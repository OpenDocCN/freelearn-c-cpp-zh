<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer084">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 class="chapterTitle" id="_idParaDest-259"><span class="koboSpan" id="kobo.2.1">Standard Library Containers, Algorithms, and Iterators</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">The C++ standard library has evolved a lot with C++11/14/17/20, and now C++23. </span><span class="koboSpan" id="kobo.3.2">However, at its core still sit three main pillars: containers, algorithms, and iterators. </span><span class="koboSpan" id="kobo.3.3">They are all implemented as generic types and general-purpose function templates. </span><span class="koboSpan" id="kobo.3.4">In this chapter, we’ll look at how they can be employed together to achieve various goals.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">We will cover the following recipes in this chapter:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.6.1">vector</span></code><span class="koboSpan" id="kobo.7.1"> as a default container</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.9.1">bitset</span></code><span class="koboSpan" id="kobo.10.1"> for fixed-size sequences of bits</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.12.1">vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.13.1"> for variable-size sequences of bits</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Using the bit manipulation utilities</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Finding elements in a range</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Sorting a range</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Initializing a range</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Using set operations on a range</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Using iterators to insert new elements into a container</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Writing your own random-access iterator</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Container access with non-member functions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Selecting the right standard containers</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.23.1">We’ll begin this chapter by exploring the functionalities of the de facto default container in C++, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.24.1">std::vector</span></code><span class="koboSpan" id="kobo.25.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-260"><span class="koboSpan" id="kobo.26.1">Using vector as a default container</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.27.1">The </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.28.1">standard library provides various types of containers that store collections of objects; the library includes sequence containers (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.29.1">vector</span></code><span class="koboSpan" id="kobo.30.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.31.1">array</span></code><span class="koboSpan" id="kobo.32.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">list</span></code><span class="koboSpan" id="kobo.34.1">), ordered and unordered associative containers (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.35.1">set</span></code><span class="koboSpan" id="kobo.36.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">map</span></code><span class="koboSpan" id="kobo.38.1">), and container adapters that do not store data but provide an adapted interface toward a sequence container (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">stack</span></code><span class="koboSpan" id="kobo.40.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">queue</span></code><span class="koboSpan" id="kobo.42.1">). </span><span class="koboSpan" id="kobo.42.2">All of them are implemented as class templates, which means they can be used with any type (providing it meets the container requirements). </span><span class="koboSpan" id="kobo.42.3">In general, you should always use the container that is the most appropriate for a particular problem, which not only provides good performance in terms of speed of inserts, deletes, access to elements, and memory usage but also makes the code easy to read and maintain. </span><span class="koboSpan" id="kobo.42.4">However, the default choice should be </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">vector</span></code><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">In this recipe, we will see why </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">vector</span></code><span class="koboSpan" id="kobo.46.1"> should be the preferred choice for a container in many cases and what the most common operations with </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">vector</span></code><span class="koboSpan" id="kobo.48.1"> are.</span></p>
<h2 class="heading-2" id="_idParaDest-261"><span class="koboSpan" id="kobo.49.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.50.1">For this recipe, you must be familiar with arrays, both statically and dynamically allocated. </span><span class="koboSpan" id="kobo.50.2">A couple of examples are provided here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.51.1">double</span></span><span class="koboSpan" id="kobo.52.1"> d[</span><span class="hljs-number"><span class="koboSpan" id="kobo.53.1">3</span></span><span class="koboSpan" id="kobo.54.1">];           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.55.1">// a statically allocated array of 3 doubles</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.56.1">int</span></span><span class="koboSpan" id="kobo.57.1">* arr = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.58.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.59.1">int</span></span><span class="koboSpan" id="kobo.60.1">[</span><span class="hljs-number"><span class="koboSpan" id="kobo.61.1">5</span></span><span class="koboSpan" id="kobo.62.1">]; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.63.1">// a dynamically allocated array of 5 ints</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.64.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.65.1">vector</span></code><span class="koboSpan" id="kobo.66.1"> class template is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">std</span></code><span class="koboSpan" id="kobo.68.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.69.1">&lt;vector&gt;</span></code><span class="koboSpan" id="kobo.70.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-262"><span class="koboSpan" id="kobo.71.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.72.1">To initialize an </span><code class="inlineCode"><span class="koboSpan" id="kobo.73.1">std::vector</span></code><span class="koboSpan" id="kobo.74.1"> class template, you can use any of the following methods, but you are not restricted to only these:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.75.1">Initialize from an initialization list:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.76.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.77.1">int</span></span><span class="koboSpan" id="kobo.78.1">&gt; v1 { </span><span class="hljs-number"><span class="koboSpan" id="kobo.79.1">1</span></span><span class="koboSpan" id="kobo.80.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.81.1">2</span></span><span class="koboSpan" id="kobo.82.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.83.1">3</span></span><span class="koboSpan" id="kobo.84.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.85.1">4</span></span><span class="koboSpan" id="kobo.86.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.87.1">5</span></span><span class="koboSpan" id="kobo.88.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.89.1">Initialize from an array:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.90.1">int</span></span><span class="koboSpan" id="kobo.91.1"> arr[] = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.92.1">1</span></span><span class="koboSpan" id="kobo.93.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.94.1">2</span></span><span class="koboSpan" id="kobo.95.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.96.1">3</span></span><span class="koboSpan" id="kobo.97.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.98.1">4</span></span><span class="koboSpan" id="kobo.99.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.100.1">5</span></span><span class="koboSpan" id="kobo.101.1"> };
</span><span class="hljs-function"><span class="koboSpan" id="kobo.102.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.103.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.104.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.105.1">v21</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.106.1">(arr, arr + </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.107.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.108.1">)</span></span><span class="koboSpan" id="kobo.109.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.110.1">// v21 = { 1, 2, 3, 4, 5 }</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.111.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.112.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.113.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.114.1">v22</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.115.1">(arr+</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.116.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.117.1">, arr+</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.118.1">4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.119.1">)</span></span><span class="koboSpan" id="kobo.120.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.121.1">// v22 = { 2, 3, 4 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.122.1">Initialize from another container:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.123.1">std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.124.1">int</span></span><span class="koboSpan" id="kobo.125.1">&gt; l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.126.1">1</span></span><span class="koboSpan" id="kobo.127.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.128.1">2</span></span><span class="koboSpan" id="kobo.129.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.130.1">3</span></span><span class="koboSpan" id="kobo.131.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.132.1">4</span></span><span class="koboSpan" id="kobo.133.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.134.1">5</span></span><span class="koboSpan" id="kobo.135.1"> };
</span><span class="hljs-function"><span class="koboSpan" id="kobo.136.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.137.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.138.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.139.1">v3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.140.1">(l.begin(), l.end())</span></span><span class="koboSpan" id="kobo.141.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.142.1">//{ 1, 2, 3, 4, 5 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.143.1">Initialize from a count and a value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.144.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.145.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.146.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.147.1">v4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.148.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.149.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.150.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.151.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.152.1">)</span></span><span class="koboSpan" id="kobo.153.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.154.1">// {1, 1, 1, 1, 1}</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.155.1">To </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.156.1">modify the content of </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">std::vector</span></code><span class="koboSpan" id="kobo.158.1">, you can use any of the following methods (as above, you’re not restricted to just these):</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.159.1">Add an element at the end of the vector with </span><code class="inlineCode"><span class="koboSpan" id="kobo.160.1">push_back()</span></code><span class="koboSpan" id="kobo.161.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.162.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.163.1">int</span></span><span class="koboSpan" id="kobo.164.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.165.1">1</span></span><span class="koboSpan" id="kobo.166.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.167.1">2</span></span><span class="koboSpan" id="kobo.168.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.169.1">3</span></span><span class="koboSpan" id="kobo.170.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.171.1">4</span></span><span class="koboSpan" id="kobo.172.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.173.1">5</span></span><span class="koboSpan" id="kobo.174.1"> };
v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.175.1">push_back</span></span><span class="koboSpan" id="kobo.176.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.177.1">6</span></span><span class="koboSpan" id="kobo.178.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.179.1">// v1 = { 1, 2, 3, 4, 5, 6 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.180.1">Remove an element from the end of the vector with </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">pop_back()</span></code><span class="koboSpan" id="kobo.182.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.183.1">v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.184.1">pop_back</span></span><span class="koboSpan" id="kobo.185.1">();   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.186.1">// v1 = { 1, 2, 3, 4, 5 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.187.1">Insert anywhere in the vector with </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">insert()</span></code><span class="koboSpan" id="kobo.189.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.190.1">int</span></span><span class="koboSpan" id="kobo.191.1"> arr[] = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.192.1">1</span></span><span class="koboSpan" id="kobo.193.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.194.1">2</span></span><span class="koboSpan" id="kobo.195.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.196.1">3</span></span><span class="koboSpan" id="kobo.197.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.198.1">4</span></span><span class="koboSpan" id="kobo.199.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.200.1">5</span></span><span class="koboSpan" id="kobo.201.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.202.1">int</span></span><span class="koboSpan" id="kobo.203.1">&gt; v21;
v21.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.204.1">insert</span></span><span class="koboSpan" id="kobo.205.1">(v21.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.206.1">begin</span></span><span class="koboSpan" id="kobo.207.1">(), arr, arr + </span><span class="hljs-number"><span class="koboSpan" id="kobo.208.1">5</span></span><span class="koboSpan" id="kobo.209.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.210.1">// v21 = { 1, 2, 3, 4, 5 }</span></span><span class="koboSpan" id="kobo.211.1">
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.212.1">int</span></span><span class="koboSpan" id="kobo.213.1">&gt; v22;
v22.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.214.1">insert</span></span><span class="koboSpan" id="kobo.215.1">(v22.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.216.1">begin</span></span><span class="koboSpan" id="kobo.217.1">(), arr, arr + </span><span class="hljs-number"><span class="koboSpan" id="kobo.218.1">3</span></span><span class="koboSpan" id="kobo.219.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.220.1">// v22 = { 1, 2, 3 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.221.1">Add an element by creating it at the end of the vector with </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">emplace_back()</span></code><span class="koboSpan" id="kobo.223.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.225.1">foo</span></span><span class="koboSpan" id="kobo.226.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.227.1">int</span></span><span class="koboSpan" id="kobo.228.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.229.1">double</span></span><span class="koboSpan" id="kobo.230.1"> b;
  std::string c;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.231.1">foo</span></span><span class="koboSpan" id="kobo.232.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.233.1">int</span></span><span class="koboSpan" id="kobo.234.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.235.1">double</span></span><span class="koboSpan" id="kobo.236.1"> b, std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.237.1">const</span></span><span class="koboSpan" id="kobo.238.1"> &amp; c) :
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.239.1">a</span></span><span class="koboSpan" id="kobo.240.1">(a), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.241.1">b</span></span><span class="koboSpan" id="kobo.242.1">(b), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.243.1">c</span></span><span class="koboSpan" id="kobo.244.1">(c) {}
};
std::vector&lt;foo&gt; v3;
v3.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.245.1">emplace_back</span></span><span class="koboSpan" id="kobo.246.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.247.1">1</span></span><span class="koboSpan" id="kobo.248.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.249.1">1.0</span></span><span class="koboSpan" id="kobo.250.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.251.1">"one"</span></span><span class="koboSpan" id="kobo.252.1">s);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.253.1">// v3 = { foo{1, 1.0, "one"} }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.254.1">Insert an element by creating it anywhere in the vector with </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">emplace()</span></code><span class="koboSpan" id="kobo.256.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.257.1">v3.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.258.1">emplace</span></span><span class="koboSpan" id="kobo.259.1">(v3.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.260.1">begin</span></span><span class="koboSpan" id="kobo.261.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.262.1">2</span></span><span class="koboSpan" id="kobo.263.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.264.1">2.0</span></span><span class="koboSpan" id="kobo.265.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.266.1">"two"</span></span><span class="koboSpan" id="kobo.267.1">s);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.268.1">// v3 = { foo{2, 2.0, "two"}, foo{1, 1.0, "one"} }</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.269.1">To</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.270.1"> modify the whole content of the vector, you can use any of the following methods, although you’re not restricted to just these:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.271.1">Assign from another vector with </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">operator=</span></code><span class="koboSpan" id="kobo.273.1">; this replaces the content of the container:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.274.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.275.1">int</span></span><span class="koboSpan" id="kobo.276.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.277.1">1</span></span><span class="koboSpan" id="kobo.278.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.279.1">2</span></span><span class="koboSpan" id="kobo.280.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.281.1">3</span></span><span class="koboSpan" id="kobo.282.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.283.1">4</span></span><span class="koboSpan" id="kobo.284.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.285.1">5</span></span><span class="koboSpan" id="kobo.286.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.287.1">int</span></span><span class="koboSpan" id="kobo.288.1">&gt; v2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.289.1">10</span></span><span class="koboSpan" id="kobo.290.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.291.1">20</span></span><span class="koboSpan" id="kobo.292.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.293.1">30</span></span><span class="koboSpan" id="kobo.294.1"> };
v2 = v1; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.295.1">// v2 = { 1, 2, 3, 4, 5 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.296.1">Assign from another sequence defined by a begin and end iterator with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">assign()</span></code><span class="koboSpan" id="kobo.298.1"> method; this replaces the content of the container:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.299.1">int</span></span><span class="koboSpan" id="kobo.300.1"> arr[] = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.301.1">1</span></span><span class="koboSpan" id="kobo.302.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.303.1">2</span></span><span class="koboSpan" id="kobo.304.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.305.1">3</span></span><span class="koboSpan" id="kobo.306.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.307.1">4</span></span><span class="koboSpan" id="kobo.308.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.309.1">5</span></span><span class="koboSpan" id="kobo.310.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.311.1">int</span></span><span class="koboSpan" id="kobo.312.1">&gt; v31;
v31.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.313.1">assign</span></span><span class="koboSpan" id="kobo.314.1">(arr, arr + </span><span class="hljs-number"><span class="koboSpan" id="kobo.315.1">5</span></span><span class="koboSpan" id="kobo.316.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.317.1">// v31 = { 1, 2, 3, 4, 5 }</span></span><span class="koboSpan" id="kobo.318.1">
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.319.1">int</span></span><span class="koboSpan" id="kobo.320.1">&gt; v32;
v32.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.321.1">assign</span></span><span class="koboSpan" id="kobo.322.1">(arr + </span><span class="hljs-number"><span class="koboSpan" id="kobo.323.1">1</span></span><span class="koboSpan" id="kobo.324.1">, arr + </span><span class="hljs-number"><span class="koboSpan" id="kobo.325.1">4</span></span><span class="koboSpan" id="kobo.326.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.327.1">// v32 = { 2, 3, 4 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="hljs-function"><span class="koboSpan" id="kobo.328.1">Swap the content of two vectors with the </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">swap()</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.330.1"> method:</span></span>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.331.1">std::vector&lt;int&gt; v4{</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.332.1">1</span></span><span class="koboSpan" id="kobo.333.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.334.1">2</span></span><span class="koboSpan" id="kobo.335.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.336.1">3</span></span><span class="koboSpan" id="kobo.337.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.338.1">4</span></span><span class="koboSpan" id="kobo.339.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.340.1">5</span></span><span class="koboSpan" id="kobo.341.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.342.1">int</span></span><span class="koboSpan" id="kobo.343.1">&gt; v5{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.344.1">10</span></span><span class="koboSpan" id="kobo.345.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.346.1">20</span></span><span class="koboSpan" id="kobo.347.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.348.1">30</span></span><span class="koboSpan" id="kobo.349.1"> };
v4.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.350.1">swap</span></span><span class="koboSpan" id="kobo.351.1">(v5); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.352.1">// v4 = { 10, 20, 30 }, v5 = { 1, 2, 3, 4, 5 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.353.1">Remove all the elements with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">clear()</span></code><span class="koboSpan" id="kobo.355.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.356.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.357.1">int</span></span><span class="koboSpan" id="kobo.358.1">&gt; v6{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.359.1">1</span></span><span class="koboSpan" id="kobo.360.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.361.1">2</span></span><span class="koboSpan" id="kobo.362.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.363.1">3</span></span><span class="koboSpan" id="kobo.364.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.365.1">4</span></span><span class="koboSpan" id="kobo.366.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.367.1">5</span></span><span class="koboSpan" id="kobo.368.1"> };
v6.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.369.1">clear</span></span><span class="koboSpan" id="kobo.370.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.371.1">// v6 = { }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.372.1">Remove one or more elements with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">erase()</span></code><span class="koboSpan" id="kobo.374.1"> method (which requires either an iterator or a pair of iterators that define the range of elements from the vector to be removed):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.375.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.376.1">int</span></span><span class="koboSpan" id="kobo.377.1">&gt; v7{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.378.1">1</span></span><span class="koboSpan" id="kobo.379.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.380.1">2</span></span><span class="koboSpan" id="kobo.381.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.382.1">3</span></span><span class="koboSpan" id="kobo.383.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.384.1">4</span></span><span class="koboSpan" id="kobo.385.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.386.1">5</span></span><span class="koboSpan" id="kobo.387.1"> };
v7.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.388.1">erase</span></span><span class="koboSpan" id="kobo.389.1">(v7.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.390.1">begin</span></span><span class="koboSpan" id="kobo.391.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.392.1">2</span></span><span class="koboSpan" id="kobo.393.1">, v7.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.394.1">begin</span></span><span class="koboSpan" id="kobo.395.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.396.1">4</span></span><span class="koboSpan" id="kobo.397.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.398.1">// v7 = { 1, 2, 5 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.399.1">Remove one or more elements that satisfy a predicate with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">std::remove_if()</span></code><span class="koboSpan" id="kobo.401.1"> function and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">erase()</span></code><span class="koboSpan" id="kobo.403.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.404.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.405.1">int</span></span><span class="koboSpan" id="kobo.406.1">&gt; v8{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.407.1">1</span></span><span class="koboSpan" id="kobo.408.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.409.1">2</span></span><span class="koboSpan" id="kobo.410.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.411.1">3</span></span><span class="koboSpan" id="kobo.412.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.413.1">4</span></span><span class="koboSpan" id="kobo.414.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.415.1">5</span></span><span class="koboSpan" id="kobo.416.1"> };
auto iterToNext = v8.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.417.1">erase</span></span><span class="koboSpan" id="kobo.418.1">(
   std::remove_if(v8.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.419.1">begin</span></span><span class="koboSpan" id="kobo.420.1">(), v8.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.421.1">end</span></span><span class="koboSpan" id="kobo.422.1">(), 
      [](const </span><span class="hljs-type"><span class="koboSpan" id="kobo.423.1">int</span></span><span class="koboSpan" id="kobo.424.1"> n) {return n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.425.1">2</span></span><span class="koboSpan" id="kobo.426.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.427.1">0</span></span><span class="koboSpan" id="kobo.428.1">; }),
   v8.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.429.1">end</span></span><span class="koboSpan" id="kobo.430.1">());                            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.431.1">// v8 = { 1, 3, 5 }</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.432.1">Remove one or more elements that satisfy a predicate with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.433.1">std::erase_if()</span></code><span class="koboSpan" id="kobo.434.1"> function, introduced in C++20. </span><span class="koboSpan" id="kobo.434.2">A similar </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">std::erase()</span></code><span class="koboSpan" id="kobo.436.1"> function also exists:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.437.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.438.1">int</span></span><span class="koboSpan" id="kobo.439.1">&gt; v9{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.440.1">1</span></span><span class="koboSpan" id="kobo.441.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.442.1">2</span></span><span class="koboSpan" id="kobo.443.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.444.1">3</span></span><span class="koboSpan" id="kobo.445.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.446.1">4</span></span><span class="koboSpan" id="kobo.447.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.448.1">5</span></span><span class="koboSpan" id="kobo.449.1"> };
auto erasedCount = std::erase_if(v9, [](const </span><span class="hljs-type"><span class="koboSpan" id="kobo.450.1">int</span></span><span class="koboSpan" id="kobo.451.1"> n) {
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.452.1">return</span></span><span class="koboSpan" id="kobo.453.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.454.1">2</span></span><span class="koboSpan" id="kobo.455.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.456.1">0</span></span><span class="koboSpan" id="kobo.457.1">; });                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.458.1">// v9 = { 1, 3, 5 }</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.459.1">To get </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.460.1">the address of the first element in a vector, usually to pass the content of a vector to a C-like API, use any of the following methods:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.461.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">data()</span></code><span class="koboSpan" id="kobo.463.1"> method, which returns a pointer to the first element, providing direct access to the underlying contiguous sequence of memory where the vector elements are stored; this is only available since C++11:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.464.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.465.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.466.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.467.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.468.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.469.1"> * </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.470.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.471.1"> arr, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.472.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.473.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.474.1"> size)</span></span><span class="koboSpan" id="kobo.475.1">
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.476.1">/* do something */</span></span><span class="koboSpan" id="kobo.477.1"> }
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.478.1">int</span></span><span class="koboSpan" id="kobo.479.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.480.1">1</span></span><span class="koboSpan" id="kobo.481.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.482.1">2</span></span><span class="koboSpan" id="kobo.483.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.484.1">3</span></span><span class="koboSpan" id="kobo.485.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.486.1">4</span></span><span class="koboSpan" id="kobo.487.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.488.1">5</span></span><span class="koboSpan" id="kobo.489.1"> };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.490.1">process</span></span><span class="koboSpan" id="kobo.491.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.492.1">data</span></span><span class="koboSpan" id="kobo.493.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.494.1">size</span></span><span class="koboSpan" id="kobo.495.1">());
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.496.1">Get the address of the first element:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.497.1">process</span></span><span class="koboSpan" id="kobo.498.1">(&amp;v[</span><span class="hljs-number"><span class="koboSpan" id="kobo.499.1">0</span></span><span class="koboSpan" id="kobo.500.1">], v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.501.1">size</span></span><span class="koboSpan" id="kobo.502.1">());
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.503.1">Get the address of the element referred to by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">front()</span></code><span class="koboSpan" id="kobo.505.1"> method (calling this method on an empty vector is undefined behavior):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.506.1">process</span></span><span class="koboSpan" id="kobo.507.1">(&amp;v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.508.1">front</span></span><span class="koboSpan" id="kobo.509.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.510.1">size</span></span><span class="koboSpan" id="kobo.511.1">());
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.512.1">Get the address of the element pointed by the iterator returned from </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">begin()</span></code><span class="koboSpan" id="kobo.514.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.515.1">process</span></span><span class="koboSpan" id="kobo.516.1">(&amp;*v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.517.1">begin</span></span><span class="koboSpan" id="kobo.518.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.519.1">size</span></span><span class="koboSpan" id="kobo.520.1">());
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.521.1">To </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.522.1">modify the content of a vector, in C++23, you can also use the following range-aware member functions:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.523.1">To replace the elements of a vector with a copy of the elements of a given range, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">assign_range()</span></code><span class="koboSpan" id="kobo.525.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.526.1">std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.527.1">int</span></span><span class="koboSpan" id="kobo.528.1">&gt;   l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.529.1">1</span></span><span class="koboSpan" id="kobo.530.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.531.1">2</span></span><span class="koboSpan" id="kobo.532.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.533.1">3</span></span><span class="koboSpan" id="kobo.534.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.535.1">4</span></span><span class="koboSpan" id="kobo.536.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.537.1">5</span></span><span class="koboSpan" id="kobo.538.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.539.1">int</span></span><span class="koboSpan" id="kobo.540.1">&gt; v;
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.541.1">assign_range</span></span><span class="koboSpan" id="kobo.542.1">(l); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.543.1">// v = {1, 2, 3, 4, 5}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.544.1">To append copies of the elements of a range at the end of a vector (before the end iterator), use </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">append_range()</span></code><span class="koboSpan" id="kobo.546.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.547.1">std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.548.1">int</span></span><span class="koboSpan" id="kobo.549.1">&gt;   l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.550.1">3</span></span><span class="koboSpan" id="kobo.551.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.552.1">4</span></span><span class="koboSpan" id="kobo.553.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.554.1">5</span></span><span class="koboSpan" id="kobo.555.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.556.1">int</span></span><span class="koboSpan" id="kobo.557.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.558.1">1</span></span><span class="koboSpan" id="kobo.559.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.560.1">2</span></span><span class="koboSpan" id="kobo.561.1"> };
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.562.1">append_range</span></span><span class="koboSpan" id="kobo.563.1">(l);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.564.1">// v = {1, 2, 3, 4, 5}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.565.1">To insert copies of the elements of a range before a given iterator of a vector, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">insert_range()</span></code><span class="koboSpan" id="kobo.567.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.568.1">std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.569.1">int</span></span><span class="koboSpan" id="kobo.570.1">&gt;   l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.571.1">2</span></span><span class="koboSpan" id="kobo.572.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.573.1">3</span></span><span class="koboSpan" id="kobo.574.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.575.1">4</span></span><span class="koboSpan" id="kobo.576.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.577.1">int</span></span><span class="koboSpan" id="kobo.578.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.579.1">1</span></span><span class="koboSpan" id="kobo.580.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.581.1">5</span></span><span class="koboSpan" id="kobo.582.1"> };
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.583.1">insert_range</span></span><span class="koboSpan" id="kobo.584.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.585.1">begin</span></span><span class="koboSpan" id="kobo.586.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.587.1">1</span></span><span class="koboSpan" id="kobo.588.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.589.1">l</span></span><span class="koboSpan" id="kobo.590.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.591.1">// v = {1, 2, 3, 4, 5}</span></span>
</code></pre>
<h2 class="heading-2" id="_idParaDest-263"><span class="koboSpan" id="kobo.592.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.593.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.594.1">std::vector</span></code><span class="koboSpan" id="kobo.595.1"> class is designed to be the C++ container most similar to and inter-operable with arrays. </span><span class="koboSpan" id="kobo.595.2">A vector is a variable-sized sequence of elements, guaranteed to be stored contiguously in memory, which makes the content of a vector easily passable to a C-like function that takes a pointer to an element of an array and, usually, a size. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.596.1">There are many benefits of using a vector instead of arrays, and these benefits include:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.597.1">No direct memory management is required from the developer as the container does this internally, allocating memory, reallocating it, and releasing it.
    </span><div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.598.1">Note that a vector is intended for storing object instances. </span><span class="koboSpan" id="kobo.598.2">If you need to store pointers, do not store raw pointers but smart pointers. </span><span class="koboSpan" id="kobo.598.3">Otherwise, you need to handle the lifetime management of the pointed objects.</span></p>
</div></li>
</ul>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.599.1">The possibility of modifying the size of the vector.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.600.1">Simple assignment or concatenation of two vectors.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.601.1">Direct comparison of two vectors.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.602.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.603.1">vector</span></code><span class="koboSpan" id="kobo.604.1"> class is </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.605.1">a very efficient container, with all its implementations providing a lot of optimizations that most developers are not capable of doing with arrays. </span><span class="koboSpan" id="kobo.605.2">Random access to its elements and insertion and removal at the end of a vector is a constant </span><em class="italic"><span class="koboSpan" id="kobo.606.1">O(1)</span></em><span class="koboSpan" id="kobo.607.1"> operation (provided that reallocation is not necessary), while insertion and removal anywhere else is a linear </span><em class="italic"><span class="koboSpan" id="kobo.608.1">O(n)</span></em><span class="koboSpan" id="kobo.609.1"> operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.610.1">Compared to other standard containers, the vector has various benefits:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.611.1">It is compatible with arrays and C-like APIs. </span><span class="koboSpan" id="kobo.611.2">If a function takes an array as a parameter, the content of other containers (except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">std::array</span></code><span class="koboSpan" id="kobo.613.1">) needs to be copied to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">vector</span></code><span class="koboSpan" id="kobo.615.1"> before being passed as an argument to the function.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.616.1">It has the fastest access to elements of all containers (but the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.617.1">std::array</span></code><span class="koboSpan" id="kobo.618.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.619.1">It has no per-element memory overhead for storing elements. </span><span class="koboSpan" id="kobo.619.2">This is because elements are stored in a contiguous space, like arrays are. </span><span class="koboSpan" id="kobo.619.3">Therefore, </span><code class="inlineCode"><span class="koboSpan" id="kobo.620.1">vector</span></code><span class="koboSpan" id="kobo.621.1"> has a small memory footprint, unlike other containers, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.622.1">list</span></code><span class="koboSpan" id="kobo.623.1">, which require additional pointers to other elements, or associative containers, which require hash values.</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">std::vector</span></code><span class="koboSpan" id="kobo.625.1"> is very similar in semantics to arrays but has a variable size. </span><span class="koboSpan" id="kobo.625.2">The size of a vector can increase and decrease. </span><span class="koboSpan" id="kobo.625.3">There are two properties that define the size of a vector:</span></p>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.626.1">Capacity</span></em><span class="koboSpan" id="kobo.627.1"> is the number of elements the vector can accommodate without performing additional memory allocations; this is indicated by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">capacity()</span></code><span class="koboSpan" id="kobo.629.1"> method.</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.630.1">Size</span></em><span class="koboSpan" id="kobo.631.1"> is the actual number of elements in the vector; this is indicated by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.632.1">size()</span></code><span class="koboSpan" id="kobo.633.1"> method.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.634.1">Size is always smaller than or equal to capacity. </span><span class="koboSpan" id="kobo.634.2">When size is equal to capacity and a new element needs to be added, the capacity needs to be modified so that the vector has space for more elements. </span><span class="koboSpan" id="kobo.634.3">In this case, the vector allocates a new chunk of memory and moves the previous content to the new location before freeing the previously allocated memory. </span><span class="koboSpan" id="kobo.634.4">Though this sounds time-consuming—and it is—implementations increase the capacity exponentially by doubling it each time it needs to be changed. </span><span class="koboSpan" id="kobo.634.5">As a result, on average, each element of the vector only needs to be moved once (that is because all the elements of the vector are moved during an increase of capacity, but then an equal number of elements can be added without incurring more moves, given that insertions are performed at the end of the vector).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.635.1">If you know </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.636.1">beforehand how many elements will be inserted in the vector, you can first call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">reserve()</span></code><span class="koboSpan" id="kobo.638.1"> method to increase the capacity to at least the specified amount (this method does nothing if the specified size is smaller than the current capacity) and only then insert the elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.639.1">On the other hand, if you need to free additional reserved memory, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">shrink_to_fit()</span></code><span class="koboSpan" id="kobo.641.1"> method to request this, but it is an implementation decision as to whether to free any memory or not. </span><span class="koboSpan" id="kobo.641.2">An alternative to this non-binding method, available since C++11, is to do a swap with a temporary, empty vector:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.642.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.643.1">int</span></span><span class="koboSpan" id="kobo.644.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.645.1">1</span></span><span class="koboSpan" id="kobo.646.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.647.1">2</span></span><span class="koboSpan" id="kobo.648.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.649.1">3</span></span><span class="koboSpan" id="kobo.650.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.651.1">4</span></span><span class="koboSpan" id="kobo.652.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.653.1">5</span></span><span class="koboSpan" id="kobo.654.1"> };
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.655.1">vector</span></span><span class="koboSpan" id="kobo.656.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.657.1">int</span></span><span class="koboSpan" id="kobo.658.1">&gt;().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.659.1">swap</span></span><span class="koboSpan" id="kobo.660.1">(v); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.661.1">// v.size = 0, v.capacity = 0</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.662.1">Calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">clear()</span></code><span class="koboSpan" id="kobo.664.1"> method only removes all the elements from the vector but does not free any memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.665.1">It should be noted that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">vector</span></code><span class="koboSpan" id="kobo.667.1"> class implements some operations that are specific to other types of containers:</span></p>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.668.1">stack</span></em><span class="koboSpan" id="kobo.669.1">: With </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">push_back()</span></code><span class="koboSpan" id="kobo.671.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">emplace_back()</span></code><span class="koboSpan" id="kobo.673.1"> to add at the end and </span><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">pop_back()</span></code><span class="koboSpan" id="kobo.675.1"> to remove from the end. </span><span class="koboSpan" id="kobo.675.2">Keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">pop_back()</span></code><span class="koboSpan" id="kobo.677.1"> does not return the last element that has been removed. </span><span class="koboSpan" id="kobo.677.2">You need to access that explicitly, if that is necessary, for instance, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">back()</span></code><span class="koboSpan" id="kobo.679.1"> method before removing the element.</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.680.1">list</span></em><span class="koboSpan" id="kobo.681.1">: With </span><code class="inlineCode"><span class="koboSpan" id="kobo.682.1">insert()</span></code><span class="koboSpan" id="kobo.683.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.684.1">emplace()</span></code><span class="koboSpan" id="kobo.685.1"> to add elements in the middle of the sequence and </span><code class="inlineCode"><span class="koboSpan" id="kobo.686.1">erase()</span></code><span class="koboSpan" id="kobo.687.1"> to remove elements from anywhere in the sequence.</span></li>
</ul>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.688.1">A good rule of thumb for C++ containers is to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.689.1">std::vector</span></code><span class="koboSpan" id="kobo.690.1"> as the default container unless you have good reasons to use another one.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-264"><span class="koboSpan" id="kobo.691.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.692.1">Using bitset for fixed-size sequences of bits</span></em><span class="koboSpan" id="kobo.693.1">, to learn about the standard container for handling bit sequences of fixed sizes</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.694.1">Using vector&lt;bool&gt; for variable-size sequences of bits</span></em><span class="koboSpan" id="kobo.695.1">, to learn about the specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.696.1">std::vector</span></code><span class="koboSpan" id="kobo.697.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">bool</span></code><span class="koboSpan" id="kobo.699.1"> type, intended for handling bit sequences of variable sizes</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-265"><span class="koboSpan" id="kobo.700.1">Using bitset for fixed-size sequences of bits</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.701.1">It is not </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.702.1">uncommon for developers to operate with bit flags. </span><span class="koboSpan" id="kobo.702.2">This can be either because they work with operating system APIs (usually written in C) that take various types of arguments (such as options or styles) in the form of bit flags, or because they work with libraries that do similar things, or simply because some types of problems are naturally solved with bit flags. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.703.1">We can think of alternatives to working with bits and bit operations, such as defining arrays that have one element for every option/flag, or defining a structure with members and functions to model the bit flags, but these are often more complicated; and in cases when you need to pass a numerical value representing bit flags to a function, you still need to convert the array or the structure to a sequence of bits. </span><span class="koboSpan" id="kobo.703.2">For this reason, the C++ standard provides a container called </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">std::bitset</span></code><span class="koboSpan" id="kobo.705.1"> for fixed-size sequences of bits.</span></p>
<h2 class="heading-2" id="_idParaDest-266"><span class="koboSpan" id="kobo.706.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.707.1">For this recipe, you must be familiar with bitwise operations (AND, OR, XOR, NOT, and shifting – moving each digit in a number’s binary representation to the left or right). </span><span class="koboSpan" id="kobo.707.2">If you need to learn more about these, </span><a href="https://en.wikipedia.org/wiki/Bitwise_operation"><span class="url"><span class="koboSpan" id="kobo.708.1">https://en.wikipedia.org/wiki/Bitwise_operation</span></span></a><span class="koboSpan" id="kobo.709.1"> is a good starting point.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.710.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">bitset</span></code><span class="koboSpan" id="kobo.712.1"> class is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">std</span></code><span class="koboSpan" id="kobo.714.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">&lt;bitset&gt;</span></code><span class="koboSpan" id="kobo.716.1"> header. </span><span class="koboSpan" id="kobo.716.2">A bitset represents a fixed-size sequence of bits, with the size defined at compile time. </span><span class="koboSpan" id="kobo.716.3">For convenience, in this recipe, most examples will be with bitsets of 8 bits.</span></p>
<h2 class="heading-2" id="_idParaDest-267"><span class="koboSpan" id="kobo.717.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.718.1">To construct an </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">std::bitset</span></code><span class="koboSpan" id="kobo.720.1"> object, use one of the available constructors:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.721.1">An empty bitset with all bits set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">0</span></code><span class="koboSpan" id="kobo.723.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.724.1">std::bitset&lt;8&gt; b1;            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.725.1">// [0,0,0,0,0,0,0,0]</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.726.1">A bitset from a numerical value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.727.1">std::bitset&lt;8&gt; b2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.728.1">10</span></span><span class="koboSpan" id="kobo.729.1"> };      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.730.1">// [0,0,0,0,1,0,1,0]</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.731.1">A bitset from a string of </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">'0'</span></code><span class="koboSpan" id="kobo.733.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">'</span></code><code class="inlineCode"><span class="koboSpan" id="kobo.735.1">1'</span></code><span class="koboSpan" id="kobo.736.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.737.1">std::bitset&lt;8&gt; b3{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.738.1">"1010"</span></span><span class="koboSpan" id="kobo.739.1">s }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.740.1">// [0,0,0,0,1,0,1,0]</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.741.1">A bitset from a string containing any two characters representing </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">'0'</span></code><span class="koboSpan" id="kobo.743.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">'1'</span></code><span class="koboSpan" id="kobo.745.1">; in this case, we must specify which character represents a </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">0</span></code><span class="koboSpan" id="kobo.747.1"> (the fourth parameter, </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">'o'</span></code><span class="koboSpan" id="kobo.749.1">) and which character represents a </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">1</span></code><span class="koboSpan" id="kobo.751.1"> (the fifth parameter, </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">'x'</span></code><span class="koboSpan" id="kobo.753.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.754.1">std::bitset&lt;8&gt; b4
  { </span><span class="hljs-string"><span class="koboSpan" id="kobo.755.1">"ooooxoxo"</span></span><span class="koboSpan" id="kobo.756.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.757.1">0</span></span><span class="koboSpan" id="kobo.758.1">, std::string::npos, </span><span class="hljs-string"><span class="koboSpan" id="kobo.759.1">'o'</span></span><span class="koboSpan" id="kobo.760.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.761.1">'x'</span></span><span class="koboSpan" id="kobo.762.1"> };
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.763.1">// [0,0,0,0,1,0,1,0]</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.764.1">To test</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.765.1"> individual bits in the set or the entire set for specific values, use any of the available methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">count()</span></code><span class="koboSpan" id="kobo.767.1"> to get the number of bits set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">1</span></code><span class="koboSpan" id="kobo.769.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.770.1">std::bitset&lt;8&gt; bs{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.771.1">10</span></span><span class="koboSpan" id="kobo.772.1"> };
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.773.1">"has "</span></span><span class="koboSpan" id="kobo.774.1"> &lt;&lt; bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.775.1">count</span></span><span class="koboSpan" id="kobo.776.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.777.1">" 1s"</span></span><span class="koboSpan" id="kobo.778.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.779.1">'\n'</span></span><span class="koboSpan" id="kobo.780.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">any()</span></code><span class="koboSpan" id="kobo.782.1"> to check whether there is at least one bit set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.783.1">1</span></code><span class="koboSpan" id="kobo.784.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.785.1">if</span></span><span class="koboSpan" id="kobo.786.1"> (bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.787.1">any</span></span><span class="koboSpan" id="kobo.788.1">()) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.789.1">"has some 1s"</span></span><span class="koboSpan" id="kobo.790.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.791.1">'\n'</span></span><span class="koboSpan" id="kobo.792.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.793.1">all()</span></code><span class="koboSpan" id="kobo.794.1"> to check whether all the bits are set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.795.1">1</span></code><span class="koboSpan" id="kobo.796.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.797.1">if</span></span><span class="koboSpan" id="kobo.798.1"> (bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.799.1">all</span></span><span class="koboSpan" id="kobo.800.1">()) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.801.1">"has only 1s"</span></span><span class="koboSpan" id="kobo.802.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.803.1">'\n'</span></span><span class="koboSpan" id="kobo.804.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">none()</span></code><span class="koboSpan" id="kobo.806.1"> to check whether all the bits are set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">0</span></code><span class="koboSpan" id="kobo.808.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.809.1">if</span></span><span class="koboSpan" id="kobo.810.1"> (bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.811.1">none</span></span><span class="koboSpan" id="kobo.812.1">()) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.813.1">"has no 1s"</span></span><span class="koboSpan" id="kobo.814.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.815.1">'\n'</span></span><span class="koboSpan" id="kobo.816.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.817.1">test()</span></code><span class="koboSpan" id="kobo.818.1"> to check the value of an individual bit (whose position is the only argument to the function):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.819.1">if</span></span><span class="koboSpan" id="kobo.820.1"> (!bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.821.1">test</span></span><span class="koboSpan" id="kobo.822.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.823.1">0</span></span><span class="koboSpan" id="kobo.824.1">)) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.825.1">"even"</span></span><span class="koboSpan" id="kobo.826.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.827.1">'\n'</span></span><span class="koboSpan" id="kobo.828.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.829.1">operator[]</span></code><span class="koboSpan" id="kobo.830.1"> to access and test individual bits:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.831.1">if</span></span><span class="koboSpan" id="kobo.832.1">(!bs[</span><span class="hljs-number"><span class="koboSpan" id="kobo.833.1">0</span></span><span class="koboSpan" id="kobo.834.1">]) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.835.1">"even"</span></span><span class="koboSpan" id="kobo.836.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.837.1">'\n'</span></span><span class="koboSpan" id="kobo.838.1">;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.839.1">To modify</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.840.1"> the content of a bitset, use any of the following methods:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.841.1">Member operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.842.1">|=</span></code><span class="koboSpan" id="kobo.843.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.844.1">&amp;=</span></code><span class="koboSpan" id="kobo.845.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">^=</span></code><span class="koboSpan" id="kobo.847.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">~</span></code><span class="koboSpan" id="kobo.849.1"> to perform the binary operation OR, AND, XOR, and NOT, respectively. </span><span class="koboSpan" id="kobo.849.2">Alternatively, use the non-member operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.850.1">|</span></code><span class="koboSpan" id="kobo.851.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.852.1">&amp;</span></code><span class="koboSpan" id="kobo.853.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.854.1">^</span></code><span class="koboSpan" id="kobo.855.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.856.1">std::bitset&lt;8&gt; b1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.857.1">42</span></span><span class="koboSpan" id="kobo.858.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.859.1">// [0,0,1,0,1,0,1,0]</span></span><span class="koboSpan" id="kobo.860.1">
std::bitset&lt;8&gt; b2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.861.1">11</span></span><span class="koboSpan" id="kobo.862.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.863.1">// [0,0,0,0,1,0,1,1]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.864.1">auto</span></span><span class="koboSpan" id="kobo.865.1"> b3 = b1 | b2;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.866.1">// [0,0,1,0,1,0,1,1]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.867.1">auto</span></span><span class="koboSpan" id="kobo.868.1"> b4 = b1 &amp; b2;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.869.1">// [0,0,0,0,1,0,1,0]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.870.1">auto</span></span><span class="koboSpan" id="kobo.871.1"> b5 = b1 ^ b2;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.872.1">// [0,0,1,0,0,0,0,1]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.873.1">auto</span></span><span class="koboSpan" id="kobo.874.1"> b6 = ~b1;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.875.1">// [1,1,0,1,0,1,0,1]</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.876.1">Member operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.877.1">&lt;&lt;=</span></code><span class="koboSpan" id="kobo.878.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.879.1">&lt;&lt;</span></code><span class="koboSpan" id="kobo.880.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.881.1">&gt;&gt;=</span></code><span class="koboSpan" id="kobo.882.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.883.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.884.1"> to perform shifting operations:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.885.1">auto</span></span><span class="koboSpan" id="kobo.886.1"> b7 = b1 &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.887.1">2</span></span><span class="koboSpan" id="kobo.888.1">;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.889.1">// [1,0,1,0,1,0,0,0]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.890.1">auto</span></span><span class="koboSpan" id="kobo.891.1"> b8 = b1 &gt;&gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.892.1">2</span></span><span class="koboSpan" id="kobo.893.1">;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.894.1">// [0,0,0,0,1,0,1,0]</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">flip()</span></code><span class="koboSpan" id="kobo.896.1"> to toggle the entire set or an individual bit from </span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">0</span></code><span class="koboSpan" id="kobo.898.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">1</span></code><span class="koboSpan" id="kobo.900.1"> or from </span><code class="inlineCode"><span class="koboSpan" id="kobo.901.1">1</span></code><span class="koboSpan" id="kobo.902.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.903.1">0</span></code><span class="koboSpan" id="kobo.904.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.905.1">b1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.906.1">flip</span></span><span class="koboSpan" id="kobo.907.1">();               </span><span class="hljs-comment"><span class="koboSpan" id="kobo.908.1">// [1,1,0,1,0,1,0,1]</span></span><span class="koboSpan" id="kobo.909.1">
b1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.910.1">flip</span></span><span class="koboSpan" id="kobo.911.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.912.1">0</span></span><span class="koboSpan" id="kobo.913.1">);              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.914.1">// [1,1,0,1,0,1,0,0]</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">set()</span></code><span class="koboSpan" id="kobo.916.1"> to change the entire set or an individual bit to </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">true</span></code><span class="koboSpan" id="kobo.918.1"> or the specified value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.919.1">b1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.920.1">set</span></span><span class="koboSpan" id="kobo.921.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.922.1">0</span></span><span class="koboSpan" id="kobo.923.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.924.1">true</span></span><span class="koboSpan" id="kobo.925.1">);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.926.1">// [1,1,0,1,0,1,0,1]</span></span><span class="koboSpan" id="kobo.927.1">
b1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.928.1">set</span></span><span class="koboSpan" id="kobo.929.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.930.1">0</span></span><span class="koboSpan" id="kobo.931.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.932.1">false</span></span><span class="koboSpan" id="kobo.933.1">);        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.934.1">// [1,1,0,1,0,1,0,0]</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.935.1">reset()</span></code><span class="koboSpan" id="kobo.936.1"> to change the entire set or an individual bit to </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">false</span></code><span class="koboSpan" id="kobo.938.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.939.1">b1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.940.1">reset</span></span><span class="koboSpan" id="kobo.941.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.942.1">2</span></span><span class="koboSpan" id="kobo.943.1">);             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.944.1">// [1,1,0,1,0,0,0,0]</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.945.1">To convert a bitset to a numerical or string value, use the following methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">to_ulong()</span></code><span class="koboSpan" id="kobo.947.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">to_ullong()</span></code><span class="koboSpan" id="kobo.949.1"> to convert to </span><code class="inlineCode"><span class="koboSpan" id="kobo.950.1">unsigned long</span></code><span class="koboSpan" id="kobo.951.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.952.1">unsigned long long</span></code><span class="koboSpan" id="kobo.953.1">. </span><span class="koboSpan" id="kobo.953.2">These operations throw an </span><code class="inlineCode"><span class="koboSpan" id="kobo.954.1">std::overflow_error</span></code><span class="koboSpan" id="kobo.955.1"> exception if the value cannot be represented in the output type. </span><span class="koboSpan" id="kobo.955.2">Refer to the following examples:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.956.1">std::bitset&lt;8&gt; bs{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.957.1">42</span></span><span class="koboSpan" id="kobo.958.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.959.1">auto</span></span><span class="koboSpan" id="kobo.960.1"> n1 = bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.961.1">to_ulong</span></span><span class="koboSpan" id="kobo.962.1">();  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.963.1">// n1 = 42UL</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.964.1">auto</span></span><span class="koboSpan" id="kobo.965.1"> n2 = bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.966.1">to_ullong</span></span><span class="koboSpan" id="kobo.967.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.968.1">// n2 = 42ULL</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.969.1">to_string()</span></code><span class="koboSpan" id="kobo.970.1"> to convert to </span><code class="inlineCode"><span class="koboSpan" id="kobo.971.1">std::basic_string</span></code><span class="koboSpan" id="kobo.972.1">. </span><span class="koboSpan" id="kobo.972.2">By default, the result is a string containing </span><code class="inlineCode"><span class="koboSpan" id="kobo.973.1">'0'</span></code><span class="koboSpan" id="kobo.974.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.975.1">'1'</span></code><span class="koboSpan" id="kobo.976.1">, but you can specify a different character for these two values:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.977.1">auto</span></span><span class="koboSpan" id="kobo.978.1"> s1 = bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.979.1">to_string</span></span><span class="koboSpan" id="kobo.980.1">();         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.981.1">// s1 = "00101010"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.982.1">auto</span></span><span class="koboSpan" id="kobo.983.1"> s2 = bs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.984.1">to_string</span></span><span class="koboSpan" id="kobo.985.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.986.1">'o'</span></span><span class="koboSpan" id="kobo.987.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.988.1">'x'</span></span><span class="koboSpan" id="kobo.989.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.990.1">// s2 = "ooxoxoxo"</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-268"><span class="koboSpan" id="kobo.991.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.992.1">If you’ve </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.993.1">ever worked with C or C-like APIs, chances are you have either written or at least seen code that manipulates bits to define styles, options, or other kinds of values. </span><span class="koboSpan" id="kobo.993.2">This usually involves operations such as:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.994.1">Defining the bit flags; these can be enumerations, static constants in a class, or macros introduced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.995.1">#define</span></code><span class="koboSpan" id="kobo.996.1"> in the C style. </span><span class="koboSpan" id="kobo.996.2">Usually, there is a flag representing no value (style, option, and so on). </span><span class="koboSpan" id="kobo.996.3">Since these are supposed to be bit flags, their values are powers of 2.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.997.1">Adding and removing flags from the set (that is, a numerical value). </span><span class="koboSpan" id="kobo.997.2">Adding a bit flag is done with the bit-or operator (</span><code class="inlineCode"><span class="koboSpan" id="kobo.998.1">value |= FLAG</span></code><span class="koboSpan" id="kobo.999.1">) and removing a bit flag is done with the bit-and operator, with the negated flag (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1000.1">value &amp;= ~FLAG</span></code><span class="koboSpan" id="kobo.1001.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1002.1">Testing whether a flag is added to the set (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1003.1">value &amp; FLAG == FLAG</span></code><span class="koboSpan" id="kobo.1004.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1005.1">Calling functions with the flags as an argument.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1006.1">The following shows a simple example of flags defining the border style of a control that can have a border on the left, right, top, or bottom sides, or any combination of these, including no border:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1007.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1008.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1009.1"> BORDER_NONE   0x00</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1010.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1012.1"> BORDER_LEFT   0x01</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1013.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1014.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1015.1"> BORDER_TOP    0x02</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1016.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1017.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1018.1"> BORDER_RIGHT  0x04</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1019.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1020.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1021.1"> BORDER_BOTTOM 0x08</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1022.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1023.1">apply_style</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1024.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1025.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1026.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1027.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1028.1"> style)</span></span><span class="koboSpan" id="kobo.1029.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1030.1">if</span></span><span class="koboSpan" id="kobo.1031.1"> (style &amp; BORDER_BOTTOM) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1032.1">/* do something */</span></span><span class="koboSpan" id="kobo.1033.1"> }
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1034.1">// initialize with no flags</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1035.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1036.1">int</span></span><span class="koboSpan" id="kobo.1037.1"> style = BORDER_NONE;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1038.1">// set a flag</span></span><span class="koboSpan" id="kobo.1039.1">
style = BORDER_BOTTOM;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1040.1">// add more flags</span></span><span class="koboSpan" id="kobo.1041.1">
style |= BORDER_LEFT | BORDER_RIGHT | BORDER_TOP;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1042.1">// remove some flags</span></span><span class="koboSpan" id="kobo.1043.1">
style &amp;= ~BORDER_LEFT;
style &amp;= ~BORDER_RIGHT;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1044.1">// test if a flag is set</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1045.1">if</span></span><span class="koboSpan" id="kobo.1046.1"> ((style &amp; BORDER_BOTTOM) == BORDER_BOTTOM) {}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1047.1">// pass the flags as argument to a function</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1048.1">apply_style</span></span><span class="koboSpan" id="kobo.1049.1">(style);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1050.1">The </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.1051.1">standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">std::bitset</span></code><span class="koboSpan" id="kobo.1053.1"> class is intended as a C++ alternative to this C-like working style with sets of bits. </span><span class="koboSpan" id="kobo.1053.2">It enables us to write more robust and safer code because it abstracts the bit operations with member functions, though we still need to identify what each bit in the set is representing:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1054.1">Adding and removing flags is done with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1055.1">set()</span></code><span class="koboSpan" id="kobo.1056.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1057.1">reset()</span></code><span class="koboSpan" id="kobo.1058.1"> methods, which set the value of a bit indicated by its position to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1059.1">1</span></code><span class="koboSpan" id="kobo.1060.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1061.1">0</span></code><span class="koboSpan" id="kobo.1062.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1063.1">true</span></code><span class="koboSpan" id="kobo.1064.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1065.1">false</span></code><span class="koboSpan" id="kobo.1066.1">); alternatively, we can use the index operator for the same purpose.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1067.1">Testing if a bit is set with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1068.1">test()</span></code><span class="koboSpan" id="kobo.1069.1"> method.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1070.1">Conversion from an integer or a string is done through the constructor, and conversion to an integer or string is done with member functions so that the values from the bitsets can be used where integers are expected (such as arguments to functions).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1071.1">Notice that the constructors that build a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1072.1">bitset</span></code><span class="koboSpan" id="kobo.1073.1"> from a sequence of characters – be that a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1074.1">std::basic_string</span></code><span class="koboSpan" id="kobo.1075.1">, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1076.1">const char*</span></code><span class="koboSpan" id="kobo.1077.1"> (or any other character type), or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1078.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.1079.1"> in C++26, may throw exceptions: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1080.1">std::invalid_argument</span></code><span class="koboSpan" id="kobo.1081.1">, if any character is not the zero or one specified values, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1082.1">std::out_of_range</span></code><span class="koboSpan" id="kobo.1083.1">, if the starting offset into the sequence is beyond the end of the sequence.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1084.1">In addition to these operations, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1085.1">bitset</span></code><span class="koboSpan" id="kobo.1086.1"> class has additional methods for performing bitwise operations on bits, shifting, testing, and others that have been shown in the previous section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1087.1">Conceptually, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1088.1">std::bitset</span></code><span class="koboSpan" id="kobo.1089.1"> is a representation of a numerical value that enables you to access and modify individual bits. </span><span class="koboSpan" id="kobo.1089.2">Internally, however, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">bitset</span></code><span class="koboSpan" id="kobo.1091.1"> has an array of integer values</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.1092.1"> on which it performs bit operations. </span><span class="koboSpan" id="kobo.1092.2">The size of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">bitset</span></code><span class="koboSpan" id="kobo.1094.1"> is not limited to the size of a numerical type; it can be anything, except that it is a compile-time constant.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1095.1">The example of the control border styles from the previous section can be written using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1096.1">std::bitset</span></code><span class="koboSpan" id="kobo.1097.1"> in the following manner:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1098.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1099.1">border_flags</span></span><span class="koboSpan" id="kobo.1100.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1101.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1102.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1103.1">int</span></span><span class="koboSpan" id="kobo.1104.1"> left = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1105.1">0</span></span><span class="koboSpan" id="kobo.1106.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1107.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1108.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1109.1">int</span></span><span class="koboSpan" id="kobo.1110.1"> top = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1111.1">1</span></span><span class="koboSpan" id="kobo.1112.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1113.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1114.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1115.1">int</span></span><span class="koboSpan" id="kobo.1116.1"> right = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1117.1">2</span></span><span class="koboSpan" id="kobo.1118.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1119.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1120.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1121.1">int</span></span><span class="koboSpan" id="kobo.1122.1"> bottom = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1123.1">3</span></span><span class="koboSpan" id="kobo.1124.1">;
};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1125.1">// initialize with no flags</span></span><span class="koboSpan" id="kobo.1126.1">
std::bitset&lt;4&gt; style;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1127.1">// set a flag</span></span><span class="koboSpan" id="kobo.1128.1">
style.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1129.1">set</span></span><span class="koboSpan" id="kobo.1130.1">(border_flags::bottom);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1131.1">// set more flags</span></span><span class="koboSpan" id="kobo.1132.1">
style
  .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1133.1">set</span></span><span class="koboSpan" id="kobo.1134.1">(border_flags::left)
  .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1135.1">set</span></span><span class="koboSpan" id="kobo.1136.1">(border_flags::top)
  .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1137.1">set</span></span><span class="koboSpan" id="kobo.1138.1">(border_flags::right);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1139.1">// remove some flags</span></span><span class="koboSpan" id="kobo.1140.1">
style[border_flags::left] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1141.1">0</span></span><span class="koboSpan" id="kobo.1142.1">;
style.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1143.1">reset</span></span><span class="koboSpan" id="kobo.1144.1">(border_flags::right);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1145.1">// test if a flag is set</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1146.1">if</span></span><span class="koboSpan" id="kobo.1147.1"> (style.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1148.1">test</span></span><span class="koboSpan" id="kobo.1149.1">(border_flags::bottom)) {}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1150.1">// pass the flags as argument to a function</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1151.1">apply_style</span></span><span class="koboSpan" id="kobo.1152.1">(style.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1153.1">to_ulong</span></span><span class="koboSpan" id="kobo.1154.1">());
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1155.1">Keep in mind this is only one possible implementation. </span><span class="koboSpan" id="kobo.1155.2">For instance, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1156.1">border_flags</span></code><span class="koboSpan" id="kobo.1157.1"> class could have been an enumeration. </span><span class="koboSpan" id="kobo.1157.2">However, using a scoped enumeration would require explicit casts to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1158.1">int</span></code><span class="koboSpan" id="kobo.1159.1">. </span><span class="koboSpan" id="kobo.1159.2">Different solutions may have advantages and disadvantages. </span><span class="koboSpan" id="kobo.1159.3">You can take it as an exercise to write an alternative solution.</span></p>
<h2 class="heading-2" id="_idParaDest-269"><span class="koboSpan" id="kobo.1160.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1161.1">A bitset </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.1162.1">can be created from an integer and can convert its value to an integer using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1163.1">to_ulong()</span></code><span class="koboSpan" id="kobo.1164.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1165.1">to_ullong()</span></code><span class="koboSpan" id="kobo.1166.1"> methods. </span><span class="koboSpan" id="kobo.1166.2">However, if the size of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1167.1">bitset</span></code><span class="koboSpan" id="kobo.1168.1"> is larger than the size of these numerical types and any of the bits beyond the size of the requested numerical type is set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1169.1">1</span></code><span class="koboSpan" id="kobo.1170.1">, then these methods throw an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1171.1">std::overflow_error</span></code><span class="koboSpan" id="kobo.1172.1"> exception. </span><span class="koboSpan" id="kobo.1172.2">This is because the value cannot be represented on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1173.1">unsigned long</span></code><span class="koboSpan" id="kobo.1174.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1175.1">unsigned long long</span></code><span class="koboSpan" id="kobo.1176.1">. </span><span class="koboSpan" id="kobo.1176.2">In order to extract all the bits, we need to do the following operations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1177.1">Clear the bits beyond the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1178.1">unsigned long</span></code><span class="koboSpan" id="kobo.1179.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1180.1">unsigned long long</span></code><span class="koboSpan" id="kobo.1181.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1182.1">Convert the value to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1183.1">unsigned long</span></code><span class="koboSpan" id="kobo.1184.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">unsigned long long</span></code><span class="koboSpan" id="kobo.1186.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1187.1">Shift the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1188.1">bitset</span></code><span class="koboSpan" id="kobo.1189.1"> with the number of bits in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1190.1">unsigned long</span></code><span class="koboSpan" id="kobo.1191.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1192.1">unsigned long long</span></code><span class="koboSpan" id="kobo.1193.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1194.1">Do this until all the bits are retrieved.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1195.1">These are implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1196.1">template</span></span><span class="koboSpan" id="kobo.1197.1"> &lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1198.1">size_t</span></span><span class="koboSpan" id="kobo.1199.1"> N&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1200.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1201.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1202.1">long</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1203.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1204.1">bitset_to_vectorulong</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1205.1">(std::bitset&lt;N&gt; bs)</span></span><span class="koboSpan" id="kobo.1206.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1207.1">auto</span></span><span class="koboSpan" id="kobo.1208.1"> result = std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1209.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1210.1">long</span></span><span class="koboSpan" id="kobo.1211.1">&gt; {};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1212.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1213.1">const</span></span><span class="koboSpan" id="kobo.1214.1"> size = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1215.1">8</span></span><span class="koboSpan" id="kobo.1216.1"> * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1217.1">sizeof</span></span><span class="koboSpan" id="kobo.1218.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1219.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1220.1">long</span></span><span class="koboSpan" id="kobo.1221.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1222.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1223.1">const</span></span><span class="koboSpan" id="kobo.1224.1"> mask = std::bitset&lt;N&gt;{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1225.1">static_cast</span></span><span class="koboSpan" id="kobo.1226.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1227.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1228.1">long</span></span><span class="koboSpan" id="kobo.1229.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1230.1">-1</span></span><span class="koboSpan" id="kobo.1231.1">)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1232.1">auto</span></span><span class="koboSpan" id="kobo.1233.1"> totalbits = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1234.1">0</span></span><span class="koboSpan" id="kobo.1235.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1236.1">while</span></span><span class="koboSpan" id="kobo.1237.1"> (totalbits &lt; N)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1238.1">auto</span></span><span class="koboSpan" id="kobo.1239.1"> value = (bs &amp; mask).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1240.1">to_ulong</span></span><span class="koboSpan" id="kobo.1241.1">();
    result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1242.1">push_back</span></span><span class="koboSpan" id="kobo.1243.1">(value);
    bs &gt;&gt;= size;
    totalbits += size;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1244.1">return</span></span><span class="koboSpan" id="kobo.1245.1"> result;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1246.1">To exemplify, let’s take the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.1247.1">bitset</span></code><span class="koboSpan" id="kobo.1248.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1249.1">std::bitset&lt;128&gt; bs =
    (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1250.1">bitset</span></span><span class="koboSpan" id="kobo.1251.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.1252.1">128</span></span><span class="koboSpan" id="kobo.1253.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1254.1">0xFEDC</span></span><span class="koboSpan" id="kobo.1255.1">) &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1256.1">96</span></span><span class="koboSpan" id="kobo.1257.1">) |
    (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1258.1">bitset</span></span><span class="koboSpan" id="kobo.1259.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.1260.1">128</span></span><span class="koboSpan" id="kobo.1261.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1262.1">0xBA98</span></span><span class="koboSpan" id="kobo.1263.1">) &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1264.1">64</span></span><span class="koboSpan" id="kobo.1265.1">) |
    (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1266.1">bitset</span></span><span class="koboSpan" id="kobo.1267.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.1268.1">128</span></span><span class="koboSpan" id="kobo.1269.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1270.1">0x7654</span></span><span class="koboSpan" id="kobo.1271.1">) &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1272.1">32</span></span><span class="koboSpan" id="kobo.1273.1">) |
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1274.1">bitset</span></span><span class="koboSpan" id="kobo.1275.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.1276.1">128</span></span><span class="koboSpan" id="kobo.1277.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1278.1">0x3210</span></span><span class="koboSpan" id="kobo.1279.1">);
std::cout &lt;&lt; bs &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1280.1">'\n'</span></span><span class="koboSpan" id="kobo.1281.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1282.1">If we print</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.1283.1"> its content, we get the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1284.1">00000000000000001111111011011100000000000000000010111010100110000000000000000000011101100101010000000000000000000011001000010000
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1285.1">However, when we convert this set to a sequence of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1286.1">unsigned long</span></code><span class="koboSpan" id="kobo.1287.1"> values using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1288.1">biset_to_vectorulong()</span></code><span class="koboSpan" id="kobo.1289.1"> and print their hexadecimal representation, we get the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1290.1">auto</span></span><span class="koboSpan" id="kobo.1291.1"> result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1292.1">bitset_to_vectorulong</span></span><span class="koboSpan" id="kobo.1293.1">(bs);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1294.1">for</span></span><span class="koboSpan" id="kobo.1295.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1296.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1297.1">const</span></span><span class="koboSpan" id="kobo.1298.1"> v : result)
  std::cout &lt;&lt; std::hex &lt;&lt; v &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1299.1">'\n'</span></span><span class="koboSpan" id="kobo.1300.1">;
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1301.1">3210
7654
ba98
fedc
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1302.1">For cases where the size of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1303.1">bitset</span></code><span class="koboSpan" id="kobo.1304.1"> cannot be known at compile time, the alternative is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1305.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1306.1">, which we will cover in the next recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-270"><span class="koboSpan" id="kobo.1307.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1308.1">Using vector&lt;bool&gt; for variable-size sequences of bits</span></em><span class="koboSpan" id="kobo.1309.1">, to learn about the specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1310.1">std::vector</span></code><span class="koboSpan" id="kobo.1311.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1312.1">bool</span></code><span class="koboSpan" id="kobo.1313.1"> type, which is used for handling bit sequences of variable sizes</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1314.1">Using the bit manipulation utilities</span></em><span class="koboSpan" id="kobo.1315.1">, to explore the C++20 set of utility functions for bit manipulation from the numeric library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-271"><span class="koboSpan" id="kobo.1316.1">Using vector&lt;bool&gt; for variable-size sequences of bits</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1317.1">In the </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.1318.1">previous recipe, we looked at using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1319.1">std::bitset</span></code><span class="koboSpan" id="kobo.1320.1"> for fixed-size sequences of bits. </span><span class="koboSpan" id="kobo.1320.2">Sometimes, however, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1321.1">std::bitset</span></code><span class="koboSpan" id="kobo.1322.1"> is not a good choice because you do not know the number of bits at compile time, and just defining a set of a large enough number of bits is not a good idea. </span><span class="koboSpan" id="kobo.1322.2">This is because you can get into a situation where the number is not actually large enough. </span><span class="koboSpan" id="kobo.1322.3">The standard alternative for this is to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1324.1"> container, which is a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1325.1">std::vector</span></code><span class="koboSpan" id="kobo.1326.1"> with space and speed optimizations since implementations do not actually store Boolean values, but individual bits for each element.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1327.1">For this reason, however, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1328.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1329.1"> does not meet the requirements of a standard container or sequential container, nor does </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">std::vector&lt;bool&gt;::iterator</span></code><span class="koboSpan" id="kobo.1331.1"> meet the requirements of a forward iterator. </span><span class="koboSpan" id="kobo.1331.2">As a result, this specialization cannot be used in generic code where a vector is expected. </span><span class="koboSpan" id="kobo.1331.3">On the other hand, being a vector, it has a different interface from that of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">std::bitset</span></code><span class="koboSpan" id="kobo.1333.1"> and cannot be viewed as a binary representation of a number. </span><span class="koboSpan" id="kobo.1333.2">There are no direct ways to construct </span><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1335.1"> from a number or string, nor to convert it to a number or string.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-272"><span class="koboSpan" id="kobo.1336.1">Getting ready...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1337.1">This recipe assumes you are familiar with both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1338.1">std::vector</span></code><span class="koboSpan" id="kobo.1339.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1340.1">std::bitset</span></code><span class="koboSpan" id="kobo.1341.1">. </span><span class="koboSpan" id="kobo.1341.2">If you didn’t read the previous recipes, </span><em class="italic"><span class="koboSpan" id="kobo.1342.1">Using vector as a default container</span></em><span class="koboSpan" id="kobo.1343.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1344.1">Using bitset for fixed-size sequences of bits</span></em><span class="koboSpan" id="kobo.1345.1">, you should read them before continuing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1346.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1347.1">vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1348.1"> class is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1349.1">std</span></code><span class="koboSpan" id="kobo.1350.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1351.1">&lt;vector&gt;</span></code><span class="koboSpan" id="kobo.1352.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-273"><span class="koboSpan" id="kobo.1353.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1354.1">To manipulate an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1355.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1356.1">, use the same methods you would use for an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1357.1">std::vector&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1358.1">, as shown in the following examples:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1359.1">Creating an empty vector:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1360.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1361.1">bool</span></span><span class="koboSpan" id="kobo.1362.1">&gt; bv; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1363.1">// []</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1364.1">Adding bits to the vector:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1365.1">bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1366.1">push_back</span></span><span class="koboSpan" id="kobo.1367.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1368.1">true</span></span><span class="koboSpan" id="kobo.1369.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1370.1">// [1]</span></span><span class="koboSpan" id="kobo.1371.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1372.1">push_back</span></span><span class="koboSpan" id="kobo.1373.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1374.1">true</span></span><span class="koboSpan" id="kobo.1375.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1376.1">// [1, 1]</span></span><span class="koboSpan" id="kobo.1377.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1378.1">push_back</span></span><span class="koboSpan" id="kobo.1379.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1380.1">false</span></span><span class="koboSpan" id="kobo.1381.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1382.1">// [1, 1, 0]</span></span><span class="koboSpan" id="kobo.1383.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1384.1">push_back</span></span><span class="koboSpan" id="kobo.1385.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1386.1">false</span></span><span class="koboSpan" id="kobo.1387.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1388.1">// [1, 1, 0, 0]</span></span><span class="koboSpan" id="kobo.1389.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1390.1">push_back</span></span><span class="koboSpan" id="kobo.1391.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1392.1">true</span></span><span class="koboSpan" id="kobo.1393.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1394.1">// [1, 1, 0, 0, 1]</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1395.1">Setting the values of individual bits:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1396.1">bv[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1397.1">3</span></span><span class="koboSpan" id="kobo.1398.1">] = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1399.1">true</span></span><span class="koboSpan" id="kobo.1400.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1401.1">// [1, 1, 0, 1, 1]</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1402.1">Using generic algorithms:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1403.1">auto</span></span><span class="koboSpan" id="kobo.1404.1"> count_of_ones = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1405.1">count</span></span><span class="koboSpan" id="kobo.1406.1">(bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1407.1">cbegin</span></span><span class="koboSpan" id="kobo.1408.1">(), bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1409.1">cend</span></span><span class="koboSpan" id="kobo.1410.1">(), </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1411.1">true</span></span><span class="koboSpan" id="kobo.1412.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1413.1">Removing bits from the vector:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1414.1">bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1415.1">erase</span></span><span class="koboSpan" id="kobo.1416.1">(bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1417.1">begin</span></span><span class="koboSpan" id="kobo.1418.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1419.1">2</span></span><span class="koboSpan" id="kobo.1420.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1421.1">// [1, 1, 1, 1]</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-274"><span class="koboSpan" id="kobo.1422.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1423.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1424.1"> is not </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.1425.1">a standard vector because it is designed to provide space optimization by storing a single bit for each element instead of a Boolean value. </span><span class="koboSpan" id="kobo.1425.2">Therefore, its elements are not stored in a contiguous sequence and cannot be substituted for an array of Booleans. </span><span class="koboSpan" id="kobo.1425.3">Due to this:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1426.1">The index operator cannot return a reference to a specific element because elements are not stored individually:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1427.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1428.1">bool</span></span><span class="koboSpan" id="kobo.1429.1">&gt; bv;
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1430.1">resize</span></span><span class="koboSpan" id="kobo.1431.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1432.1">10</span></span><span class="koboSpan" id="kobo.1433.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1434.1">auto</span></span><span class="koboSpan" id="kobo.1435.1">&amp; bit = bv[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1436.1">0</span></span><span class="koboSpan" id="kobo.1437.1">];      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1438.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1439.1">Dereferencing an iterator cannot produce a reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1440.1">bool</span></code><span class="koboSpan" id="kobo.1441.1"> for the same reason as mentioned earlier:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1442.1">auto</span></span><span class="koboSpan" id="kobo.1443.1">&amp; bit = *bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1444.1">begin</span></span><span class="koboSpan" id="kobo.1445.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1446.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1447.1">There is no guarantee that individual bits can be manipulated independently at the same time from different threads.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1448.1">The vector cannot be used with algorithms that require forward iterators, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1449.1">std::search()</span></code><span class="koboSpan" id="kobo.1450.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1451.1">The vector cannot be used in some generic code where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1452.1">std::vector&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1453.1"> is expected if such code requires any of the operations mentioned in this list.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1454.1">An</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.1455.1"> alternative to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1456.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1457.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1458.1">std::dequeu&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1459.1">, which is a standard container (a double-ended queue) that meets all container and iterator requirements and can be used with all standard algorithms. </span><span class="koboSpan" id="kobo.1459.2">However, this will not have the space optimization that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1460.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1461.1"> provides.</span></p>
<h2 class="heading-2" id="_idParaDest-275"><span class="koboSpan" id="kobo.1462.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1463.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1464.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1465.1"> interface is very different from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1466.1">std::bitset</span></code><span class="koboSpan" id="kobo.1467.1">. </span><span class="koboSpan" id="kobo.1467.2">If you want to be able to write code in a similar manner, you can create a wrapper on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1468.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1469.1">, which looks like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1470.1">std::bitset</span></code><span class="koboSpan" id="kobo.1471.1">, where possible. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1472.1">The following implementation provides members similar to what is available in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1473.1">std::bitset</span></code><span class="koboSpan" id="kobo.1474.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1475.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1476.1">bitvector</span></span><span class="koboSpan" id="kobo.1477.1">
{
  std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1478.1">bool</span></span><span class="koboSpan" id="kobo.1479.1">&gt; bv;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1480.1">public</span></span><span class="koboSpan" id="kobo.1481.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1482.1">bitvector</span></span><span class="koboSpan" id="kobo.1483.1">(std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1484.1">bool</span></span><span class="koboSpan" id="kobo.1485.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.1486.1">const</span></span><span class="koboSpan" id="kobo.1487.1"> &amp; bv) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1488.1">bv</span></span><span class="koboSpan" id="kobo.1489.1">(bv) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1490.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1491.1">operator</span></span><span class="koboSpan" id="kobo.1492.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1493.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1494.1">const</span></span><span class="koboSpan" id="kobo.1495.1"> i) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1496.1">return</span></span><span class="koboSpan" id="kobo.1497.1"> bv[i]; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1498.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1499.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1500.1">any</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1501.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1502.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1503.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1504.1">for</span></span><span class="koboSpan" id="kobo.1505.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1506.1">auto</span></span><span class="koboSpan" id="kobo.1507.1"> b : bv) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1508.1">if</span></span><span class="koboSpan" id="kobo.1509.1"> (b) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1510.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1511.1">true</span></span><span class="koboSpan" id="kobo.1512.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1513.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1514.1">false</span></span><span class="koboSpan" id="kobo.1515.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1516.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1517.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1518.1">all</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1519.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1520.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1521.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1522.1">for</span></span><span class="koboSpan" id="kobo.1523.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1524.1">auto</span></span><span class="koboSpan" id="kobo.1525.1"> b : bv) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1526.1">if</span></span><span class="koboSpan" id="kobo.1527.1"> (!b) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1528.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1529.1">false</span></span><span class="koboSpan" id="kobo.1530.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1531.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1532.1">true</span></span><span class="koboSpan" id="kobo.1533.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1534.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1535.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1536.1">none</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1537.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1538.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1539.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1540.1">return</span></span><span class="koboSpan" id="kobo.1541.1"> !</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1542.1">any</span></span><span class="koboSpan" id="kobo.1543.1">(); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1544.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1545.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1546.1">count</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1547.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1548.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1549.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1550.1">return</span></span><span class="koboSpan" id="kobo.1551.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1552.1">count</span></span><span class="koboSpan" id="kobo.1553.1">(bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1554.1">cbegin</span></span><span class="koboSpan" id="kobo.1555.1">(), bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1556.1">cend</span></span><span class="koboSpan" id="kobo.1557.1">(), </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1558.1">true</span></span><span class="koboSpan" id="kobo.1559.1">);
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1560.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1561.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1562.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1563.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1564.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1565.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1566.1">return</span></span><span class="koboSpan" id="kobo.1567.1"> bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1568.1">size</span></span><span class="koboSpan" id="kobo.1569.1">(); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1570.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1571.1"> bitvector &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1572.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1573.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1574.1">bool</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1575.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1576.1"> value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1577.1">{
    bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1578.1">push_back</span></span><span class="koboSpan" id="kobo.1579.1">(value);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1580.1">return</span></span><span class="koboSpan" id="kobo.1581.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1582.1">this</span></span><span class="koboSpan" id="kobo.1583.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1584.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1585.1"> bitvector &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1586.1">remove</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1587.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1588.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1589.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1590.1"> index)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1591.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1592.1">if</span></span><span class="koboSpan" id="kobo.1593.1"> (index &gt;= bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1594.1">size</span></span><span class="koboSpan" id="kobo.1595.1">())
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1596.1">throw</span></span><span class="koboSpan" id="kobo.1597.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1598.1">out_of_range</span></span><span class="koboSpan" id="kobo.1599.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1600.1">"Index out of range"</span></span><span class="koboSpan" id="kobo.1601.1">);
    bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1602.1">erase</span></span><span class="koboSpan" id="kobo.1603.1">(bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1604.1">begin</span></span><span class="koboSpan" id="kobo.1605.1">() + index);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1606.1">return</span></span><span class="koboSpan" id="kobo.1607.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1608.1">this</span></span><span class="koboSpan" id="kobo.1609.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1610.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1611.1"> bitvector &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1612.1">set</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1613.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1614.1">bool</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1615.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1616.1"> value = </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1617.1">true</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1618.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1619.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1620.1">for</span></span><span class="koboSpan" id="kobo.1621.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1622.1">size_t</span></span><span class="koboSpan" id="kobo.1623.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1624.1">0</span></span><span class="koboSpan" id="kobo.1625.1">; i &lt; bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1626.1">size</span></span><span class="koboSpan" id="kobo.1627.1">(); ++i)
      bv[i] = value;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1628.1">return</span></span><span class="koboSpan" id="kobo.1629.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1630.1">this</span></span><span class="koboSpan" id="kobo.1631.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1632.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1633.1"> bitvector&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1634.1">set</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1635.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1636.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1637.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1638.1"> index, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1639.1">bool</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1640.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1641.1"> value = </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1642.1">true</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1643.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1644.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1645.1">if</span></span><span class="koboSpan" id="kobo.1646.1"> (index &gt;= bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1647.1">size</span></span><span class="koboSpan" id="kobo.1648.1">())
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1649.1">throw</span></span><span class="koboSpan" id="kobo.1650.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1651.1">out_of_range</span></span><span class="koboSpan" id="kobo.1652.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1653.1">"Index out of range"</span></span><span class="koboSpan" id="kobo.1654.1">);
    bv[index] = value;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1655.1">return</span></span><span class="koboSpan" id="kobo.1656.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1657.1">this</span></span><span class="koboSpan" id="kobo.1658.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1659.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1660.1"> bitvector &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1661.1">reset</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1662.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1663.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1664.1">for</span></span><span class="koboSpan" id="kobo.1665.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1666.1">size_t</span></span><span class="koboSpan" id="kobo.1667.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1668.1">0</span></span><span class="koboSpan" id="kobo.1669.1">; i &lt; bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1670.1">size</span></span><span class="koboSpan" id="kobo.1671.1">(); ++i) bv[i] = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1672.1">false</span></span><span class="koboSpan" id="kobo.1673.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1674.1">return</span></span><span class="koboSpan" id="kobo.1675.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1676.1">this</span></span><span class="koboSpan" id="kobo.1677.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1678.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1679.1"> bitvector &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1680.1">reset</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1681.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1682.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1683.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1684.1"> index)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1685.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1686.1">if</span></span><span class="koboSpan" id="kobo.1687.1"> (index &gt;= bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1688.1">size</span></span><span class="koboSpan" id="kobo.1689.1">())
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1690.1">throw</span></span><span class="koboSpan" id="kobo.1691.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1692.1">out_of_range</span></span><span class="koboSpan" id="kobo.1693.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1694.1">"Index out of range"</span></span><span class="koboSpan" id="kobo.1695.1">);
    bv[index] = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1696.1">false</span></span><span class="koboSpan" id="kobo.1697.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1698.1">return</span></span><span class="koboSpan" id="kobo.1699.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1700.1">this</span></span><span class="koboSpan" id="kobo.1701.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1702.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1703.1"> bitvector &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1704.1">flip</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1705.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1706.1">{
    bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1707.1">flip</span></span><span class="koboSpan" id="kobo.1708.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1709.1">return</span></span><span class="koboSpan" id="kobo.1710.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1711.1">this</span></span><span class="koboSpan" id="kobo.1712.1">;
  }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.1713.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1714.1">bool</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1715.1">&gt;&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1716.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1717.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1718.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1719.1">return</span></span><span class="koboSpan" id="kobo.1720.1"> bv; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1721.1">This is</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.1722.1"> only a basic implementation, and if you want to use such a wrapper, you should add additional methods, such as bit logic operations, shifting, maybe reading and writing from and to streams, and so on. </span><span class="koboSpan" id="kobo.1722.2">However, with the preceding code, we can write the following examples:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1723.1">bitvector bv;
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1724.1">add</span></span><span class="koboSpan" id="kobo.1725.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1726.1">true</span></span><span class="koboSpan" id="kobo.1727.1">).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1728.1">add</span></span><span class="koboSpan" id="kobo.1729.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1730.1">true</span></span><span class="koboSpan" id="kobo.1731.1">).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1732.1">add</span></span><span class="koboSpan" id="kobo.1733.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1734.1">false</span></span><span class="koboSpan" id="kobo.1735.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1736.1">// [1, 1, 0]</span></span><span class="koboSpan" id="kobo.1737.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1738.1">add</span></span><span class="koboSpan" id="kobo.1739.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1740.1">false</span></span><span class="koboSpan" id="kobo.1741.1">);                     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1742.1">// [1, 1, 0, 0]</span></span><span class="koboSpan" id="kobo.1743.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1744.1">add</span></span><span class="koboSpan" id="kobo.1745.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1746.1">true</span></span><span class="koboSpan" id="kobo.1747.1">);                      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1748.1">// [1, 1, 0, 0, 1]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1749.1">if</span></span><span class="koboSpan" id="kobo.1750.1"> (bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1751.1">any</span></span><span class="koboSpan" id="kobo.1752.1">()) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1753.1">"has some 1s"</span></span><span class="koboSpan" id="kobo.1754.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1755.1">'\n'</span></span><span class="koboSpan" id="kobo.1756.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1757.1">if</span></span><span class="koboSpan" id="kobo.1758.1"> (bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1759.1">all</span></span><span class="koboSpan" id="kobo.1760.1">()) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1761.1">"has only 1s"</span></span><span class="koboSpan" id="kobo.1762.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1763.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1764.1">\n'</span></span><span class="koboSpan" id="kobo.1765.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1766.1">if</span></span><span class="koboSpan" id="kobo.1767.1"> (bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1768.1">none</span></span><span class="koboSpan" id="kobo.1769.1">()) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1770.1">"has no 1s"</span></span><span class="koboSpan" id="kobo.1771.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1772.1">'\n'</span></span><span class="koboSpan" id="kobo.1773.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1774.1">"has "</span></span><span class="koboSpan" id="kobo.1775.1"> &lt;&lt; bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1776.1">count</span></span><span class="koboSpan" id="kobo.1777.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1778.1">" 1s"</span></span><span class="koboSpan" id="kobo.1779.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1780.1">'\n'</span></span><span class="koboSpan" id="kobo.1781.1">;
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1782.1">set</span></span><span class="koboSpan" id="kobo.1783.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1784.1">2</span></span><span class="koboSpan" id="kobo.1785.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1786.1">true</span></span><span class="koboSpan" id="kobo.1787.1">);                   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1788.1">// [1, 1, 1, 0, 1]</span></span><span class="koboSpan" id="kobo.1789.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1790.1">set</span></span><span class="koboSpan" id="kobo.1791.1">();                          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1792.1">// [1, 1, 1, 1, 1]</span></span><span class="koboSpan" id="kobo.1793.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1794.1">reset</span></span><span class="koboSpan" id="kobo.1795.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1796.1">0</span></span><span class="koboSpan" id="kobo.1797.1">);                       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1798.1">// [0, 1, 1, 1, 1]</span></span><span class="koboSpan" id="kobo.1799.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1800.1">reset</span></span><span class="koboSpan" id="kobo.1801.1">();                        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1802.1">// [0, 0, 0, 0, 0]</span></span><span class="koboSpan" id="kobo.1803.1">
bv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1804.1">flip</span></span><span class="koboSpan" id="kobo.1805.1">();                         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1806.1">// [1, 1, 1, 1, 1]</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1807.1">These examples are very similar to the examples where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1808.1">std::bitset</span></code><span class="koboSpan" id="kobo.1809.1"> was used. </span><span class="koboSpan" id="kobo.1809.2">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.1810.1">bitvector</span></code><span class="koboSpan" id="kobo.1811.1"> class has an API compatible with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1812.1">std::bitset</span></code><span class="koboSpan" id="kobo.1813.1"> but is useful for handling bit sequences of variable sizes.</span></p>
<h2 class="heading-2" id="_idParaDest-276"><span class="koboSpan" id="kobo.1814.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1815.1">Using vector as a default container</span></em><span class="koboSpan" id="kobo.1816.1">, to learn how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1817.1">std::vector</span></code><span class="koboSpan" id="kobo.1818.1"> standard container</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1819.1">Using bitset for fixed-size sequences of bits</span></em><span class="koboSpan" id="kobo.1820.1">, to learn about the standard container for handling bit sequences of fixed sizes</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1821.1">Using the bit manipulation utilities</span></em><span class="koboSpan" id="kobo.1822.1">, to explore the C++20 set of utility functions for bit manipulation from the numeric library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-277"><span class="koboSpan" id="kobo.1823.1">Using the bit manipulation utilities</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1824.1">In the </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.1825.1">previous recipes, we have seen how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1826.1">std::bitset</span></code><span class="koboSpan" id="kobo.1827.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1828.1">std::vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1829.1"> to work with fixed and variable sequences of bits. </span><span class="koboSpan" id="kobo.1829.2">There are, however, situations when we need to manipulate or process individual or multiple bits of an unsigned integral value. </span><span class="koboSpan" id="kobo.1829.3">This includes operations such as counting or rotating bits. </span><span class="koboSpan" id="kobo.1829.4">The C++20 standard provides a set of utility functions for bit manipulation as part of the numeric library. </span><span class="koboSpan" id="kobo.1829.5">In this recipe, we will learn what they are and how to use these utilities.</span></p>
<h2 class="heading-2" id="_idParaDest-278"><span class="koboSpan" id="kobo.1830.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1831.1">The function templates discussed in this recipe are all available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1832.1">std</span></code><span class="koboSpan" id="kobo.1833.1"> namespace in the new C++20 header </span><code class="inlineCode"><span class="koboSpan" id="kobo.1834.1">&lt;bit&gt;</span></code><span class="koboSpan" id="kobo.1835.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-279"><span class="koboSpan" id="kobo.1836.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1837.1">Use the following function templates to manipulate bits of unsigned integral types:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1838.1">If you need to perform a circular shift, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1839.1">std::rotl&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.1840.1"> for left rotation and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1841.1">std::rotr&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.1842.1"> for right rotation:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1843.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1844.1">char</span></span><span class="koboSpan" id="kobo.1845.1"> n = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1846.1">0b00111100</span></span><span class="koboSpan" id="kobo.1847.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1848.1">auto</span></span><span class="koboSpan" id="kobo.1849.1"> vl1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1850.1">rotl</span></span><span class="koboSpan" id="kobo.1851.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1852.1">0</span></span><span class="koboSpan" id="kobo.1853.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1854.1">// 0b00111100</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1855.1">auto</span></span><span class="koboSpan" id="kobo.1856.1"> vl2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1857.1">rotl</span></span><span class="koboSpan" id="kobo.1858.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1859.1">1</span></span><span class="koboSpan" id="kobo.1860.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1861.1">// 0b01111000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1862.1">auto</span></span><span class="koboSpan" id="kobo.1863.1"> vl3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1864.1">rotl</span></span><span class="koboSpan" id="kobo.1865.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1866.1">3</span></span><span class="koboSpan" id="kobo.1867.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1868.1">// 0b11100001</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1869.1">auto</span></span><span class="koboSpan" id="kobo.1870.1"> vl4 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1871.1">rotl</span></span><span class="koboSpan" id="kobo.1872.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1873.1">9</span></span><span class="koboSpan" id="kobo.1874.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1875.1">// 0b01111000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1876.1">auto</span></span><span class="koboSpan" id="kobo.1877.1"> vl5 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1878.1">rotl</span></span><span class="koboSpan" id="kobo.1879.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1880.1">-2</span></span><span class="koboSpan" id="kobo.1881.1">);</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1882.1">// 0b00001111</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1883.1">auto</span></span><span class="koboSpan" id="kobo.1884.1"> vr1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1885.1">rotr</span></span><span class="koboSpan" id="kobo.1886.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1887.1">0</span></span><span class="koboSpan" id="kobo.1888.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1889.1">// 0b00111100</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1890.1">auto</span></span><span class="koboSpan" id="kobo.1891.1"> vr2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1892.1">rotr</span></span><span class="koboSpan" id="kobo.1893.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1894.1">1</span></span><span class="koboSpan" id="kobo.1895.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1896.1">// 0b00011110</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1897.1">auto</span></span><span class="koboSpan" id="kobo.1898.1"> vr3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1899.1">rotr</span></span><span class="koboSpan" id="kobo.1900.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1901.1">3</span></span><span class="koboSpan" id="kobo.1902.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1903.1">// 0b10000111</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1904.1">auto</span></span><span class="koboSpan" id="kobo.1905.1"> vr4 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1906.1">rotr</span></span><span class="koboSpan" id="kobo.1907.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1908.1">9</span></span><span class="koboSpan" id="kobo.1909.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1910.1">// 0b00011110</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1911.1">auto</span></span><span class="koboSpan" id="kobo.1912.1"> vr5 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1913.1">rotr</span></span><span class="koboSpan" id="kobo.1914.1">(n, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1915.1">-2</span></span><span class="koboSpan" id="kobo.1916.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1917.1">// 0b11110000</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1918.1">If you need to count the number of consecutive </span><code class="inlineCode"><span class="koboSpan" id="kobo.1919.1">0</span></code><span class="koboSpan" id="kobo.1920.1"> bits (that is, until a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1921.1">1</span></code><span class="koboSpan" id="kobo.1922.1"> is found), use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1923.1">std::countl_zero&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.1924.1"> to count from left to right (that is, starting with the most significant bit) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1925.1">std::countr_zero&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.1926.1"> to count from right to left (that is, starting with the least significant bit):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1927.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1928.1">countl_zero</span></span><span class="koboSpan" id="kobo.1929.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1930.1">0b00000000u</span></span><span class="koboSpan" id="kobo.1931.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1932.1">'\n'</span></span><span class="koboSpan" id="kobo.1933.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1934.1">// 8</span></span><span class="koboSpan" id="kobo.1935.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1936.1">countl_zero</span></span><span class="koboSpan" id="kobo.1937.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1938.1">0b11111111u</span></span><span class="koboSpan" id="kobo.1939.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1940.1">'\n'</span></span><span class="koboSpan" id="kobo.1941.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1942.1">// 0</span></span><span class="koboSpan" id="kobo.1943.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1944.1">countl_zero</span></span><span class="koboSpan" id="kobo.1945.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1946.1">0b00111010u</span></span><span class="koboSpan" id="kobo.1947.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1948.1">'\n'</span></span><span class="koboSpan" id="kobo.1949.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1950.1">// 2</span></span><span class="koboSpan" id="kobo.1951.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1952.1">countr_zero</span></span><span class="koboSpan" id="kobo.1953.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1954.1">0b00000000u</span></span><span class="koboSpan" id="kobo.1955.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1956.1">'\n'</span></span><span class="koboSpan" id="kobo.1957.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1958.1">// 8</span></span><span class="koboSpan" id="kobo.1959.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1960.1">countr_zero</span></span><span class="koboSpan" id="kobo.1961.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1962.1">0b11111111u</span></span><span class="koboSpan" id="kobo.1963.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1964.1">'\n'</span></span><span class="koboSpan" id="kobo.1965.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1966.1">// 0</span></span><span class="koboSpan" id="kobo.1967.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1968.1">countr_zero</span></span><span class="koboSpan" id="kobo.1969.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1970.1">0b00111010u</span></span><span class="koboSpan" id="kobo.1971.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1972.1">'\n'</span></span><span class="koboSpan" id="kobo.1973.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1974.1">// 1</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1975.1">If you need to count the number of consecutive </span><code class="inlineCode"><span class="koboSpan" id="kobo.1976.1">1</span></code><span class="koboSpan" id="kobo.1977.1"> bits (that is, until a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1978.1">0</span></code><span class="koboSpan" id="kobo.1979.1"> is found), use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1980.1">std::countl_one&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.1981.1"> to count from left to right (that is, starting with the most significant bit) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1982.1">std::countr_one&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.1983.1"> to count from right to left (that is, starting with the least significant bit):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1984.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1985.1">countl_one</span></span><span class="koboSpan" id="kobo.1986.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1987.1">0b00000000u</span></span><span class="koboSpan" id="kobo.1988.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1989.1">'\n'</span></span><span class="koboSpan" id="kobo.1990.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1991.1">// 0</span></span><span class="koboSpan" id="kobo.1992.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1993.1">countl_one</span></span><span class="koboSpan" id="kobo.1994.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1995.1">0b11111111u</span></span><span class="koboSpan" id="kobo.1996.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1997.1">'\n'</span></span><span class="koboSpan" id="kobo.1998.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1999.1">// 8</span></span><span class="koboSpan" id="kobo.2000.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2001.1">countl_one</span></span><span class="koboSpan" id="kobo.2002.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2003.1">0b11000101u</span></span><span class="koboSpan" id="kobo.2004.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2005.1">'\n'</span></span><span class="koboSpan" id="kobo.2006.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2007.1">// 2</span></span><span class="koboSpan" id="kobo.2008.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2009.1">countr_one</span></span><span class="koboSpan" id="kobo.2010.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2011.1">0b00000000u</span></span><span class="koboSpan" id="kobo.2012.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2013.1">'\n'</span></span><span class="koboSpan" id="kobo.2014.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2015.1">// 0</span></span><span class="koboSpan" id="kobo.2016.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2017.1">countr_one</span></span><span class="koboSpan" id="kobo.2018.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2019.1">0b11111111u</span></span><span class="koboSpan" id="kobo.2020.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2021.1">'\n'</span></span><span class="koboSpan" id="kobo.2022.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2023.1">// 8</span></span><span class="koboSpan" id="kobo.2024.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2025.1">countr_one</span></span><span class="koboSpan" id="kobo.2026.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2027.1">0b11000101u</span></span><span class="koboSpan" id="kobo.2028.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2029.1">'\n'</span></span><span class="koboSpan" id="kobo.2030.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2031.1">// 1</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2032.1">If </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.2033.1">you need to count the number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2034.1">1</span></code><span class="koboSpan" id="kobo.2035.1"> bits, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2036.1">std::popcount&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.2037.1">. </span><span class="koboSpan" id="kobo.2037.2">The number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2038.1">0</span></code><span class="koboSpan" id="kobo.2039.1"> bits is the number of digits used to represent the value (this can be determined with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2040.1">std::numeric_limits&lt;T&gt;::digits</span></code><span class="koboSpan" id="kobo.2041.1">), minus the count of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2042.1">1</span></code><span class="koboSpan" id="kobo.2043.1"> bits:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2044.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2045.1">popcount</span></span><span class="koboSpan" id="kobo.2046.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2047.1">0b00000000u</span></span><span class="koboSpan" id="kobo.2048.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2049.1">'\n'</span></span><span class="koboSpan" id="kobo.2050.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2051.1">// 0</span></span><span class="koboSpan" id="kobo.2052.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2053.1">popcount</span></span><span class="koboSpan" id="kobo.2054.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2055.1">0b11111111u</span></span><span class="koboSpan" id="kobo.2056.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2057.1">'\n'</span></span><span class="koboSpan" id="kobo.2058.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2059.1">// 8</span></span><span class="koboSpan" id="kobo.2060.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2061.1">popcount</span></span><span class="koboSpan" id="kobo.2062.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2063.1">0b10000001u</span></span><span class="koboSpan" id="kobo.2064.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2065.1">'\n'</span></span><span class="koboSpan" id="kobo.2066.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2067.1">// 2</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2068.1">If you need to check whether a number is a power of two, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2069.1">std::has_single_bit&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.2070.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2071.1">std::cout &lt;&lt; std::boolalpha &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2072.1">has_single_bit</span></span><span class="koboSpan" id="kobo.2073.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2074.1">0u</span></span><span class="koboSpan" id="kobo.2075.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2076.1">'\n'</span></span><span class="koboSpan" id="kobo.2077.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2078.1">// false</span></span><span class="koboSpan" id="kobo.2079.1">
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2080.1">has_single_bit</span></span><span class="koboSpan" id="kobo.2081.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2082.1">1u</span></span><span class="koboSpan" id="kobo.2083.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2084.1">'\n'</span></span><span class="koboSpan" id="kobo.2085.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2086.1">// true</span></span><span class="koboSpan" id="kobo.2087.1">
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2088.1">has_single_bit</span></span><span class="koboSpan" id="kobo.2089.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2090.1">2u</span></span><span class="koboSpan" id="kobo.2091.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2092.1">'\n'</span></span><span class="koboSpan" id="kobo.2093.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2094.1">// true</span></span><span class="koboSpan" id="kobo.2095.1">
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2096.1">has_single_bit</span></span><span class="koboSpan" id="kobo.2097.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2098.1">3u</span></span><span class="koboSpan" id="kobo.2099.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2100.1">'\n'</span></span><span class="koboSpan" id="kobo.2101.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2102.1">// false</span></span><span class="koboSpan" id="kobo.2103.1">
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2104.1">has_single_bit</span></span><span class="koboSpan" id="kobo.2105.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2106.1">4u</span></span><span class="koboSpan" id="kobo.2107.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2108.1">'\n'</span></span><span class="koboSpan" id="kobo.2109.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2110.1">// true</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2111.1">If you need to find the smallest power of two that is greater than or equal to a given number, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2112.1">std::bit_ceil&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.2113.1">. </span><span class="koboSpan" id="kobo.2113.2">On the other hand, if you need to find the largest power of two that is smaller than or equal to a given number, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2114.1">std::bit_floor&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.2115.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2116.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2117.1">bit_ceil</span></span><span class="koboSpan" id="kobo.2118.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2119.1">0u</span></span><span class="koboSpan" id="kobo.2120.1">)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2121.1">'\n'</span></span><span class="koboSpan" id="kobo.2122.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2123.1">// 0</span></span><span class="koboSpan" id="kobo.2124.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2125.1">bit_ceil</span></span><span class="koboSpan" id="kobo.2126.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2127.1">3u</span></span><span class="koboSpan" id="kobo.2128.1">)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2129.1">'\n'</span></span><span class="koboSpan" id="kobo.2130.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2131.1">// 4</span></span><span class="koboSpan" id="kobo.2132.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2133.1">bit_ceil</span></span><span class="koboSpan" id="kobo.2134.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2135.1">4u</span></span><span class="koboSpan" id="kobo.2136.1">)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2137.1">'\n'</span></span><span class="koboSpan" id="kobo.2138.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2139.1">// 4</span></span><span class="koboSpan" id="kobo.2140.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2141.1">bit_ceil</span></span><span class="koboSpan" id="kobo.2142.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2143.1">31u</span></span><span class="koboSpan" id="kobo.2144.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2145.1">'\n'</span></span><span class="koboSpan" id="kobo.2146.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2147.1">// 32</span></span><span class="koboSpan" id="kobo.2148.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2149.1">bit_ceil</span></span><span class="koboSpan" id="kobo.2150.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2151.1">42u</span></span><span class="koboSpan" id="kobo.2152.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2153.1">'\n'</span></span><span class="koboSpan" id="kobo.2154.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2155.1">// 64</span></span><span class="koboSpan" id="kobo.2156.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2157.1">bit_floor</span></span><span class="koboSpan" id="kobo.2158.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2159.1">0u</span></span><span class="koboSpan" id="kobo.2160.1">)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2161.1">'\n'</span></span><span class="koboSpan" id="kobo.2162.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2163.1">// 0</span></span><span class="koboSpan" id="kobo.2164.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2165.1">bit_floor</span></span><span class="koboSpan" id="kobo.2166.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2167.1">3u</span></span><span class="koboSpan" id="kobo.2168.1">)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2169.1">'\n'</span></span><span class="koboSpan" id="kobo.2170.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2171.1">// 2</span></span><span class="koboSpan" id="kobo.2172.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2173.1">bit_floor</span></span><span class="koboSpan" id="kobo.2174.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2175.1">4u</span></span><span class="koboSpan" id="kobo.2176.1">)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2177.1">'\n'</span></span><span class="koboSpan" id="kobo.2178.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2179.1">// 4</span></span><span class="koboSpan" id="kobo.2180.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2181.1">bit_floor</span></span><span class="koboSpan" id="kobo.2182.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2183.1">31u</span></span><span class="koboSpan" id="kobo.2184.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2185.1">'\n'</span></span><span class="koboSpan" id="kobo.2186.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2187.1">// 16</span></span><span class="koboSpan" id="kobo.2188.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2189.1">bit_floor</span></span><span class="koboSpan" id="kobo.2190.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2191.1">42u</span></span><span class="koboSpan" id="kobo.2192.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2193.1">'\n'</span></span><span class="koboSpan" id="kobo.2194.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2195.1">// 32</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2196.1">If you </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.2197.1">need to determine the smallest number of digits to represent a number, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2198.1">std::bit_width&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.2199.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2200.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2201.1">bit_width</span></span><span class="koboSpan" id="kobo.2202.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2203.1">0u</span></span><span class="koboSpan" id="kobo.2204.1">)    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2205.1">'\n'</span></span><span class="koboSpan" id="kobo.2206.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2207.1">// 0</span></span><span class="koboSpan" id="kobo.2208.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2209.1">bit_width</span></span><span class="koboSpan" id="kobo.2210.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2211.1">2u</span></span><span class="koboSpan" id="kobo.2212.1">)    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2213.1">'\n'</span></span><span class="koboSpan" id="kobo.2214.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2215.1">// 2</span></span><span class="koboSpan" id="kobo.2216.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2217.1">bit_width</span></span><span class="koboSpan" id="kobo.2218.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2219.1">15u</span></span><span class="koboSpan" id="kobo.2220.1">)   &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2221.1">'\n'</span></span><span class="koboSpan" id="kobo.2222.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2223.1">// 4</span></span><span class="koboSpan" id="kobo.2224.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2225.1">bit_width</span></span><span class="koboSpan" id="kobo.2226.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2227.1">16u</span></span><span class="koboSpan" id="kobo.2228.1">)   &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2229.1">'\n'</span></span><span class="koboSpan" id="kobo.2230.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2231.1">// 5</span></span><span class="koboSpan" id="kobo.2232.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2233.1">bit_width</span></span><span class="koboSpan" id="kobo.2234.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2235.1">1000u</span></span><span class="koboSpan" id="kobo.2236.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2237.1">'\n'</span></span><span class="koboSpan" id="kobo.2238.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2239.1">// 10</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2240.1">If you need to reinterpret the object representation of a type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2241.1">F</span></code><span class="koboSpan" id="kobo.2242.1"> as that of a type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2243.1">T</span></code><span class="koboSpan" id="kobo.2244.1">, then use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2245.1">std::bit_cast&lt;T, F&gt;()</span></code><span class="koboSpan" id="kobo.2246.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2247.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2248.1">double</span></span><span class="koboSpan" id="kobo.2249.1">   pi   = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2250.1">3.1415927</span></span><span class="koboSpan" id="kobo.2251.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2252.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2253.1">uint64_t</span></span><span class="koboSpan" id="kobo.2254.1"> bits = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2255.1">bit_cast</span></span><span class="koboSpan" id="kobo.2256.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2257.1">uint64_t</span></span><span class="koboSpan" id="kobo.2258.1">&gt;(pi);
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2259.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2260.1">double</span></span><span class="koboSpan" id="kobo.2261.1">   pi2  = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2262.1">bit_cast</span></span><span class="koboSpan" id="kobo.2263.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2264.1">double</span></span><span class="koboSpan" id="kobo.2265.1">&gt;(bits);
std::cout
   &lt;&lt; std::fixed &lt;&lt; pi   &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2266.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2267.1">\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.2268.1">// 3.1415923</span></span><span class="koboSpan" id="kobo.2269.1">
   &lt;&lt; std::hex   &lt;&lt; bits &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2270.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.2271.1">// 400921fb5a7ed197</span></span><span class="koboSpan" id="kobo.2272.1">
   &lt;&lt; std::fixed &lt;&lt; pi2  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2273.1">'\n'</span></span><span class="koboSpan" id="kobo.2274.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2275.1">// 3.1415923</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-280"><span class="koboSpan" id="kobo.2276.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2277.1">All the function templates mentioned in the previous section, with the exception of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2278.1">std::bit_cast&lt;T, F&gt;()</span></code><span class="koboSpan" id="kobo.2279.1"> are only available for unsigned integral types. </span><span class="koboSpan" id="kobo.2279.2">That includes the types </span><code class="inlineCode"><span class="koboSpan" id="kobo.2280.1">unsigned char</span></code><span class="koboSpan" id="kobo.2281.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2282.1">unsigned short</span></code><span class="koboSpan" id="kobo.2283.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2284.1">unsigned int</span></code><span class="koboSpan" id="kobo.2285.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2286.1">unsigned long</span></code><span class="koboSpan" id="kobo.2287.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2288.1">unsigned long long</span></code><span class="koboSpan" id="kobo.2289.1">, as well as the fixed width unsigned integer types (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2290.1">uint8_t</span></code><span class="koboSpan" id="kobo.2291.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2292.1">uint64_t</span></code><span class="koboSpan" id="kobo.2293.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2294.1">uint_least8_t</span></code><span class="koboSpan" id="kobo.2295.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2296.1">uintmax_t</span></code><span class="koboSpan" id="kobo.2297.1">, and so on). </span><span class="koboSpan" id="kobo.2297.2">These functions are simple and should not require a detailed description.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2298.1">The</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.2299.1"> function that is different from the rest is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2300.1">std::bit_cast&lt;T, F&gt;()</span></code><span class="koboSpan" id="kobo.2301.1">. </span><span class="koboSpan" id="kobo.2301.2">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2302.1">F</span></code><span class="koboSpan" id="kobo.2303.1"> is the type that is reinterpreted, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2304.1">T</span></code><span class="koboSpan" id="kobo.2305.1"> is the type that we interpret to. </span><span class="koboSpan" id="kobo.2305.2">This function template does not require </span><code class="inlineCode"><span class="koboSpan" id="kobo.2306.1">T</span></code><span class="koboSpan" id="kobo.2307.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2308.1">F</span></code><span class="koboSpan" id="kobo.2309.1"> to be unsigned integral types, but both of them must be trivially copyable. </span><span class="koboSpan" id="kobo.2309.2">Moreover, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2310.1">sizeof(T)</span></code><span class="koboSpan" id="kobo.2311.1"> must be the same as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2312.1">sizeof(F)</span></code><span class="koboSpan" id="kobo.2313.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2314.1">The specification for this function does not mention the value of padding bits in the result. </span><span class="koboSpan" id="kobo.2314.2">On the other hand, if the result value does not correspond to a valid value of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2315.1">T</span></code><span class="koboSpan" id="kobo.2316.1">, then the behavior is undefined.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2317.1">std::bit_cast&lt;T, F&gt;()</span></code><span class="koboSpan" id="kobo.2318.1"> can be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2319.1">constexpr</span></code><span class="koboSpan" id="kobo.2320.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.2321.1">T</span></code><span class="koboSpan" id="kobo.2322.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2323.1">F</span></code><span class="koboSpan" id="kobo.2324.1">, and the types of all their sub-objects are not a union type, a pointer type, a pointer to member type, or a volatile-qualified type, and have no non-static data members of a reference type.</span></p>
<h2 class="heading-2" id="_idParaDest-281"><span class="koboSpan" id="kobo.2325.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2326.1">Using bitset for fixed-size sequences of bits</span></em><span class="koboSpan" id="kobo.2327.1">, to learn about the standard container for handling bit sequences of fixed sizes</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2328.1">Using vector&lt;bool&gt; for variable-size sequences of bits</span></em><span class="koboSpan" id="kobo.2329.1">, to learn about the specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2330.1">std::vector</span></code><span class="koboSpan" id="kobo.2331.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2332.1">bool</span></code><span class="koboSpan" id="kobo.2333.1"> type intended for handling bit sequences of variable sizes</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-282"><span class="koboSpan" id="kobo.2334.1">Finding elements in a range</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2335.1">One </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.2336.1">of the most common operations we do in any application is searching through data. </span><span class="koboSpan" id="kobo.2336.2">Therefore, it is not surprising that the standard library </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.2337.1">provides many generic algorithms for searching through standard containers, or anything that can represent a range and is defined by a start and a past-the-end iterator. </span><span class="koboSpan" id="kobo.2337.2">In this recipe, we will see what these standard algorithms are and how they can be used.</span></p>
<h2 class="heading-2" id="_idParaDest-283"><span class="koboSpan" id="kobo.2338.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2339.1">For all the examples in this recipe, we will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2340.1">std::vector</span></code><span class="koboSpan" id="kobo.2341.1">, but all the algorithms work with ranges defined by a begin and past-the-end, either input or forward iterators, depending on the algorithm (for more information about the various types of iterators, see the </span><em class="italic"><span class="koboSpan" id="kobo.2342.1">Writing your own random access iterator</span></em><span class="koboSpan" id="kobo.2343.1"> recipe, later in this chapter). </span><span class="koboSpan" id="kobo.2343.2">All these algorithms are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2344.1">std</span></code><span class="koboSpan" id="kobo.2345.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2346.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.2347.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-284"><span class="koboSpan" id="kobo.2348.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2349.1">The </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.2350.1">following is a list of algorithms that can be used for finding</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.2351.1"> elements in a range:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2352.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2353.1">std::find()</span></code><span class="koboSpan" id="kobo.2354.1"> to find a value in a range; this algorithm returns an iterator to the first element equal to the value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2355.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2356.1">int</span></span><span class="koboSpan" id="kobo.2357.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2358.1">13</span></span><span class="koboSpan" id="kobo.2359.1">, 1, 5, 3, 2, 8, 1 };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2360.1">auto</span></span><span class="koboSpan" id="kobo.2361.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2362.1">find</span></span><span class="koboSpan" id="kobo.2363.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2364.1">cbegin</span></span><span class="koboSpan" id="kobo.2365.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2366.1">cend</span></span><span class="koboSpan" id="kobo.2367.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2368.1">3</span></span><span class="koboSpan" id="kobo.2369.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2370.1">if</span></span><span class="koboSpan" id="kobo.2371.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2372.1">cend</span></span><span class="koboSpan" id="kobo.2373.1">()) std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2374.1">'\n'</span></span><span class="koboSpan" id="kobo.2375.1">; // prints 3
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2376.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2377.1">std::find_if()</span></code><span class="koboSpan" id="kobo.2378.1"> to find a value in a range that meets a criterion from a unary predicate; this algorithm returns an iterator to the first element for which the predicate returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2379.1">true</span></code><span class="koboSpan" id="kobo.2380.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2381.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2382.1">int</span></span><span class="koboSpan" id="kobo.2383.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2384.1">13</span></span><span class="koboSpan" id="kobo.2385.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2386.1">1</span></span><span class="koboSpan" id="kobo.2387.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2388.1">5</span></span><span class="koboSpan" id="kobo.2389.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2390.1">3</span></span><span class="koboSpan" id="kobo.2391.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2392.1">2</span></span><span class="koboSpan" id="kobo.2393.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2394.1">8</span></span><span class="koboSpan" id="kobo.2395.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2396.1">1</span></span><span class="koboSpan" id="kobo.2397.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2398.1">auto</span></span><span class="koboSpan" id="kobo.2399.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2400.1">find_if</span></span><span class="koboSpan" id="kobo.2401.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2402.1">cbegin</span></span><span class="koboSpan" id="kobo.2403.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2404.1">cend</span></span><span class="koboSpan" id="kobo.2405.1">(),
                       [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.2406.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2407.1">const</span></span><span class="koboSpan" id="kobo.2408.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2409.1">return</span></span><span class="koboSpan" id="kobo.2410.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2411.1">10</span></span><span class="koboSpan" id="kobo.2412.1">; });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2413.1">if</span></span><span class="koboSpan" id="kobo.2414.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2415.1">cend</span></span><span class="koboSpan" id="kobo.2416.1">()) std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2417.1">'\n'</span></span><span class="koboSpan" id="kobo.2418.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2419.1">// prints 13</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2420.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2421.1">std::find_if_not()</span></code><span class="koboSpan" id="kobo.2422.1"> to find a value in a range that does not meet a criterion from a unary predicate; this algorithm returns an iterator to the first element for which the predicate returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2423.1">false</span></code><span class="koboSpan" id="kobo.2424.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2425.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2426.1">int</span></span><span class="koboSpan" id="kobo.2427.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2428.1">13</span></span><span class="koboSpan" id="kobo.2429.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2430.1">1</span></span><span class="koboSpan" id="kobo.2431.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2432.1">5</span></span><span class="koboSpan" id="kobo.2433.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2434.1">3</span></span><span class="koboSpan" id="kobo.2435.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2436.1">2</span></span><span class="koboSpan" id="kobo.2437.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2438.1">8</span></span><span class="koboSpan" id="kobo.2439.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2440.1">1</span></span><span class="koboSpan" id="kobo.2441.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2442.1">auto</span></span><span class="koboSpan" id="kobo.2443.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2444.1">find_if_not</span></span><span class="koboSpan" id="kobo.2445.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2446.1">cbegin</span></span><span class="koboSpan" id="kobo.2447.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2448.1">cend</span></span><span class="koboSpan" id="kobo.2449.1">(),
                    [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.2450.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2451.1">const</span></span><span class="koboSpan" id="kobo.2452.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2453.1">return</span></span><span class="koboSpan" id="kobo.2454.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.2455.1">2</span></span><span class="koboSpan" id="kobo.2456.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2457.1">1</span></span><span class="koboSpan" id="kobo.2458.1">; });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2459.1">if</span></span><span class="koboSpan" id="kobo.2460.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2461.1">cend</span></span><span class="koboSpan" id="kobo.2462.1">()) std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2463.1">'\n'</span></span><span class="koboSpan" id="kobo.2464.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2465.1">// prints 2</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2466.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2467.1">std::find_first_of()</span></code><span class="koboSpan" id="kobo.2468.1"> to search for the occurrence of any value from a range in another range; this algorithm returns an iterator to the first element that is found:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2469.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2470.1">int</span></span><span class="koboSpan" id="kobo.2471.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2472.1">13</span></span><span class="koboSpan" id="kobo.2473.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2474.1">1</span></span><span class="koboSpan" id="kobo.2475.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2476.1">5</span></span><span class="koboSpan" id="kobo.2477.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2478.1">3</span></span><span class="koboSpan" id="kobo.2479.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2480.1">2</span></span><span class="koboSpan" id="kobo.2481.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2482.1">8</span></span><span class="koboSpan" id="kobo.2483.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2484.1">1</span></span><span class="koboSpan" id="kobo.2485.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2486.1">int</span></span><span class="koboSpan" id="kobo.2487.1">&gt; p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2488.1">5</span></span><span class="koboSpan" id="kobo.2489.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2490.1">7</span></span><span class="koboSpan" id="kobo.2491.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2492.1">11</span></span><span class="koboSpan" id="kobo.2493.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2494.1">auto</span></span><span class="koboSpan" id="kobo.2495.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2496.1">find_first_of</span></span><span class="koboSpan" id="kobo.2497.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2498.1">cbegin</span></span><span class="koboSpan" id="kobo.2499.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2500.1">cend</span></span><span class="koboSpan" id="kobo.2501.1">(),
                             p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2502.1">cbegin</span></span><span class="koboSpan" id="kobo.2503.1">(), p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2504.1">cend</span></span><span class="koboSpan" id="kobo.2505.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2506.1">if</span></span><span class="koboSpan" id="kobo.2507.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2508.1">cend</span></span><span class="koboSpan" id="kobo.2509.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2510.1">"found "</span></span><span class="koboSpan" id="kobo.2511.1"> &lt;&lt; *it
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2512.1">" at index "</span></span><span class="koboSpan" id="kobo.2513.1"> &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2514.1">distance</span></span><span class="koboSpan" id="kobo.2515.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2516.1">cbegin</span></span><span class="koboSpan" id="kobo.2517.1">(), it)
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2518.1">'\n'</span></span><span class="koboSpan" id="kobo.2519.1">; 
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2520.1">// found 5 at index 2</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2521.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2522.1">std::find_end()</span></code><span class="koboSpan" id="kobo.2523.1"> to find the last occurrence of a subrange of elements in a </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.2524.1">range; this algorithm returns an iterator</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.2525.1"> to the first element of the last subrange in the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2526.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2527.1">int</span></span><span class="koboSpan" id="kobo.2528.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2529.1">1</span></span><span class="koboSpan" id="kobo.2530.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2531.1">1</span></span><span class="koboSpan" id="kobo.2532.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2533.1">0</span></span><span class="koboSpan" id="kobo.2534.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2535.1">0</span></span><span class="koboSpan" id="kobo.2536.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2537.1">1</span></span><span class="koboSpan" id="kobo.2538.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2539.1">0</span></span><span class="koboSpan" id="kobo.2540.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2541.1">1</span></span><span class="koboSpan" id="kobo.2542.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2543.1">0</span></span><span class="koboSpan" id="kobo.2544.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2545.1">1</span></span><span class="koboSpan" id="kobo.2546.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2547.1">0</span></span><span class="koboSpan" id="kobo.2548.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2549.1">1</span></span><span class="koboSpan" id="kobo.2550.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2551.1">1</span></span><span class="koboSpan" id="kobo.2552.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2553.1">int</span></span><span class="koboSpan" id="kobo.2554.1">&gt; v2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2555.1">1</span></span><span class="koboSpan" id="kobo.2556.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2557.1">0</span></span><span class="koboSpan" id="kobo.2558.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2559.1">1</span></span><span class="koboSpan" id="kobo.2560.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2561.1">auto</span></span><span class="koboSpan" id="kobo.2562.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2563.1">find_end</span></span><span class="koboSpan" id="kobo.2564.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2565.1">cbegin</span></span><span class="koboSpan" id="kobo.2566.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2567.1">cend</span></span><span class="koboSpan" id="kobo.2568.1">(),
                        v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2569.1">cbegin</span></span><span class="koboSpan" id="kobo.2570.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2571.1">cend</span></span><span class="koboSpan" id="kobo.2572.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2573.1">if</span></span><span class="koboSpan" id="kobo.2574.1"> (it != v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2575.1">cend</span></span><span class="koboSpan" id="kobo.2576.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2577.1">"found at index "</span></span><span class="koboSpan" id="kobo.2578.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2579.1">distance</span></span><span class="koboSpan" id="kobo.2580.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2581.1">cbegin</span></span><span class="koboSpan" id="kobo.2582.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2583.1">'\n'</span></span><span class="koboSpan" id="kobo.2584.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2585.1">// found at index 8</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2586.1">To find the minimum and the maximum elements in a range, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2587.1">std::min_element()</span></code><span class="koboSpan" id="kobo.2588.1"> for the minimum, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2589.1">std::max_element()</span></code><span class="koboSpan" id="kobo.2590.1"> for the maximum, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2591.1">std::minmax_element()</span></code><span class="koboSpan" id="kobo.2592.1"> for both the minimum and the maximum:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2593.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2594.1">int</span></span><span class="koboSpan" id="kobo.2595.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2596.1">1</span></span><span class="koboSpan" id="kobo.2597.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2598.1">5</span></span><span class="koboSpan" id="kobo.2599.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2600.1">-2</span></span><span class="koboSpan" id="kobo.2601.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2602.1">9</span></span><span class="koboSpan" id="kobo.2603.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2604.1">6</span></span><span class="koboSpan" id="kobo.2605.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2606.1">auto</span></span><span class="koboSpan" id="kobo.2607.1"> minit = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2608.1">min_element</span></span><span class="koboSpan" id="kobo.2609.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2610.1">begin</span></span><span class="koboSpan" id="kobo.2611.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2612.1">end</span></span><span class="koboSpan" id="kobo.2613.1">());
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2614.1">"min="</span></span><span class="koboSpan" id="kobo.2615.1"> &lt;&lt; *minit &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2616.1">'\n'</span></span><span class="koboSpan" id="kobo.2617.1">;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2618.1">// min=-2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2619.1">auto</span></span><span class="koboSpan" id="kobo.2620.1"> maxit = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2621.1">max_element</span></span><span class="koboSpan" id="kobo.2622.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2623.1">begin</span></span><span class="koboSpan" id="kobo.2624.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2625.1">end</span></span><span class="koboSpan" id="kobo.2626.1">());
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2627.1">"max="</span></span><span class="koboSpan" id="kobo.2628.1"> &lt;&lt; *maxit &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2629.1">'\n'</span></span><span class="koboSpan" id="kobo.2630.1">;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2631.1">// max=9</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2632.1">auto</span></span><span class="koboSpan" id="kobo.2633.1"> minmaxit = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2634.1">minmax_element</span></span><span class="koboSpan" id="kobo.2635.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2636.1">begin</span></span><span class="koboSpan" id="kobo.2637.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2638.1">end</span></span><span class="koboSpan" id="kobo.2639.1">());
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2640.1">"min="</span></span><span class="koboSpan" id="kobo.2641.1"> &lt;&lt; *minmaxit.first &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2642.1">'\n'</span></span><span class="koboSpan" id="kobo.2643.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2644.1">// min=-2</span></span><span class="koboSpan" id="kobo.2645.1">
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2646.1">"max="</span></span><span class="koboSpan" id="kobo.2647.1"> &lt;&lt; *minmaxit.second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2648.1">'\n'</span></span><span class="koboSpan" id="kobo.2649.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2650.1">// max=9</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2651.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2652.1">std::search()</span></code><span class="koboSpan" id="kobo.2653.1"> to search for the first occurrence of a subrange in a range; this algorithm returns an iterator to the first element of the subrange in the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2654.1">auto</span></span><span class="koboSpan" id="kobo.2655.1"> text = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2656.1">"The quick brown fox jumps over the lazy dog"</span></span><span class="koboSpan" id="kobo.2657.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2658.1">auto</span></span><span class="koboSpan" id="kobo.2659.1"> word = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2660.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2661.1">over"</span></span><span class="koboSpan" id="kobo.2662.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2663.1">auto</span></span><span class="koboSpan" id="kobo.2664.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2665.1">search</span></span><span class="koboSpan" id="kobo.2666.1">(text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2667.1">cbegin</span></span><span class="koboSpan" id="kobo.2668.1">(), text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2669.1">cend</span></span><span class="koboSpan" id="kobo.2670.1">(),
                      word.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2671.1">cbegin</span></span><span class="koboSpan" id="kobo.2672.1">(), word.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2673.1">cend</span></span><span class="koboSpan" id="kobo.2674.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2675.1">if</span></span><span class="koboSpan" id="kobo.2676.1"> (it != text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2677.1">cend</span></span><span class="koboSpan" id="kobo.2678.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2679.1">"found "</span></span><span class="koboSpan" id="kobo.2680.1"> &lt;&lt; word
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2681.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2682.1"> at index "</span></span><span class="koboSpan" id="kobo.2683.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2684.1">distance</span></span><span class="koboSpan" id="kobo.2685.1">(text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2686.1">cbegin</span></span><span class="koboSpan" id="kobo.2687.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2688.1">'\n'</span></span><span class="koboSpan" id="kobo.2689.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2690.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2691.1">std::search()</span></code><span class="koboSpan" id="kobo.2692.1"> with a </span><em class="italic"><span class="koboSpan" id="kobo.2693.1">searcher</span></em><span class="koboSpan" id="kobo.2694.1">, which is a class that implements a searching </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.2695.1">algorithm and meets some predefined </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.2696.1">criteria. </span><span class="koboSpan" id="kobo.2696.2">This overload of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2697.1">std::search()</span></code><span class="koboSpan" id="kobo.2698.1"> was introduced in C++17, and available standard searchers implement the </span><em class="italic"><span class="koboSpan" id="kobo.2699.1">Boyer-Moore</span></em><span class="koboSpan" id="kobo.2700.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.2701.1">Boyer-Moore-Horspool</span></em><span class="koboSpan" id="kobo.2702.1"> string searching algorithms:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2703.1">auto</span></span><span class="koboSpan" id="kobo.2704.1"> text = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2705.1">"The quick brown fox jumps over the lazy dog"</span></span><span class="koboSpan" id="kobo.2706.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2707.1">auto</span></span><span class="koboSpan" id="kobo.2708.1"> word = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2709.1">"over"</span></span><span class="koboSpan" id="kobo.2710.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2711.1">auto</span></span><span class="koboSpan" id="kobo.2712.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2713.1">search</span></span><span class="koboSpan" id="kobo.2714.1">(
  text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2715.1">cbegin</span></span><span class="koboSpan" id="kobo.2716.1">(), text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2717.1">cend</span></span><span class="koboSpan" id="kobo.2718.1">(),
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2719.1">make_boyer_moore_searcher</span></span><span class="koboSpan" id="kobo.2720.1">(word.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2721.1">cbegin</span></span><span class="koboSpan" id="kobo.2722.1">(), word.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2723.1">cend</span></span><span class="koboSpan" id="kobo.2724.1">()));
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2725.1">if</span></span><span class="koboSpan" id="kobo.2726.1"> (it != text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2727.1">cend</span></span><span class="koboSpan" id="kobo.2728.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2729.1">"found "</span></span><span class="koboSpan" id="kobo.2730.1"> &lt;&lt; word
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2731.1">" at index "</span></span><span class="koboSpan" id="kobo.2732.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2733.1">distance</span></span><span class="koboSpan" id="kobo.2734.1">(text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2735.1">cbegin</span></span><span class="koboSpan" id="kobo.2736.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2737.1">'\n'</span></span><span class="koboSpan" id="kobo.2738.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2739.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2740.1">std::search_n()</span></code><span class="koboSpan" id="kobo.2741.1"> to search for </span><em class="italic"><span class="koboSpan" id="kobo.2742.1">N</span></em><span class="koboSpan" id="kobo.2743.1"> consecutive occurrences of a value in a range; this algorithm returns an iterator to the first element of the found sequence in the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2744.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2745.1">int</span></span><span class="koboSpan" id="kobo.2746.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2747.1">1</span></span><span class="koboSpan" id="kobo.2748.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2749.1">1</span></span><span class="koboSpan" id="kobo.2750.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2751.1">0</span></span><span class="koboSpan" id="kobo.2752.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2753.1">0</span></span><span class="koboSpan" id="kobo.2754.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2755.1">1</span></span><span class="koboSpan" id="kobo.2756.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2757.1">0</span></span><span class="koboSpan" id="kobo.2758.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2759.1">1</span></span><span class="koboSpan" id="kobo.2760.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2761.1">0</span></span><span class="koboSpan" id="kobo.2762.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2763.1">1</span></span><span class="koboSpan" id="kobo.2764.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2765.1">0</span></span><span class="koboSpan" id="kobo.2766.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2767.1">1</span></span><span class="koboSpan" id="kobo.2768.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2769.1">1</span></span><span class="koboSpan" id="kobo.2770.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2771.1">auto</span></span><span class="koboSpan" id="kobo.2772.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2773.1">search_n</span></span><span class="koboSpan" id="kobo.2774.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2775.1">cbegin</span></span><span class="koboSpan" id="kobo.2776.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2777.1">cend</span></span><span class="koboSpan" id="kobo.2778.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2779.1">2</span></span><span class="koboSpan" id="kobo.2780.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2781.1">0</span></span><span class="koboSpan" id="kobo.2782.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2783.1">if</span></span><span class="koboSpan" id="kobo.2784.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2785.1">cend</span></span><span class="koboSpan" id="kobo.2786.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2787.1">"found at index "</span></span><span class="koboSpan" id="kobo.2788.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2789.1">distance</span></span><span class="koboSpan" id="kobo.2790.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2791.1">cbegin</span></span><span class="koboSpan" id="kobo.2792.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2793.1">'\n'</span></span><span class="koboSpan" id="kobo.2794.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2795.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2796.1">std::adjacent_find()</span></code><span class="koboSpan" id="kobo.2797.1"> to find two adjacent elements in a range that are </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.2798.1">equal or satisfy a binary predicate; this algorithm</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.2799.1"> returns an iterator to the first element that is found:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2800.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2801.1">int</span></span><span class="koboSpan" id="kobo.2802.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2803.1">1</span></span><span class="koboSpan" id="kobo.2804.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2805.1">1</span></span><span class="koboSpan" id="kobo.2806.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2807.1">2</span></span><span class="koboSpan" id="kobo.2808.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2809.1">3</span></span><span class="koboSpan" id="kobo.2810.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2811.1">5</span></span><span class="koboSpan" id="kobo.2812.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2813.1">8</span></span><span class="koboSpan" id="kobo.2814.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2815.1">13</span></span><span class="koboSpan" id="kobo.2816.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2817.1">auto</span></span><span class="koboSpan" id="kobo.2818.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2819.1">adjacent_find</span></span><span class="koboSpan" id="kobo.2820.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2821.1">cbegin</span></span><span class="koboSpan" id="kobo.2822.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2823.1">cend</span></span><span class="koboSpan" id="kobo.2824.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2825.1">if</span></span><span class="koboSpan" id="kobo.2826.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2827.1">cend</span></span><span class="koboSpan" id="kobo.2828.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2829.1">"found at index "</span></span><span class="koboSpan" id="kobo.2830.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2831.1">distance</span></span><span class="koboSpan" id="kobo.2832.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2833.1">cbegin</span></span><span class="koboSpan" id="kobo.2834.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2835.1">'\n'</span></span><span class="koboSpan" id="kobo.2836.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2837.1">auto</span></span><span class="koboSpan" id="kobo.2838.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2839.1">adjacent_find</span></span><span class="koboSpan" id="kobo.2840.1">(
  v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2841.1">cbegin</span></span><span class="koboSpan" id="kobo.2842.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2843.1">cend</span></span><span class="koboSpan" id="kobo.2844.1">(),
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.2845.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2846.1">const</span></span><span class="koboSpan" id="kobo.2847.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2848.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2849.1">const</span></span><span class="koboSpan" id="kobo.2850.1"> b) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2851.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2852.1">IsPrime</span></span><span class="koboSpan" id="kobo.2853.1">(a) &amp;&amp; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2854.1">IsPrime</span></span><span class="koboSpan" id="kobo.2855.1">(b); });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2856.1">if</span></span><span class="koboSpan" id="kobo.2857.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2858.1">cend</span></span><span class="koboSpan" id="kobo.2859.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2860.1">"found at index "</span></span><span class="koboSpan" id="kobo.2861.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2862.1">distance</span></span><span class="koboSpan" id="kobo.2863.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2864.1">cbegin</span></span><span class="koboSpan" id="kobo.2865.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2866.1">'\n'</span></span><span class="koboSpan" id="kobo.2867.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2868.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2869.1">std::binary_search()</span></code><span class="koboSpan" id="kobo.2870.1"> to find whether an element exists in a sorted range; this algorithm returns a Boolean value to indicate whether the value was found or not:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2871.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2872.1">int</span></span><span class="koboSpan" id="kobo.2873.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2874.1">1</span></span><span class="koboSpan" id="kobo.2875.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2876.1">1</span></span><span class="koboSpan" id="kobo.2877.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2878.1">2</span></span><span class="koboSpan" id="kobo.2879.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2880.1">3</span></span><span class="koboSpan" id="kobo.2881.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2882.1">5</span></span><span class="koboSpan" id="kobo.2883.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2884.1">8</span></span><span class="koboSpan" id="kobo.2885.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2886.1">13</span></span><span class="koboSpan" id="kobo.2887.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2888.1">auto</span></span><span class="koboSpan" id="kobo.2889.1"> success = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2890.1">binary_search</span></span><span class="koboSpan" id="kobo.2891.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2892.1">cbegin</span></span><span class="koboSpan" id="kobo.2893.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2894.1">cend</span></span><span class="koboSpan" id="kobo.2895.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2896.1">8</span></span><span class="koboSpan" id="kobo.2897.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2898.1">if</span></span><span class="koboSpan" id="kobo.2899.1"> (success) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2900.1">"found"</span></span><span class="koboSpan" id="kobo.2901.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2902.1">'\n'</span></span><span class="koboSpan" id="kobo.2903.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2904.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2905.1">std::lower_bound()</span></code><span class="koboSpan" id="kobo.2906.1"> to find the first element in a range not less than a specified value; this algorithm returns an iterator to the element:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2907.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2908.1">int</span></span><span class="koboSpan" id="kobo.2909.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2910.1">1</span></span><span class="koboSpan" id="kobo.2911.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2912.1">1</span></span><span class="koboSpan" id="kobo.2913.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2914.1">2</span></span><span class="koboSpan" id="kobo.2915.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2916.1">3</span></span><span class="koboSpan" id="kobo.2917.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2918.1">5</span></span><span class="koboSpan" id="kobo.2919.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2920.1">8</span></span><span class="koboSpan" id="kobo.2921.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2922.1">13</span></span><span class="koboSpan" id="kobo.2923.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2924.1">auto</span></span><span class="koboSpan" id="kobo.2925.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2926.1">lower_bound</span></span><span class="koboSpan" id="kobo.2927.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2928.1">cbegin</span></span><span class="koboSpan" id="kobo.2929.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2930.1">cend</span></span><span class="koboSpan" id="kobo.2931.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2932.1">1</span></span><span class="koboSpan" id="kobo.2933.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2934.1">if</span></span><span class="koboSpan" id="kobo.2935.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2936.1">cend</span></span><span class="koboSpan" id="kobo.2937.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2938.1">"lower bound at "</span></span><span class="koboSpan" id="kobo.2939.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2940.1">distance</span></span><span class="koboSpan" id="kobo.2941.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2942.1">cbegin</span></span><span class="koboSpan" id="kobo.2943.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2944.1">'\n'</span></span><span class="koboSpan" id="kobo.2945.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2946.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2947.1">std::upper_bound()</span></code><span class="koboSpan" id="kobo.2948.1"> to find the first element in a range greater than a specified value; this algorithm returns an iterator to the element:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2949.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2950.1">int</span></span><span class="koboSpan" id="kobo.2951.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2952.1">1</span></span><span class="koboSpan" id="kobo.2953.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2954.1">1</span></span><span class="koboSpan" id="kobo.2955.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2956.1">2</span></span><span class="koboSpan" id="kobo.2957.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2958.1">3</span></span><span class="koboSpan" id="kobo.2959.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2960.1">5</span></span><span class="koboSpan" id="kobo.2961.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2962.1">8</span></span><span class="koboSpan" id="kobo.2963.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2964.1">13</span></span><span class="koboSpan" id="kobo.2965.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2966.1">auto</span></span><span class="koboSpan" id="kobo.2967.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2968.1">upper_bound</span></span><span class="koboSpan" id="kobo.2969.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2970.1">cbegin</span></span><span class="koboSpan" id="kobo.2971.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2972.1">cend</span></span><span class="koboSpan" id="kobo.2973.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2974.1">1</span></span><span class="koboSpan" id="kobo.2975.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2976.1">if</span></span><span class="koboSpan" id="kobo.2977.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2978.1">cend</span></span><span class="koboSpan" id="kobo.2979.1">())
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2980.1">"upper bound at "</span></span><span class="koboSpan" id="kobo.2981.1">
            &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2982.1">distance</span></span><span class="koboSpan" id="kobo.2983.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2984.1">cbegin</span></span><span class="koboSpan" id="kobo.2985.1">(), it) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2986.1">'\n'</span></span><span class="koboSpan" id="kobo.2987.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2988.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2989.1">std::equal_range()</span></code><span class="koboSpan" id="kobo.2990.1"> to find a subrange in a range whose values are equal to </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.2991.1">a specified value. </span><span class="koboSpan" id="kobo.2991.2">This algorithm returns a pair of iterators defining the first and the one-past-end iterators to the subrange; these two iterators are equivalent to those returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2992.1">std::lower_bound()</span></code><span class="koboSpan" id="kobo.2993.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2994.1">std::upper_bound()</span></code><span class="koboSpan" id="kobo.2995.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2996.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2997.1">int</span></span><span class="koboSpan" id="kobo.2998.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2999.1">1</span></span><span class="koboSpan" id="kobo.3000.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3001.1">1</span></span><span class="koboSpan" id="kobo.3002.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3003.1">2</span></span><span class="koboSpan" id="kobo.3004.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3005.1">3</span></span><span class="koboSpan" id="kobo.3006.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3007.1">5</span></span><span class="koboSpan" id="kobo.3008.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3009.1">8</span></span><span class="koboSpan" id="kobo.3010.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3011.1">13</span></span><span class="koboSpan" id="kobo.3012.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3013.1">auto</span></span><span class="koboSpan" id="kobo.3014.1"> bounds = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3015.1">equal_range</span></span><span class="koboSpan" id="kobo.3016.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3017.1">cbegin</span></span><span class="koboSpan" id="kobo.3018.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3019.1">cend</span></span><span class="koboSpan" id="kobo.3020.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3021.1">1</span></span><span class="koboSpan" id="kobo.3022.1">);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3023.1">"range between indexes "</span></span><span class="koboSpan" id="kobo.3024.1">
          &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3025.1">distance</span></span><span class="koboSpan" id="kobo.3026.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3027.1">cbegin</span></span><span class="koboSpan" id="kobo.3028.1">(), bounds.first)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3029.1">" and "</span></span><span class="koboSpan" id="kobo.3030.1">
          &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3031.1">distance</span></span><span class="koboSpan" id="kobo.3032.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3033.1">cbegin</span></span><span class="koboSpan" id="kobo.3034.1">(), bounds.second)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3035.1">'\n'</span></span><span class="koboSpan" id="kobo.3036.1">;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-285"><span class="koboSpan" id="kobo.3037.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3038.1">The </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.3039.1">way these algorithms work is very similar: they all take, as arguments, iterators that define the searchable range and additional arguments that depend on each algorithm. </span><span class="koboSpan" id="kobo.3039.2">With the exception of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3040.1">std::binary_search()</span></code><span class="koboSpan" id="kobo.3041.1">, which returns a Boolean, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3042.1">std::equal_range()</span></code><span class="koboSpan" id="kobo.3043.1">, which returns a pair of iterators, they all return an iterator to the searched element or to a subrange. </span><span class="koboSpan" id="kobo.3043.2">These iterators must be compared with the end iterator (that is, the past-last-element) of the range to check whether the search was successful or not. </span><span class="koboSpan" id="kobo.3043.3">If the search did not find an element or a subrange, then the returned value is the end iterator.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3044.1">All these algorithms have multiple overloads, but in the </span><em class="italic"><span class="koboSpan" id="kobo.3045.1">How to do it...</span></em><span class="koboSpan" id="kobo.3046.1"> section, we only looked at one particular overload to show how the algorithm can be used. </span><span class="koboSpan" id="kobo.3046.2">For a complete reference of all overloads, you should see other sources, such as </span><a href="https://en.cppreference.com/w/cpp/algorithm"><span class="url"><span class="koboSpan" id="kobo.3047.1">https://en.cppreference.com/w/cpp/algorithm</span></span></a><span class="koboSpan" id="kobo.3048.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3049.1">In all the preceding examples, we used constant iterators, but all these algorithms work the same with mutable iterators and with reverse iterators. </span><span class="koboSpan" id="kobo.3049.2">Because they take iterators as input arguments, they can work with standard containers, arrays, or anything that represents a sequence and has iterators available.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3050.1">A </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.3051.1">special note on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3052.1">std::binary_search()</span></code><span class="koboSpan" id="kobo.3053.1"> algorithm is necessary: the iterator parameters that define the range to search in should at least meet the requirements of the forward iterators. </span><span class="koboSpan" id="kobo.3053.2">Regardless of the type of the supplied iterators, the number of comparisons is always logarithmic on the size of the range. </span><span class="koboSpan" id="kobo.3053.3">However, the number of iterator increments is different if the iterators are random access, in which case the number of increments is also logarithmic, or are not random access, in which case it is linear and proportional to the size of the range.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3054.1">All these</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.3055.1"> algorithms, except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3056.1">std::find_if_not()</span></code><span class="koboSpan" id="kobo.3057.1">, were available before C++11. </span><span class="koboSpan" id="kobo.3057.2">However, some overloads of them have been introduced in the newer standards. </span><span class="koboSpan" id="kobo.3057.3">An example is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3058.1">std::search()</span></code><span class="koboSpan" id="kobo.3059.1">, which has several overloads that were introduced in C++17. </span><span class="koboSpan" id="kobo.3059.2">One of these overloads has the following form:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3060.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3061.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3062.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3063.1"> ForwardIterator, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3064.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3065.1"> Searcher&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3066.1">ForwardIterator </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3067.1">search</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3068.1">(ForwardIterator first, ForwardIterator last,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3069.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3070.1"> Searcher&amp; searcher )</span></span><span class="koboSpan" id="kobo.3071.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3072.1">This overload searches for the occurrence of a pattern defined by a searcher function object for which the standard provides several implementations:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3073.1">default_searcher</span></code><span class="koboSpan" id="kobo.3074.1"> basically delegates the searching to the standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.3075.1">std::search()</span></code><span class="koboSpan" id="kobo.3076.1"> algorithm.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3077.1">boyer_moore_searcher</span></code><span class="koboSpan" id="kobo.3078.1"> implements the Boyer-Moore algorithm for string searching.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3079.1">boyer_moore_horspool_algorithm</span></code><span class="koboSpan" id="kobo.3080.1"> implements the Boyer-Moore-Horspool algorithm for string searching.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3081.1">Many standard containers have a member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.3082.1">find()</span></code><span class="koboSpan" id="kobo.3083.1"> for finding elements in the container. </span><span class="koboSpan" id="kobo.3083.2">When such a method is available and suits your needs, it should be preferred to the general algorithms because these member functions are optimized based on the particularities of each container.</span></p>
<h2 class="heading-2" id="_idParaDest-286"><span class="koboSpan" id="kobo.3084.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3085.1">Using vector as a default container</span></em><span class="koboSpan" id="kobo.3086.1">, to see how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3087.1">std::vector</span></code><span class="koboSpan" id="kobo.3088.1"> standard container</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3089.1">Initializing a range</span></em><span class="koboSpan" id="kobo.3090.1">, to explore the standard algorithms for filling a range with values</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3091.1">Using set operations on a range</span></em><span class="koboSpan" id="kobo.3092.1">, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3093.1">Sorting a range</span></em><span class="koboSpan" id="kobo.3094.1">, to learn about the standard algorithms for sorting ranges</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-287"><span class="koboSpan" id="kobo.3095.1">Sorting a range</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3096.1">In the </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.3097.1">previous recipe, we looked at the standard general algorithms for searching in a range. </span><span class="koboSpan" id="kobo.3097.2">Another common operation we often need to do is sorting a range because many routines, including some of the algorithms for searching, require a sorted range. </span><span class="koboSpan" id="kobo.3097.3">The standard library provides several general algorithms for sorting ranges, and in this recipe, we will see what these algorithms are and how they can be used.</span></p>
<h2 class="heading-2" id="_idParaDest-288"><span class="koboSpan" id="kobo.3098.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3099.1">The sorting general algorithms work with ranges defined by a start and end iterator and, therefore, can sort standard containers, arrays, or anything that represents a sequence and has random iterators available. </span><span class="koboSpan" id="kobo.3099.2">However, all the examples in this recipe will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3100.1">std::vector</span></code><span class="koboSpan" id="kobo.3101.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-289"><span class="koboSpan" id="kobo.3102.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3103.1">The following is a list of standard general algorithms for searching a range:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3104.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3105.1">std::sort()</span></code><span class="koboSpan" id="kobo.3106.1"> for sorting a range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3107.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3108.1">int</span></span><span class="koboSpan" id="kobo.3109.1">&gt; v{</span><span class="hljs-number"><span class="koboSpan" id="kobo.3110.1">3</span></span><span class="koboSpan" id="kobo.3111.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3112.1">13</span></span><span class="koboSpan" id="kobo.3113.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3114.1">5</span></span><span class="koboSpan" id="kobo.3115.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3116.1">8</span></span><span class="koboSpan" id="kobo.3117.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3118.1">1</span></span><span class="koboSpan" id="kobo.3119.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3120.1">2</span></span><span class="koboSpan" id="kobo.3121.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3122.1">1</span></span><span class="koboSpan" id="kobo.3123.1">};
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3124.1">sort</span></span><span class="koboSpan" id="kobo.3125.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3126.1">begin</span></span><span class="koboSpan" id="kobo.3127.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3128.1">end</span></span><span class="koboSpan" id="kobo.3129.1">());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3130.1">// v = {1, 1, 2, 3, 5, 8, 13}</span></span><span class="koboSpan" id="kobo.3131.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3132.1">sort</span></span><span class="koboSpan" id="kobo.3133.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3134.1">begin</span></span><span class="koboSpan" id="kobo.3135.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3136.1">end</span></span><span class="koboSpan" id="kobo.3137.1">(), std::greater&lt;&gt;());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3138.1">// v = {13, 8, 5, 3, 2, 1, 1}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3139.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3140.1">std::stable_sort()</span></code><span class="koboSpan" id="kobo.3141.1"> for sorting a range but keeping the order of the equal elements:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3142.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3143.1">Task</span></span><span class="koboSpan" id="kobo.3144.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3145.1">int</span></span><span class="koboSpan" id="kobo.3146.1"> priority;
  std::string name;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3147.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3148.1">operator</span></span><span class="koboSpan" id="kobo.3149.1">&lt;(Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.3150.1">const</span></span><span class="koboSpan" id="kobo.3151.1"> &amp; lhs, Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.3152.1">const</span></span><span class="koboSpan" id="kobo.3153.1"> &amp; rhs) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3154.1">return</span></span><span class="koboSpan" id="kobo.3155.1"> lhs.priority &lt; rhs.priority;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3156.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3157.1">operator</span></span><span class="koboSpan" id="kobo.3158.1">&gt;(Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.3159.1">const</span></span><span class="koboSpan" id="kobo.3160.1"> &amp; lhs, Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.3161.1">const</span></span><span class="koboSpan" id="kobo.3162.1"> &amp; rhs) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3163.1">return</span></span><span class="koboSpan" id="kobo.3164.1"> lhs.priority &gt; rhs.priority;
}
std::vector&lt;Task&gt; v{
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3165.1">10</span></span><span class="koboSpan" id="kobo.3166.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3167.1">"Task 1"</span></span><span class="koboSpan" id="kobo.3168.1">s }, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3169.1">40</span></span><span class="koboSpan" id="kobo.3170.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3171.1">"Task 2"</span></span><span class="koboSpan" id="kobo.3172.1">s }, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3173.1">25</span></span><span class="koboSpan" id="kobo.3174.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3175.1">"Task 3"</span></span><span class="koboSpan" id="kobo.3176.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3177.1">10</span></span><span class="koboSpan" id="kobo.3178.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3179.1">"Task 4"</span></span><span class="koboSpan" id="kobo.3180.1">s }, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3181.1">80</span></span><span class="koboSpan" id="kobo.3182.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3183.1">"Task 5"</span></span><span class="koboSpan" id="kobo.3184.1">s }, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3185.1">10</span></span><span class="koboSpan" id="kobo.3186.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3187.1">"Task 6"</span></span><span class="koboSpan" id="kobo.3188.1">s },
};
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3189.1">stable_sort</span></span><span class="koboSpan" id="kobo.3190.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3191.1">begin</span></span><span class="koboSpan" id="kobo.3192.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3193.1">end</span></span><span class="koboSpan" id="kobo.3194.1">());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3195.1">// {{ 10, "Task 1" },{ 10, "Task 4" },{ 10, "Task 6" },</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3196.1">//  { 25, "Task 3" },{ 40, "Task 2" },{ 80, "Task 5" }}</span></span><span class="koboSpan" id="kobo.3197.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3198.1">stable_sort</span></span><span class="koboSpan" id="kobo.3199.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3200.1">begin</span></span><span class="koboSpan" id="kobo.3201.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3202.1">end</span></span><span class="koboSpan" id="kobo.3203.1">(), std::greater&lt;&gt;());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3204.1">// {{ 80, "Task 5" },{ 40, "Task 2" },{ 25, "Task 3" },</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3205.1">//  { 10, "Task 1" },{ 10, "Task 4" },{ 10, "Task 6" }}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3206.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3207.1">std::partial_sort()</span></code><span class="koboSpan" id="kobo.3208.1"> for sorting a</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.3209.1"> part of a range (and leaving the rest in an unspecified order):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3210.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3211.1">int</span></span><span class="koboSpan" id="kobo.3212.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3213.1">3</span></span><span class="koboSpan" id="kobo.3214.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3215.1">13</span></span><span class="koboSpan" id="kobo.3216.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3217.1">5</span></span><span class="koboSpan" id="kobo.3218.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3219.1">8</span></span><span class="koboSpan" id="kobo.3220.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3221.1">1</span></span><span class="koboSpan" id="kobo.3222.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3223.1">2</span></span><span class="koboSpan" id="kobo.3224.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3225.1">1</span></span><span class="koboSpan" id="kobo.3226.1"> };
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3227.1">partial_sort</span></span><span class="koboSpan" id="kobo.3228.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3229.1">begin</span></span><span class="koboSpan" id="kobo.3230.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3231.1">begin</span></span><span class="koboSpan" id="kobo.3232.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3233.1">4</span></span><span class="koboSpan" id="kobo.3234.1">, v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3235.1">end</span></span><span class="koboSpan" id="kobo.3236.1">());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3237.1">// v = {1, 1, 2, 3, ?, ?, ?}</span></span><span class="koboSpan" id="kobo.3238.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3239.1">partial_sort</span></span><span class="koboSpan" id="kobo.3240.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3241.1">begin</span></span><span class="koboSpan" id="kobo.3242.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3243.1">begin</span></span><span class="koboSpan" id="kobo.3244.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3245.1">4</span></span><span class="koboSpan" id="kobo.3246.1">, v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3247.1">end</span></span><span class="koboSpan" id="kobo.3248.1">(),
                  std::greater&lt;&gt;());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3249.1">// v = {13, 8, 5, 3, ?, ?, ?}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3250.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3251.1">std::partial_sort_copy()</span></code><span class="koboSpan" id="kobo.3252.1"> for sorting a part of a range by copying the sorted elements to a second range and leaving the original range unchanged:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3253.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3254.1">int</span></span><span class="koboSpan" id="kobo.3255.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3256.1">3</span></span><span class="koboSpan" id="kobo.3257.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3258.1">13</span></span><span class="koboSpan" id="kobo.3259.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3260.1">5</span></span><span class="koboSpan" id="kobo.3261.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3262.1">8</span></span><span class="koboSpan" id="kobo.3263.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3264.1">1</span></span><span class="koboSpan" id="kobo.3265.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3266.1">2</span></span><span class="koboSpan" id="kobo.3267.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3268.1">1</span></span><span class="koboSpan" id="kobo.3269.1"> };
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3270.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3271.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3272.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3273.1">vc</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3274.1">(v.size())</span></span><span class="koboSpan" id="kobo.3275.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3276.1">partial_sort_copy</span></span><span class="koboSpan" id="kobo.3277.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3278.1">begin</span></span><span class="koboSpan" id="kobo.3279.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3280.1">end</span></span><span class="koboSpan" id="kobo.3281.1">(), vc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3282.1">begin</span></span><span class="koboSpan" id="kobo.3283.1">(), vc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3284.1">end</span></span><span class="koboSpan" id="kobo.3285.1">());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3286.1">// v = {3, 13, 5, 8, 1, 2, 1}</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3287.1">// vc = {1, 1, 2, 3, 5, 8, 13}</span></span><span class="koboSpan" id="kobo.3288.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3289.1">partial_sort_copy</span></span><span class="koboSpan" id="kobo.3290.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3291.1">begin</span></span><span class="koboSpan" id="kobo.3292.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3293.1">end</span></span><span class="koboSpan" id="kobo.3294.1">(),
                       vc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3295.1">begin</span></span><span class="koboSpan" id="kobo.3296.1">(), vc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3297.1">end</span></span><span class="koboSpan" id="kobo.3298.1">(),
                       std::greater&lt;&gt;());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3299.1">// vc = {13, 8, 5, 3, 2, 1, 1}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3300.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3301.1">std::nth_element()</span></code><span class="koboSpan" id="kobo.3302.1"> for sorting a range so that the </span><em class="italic"><span class="koboSpan" id="kobo.3303.1">N</span></em><span class="koboSpan" id="kobo.3304.1">th element is the one that </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.3305.1">would be in that position if the range was completely sorted, and the elements before it are all smaller and the ones after it are all greater, without any guarantee that they are also ordered:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3306.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3307.1">int</span></span><span class="koboSpan" id="kobo.3308.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3309.1">3</span></span><span class="koboSpan" id="kobo.3310.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3311.1">13</span></span><span class="koboSpan" id="kobo.3312.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3313.1">5</span></span><span class="koboSpan" id="kobo.3314.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3315.1">8</span></span><span class="koboSpan" id="kobo.3316.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3317.1">1</span></span><span class="koboSpan" id="kobo.3318.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3319.1">2</span></span><span class="koboSpan" id="kobo.3320.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3321.1">1</span></span><span class="koboSpan" id="kobo.3322.1"> };
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3323.1">nth_element</span></span><span class="koboSpan" id="kobo.3324.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3325.1">begin</span></span><span class="koboSpan" id="kobo.3326.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3327.1">begin</span></span><span class="koboSpan" id="kobo.3328.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3329.1">3</span></span><span class="koboSpan" id="kobo.3330.1">, v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3331.1">end</span></span><span class="koboSpan" id="kobo.3332.1">());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3333.1">// v = {1, 1, 2, 3, 5, 8, 13}</span></span><span class="koboSpan" id="kobo.3334.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3335.1">nth_element</span></span><span class="koboSpan" id="kobo.3336.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3337.1">begin</span></span><span class="koboSpan" id="kobo.3338.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3339.1">begin</span></span><span class="koboSpan" id="kobo.3340.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3341.1">3</span></span><span class="koboSpan" id="kobo.3342.1">, v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3343.1">end</span></span><span class="koboSpan" id="kobo.3344.1">(), std::greater&lt;&gt;());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3345.1">// v = {13, 8, 5, 3, 2, 1, 1}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3346.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3347.1">std::is_sorted()</span></code><span class="koboSpan" id="kobo.3348.1"> to check whether a range is sorted:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3349.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3350.1">int</span></span><span class="koboSpan" id="kobo.3351.1">&gt; v { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3352.1">1</span></span><span class="koboSpan" id="kobo.3353.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3354.1">1</span></span><span class="koboSpan" id="kobo.3355.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3356.1">2</span></span><span class="koboSpan" id="kobo.3357.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3358.1">3</span></span><span class="koboSpan" id="kobo.3359.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3360.1">5</span></span><span class="koboSpan" id="kobo.3361.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3362.1">8</span></span><span class="koboSpan" id="kobo.3363.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3364.1">13</span></span><span class="koboSpan" id="kobo.3365.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3366.1">auto</span></span><span class="koboSpan" id="kobo.3367.1"> sorted = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3368.1">is_sorted</span></span><span class="koboSpan" id="kobo.3369.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3370.1">cbegin</span></span><span class="koboSpan" id="kobo.3371.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3372.1">cend</span></span><span class="koboSpan" id="kobo.3373.1">());
sorted = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3374.1">is_sorted</span></span><span class="koboSpan" id="kobo.3375.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3376.1">cbegin</span></span><span class="koboSpan" id="kobo.3377.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3378.1">cend</span></span><span class="koboSpan" id="kobo.3379.1">(), std::greater&lt;&gt;());
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3380.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3381.1">std::is_sorted_until()</span></code><span class="koboSpan" id="kobo.3382.1"> to find a sorted subrange from the beginning of a range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3383.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3384.1">int</span></span><span class="koboSpan" id="kobo.3385.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3386.1">3</span></span><span class="koboSpan" id="kobo.3387.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3388.1">13</span></span><span class="koboSpan" id="kobo.3389.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3390.1">5</span></span><span class="koboSpan" id="kobo.3391.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3392.1">8</span></span><span class="koboSpan" id="kobo.3393.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3394.1">1</span></span><span class="koboSpan" id="kobo.3395.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3396.1">2</span></span><span class="koboSpan" id="kobo.3397.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3398.1">1</span></span><span class="koboSpan" id="kobo.3399.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3400.1">auto</span></span><span class="koboSpan" id="kobo.3401.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3402.1">is_sorted_until</span></span><span class="koboSpan" id="kobo.3403.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3404.1">cbegin</span></span><span class="koboSpan" id="kobo.3405.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3406.1">cend</span></span><span class="koboSpan" id="kobo.3407.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3408.1">auto</span></span><span class="koboSpan" id="kobo.3409.1"> length = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3410.1">distance</span></span><span class="koboSpan" id="kobo.3411.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3412.1">cbegin</span></span><span class="koboSpan" id="kobo.3413.1">(), it);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-290"><span class="koboSpan" id="kobo.3414.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3415.1">All the preceding </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.3416.1">general algorithms take random iterators as arguments to define the range to be sorted. </span><span class="koboSpan" id="kobo.3416.2">Some of them also take an output range. </span><span class="koboSpan" id="kobo.3416.3">They all have overloads: one that requires a comparison function for sorting the elements and one that does not and uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.3417.1">operator&lt;</span></code><span class="koboSpan" id="kobo.3418.1"> for comparing the elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3419.1">These algorithms work in the following way:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3420.1">std::sort()</span></code><span class="koboSpan" id="kobo.3421.1"> modifies the input range so that its elements are sorted according to the default or the specified comparison function; the actual algorithm for sorting is an implementation detail.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3422.1">std::stable_sort()</span></code><span class="koboSpan" id="kobo.3423.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3424.1">std::sort()</span></code><span class="koboSpan" id="kobo.3425.1">, but it guarantees to preserve the original order of elements that are equal.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3426.1">std::partial_sort()</span></code><span class="koboSpan" id="kobo.3427.1"> takes three iterator arguments indicating the first, middle, and last element in a range, where middle can be any element, not just the one at the natural middle position. </span><span class="koboSpan" id="kobo.3427.2">The result is a partially sorted range so that the first </span><em class="italic"><span class="koboSpan" id="kobo.3428.1">middle</span></em><span class="koboSpan" id="kobo.3429.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.3430.1">first</span></em><span class="koboSpan" id="kobo.3431.1"> smallest elements from the original range, that is, [</span><em class="italic"><span class="koboSpan" id="kobo.3432.1">first</span></em><span class="koboSpan" id="kobo.3433.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3434.1">last</span></em><span class="koboSpan" id="kobo.3435.1">), are found in the [</span><em class="italic"><span class="koboSpan" id="kobo.3436.1">first</span></em><span class="koboSpan" id="kobo.3437.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3438.1">middle</span></em><span class="koboSpan" id="kobo.3439.1">) subrange and the rest of the elements are in an unspecified order in the [</span><em class="italic"><span class="koboSpan" id="kobo.3440.1">middle</span></em><span class="koboSpan" id="kobo.3441.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3442.1">last</span></em><span class="koboSpan" id="kobo.3443.1">) subrange.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3444.1">std::partial_sort_copy()</span></code><span class="koboSpan" id="kobo.3445.1"> is not a variant of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3446.1">std::partial_sort()</span></code><span class="koboSpan" id="kobo.3447.1">, as the name may suggest, but of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3448.1">std::sort()</span></code><span class="koboSpan" id="kobo.3449.1">. </span><span class="koboSpan" id="kobo.3449.2">It sorts a range without altering it by copying its elements to an output range. </span><span class="koboSpan" id="kobo.3449.3">The arguments of the algorithm are the first and last iterators of the input and output ranges. </span><span class="koboSpan" id="kobo.3449.4">If the output range has a size </span><em class="italic"><span class="koboSpan" id="kobo.3450.1">M</span></em><span class="koboSpan" id="kobo.3451.1"> that is greater than or equal to the size </span><em class="italic"><span class="koboSpan" id="kobo.3452.1">N</span></em><span class="koboSpan" id="kobo.3453.1"> of the input range, the input range is entirely sorted and copied to the output range; the first </span><em class="italic"><span class="koboSpan" id="kobo.3454.1">N</span></em><span class="koboSpan" id="kobo.3455.1"> elements of the output range are overwritten, and the last </span><em class="italic"><span class="koboSpan" id="kobo.3456.1">M</span></em><span class="koboSpan" id="kobo.3457.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.3458.1">N</span></em><span class="koboSpan" id="kobo.3459.1"> elements are left untouched. </span><span class="koboSpan" id="kobo.3459.2">If the output range is smaller than the input range, then only the first </span><em class="italic"><span class="koboSpan" id="kobo.3460.1">M</span></em><span class="koboSpan" id="kobo.3461.1"> sorted elements from the input range are copied to the output range (which is entirely overwritten in this case).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3462.1">std::nth_element()</span></code><span class="koboSpan" id="kobo.3463.1"> is basically an implementation of a selection algorithm, which is an algorithm for finding the </span><em class="italic"><span class="koboSpan" id="kobo.3464.1">N</span></em><span class="koboSpan" id="kobo.3465.1">th smallest element of a range. </span><span class="koboSpan" id="kobo.3465.2">This algorithm takes three iterator arguments representing the first, </span><em class="italic"><span class="koboSpan" id="kobo.3466.1">N</span></em><span class="koboSpan" id="kobo.3467.1">th, and last element, and partially sorts the range so that, after sorting, the </span><em class="italic"><span class="koboSpan" id="kobo.3468.1">N</span></em><span class="koboSpan" id="kobo.3469.1">th element is the one that would be in that position if the range had been entirely sorted. </span><span class="koboSpan" id="kobo.3469.2">In the modified range, all the </span><em class="italic"><span class="koboSpan" id="kobo.3470.1">N</span></em><span class="koboSpan" id="kobo.3471.1"> – 1 elements before the </span><em class="italic"><span class="koboSpan" id="kobo.3472.1">N</span></em><span class="koboSpan" id="kobo.3473.1">th one are smaller than it, and all the elements after the </span><em class="italic"><span class="koboSpan" id="kobo.3474.1">N</span></em><span class="koboSpan" id="kobo.3475.1">th element are greater than it. </span><span class="koboSpan" id="kobo.3475.2">However, there is no guarantee on the order of these other elements.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3476.1">std::is_sorted()</span></code><span class="koboSpan" id="kobo.3477.1"> checks whether the specified range is sorted according to the specified or default comparison function and returns a Boolean value to indicate that.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3478.1">std::is_sorted_until()</span></code><span class="koboSpan" id="kobo.3479.1"> finds a sorted subrange of the specified range, starting from the beginning, using either a provided comparison function or the default </span><code class="inlineCode"><span class="koboSpan" id="kobo.3480.1">operator&lt;</span></code><span class="koboSpan" id="kobo.3481.1">. </span><span class="koboSpan" id="kobo.3481.2">The returned value is an iterator representing the upper bound of the sorted subrange, which is also the iterator of the one-past-last sorted element.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3482.1">Some standard </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.3483.1">containers, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3484.1">std::list</span></code><span class="koboSpan" id="kobo.3485.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3486.1">std::forward_list</span></code><span class="koboSpan" id="kobo.3487.1">, provide a member function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3488.1">sort()</span></code><span class="koboSpan" id="kobo.3489.1">, which is optimized for those containers. </span><span class="koboSpan" id="kobo.3489.2">These member functions should be preferred over the general standard algorithm, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3490.1">std::sort()</span></code><span class="koboSpan" id="kobo.3491.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-291"><span class="koboSpan" id="kobo.3492.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3493.1">Using vector as a default container</span></em><span class="koboSpan" id="kobo.3494.1">, to learn how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3495.1">std::vector</span></code><span class="koboSpan" id="kobo.3496.1"> standard container.</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3497.1">Initializing a range</span></em><span class="koboSpan" id="kobo.3498.1"> to explore the standard algorithms for filling a range with values</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3499.1">Using set operations on a range</span></em><span class="koboSpan" id="kobo.3500.1">, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3501.1">Finding elements in a range</span></em><span class="koboSpan" id="kobo.3502.1">, to learn about the standard algorithms for searching through sequences of values</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-292"><span class="koboSpan" id="kobo.3503.1">Initializing a range</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3504.1">In the </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.3505.1">previous recipes, we explored the general standard algorithms for searching in a range and sorting a range. </span><span class="koboSpan" id="kobo.3505.2">The algorithms library provides many other general algorithms, and among them are several that are intended for filling a range with values. </span><span class="koboSpan" id="kobo.3505.3">In this recipe, you will learn what these algorithms are and how they should be used.</span></p>
<h2 class="heading-2" id="_idParaDest-293"><span class="koboSpan" id="kobo.3506.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3507.1">All the examples </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.3508.1">in this recipe use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3509.1">std::vector</span></code><span class="koboSpan" id="kobo.3510.1">. </span><span class="koboSpan" id="kobo.3510.2">However, like all the general algorithms, the ones we will see in this recipe take iterators to define the bounds of a range and can therefore be used with any standard container, arrays, or custom types representing a sequence that have forward iterators defined.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3511.1">Except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3512.1">std::iota()</span></code><span class="koboSpan" id="kobo.3513.1">, which is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3514.1">&lt;numeric&gt;</span></code><span class="koboSpan" id="kobo.3515.1"> header, all the other algorithms are found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3516.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.3517.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-294"><span class="koboSpan" id="kobo.3518.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3519.1">To assign values to a range, use any of the following standard algorithms:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3520.1">std::fill()</span></code><span class="koboSpan" id="kobo.3521.1"> to assign a value to all the elements of a range; the range is defined by a first and last forward iterator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3522.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3523.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3524.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3525.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3526.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3527.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3528.1">)</span></span><span class="koboSpan" id="kobo.3529.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3530.1">fill</span></span><span class="koboSpan" id="kobo.3531.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3532.1">begin</span></span><span class="koboSpan" id="kobo.3533.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3534.1">end</span></span><span class="koboSpan" id="kobo.3535.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3536.1">42</span></span><span class="koboSpan" id="kobo.3537.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3538.1">// v = {42, 42, 42, 42, 42}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3539.1">std::fill_n()</span></code><span class="koboSpan" id="kobo.3540.1"> to assign values to a number of elements of a range; the range is defined by a first forward iterator and a counter that indicates how many elements should be assigned the specified value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3541.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3542.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3543.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3544.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3545.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3546.1">10</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3547.1">)</span></span><span class="koboSpan" id="kobo.3548.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3549.1">fill_n</span></span><span class="koboSpan" id="kobo.3550.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3551.1">begin</span></span><span class="koboSpan" id="kobo.3552.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3553.1">5</span></span><span class="koboSpan" id="kobo.3554.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3555.1">42</span></span><span class="koboSpan" id="kobo.3556.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3557.1">// v = {42, 42, 42, 42, 42, 0, 0, 0, 0, 0}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3558.1">std::generate()</span></code><span class="koboSpan" id="kobo.3559.1"> to assign the value returned by a function to the elements of a range; the range is defined by a first and last forward iterator, and the function is invoked once for each element in the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3560.1">std::random_device rd{};
std::mt19937 mt{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3561.1">rd</span></span><span class="koboSpan" id="kobo.3562.1">() };
std::uniform_int_distribution&lt;&gt; ud{</span><span class="hljs-number"><span class="koboSpan" id="kobo.3563.1">1</span></span><span class="koboSpan" id="kobo.3564.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3565.1">10</span></span><span class="koboSpan" id="kobo.3566.1">};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3567.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3568.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3569.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3570.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3571.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3572.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3573.1">)</span></span><span class="koboSpan" id="kobo.3574.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3575.1">generate</span></span><span class="koboSpan" id="kobo.3576.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3577.1">begin</span></span><span class="koboSpan" id="kobo.3578.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3579.1">end</span></span><span class="koboSpan" id="kobo.3580.1">(),
              [&amp;ud, &amp;mt] {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3581.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3582.1">ud</span></span><span class="koboSpan" id="kobo.3583.1">(mt); });
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3584.1">std::generate_n()</span></code><span class="koboSpan" id="kobo.3585.1"> to assign the value returned by a function to a number of elements of a range; the range is defined by a first forward iterator and a counter that indicates how many elements should be assigned the value from the function that is invoked once for each element:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3586.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3587.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3588.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3589.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3590.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3591.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3592.1">)</span></span><span class="koboSpan" id="kobo.3593.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3594.1">auto</span></span><span class="koboSpan" id="kobo.3595.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3596.1">1</span></span><span class="koboSpan" id="kobo.3597.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3598.1">generate_n</span></span><span class="koboSpan" id="kobo.3599.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3600.1">begin</span></span><span class="koboSpan" id="kobo.3601.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3602.1">size</span></span><span class="koboSpan" id="kobo.3603.1">(), [&amp;i] { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3604.1">return</span></span><span class="koboSpan" id="kobo.3605.1"> i*i++; });
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3606.1">// v = {1, 4, 9, 16, 25}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3607.1">std::iota()</span></code><span class="koboSpan" id="kobo.3608.1"> to assign sequentially increasing values to the elements of a range; the range is defined by a first and last forward iterator, and the values are incremented using the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.3609.1">operator++</span></code><span class="koboSpan" id="kobo.3610.1"> from an initial specified value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3611.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3612.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3613.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3614.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3615.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3616.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3617.1">)</span></span><span class="koboSpan" id="kobo.3618.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3619.1">iota</span></span><span class="koboSpan" id="kobo.3620.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3621.1">begin</span></span><span class="koboSpan" id="kobo.3622.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3623.1">end</span></span><span class="koboSpan" id="kobo.3624.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3625.1">1</span></span><span class="koboSpan" id="kobo.3626.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3627.1">// v = {1, 2, 3, 4, 5}</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-295"><span class="koboSpan" id="kobo.3628.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3629.1">std::fill()</span></code><span class="koboSpan" id="kobo.3630.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3631.1">std::fill_n()</span></code><span class="koboSpan" id="kobo.3632.1"> work similarly but differ in the way the range is specified: for</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.3633.1"> the former by a first and last iterator, for the latter by a first iterator and a count. </span><span class="koboSpan" id="kobo.3633.2">The second algorithm returns an iterator, representing either the one-past-last assigned element if the counter is greater than zero, or an iterator to the first element of the range otherwise.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3634.1">std::generate()</span></code><span class="koboSpan" id="kobo.3635.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3636.1">std::generate_n()</span></code><span class="koboSpan" id="kobo.3637.1"> are also similar, differing only in the way the range is specified. </span><span class="koboSpan" id="kobo.3637.2">The first takes two iterators, defining the range’s lower and upper bounds, while the second takes an iterator to the first element and a count. </span><span class="koboSpan" id="kobo.3637.3">Like </span><code class="inlineCode"><span class="koboSpan" id="kobo.3638.1">std::fill_n()</span></code><span class="koboSpan" id="kobo.3639.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3640.1">std::generate_n()</span></code><span class="koboSpan" id="kobo.3641.1"> also returns an iterator, representing either the one-past-last assigned element if the count is greater than zero, or an iterator to the first element of the range otherwise. </span><span class="koboSpan" id="kobo.3641.2">These algorithms call a specified function for each element in the range and assign the returned value to the element. </span><span class="koboSpan" id="kobo.3641.3">The generating function does not take any argument, so the value of the argument cannot be passed to the function. </span><span class="koboSpan" id="kobo.3641.4">This is because it’s intended as a function to initialize the elements of a range. </span><span class="koboSpan" id="kobo.3641.5">If you need to use the value of the elements to generate new values, you should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3642.1">std::transform()</span></code><span class="koboSpan" id="kobo.3643.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3644.1">std::iota()</span></code><span class="koboSpan" id="kobo.3645.1"> takes its name from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3646.1">ι</span></code><span class="koboSpan" id="kobo.3647.1"> (iota) function from the APL programming language, and though it was a part of the initial STL, it was only included in the standard library in C++11. </span><span class="koboSpan" id="kobo.3647.2">This function takes a first and last iterator to a range, as well as an initial value that is assigned to the first element of the range. </span><span class="koboSpan" id="kobo.3647.3">These are then used to generate sequentially increasing values using the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.3648.1">operator++</span></code><span class="koboSpan" id="kobo.3649.1"> for the rest of the elements in the range.</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3650.1">STL</span></strong><span class="koboSpan" id="kobo.3651.1"> stands for the </span><strong class="keyWord"><span class="koboSpan" id="kobo.3652.1">Standard Template Library</span></strong><span class="koboSpan" id="kobo.3653.1">. </span><span class="koboSpan" id="kobo.3653.2">It is a software library designed by Alexander Stepanov initially for C++ before the standardization of the C++ language. </span><span class="koboSpan" id="kobo.3653.3">It was later used to model the C++ standard library, providing containers, iterators, algorithms, and functions. </span><span class="koboSpan" id="kobo.3653.4">It should not be confused with the C++ standard library, as these two are distinct entities.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-296"><span class="koboSpan" id="kobo.3654.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3655.1">The </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.3656.1">examples we saw in this recipe used integers so they would be easy to follow. </span><span class="koboSpan" id="kobo.3656.2">However, we can also provide a real-life example to help you better understand how these algorithms can be used for more complex scenarios.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3657.1">Let’s consider a function that given two colors generates a series of intermediary points, representing a gradient. </span><span class="koboSpan" id="kobo.3657.2">A color object has three values, one for the red, green, and blue channels. </span><span class="koboSpan" id="kobo.3657.3">We can model it as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3658.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3659.1">color</span></span><span class="koboSpan" id="kobo.3660.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.3661.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3662.1">char</span></span><span class="koboSpan" id="kobo.3663.1"> red   = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3664.1">0</span></span><span class="koboSpan" id="kobo.3665.1">;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.3666.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3667.1">char</span></span><span class="koboSpan" id="kobo.3668.1"> blue  = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3669.1">0</span></span><span class="koboSpan" id="kobo.3670.1">;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.3671.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3672.1">char</span></span><span class="koboSpan" id="kobo.3673.1"> green = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3674.1">0</span></span><span class="koboSpan" id="kobo.3675.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3676.1">We will write a function that takes the start and end color, as well as the number of points to generate, and returns a vector of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3677.1">color</span></code><span class="koboSpan" id="kobo.3678.1"> objects. </span><span class="koboSpan" id="kobo.3678.2">Internally, this uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.3679.1">std::generate_n()</span></code><span class="koboSpan" id="kobo.3680.1"> to generate the values:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3681.1">std::vector&lt;color&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3682.1">make_gradient</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3683.1">(color </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3684.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3685.1">&amp; c1, color </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3686.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3687.1">&amp; c2, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3688.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3689.1"> points)</span></span><span class="koboSpan" id="kobo.3690.1">
{
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.3691.1">std::vector&lt;color&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3692.1">colors</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3693.1">(points)</span></span><span class="koboSpan" id="kobo.3694.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3695.1">auto</span></span><span class="koboSpan" id="kobo.3696.1"> rstep = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3697.1">static_cast</span></span><span class="koboSpan" id="kobo.3698.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3699.1">double</span></span><span class="koboSpan" id="kobo.3700.1">&gt;(c2.red - c1.red) / points;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3701.1">auto</span></span><span class="koboSpan" id="kobo.3702.1"> gstep = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3703.1">static_cast</span></span><span class="koboSpan" id="kobo.3704.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3705.1">double</span></span><span class="koboSpan" id="kobo.3706.1">&gt;(c2.green - c1.green) / points;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3707.1">auto</span></span><span class="koboSpan" id="kobo.3708.1"> bstep = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3709.1">static_cast</span></span><span class="koboSpan" id="kobo.3710.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3711.1">double</span></span><span class="koboSpan" id="kobo.3712.1">&gt;(c2.blue - c1.blue) / points;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3713.1">auto</span></span><span class="koboSpan" id="kobo.3714.1"> r = c1.red;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3715.1">auto</span></span><span class="koboSpan" id="kobo.3716.1"> g = c1.green;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3717.1">auto</span></span><span class="koboSpan" id="kobo.3718.1"> b = c1.blue;
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3719.1">generate_n</span></span><span class="koboSpan" id="kobo.3720.1">(colors.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3721.1">begin</span></span><span class="koboSpan" id="kobo.3722.1">(), 
                   points, 
                   [&amp;r, &amp;g, &amp;b, rstep, gstep, bstep] {
      color c {
         </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3723.1">static_cast</span></span><span class="koboSpan" id="kobo.3724.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3725.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3726.1">char</span></span><span class="koboSpan" id="kobo.3727.1">&gt;(r),
         </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3728.1">static_cast</span></span><span class="koboSpan" id="kobo.3729.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3730.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3731.1">char</span></span><span class="koboSpan" id="kobo.3732.1">&gt;(g),
         </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3733.1">static_cast</span></span><span class="koboSpan" id="kobo.3734.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3735.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3736.1">char</span></span><span class="koboSpan" id="kobo.3737.1">&gt;(b) 
      };
      r += rstep;
      g += gstep;
      b += bstep;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3738.1">return</span></span><span class="koboSpan" id="kobo.3739.1"> c;
   });
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3740.1">return</span></span><span class="koboSpan" id="kobo.3741.1"> colors;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3742.1">We can use this function as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3743.1">color white { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3744.1">255</span></span><span class="koboSpan" id="kobo.3745.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3746.1">255</span></span><span class="koboSpan" id="kobo.3747.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3748.1">255</span></span><span class="koboSpan" id="kobo.3749.1"> };
color black { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3750.1">0</span></span><span class="koboSpan" id="kobo.3751.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3752.1">0</span></span><span class="koboSpan" id="kobo.3753.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3754.1">0</span></span><span class="koboSpan" id="kobo.3755.1"> };
std::vector&lt;color&gt; grayscale = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3756.1">make_gradient</span></span><span class="koboSpan" id="kobo.3757.1">(white, black, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3758.1">256</span></span><span class="koboSpan" id="kobo.3759.1">);
std::for_each(
   grayscale.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3760.1">begin</span></span><span class="koboSpan" id="kobo.3761.1">(), grayscale.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3762.1">end</span></span><span class="koboSpan" id="kobo.3763.1">(),
   [](color </span><span class="hljs-type"><span class="koboSpan" id="kobo.3764.1">const</span></span><span class="koboSpan" id="kobo.3765.1">&amp; c) {
      std::cout &lt;&lt; 
         </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3766.1">static_cast</span></span><span class="koboSpan" id="kobo.3767.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3768.1">int</span></span><span class="koboSpan" id="kobo.3769.1">&gt;(c.red) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3770.1">", "</span></span><span class="koboSpan" id="kobo.3771.1">
         &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3772.1">static_cast</span></span><span class="koboSpan" id="kobo.3773.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3774.1">int</span></span><span class="koboSpan" id="kobo.3775.1">&gt;(c.green) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3776.1">", "</span></span><span class="koboSpan" id="kobo.3777.1">
         &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3778.1">static_cast</span></span><span class="koboSpan" id="kobo.3779.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3780.1">int</span></span><span class="koboSpan" id="kobo.3781.1">&gt;(c.blue) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3782.1">'\n'</span></span><span class="koboSpan" id="kobo.3783.1">;
   });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3784.1">Although</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.3785.1"> the output of running this snippet has 256 lines (one for each point), we can show an excerpt of it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3786.1">255, 255, 255
254, 254, 254
253, 253, 253
…
1, 1, 1
0, 0, 0
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-297"><span class="koboSpan" id="kobo.3787.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3788.1">Sorting a range</span></em><span class="koboSpan" id="kobo.3789.1">, to learn about the standard algorithms for sorting ranges</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3790.1">Using set operations on a range</span></em><span class="koboSpan" id="kobo.3791.1">, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3792.1">Finding elements in a range</span></em><span class="koboSpan" id="kobo.3793.1">, to learn about the standard algorithms for searching through sequences of values</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3794.1">Chapter 2</span></em><span class="koboSpan" id="kobo.3795.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3796.1">Generating pseudo-random numbers</span></em><span class="koboSpan" id="kobo.3797.1">, to understand the proper ways for generating pseudo-random numbers in C++</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3798.1">Chapter 2</span></em><span class="koboSpan" id="kobo.3799.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3800.1">Initializing all bits of internal state of a pseudo-random number generator</span></em><span class="koboSpan" id="kobo.3801.1">, to learn how to properly initialize random number engines</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-298"><span class="koboSpan" id="kobo.3802.1">Using set operations on a range</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3803.1">The</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.3804.1"> standard library provides several algorithms for set operations that enable us to do unions, intersections, or differences of sorted ranges. </span><span class="koboSpan" id="kobo.3804.2">In this recipe, we will see what these algorithms are and how they work.</span></p>
<h2 class="heading-2" id="_idParaDest-299"><span class="koboSpan" id="kobo.3805.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3806.1">The </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.3807.1">algorithms for set operations work with iterators, which means they can be used for standard containers, arrays, or any custom type representing a sequence that has input iterators available. </span><span class="koboSpan" id="kobo.3807.2">All the examples in this recipe will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3808.1">std::vector</span></code><span class="koboSpan" id="kobo.3809.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3810.1">For all the examples in the next section, we will use the following ranges:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3811.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3812.1">int</span></span><span class="koboSpan" id="kobo.3813.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3814.1">1</span></span><span class="koboSpan" id="kobo.3815.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3816.1">2</span></span><span class="koboSpan" id="kobo.3817.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3818.1">3</span></span><span class="koboSpan" id="kobo.3819.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3820.1">4</span></span><span class="koboSpan" id="kobo.3821.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3822.1">4</span></span><span class="koboSpan" id="kobo.3823.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3824.1">5</span></span><span class="koboSpan" id="kobo.3825.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3826.1">int</span></span><span class="koboSpan" id="kobo.3827.1">&gt; v2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3828.1">2</span></span><span class="koboSpan" id="kobo.3829.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3830.1">3</span></span><span class="koboSpan" id="kobo.3831.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3832.1">3</span></span><span class="koboSpan" id="kobo.3833.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3834.1">4</span></span><span class="koboSpan" id="kobo.3835.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3836.1">6</span></span><span class="koboSpan" id="kobo.3837.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3838.1">8</span></span><span class="koboSpan" id="kobo.3839.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3840.1">int</span></span><span class="koboSpan" id="kobo.3841.1">&gt; v3;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3842.1">In the following section, we will explore the use of the standard algorithm for set operations.</span></p>
<h2 class="heading-2" id="_idParaDest-300"><span class="koboSpan" id="kobo.3843.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3844.1">Use </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.3845.1">the </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.3846.1">following general algorithms for set operations:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3847.1">std::set_union()</span></code><span class="koboSpan" id="kobo.3848.1"> to compute the union of two ranges into a third range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3849.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3850.1">set_union</span></span><span class="koboSpan" id="kobo.3851.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3852.1">cbegin</span></span><span class="koboSpan" id="kobo.3853.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3854.1">cend</span></span><span class="koboSpan" id="kobo.3855.1">(),
               v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3856.1">cbegin</span></span><span class="koboSpan" id="kobo.3857.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3858.1">cend</span></span><span class="koboSpan" id="kobo.3859.1">(),
               std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3860.1">back_inserter</span></span><span class="koboSpan" id="kobo.3861.1">(v3));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3862.1">// v3 = {1, 2, 3, 3, 4, 4, 5, 6, 8}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3863.1">std::merge()</span></code><span class="koboSpan" id="kobo.3864.1"> to merge the content of two ranges into a third one; this is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3865.1">std::set_union()</span></code><span class="koboSpan" id="kobo.3866.1"> except that it copies the entire content of the input ranges into the output one, not just their union:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3867.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3868.1">merge</span></span><span class="koboSpan" id="kobo.3869.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3870.1">cbegin</span></span><span class="koboSpan" id="kobo.3871.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3872.1">cend</span></span><span class="koboSpan" id="kobo.3873.1">(),
           v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3874.1">cbegin</span></span><span class="koboSpan" id="kobo.3875.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3876.1">cend</span></span><span class="koboSpan" id="kobo.3877.1">(),
           std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3878.1">back_inserter</span></span><span class="koboSpan" id="kobo.3879.1">(v3));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3880.1">// v3 = {1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 8}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3881.1">std::set_intersection()</span></code><span class="koboSpan" id="kobo.3882.1"> to compute the intersection of the two ranges into a third range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3883.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3884.1">set_intersection</span></span><span class="koboSpan" id="kobo.3885.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3886.1">cbegin</span></span><span class="koboSpan" id="kobo.3887.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3888.1">cend</span></span><span class="koboSpan" id="kobo.3889.1">(),
                      v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3890.1">cbegin</span></span><span class="koboSpan" id="kobo.3891.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3892.1">cend</span></span><span class="koboSpan" id="kobo.3893.1">(),
                      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3894.1">back_inserter</span></span><span class="koboSpan" id="kobo.3895.1">(v3));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3896.1">// v3 = {2, 3, 4}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3897.1">std::set_difference()</span></code><span class="koboSpan" id="kobo.3898.1"> to compute the difference of two ranges into a third range; the output range will contain elements from the first range, which are not present in the second range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3899.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3900.1">set_difference</span></span><span class="koboSpan" id="kobo.3901.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3902.1">cbegin</span></span><span class="koboSpan" id="kobo.3903.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3904.1">cend</span></span><span class="koboSpan" id="kobo.3905.1">(),
                    v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3906.1">cbegin</span></span><span class="koboSpan" id="kobo.3907.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3908.1">cend</span></span><span class="koboSpan" id="kobo.3909.1">(),
                    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3910.1">back_inserter</span></span><span class="koboSpan" id="kobo.3911.1">(v3));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3912.1">// v3 = {1, 4, 5}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3913.1">std::set_symmetric_difference()</span></code><span class="koboSpan" id="kobo.3914.1"> to compute a dual difference of the two ranges into a third range; the output range will contain elements that are present</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.3915.1"> in any of the input ranges, but only in one:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3916.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3917.1">set_symmetric_difference</span></span><span class="koboSpan" id="kobo.3918.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3919.1">cbegin</span></span><span class="koboSpan" id="kobo.3920.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3921.1">cend</span></span><span class="koboSpan" id="kobo.3922.1">(),
                              v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3923.1">cbegin</span></span><span class="koboSpan" id="kobo.3924.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3925.1">cend</span></span><span class="koboSpan" id="kobo.3926.1">(),
                              std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3927.1">back_inserter</span></span><span class="koboSpan" id="kobo.3928.1">(v3));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3929.1">// v3 = {1, 3, 4, 5, 6, 8}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3930.1">std::includes()</span></code><span class="koboSpan" id="kobo.3931.1"> to check if one range is a subset of another range (that is, all its </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.3932.1">elements are also present in the other range):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3933.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3934.1">int</span></span><span class="koboSpan" id="kobo.3935.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3936.1">1</span></span><span class="koboSpan" id="kobo.3937.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3938.1">2</span></span><span class="koboSpan" id="kobo.3939.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3940.1">3</span></span><span class="koboSpan" id="kobo.3941.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3942.1">4</span></span><span class="koboSpan" id="kobo.3943.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3944.1">4</span></span><span class="koboSpan" id="kobo.3945.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3946.1">5</span></span><span class="koboSpan" id="kobo.3947.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3948.1">int</span></span><span class="koboSpan" id="kobo.3949.1">&gt; v2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3950.1">2</span></span><span class="koboSpan" id="kobo.3951.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3952.1">3</span></span><span class="koboSpan" id="kobo.3953.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3954.1">3</span></span><span class="koboSpan" id="kobo.3955.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3956.1">4</span></span><span class="koboSpan" id="kobo.3957.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3958.1">6</span></span><span class="koboSpan" id="kobo.3959.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3960.1">8</span></span><span class="koboSpan" id="kobo.3961.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3962.1">int</span></span><span class="koboSpan" id="kobo.3963.1">&gt; v3{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3964.1">1</span></span><span class="koboSpan" id="kobo.3965.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3966.1">2</span></span><span class="koboSpan" id="kobo.3967.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3968.1">4</span></span><span class="koboSpan" id="kobo.3969.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3970.1">int</span></span><span class="koboSpan" id="kobo.3971.1">&gt; v4{ };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3972.1">auto</span></span><span class="koboSpan" id="kobo.3973.1"> i1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3974.1">includes</span></span><span class="koboSpan" id="kobo.3975.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3976.1">cbegin</span></span><span class="koboSpan" id="kobo.3977.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3978.1">cend</span></span><span class="koboSpan" id="kobo.3979.1">(),
                        v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3980.1">cbegin</span></span><span class="koboSpan" id="kobo.3981.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3982.1">cend</span></span><span class="koboSpan" id="kobo.3983.1">()); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3984.1">// i1 = false</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3985.1">auto</span></span><span class="koboSpan" id="kobo.3986.1"> i2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3987.1">includes</span></span><span class="koboSpan" id="kobo.3988.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3989.1">cbegin</span></span><span class="koboSpan" id="kobo.3990.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3991.1">cend</span></span><span class="koboSpan" id="kobo.3992.1">(),
                        v3.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3993.1">cbegin</span></span><span class="koboSpan" id="kobo.3994.1">(), v3.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3995.1">cend</span></span><span class="koboSpan" id="kobo.3996.1">()); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3997.1">// i2 = true</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3998.1">auto</span></span><span class="koboSpan" id="kobo.3999.1"> i3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4000.1">includes</span></span><span class="koboSpan" id="kobo.4001.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4002.1">cbegin</span></span><span class="koboSpan" id="kobo.4003.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4004.1">cend</span></span><span class="koboSpan" id="kobo.4005.1">(),
                        v4.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4006.1">cbegin</span></span><span class="koboSpan" id="kobo.4007.1">(), v4.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4008.1">cend</span></span><span class="koboSpan" id="kobo.4009.1">()); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4010.1">// i3 = true</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-301"><span class="koboSpan" id="kobo.4011.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4012.1">All the set operations that produce a new range from two input ranges have the same interface and work in a similar way:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4013.1">They take two input ranges, each defined by a first and last input iterator.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4014.1">They take an output iterator to an output range where elements will be inserted.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4015.1">They have an overload that takes an extra argument representing a comparison binary function object that must return </span><code class="inlineCode"><span class="koboSpan" id="kobo.4016.1">true</span></code><span class="koboSpan" id="kobo.4017.1"> if the first argument is less than the second. </span><span class="koboSpan" id="kobo.4017.2">When a comparison function object is not specified, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4018.1">operator&lt;</span></code><span class="koboSpan" id="kobo.4019.1"> is used.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4020.1">They return an iterator past the end of the constructed output range.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4021.1">The input ranges must be sorted using either </span><code class="inlineCode"><span class="koboSpan" id="kobo.4022.1">operator&lt;</span></code><span class="koboSpan" id="kobo.4023.1"> or the provided comparison function, depending on the overload that is used.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4024.1">The output range must not overlap any of the two input ranges.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4025.1">We will </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.4026.1">demonstrate the way they work with additional </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.4027.1">examples using vectors of a POD type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4028.1">Task</span></code><span class="koboSpan" id="kobo.4029.1"> that we also used in a previous recipe:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4030.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4031.1">Task</span></span><span class="koboSpan" id="kobo.4032.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4033.1">int</span></span><span class="koboSpan" id="kobo.4034.1">         priority;
  std::string name;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4035.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4036.1">operator</span></span><span class="koboSpan" id="kobo.4037.1">&lt;(Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.4038.1">const</span></span><span class="koboSpan" id="kobo.4039.1"> &amp; lhs, Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.4040.1">const</span></span><span class="koboSpan" id="kobo.4041.1"> &amp; rhs) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4042.1">return</span></span><span class="koboSpan" id="kobo.4043.1"> lhs.priority &lt; rhs.priority;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4044.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4045.1">operator</span></span><span class="koboSpan" id="kobo.4046.1">&gt;(Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.4047.1">const</span></span><span class="koboSpan" id="kobo.4048.1"> &amp; lhs, Task </span><span class="hljs-type"><span class="koboSpan" id="kobo.4049.1">const</span></span><span class="koboSpan" id="kobo.4050.1"> &amp; rhs) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4051.1">return</span></span><span class="koboSpan" id="kobo.4052.1"> lhs.priority &gt; rhs.priority;
}
std::vector&lt;Task&gt; v1{
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4053.1">10</span></span><span class="koboSpan" id="kobo.4054.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4055.1">"Task 1.1"</span></span><span class="koboSpan" id="kobo.4056.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4057.1">20</span></span><span class="koboSpan" id="kobo.4058.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4059.1">"Task 1.2"</span></span><span class="koboSpan" id="kobo.4060.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4061.1">20</span></span><span class="koboSpan" id="kobo.4062.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4063.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4064.1">Task 1.3"</span></span><span class="koboSpan" id="kobo.4065.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4066.1">20</span></span><span class="koboSpan" id="kobo.4067.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4068.1">"Task 1.4"</span></span><span class="koboSpan" id="kobo.4069.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4070.1">30</span></span><span class="koboSpan" id="kobo.4071.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4072.1">"Task 1.5"</span></span><span class="koboSpan" id="kobo.4073.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4074.1">50</span></span><span class="koboSpan" id="kobo.4075.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4076.1">"Task 1.6"</span></span><span class="koboSpan" id="kobo.4077.1">s },
};
std::vector&lt;Task&gt; v2{
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4078.1">20</span></span><span class="koboSpan" id="kobo.4079.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4080.1">"Task 2.1"</span></span><span class="koboSpan" id="kobo.4081.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4082.1">30</span></span><span class="koboSpan" id="kobo.4083.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4084.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4085.1">Task 2.2"</span></span><span class="koboSpan" id="kobo.4086.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4087.1">30</span></span><span class="koboSpan" id="kobo.4088.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4089.1">"Task 2.3"</span></span><span class="koboSpan" id="kobo.4090.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4091.1">30</span></span><span class="koboSpan" id="kobo.4092.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4093.1">"Task 2.4"</span></span><span class="koboSpan" id="kobo.4094.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4095.1">40</span></span><span class="koboSpan" id="kobo.4096.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4097.1">"Task 2.5"</span></span><span class="koboSpan" id="kobo.4098.1">s },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4099.1">50</span></span><span class="koboSpan" id="kobo.4100.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4101.1">"Task 2.6"</span></span><span class="koboSpan" id="kobo.4102.1">s },
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4103.1">The particular way each algorithm produces the output range is described here:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4104.1">std::set_union()</span></code><span class="koboSpan" id="kobo.4105.1"> copies all the elements present in one or both of the input ranges to the output range, producing a new sorted range. </span><span class="koboSpan" id="kobo.4105.2">If an element is found </span><em class="italic"><span class="koboSpan" id="kobo.4106.1">M</span></em><span class="koboSpan" id="kobo.4107.1"> times in the first range and </span><em class="italic"><span class="koboSpan" id="kobo.4108.1">N</span></em><span class="koboSpan" id="kobo.4109.1"> times in the second range, then all the </span><em class="italic"><span class="koboSpan" id="kobo.4110.1">M</span></em><span class="koboSpan" id="kobo.4111.1"> elements from the first range will be copied to the output range in their existing order, and then the </span><em class="italic"><span class="koboSpan" id="kobo.4112.1">N</span></em><span class="koboSpan" id="kobo.4113.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.4114.1">M</span></em><span class="koboSpan" id="kobo.4115.1"> elements from the second range are copied to the output range if </span><em class="italic"><span class="koboSpan" id="kobo.4116.1">N</span></em><span class="koboSpan" id="kobo.4117.1"> &gt; </span><em class="italic"><span class="koboSpan" id="kobo.4118.1">M</span></em><span class="koboSpan" id="kobo.4119.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4120.1">0</span></code><span class="koboSpan" id="kobo.4121.1"> elements otherwise:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4122.1">std::vector&lt;Task&gt; v3;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4123.1">set_union</span></span><span class="koboSpan" id="kobo.4124.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4125.1">cbegin</span></span><span class="koboSpan" id="kobo.4126.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4127.1">cend</span></span><span class="koboSpan" id="kobo.4128.1">(),
               v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4129.1">cbegin</span></span><span class="koboSpan" id="kobo.4130.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4131.1">cend</span></span><span class="koboSpan" id="kobo.4132.1">(),
               std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4133.1">back_inserter</span></span><span class="koboSpan" id="kobo.4134.1">(v3));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4135.1">// v3 = {{10, "Task 1.1"},{20, "Task 1.2"},{20, "Task 1.3"},</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4136.1">//       {20, "Task 1.4"},{30, "Task 1.5"},{30, "Task 2.3"},</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4137.1">//       {30, "Task 2.4"},{40, "Task 2.5"},{50, "Task 1.6"}}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4138.1">std::merge()</span></code><span class="koboSpan" id="kobo.4139.1"> copies all the elements from both the input ranges into the output</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.4140.1"> range, producing a new range sorted</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.4141.1"> with respect to the comparison function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4142.1">std::vector&lt;Task&gt; v4;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4143.1">merge</span></span><span class="koboSpan" id="kobo.4144.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4145.1">cbegin</span></span><span class="koboSpan" id="kobo.4146.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4147.1">cend</span></span><span class="koboSpan" id="kobo.4148.1">(),
           v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4149.1">cbegin</span></span><span class="koboSpan" id="kobo.4150.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4151.1">cend</span></span><span class="koboSpan" id="kobo.4152.1">(),
           std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4153.1">back_inserter</span></span><span class="koboSpan" id="kobo.4154.1">(v4));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4155.1">// v4 = {{10, "Task 1.1"},{20, "Task 1.2"},{20, "Task 1.3"},</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4156.1">//       {20, "Task 1.4"},{20, "Task 2.1"},{30, "Task 1.5"},</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4157.1">//       {30, "Task 2.2"},{30, "Task 2.3"},{30, "Task 2.4"},</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4158.1">//       {40, "Task 2.5"},{50, "Task 1.6"},{50, "Task 2.6"}}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4159.1">std::set_intersection()</span></code><span class="koboSpan" id="kobo.4160.1"> copies all the elements that are found in both the input ranges into the output range, producing a new range sorted with respect to the comparison function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4161.1">std::vector&lt;Task&gt; v5;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4162.1">set_intersection</span></span><span class="koboSpan" id="kobo.4163.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4164.1">cbegin</span></span><span class="koboSpan" id="kobo.4165.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4166.1">cend</span></span><span class="koboSpan" id="kobo.4167.1">(),
                      v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4168.1">cbegin</span></span><span class="koboSpan" id="kobo.4169.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4170.1">cend</span></span><span class="koboSpan" id="kobo.4171.1">(),
                      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4172.1">back_inserter</span></span><span class="koboSpan" id="kobo.4173.1">(v5));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4174.1">// v5 = {{20, "Task 1.2"},{30, "Task 1.5"},{50, "Task 1.6"}}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4175.1">std::set_difference()</span></code><span class="koboSpan" id="kobo.4176.1"> copies to the output range all the elements from the first input range that are not found in the second input range. </span><span class="koboSpan" id="kobo.4176.2">For equivalent elements that are found in both ranges, the following rule applies: if an element is found </span><em class="italic"><span class="koboSpan" id="kobo.4177.1">M</span></em><span class="koboSpan" id="kobo.4178.1"> times in the first range and </span><em class="italic"><span class="koboSpan" id="kobo.4179.1">N</span></em><span class="koboSpan" id="kobo.4180.1"> times in the second range, and if </span><em class="italic"><span class="koboSpan" id="kobo.4181.1">M</span></em><span class="koboSpan" id="kobo.4182.1"> &gt; </span><em class="italic"><span class="koboSpan" id="kobo.4183.1">N</span></em><span class="koboSpan" id="kobo.4184.1">, then it is copied </span><em class="italic"><span class="koboSpan" id="kobo.4185.1">M</span></em><span class="koboSpan" id="kobo.4186.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.4187.1">N</span></em><span class="koboSpan" id="kobo.4188.1"> times; otherwise, it is not copied:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4189.1">std::vector&lt;Task&gt; v6;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4190.1">set_difference</span></span><span class="koboSpan" id="kobo.4191.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4192.1">cbegin</span></span><span class="koboSpan" id="kobo.4193.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4194.1">cend</span></span><span class="koboSpan" id="kobo.4195.1">(),
                    v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4196.1">cbegin</span></span><span class="koboSpan" id="kobo.4197.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4198.1">cend</span></span><span class="koboSpan" id="kobo.4199.1">(),
                    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4200.1">back_inserter</span></span><span class="koboSpan" id="kobo.4201.1">(v6));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4202.1">// v6 = {{10, "Task 1.1"},{20, "Task 1.3"},{20, "Task 1.4"}}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4203.1">std::set_symmetric_difference()</span></code><span class="koboSpan" id="kobo.4204.1"> copies to the output range all the elements that are found in either of the two input ranges but not in both of them. </span><span class="koboSpan" id="kobo.4204.2">If an element is found </span><em class="italic"><span class="koboSpan" id="kobo.4205.1">M</span></em><span class="koboSpan" id="kobo.4206.1"> times in the first range and </span><em class="italic"><span class="koboSpan" id="kobo.4207.1">N</span></em><span class="koboSpan" id="kobo.4208.1"> times in the second range, then if </span><em class="italic"><span class="koboSpan" id="kobo.4209.1">M</span></em><span class="koboSpan" id="kobo.4210.1"> &gt; </span><em class="italic"><span class="koboSpan" id="kobo.4211.1">N</span></em><span class="koboSpan" id="kobo.4212.1">, the last </span><em class="italic"><span class="koboSpan" id="kobo.4213.1">M</span></em><span class="koboSpan" id="kobo.4214.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.4215.1">N</span></em><span class="koboSpan" id="kobo.4216.1"> of those elements from the first range are copied into the output range; otherwise, the last </span><em class="italic"><span class="koboSpan" id="kobo.4217.1">N</span></em><span class="koboSpan" id="kobo.4218.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.4219.1">M</span></em><span class="koboSpan" id="kobo.4220.1"> of those elements from the second range will be copied into the output range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4221.1">std::vector&lt;Task&gt; v7;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4222.1">set_symmetric_difference</span></span><span class="koboSpan" id="kobo.4223.1">(v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4224.1">cbegin</span></span><span class="koboSpan" id="kobo.4225.1">(), v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4226.1">cend</span></span><span class="koboSpan" id="kobo.4227.1">(),
                              v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4228.1">cbegin</span></span><span class="koboSpan" id="kobo.4229.1">(), v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4230.1">cend</span></span><span class="koboSpan" id="kobo.4231.1">(),
                              std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4232.1">back_inserter</span></span><span class="koboSpan" id="kobo.4233.1">(v7));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4234.1">// v7 = {{10, "Task 1.1"},{20, "Task 1.3"},{20, "Task 1.4"}</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4235.1">//       {30, "Task 2.3"},{30, "Task 2.4"},{40, "Task 2.5"}}</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4236.1">On</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.4237.1"> the </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.4238.1">other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4239.1">std::includes()</span></code><span class="koboSpan" id="kobo.4240.1"> does not produce an output range; it only checks whether the second range is included in the first range. </span><span class="koboSpan" id="kobo.4240.2">It returns a Boolean value that is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4241.1">true</span></code><span class="koboSpan" id="kobo.4242.1"> if the second range is empty or all its elements are included in the first range, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4243.1">false</span></code><span class="koboSpan" id="kobo.4244.1"> otherwise. </span><span class="koboSpan" id="kobo.4244.2">It also has two overloads, one of which specifies a comparison binary function object.</span></p>
<h2 class="heading-2" id="_idParaDest-302"><span class="koboSpan" id="kobo.4245.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4246.1">Using vector as a default container</span></em><span class="koboSpan" id="kobo.4247.1">, to learn how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4248.1">std::vector</span></code><span class="koboSpan" id="kobo.4249.1"> standard container</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4250.1">Sorting a range</span></em><span class="koboSpan" id="kobo.4251.1"> to learn about the standard algorithms for sorting ranges</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4252.1">Using iterators to insert new elements in a container</span></em><span class="koboSpan" id="kobo.4253.1">, to learn how to use iterators and iterator adapters to add elements to a range</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4254.1">Finding elements in a range</span></em><span class="koboSpan" id="kobo.4255.1">, to learn about the standard algorithms for searching through sequences of values</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-303"><span class="koboSpan" id="kobo.4256.1">Using iterators to insert new elements into a container</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4257.1">When </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.4258.1">you’re working with containers, it is often useful to insert new elements at the beginning, end, or somewhere in the middle. </span><span class="koboSpan" id="kobo.4258.2">There are algorithms, such as the ones we saw in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.4259.1">Using set operations on a range</span></em><span class="koboSpan" id="kobo.4260.1">, that require an iterator to a range to insert into, but if you simply pass an iterator, such as the one returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.4261.1">begin()</span></code><span class="koboSpan" id="kobo.4262.1">, it will not insert but overwrite the elements of the container. </span><span class="koboSpan" id="kobo.4262.2">Moreover, it’s not possible to insert at the end by using the iterator returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.4263.1">end()</span></code><span class="koboSpan" id="kobo.4264.1">. </span><span class="koboSpan" id="kobo.4264.2">In order to perform such operations, the standard library provides a set of iterators and iterator adapters that enable these scenarios.</span></p>
<h2 class="heading-2" id="_idParaDest-304"><span class="koboSpan" id="kobo.4265.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4266.1">The iterators and adapters discussed in this recipe are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4267.1">std</span></code><span class="koboSpan" id="kobo.4268.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4269.1">&lt;iterator&gt;</span></code><span class="koboSpan" id="kobo.4270.1"> header. </span><span class="koboSpan" id="kobo.4270.2">If you include headers such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4271.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.4272.1">, you do not have to explicitly include </span><code class="inlineCode"><span class="koboSpan" id="kobo.4273.1">&lt;iterator&gt;</span></code><span class="koboSpan" id="kobo.4274.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-305"><span class="koboSpan" id="kobo.4275.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4276.1">Use the following iterator adapters to insert new elements into a container:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4277.1">std::back_inserter()</span></code><span class="koboSpan" id="kobo.4278.1"> to insert elements at the end for containers that have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4279.1">push_back()</span></code><span class="koboSpan" id="kobo.4280.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4281.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4282.1">int</span></span><span class="koboSpan" id="kobo.4283.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4284.1">1</span></span><span class="koboSpan" id="kobo.4285.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4286.1">2</span></span><span class="koboSpan" id="kobo.4287.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4288.1">3</span></span><span class="koboSpan" id="kobo.4289.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4290.1">4</span></span><span class="koboSpan" id="kobo.4291.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4292.1">5</span></span><span class="koboSpan" id="kobo.4293.1"> };
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4294.1">fill_n</span></span><span class="koboSpan" id="kobo.4295.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4296.1">back_inserter</span></span><span class="koboSpan" id="kobo.4297.1">(v), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4298.1">3</span></span><span class="koboSpan" id="kobo.4299.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4300.1">0</span></span><span class="koboSpan" id="kobo.4301.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4302.1">// v={1,2,3,4,5,0,0,0}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4303.1">std::front_inserter()</span></code><span class="koboSpan" id="kobo.4304.1"> to insert elements at the beginning for containers that have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4305.1">push_front()</span></code><span class="koboSpan" id="kobo.4306.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4307.1">std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4308.1">int</span></span><span class="koboSpan" id="kobo.4309.1">&gt; l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4310.1">1</span></span><span class="koboSpan" id="kobo.4311.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4312.1">2</span></span><span class="koboSpan" id="kobo.4313.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4314.1">3</span></span><span class="koboSpan" id="kobo.4315.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4316.1">4</span></span><span class="koboSpan" id="kobo.4317.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4318.1">5</span></span><span class="koboSpan" id="kobo.4319.1"> };
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4320.1">fill_n</span></span><span class="koboSpan" id="kobo.4321.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4322.1">front_inserter</span></span><span class="koboSpan" id="kobo.4323.1">(l), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4324.1">3</span></span><span class="koboSpan" id="kobo.4325.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4326.1">0</span></span><span class="koboSpan" id="kobo.4327.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4328.1">// l={0,0,0,1,2,3,4,5}</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4329.1">std::inserter()</span></code><span class="koboSpan" id="kobo.4330.1"> to insert anywhere in a container, for containers that have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4331.1">insert()</span></code><span class="koboSpan" id="kobo.4332.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4333.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4334.1">int</span></span><span class="koboSpan" id="kobo.4335.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4336.1">1</span></span><span class="koboSpan" id="kobo.4337.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4338.1">2</span></span><span class="koboSpan" id="kobo.4339.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4340.1">3</span></span><span class="koboSpan" id="kobo.4341.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4342.1">4</span></span><span class="koboSpan" id="kobo.4343.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4344.1">5</span></span><span class="koboSpan" id="kobo.4345.1"> };
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4346.1">fill_n</span></span><span class="koboSpan" id="kobo.4347.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4348.1">inserter</span></span><span class="koboSpan" id="kobo.4349.1">(v, v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4350.1">begin</span></span><span class="koboSpan" id="kobo.4351.1">()), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4352.1">3</span></span><span class="koboSpan" id="kobo.4353.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4354.1">0</span></span><span class="koboSpan" id="kobo.4355.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4356.1">// v={0,0,0,1,2,3,4,5}</span></span><span class="koboSpan" id="kobo.4357.1">
std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4358.1">int</span></span><span class="koboSpan" id="kobo.4359.1">&gt; l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4360.1">1</span></span><span class="koboSpan" id="kobo.4361.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4362.1">2</span></span><span class="koboSpan" id="kobo.4363.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4364.1">3</span></span><span class="koboSpan" id="kobo.4365.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4366.1">4</span></span><span class="koboSpan" id="kobo.4367.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4368.1">5</span></span><span class="koboSpan" id="kobo.4369.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4370.1">auto</span></span><span class="koboSpan" id="kobo.4371.1"> it = l.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4372.1">begin</span></span><span class="koboSpan" id="kobo.4373.1">();
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4374.1">advance</span></span><span class="koboSpan" id="kobo.4375.1">(it, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4376.1">3</span></span><span class="koboSpan" id="kobo.4377.1">);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4378.1">fill_n</span></span><span class="koboSpan" id="kobo.4379.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4380.1">inserter</span></span><span class="koboSpan" id="kobo.4381.1">(l, it), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4382.1">3</span></span><span class="koboSpan" id="kobo.4383.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4384.1">0</span></span><span class="koboSpan" id="kobo.4385.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4386.1">// l={1,2,3,0,0,0,4,5}</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-306"><span class="koboSpan" id="kobo.4387.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4388.1">std::back_inserter()</span></code><span class="koboSpan" id="kobo.4389.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4390.1">std::front_inserter()</span></code><span class="koboSpan" id="kobo.4391.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4392.1">std::inserter()</span></code><span class="koboSpan" id="kobo.4393.1"> are all helper functions</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.4394.1"> that create iterator adapters of the types </span><code class="inlineCode"><span class="koboSpan" id="kobo.4395.1">std::back_insert_iterator</span></code><span class="koboSpan" id="kobo.4396.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4397.1">std::front_insert_iterator</span></code><span class="koboSpan" id="kobo.4398.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4399.1">std::insert_iterator</span></code><span class="koboSpan" id="kobo.4400.1">. </span><span class="koboSpan" id="kobo.4400.2">These are all output iterators that append, prepend, or insert into the container for which they were constructed. </span><span class="koboSpan" id="kobo.4400.3">Incrementing and dereferencing these iterators does not do anything. </span><span class="koboSpan" id="kobo.4400.4">However, upon assignment, these iterators call the following methods from the container:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4401.1">std::back_insterter_iterator</span></code><span class="koboSpan" id="kobo.4402.1"> calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.4403.1">push_back()</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4404.1">std::front_inserter_iterator</span></code><span class="koboSpan" id="kobo.4405.1"> calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.4406.1">push_front()</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4407.1">std::insert_iterator</span></code><span class="koboSpan" id="kobo.4408.1"> calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.4409.1">insert()</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4410.1">The following is the oversimplified implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4411.1">std::back_inserter_iterator</span></code><span class="koboSpan" id="kobo.4412.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4413.1">template</span></span><span class="koboSpan" id="kobo.4414.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4415.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4416.1">C</span></span><span class="koboSpan" id="kobo.4417.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4418.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4419.1">back_insert_iterator</span></span><span class="koboSpan" id="kobo.4420.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4421.1">public</span></span><span class="koboSpan" id="kobo.4422.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4423.1">typedef</span></span><span class="koboSpan" id="kobo.4424.1"> back_insert_iterator&lt;C&gt; T;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4425.1">typedef</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4426.1">typename</span></span><span class="koboSpan" id="kobo.4427.1"> C::value_type V;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4428.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4429.1">back_insert_iterator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4430.1">( C&amp; c )</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4431.1"> :container( &amp;c ) {</span></span><span class="koboSpan" id="kobo.4432.1"> }
  T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4433.1">operator</span></span><span class="koboSpan" id="kobo.4434.1">=( </span><span class="hljs-type"><span class="koboSpan" id="kobo.4435.1">const</span></span><span class="koboSpan" id="kobo.4436.1"> V&amp; val ) {
    container-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4437.1">push_back</span></span><span class="koboSpan" id="kobo.4438.1">( val );
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4439.1">return</span></span><span class="koboSpan" id="kobo.4440.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4441.1">this</span></span><span class="koboSpan" id="kobo.4442.1">;
  }
  T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4443.1">operator</span></span><span class="koboSpan" id="kobo.4444.1">*() { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4445.1">return</span></span><span class="koboSpan" id="kobo.4446.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4447.1">this</span></span><span class="koboSpan" id="kobo.4448.1">; }
  T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4449.1">operator</span></span><span class="koboSpan" id="kobo.4450.1">++() { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4451.1">return</span></span><span class="koboSpan" id="kobo.4452.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4453.1">this</span></span><span class="koboSpan" id="kobo.4454.1">; }
  T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4455.1">operator</span></span><span class="koboSpan" id="kobo.4456.1">++( </span><span class="hljs-type"><span class="koboSpan" id="kobo.4457.1">int</span></span><span class="koboSpan" id="kobo.4458.1"> ) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4459.1">return</span></span><span class="koboSpan" id="kobo.4460.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4461.1">this</span></span><span class="koboSpan" id="kobo.4462.1">; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4463.1">protected</span></span><span class="koboSpan" id="kobo.4464.1">:
  C* container;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4465.1">Because of the way the assignment operator works, these iterators can only be used with some standard containers:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4466.1">std::back_insert_iterator</span></code><span class="koboSpan" id="kobo.4467.1"> can be used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4468.1">std::vector</span></code><span class="koboSpan" id="kobo.4469.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4470.1">std::list</span></code><span class="koboSpan" id="kobo.4471.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4472.1">std::deque</span></code><span class="koboSpan" id="kobo.4473.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4474.1">std::basic_string</span></code><span class="koboSpan" id="kobo.4475.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4476.1">std::front_insert_iterator</span></code><span class="koboSpan" id="kobo.4477.1"> can be used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4478.1">std::list</span></code><span class="koboSpan" id="kobo.4479.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4480.1">std::forward_list</span></code><span class="koboSpan" id="kobo.4481.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4482.1">std:deque</span></code><span class="koboSpan" id="kobo.4483.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4484.1">std::insert_iterator</span></code><span class="koboSpan" id="kobo.4485.1"> can be used with all the standard containers.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4486.1">The following example inserts three elements with the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.4487.1">0</span></code><span class="koboSpan" id="kobo.4488.1"> at the beginning of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4489.1">std::vector</span></code><span class="koboSpan" id="kobo.4490.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4491.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4492.1">int</span></span><span class="koboSpan" id="kobo.4493.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4494.1">1</span></span><span class="koboSpan" id="kobo.4495.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4496.1">2</span></span><span class="koboSpan" id="kobo.4497.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4498.1">3</span></span><span class="koboSpan" id="kobo.4499.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4500.1">4</span></span><span class="koboSpan" id="kobo.4501.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4502.1">5</span></span><span class="koboSpan" id="kobo.4503.1"> };
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4504.1">fill_n</span></span><span class="koboSpan" id="kobo.4505.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4506.1">inserter</span></span><span class="koboSpan" id="kobo.4507.1">(v, v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4508.1">begin</span></span><span class="koboSpan" id="kobo.4509.1">()), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4510.1">3</span></span><span class="koboSpan" id="kobo.4511.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4512.1">0</span></span><span class="koboSpan" id="kobo.4513.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4514.1">// v={0,0,0,1,2,3,4,5}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4515.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4516.1">std::inserter()</span></code><span class="koboSpan" id="kobo.4517.1"> adapter</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.4518.1"> takes two arguments: the container and the iterator where an element is supposed to be inserted. </span><span class="koboSpan" id="kobo.4518.2">Upon calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4519.1">insert()</span></code><span class="koboSpan" id="kobo.4520.1"> on the container, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4521.1">std::insert_iterator</span></code><span class="koboSpan" id="kobo.4522.1"> increments the iterator, so upon being assigned again, it can insert a new element into the next position. </span><span class="koboSpan" id="kobo.4522.2">Take a look at the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4523.1">T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4524.1">operator</span></span><span class="koboSpan" id="kobo.4525.1">=(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4526.1">const</span></span><span class="koboSpan" id="kobo.4527.1"> V&amp; v)
{
  iter = container-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4528.1">insert</span></span><span class="koboSpan" id="kobo.4529.1">(iter, v);
  ++iter;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4530.1">return</span></span><span class="koboSpan" id="kobo.4531.1"> (*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4532.1">this</span></span><span class="koboSpan" id="kobo.4533.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4534.1">This snippet shows (conceptually) how the assignment operator is implemented for this </span><code class="inlineCode"><span class="koboSpan" id="kobo.4535.1">std::inserter_iterator</span></code><span class="koboSpan" id="kobo.4536.1"> adapter. </span><span class="koboSpan" id="kobo.4536.2">You can see that it first calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4537.1">insert()</span></code><span class="koboSpan" id="kobo.4538.1"> member function of the container and then increments the returned iterator. </span><span class="koboSpan" id="kobo.4538.2">Because all the standard containers have a method called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4539.1">insert()</span></code><span class="koboSpan" id="kobo.4540.1"> with this signature, this adapter can be used with all these containers.</span></p>
<h2 class="heading-2" id="_idParaDest-307"><span class="koboSpan" id="kobo.4541.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4542.1">These iterator adapters are intended to be used with algorithms or functions that insert multiple elements into a range. </span><span class="koboSpan" id="kobo.4542.2">They can also be used, of course, to insert a single element, but that is rather an anti-pattern, since simply calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4543.1">push_back()</span></code><span class="koboSpan" id="kobo.4544.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4545.1">push_front()</span></code><span class="koboSpan" id="kobo.4546.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4547.1">insert()</span></code><span class="koboSpan" id="kobo.4548.1"> is much simpler and intuitive in this case. </span><span class="koboSpan" id="kobo.4548.2">Consider the following snippets:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4549.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4550.1">int</span></span><span class="koboSpan" id="kobo.4551.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4552.1">1</span></span><span class="koboSpan" id="kobo.4553.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4554.1">2</span></span><span class="koboSpan" id="kobo.4555.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4556.1">3</span></span><span class="koboSpan" id="kobo.4557.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4558.1">4</span></span><span class="koboSpan" id="kobo.4559.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4560.1">5</span></span><span class="koboSpan" id="kobo.4561.1"> };
*std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4562.1">back_inserter</span></span><span class="koboSpan" id="kobo.4563.1">(v) = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4564.1">6</span></span><span class="koboSpan" id="kobo.4565.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4566.1">// v = {1,2,3,4,5,6}</span></span><span class="koboSpan" id="kobo.4567.1">
std::back_insert_iterator&lt;std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4568.1">int</span></span><span class="koboSpan" id="kobo.4569.1">&gt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4570.1">it</span></span><span class="koboSpan" id="kobo.4571.1">(v);
*it = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4572.1">7</span></span><span class="koboSpan" id="kobo.4573.1">;                    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4574.1">// v = {1,2,3,4,5,6,7}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4575.1">The</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.4576.1"> examples shown here, where adaptor iterators are used to insert a single element, should be avoided. </span><span class="koboSpan" id="kobo.4576.2">They do not provide any benefit; they only make the code cluttered.</span></p>
<h2 class="heading-2" id="_idParaDest-308"><span class="koboSpan" id="kobo.4577.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4578.1">Using set operations on a range</span></em><span class="koboSpan" id="kobo.4579.1">, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-309"><span class="koboSpan" id="kobo.4580.1">Writing your own random-access iterator</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4581.1">In the</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.4582.1"> first chapter, we saw how we can enable range-based for loops for custom types by implementing iterators, as well as free </span><code class="inlineCode"><span class="koboSpan" id="kobo.4583.1">begin()</span></code><span class="koboSpan" id="kobo.4584.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4585.1">end()</span></code><span class="koboSpan" id="kobo.4586.1"> functions to return iterators to the first and one-past-the-last element of the custom range. </span><span class="koboSpan" id="kobo.4586.2">You might have noticed that the minimal iterator implementation that we provided in that recipe does not meet the requirements for a standard iterator. </span><span class="koboSpan" id="kobo.4586.3">This is because it cannot be copy constructible or assigned and cannot be incremented. </span><span class="koboSpan" id="kobo.4586.4">In this recipe, we will build upon that example and show you how to create a random-access iterator that meets all requirements.</span></p>
<h2 class="heading-2" id="_idParaDest-310"><span class="koboSpan" id="kobo.4587.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4588.1">For this recipe, you should know the types of iterators the standard defines and how they are different. </span><span class="koboSpan" id="kobo.4588.2">A good overview of their requirements is available at </span><a href="http://www.cplusplus.com/reference/iterator/"><span class="url"><span class="koboSpan" id="kobo.4589.1">http://www.cplusplus.com/reference/iterator/</span></span></a><span class="koboSpan" id="kobo.4590.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4591.1">To exemplify how to write a random-access iterator, we will consider a variant of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4592.1">dummy_array</span></code><span class="koboSpan" id="kobo.4593.1"> class used in the </span><em class="italic"><span class="koboSpan" id="kobo.4594.1">Enabling range-based for loops for custom types</span></em><span class="koboSpan" id="kobo.4595.1"> recipe of </span><em class="chapterRef"><span class="koboSpan" id="kobo.4596.1">Chapter 1</span></em><span class="koboSpan" id="kobo.4597.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4598.1">Learning Modern Core Language Features</span></em><span class="koboSpan" id="kobo.4599.1">. </span><span class="koboSpan" id="kobo.4599.2">This is a very simple array concept with no practical value other than serving as a code base for demonstrating iterators:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4600.1">template</span></span><span class="koboSpan" id="kobo.4601.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4602.1">typename</span></span><span class="koboSpan" id="kobo.4603.1"> Type, </span><span class="hljs-type"><span class="koboSpan" id="kobo.4604.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4605.1">const</span></span><span class="koboSpan" id="kobo.4606.1"> SIZE&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4607.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4608.1">dummy_array</span></span><span class="koboSpan" id="kobo.4609.1">
{
  Type data[SIZE] = {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4610.1">public</span></span><span class="koboSpan" id="kobo.4611.1">:
  Type&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4612.1">operator</span></span><span class="koboSpan" id="kobo.4613.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.4614.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4615.1">const</span></span><span class="koboSpan" id="kobo.4616.1"> index)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4617.1">if</span></span><span class="koboSpan" id="kobo.4618.1"> (index &lt; SIZE) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4619.1">return</span></span><span class="koboSpan" id="kobo.4620.1"> data[index];
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4621.1">throw</span></span><span class="koboSpan" id="kobo.4622.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4623.1">out_of_range</span></span><span class="koboSpan" id="kobo.4624.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4625.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4626.1">index out of range"</span></span><span class="koboSpan" id="kobo.4627.1">);
  }
  Type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4628.1">const</span></span><span class="koboSpan" id="kobo.4629.1"> &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4630.1">operator</span></span><span class="koboSpan" id="kobo.4631.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.4632.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4633.1">const</span></span><span class="koboSpan" id="kobo.4634.1"> index) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4635.1">const</span></span><span class="koboSpan" id="kobo.4636.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4637.1">if</span></span><span class="koboSpan" id="kobo.4638.1"> (index &lt; SIZE) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4639.1">return</span></span><span class="koboSpan" id="kobo.4640.1"> data[index];
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4641.1">throw</span></span><span class="koboSpan" id="kobo.4642.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4643.1">out_of_range</span></span><span class="koboSpan" id="kobo.4644.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4645.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4646.1">index out of range"</span></span><span class="koboSpan" id="kobo.4647.1">);
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4648.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4649.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4650.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4651.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4652.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4653.1">return</span></span><span class="koboSpan" id="kobo.4654.1"> SIZE; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4655.1">All the </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.4656.1">code shown in the next section, the iterator classes, typedefs, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4657.1">begin()</span></code><span class="koboSpan" id="kobo.4658.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4659.1">end()</span></code><span class="koboSpan" id="kobo.4660.1"> functions, will be a part of this class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4661.1">Also, in this recipe, we will look at an example utilizing the following class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4662.1">Tag</span></code><span class="koboSpan" id="kobo.4663.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4664.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4665.1">Tag</span></span><span class="koboSpan" id="kobo.4666.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.4667.1">int</span></span><span class="koboSpan" id="kobo.4668.1"> id;
   std::string name;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4669.1">Tag</span></span><span class="koboSpan" id="kobo.4670.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4671.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4672.1">const</span></span><span class="koboSpan" id="kobo.4673.1"> id = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4674.1">0</span></span><span class="koboSpan" id="kobo.4675.1">, std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.4676.1">const</span></span><span class="koboSpan" id="kobo.4677.1">&amp; name = </span><span class="hljs-string"><span class="koboSpan" id="kobo.4678.1">""</span></span><span class="koboSpan" id="kobo.4679.1">s) :
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4680.1">id</span></span><span class="koboSpan" id="kobo.4681.1">(id), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4682.1">name</span></span><span class="koboSpan" id="kobo.4683.1">(name)
   {}
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-311"><span class="koboSpan" id="kobo.4684.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4685.1">To provide mutable and constant random-access iterators for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4686.1">dummy_array</span></code><span class="koboSpan" id="kobo.4687.1"> class shown in the previous section, add the following members to the class:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4688.1">An iterator class template, which is parameterized with the type of elements and the size of the array. </span><span class="koboSpan" id="kobo.4688.2">The class must have the following public typedefs that define standard synonyms:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4689.1">template</span></span><span class="koboSpan" id="kobo.4690.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4691.1">typename</span></span><span class="koboSpan" id="kobo.4692.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.4693.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4694.1">const</span></span><span class="koboSpan" id="kobo.4695.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4696.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4697.1">dummy_array_iterator</span></span><span class="koboSpan" id="kobo.4698.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4699.1">public</span></span><span class="koboSpan" id="kobo.4700.1">:
  using self_type         = dummy_array_iterator;
  using value_type        = T;
  using reference         = T&amp;;
  using pointer           = T* ;
  using iterator_category = std::random_access_iterator_tag;
  using difference_type   = ptrdiff_t;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4701.1">Private </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.4702.1">members for the iterator class—a pointer to the array data and a current index into the array:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4703.1">private</span></span><span class="koboSpan" id="kobo.4704.1">:
  pointer ptr = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4705.1">nullptr</span></span><span class="koboSpan" id="kobo.4706.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4707.1">size_t</span></span><span class="koboSpan" id="kobo.4708.1"> index = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4709.1">0</span></span><span class="koboSpan" id="kobo.4710.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4711.1">A private method for the iterator class to check whether two iterator instances point to the same array data:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4712.1">private</span></span><span class="koboSpan" id="kobo.4713.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4714.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4715.1">compatible</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4716.1">(self_type </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4717.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4718.1"> &amp; other)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4719.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4720.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4721.1">return</span></span><span class="koboSpan" id="kobo.4722.1"> ptr == other.ptr;
  }
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4723.1">An explicit constructor for the iterator class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4724.1">public</span></span><span class="koboSpan" id="kobo.4725.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4726.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4727.1">dummy_array_iterator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4728.1">(pointer ptr,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4729.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4730.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4731.1"> index)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4732.1">  : ptr(ptr), index(index) {</span></span><span class="koboSpan" id="kobo.4733.1"> }
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4734.1">Iterator class members to meet common requirements for all iterators—copy-constructible, copy-assignable, destructible, prefix, and postfix incrementable. </span><span class="koboSpan" id="kobo.4734.2">In this implementation, the post-increment operator is implemented in terms of the pre-increment operator to avoid code duplication:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.4735.1">dummy_array_iterator</span></span><span class="koboSpan" id="kobo.4736.1">(dummy_array_iterator </span><span class="hljs-type"><span class="koboSpan" id="kobo.4737.1">const</span></span><span class="koboSpan" id="kobo.4738.1"> &amp; o)
    = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4739.1">default</span></span><span class="koboSpan" id="kobo.4740.1">;
dummy_array_iterator&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4741.1">operator</span></span><span class="koboSpan" id="kobo.4742.1">=(dummy_array_iterator </span><span class="hljs-type"><span class="koboSpan" id="kobo.4743.1">const</span></span><span class="koboSpan" id="kobo.4744.1"> &amp; o)
    = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4745.1">default</span></span><span class="koboSpan" id="kobo.4746.1">;
~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4747.1">dummy_array_iterator</span></span><span class="koboSpan" id="kobo.4748.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4749.1">default</span></span><span class="koboSpan" id="kobo.4750.1">;
self_type &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4751.1">operator</span></span><span class="koboSpan" id="kobo.4752.1">++ ()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4753.1">if</span></span><span class="koboSpan" id="kobo.4754.1"> (index &gt;= Size)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4755.1">throw</span></span><span class="koboSpan" id="kobo.4756.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4757.1">out_of_range</span></span><span class="koboSpan" id="kobo.4758.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4759.1">"Iterator cannot be incremented </span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.4760.1">                             past the end of range."</span></span><span class="koboSpan" id="kobo.4761.1">);
  ++index;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4762.1">return</span></span><span class="koboSpan" id="kobo.4763.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4764.1">this</span></span><span class="koboSpan" id="kobo.4765.1">;
}
self_type </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4766.1">operator</span></span><span class="koboSpan" id="kobo.4767.1">++ (</span><span class="hljs-type"><span class="koboSpan" id="kobo.4768.1">int</span></span><span class="koboSpan" id="kobo.4769.1">)
{
  self_type tmp = *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4770.1">this</span></span><span class="koboSpan" id="kobo.4771.1">;
  ++*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4772.1">this</span></span><span class="koboSpan" id="kobo.4773.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4774.1">return</span></span><span class="koboSpan" id="kobo.4775.1"> tmp;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4776.1">Iterator </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.4777.1">class members to meet input iterator requirements—test for equality/inequality, dereferenceable as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4778.1">rvalues</span></code><span class="koboSpan" id="kobo.4779.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4780.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4781.1">operator</span></span><span class="koboSpan" id="kobo.4782.1">== (self_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4783.1">const</span></span><span class="koboSpan" id="kobo.4784.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4785.1">const</span></span><span class="koboSpan" id="kobo.4786.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4787.1">assert</span></span><span class="koboSpan" id="kobo.4788.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4789.1">compatible</span></span><span class="koboSpan" id="kobo.4790.1">(other));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4791.1">return</span></span><span class="koboSpan" id="kobo.4792.1"> index == other.index;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4793.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4794.1">operator</span></span><span class="koboSpan" id="kobo.4795.1">!= (self_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4796.1">const</span></span><span class="koboSpan" id="kobo.4797.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4798.1">const</span></span><span class="koboSpan" id="kobo.4799.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4800.1">return</span></span><span class="koboSpan" id="kobo.4801.1"> !(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4802.1">this</span></span><span class="koboSpan" id="kobo.4803.1"> == other);
}
reference </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4804.1">operator</span></span><span class="koboSpan" id="kobo.4805.1">* () </span><span class="hljs-type"><span class="koboSpan" id="kobo.4806.1">const</span></span><span class="koboSpan" id="kobo.4807.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4808.1">if</span></span><span class="koboSpan" id="kobo.4809.1"> (ptr == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4810.1">nullptr</span></span><span class="koboSpan" id="kobo.4811.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4812.1">throw</span></span><span class="koboSpan" id="kobo.4813.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4814.1">bad_function_call</span></span><span class="koboSpan" id="kobo.4815.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4816.1">return</span></span><span class="koboSpan" id="kobo.4817.1"> *(ptr + index);
}
reference </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4818.1">operator</span></span><span class="koboSpan" id="kobo.4819.1">-&gt; () </span><span class="hljs-type"><span class="koboSpan" id="kobo.4820.1">const</span></span><span class="koboSpan" id="kobo.4821.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4822.1">if</span></span><span class="koboSpan" id="kobo.4823.1"> (ptr == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4824.1">nullptr</span></span><span class="koboSpan" id="kobo.4825.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4826.1">throw</span></span><span class="koboSpan" id="kobo.4827.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4828.1">bad_function_call</span></span><span class="koboSpan" id="kobo.4829.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4830.1">return</span></span><span class="koboSpan" id="kobo.4831.1"> *(ptr + index);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4832.1">Iterator</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.4833.1"> class members to meet forward iterator requirements—default constructible:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.4834.1">dummy_array_iterator</span></span><span class="koboSpan" id="kobo.4835.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4836.1">default</span></span><span class="koboSpan" id="kobo.4837.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4838.1">Iterator class members to meet bidirectional iterator requirements—decrementable:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4839.1">self_type &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4840.1">operator</span></span><span class="koboSpan" id="kobo.4841.1">--()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4842.1">if</span></span><span class="koboSpan" id="kobo.4843.1"> (index &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.4844.1">0</span></span><span class="koboSpan" id="kobo.4845.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4846.1">throw</span></span><span class="koboSpan" id="kobo.4847.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4848.1">out_of_range</span></span><span class="koboSpan" id="kobo.4849.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4850.1">"Iterator cannot be decremented</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.4851.1">                             past the end of range."</span></span><span class="koboSpan" id="kobo.4852.1">);
  --index;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4853.1">return</span></span><span class="koboSpan" id="kobo.4854.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4855.1">this</span></span><span class="koboSpan" id="kobo.4856.1">;
}
self_type </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4857.1">operator</span></span><span class="koboSpan" id="kobo.4858.1">--(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4859.1">int</span></span><span class="koboSpan" id="kobo.4860.1">)
{
  self_type tmp = *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4861.1">this</span></span><span class="koboSpan" id="kobo.4862.1">;
  --*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4863.1">this</span></span><span class="koboSpan" id="kobo.4864.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4865.1">return</span></span><span class="koboSpan" id="kobo.4866.1"> tmp;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4867.1">Iterator class members to meet random access iterator requirements—arithmetic add and subtract, comparable for inequality with other iterators, compound assignments, and offset dereferenceable:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4868.1">self_type </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4869.1">operator</span></span><span class="koboSpan" id="kobo.4870.1">+(difference_type offset) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4871.1">const</span></span><span class="koboSpan" id="kobo.4872.1">
{
  self_type tmp = *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4873.1">this</span></span><span class="koboSpan" id="kobo.4874.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4875.1">return</span></span><span class="koboSpan" id="kobo.4876.1"> tmp += offset;
}
self_type </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4877.1">operator</span></span><span class="koboSpan" id="kobo.4878.1">-(difference_type offset) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4879.1">const</span></span><span class="koboSpan" id="kobo.4880.1">
{
  self_type tmp = *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4881.1">this</span></span><span class="koboSpan" id="kobo.4882.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4883.1">return</span></span><span class="koboSpan" id="kobo.4884.1"> tmp -= offset;
}
difference_type </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4885.1">operator</span></span><span class="koboSpan" id="kobo.4886.1">-(self_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4887.1">const</span></span><span class="koboSpan" id="kobo.4888.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4889.1">const</span></span><span class="koboSpan" id="kobo.4890.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4891.1">assert</span></span><span class="koboSpan" id="kobo.4892.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4893.1">compatible</span></span><span class="koboSpan" id="kobo.4894.1">(other));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4895.1">return</span></span><span class="koboSpan" id="kobo.4896.1"> (index - other.index);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4897.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4898.1">operator</span></span><span class="koboSpan" id="kobo.4899.1">&lt;(self_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4900.1">const</span></span><span class="koboSpan" id="kobo.4901.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4902.1">const</span></span><span class="koboSpan" id="kobo.4903.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4904.1">assert</span></span><span class="koboSpan" id="kobo.4905.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4906.1">compatible</span></span><span class="koboSpan" id="kobo.4907.1">(other));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4908.1">return</span></span><span class="koboSpan" id="kobo.4909.1"> index &lt; other.index;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4910.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4911.1">operator</span></span><span class="koboSpan" id="kobo.4912.1">&gt;(self_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4913.1">const</span></span><span class="koboSpan" id="kobo.4914.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4915.1">const</span></span><span class="koboSpan" id="kobo.4916.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4917.1">return</span></span><span class="koboSpan" id="kobo.4918.1"> other &lt; *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4919.1">this</span></span><span class="koboSpan" id="kobo.4920.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4921.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4922.1">operator</span></span><span class="koboSpan" id="kobo.4923.1">&lt;=(self_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4924.1">const</span></span><span class="koboSpan" id="kobo.4925.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4926.1">const</span></span><span class="koboSpan" id="kobo.4927.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4928.1">return</span></span><span class="koboSpan" id="kobo.4929.1"> !(other &lt; *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4930.1">this</span></span><span class="koboSpan" id="kobo.4931.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4932.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4933.1">operator</span></span><span class="koboSpan" id="kobo.4934.1">&gt;=(self_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4935.1">const</span></span><span class="koboSpan" id="kobo.4936.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4937.1">const</span></span><span class="koboSpan" id="kobo.4938.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4939.1">return</span></span><span class="koboSpan" id="kobo.4940.1"> !(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4941.1">this</span></span><span class="koboSpan" id="kobo.4942.1"> &lt; other);
}
self_type &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4943.1">operator</span></span><span class="koboSpan" id="kobo.4944.1">+=(difference_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4945.1">const</span></span><span class="koboSpan" id="kobo.4946.1"> offset)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4947.1">if</span></span><span class="koboSpan" id="kobo.4948.1"> (index + offset &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4949.1">0</span></span><span class="koboSpan" id="kobo.4950.1"> || index + offset &gt; Size)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4951.1">throw</span></span><span class="koboSpan" id="kobo.4952.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4953.1">out_of_range</span></span><span class="koboSpan" id="kobo.4954.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4955.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4956.1">Iterator cannot be incremented </span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.4957.1">                             past the end of range."</span></span><span class="koboSpan" id="kobo.4958.1">);
  index += offset;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4959.1">return</span></span><span class="koboSpan" id="kobo.4960.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4961.1">this</span></span><span class="koboSpan" id="kobo.4962.1">;
}
self_type &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4963.1">operator</span></span><span class="koboSpan" id="kobo.4964.1">-=(difference_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4965.1">const</span></span><span class="koboSpan" id="kobo.4966.1"> offset)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4967.1">return</span></span><span class="koboSpan" id="kobo.4968.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4969.1">this</span></span><span class="koboSpan" id="kobo.4970.1"> += -offset;
}
value_type &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4971.1">operator</span></span><span class="koboSpan" id="kobo.4972.1">[](difference_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4973.1">const</span></span><span class="koboSpan" id="kobo.4974.1"> offset)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4975.1">return</span></span><span class="koboSpan" id="kobo.4976.1"> (*(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4977.1">this</span></span><span class="koboSpan" id="kobo.4978.1"> + offset));
}
value_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4979.1">const</span></span><span class="koboSpan" id="kobo.4980.1"> &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4981.1">operator</span></span><span class="koboSpan" id="kobo.4982.1">[](difference_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.4983.1">const</span></span><span class="koboSpan" id="kobo.4984.1"> offset)
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4985.1">const</span></span><span class="koboSpan" id="kobo.4986.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4987.1">return</span></span><span class="koboSpan" id="kobo.4988.1"> (*(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4989.1">this</span></span><span class="koboSpan" id="kobo.4990.1"> + offset));
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4991.1">Add typedefs to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4992.1">dummy_array</span></code><span class="koboSpan" id="kobo.4993.1"> class for mutable and constant iterator synonyms:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4994.1">public</span></span><span class="koboSpan" id="kobo.4995.1">:
  using iterator = dummy_array_iterator&lt;Type, SIZE&gt;;
  using constant_iterator = dummy_array_iterator&lt;Type const, 
                                                 SIZE&gt;;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4996.1">Add</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.4997.1"> the public </span><code class="inlineCode"><span class="koboSpan" id="kobo.4998.1">begin()</span></code><span class="koboSpan" id="kobo.4999.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5000.1">end()</span></code><span class="koboSpan" id="kobo.5001.1"> functions to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5002.1">dummy_array</span></code><span class="koboSpan" id="kobo.5003.1"> class to return the iterators to the first and one-past-last elements in the array:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5004.1">iterator </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5005.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5006.1">()</span></span><span class="koboSpan" id="kobo.5007.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5008.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5009.1">iterator</span></span><span class="koboSpan" id="kobo.5010.1">(data, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5011.1">0</span></span><span class="koboSpan" id="kobo.5012.1">);
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.5013.1">iterator </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5014.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5015.1">()</span></span><span class="koboSpan" id="kobo.5016.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5017.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5018.1">iterator</span></span><span class="koboSpan" id="kobo.5019.1">(data, SIZE);
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.5020.1">constant_iterator </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5021.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5022.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5023.1">const</span></span><span class="koboSpan" id="kobo.5024.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5025.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5026.1">constant_iterator</span></span><span class="koboSpan" id="kobo.5027.1">(data, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5028.1">0</span></span><span class="koboSpan" id="kobo.5029.1">);
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.5030.1">constant_iterator </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5031.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5032.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5033.1">const</span></span><span class="koboSpan" id="kobo.5034.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5035.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5036.1">constant_iterator</span></span><span class="koboSpan" id="kobo.5037.1">(data, SIZE);
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-312"><span class="koboSpan" id="kobo.5038.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5039.1">The</span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.5040.1"> standard library defines five categories of iterators:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.5041.1">Input iterators</span></strong><span class="koboSpan" id="kobo.5042.1">: These are </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.5043.1">the simplest category and guarantee validity only for single-pass sequential algorithms. </span><span class="koboSpan" id="kobo.5043.2">After being incremented, the previous copies may become invalid.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.5044.1">Output iterators</span></strong><span class="koboSpan" id="kobo.5045.1">: These </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.5046.1">are basically input iterators that can be used to write to the pointed element.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.5047.1">Forward iterators</span></strong><span class="koboSpan" id="kobo.5048.1">: These </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.5049.1">can read (and write) data to the pointed element. </span><span class="koboSpan" id="kobo.5049.2">They satisfy the requirements for input iterators and, in addition, must be default constructible and must support multi-pass scenarios without invalidating the previous copies.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.5050.1">Bidirectional iterators</span></strong><span class="koboSpan" id="kobo.5051.1">: These </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.5052.1">are forward iterators that, in addition, support decrementing so that they can move in both directions.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.5053.1">Random access iterators</span></strong><span class="koboSpan" id="kobo.5054.1">: These </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.5055.1">support access to any element in the container in constant time. </span><span class="koboSpan" id="kobo.5055.2">They implement all the requirements for bidirectional iterators, and, in addition, support arithmetic operations </span><code class="inlineCode"><span class="koboSpan" id="kobo.5056.1">+</span></code><span class="koboSpan" id="kobo.5057.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5058.1">-</span></code><span class="koboSpan" id="kobo.5059.1">, compound assignments </span><code class="inlineCode"><span class="koboSpan" id="kobo.5060.1">+=</span></code><span class="koboSpan" id="kobo.5061.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5062.1">-=</span></code><span class="koboSpan" id="kobo.5063.1">, comparisons with other iterators with </span><code class="inlineCode"><span class="koboSpan" id="kobo.5064.1">&lt;</span></code><span class="koboSpan" id="kobo.5065.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5066.1">&lt;=</span></code><span class="koboSpan" id="kobo.5067.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5068.1">&gt;</span></code><span class="koboSpan" id="kobo.5069.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5070.1">&gt;=</span></code><span class="koboSpan" id="kobo.5071.1">, and the offset dereference operator.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5072.1">Forward, bidirectional, and random-access iterators that also implement the requirements of output iterators are called </span><em class="italic"><span class="koboSpan" id="kobo.5073.1">mutable iterators</span></em><span class="koboSpan" id="kobo.5074.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5075.1">In the previous section, we saw how to implement random access iterators, with a step-by-step walkthrough of the requirements of each category of iterators (as each iterator category includes the requirements of the previous category and adds new requirements). </span><span class="koboSpan" id="kobo.5075.2">The iterator class template is common for both constant and mutable iterators, and we have defined two synonyms for it called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5076.1">iterator</span></code><span class="koboSpan" id="kobo.5077.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5078.1">constant_iterator</span></code><span class="koboSpan" id="kobo.5079.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5080.1">After implementing the inner iterator class template, we also defined the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5081.1">begin()</span></code><span class="koboSpan" id="kobo.5082.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5083.1">end()</span></code><span class="koboSpan" id="kobo.5084.1"> member functions, which return an iterator to the first and the one-past-last element in the array, respectively. </span><span class="koboSpan" id="kobo.5084.2">These methods have overloads to return mutable or constant iterators, depending on whether the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5085.1">dummy_array</span></code><span class="koboSpan" id="kobo.5086.1"> class instance is mutable or constant.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5087.1">With this </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.5088.1">implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5089.1">dummy_array</span></code><span class="koboSpan" id="kobo.5090.1"> class and its iterators, we can write the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5091.1">// defining and initializing an array of integers
dummy_array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5092.1">int</span></span><span class="koboSpan" id="kobo.5093.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5094.1">3</span></span><span class="koboSpan" id="kobo.5095.1">&gt; a;
a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5096.1">0</span></span><span class="koboSpan" id="kobo.5097.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5098.1">10</span></span><span class="koboSpan" id="kobo.5099.1">;
a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5100.1">1</span></span><span class="koboSpan" id="kobo.5101.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5102.1">20</span></span><span class="koboSpan" id="kobo.5103.1">;
a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5104.1">2</span></span><span class="koboSpan" id="kobo.5105.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5106.1">30</span></span><span class="koboSpan" id="kobo.5107.1">;
// modifying the elements of the array
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5108.1">transform</span></span><span class="koboSpan" id="kobo.5109.1">(a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5110.1">begin</span></span><span class="koboSpan" id="kobo.5111.1">(), a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5112.1">end</span></span><span class="koboSpan" id="kobo.5113.1">(), a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5114.1">begin</span></span><span class="koboSpan" id="kobo.5115.1">(),
               [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5116.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5117.1">const</span></span><span class="koboSpan" id="kobo.5118.1"> e) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5119.1">return</span></span><span class="koboSpan" id="kobo.5120.1"> e * </span><span class="hljs-number"><span class="koboSpan" id="kobo.5121.1">2</span></span><span class="koboSpan" id="kobo.5122.1">; });
// iterating through and printing the values of the array
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5123.1">for</span></span><span class="koboSpan" id="kobo.5124.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5125.1">auto</span></span><span class="koboSpan" id="kobo.5126.1">&amp;&amp; e : a) std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5127.1">'\n'</span></span><span class="koboSpan" id="kobo.5128.1">;
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5129.1">20
40
60
</span></code></pre>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5130.1">auto</span></span><span class="koboSpan" id="kobo.5131.1"> lp = [](dummy_array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5132.1">int</span></span><span class="koboSpan" id="kobo.5133.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5134.1">3</span></span><span class="koboSpan" id="kobo.5135.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.5136.1">const</span></span><span class="koboSpan" id="kobo.5137.1"> &amp; ca)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5138.1">for</span></span><span class="koboSpan" id="kobo.5139.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5140.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5141.1">const</span></span><span class="koboSpan" id="kobo.5142.1"> &amp; e : ca)
    std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5143.1">'\n'</span></span><span class="koboSpan" id="kobo.5144.1">;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5145.1">lp</span></span><span class="koboSpan" id="kobo.5146.1">(a);
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5147.1">20
40
60
</span></code></pre>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5148.1">// defining and initializing an array of smart pointers
dummy_array&lt;std::unique_ptr&lt;Tag&gt;, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5149.1">3</span></span><span class="koboSpan" id="kobo.5150.1">&gt; ta;
ta[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5151.1">0</span></span><span class="koboSpan" id="kobo.5152.1">] = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5153.1">make_unique</span></span><span class="koboSpan" id="kobo.5154.1">&lt;Tag&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5155.1">1</span></span><span class="koboSpan" id="kobo.5156.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5157.1">"Tag 1"</span></span><span class="koboSpan" id="kobo.5158.1">);
ta[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5159.1">1</span></span><span class="koboSpan" id="kobo.5160.1">] = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5161.1">make_unique</span></span><span class="koboSpan" id="kobo.5162.1">&lt;Tag&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5163.1">2</span></span><span class="koboSpan" id="kobo.5164.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5165.1">"Tag 2"</span></span><span class="koboSpan" id="kobo.5166.1">);
ta[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5167.1">2</span></span><span class="koboSpan" id="kobo.5168.1">] = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5169.1">make_unique</span></span><span class="koboSpan" id="kobo.5170.1">&lt;Tag&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5171.1">3</span></span><span class="koboSpan" id="kobo.5172.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5173.1">"Tag 3"</span></span><span class="koboSpan" id="kobo.5174.1">);
// iterating through and printing the pointed values
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5175.1">for</span></span><span class="koboSpan" id="kobo.5176.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5177.1">auto</span></span><span class="koboSpan" id="kobo.5178.1"> it = ta.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5179.1">begin</span></span><span class="koboSpan" id="kobo.5180.1">(); it != ta.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5181.1">end</span></span><span class="koboSpan" id="kobo.5182.1">(); ++it)
  std::cout &lt;&lt; it-&gt;id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5183.1">" "</span></span><span class="koboSpan" id="kobo.5184.1"> &lt;&lt; it-&gt;name &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5185.1">'\n'</span></span><span class="koboSpan" id="kobo.5186.1">;
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5187.1">1 Tag 1
2 Tag 2
3 Tag 3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5188.1">For more</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.5189.1"> examples, check the source code that accompanies this book.</span></p>
<h2 class="heading-2" id="_idParaDest-313"><span class="koboSpan" id="kobo.5190.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5191.1">Apart from </span><code class="inlineCode"><span class="koboSpan" id="kobo.5192.1">begin()</span></code><span class="koboSpan" id="kobo.5193.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5194.1">end()</span></code><span class="koboSpan" id="kobo.5195.1">, a container may have additional methods such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5196.1">cbegin()</span></code><span class="koboSpan" id="kobo.5197.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5198.1">cend()</span></code><span class="koboSpan" id="kobo.5199.1"> (for constant iterators), </span><code class="inlineCode"><span class="koboSpan" id="kobo.5200.1">rbegin()</span></code><span class="koboSpan" id="kobo.5201.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5202.1">rend()</span></code><span class="koboSpan" id="kobo.5203.1"> (for mutable reverse iterators), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5204.1">crbegin()</span></code><span class="koboSpan" id="kobo.5205.1">/ </span><code class="inlineCode"><span class="koboSpan" id="kobo.5206.1">crend()</span></code><span class="koboSpan" id="kobo.5207.1"> (for constant reverse iterators). </span><span class="koboSpan" id="kobo.5207.2">Implementing this is left as an exercise for you.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5208.1">On the other hand, in modern C++, these functions that return the first and last iterators do not have to be member functions but can be provided as non-member functions. </span><span class="koboSpan" id="kobo.5208.2">In fact, this is the topic of the next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.5209.1">Container access with non-member functions</span></em><span class="koboSpan" id="kobo.5210.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-314"><span class="koboSpan" id="kobo.5211.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5212.1">Chapter 1</span></em><span class="koboSpan" id="kobo.5213.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5214.1">Enabling range-based for loops for custom types, </span></em><span class="koboSpan" id="kobo.5215.1">to learn to execute one or more statements for each element of a collection</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5216.1">Chapter 1</span></em><span class="koboSpan" id="kobo.5217.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5218.1">Creating type aliases and alias templates</span></em><span class="koboSpan" id="kobo.5219.1">, to learn about aliases for types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-315"><span class="koboSpan" id="kobo.5220.1">Container access with non-member functions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5221.1">Standard containers provide the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5222.1">begin()</span></code><span class="koboSpan" id="kobo.5223.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5224.1">end()</span></code><span class="koboSpan" id="kobo.5225.1"> member functions for retrieving iterators for</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.5226.1"> the first and one-past-last elements of the container. </span><span class="koboSpan" id="kobo.5226.2">There are actually four sets of these functions. </span><span class="koboSpan" id="kobo.5226.3">Apart from </span><code class="inlineCode"><span class="koboSpan" id="kobo.5227.1">begin()</span></code><span class="koboSpan" id="kobo.5228.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5229.1">end()</span></code><span class="koboSpan" id="kobo.5230.1">, containers provide </span><code class="inlineCode"><span class="koboSpan" id="kobo.5231.1">cbegin()</span></code><span class="koboSpan" id="kobo.5232.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5233.1">cend()</span></code><span class="koboSpan" id="kobo.5234.1"> to return constant iterators, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5235.1">rbegin()</span></code><span class="koboSpan" id="kobo.5236.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5237.1">rend()</span></code><span class="koboSpan" id="kobo.5238.1"> to return mutable reverse iterators, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5239.1">crbegin()</span></code><span class="koboSpan" id="kobo.5240.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5241.1">crend()</span></code><span class="koboSpan" id="kobo.5242.1"> to return constant reverse iterators. </span><span class="koboSpan" id="kobo.5242.2">In C++11/C++14, all these have non-member equivalents that work with standard containers, arrays, and any custom type that specializes them. </span><span class="koboSpan" id="kobo.5242.3">In C++17, even more non-member functions have been added: </span><code class="inlineCode"><span class="koboSpan" id="kobo.5243.1">std::data()</span></code><span class="koboSpan" id="kobo.5244.1">, which returns a pointer to the block of memory containing the elements of the container; </span><code class="inlineCode"><span class="koboSpan" id="kobo.5245.1">std::size()</span></code><span class="koboSpan" id="kobo.5246.1">, which returns the size of a container or array; and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5247.1">std::empty()</span></code><span class="koboSpan" id="kobo.5248.1">, which returns whether the given container is empty. </span><span class="koboSpan" id="kobo.5248.2">These non-member functions are intended for generic code but can be used anywhere in your code. </span><span class="koboSpan" id="kobo.5248.3">Moreover, in C++20, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5249.1">std::ssize()</span></code><span class="koboSpan" id="kobo.5250.1"> non-member function was introduced to return the size of a container or array as a signed integer.</span></p>
<h2 class="heading-2" id="_idParaDest-316"><span class="koboSpan" id="kobo.5251.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5252.1">In this</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.5253.1"> recipe, we will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5254.1">dummy_array</span></code><span class="koboSpan" id="kobo.5255.1"> class and its iterators that we implemented in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.5256.1">Writing your own random-access iterator</span></em><span class="koboSpan" id="kobo.5257.1">, as an example. </span><span class="koboSpan" id="kobo.5257.2">You should read that recipe before continuing </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.5258.1">with this one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5259.1">Non-member </span><code class="inlineCode"><span class="koboSpan" id="kobo.5260.1">begin()</span></code><span class="koboSpan" id="kobo.5261.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5262.1">end()</span></code><span class="koboSpan" id="kobo.5263.1"> functions and the other variants, as well as non-member </span><code class="inlineCode"><span class="koboSpan" id="kobo.5264.1">data()</span></code><span class="koboSpan" id="kobo.5265.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5266.1">size()</span></code><span class="koboSpan" id="kobo.5267.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5268.1">empty() </span></code><span class="koboSpan" id="kobo.5269.1">functions are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5270.1">std</span></code><span class="koboSpan" id="kobo.5271.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5272.1">&lt;iterator&gt;</span></code><span class="koboSpan" id="kobo.5273.1"> header, which is implicitly included with any of the following headers: </span><code class="inlineCode"><span class="koboSpan" id="kobo.5274.1">&lt;array&gt;</span></code><span class="koboSpan" id="kobo.5275.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5276.1">&lt;deque&gt;</span></code><span class="koboSpan" id="kobo.5277.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5278.1">&lt;forward_list&gt;</span></code><span class="koboSpan" id="kobo.5279.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5280.1">&lt;list&gt;</span></code><span class="koboSpan" id="kobo.5281.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5282.1">&lt;map&gt;</span></code><span class="koboSpan" id="kobo.5283.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5284.1">&lt;regex&gt;</span></code><span class="koboSpan" id="kobo.5285.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5286.1">&lt;set&gt;</span></code><span class="koboSpan" id="kobo.5287.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5288.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.5289.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5290.1">&lt;unordered_map&gt;</span></code><span class="koboSpan" id="kobo.5291.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5292.1">&lt;unordered_set&gt;</span></code><span class="koboSpan" id="kobo.5293.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5294.1">&lt;vector&gt;</span></code><span class="koboSpan" id="kobo.5295.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5296.1">In this recipe, we will refer to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5297.1">std::begin()</span></code><span class="koboSpan" id="kobo.5298.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5299.1">std::end()</span></code><span class="koboSpan" id="kobo.5300.1"> functions, but everything discussed also applies to the other functions: </span><code class="inlineCode"><span class="koboSpan" id="kobo.5301.1">std::cbegin()</span></code><span class="koboSpan" id="kobo.5302.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5303.1">std::cend()</span></code><span class="koboSpan" id="kobo.5304.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5305.1">std::rbegin()</span></code><span class="koboSpan" id="kobo.5306.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5307.1">std::rend()</span></code><span class="koboSpan" id="kobo.5308.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5309.1">std::crbegin()</span></code><span class="koboSpan" id="kobo.5310.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5311.1">std::crend()</span></code><span class="koboSpan" id="kobo.5312.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-317"><span class="koboSpan" id="kobo.5313.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5314.1">Use the non-member </span><code class="inlineCode"><span class="koboSpan" id="kobo.5315.1">std::begin()</span></code><span class="koboSpan" id="kobo.5316.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5317.1">std::end()</span></code><span class="koboSpan" id="kobo.5318.1"> function and the other variants, as well as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5319.1">std::data()</span></code><span class="koboSpan" id="kobo.5320.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5321.1">std::size()</span></code><span class="koboSpan" id="kobo.5322.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5323.1">std::empty()</span></code><span class="koboSpan" id="kobo.5324.1"> with:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5325.1">Standard containers:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5326.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5327.1">int</span></span><span class="koboSpan" id="kobo.5328.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.5329.1">1</span></span><span class="koboSpan" id="kobo.5330.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5331.1">2</span></span><span class="koboSpan" id="kobo.5332.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5333.1">3</span></span><span class="koboSpan" id="kobo.5334.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5335.1">4</span></span><span class="koboSpan" id="kobo.5336.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5337.1">5</span></span><span class="koboSpan" id="kobo.5338.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5339.1">auto</span></span><span class="koboSpan" id="kobo.5340.1"> sv1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5341.1">size</span></span><span class="koboSpan" id="kobo.5342.1">(v1);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5343.1">// sv1 = 5</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5344.1">auto</span></span><span class="koboSpan" id="kobo.5345.1"> ev1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5346.1">empty</span></span><span class="koboSpan" id="kobo.5347.1">(v1); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5348.1">// ev1 = false</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5349.1">auto</span></span><span class="koboSpan" id="kobo.5350.1"> dv1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5351.1">data</span></span><span class="koboSpan" id="kobo.5352.1">(v1);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5353.1">// dv1 = v1.data()</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5354.1">for</span></span><span class="koboSpan" id="kobo.5355.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5356.1">auto</span></span><span class="koboSpan" id="kobo.5357.1"> i = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5358.1">begin</span></span><span class="koboSpan" id="kobo.5359.1">(v1); i != std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5360.1">end</span></span><span class="koboSpan" id="kobo.5361.1">(v1); ++i)
  std::cout &lt;&lt; *i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5362.1">'\n'</span></span><span class="koboSpan" id="kobo.5363.1">;
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5364.1">int</span></span><span class="koboSpan" id="kobo.5365.1">&gt; v2;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5366.1">copy</span></span><span class="koboSpan" id="kobo.5367.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5368.1">cbegin</span></span><span class="koboSpan" id="kobo.5369.1">(v1), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5370.1">cend</span></span><span class="koboSpan" id="kobo.5371.1">(v1),
          std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5372.1">back_inserter</span></span><span class="koboSpan" id="kobo.5373.1">(v2));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5374.1">Arrays:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5375.1">int</span></span><span class="koboSpan" id="kobo.5376.1"> a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5377.1">5</span></span><span class="koboSpan" id="kobo.5378.1">] = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.5379.1">1</span></span><span class="koboSpan" id="kobo.5380.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5381.1">2</span></span><span class="koboSpan" id="kobo.5382.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5383.1">3</span></span><span class="koboSpan" id="kobo.5384.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5385.1">4</span></span><span class="koboSpan" id="kobo.5386.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5387.1">5</span></span><span class="koboSpan" id="kobo.5388.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5389.1">auto</span></span><span class="koboSpan" id="kobo.5390.1"> pos = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5391.1">find_if</span></span><span class="koboSpan" id="kobo.5392.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5393.1">crbegin</span></span><span class="koboSpan" id="kobo.5394.1">(a), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5395.1">crend</span></span><span class="koboSpan" id="kobo.5396.1">(a),
                        [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5397.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5398.1">const</span></span><span class="koboSpan" id="kobo.5399.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5400.1">return</span></span><span class="koboSpan" id="kobo.5401.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.5402.1">2</span></span><span class="koboSpan" id="kobo.5403.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5404.1">0</span></span><span class="koboSpan" id="kobo.5405.1">; });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5406.1">auto</span></span><span class="koboSpan" id="kobo.5407.1"> sa = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5408.1">size</span></span><span class="koboSpan" id="kobo.5409.1">(a);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5410.1">// sa = 5</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5411.1">auto</span></span><span class="koboSpan" id="kobo.5412.1"> ea = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5413.1">empty</span></span><span class="koboSpan" id="kobo.5414.1">(a); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5415.1">// ea = false</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5416.1">auto</span></span><span class="koboSpan" id="kobo.5417.1"> da = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5418.1">data</span></span><span class="koboSpan" id="kobo.5419.1">(a);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5420.1">// da = a</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5421.1">Custom</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.5422.1"> types that provide </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.5423.1">the corresponding member functions; that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5424.1">begin()</span></code><span class="koboSpan" id="kobo.5425.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5426.1">end()</span></code><span class="koboSpan" id="kobo.5427.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5428.1">data()</span></code><span class="koboSpan" id="kobo.5429.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5430.1">empty()</span></code><span class="koboSpan" id="kobo.5431.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5432.1">size()</span></code><span class="koboSpan" id="kobo.5433.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5434.1">dummy_array&lt;std::string, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5435.1">5</span></span><span class="koboSpan" id="kobo.5436.1">&gt; sa;
dummy_array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5437.1">int</span></span><span class="koboSpan" id="kobo.5438.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5439.1">5</span></span><span class="koboSpan" id="kobo.5440.1">&gt; sb;
sa[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5441.1">0</span></span><span class="koboSpan" id="kobo.5442.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.5443.1">"1"</span></span><span class="koboSpan" id="kobo.5444.1">s;
sa[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5445.1">1</span></span><span class="koboSpan" id="kobo.5446.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.5447.1">"2"</span></span><span class="koboSpan" id="kobo.5448.1">s;
sa[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5449.1">2</span></span><span class="koboSpan" id="kobo.5450.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.5451.1">"3"</span></span><span class="koboSpan" id="kobo.5452.1">s;
sa[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5453.1">3</span></span><span class="koboSpan" id="kobo.5454.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.5455.1">"4"</span></span><span class="koboSpan" id="kobo.5456.1">s;
sa[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5457.1">4</span></span><span class="koboSpan" id="kobo.5458.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.5459.1">"5"</span></span><span class="koboSpan" id="kobo.5460.1">s;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5461.1">transform</span></span><span class="koboSpan" id="kobo.5462.1">(
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5463.1">begin</span></span><span class="koboSpan" id="kobo.5464.1">(sa), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5465.1">end</span></span><span class="koboSpan" id="kobo.5466.1">(sa),
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5467.1">begin</span></span><span class="koboSpan" id="kobo.5468.1">(sb),
  [](std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.5469.1">const</span></span><span class="koboSpan" id="kobo.5470.1"> &amp; s) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5471.1">return</span></span><span class="koboSpan" id="kobo.5472.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5473.1">stoi</span></span><span class="koboSpan" id="kobo.5474.1">(s); });
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.5475.1">// sb = [1, 2, 3, 4, 5]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5476.1">auto</span></span><span class="koboSpan" id="kobo.5477.1"> sa_size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5478.1">size</span></span><span class="koboSpan" id="kobo.5479.1">(sa); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5480.1">// sa_size = 5</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5481.1">Generic code where the type of the container is not known:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5482.1">template</span></span><span class="koboSpan" id="kobo.5483.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5484.1">typename</span></span><span class="koboSpan" id="kobo.5485.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5486.1">typename</span></span><span class="koboSpan" id="kobo.5487.1"> C&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5488.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5489.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5490.1">(F&amp;&amp; f, C </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5491.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5492.1"> &amp; c)</span></span><span class="koboSpan" id="kobo.5493.1">
{
  std::for_each(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5494.1">begin</span></span><span class="koboSpan" id="kobo.5495.1">(c), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5496.1">end</span></span><span class="koboSpan" id="kobo.5497.1">(c),
                std::forward&lt;F&gt;(f));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5498.1">auto</span></span><span class="koboSpan" id="kobo.5499.1"> l = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5500.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5501.1">const</span></span><span class="koboSpan" id="kobo.5502.1"> e) {std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5503.1">'\n'</span></span><span class="koboSpan" id="kobo.5504.1">; };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5505.1">process</span></span><span class="koboSpan" id="kobo.5506.1">(l, v1); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5507.1">// std::vector&lt;int&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.5508.1">process</span></span><span class="koboSpan" id="kobo.5509.1">(l, a);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5510.1">// int[5]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.5511.1">process</span></span><span class="koboSpan" id="kobo.5512.1">(l, sa); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5513.1">// dummy_array&lt;std::string, 5&gt;</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-318"><span class="koboSpan" id="kobo.5514.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5515.1">These</span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.5516.1"> non-member functions were introduced </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.5517.1">in different versions of the standard, but all of them were modified in C++17 to return </span><code class="inlineCode"><span class="koboSpan" id="kobo.5518.1">constexpr auto</span></code><span class="koboSpan" id="kobo.5519.1">:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5520.1">std::begin()</span></code><span class="koboSpan" id="kobo.5521.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5522.1">std::end()</span></code><span class="koboSpan" id="kobo.5523.1"> in C++11</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5524.1">std::cbegin()</span></code><span class="koboSpan" id="kobo.5525.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5526.1">std::cend()</span></code><span class="koboSpan" id="kobo.5527.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5528.1">std::rbegin()</span></code><span class="koboSpan" id="kobo.5529.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5530.1">std::rend()</span></code><span class="koboSpan" id="kobo.5531.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5532.1">std::crbegin()</span></code><span class="koboSpan" id="kobo.5533.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5534.1">std::crend()</span></code><span class="koboSpan" id="kobo.5535.1"> in C++14</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5536.1">std::data()</span></code><span class="koboSpan" id="kobo.5537.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5538.1">std::size()</span></code><span class="koboSpan" id="kobo.5539.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5540.1">std::empty()</span></code><span class="koboSpan" id="kobo.5541.1"> in C++17</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5542.1">std::ssize()</span></code><span class="koboSpan" id="kobo.5543.1"> in C++20</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5544.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5545.1">begin()</span></code><span class="koboSpan" id="kobo.5546.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5547.1">end()</span></code><span class="koboSpan" id="kobo.5548.1"> family of functions have overloads for container classes and arrays, and all they do is the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5549.1">Return the results of calling the container-corresponding member function for containers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5550.1">Return a pointer to the first or one-past-last element of the array for arrays</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5551.1">The actual typical implementation for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5552.1">std::begin()</span></code><span class="koboSpan" id="kobo.5553.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5554.1">std::end()</span></code><span class="koboSpan" id="kobo.5555.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5556.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5557.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5558.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5559.1"> C&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5560.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5561.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5562.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5563.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5564.1">(C&amp; c)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5565.1"> -&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5566.1">decltype</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5567.1">(c.begin())</span></span><span class="koboSpan" id="kobo.5568.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5569.1">return</span></span><span class="koboSpan" id="kobo.5570.1"> c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5571.1">begin</span></span><span class="koboSpan" id="kobo.5572.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5573.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5574.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5575.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5576.1"> C&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5577.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5578.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5579.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5580.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5581.1">(C&amp; c)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5582.1"> -&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5583.1">decltype</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5584.1">(c.end())</span></span><span class="koboSpan" id="kobo.5585.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5586.1">return</span></span><span class="koboSpan" id="kobo.5587.1"> c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5588.1">end</span></span><span class="koboSpan" id="kobo.5589.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5590.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5591.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5592.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5593.1"> T, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5594.1">size_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5595.1"> N&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5596.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5597.1"> T* </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5598.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5599.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5600.1">(T (&amp;array)[N])</span></span><span class="koboSpan" id="kobo.5601.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5602.1">return</span></span><span class="koboSpan" id="kobo.5603.1"> array;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5604.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5605.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5606.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5607.1"> T, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5608.1">size_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5609.1"> N&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5610.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5611.1"> T* </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5612.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5613.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5614.1">(T (&amp;array)[N])</span></span><span class="koboSpan" id="kobo.5615.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5616.1">return</span></span><span class="koboSpan" id="kobo.5617.1"> array+N;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5618.1">Custom specialization</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.5619.1"> can be provided for</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.5620.1"> containers that do not have corresponding </span><code class="inlineCode"><span class="koboSpan" id="kobo.5621.1">begin()</span></code><span class="koboSpan" id="kobo.5622.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5623.1">end()</span></code><span class="koboSpan" id="kobo.5624.1"> members but can still be iterated. </span><span class="koboSpan" id="kobo.5624.2">The standard library actually provides such specializations for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5625.1">std::initializer_list</span></code><span class="koboSpan" id="kobo.5626.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5627.1">std::valarray</span></code><span class="koboSpan" id="kobo.5628.1">.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.5629.1">Specializations must be defined in the same namespace where the original class or function template has been defined. </span><span class="koboSpan" id="kobo.5629.2">Therefore, if you want to specialize any of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5630.1">std::begin()</span></code><span class="koboSpan" id="kobo.5631.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5632.1">std::end()</span></code><span class="koboSpan" id="kobo.5633.1"> pairs, you must do so in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5634.1">std</span></code><span class="koboSpan" id="kobo.5635.1"> namespace.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.5636.1">The other non-member functions for container access that were introduced in C++17 also have several overloads:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5637.1">std::data()</span></code><span class="koboSpan" id="kobo.5638.1"> has several overloads; for a class </span><code class="inlineCode"><span class="koboSpan" id="kobo.5639.1">C</span></code><span class="koboSpan" id="kobo.5640.1"> it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5641.1">c.data()</span></code><span class="koboSpan" id="kobo.5642.1">, for arrays it returns the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5643.1">array</span></code><span class="koboSpan" id="kobo.5644.1">, and for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5645.1">std::initializer_list&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5646.1"> it returns the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5647.1">il.begin()</span></code><span class="koboSpan" id="kobo.5648.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5649.1">template</span></span><span class="koboSpan" id="kobo.5650.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5651.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5652.1">C</span></span><span class="koboSpan" id="kobo.5653.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5654.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5655.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5656.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5657.1">(C&amp; c)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5658.1"> -&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5659.1">decltype</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5660.1">(c.data())</span></span><span class="koboSpan" id="kobo.5661.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5662.1">return</span></span><span class="koboSpan" id="kobo.5663.1"> c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5664.1">data</span></span><span class="koboSpan" id="kobo.5665.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5666.1">template</span></span><span class="koboSpan" id="kobo.5667.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5668.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5669.1">C</span></span><span class="koboSpan" id="kobo.5670.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5671.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5672.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5673.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5674.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5675.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5676.1"> C&amp; c)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5677.1"> -&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5678.1">decltype</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5679.1">(c.data())</span></span><span class="koboSpan" id="kobo.5680.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5681.1">return</span></span><span class="koboSpan" id="kobo.5682.1"> c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5683.1">data</span></span><span class="koboSpan" id="kobo.5684.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5685.1">template</span></span><span class="koboSpan" id="kobo.5686.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5687.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5688.1">T</span></span><span class="koboSpan" id="kobo.5689.1">, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5690.1">size_t</span></span><span class="koboSpan" id="kobo.5691.1"> N&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5692.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5693.1"> T* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5694.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5695.1">(T (&amp;array)[N])</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5696.1">noexcept</span></span><span class="koboSpan" id="kobo.5697.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5698.1">return</span></span><span class="koboSpan" id="kobo.5699.1"> array;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5700.1">template</span></span><span class="koboSpan" id="kobo.5701.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5702.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5703.1">E</span></span><span class="koboSpan" id="kobo.5704.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5705.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5706.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5707.1"> E* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5708.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5709.1">(std::initializer_list&lt;E&gt; il)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5710.1">noexcept</span></span><span class="koboSpan" id="kobo.5711.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5712.1">return</span></span><span class="koboSpan" id="kobo.5713.1"> il.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5714.1">begin</span></span><span class="koboSpan" id="kobo.5715.1">();
}
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5716.1">std::size()</span></code><span class="koboSpan" id="kobo.5717.1"> has two overloads; for a class </span><code class="inlineCode"><span class="koboSpan" id="kobo.5718.1">C</span></code><span class="koboSpan" id="kobo.5719.1"> it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5720.1">c.size()</span></code><span class="koboSpan" id="kobo.5721.1">, and for arrays it returns</span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.5722.1"> the size </span><code class="inlineCode"><span class="koboSpan" id="kobo.5723.1">N</span></code><span class="koboSpan" id="kobo.5724.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5725.1">template</span></span><span class="koboSpan" id="kobo.5726.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5727.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5728.1">C</span></span><span class="koboSpan" id="kobo.5729.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5730.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5731.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5732.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5733.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5734.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5735.1"> C&amp; c)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5736.1"> -&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5737.1">decltype</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5738.1">(c.size())</span></span><span class="koboSpan" id="kobo.5739.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5740.1">return</span></span><span class="koboSpan" id="kobo.5741.1"> c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5742.1">size</span></span><span class="koboSpan" id="kobo.5743.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5744.1">template</span></span><span class="koboSpan" id="kobo.5745.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5746.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5747.1">T</span></span><span class="koboSpan" id="kobo.5748.1">, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5749.1">size_t</span></span><span class="koboSpan" id="kobo.5750.1"> N&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5751.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5752.1"> std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5753.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5754.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5755.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5756.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5757.1"> T (&amp;array)[N])</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5758.1">noexcept</span></span><span class="koboSpan" id="kobo.5759.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5760.1">return</span></span><span class="koboSpan" id="kobo.5761.1"> N;
}
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5762.1">std::empty()</span></code><span class="koboSpan" id="kobo.5763.1"> has </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.5764.1">several overloads; for a class </span><code class="inlineCode"><span class="koboSpan" id="kobo.5765.1">C</span></code><span class="koboSpan" id="kobo.5766.1"> it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5767.1">c.empty()</span></code><span class="koboSpan" id="kobo.5768.1">, for arrays it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5769.1">false</span></code><span class="koboSpan" id="kobo.5770.1">, and for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5771.1">std::initializer_list&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5772.1"> it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5773.1">il.size() == 0</span></code><span class="koboSpan" id="kobo.5774.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5775.1">template</span></span><span class="koboSpan" id="kobo.5776.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5777.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5778.1">C</span></span><span class="koboSpan" id="kobo.5779.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5780.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5781.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5782.1">empty</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5783.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5784.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5785.1"> C&amp; c)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5786.1"> -&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5787.1">decltype</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5788.1">(c.empty())</span></span><span class="koboSpan" id="kobo.5789.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5790.1">return</span></span><span class="koboSpan" id="kobo.5791.1"> c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5792.1">empty</span></span><span class="koboSpan" id="kobo.5793.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5794.1">template</span></span><span class="koboSpan" id="kobo.5795.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5796.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5797.1">T</span></span><span class="koboSpan" id="kobo.5798.1">, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5799.1">size_t</span></span><span class="koboSpan" id="kobo.5800.1"> N&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5801.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5802.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5803.1">empty</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5804.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5805.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5806.1"> T (&amp;array)[N])</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5807.1">noexcept</span></span><span class="koboSpan" id="kobo.5808.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5809.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.5810.1">false</span></span><span class="koboSpan" id="kobo.5811.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5812.1">template</span></span><span class="koboSpan" id="kobo.5813.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5814.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5815.1">E</span></span><span class="koboSpan" id="kobo.5816.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5817.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5818.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5819.1">empty</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5820.1">(std::initializer_list&lt;E&gt; il)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5821.1">noexcept</span></span><span class="koboSpan" id="kobo.5822.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5823.1">return</span></span><span class="koboSpan" id="kobo.5824.1"> il.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5825.1">size</span></span><span class="koboSpan" id="kobo.5826.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5827.1">0</span></span><span class="koboSpan" id="kobo.5828.1">;
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5829.1">In C++20, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5830.1">std::ssize()</span></code><span class="koboSpan" id="kobo.5831.1"> non-member function was added as a companion to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5832.1">std::size()</span></code><span class="koboSpan" id="kobo.5833.1"> to return the number of elements in a given container or an array as a signed integer. </span><code class="inlineCode"><span class="koboSpan" id="kobo.5834.1">std::size()</span></code><span class="koboSpan" id="kobo.5835.1"> returns an unsigned integer, but there are scenarios where a signed value is desired. </span><span class="koboSpan" id="kobo.5835.2">For instance, the C++20 class </span><code class="inlineCode"><span class="koboSpan" id="kobo.5836.1">std::span</span></code><span class="koboSpan" id="kobo.5837.1">, which represents a view to a contiguous sequence of objects, has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5838.1">size()</span></code><span class="koboSpan" id="kobo.5839.1"> member function that returns a signed integer, unlike</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.5840.1"> standard library containers where the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5841.1">size()</span></code><span class="koboSpan" id="kobo.5842.1"> member function returns an unsigned integer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5843.1">The </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.5844.1">reason the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.5845.1">size()</span></code><span class="koboSpan" id="kobo.5846.1"> of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5847.1">std::span</span></code><span class="koboSpan" id="kobo.5848.1"> returns a signed integer is that the value -1 is supposed to represent a sentinel for types whose size was not known at compile time. </span><span class="koboSpan" id="kobo.5848.2">Performing mixed signed and unsigned arithmetic can lead to errors in code that are hard to find. </span><code class="inlineCode"><span class="koboSpan" id="kobo.5849.1">std::ssize()</span></code><span class="koboSpan" id="kobo.5850.1"> has two overloads: for a class </span><code class="inlineCode"><span class="koboSpan" id="kobo.5851.1">C</span></code><span class="koboSpan" id="kobo.5852.1"> it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5853.1">c.size()</span></code><span class="koboSpan" id="kobo.5854.1"> statically cast to a signed integer (typically </span><code class="inlineCode"><span class="koboSpan" id="kobo.5855.1">std::ptrdiff_t</span></code><span class="koboSpan" id="kobo.5856.1">) and for arrays it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5857.1">N</span></code><span class="koboSpan" id="kobo.5858.1">, the number of elements. </span><span class="koboSpan" id="kobo.5858.2">Take a look at the following code snippets:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5859.1">template</span></span><span class="koboSpan" id="kobo.5860.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5861.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5862.1">C</span></span><span class="koboSpan" id="kobo.5863.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5864.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5865.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5866.1">ssize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5867.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5868.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5869.1"> C&amp; c)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.5870.1">    -&gt; std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5871.1">common_type_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5872.1">&lt;std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5873.1">ptrdiff_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5874.1">,</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.5875.1">                          std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5876.1">make_signed_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5877.1">&lt;</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5878.1">decltype</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5879.1">(c.size())</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5880.1">&gt;&gt;</span></span><span class="koboSpan" id="kobo.5881.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5882.1">using</span></span><span class="koboSpan" id="kobo.5883.1"> R = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5884.1">common_type_t</span></span><span class="koboSpan" id="kobo.5885.1">&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5886.1">ptrdiff_t</span></span><span class="koboSpan" id="kobo.5887.1">,
                      std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5888.1">make_signed_t</span></span><span class="koboSpan" id="kobo.5889.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5890.1">decltype</span></span><span class="koboSpan" id="kobo.5891.1">(c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5892.1">size</span></span><span class="koboSpan" id="kobo.5893.1">())&gt;&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5894.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5895.1">static_cast</span></span><span class="koboSpan" id="kobo.5896.1">&lt;R&gt;(c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5897.1">size</span></span><span class="koboSpan" id="kobo.5898.1">());
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5899.1">template</span></span><span class="koboSpan" id="kobo.5900.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5901.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5902.1">T</span></span><span class="koboSpan" id="kobo.5903.1">, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5904.1">ptrdiff_t</span></span><span class="koboSpan" id="kobo.5905.1"> N&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5906.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5907.1"> std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5908.1">ptrdiff_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5909.1">ssize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5910.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5911.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5912.1"> T (&amp;array)[N])</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5913.1">noexcept</span></span><span class="koboSpan" id="kobo.5914.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5915.1">return</span></span><span class="koboSpan" id="kobo.5916.1"> N;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5917.1">The preceding snippets show possible implementations for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5918.1">std::ssize()</span></code><span class="koboSpan" id="kobo.5919.1"> function for containers and arrays.</span></p>
<h2 class="heading-2" id="_idParaDest-319"><span class="koboSpan" id="kobo.5920.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5921.1">These non-member functions are mainly intended for template code where the container is not known and can be a standard container, an array, or a custom type. </span><span class="koboSpan" id="kobo.5921.2">Using the non-member version of these functions enables us to write simpler and less code that works with all these types of containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5922.1">However, the </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.5923.1">use of these functions is not and should </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.5924.1">not be limited to generic code. </span><span class="koboSpan" id="kobo.5924.2">Though it is rather a matter of personal preference, it can be a good habit to be consistent and use them everywhere in your code. </span><span class="koboSpan" id="kobo.5924.3">All these methods have lightweight implementations that will most likely be inlined by the compiler, which means that there will be no overhead at all for using the corresponding member functions.</span></p>
<h2 class="heading-2" id="_idParaDest-320"><span class="koboSpan" id="kobo.5925.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5926.1">Writing your own random-access iterator</span></em><span class="koboSpan" id="kobo.5927.1">, to understand what you need to do to write a custom, random-access iterator</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-321"><span class="koboSpan" id="kobo.5928.1">Selecting the right standard containers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5929.1">The</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.5930.1"> standard library contains a variety of containers for meeting multiple and various needs. </span><span class="koboSpan" id="kobo.5930.2">There are sequence containers (in which elements are arranged in a certain position), container adapters (that provide a different interface for sequential containers), associative containers (in which the order is given by a key associated with an element), unordered associative containers (in which the elements do not follow a certain order). </span><span class="koboSpan" id="kobo.5930.3">Selecting the right container for a given task is not always straight forward. </span><span class="koboSpan" id="kobo.5930.4">This recipe will provide guidelines to help you decide which one to use for what purpose.</span></p>
<h2 class="heading-2" id="_idParaDest-322"><span class="koboSpan" id="kobo.5931.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5932.1">To decide which standard container you should use, consider the following guidelines:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5933.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5934.1">std::vector</span></code><span class="koboSpan" id="kobo.5935.1"> as the default container, when no other specific requirements exist.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5936.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5937.1">std::array</span></code><span class="koboSpan" id="kobo.5938.1"> when the length of a sequence is fixed and known at compile time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5939.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5940.1">std::deque</span></code><span class="koboSpan" id="kobo.5941.1"> if you frequently need to add or remove elements at the beginning and the end of a sequence.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5942.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5943.1">std::list</span></code><span class="koboSpan" id="kobo.5944.1"> if you frequently need to add or remove elements in the middle of the sequence (that’s anywhere else other than the beginning and end) and bidirectional traversing of the sequence is required.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5945.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5946.1">std::forward_list</span></code><span class="koboSpan" id="kobo.5947.1"> if you frequently need to add or remove elements anywhere in the sequence but you only need to traverse the sequence in one direction.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5948.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5949.1">std::stack</span></code><span class="koboSpan" id="kobo.5950.1"> if you need a sequence with </span><strong class="keyWord"><span class="koboSpan" id="kobo.5951.1">last-in, first-out</span></strong><span class="koboSpan" id="kobo.5952.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.5953.1">LIFO</span></strong><span class="koboSpan" id="kobo.5954.1">) semantics.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5955.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5956.1">std::queue</span></code><span class="koboSpan" id="kobo.5957.1"> if you need a sequence with </span><strong class="keyWord"><span class="koboSpan" id="kobo.5958.1">first-in, first-out </span></strong><span class="koboSpan" id="kobo.5959.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.5960.1">FIFO</span></strong><span class="koboSpan" id="kobo.5961.1">) semantics.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5962.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5963.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.5964.1"> if you need a sequence with FIFO semantics, but in which elements are arranged in a strict weak ordering (the largest – highest priority element comes first).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5965.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5966.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.5967.1"> if you need to store key-value pairs and the order of the elements is not important but keys must be unique.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5968.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5969.1">std::map</span></code><span class="koboSpan" id="kobo.5970.1"> if you need to store key-value pairs with unique keys but the order of the elements is given by their keys.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5971.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5972.1">std::unordered_multimap</span></code><span class="koboSpan" id="kobo.5973.1"> if you need to store key-value pairs, the keys can be duplicated, and the order of the elements is not important.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5974.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5975.1">std::multimap</span></code><span class="koboSpan" id="kobo.5976.1"> if you need to store key-value pairs, the keys can be duplicated, and the elements are stored in an order given by their keys.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5977.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5978.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.5979.1"> if you need to store unique values but their order is not important.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5980.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5981.1">std::set</span></code><span class="koboSpan" id="kobo.5982.1"> if you need to store unique values but the order of the elements is important (the lowest elements are stored first).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5983.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5984.1">std::unordered_multiset</span></code><span class="koboSpan" id="kobo.5985.1"> if you want to store non-unique values, although their order does not matter, and you want the search capabilities of a set.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5986.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5987.1">std::multiset</span></code><span class="koboSpan" id="kobo.5988.1"> if you want to store non-unique value, but the order of the elements matter, with those having a lowest key coming first, and you want the search capabilities of a set.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-323"><span class="koboSpan" id="kobo.5989.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5990.1">Containers </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.5991.1">are objects that store other objects, internally managing the memory used by the stored objects. </span><span class="koboSpan" id="kobo.5991.2">They provide access to elements and other functionality defined by standardized interfaces. </span><span class="koboSpan" id="kobo.5991.3">There are four categories of containers in the standard library:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.5992.1">Sequence containers</span></strong><span class="koboSpan" id="kobo.5993.1"> store</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.5994.1"> elements in a certain order but this order does not depend on the value of the element. </span><span class="koboSpan" id="kobo.5994.2">Sequence containers are typically implemented either as arrays (elements are stored contiguous in memory) or linked lists (elements are stored in nodes that point to others). </span><span class="koboSpan" id="kobo.5994.3">The standard sequence containers are </span><code class="inlineCode"><span class="koboSpan" id="kobo.5995.1">std::array</span></code><span class="koboSpan" id="kobo.5996.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5997.1">std::vector</span></code><span class="koboSpan" id="kobo.5998.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5999.1">std::list</span></code><span class="koboSpan" id="kobo.6000.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6001.1">std::forward_list</span></code><span class="koboSpan" id="kobo.6002.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6003.1">std::deque</span></code><span class="koboSpan" id="kobo.6004.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.6005.1">Container adaptors</span></strong><span class="koboSpan" id="kobo.6006.1"> define</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.6007.1"> an adapted interface towards a sequence container. </span><span class="koboSpan" id="kobo.6007.2">These are </span><code class="inlineCode"><span class="koboSpan" id="kobo.6008.1">std::stack</span></code><span class="koboSpan" id="kobo.6009.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6010.1">std::queue</span></code><span class="koboSpan" id="kobo.6011.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6012.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.6013.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.6014.1">Associative containers</span></strong><span class="koboSpan" id="kobo.6015.1"> store elements in a certain order given by keys associated with</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.6016.1"> each element. </span><span class="koboSpan" id="kobo.6016.2">Although they support insertion and deletion, this cannot happen at a specific position but depends on the key. </span><span class="koboSpan" id="kobo.6016.3">They provide good performance for searching elements, a binary search that has logarithmic complexity being possible for all containers. </span><span class="koboSpan" id="kobo.6016.4">The standard associative containers are </span><code class="inlineCode"><span class="koboSpan" id="kobo.6017.1">std::map</span></code><span class="koboSpan" id="kobo.6018.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6019.1">std::set</span></code><span class="koboSpan" id="kobo.6020.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6021.1">std::multimap</span></code><span class="koboSpan" id="kobo.6022.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6023.1">std::multiset</span></code><span class="koboSpan" id="kobo.6024.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.6025.1">Unordered associative containers</span></strong><span class="koboSpan" id="kobo.6026.1"> store elements that are not ordered. </span><span class="koboSpan" id="kobo.6026.2">These</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.6027.1"> containers are implemented using hash tables, which makes searching elements a constant-time operation. </span><span class="koboSpan" id="kobo.6027.2">Unlike associated containers, the unordered ones do not support binary search. </span><span class="koboSpan" id="kobo.6027.3">Hash functions must be implemented for the types of the elements stored in an unordered associative container. </span><span class="koboSpan" id="kobo.6027.4">The standard containers are </span><code class="inlineCode"><span class="koboSpan" id="kobo.6028.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6029.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6030.1">std::unordered_multimap</span></code><span class="koboSpan" id="kobo.6031.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6032.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6033.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6034.1">std::unordered_multiset</span></code><span class="koboSpan" id="kobo.6035.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6036.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6037.1">std::vector</span></code><span class="koboSpan" id="kobo.6038.1"> container </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.6039.1">is perhaps the most used one, as the code snippets in this book also show. </span><span class="koboSpan" id="kobo.6039.2">A vector stores its elements sequentially in a contiguous memory. </span><span class="koboSpan" id="kobo.6039.3">A vector can grow and shrink. </span><span class="koboSpan" id="kobo.6039.4">Although elements can be inserted anywhere in the sequence, the most efficient operations are insertions and removals at the end of the sequence (with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6040.1">push_back()</span></code><span class="koboSpan" id="kobo.6041.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6042.1">pop_back()</span></code><span class="koboSpan" id="kobo.6043.1">):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6044.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6045.1">int</span></span><span class="koboSpan" id="kobo.6046.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.6047.1">1</span></span><span class="koboSpan" id="kobo.6048.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6049.1">1</span></span><span class="koboSpan" id="kobo.6050.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6051.1">2</span></span><span class="koboSpan" id="kobo.6052.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6053.1">3</span></span><span class="koboSpan" id="kobo.6054.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6055.1">5</span></span><span class="koboSpan" id="kobo.6056.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6057.1">8</span></span><span class="koboSpan" id="kobo.6058.1"> };
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6059.1">push_back</span></span><span class="koboSpan" id="kobo.6060.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.6061.1">13</span></span><span class="koboSpan" id="kobo.6062.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6063.1">// insert at the end</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6064.1">Here is a conceptual representation of a vector before and after inserting an element at its end:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.6065.1"><img alt="" src="../Images/B21549_05_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.6066.1">Figure 5.1: Inserting an element at the end of a vector</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6067.1">Inserting</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.6068.1"> or removing elements anywhere other than the end of the sequence (with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6069.1">insert()</span></code><span class="koboSpan" id="kobo.6070.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6071.1">erase()</span></code><span class="koboSpan" id="kobo.6072.1">) is less performant because all of the elements after the insertion/removal position must be moved in memory. </span><span class="koboSpan" id="kobo.6072.2">If an insert operation would determine capacity of the vector (the number of elements that can be stored in the allocated memory) to be exceeded, a reallocation must occur. </span><span class="koboSpan" id="kobo.6072.3">In this case, a new, larger contiguous sequence of memory is allocated, and all the stored elements are copied to this new buffer, along with the newly added ones, and the old memory chunk is deleted:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6073.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6074.1">int</span></span><span class="koboSpan" id="kobo.6075.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.6076.1">1</span></span><span class="koboSpan" id="kobo.6077.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6078.1">1</span></span><span class="koboSpan" id="kobo.6079.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6080.1">2</span></span><span class="koboSpan" id="kobo.6081.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6082.1">3</span></span><span class="koboSpan" id="kobo.6083.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6084.1">5</span></span><span class="koboSpan" id="kobo.6085.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6086.1">8</span></span><span class="koboSpan" id="kobo.6087.1"> };
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6088.1">insert</span></span><span class="koboSpan" id="kobo.6089.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6090.1">begin</span></span><span class="koboSpan" id="kobo.6091.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.6092.1">3</span></span><span class="koboSpan" id="kobo.6093.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6094.1">13</span></span><span class="koboSpan" id="kobo.6095.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6096.1">// insert in the middle</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6097.1">The next diagram shows a conceptual representation of a vector before and after inserting a new element in the middle:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.6098.1"><img alt="" src="../Images/B21549_05_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.6099.1">Figure 5.2: Inserting an element in the middle of a vector</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6100.1">If </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.6101.1">frequent insertions or deletion also occur at the beginning of the sequence, a better alternative is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6102.1">std::deque</span></code><span class="koboSpan" id="kobo.6103.1"> container. </span><span class="koboSpan" id="kobo.6103.2">This allows fast inserts and removals at both ends (with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6104.1">push_front()</span></code><span class="koboSpan" id="kobo.6105.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.6106.1">pop_front()</span></code><span class="koboSpan" id="kobo.6107.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6108.1">push_back()</span></code><span class="koboSpan" id="kobo.6109.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.6110.1">pop_back()</span></code><span class="koboSpan" id="kobo.6111.1">). </span><span class="koboSpan" id="kobo.6111.2">Removals at the two ends do not invalidate pointers or references to the rest of the elements. </span><span class="koboSpan" id="kobo.6111.3">However, unlike </span><code class="inlineCode"><span class="koboSpan" id="kobo.6112.1">std::vector</span></code><span class="koboSpan" id="kobo.6113.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6114.1">std::deque</span></code><span class="koboSpan" id="kobo.6115.1"> does not store its elements contiguously in memory, but in a sequence of fixed-length arrays that require extra management. </span><span class="koboSpan" id="kobo.6115.2">Although indexing elements involve two levels of pointer dereferencing, compared to just one for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6116.1">std::vector</span></code><span class="koboSpan" id="kobo.6117.1">, expanding a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6118.1">deque</span></code><span class="koboSpan" id="kobo.6119.1"> is faster than for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6120.1">vector</span></code><span class="koboSpan" id="kobo.6121.1">, because it does not require reallocating all the memory and copying the existing elements:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6122.1">std::deque&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6123.1">int</span></span><span class="koboSpan" id="kobo.6124.1">&gt; d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.6125.1">1</span></span><span class="koboSpan" id="kobo.6126.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.6127.1">2</span></span><span class="koboSpan" id="kobo.6128.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.6129.1">3</span></span><span class="koboSpan" id="kobo.6130.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.6131.1">5</span></span><span class="koboSpan" id="kobo.6132.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.6133.1">8</span></span><span class="koboSpan" id="kobo.6134.1"> };
d.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6135.1">push_front</span></span><span class="koboSpan" id="kobo.6136.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.6137.1">1</span></span><span class="koboSpan" id="kobo.6138.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6139.1">// insert at the beginning</span></span><span class="koboSpan" id="kobo.6140.1">
d.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6141.1">push_back</span></span><span class="koboSpan" id="kobo.6142.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.6143.1">13</span></span><span class="koboSpan" id="kobo.6144.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6145.1">// insert at the end</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6146.1">Neither </span><code class="inlineCode"><span class="koboSpan" id="kobo.6147.1">std::vector</span></code><span class="koboSpan" id="kobo.6148.1"> nor </span><code class="inlineCode"><span class="koboSpan" id="kobo.6149.1">std::deque</span></code><span class="koboSpan" id="kobo.6150.1"> have a good performance for insertions in the middle of the sequence (middle meaning anywhere other than the ends). </span><span class="koboSpan" id="kobo.6150.2">A container that does offer constant time insertions in the middle is </span><code class="inlineCode"><span class="koboSpan" id="kobo.6151.1">std::list</span></code><span class="koboSpan" id="kobo.6152.1">. </span><span class="koboSpan" id="kobo.6152.2">This is implemented as a double-linked list, which means elements are not stored in contiguous memory. </span><span class="koboSpan" id="kobo.6152.3">The use cases for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6153.1">std::list</span></code><span class="koboSpan" id="kobo.6154.1"> are not many though. </span><span class="koboSpan" id="kobo.6154.2">A typical one is the situations when you need to do many inserts and removals in the middle, more than iterations over the list. </span><span class="koboSpan" id="kobo.6154.3">You can</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.6155.1"> also use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6156.1">std::list</span></code><span class="koboSpan" id="kobo.6157.1"> when you have one or more sequences that you need to split and join often. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.6158.1">If you also need to retain the validity of iterators and references to the elements of the list even after an insert or removal, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.6159.1">std::list</span></code><span class="koboSpan" id="kobo.6160.1"> is a good candidate:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6161.1">std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6162.1">int</span></span><span class="koboSpan" id="kobo.6163.1">&gt; l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.6164.1">1</span></span><span class="koboSpan" id="kobo.6165.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6166.1">1</span></span><span class="koboSpan" id="kobo.6167.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.6168.1"> 2</span></span><span class="koboSpan" id="kobo.6169.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6170.1">3</span></span><span class="koboSpan" id="kobo.6171.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6172.1">5</span></span><span class="koboSpan" id="kobo.6173.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6174.1">8</span></span><span class="koboSpan" id="kobo.6175.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6176.1">auto</span></span><span class="koboSpan" id="kobo.6177.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6178.1">find</span></span><span class="koboSpan" id="kobo.6179.1">(l.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6180.1">begin</span></span><span class="koboSpan" id="kobo.6181.1">(), l.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6182.1">end</span></span><span class="koboSpan" id="kobo.6183.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.6184.1">3</span></span><span class="koboSpan" id="kobo.6185.1">);
l.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6186.1">insert</span></span><span class="koboSpan" id="kobo.6187.1">(it, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6188.1">13</span></span><span class="koboSpan" id="kobo.6189.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6190.1">The next diagram shows a conceptual representation of a (double-linked) list and the insertion of a new element in the middle of it:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.6191.1"><img alt="" src="../Images/B21549_05_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.6192.1">Figure 5.3: Inserting an element in the middle of a list</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6193.1">If you want to store values identified by a key, associative containers are the appropriate </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.6194.1">solution. </span><span class="koboSpan" id="kobo.6194.2">Storing key-value pairs is possible with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.6195.1">std::map</span></code><span class="koboSpan" id="kobo.6196.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6197.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6198.1">. </span><span class="koboSpan" id="kobo.6198.2">These two containers differ significantly:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6199.1">std::map</span></code><span class="koboSpan" id="kobo.6200.1"> stores the key-value pairs ordered by the key (using a comparison function, the </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.6201.1">default being </span><code class="inlineCode"><span class="koboSpan" id="kobo.6202.1">std::less</span></code><span class="koboSpan" id="kobo.6203.1">), while </span><code class="inlineCode"><span class="koboSpan" id="kobo.6204.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6205.1">, as the name implies, does not retain any order.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6206.1">std::map</span></code><span class="koboSpan" id="kobo.6207.1"> is implemented with self-balancing </span><strong class="keyWord"><span class="koboSpan" id="kobo.6208.1">binary search trees</span></strong><span class="koboSpan" id="kobo.6209.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6210.1">BST</span></strong><span class="koboSpan" id="kobo.6211.1">) such as red-back trees, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.6212.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6213.1"> is implemented with hash tables. </span><span class="koboSpan" id="kobo.6213.2">Since hash tables require more book-keeping data, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6214.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6215.1"> uses more memory than </span><code class="inlineCode"><span class="koboSpan" id="kobo.6216.1">std::map</span></code><span class="koboSpan" id="kobo.6217.1"> to store the same number of elements.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6218.1">std::map</span></code><span class="koboSpan" id="kobo.6219.1"> provides logarithmic complexity, </span><em class="italic"><span class="koboSpan" id="kobo.6220.1">O(log(n))</span></em><span class="koboSpan" id="kobo.6221.1">, for search operations, and the same plus a rebalancing for inserts and removals, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.6222.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6223.1"> provides constant-time,</span><em class="italic"><span class="koboSpan" id="kobo.6224.1"> O(1)</span></em><span class="koboSpan" id="kobo.6225.1">, on average for inserts, although worst case scenarios decrease to linear complexity, </span><em class="italic"><span class="koboSpan" id="kobo.6226.1">O(n)</span></em><span class="koboSpan" id="kobo.6227.1">, for all search, insert, and remove operations.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6228.1">Based on these differences, we can identify typical use cases for each of these containers:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6229.1">std::map</span></code><span class="koboSpan" id="kobo.6230.1"> is recommended when:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6231.1">You need to store the elements ordered in the container, so that they can be accessed in their defined order</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6232.1">You need the successor or predecessor of an element</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6233.1">You need to lexicographically compare maps with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6234.1">&lt;</span></code><span class="koboSpan" id="kobo.6235.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6236.1">&lt;=</span></code><span class="koboSpan" id="kobo.6237.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6238.1">&gt;</span></code><span class="koboSpan" id="kobo.6239.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6240.1">&gt;=</span></code><span class="koboSpan" id="kobo.6241.1"> operators</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6242.1">You want to use algorithms such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6243.1">binary_search()</span></code><span class="koboSpan" id="kobo.6244.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6245.1">lower_bound()</span></code><span class="koboSpan" id="kobo.6246.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6247.1">upper_bound()</span></code></li>
</ul>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6248.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6249.1"> is recommended when:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6250.1">You don’t need to store the unique objects in a particular order</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6251.1">You perform a lot of inserts/removals and searches</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6252.1">You need to access individual elements and iterating over the entire sequence is not required</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6253.1">In order to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.6254.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6255.1">, a hash function (either a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.6256.1">std::hash&lt;T&gt;</span></code><span class="koboSpan" id="kobo.6257.1"> or a different implementation) must be defined for the type of the stored elements. </span><span class="koboSpan" id="kobo.6257.2">This is necessary because in an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6258.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6259.1">, elements are stored in buckets. </span><span class="koboSpan" id="kobo.6259.2">The bucket to which an element is stored depends on the hash value of the key. </span><span class="koboSpan" id="kobo.6259.3">A good hashing function can prevent collisions, allowing all operations to take constant time – </span><em class="italic"><span class="koboSpan" id="kobo.6260.1">O(1)</span></em><span class="koboSpan" id="kobo.6261.1">. </span><span class="koboSpan" id="kobo.6261.2">On the other hand, if the hashing function is not well crafted, it can lead to collisions that degrade searches and inserts/removals to linear complexity – </span><em class="italic"><span class="koboSpan" id="kobo.6262.1">O(n)</span></em><span class="koboSpan" id="kobo.6263.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6264.1">When you</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.6265.1"> want to store unique objects but do not have a key associated with each object, the right standard containers are </span><code class="inlineCode"><span class="koboSpan" id="kobo.6266.1">std::set</span></code><span class="koboSpan" id="kobo.6267.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6268.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6269.1">. </span><span class="koboSpan" id="kobo.6269.2">A set is very similar to a map, except that the object is also the key. </span><span class="koboSpan" id="kobo.6269.3">These two containers, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6270.1">std::set</span></code><span class="koboSpan" id="kobo.6271.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6272.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6273.1">, have the same differences we saw for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6274.1">std::map</span></code><span class="koboSpan" id="kobo.6275.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6276.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6277.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6278.1">In a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6279.1">std::set</span></code><span class="koboSpan" id="kobo.6280.1"> objects are ordered, while in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6281.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6282.1"> they are unordered.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6283.1">std::set</span></code><span class="koboSpan" id="kobo.6284.1"> is implemented with red-black trees, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.6285.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6286.1"> is implemented with hash tables.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6287.1">std::set</span></code><span class="koboSpan" id="kobo.6288.1"> provides logarithmic complexity, </span><em class="italic"><span class="koboSpan" id="kobo.6289.1">O(log(n))</span></em><span class="koboSpan" id="kobo.6290.1">, for search operations, and the same plus a rebalancing for inserts and removals, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.6291.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6292.1"> provides constant-time, </span><em class="italic"><span class="koboSpan" id="kobo.6293.1">O(1)</span></em><span class="koboSpan" id="kobo.6294.1">, on average for inserts, although worst case scenarios decrease to linear complexity, </span><em class="italic"><span class="koboSpan" id="kobo.6295.1">O(n)</span></em><span class="koboSpan" id="kobo.6296.1">, for all search, insert, and remove operations.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6297.1">Taking these differences into consideration and the similarities with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6298.1">std::map</span></code><span class="koboSpan" id="kobo.6299.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.6300.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6301.1"> containers, we can identify the same use-case scenarios for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6302.1">std::set</span></code><span class="koboSpan" id="kobo.6303.1"> as we did for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6304.1">std::map</span></code><span class="koboSpan" id="kobo.6305.1"> and for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6306.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6307.1"> as we did for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6308.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6309.1">. </span><span class="koboSpan" id="kobo.6309.2">Also, for using </span><code class="inlineCode"><span class="koboSpan" id="kobo.6310.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.6311.1">, a hashing function must be defined for the type of the stored objects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6312.1">When you need to store more than one value associated with a key, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.6313.1">std::multimap</span></code><span class="koboSpan" id="kobo.6314.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6315.1">std::unordered_multimap</span></code><span class="koboSpan" id="kobo.6316.1">. </span><span class="koboSpan" id="kobo.6316.2">These two have the same considerations as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6317.1">std::map</span></code><span class="koboSpan" id="kobo.6318.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6319.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6320.1">. </span><span class="koboSpan" id="kobo.6320.2">We can say that </span><code class="inlineCode"><span class="koboSpan" id="kobo.6321.1">std::multimap</span></code><span class="koboSpan" id="kobo.6322.1"> is to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6323.1">std::map</span></code><span class="koboSpan" id="kobo.6324.1"> what </span><code class="inlineCode"><span class="koboSpan" id="kobo.6325.1">std::unordered_multimap</span></code><span class="koboSpan" id="kobo.6326.1"> is to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6327.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.6328.1">. </span><span class="koboSpan" id="kobo.6328.2">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6329.1">std::multiset</span></code><span class="koboSpan" id="kobo.6330.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6331.1">std::unordered_multiset</span></code><span class="koboSpan" id="kobo.6332.1"> can be used to store duplicates in a set.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6333.1">Considering all the various standard container types and their typical use based on their characteristics, we can use the following diagram to select the most appropriate container. </span><span class="koboSpan" id="kobo.6333.2">The following diagram was created by me, based on the one created by Mikael Persson and shared on StackOverflow: (</span><a href="https://stackoverflow.com/a/22671607/648078"><span class="url"><span class="koboSpan" id="kobo.6334.1">https://stackoverflow.com/a/22671607/648078</span></span></a><span class="koboSpan" id="kobo.6335.1">).</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.6336.1"><img alt="" src="../Images/B21549_05_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.6337.1">Figure 5.4: Flowchart for selecting the right standard container</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.6338.1">Although this recipe is intended as a guide for selecting the right standard container, it does not cover all containers and all possible considerations. </span><span class="koboSpan" id="kobo.6338.2">When performance is key, the best choice may not be the typical one. </span><span class="koboSpan" id="kobo.6338.3">In such a situation, you should try different implementations with different choices, benchmark them, and decide on a solution based on the results of your measurements.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-324"><span class="koboSpan" id="kobo.6339.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6340.1">Using vector as a default container</span></em><span class="koboSpan" id="kobo.6341.1">, to learn how you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6342.1">std::vector</span></code><span class="koboSpan" id="kobo.6343.1"> class</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6344.1">Using vector&lt;bool&gt; for variable-size sequences of bits</span></em><span class="koboSpan" id="kobo.6345.1">, to understand how this </span><code class="inlineCode"><span class="koboSpan" id="kobo.6346.1">std::vector</span></code><span class="koboSpan" id="kobo.6347.1"> specialization for bool can be used to manipulate sequence of bits</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.6348.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6349.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_05.xhtml"><span class="url"><span class="koboSpan" id="kobo.6350.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.6351.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>