<html><head></head><body>
<div><h1 class="chapterNumber">5</h1>
<h1 class="chapterTitle" id="_idParaDest-259">Standard Library Containers, Algorithms, and Iterators</h1>
<p class="normal">The C++ standard library has evolved a lot with C++11/14/17/20, and now C++23. However, at its core still sit three main pillars: containers, algorithms, and iterators. They are all implemented as generic types and general-purpose function templates. In this chapter, we’ll look at how they can be employed together to achieve various goals.</p>
<p class="normal">We will cover the following recipes in this chapter:</p>
<ul>
<li class="bulletList">Using <code class="inlineCode">vector</code> as a default container</li>
<li class="bulletList">Using <code class="inlineCode">bitset</code> for fixed-size sequences of bits</li>
<li class="bulletList">Using <code class="inlineCode">vector&lt;bool&gt;</code> for variable-size sequences of bits</li>
<li class="bulletList">Using the bit manipulation utilities</li>
<li class="bulletList">Finding elements in a range</li>
<li class="bulletList">Sorting a range</li>
<li class="bulletList">Initializing a range</li>
<li class="bulletList">Using set operations on a range</li>
<li class="bulletList">Using iterators to insert new elements into a container</li>
<li class="bulletList">Writing your own random-access iterator</li>
<li class="bulletList">Container access with non-member functions</li>
<li class="bulletList">Selecting the right standard containers</li>
</ul>
<p class="normal">We’ll begin this chapter by exploring the functionalities of the de facto default container in C++, which is <code class="inlineCode">std::vector</code>.</p>
<h1 class="heading-1" id="_idParaDest-260">Using vector as a default container</h1>
<p class="normal">The <a id="_idIndexMarker573"/>standard library provides various types of containers that store collections of objects; the library includes sequence containers (such as <code class="inlineCode">vector</code>, <code class="inlineCode">array</code>, and <code class="inlineCode">list</code>), ordered and unordered associative containers (such as <code class="inlineCode">set</code> and <code class="inlineCode">map</code>), and container adapters that do not store data but provide an adapted interface toward a sequence container (such as <code class="inlineCode">stack</code> and <code class="inlineCode">queue</code>). All of them are implemented as class templates, which means they can be used with any type (providing it meets the container requirements). In general, you should always use the container that is the most appropriate for a particular problem, which not only provides good performance in terms of speed of inserts, deletes, access to elements, and memory usage but also makes the code easy to read and maintain. However, the default choice should be <code class="inlineCode">vector</code>. In this recipe, we will see why <code class="inlineCode">vector</code> should be the preferred choice for a container in many cases and what the most common operations with <code class="inlineCode">vector</code> are.</p>
<h2 class="heading-2" id="_idParaDest-261">Getting ready</h2>
<p class="normal">For this recipe, you must be familiar with arrays, both statically and dynamically allocated. A couple of examples are provided here:</p>
<pre class="programlisting code"><code class="hljs-code">double d[3];           // a statically allocated array of 3 doubles
int* arr = new int[5]; // a dynamically allocated array of 5 ints
</code></pre>
<p class="normal">The <code class="inlineCode">vector</code> class template is available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;vector&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-262">How to do it...</h2>
<p class="normal">To initialize an <code class="inlineCode">std::vector</code> class template, you can use any of the following methods, but you are not restricted to only these:</p>
<ul>
<li class="bulletList">Initialize from an initialization list:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v1 { 1, 2, 3, 4, 5 };
</code></pre>
</li>
<li class="bulletList">Initialize from an array:
        <pre class="programlisting code"><code class="hljs-code">int arr[] = { 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; v21(arr, arr + 5); // v21 = { 1, 2, 3, 4, 5 }
std::vector&lt;int&gt; v22(arr+1, arr+4); // v22 = { 2, 3, 4 }
</code></pre>
</li>
<li class="bulletList">Initialize from another container:
        <pre class="programlisting code"><code class="hljs-code">std::list&lt;int&gt; l{ 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; v3(l.begin(), l.end()); //{ 1, 2, 3, 4, 5 }
</code></pre>
</li>
<li class="bulletList">Initialize from a count and a value:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v4(5, 1); // {1, 1, 1, 1, 1}
</code></pre>
</li>
</ul>
<p class="normal">To <a id="_idIndexMarker574"/>modify the content of <code class="inlineCode">std::vector</code>, you can use any of the following methods (as above, you’re not restricted to just these):</p>
<ul>
<li class="bulletList">Add an element at the end of the vector with <code class="inlineCode">push_back()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 5 };
v1.push_back(6); // v1 = { 1, 2, 3, 4, 5, 6 }
</code></pre>
</li>
<li class="bulletList">Remove an element from the end of the vector with <code class="inlineCode">pop_back()</code>:
        <pre class="programlisting code"><code class="hljs-code">v1.pop_back();   // v1 = { 1, 2, 3, 4, 5 }
</code></pre>
</li>
<li class="bulletList">Insert anywhere in the vector with <code class="inlineCode">insert()</code>:
        <pre class="programlisting code"><code class="hljs-code">int arr[] = { 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; v21;
v21.insert(v21.begin(), arr, arr + 5); // v21 = { 1, 2, 3, 4, 5 }
std::vector&lt;int&gt; v22;
v22.insert(v22.begin(), arr, arr + 3); // v22 = { 1, 2, 3 }
</code></pre>
</li>
<li class="bulletList">Add an element by creating it at the end of the vector with <code class="inlineCode">emplace_back()</code>:
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  int a;
  double b;
  std::string c;
  foo(int a, double b, std::string const &amp; c) :
    a(a), b(b), c(c) {}
};
std::vector&lt;foo&gt; v3;
v3.emplace_back(1, 1.0, "one"s);
// v3 = { foo{1, 1.0, "one"} }
</code></pre>
</li>
<li class="bulletList">Insert an element by creating it anywhere in the vector with <code class="inlineCode">emplace()</code>:
        <pre class="programlisting code"><code class="hljs-code">v3.emplace(v3.begin(), 2, 2.0, "two"s);
// v3 = { foo{2, 2.0, "two"}, foo{1, 1.0, "one"} }
</code></pre>
</li>
</ul>
<p class="normal">To<a id="_idIndexMarker575"/> modify the whole content of the vector, you can use any of the following methods, although you’re not restricted to just these:</p>
<ul>
<li class="bulletList">Assign from another vector with <code class="inlineCode">operator=</code>; this replaces the content of the container:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; v2{ 10, 20, 30 };
v2 = v1; // v2 = { 1, 2, 3, 4, 5 }
</code></pre>
</li>
<li class="bulletList">Assign from another sequence defined by a begin and end iterator with the <code class="inlineCode">assign()</code> method; this replaces the content of the container:
        <pre class="programlisting code"><code class="hljs-code">int arr[] = { 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; v31;
v31.assign(arr, arr + 5);     // v31 = { 1, 2, 3, 4, 5 }
std::vector&lt;int&gt; v32;
v32.assign(arr + 1, arr + 4); // v32 = { 2, 3, 4 }
</code></pre>
</li>
<li class="bulletList">Swap the content of two vectors with the <code class="inlineCode">swap()</code> method:
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v4{ 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; v5{ 10, 20, 30 };
v4.swap(v5); // v4 = { 10, 20, 30 }, v5 = { 1, 2, 3, 4, 5 }
</code></pre>
</li>
<li class="bulletList">Remove all the elements with the <code class="inlineCode">clear()</code> method:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v6{ 1, 2, 3, 4, 5 };
v6.clear(); // v6 = { }
</code></pre>
</li>
<li class="bulletList">Remove one or more elements with the <code class="inlineCode">erase()</code> method (which requires either an iterator or a pair of iterators that define the range of elements from the vector to be removed):
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v7{ 1, 2, 3, 4, 5 };
v7.erase(v7.begin() + 2, v7.begin() + 4); // v7 = { 1, 2, 5 }
</code></pre>
</li>
<li class="bulletList">Remove one or more elements that satisfy a predicate with the <code class="inlineCode">std::remove_if()</code> function and the <code class="inlineCode">erase()</code> method:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v8{ 1, 2, 3, 4, 5 };
auto iterToNext = v8.erase(
   std::remove_if(v8.begin(), v8.end(), 
      [](const int n) {return n % 2 == 0; }),
   v8.end());                            // v8 = { 1, 3, 5 }
</code></pre>
</li>
<li class="bulletList">Remove one or more elements that satisfy a predicate with the <code class="inlineCode">std::erase_if()</code> function, introduced in C++20. A similar <code class="inlineCode">std::erase()</code> function also exists:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v9{ 1, 2, 3, 4, 5 };
auto erasedCount = std::erase_if(v9, [](const int n) {
   return n % 2 == 0; });                // v9 = { 1, 3, 5 }
</code></pre>
</li>
</ul>
<p class="normal">To get <a id="_idIndexMarker576"/>the address of the first element in a vector, usually to pass the content of a vector to a C-like API, use any of the following methods:</p>
<ul>
<li class="bulletList">Use the <code class="inlineCode">data()</code> method, which returns a pointer to the first element, providing direct access to the underlying contiguous sequence of memory where the vector elements are stored; this is only available since C++11:
        <pre class="programlisting code"><code class="hljs-code">void process(int const * const arr, size_t const size)
{ /* do something */ }
std::vector&lt;int&gt; v{ 1, 2, 3, 4, 5 };
process(v.data(), v.size());
</code></pre>
</li>
<li class="bulletList">Get the address of the first element:
        <pre class="programlisting code"><code class="hljs-code">process(&amp;v[0], v.size());
</code></pre>
</li>
<li class="bulletList">Get the address of the element referred to by the <code class="inlineCode">front()</code> method (calling this method on an empty vector is undefined behavior):
        <pre class="programlisting code"><code class="hljs-code">process(&amp;v.front(), v.size());
</code></pre>
</li>
<li class="bulletList">Get the address of the element pointed by the iterator returned from <code class="inlineCode">begin()</code>:
        <pre class="programlisting code"><code class="hljs-code">process(&amp;*v.begin(), v.size());
</code></pre>
</li>
</ul>
<p class="normal">To <a id="_idIndexMarker577"/>modify the content of a vector, in C++23, you can also use the following range-aware member functions:</p>
<p class="normal">To replace the elements of a vector with a copy of the elements of a given range, use <code class="inlineCode">assign_range()</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::list&lt;int&gt;   l{ 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; v;
v.assign_range(l); // v = {1, 2, 3, 4, 5}
</code></pre>
<p class="normal">To append copies of the elements of a range at the end of a vector (before the end iterator), use <code class="inlineCode">append_range()</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::list&lt;int&gt;   l{ 3, 4, 5 };
std::vector&lt;int&gt; v{ 1, 2 };
v.append_range(l);  // v = {1, 2, 3, 4, 5}
</code></pre>
<p class="normal">To insert copies of the elements of a range before a given iterator of a vector, use <code class="inlineCode">insert_range()</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::list&lt;int&gt;   l{ 2, 3, 4 };
std::vector&lt;int&gt; v{ 1, 5 };
v.insert_range(v.begin() + 1, l); // v = {1, 2, 3, 4, 5}
</code></pre>
<h2 class="heading-2" id="_idParaDest-263">How it works...</h2>
<p class="normal">The <code class="inlineCode">std::vector</code> class is designed to be the C++ container most similar to and inter-operable with arrays. A vector is a variable-sized sequence of elements, guaranteed to be stored contiguously in memory, which makes the content of a vector easily passable to a C-like function that takes a pointer to an element of an array and, usually, a size. </p>
<p class="normal">There are many benefits of using a vector instead of arrays, and these benefits include:</p>
<ul>
<li class="bulletList">No direct memory management is required from the developer as the container does this internally, allocating memory, reallocating it, and releasing it.
    <div><p class="normal">Note that a vector is intended for storing object instances. If you need to store pointers, do not store raw pointers but smart pointers. Otherwise, you need to handle the lifetime management of the pointed objects.</p>
</div></li>
</ul>
<ul>
<li class="bulletList">The possibility of modifying the size of the vector.</li>
<li class="bulletList">Simple assignment or concatenation of two vectors.</li>
<li class="bulletList">Direct comparison of two vectors.</li>
</ul>
<p class="normal">The <code class="inlineCode">vector</code> class is <a id="_idIndexMarker578"/>a very efficient container, with all its implementations providing a lot of optimizations that most developers are not capable of doing with arrays. Random access to its elements and insertion and removal at the end of a vector is a constant <em class="italic">O(1)</em> operation (provided that reallocation is not necessary), while insertion and removal anywhere else is a linear <em class="italic">O(n)</em> operation.</p>
<p class="normal">Compared to other standard containers, the vector has various benefits:</p>
<ul>
<li class="bulletList">It is compatible with arrays and C-like APIs. If a function takes an array as a parameter, the content of other containers (except for <code class="inlineCode">std::array</code>) needs to be copied to a <code class="inlineCode">vector</code> before being passed as an argument to the function.</li>
<li class="bulletList">It has the fastest access to elements of all containers (but the same as <code class="inlineCode">std::array</code>).</li>
<li class="bulletList">It has no per-element memory overhead for storing elements. This is because elements are stored in a contiguous space, like arrays are. Therefore, <code class="inlineCode">vector</code> has a small memory footprint, unlike other containers, such as <code class="inlineCode">list</code>, which require additional pointers to other elements, or associative containers, which require hash values.</li>
</ul>
<p class="normal"><code class="inlineCode">std::vector</code> is very similar in semantics to arrays but has a variable size. The size of a vector can increase and decrease. There are two properties that define the size of a vector:</p>
<ul>
<li class="bulletList"><em class="italic">Capacity</em> is the number of elements the vector can accommodate without performing additional memory allocations; this is indicated by the <code class="inlineCode">capacity()</code> method.</li>
<li class="bulletList"><em class="italic">Size</em> is the actual number of elements in the vector; this is indicated by the <code class="inlineCode">size()</code> method.</li>
</ul>
<p class="normal">Size is always smaller than or equal to capacity. When size is equal to capacity and a new element needs to be added, the capacity needs to be modified so that the vector has space for more elements. In this case, the vector allocates a new chunk of memory and moves the previous content to the new location before freeing the previously allocated memory. Though this sounds time-consuming—and it is—implementations increase the capacity exponentially by doubling it each time it needs to be changed. As a result, on average, each element of the vector only needs to be moved once (that is because all the elements of the vector are moved during an increase of capacity, but then an equal number of elements can be added without incurring more moves, given that insertions are performed at the end of the vector).</p>
<p class="normal">If you know <a id="_idIndexMarker579"/>beforehand how many elements will be inserted in the vector, you can first call the <code class="inlineCode">reserve()</code> method to increase the capacity to at least the specified amount (this method does nothing if the specified size is smaller than the current capacity) and only then insert the elements.</p>
<p class="normal">On the other hand, if you need to free additional reserved memory, you can use the <code class="inlineCode">shrink_to_fit()</code> method to request this, but it is an implementation decision as to whether to free any memory or not. An alternative to this non-binding method, available since C++11, is to do a swap with a temporary, empty vector:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 2, 3, 4, 5 };
std::vector&lt;int&gt;().swap(v); // v.size = 0, v.capacity = 0
</code></pre>
<p class="normal">Calling the <code class="inlineCode">clear()</code> method only removes all the elements from the vector but does not free any memory.</p>
<p class="normal">It should be noted that the <code class="inlineCode">vector</code> class implements some operations that are specific to other types of containers:</p>
<ul>
<li class="bulletList"><em class="italic">stack</em>: With <code class="inlineCode">push_back()</code> and <code class="inlineCode">emplace_back()</code> to add at the end and <code class="inlineCode">pop_back()</code> to remove from the end. Keep in mind that <code class="inlineCode">pop_back()</code> does not return the last element that has been removed. You need to access that explicitly, if that is necessary, for instance, using the <code class="inlineCode">back()</code> method before removing the element.</li>
<li class="bulletList"><em class="italic">list</em>: With <code class="inlineCode">insert()</code> and <code class="inlineCode">emplace()</code> to add elements in the middle of the sequence and <code class="inlineCode">erase()</code> to remove elements from anywhere in the sequence.</li>
</ul>
<div><p class="normal">A good rule of thumb for C++ containers is to use <code class="inlineCode">std::vector</code> as the default container unless you have good reasons to use another one.</p>
</div>
<h2 class="heading-2" id="_idParaDest-264">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using bitset for fixed-size sequences of bits</em>, to learn about the standard container for handling bit sequences of fixed sizes</li>
<li class="bulletList"><em class="italic">Using vector&lt;bool&gt; for variable-size sequences of bits</em>, to learn about the specialization of <code class="inlineCode">std::vector</code> for the <code class="inlineCode">bool</code> type, intended for handling bit sequences of variable sizes</li>
</ul>
<h1 class="heading-1" id="_idParaDest-265">Using bitset for fixed-size sequences of bits</h1>
<p class="normal">It is not <a id="_idIndexMarker580"/>uncommon for developers to operate with bit flags. This can be either because they work with operating system APIs (usually written in C) that take various types of arguments (such as options or styles) in the form of bit flags, or because they work with libraries that do similar things, or simply because some types of problems are naturally solved with bit flags. </p>
<p class="normal">We can think of alternatives to working with bits and bit operations, such as defining arrays that have one element for every option/flag, or defining a structure with members and functions to model the bit flags, but these are often more complicated; and in cases when you need to pass a numerical value representing bit flags to a function, you still need to convert the array or the structure to a sequence of bits. For this reason, the C++ standard provides a container called <code class="inlineCode">std::bitset</code> for fixed-size sequences of bits.</p>
<h2 class="heading-2" id="_idParaDest-266">Getting ready</h2>
<p class="normal">For this recipe, you must be familiar with bitwise operations (AND, OR, XOR, NOT, and shifting – moving each digit in a number’s binary representation to the left or right). If you need to learn more about these, <a href="https://en.wikipedia.org/wiki/Bitwise_operation">https://en.wikipedia.org/wiki/Bitwise_operation</a> is a good starting point.</p>
<p class="normal">The <code class="inlineCode">bitset</code> class is available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;bitset&gt;</code> header. A bitset represents a fixed-size sequence of bits, with the size defined at compile time. For convenience, in this recipe, most examples will be with bitsets of 8 bits.</p>
<h2 class="heading-2" id="_idParaDest-267">How to do it...</h2>
<p class="normal">To construct an <code class="inlineCode">std::bitset</code> object, use one of the available constructors:</p>
<ul>
<li class="bulletList">An empty bitset with all bits set to <code class="inlineCode">0</code>:
        <pre class="programlisting code"><code class="hljs-code">std::bitset&lt;8&gt; b1;            // [0,0,0,0,0,0,0,0]
</code></pre>
</li>
<li class="bulletList">A bitset from a numerical value:
        <pre class="programlisting code"><code class="hljs-code">std::bitset&lt;8&gt; b2{ 10 };      // [0,0,0,0,1,0,1,0]
</code></pre>
</li>
<li class="bulletList">A bitset from a string of <code class="inlineCode">'0'</code> and <code class="inlineCode">'</code><code class="inlineCode">1'</code>:
        <pre class="programlisting code"><code class="hljs-code">std::bitset&lt;8&gt; b3{ "1010"s }; // [0,0,0,0,1,0,1,0]
</code></pre>
</li>
<li class="bulletList">A bitset from a string containing any two characters representing <code class="inlineCode">'0'</code> and <code class="inlineCode">'1'</code>; in this case, we must specify which character represents a <code class="inlineCode">0</code> (the fourth parameter, <code class="inlineCode">'o'</code>) and which character represents a <code class="inlineCode">1</code> (the fifth parameter, <code class="inlineCode">'x'</code>):
        <pre class="programlisting code"><code class="hljs-code">std::bitset&lt;8&gt; b4
  { "ooooxoxo"s, 0, std::string::npos, 'o', 'x' };
  // [0,0,0,0,1,0,1,0]
</code></pre>
</li>
</ul>
<p class="normal">To test<a id="_idIndexMarker581"/> individual bits in the set or the entire set for specific values, use any of the available methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">count()</code> to get the number of bits set to <code class="inlineCode">1</code>:
        <pre class="programlisting code"><code class="hljs-code">std::bitset&lt;8&gt; bs{ 10 };
std::cout &lt;&lt; "has " &lt;&lt; bs.count() &lt;&lt; " 1s" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">any()</code> to check whether there is at least one bit set to <code class="inlineCode">1</code>:
        <pre class="programlisting code"><code class="hljs-code">if (bs.any()) std::cout &lt;&lt; "has some 1s" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">all()</code> to check whether all the bits are set to <code class="inlineCode">1</code>:
        <pre class="programlisting code"><code class="hljs-code">if (bs.all()) std::cout &lt;&lt; "has only 1s" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">none()</code> to check whether all the bits are set to <code class="inlineCode">0</code>:
        <pre class="programlisting code"><code class="hljs-code">if (bs.none()) std::cout &lt;&lt; "has no 1s" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">test()</code> to check the value of an individual bit (whose position is the only argument to the function):
        <pre class="programlisting code"><code class="hljs-code">if (!bs.test(0)) std::cout &lt;&lt; "even" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">operator[]</code> to access and test individual bits:
        <pre class="programlisting code"><code class="hljs-code">if(!bs[0]) std::cout &lt;&lt; "even" &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<p class="normal">To modify<a id="_idIndexMarker582"/> the content of a bitset, use any of the following methods:</p>
<ul>
<li class="bulletList">Member operators <code class="inlineCode">|=</code>, <code class="inlineCode">&amp;=</code>, <code class="inlineCode">^=</code>, and <code class="inlineCode">~</code> to perform the binary operation OR, AND, XOR, and NOT, respectively. Alternatively, use the non-member operators <code class="inlineCode">|</code>, <code class="inlineCode">&amp;</code>, and <code class="inlineCode">^</code>:
        <pre class="programlisting code"><code class="hljs-code">std::bitset&lt;8&gt; b1{ 42 }; // [0,0,1,0,1,0,1,0]
std::bitset&lt;8&gt; b2{ 11 }; // [0,0,0,0,1,0,1,1]
auto b3 = b1 | b2;       // [0,0,1,0,1,0,1,1]
auto b4 = b1 &amp; b2;       // [0,0,0,0,1,0,1,0]
auto b5 = b1 ^ b2;       // [0,0,1,0,0,0,0,1]
auto b6 = ~b1;           // [1,1,0,1,0,1,0,1]
</code></pre>
</li>
<li class="bulletList">Member operators <code class="inlineCode">&lt;&lt;=</code>, <code class="inlineCode">&lt;&lt;</code>, <code class="inlineCode">&gt;&gt;=</code>, and <code class="inlineCode">&gt;&gt;</code> to perform shifting operations:
        <pre class="programlisting code"><code class="hljs-code">auto b7 = b1 &lt;&lt; 2;       // [1,0,1,0,1,0,0,0]
auto b8 = b1 &gt;&gt; 2;       // [0,0,0,0,1,0,1,0]
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">flip()</code> to toggle the entire set or an individual bit from <code class="inlineCode">0</code> to <code class="inlineCode">1</code> or from <code class="inlineCode">1</code> to <code class="inlineCode">0</code>:
        <pre class="programlisting code"><code class="hljs-code">b1.flip();               // [1,1,0,1,0,1,0,1]
b1.flip(0);              // [1,1,0,1,0,1,0,0]
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">set()</code> to change the entire set or an individual bit to <code class="inlineCode">true</code> or the specified value:
        <pre class="programlisting code"><code class="hljs-code">b1.set(0, true);         // [1,1,0,1,0,1,0,1]
b1.set(0, false);        // [1,1,0,1,0,1,0,0]
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">reset()</code> to change the entire set or an individual bit to <code class="inlineCode">false</code>:
        <pre class="programlisting code"><code class="hljs-code">b1.reset(2);             // [1,1,0,1,0,0,0,0]
</code></pre>
</li>
</ul>
<p class="normal">To convert a bitset to a numerical or string value, use the following methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">to_ulong()</code> and <code class="inlineCode">to_ullong()</code> to convert to <code class="inlineCode">unsigned long</code> or <code class="inlineCode">unsigned long long</code>. These operations throw an <code class="inlineCode">std::overflow_error</code> exception if the value cannot be represented in the output type. Refer to the following examples:
        <pre class="programlisting code"><code class="hljs-code">std::bitset&lt;8&gt; bs{ 42 };
auto n1 = bs.to_ulong();  // n1 = 42UL
auto n2 = bs.to_ullong(); // n2 = 42ULL
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">to_string()</code> to convert to <code class="inlineCode">std::basic_string</code>. By default, the result is a string containing <code class="inlineCode">'0'</code> and <code class="inlineCode">'1'</code>, but you can specify a different character for these two values:
        <pre class="programlisting code"><code class="hljs-code">auto s1 = bs.to_string();         // s1 = "00101010"
auto s2 = bs.to_string('o', 'x'); // s2 = "ooxoxoxo"
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-268">How it works...</h2>
<p class="normal">If you’ve <a id="_idIndexMarker583"/>ever worked with C or C-like APIs, chances are you have either written or at least seen code that manipulates bits to define styles, options, or other kinds of values. This usually involves operations such as:</p>
<ul>
<li class="bulletList">Defining the bit flags; these can be enumerations, static constants in a class, or macros introduced with <code class="inlineCode">#define</code> in the C style. Usually, there is a flag representing no value (style, option, and so on). Since these are supposed to be bit flags, their values are powers of 2.</li>
<li class="bulletList">Adding and removing flags from the set (that is, a numerical value). Adding a bit flag is done with the bit-or operator (<code class="inlineCode">value |= FLAG</code>) and removing a bit flag is done with the bit-and operator, with the negated flag (<code class="inlineCode">value &amp;= ~FLAG</code>).</li>
<li class="bulletList">Testing whether a flag is added to the set (<code class="inlineCode">value &amp; FLAG == FLAG</code>).</li>
<li class="bulletList">Calling functions with the flags as an argument.</li>
</ul>
<p class="normal">The following shows a simple example of flags defining the border style of a control that can have a border on the left, right, top, or bottom sides, or any combination of these, including no border:</p>
<pre class="programlisting code"><code class="hljs-code">#define BORDER_NONE   0x00
#define BORDER_LEFT   0x01
#define BORDER_TOP    0x02
#define BORDER_RIGHT  0x04
#define BORDER_BOTTOM 0x08
void apply_style(unsigned int const style)
{
  if (style &amp; BORDER_BOTTOM) { /* do something */ }
}
// initialize with no flags
unsigned int style = BORDER_NONE;
// set a flag
style = BORDER_BOTTOM;
// add more flags
style |= BORDER_LEFT | BORDER_RIGHT | BORDER_TOP;
// remove some flags
style &amp;= ~BORDER_LEFT;
style &amp;= ~BORDER_RIGHT;
// test if a flag is set
if ((style &amp; BORDER_BOTTOM) == BORDER_BOTTOM) {}
// pass the flags as argument to a function
apply_style(style);
</code></pre>
<p class="normal">The <a id="_idIndexMarker584"/>standard <code class="inlineCode">std::bitset</code> class is intended as a C++ alternative to this C-like working style with sets of bits. It enables us to write more robust and safer code because it abstracts the bit operations with member functions, though we still need to identify what each bit in the set is representing:</p>
<ul>
<li class="bulletList">Adding and removing flags is done with the <code class="inlineCode">set()</code> and <code class="inlineCode">reset()</code> methods, which set the value of a bit indicated by its position to <code class="inlineCode">1</code> or <code class="inlineCode">0</code> (or <code class="inlineCode">true</code> and <code class="inlineCode">false</code>); alternatively, we can use the index operator for the same purpose.</li>
<li class="bulletList">Testing if a bit is set with the <code class="inlineCode">test()</code> method.</li>
<li class="bulletList">Conversion from an integer or a string is done through the constructor, and conversion to an integer or string is done with member functions so that the values from the bitsets can be used where integers are expected (such as arguments to functions).</li>
</ul>
<p class="normal">Notice that the constructors that build a <code class="inlineCode">bitset</code> from a sequence of characters – be that a <code class="inlineCode">std::basic_string</code>, a <code class="inlineCode">const char*</code> (or any other character type), or a <code class="inlineCode">std::basic_string_view</code> in C++26, may throw exceptions: <code class="inlineCode">std::invalid_argument</code>, if any character is not the zero or one specified values, or <code class="inlineCode">std::out_of_range</code>, if the starting offset into the sequence is beyond the end of the sequence.</p>
<p class="normal">In addition to these operations, the <code class="inlineCode">bitset</code> class has additional methods for performing bitwise operations on bits, shifting, testing, and others that have been shown in the previous section.</p>
<p class="normal">Conceptually, <code class="inlineCode">std::bitset</code> is a representation of a numerical value that enables you to access and modify individual bits. Internally, however, a <code class="inlineCode">bitset</code> has an array of integer values<a id="_idIndexMarker585"/> on which it performs bit operations. The size of a <code class="inlineCode">bitset</code> is not limited to the size of a numerical type; it can be anything, except that it is a compile-time constant.</p>
<p class="normal">The example of the control border styles from the previous section can be written using <code class="inlineCode">std::bitset</code> in the following manner:</p>
<pre class="programlisting code"><code class="hljs-code">struct border_flags
{
  static const int left = 0;
  static const int top = 1;
  static const int right = 2;
  static const int bottom = 3;
};
// initialize with no flags
std::bitset&lt;4&gt; style;
// set a flag
style.set(border_flags::bottom);
// set more flags
style
  .set(border_flags::left)
  .set(border_flags::top)
  .set(border_flags::right);
// remove some flags
style[border_flags::left] = 0;
style.reset(border_flags::right);
// test if a flag is set
if (style.test(border_flags::bottom)) {}
// pass the flags as argument to a function
apply_style(style.to_ulong());
</code></pre>
<p class="normal">Keep in mind this is only one possible implementation. For instance, the <code class="inlineCode">border_flags</code> class could have been an enumeration. However, using a scoped enumeration would require explicit casts to <code class="inlineCode">int</code>. Different solutions may have advantages and disadvantages. You can take it as an exercise to write an alternative solution.</p>
<h2 class="heading-2" id="_idParaDest-269">There’s more...</h2>
<p class="normal">A bitset <a id="_idIndexMarker586"/>can be created from an integer and can convert its value to an integer using the <code class="inlineCode">to_ulong()</code> or <code class="inlineCode">to_ullong()</code> methods. However, if the size of the <code class="inlineCode">bitset</code> is larger than the size of these numerical types and any of the bits beyond the size of the requested numerical type is set to <code class="inlineCode">1</code>, then these methods throw an <code class="inlineCode">std::overflow_error</code> exception. This is because the value cannot be represented on <code class="inlineCode">unsigned long</code> or <code class="inlineCode">unsigned long long</code>. In order to extract all the bits, we need to do the following operations:</p>
<ul>
<li class="bulletList">Clear the bits beyond the size of <code class="inlineCode">unsigned long</code> or <code class="inlineCode">unsigned long long</code>.</li>
<li class="bulletList">Convert the value to <code class="inlineCode">unsigned long</code> or <code class="inlineCode">unsigned long long</code>.</li>
<li class="bulletList">Shift the <code class="inlineCode">bitset</code> with the number of bits in <code class="inlineCode">unsigned long</code> or <code class="inlineCode">unsigned long long</code>.</li>
<li class="bulletList">Do this until all the bits are retrieved.</li>
</ul>
<p class="normal">These are implemented as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;size_t N&gt;
std::vector&lt;unsigned long&gt; bitset_to_vectorulong(std::bitset&lt;N&gt; bs)
{
  auto result = std::vector&lt;unsigned long&gt; {};
  auto const size = 8 * sizeof(unsigned long);
  auto const mask = std::bitset&lt;N&gt;{ static_cast&lt;unsigned long&gt;(-1)};
  auto totalbits = 0;
  while (totalbits &lt; N)
  {
    auto value = (bs &amp; mask).to_ulong();
    result.push_back(value);
    bs &gt;&gt;= size;
    totalbits += size;
  }
  return result;
}
</code></pre>
<p class="normal">To exemplify, let’s take the following <code class="inlineCode">bitset</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::bitset&lt;128&gt; bs =
    (std::bitset&lt;128&gt;(0xFEDC) &lt;&lt; 96) |
    (std::bitset&lt;128&gt;(0xBA98) &lt;&lt; 64) |
    (std::bitset&lt;128&gt;(0x7654) &lt;&lt; 32) |
    std::bitset&lt;128&gt;(0x3210);
std::cout &lt;&lt; bs &lt;&lt; '\n';
</code></pre>
<p class="normal">If we print<a id="_idIndexMarker587"/> its content, we get the following:</p>
<pre class="programlisting con"><code class="hljs-con">00000000000000001111111011011100000000000000000010111010100110000000000000000000011101100101010000000000000000000011001000010000
</code></pre>
<p class="normal">However, when we convert this set to a sequence of <code class="inlineCode">unsigned long</code> values using <code class="inlineCode">biset_to_vectorulong()</code> and print their hexadecimal representation, we get the following:</p>
<pre class="programlisting code"><code class="hljs-code">auto result = bitset_to_vectorulong(bs);
for (auto const v : result)
  std::cout &lt;&lt; std::hex &lt;&lt; v &lt;&lt; '\n';
</code></pre>
<pre class="programlisting con"><code class="hljs-con">3210
7654
ba98
fedc
</code></pre>
<p class="normal">For cases where the size of the <code class="inlineCode">bitset</code> cannot be known at compile time, the alternative is <code class="inlineCode">std::vector&lt;bool&gt;</code>, which we will cover in the next recipe.</p>
<h2 class="heading-2" id="_idParaDest-270">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using vector&lt;bool&gt; for variable-size sequences of bits</em>, to learn about the specialization of <code class="inlineCode">std::vector</code> for the <code class="inlineCode">bool</code> type, which is used for handling bit sequences of variable sizes</li>
<li class="bulletList"><em class="italic">Using the bit manipulation utilities</em>, to explore the C++20 set of utility functions for bit manipulation from the numeric library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-271">Using vector&lt;bool&gt; for variable-size sequences of bits</h1>
<p class="normal">In the <a id="_idIndexMarker588"/>previous recipe, we looked at using <code class="inlineCode">std::bitset</code> for fixed-size sequences of bits. Sometimes, however, <code class="inlineCode">std::bitset</code> is not a good choice because you do not know the number of bits at compile time, and just defining a set of a large enough number of bits is not a good idea. This is because you can get into a situation where the number is not actually large enough. The standard alternative for this is to use the <code class="inlineCode">std::vector&lt;bool&gt;</code> container, which is a specialization of <code class="inlineCode">std::vector</code> with space and speed optimizations since implementations do not actually store Boolean values, but individual bits for each element.</p>
<div><p class="normal">For this reason, however, <code class="inlineCode">std::vector&lt;bool&gt;</code> does not meet the requirements of a standard container or sequential container, nor does <code class="inlineCode">std::vector&lt;bool&gt;::iterator</code> meet the requirements of a forward iterator. As a result, this specialization cannot be used in generic code where a vector is expected. On the other hand, being a vector, it has a different interface from that of <code class="inlineCode">std::bitset</code> and cannot be viewed as a binary representation of a number. There are no direct ways to construct <code class="inlineCode">std::vector&lt;bool&gt;</code> from a number or string, nor to convert it to a number or string.</p>
</div>
<h2 class="heading-2" id="_idParaDest-272">Getting ready...</h2>
<p class="normal">This recipe assumes you are familiar with both <code class="inlineCode">std::vector</code> and <code class="inlineCode">std::bitset</code>. If you didn’t read the previous recipes, <em class="italic">Using vector as a default container</em> and <em class="italic">Using bitset for fixed-size sequences of bits</em>, you should read them before continuing.</p>
<p class="normal">The <code class="inlineCode">vector&lt;bool&gt;</code> class is available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;vector&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-273">How to do it...</h2>
<p class="normal">To manipulate an <code class="inlineCode">std::vector&lt;bool&gt;</code>, use the same methods you would use for an <code class="inlineCode">std::vector&lt;T&gt;</code>, as shown in the following examples:</p>
<ul>
<li class="bulletList">Creating an empty vector:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;bool&gt; bv; // []
</code></pre>
</li>
<li class="bulletList">Adding bits to the vector:
        <pre class="programlisting code"><code class="hljs-code">bv.push_back(true);  // [1]
bv.push_back(true);  // [1, 1]
bv.push_back(false); // [1, 1, 0]
bv.push_back(false); // [1, 1, 0, 0]
bv.push_back(true);  // [1, 1, 0, 0, 1]
</code></pre>
</li>
<li class="bulletList">Setting the values of individual bits:
        <pre class="programlisting code"><code class="hljs-code">bv[3] = true;        // [1, 1, 0, 1, 1]
</code></pre>
</li>
<li class="bulletList">Using generic algorithms:
        <pre class="programlisting code"><code class="hljs-code">auto count_of_ones = std::count(bv.cbegin(), bv.cend(), true);
</code></pre>
</li>
<li class="bulletList">Removing bits from the vector:
        <pre class="programlisting code"><code class="hljs-code">bv.erase(bv.begin() + 2); // [1, 1, 1, 1]
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-274">How it works...</h2>
<p class="normal"><code class="inlineCode">std::vector&lt;bool&gt;</code> is not <a id="_idIndexMarker589"/>a standard vector because it is designed to provide space optimization by storing a single bit for each element instead of a Boolean value. Therefore, its elements are not stored in a contiguous sequence and cannot be substituted for an array of Booleans. Due to this:</p>
<ul>
<li class="bulletList">The index operator cannot return a reference to a specific element because elements are not stored individually:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;bool&gt; bv;
bv.resize(10);
auto&amp; bit = bv[0];      // error
</code></pre>
</li>
<li class="bulletList">Dereferencing an iterator cannot produce a reference to <code class="inlineCode">bool</code> for the same reason as mentioned earlier:
        <pre class="programlisting code"><code class="hljs-code">auto&amp; bit = *bv.begin(); // error
</code></pre>
</li>
<li class="bulletList">There is no guarantee that individual bits can be manipulated independently at the same time from different threads.</li>
<li class="bulletList">The vector cannot be used with algorithms that require forward iterators, such as <code class="inlineCode">std::search()</code>.</li>
<li class="bulletList">The vector cannot be used in some generic code where <code class="inlineCode">std::vector&lt;T&gt;</code> is expected if such code requires any of the operations mentioned in this list.</li>
</ul>
<p class="normal">An<a id="_idIndexMarker590"/> alternative to <code class="inlineCode">std::vector&lt;bool&gt;</code> is <code class="inlineCode">std::dequeu&lt;bool&gt;</code>, which is a standard container (a double-ended queue) that meets all container and iterator requirements and can be used with all standard algorithms. However, this will not have the space optimization that <code class="inlineCode">std::vector&lt;bool&gt;</code> provides.</p>
<h2 class="heading-2" id="_idParaDest-275">There’s more...</h2>
<p class="normal">The <code class="inlineCode">std::vector&lt;bool&gt;</code> interface is very different from <code class="inlineCode">std::bitset</code>. If you want to be able to write code in a similar manner, you can create a wrapper on <code class="inlineCode">std::vector&lt;bool&gt;</code>, which looks like <code class="inlineCode">std::bitset</code>, where possible. </p>
<p class="normal">The following implementation provides members similar to what is available in <code class="inlineCode">std::bitset</code>:</p>
<pre class="programlisting code"><code class="hljs-code">class bitvector
{
  std::vector&lt;bool&gt; bv;
public:
  bitvector(std::vector&lt;bool&gt; const &amp; bv) : bv(bv) {}
  bool operator[](size_t const i) { return bv[i]; }
  inline bool any() const {
    for (auto b : bv) if (b) return true;
    return false;
  }
  inline bool all() const {
    for (auto b : bv) if (!b) return false;
    return true;
  }
  inline bool none() const { return !any(); }
  inline size_t count() const {
    return std::count(bv.cbegin(), bv.cend(), true);
  }
  inline size_t size() const { return bv.size(); }
  inline bitvector &amp; add(bool const value) {
    bv.push_back(value);
    return *this;
  }
  inline bitvector &amp; remove(size_t const index) {
    if (index &gt;= bv.size())
      throw std::out_of_range("Index out of range");
    bv.erase(bv.begin() + index);
    return *this;
  }
  inline bitvector &amp; set(bool const value = true) {
    for (size_t i = 0; i &lt; bv.size(); ++i)
      bv[i] = value;
    return *this;
  }
  inline bitvector&amp; set(size_t const index, bool const value = true) {
    if (index &gt;= bv.size())
      throw std::out_of_range("Index out of range");
    bv[index] = value;
    return *this;
  }
  inline bitvector &amp; reset() {
    for (size_t i = 0; i &lt; bv.size(); ++i) bv[i] = false;
    return *this;
  }
  inline bitvector &amp; reset(size_t const index) {
    if (index &gt;= bv.size())
      throw std::out_of_range("Index out of range");
    bv[index] = false;
    return *this;
  }
  inline bitvector &amp; flip() {
    bv.flip();
    return *this;
  }
  std::vector&lt;bool&gt;&amp; data() { return bv; }
};
</code></pre>
<p class="normal">This is<a id="_idIndexMarker591"/> only a basic implementation, and if you want to use such a wrapper, you should add additional methods, such as bit logic operations, shifting, maybe reading and writing from and to streams, and so on. However, with the preceding code, we can write the following examples:</p>
<pre class="programlisting code"><code class="hljs-code">bitvector bv;
bv.add(true).add(true).add(false); // [1, 1, 0]
bv.add(false);                     // [1, 1, 0, 0]
bv.add(true);                      // [1, 1, 0, 0, 1]
if (bv.any()) std::cout &lt;&lt; "has some 1s" &lt;&lt; '\n';
if (bv.all()) std::cout &lt;&lt; "has only 1s" &lt;&lt; '\n';
if (bv.none()) std::cout &lt;&lt; "has no 1s" &lt;&lt; '\n';
std::cout &lt;&lt; "has " &lt;&lt; bv.count() &lt;&lt; " 1s" &lt;&lt; '\n';
bv.set(2, true);                   // [1, 1, 1, 0, 1]
bv.set();                          // [1, 1, 1, 1, 1]
bv.reset(0);                       // [0, 1, 1, 1, 1]
bv.reset();                        // [0, 0, 0, 0, 0]
bv.flip();                         // [1, 1, 1, 1, 1]
</code></pre>
<p class="normal">These examples are very similar to the examples where <code class="inlineCode">std::bitset</code> was used. This <code class="inlineCode">bitvector</code> class has an API compatible with <code class="inlineCode">std::bitset</code> but is useful for handling bit sequences of variable sizes.</p>
<h2 class="heading-2" id="_idParaDest-276">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using vector as a default container</em>, to learn how to use the <code class="inlineCode">std::vector</code> standard container</li>
<li class="bulletList"><em class="italic">Using bitset for fixed-size sequences of bits</em>, to learn about the standard container for handling bit sequences of fixed sizes</li>
<li class="bulletList"><em class="italic">Using the bit manipulation utilities</em>, to explore the C++20 set of utility functions for bit manipulation from the numeric library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-277">Using the bit manipulation utilities</h1>
<p class="normal">In the <a id="_idIndexMarker592"/>previous recipes, we have seen how to use <code class="inlineCode">std::bitset</code> and <code class="inlineCode">std::vector&lt;bool&gt;</code> to work with fixed and variable sequences of bits. There are, however, situations when we need to manipulate or process individual or multiple bits of an unsigned integral value. This includes operations such as counting or rotating bits. The C++20 standard provides a set of utility functions for bit manipulation as part of the numeric library. In this recipe, we will learn what they are and how to use these utilities.</p>
<h2 class="heading-2" id="_idParaDest-278">Getting ready</h2>
<p class="normal">The function templates discussed in this recipe are all available in the <code class="inlineCode">std</code> namespace in the new C++20 header <code class="inlineCode">&lt;bit&gt;</code>.</p>
<h2 class="heading-2" id="_idParaDest-279">How to do it…</h2>
<p class="normal">Use the following function templates to manipulate bits of unsigned integral types:</p>
<ul>
<li class="bulletList">If you need to perform a circular shift, use <code class="inlineCode">std::rotl&lt;T&gt;()</code> for left rotation and <code class="inlineCode">std::rotr&lt;T&gt;()</code> for right rotation:
        <pre class="programlisting code"><code class="hljs-code">unsigned char n = 0b00111100;
auto vl1 = std::rotl(n, 0); // 0b00111100
auto vl2 = std::rotl(n, 1); // 0b01111000
auto vl3 = std::rotl(n, 3); // 0b11100001
auto vl4 = std::rotl(n, 9); // 0b01111000
auto vl5 = std::rotl(n, -2);// 0b00001111
auto vr1 = std::rotr(n, 0);  // 0b00111100
auto vr2 = std::rotr(n, 1);  // 0b00011110
auto vr3 = std::rotr(n, 3);  // 0b10000111
auto vr4 = std::rotr(n, 9);  // 0b00011110
auto vr5 = std::rotr(n, -2); // 0b11110000
</code></pre>
</li>
<li class="bulletList">If you need to count the number of consecutive <code class="inlineCode">0</code> bits (that is, until a <code class="inlineCode">1</code> is found), use <code class="inlineCode">std::countl_zero&lt;T&gt;()</code> to count from left to right (that is, starting with the most significant bit) and <code class="inlineCode">std::countr_zero&lt;T&gt;()</code> to count from right to left (that is, starting with the least significant bit):
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::countl_zero(0b00000000u) &lt;&lt; '\n'; // 8
std::cout &lt;&lt; std::countl_zero(0b11111111u) &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::countl_zero(0b00111010u) &lt;&lt; '\n'; // 2
std::cout &lt;&lt; std::countr_zero(0b00000000u) &lt;&lt; '\n'; // 8
std::cout &lt;&lt; std::countr_zero(0b11111111u) &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::countr_zero(0b00111010u) &lt;&lt; '\n'; // 1
</code></pre>
</li>
<li class="bulletList">If you need to count the number of consecutive <code class="inlineCode">1</code> bits (that is, until a <code class="inlineCode">0</code> is found), use <code class="inlineCode">std::countl_one&lt;T&gt;()</code> to count from left to right (that is, starting with the most significant bit) and <code class="inlineCode">std::countr_one&lt;T&gt;()</code> to count from right to left (that is, starting with the least significant bit):
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::countl_one(0b00000000u) &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::countl_one(0b11111111u) &lt;&lt; '\n'; // 8
std::cout &lt;&lt; std::countl_one(0b11000101u) &lt;&lt; '\n'; // 2
std::cout &lt;&lt; std::countr_one(0b00000000u) &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::countr_one(0b11111111u) &lt;&lt; '\n'; // 8
std::cout &lt;&lt; std::countr_one(0b11000101u) &lt;&lt; '\n'; // 1
</code></pre>
</li>
<li class="bulletList">If <a id="_idIndexMarker593"/>you need to count the number of <code class="inlineCode">1</code> bits, use <code class="inlineCode">std::popcount&lt;T&gt;()</code>. The number of <code class="inlineCode">0</code> bits is the number of digits used to represent the value (this can be determined with <code class="inlineCode">std::numeric_limits&lt;T&gt;::digits</code>), minus the count of <code class="inlineCode">1</code> bits:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::popcount(0b00000000u) &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::popcount(0b11111111u) &lt;&lt; '\n'; // 8
std::cout &lt;&lt; std::popcount(0b10000001u) &lt;&lt; '\n'; // 2
</code></pre>
</li>
<li class="bulletList">If you need to check whether a number is a power of two, use <code class="inlineCode">std::has_single_bit&lt;T&gt;()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::boolalpha &lt;&lt; std::has_single_bit(0u) &lt;&lt; '\n'; // false
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::has_single_bit(1u) &lt;&lt; '\n'; // true
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::has_single_bit(2u) &lt;&lt; '\n'; // true
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::has_single_bit(3u) &lt;&lt; '\n'; // false
std::cout &lt;&lt; std::boolalpha &lt;&lt; std::has_single_bit(4u) &lt;&lt; '\n'; // true
</code></pre>
</li>
<li class="bulletList">If you need to find the smallest power of two that is greater than or equal to a given number, use <code class="inlineCode">std::bit_ceil&lt;T&gt;()</code>. On the other hand, if you need to find the largest power of two that is smaller than or equal to a given number, use <code class="inlineCode">std::bit_floor&lt;T&gt;()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::bit_ceil(0u)  &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::bit_ceil(3u)  &lt;&lt; '\n'; // 4
std::cout &lt;&lt; std::bit_ceil(4u)  &lt;&lt; '\n'; // 4
std::cout &lt;&lt; std::bit_ceil(31u) &lt;&lt; '\n'; // 32
std::cout &lt;&lt; std::bit_ceil(42u) &lt;&lt; '\n'; // 64
std::cout &lt;&lt; std::bit_floor(0u)  &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::bit_floor(3u)  &lt;&lt; '\n'; // 2
std::cout &lt;&lt; std::bit_floor(4u)  &lt;&lt; '\n'; // 4
std::cout &lt;&lt; std::bit_floor(31u) &lt;&lt; '\n'; // 16
std::cout &lt;&lt; std::bit_floor(42u) &lt;&lt; '\n'; // 32
</code></pre>
</li>
<li class="bulletList">If you <a id="_idIndexMarker594"/>need to determine the smallest number of digits to represent a number, use <code class="inlineCode">std::bit_width&lt;T&gt;()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::bit_width(0u)    &lt;&lt; '\n'; // 0
std::cout &lt;&lt; std::bit_width(2u)    &lt;&lt; '\n'; // 2
std::cout &lt;&lt; std::bit_width(15u)   &lt;&lt; '\n'; // 4
std::cout &lt;&lt; std::bit_width(16u)   &lt;&lt; '\n'; // 5
std::cout &lt;&lt; std::bit_width(1000u) &lt;&lt; '\n'; // 10
</code></pre>
</li>
<li class="bulletList">If you need to reinterpret the object representation of a type <code class="inlineCode">F</code> as that of a type <code class="inlineCode">T</code>, then use <code class="inlineCode">std::bit_cast&lt;T, F&gt;()</code>:
        <pre class="programlisting code"><code class="hljs-code">const double   pi   = 3.1415927;
const uint64_t bits = std::bit_cast&lt;uint64_t&gt;(pi);
const double   pi2  = std::bit_cast&lt;double&gt;(bits);
std::cout
   &lt;&lt; std::fixed &lt;&lt; pi   &lt;&lt; '\n' // 3.1415923
   &lt;&lt; std::hex   &lt;&lt; bits &lt;&lt; '\n' // 400921fb5a7ed197
   &lt;&lt; std::fixed &lt;&lt; pi2  &lt;&lt; '\n';  // 3.1415923
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-280">How it works…</h2>
<p class="normal">All the function templates mentioned in the previous section, with the exception of <code class="inlineCode">std::bit_cast&lt;T, F&gt;()</code> are only available for unsigned integral types. That includes the types <code class="inlineCode">unsigned char</code>, <code class="inlineCode">unsigned short</code>, <code class="inlineCode">unsigned int</code>, <code class="inlineCode">unsigned long</code>, and <code class="inlineCode">unsigned long long</code>, as well as the fixed width unsigned integer types (such as <code class="inlineCode">uint8_t</code>, <code class="inlineCode">uint64_t</code>, <code class="inlineCode">uint_least8_t</code>, <code class="inlineCode">uintmax_t</code>, and so on). These functions are simple and should not require a detailed description.</p>
<p class="normal">The<a id="_idIndexMarker595"/> function that is different from the rest is <code class="inlineCode">std::bit_cast&lt;T, F&gt;()</code>. Here, <code class="inlineCode">F</code> is the type that is reinterpreted, and <code class="inlineCode">T</code> is the type that we interpret to. This function template does not require <code class="inlineCode">T</code> and <code class="inlineCode">F</code> to be unsigned integral types, but both of them must be trivially copyable. Moreover, the <code class="inlineCode">sizeof(T)</code> must be the same as the <code class="inlineCode">sizeof(F)</code>.</p>
<p class="normal">The specification for this function does not mention the value of padding bits in the result. On the other hand, if the result value does not correspond to a valid value of the type <code class="inlineCode">T</code>, then the behavior is undefined.</p>
<p class="normal"><code class="inlineCode">std::bit_cast&lt;T, F&gt;()</code> can be <code class="inlineCode">constexpr</code> if <code class="inlineCode">T</code>, <code class="inlineCode">F</code>, and the types of all their sub-objects are not a union type, a pointer type, a pointer to member type, or a volatile-qualified type, and have no non-static data members of a reference type.</p>
<h2 class="heading-2" id="_idParaDest-281">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using bitset for fixed-size sequences of bits</em>, to learn about the standard container for handling bit sequences of fixed sizes</li>
<li class="bulletList"><em class="italic">Using vector&lt;bool&gt; for variable-size sequences of bits</em>, to learn about the specialization of <code class="inlineCode">std::vector</code> for the <code class="inlineCode">bool</code> type intended for handling bit sequences of variable sizes</li>
</ul>
<h1 class="heading-1" id="_idParaDest-282">Finding elements in a range</h1>
<p class="normal">One <a id="_idIndexMarker596"/>of the most common operations we do in any application is searching through data. Therefore, it is not surprising that the standard library <a id="_idIndexMarker597"/>provides many generic algorithms for searching through standard containers, or anything that can represent a range and is defined by a start and a past-the-end iterator. In this recipe, we will see what these standard algorithms are and how they can be used.</p>
<h2 class="heading-2" id="_idParaDest-283">Getting ready</h2>
<p class="normal">For all the examples in this recipe, we will use <code class="inlineCode">std::vector</code>, but all the algorithms work with ranges defined by a begin and past-the-end, either input or forward iterators, depending on the algorithm (for more information about the various types of iterators, see the <em class="italic">Writing your own random access iterator</em> recipe, later in this chapter). All these algorithms are available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;algorithm&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-284">How to do it...</h2>
<p class="normal">The <a id="_idIndexMarker598"/>following is a list of algorithms that can be used for finding<a id="_idIndexMarker599"/> elements in a range:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">std::find()</code> to find a value in a range; this algorithm returns an iterator to the first element equal to the value:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 13, 1, 5, 3, 2, 8, 1 };
auto it = std::find(v.cbegin(), v.cend(), 3);
if (it != v.cend()) std::cout &lt;&lt; *it &lt;&lt; '\n'; // prints 3
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::find_if()</code> to find a value in a range that meets a criterion from a unary predicate; this algorithm returns an iterator to the first element for which the predicate returns <code class="inlineCode">true</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 13, 1, 5, 3, 2, 8, 1 };
auto it = std::find_if(v.cbegin(), v.cend(),
                       [](int const n) {return n &gt; 10; });
if (it != v.cend()) std::cout &lt;&lt; *it &lt;&lt; '\n'; // prints 13
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::find_if_not()</code> to find a value in a range that does not meet a criterion from a unary predicate; this algorithm returns an iterator to the first element for which the predicate returns <code class="inlineCode">false</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 13, 1, 5, 3, 2, 8, 1 };
auto it = std::find_if_not(v.cbegin(), v.cend(),
                    [](int const n) {return n % 2 == 1; });
if (it != v.cend()) std::cout &lt;&lt; *it &lt;&lt; '\n'; // prints 2
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::find_first_of()</code> to search for the occurrence of any value from a range in another range; this algorithm returns an iterator to the first element that is found:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 13, 1, 5, 3, 2, 8, 1 };
std::vector&lt;int&gt; p{ 5, 7, 11 };
auto it = std::find_first_of(v.cbegin(), v.cend(),
                             p.cbegin(), p.cend());
if (it != v.cend())
  std::cout &lt;&lt; "found " &lt;&lt; *it
            &lt;&lt; " at index " &lt;&lt; std::distance(v.cbegin(), it)
            &lt;&lt; '\n'; 
// found 5 at index 2
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::find_end()</code> to find the last occurrence of a subrange of elements in a <a id="_idIndexMarker600"/>range; this algorithm returns an iterator<a id="_idIndexMarker601"/> to the first element of the last subrange in the range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v1{ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1 };
std::vector&lt;int&gt; v2{ 1, 0, 1 };
auto it = std::find_end(v1.cbegin(), v1.cend(),
                        v2.cbegin(), v2.cend());
if (it != v1.cend())
  std::cout &lt;&lt; "found at index "
            &lt;&lt; std::distance(v1.cbegin(), it) &lt;&lt; '\n';
// found at index 8
</code></pre>
</li>
<li class="bulletList">To find the minimum and the maximum elements in a range, use <code class="inlineCode">std::min_element()</code> for the minimum, <code class="inlineCode">std::max_element()</code> for the maximum, and <code class="inlineCode">std::minmax_element()</code> for both the minimum and the maximum:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 5, -2, 9, 6 };
auto minit = std::min_element(v.begin(), v.end());
std::cout &lt;&lt; "min=" &lt;&lt; *minit &lt;&lt; '\n';           // min=-2
auto maxit = std::max_element(v.begin(), v.end());
std::cout &lt;&lt; "max=" &lt;&lt; *maxit &lt;&lt; '\n';           // max=9
auto minmaxit = std::minmax_element(v.begin(), v.end());
std::cout &lt;&lt; "min=" &lt;&lt; *minmaxit.first &lt;&lt; '\n';  // min=-2
std::cout &lt;&lt; "max=" &lt;&lt; *minmaxit.second &lt;&lt; '\n'; // max=9
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::search()</code> to search for the first occurrence of a subrange in a range; this algorithm returns an iterator to the first element of the subrange in the range:
        <pre class="programlisting code"><code class="hljs-code">auto text = "The quick brown fox jumps over the lazy dog"s;
auto word = "over"s;
auto it = std::search(text.cbegin(), text.cend(),
                      word.cbegin(), word.cend());
if (it != text.cend())
  std::cout &lt;&lt; "found " &lt;&lt; word
            &lt;&lt; " at index "
            &lt;&lt; std::distance(text.cbegin(), it) &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::search()</code> with a <em class="italic">searcher</em>, which is a class that implements a searching <a id="_idIndexMarker602"/>algorithm and meets some predefined <a id="_idIndexMarker603"/>criteria. This overload of <code class="inlineCode">std::search()</code> was introduced in C++17, and available standard searchers implement the <em class="italic">Boyer-Moore</em> and <em class="italic">Boyer-Moore-Horspool</em> string searching algorithms:
        <pre class="programlisting code"><code class="hljs-code">auto text = "The quick brown fox jumps over the lazy dog"s;
auto word = "over"s;
auto it = std::search(
  text.cbegin(), text.cend(),
  std::make_boyer_moore_searcher(word.cbegin(), word.cend()));
if (it != text.cend())
  std::cout &lt;&lt; "found " &lt;&lt; word
            &lt;&lt; " at index "
            &lt;&lt; std::distance(text.cbegin(), it) &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::search_n()</code> to search for <em class="italic">N</em> consecutive occurrences of a value in a range; this algorithm returns an iterator to the first element of the found sequence in the range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1 };
auto it = std::search_n(v.cbegin(), v.cend(), 2, 0);
if (it != v.cend())
  std::cout &lt;&lt; "found at index "
            &lt;&lt; std::distance(v.cbegin(), it) &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::adjacent_find()</code> to find two adjacent elements in a range that are <a id="_idIndexMarker604"/>equal or satisfy a binary predicate; this algorithm<a id="_idIndexMarker605"/> returns an iterator to the first element that is found:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto it = std::adjacent_find(v.cbegin(), v.cend());
if (it != v.cend())
  std::cout &lt;&lt; "found at index "
            &lt;&lt; std::distance(v.cbegin(), it) &lt;&lt; '\n';
auto it = std::adjacent_find(
  v.cbegin(), v.cend(),
  [](int const a, int const b) {
    return IsPrime(a) &amp;&amp; IsPrime(b); });
if (it != v.cend())
  std::cout &lt;&lt; "found at index "
            &lt;&lt; std::distance(v.cbegin(), it) &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::binary_search()</code> to find whether an element exists in a sorted range; this algorithm returns a Boolean value to indicate whether the value was found or not:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto success = std::binary_search(v.cbegin(), v.cend(), 8);
if (success) std::cout &lt;&lt; "found" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::lower_bound()</code> to find the first element in a range not less than a specified value; this algorithm returns an iterator to the element:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto it = std::lower_bound(v.cbegin(), v.cend(), 1);
if (it != v.cend())
  std::cout &lt;&lt; "lower bound at "
            &lt;&lt; std::distance(v.cbegin(), it) &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::upper_bound()</code> to find the first element in a range greater than a specified value; this algorithm returns an iterator to the element:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto it = std::upper_bound(v.cbegin(), v.cend(), 1);
if (it != v.cend())
  std::cout &lt;&lt; "upper bound at "
            &lt;&lt; std::distance(v.cbegin(), it) &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::equal_range()</code> to find a subrange in a range whose values are equal to <a id="_idIndexMarker606"/>a specified value. This algorithm returns a pair of iterators defining the first and the one-past-end iterators to the subrange; these two iterators are equivalent to those returned by <code class="inlineCode">std::lower_bound()</code> and <code class="inlineCode">std::upper_bound()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto bounds = std::equal_range(v.cbegin(), v.cend(), 1);
std::cout &lt;&lt; "range between indexes "
          &lt;&lt; std::distance(v.cbegin(), bounds.first)
          &lt;&lt; " and "
          &lt;&lt; std::distance(v.cbegin(), bounds.second)
          &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-285">How it works...</h2>
<p class="normal">The <a id="_idIndexMarker607"/>way these algorithms work is very similar: they all take, as arguments, iterators that define the searchable range and additional arguments that depend on each algorithm. With the exception of <code class="inlineCode">std::binary_search()</code>, which returns a Boolean, and <code class="inlineCode">std::equal_range()</code>, which returns a pair of iterators, they all return an iterator to the searched element or to a subrange. These iterators must be compared with the end iterator (that is, the past-last-element) of the range to check whether the search was successful or not. If the search did not find an element or a subrange, then the returned value is the end iterator.</p>
<p class="normal">All these algorithms have multiple overloads, but in the <em class="italic">How to do it...</em> section, we only looked at one particular overload to show how the algorithm can be used. For a complete reference of all overloads, you should see other sources, such as <a href="https://en.cppreference.com/w/cpp/algorithm">https://en.cppreference.com/w/cpp/algorithm</a>.</p>
<p class="normal">In all the preceding examples, we used constant iterators, but all these algorithms work the same with mutable iterators and with reverse iterators. Because they take iterators as input arguments, they can work with standard containers, arrays, or anything that represents a sequence and has iterators available.</p>
<p class="normal">A <a id="_idIndexMarker608"/>special note on the <code class="inlineCode">std::binary_search()</code> algorithm is necessary: the iterator parameters that define the range to search in should at least meet the requirements of the forward iterators. Regardless of the type of the supplied iterators, the number of comparisons is always logarithmic on the size of the range. However, the number of iterator increments is different if the iterators are random access, in which case the number of increments is also logarithmic, or are not random access, in which case it is linear and proportional to the size of the range.</p>
<p class="normal">All these<a id="_idIndexMarker609"/> algorithms, except for <code class="inlineCode">std::find_if_not()</code>, were available before C++11. However, some overloads of them have been introduced in the newer standards. An example is <code class="inlineCode">std::search()</code>, which has several overloads that were introduced in C++17. One of these overloads has the following form:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class ForwardIterator, class Searcher&gt;
ForwardIterator search(ForwardIterator first, ForwardIterator last,
 const Searcher&amp; searcher );
</code></pre>
<p class="normal">This overload searches for the occurrence of a pattern defined by a searcher function object for which the standard provides several implementations:</p>
<ul>
<li class="bulletList"><code class="inlineCode">default_searcher</code> basically delegates the searching to the standard <code class="inlineCode">std::search()</code> algorithm.</li>
<li class="bulletList"><code class="inlineCode">boyer_moore_searcher</code> implements the Boyer-Moore algorithm for string searching.</li>
<li class="bulletList"><code class="inlineCode">boyer_moore_horspool_algorithm</code> implements the Boyer-Moore-Horspool algorithm for string searching.</li>
</ul>
<p class="normal">Many standard containers have a member function <code class="inlineCode">find()</code> for finding elements in the container. When such a method is available and suits your needs, it should be preferred to the general algorithms because these member functions are optimized based on the particularities of each container.</p>
<h2 class="heading-2" id="_idParaDest-286">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using vector as a default container</em>, to see how to use the <code class="inlineCode">std::vector</code> standard container</li>
<li class="bulletList"><em class="italic">Initializing a range</em>, to explore the standard algorithms for filling a range with values</li>
<li class="bulletList"><em class="italic">Using set operations on a range</em>, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</li>
<li class="bulletList"><em class="italic">Sorting a range</em>, to learn about the standard algorithms for sorting ranges</li>
</ul>
<h1 class="heading-1" id="_idParaDest-287">Sorting a range</h1>
<p class="normal">In the <a id="_idIndexMarker610"/>previous recipe, we looked at the standard general algorithms for searching in a range. Another common operation we often need to do is sorting a range because many routines, including some of the algorithms for searching, require a sorted range. The standard library provides several general algorithms for sorting ranges, and in this recipe, we will see what these algorithms are and how they can be used.</p>
<h2 class="heading-2" id="_idParaDest-288">Getting ready</h2>
<p class="normal">The sorting general algorithms work with ranges defined by a start and end iterator and, therefore, can sort standard containers, arrays, or anything that represents a sequence and has random iterators available. However, all the examples in this recipe will use <code class="inlineCode">std::vector</code>.</p>
<h2 class="heading-2" id="_idParaDest-289">How to do it...</h2>
<p class="normal">The following is a list of standard general algorithms for searching a range:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">std::sort()</code> for sorting a range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{3, 13, 5, 8, 1, 2, 1};
std::sort(v.begin(), v.end());
// v = {1, 1, 2, 3, 5, 8, 13}
std::sort(v.begin(), v.end(), std::greater&lt;&gt;());
// v = {13, 8, 5, 3, 2, 1, 1}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::stable_sort()</code> for sorting a range but keeping the order of the equal elements:
        <pre class="programlisting code"><code class="hljs-code">struct Task
{
  int priority;
  std::string name;
};
bool operator&lt;(Task const &amp; lhs, Task const &amp; rhs) {
  return lhs.priority &lt; rhs.priority;
}
bool operator&gt;(Task const &amp; lhs, Task const &amp; rhs) {
  return lhs.priority &gt; rhs.priority;
}
std::vector&lt;Task&gt; v{
  { 10, "Task 1"s }, { 40, "Task 2"s }, { 25, "Task 3"s },
  { 10, "Task 4"s }, { 80, "Task 5"s }, { 10, "Task 6"s },
};
std::stable_sort(v.begin(), v.end());
// {{ 10, "Task 1" },{ 10, "Task 4" },{ 10, "Task 6" },
//  { 25, "Task 3" },{ 40, "Task 2" },{ 80, "Task 5" }}
std::stable_sort(v.begin(), v.end(), std::greater&lt;&gt;());
// {{ 80, "Task 5" },{ 40, "Task 2" },{ 25, "Task 3" },
//  { 10, "Task 1" },{ 10, "Task 4" },{ 10, "Task 6" }}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::partial_sort()</code> for sorting a<a id="_idIndexMarker611"/> part of a range (and leaving the rest in an unspecified order):
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 3, 13, 5, 8, 1, 2, 1 };
std::partial_sort(v.begin(), v.begin() + 4, v.end());
// v = {1, 1, 2, 3, ?, ?, ?}
std::partial_sort(v.begin(), v.begin() + 4, v.end(),
                  std::greater&lt;&gt;());
// v = {13, 8, 5, 3, ?, ?, ?}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::partial_sort_copy()</code> for sorting a part of a range by copying the sorted elements to a second range and leaving the original range unchanged:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 3, 13, 5, 8, 1, 2, 1 };
std::vector&lt;int&gt; vc(v.size());
std::partial_sort_copy(v.begin(), v.end(), vc.begin(), vc.end());
// v = {3, 13, 5, 8, 1, 2, 1}
// vc = {1, 1, 2, 3, 5, 8, 13}
std::partial_sort_copy(v.begin(), v.end(),
                       vc.begin(), vc.end(),
                       std::greater&lt;&gt;());
// vc = {13, 8, 5, 3, 2, 1, 1}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::nth_element()</code> for sorting a range so that the <em class="italic">N</em>th element is the one that <a id="_idIndexMarker612"/>would be in that position if the range was completely sorted, and the elements before it are all smaller and the ones after it are all greater, without any guarantee that they are also ordered:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 3, 13, 5, 8, 1, 2, 1 };
std::nth_element(v.begin(), v.begin() + 3, v.end());
// v = {1, 1, 2, 3, 5, 8, 13}
std::nth_element(v.begin(), v.begin() + 3, v.end(), std::greater&lt;&gt;());
// v = {13, 8, 5, 3, 2, 1, 1}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::is_sorted()</code> to check whether a range is sorted:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v { 1, 1, 2, 3, 5, 8, 13 };
auto sorted = std::is_sorted(v.cbegin(), v.cend());
sorted = std::is_sorted(v.cbegin(), v.cend(), std::greater&lt;&gt;());
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::is_sorted_until()</code> to find a sorted subrange from the beginning of a range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 3, 13, 5, 8, 1, 2, 1 };
auto it = std::is_sorted_until(v.cbegin(), v.cend());
auto length = std::distance(v.cbegin(), it);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-290">How it works...</h2>
<p class="normal">All the preceding <a id="_idIndexMarker613"/>general algorithms take random iterators as arguments to define the range to be sorted. Some of them also take an output range. They all have overloads: one that requires a comparison function for sorting the elements and one that does not and uses <code class="inlineCode">operator&lt;</code> for comparing the elements.</p>
<p class="normal">These algorithms work in the following way:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::sort()</code> modifies the input range so that its elements are sorted according to the default or the specified comparison function; the actual algorithm for sorting is an implementation detail.</li>
<li class="bulletList"><code class="inlineCode">std::stable_sort()</code> is similar to <code class="inlineCode">std::sort()</code>, but it guarantees to preserve the original order of elements that are equal.</li>
<li class="bulletList"><code class="inlineCode">std::partial_sort()</code> takes three iterator arguments indicating the first, middle, and last element in a range, where middle can be any element, not just the one at the natural middle position. The result is a partially sorted range so that the first <em class="italic">middle</em> – <em class="italic">first</em> smallest elements from the original range, that is, [<em class="italic">first</em>, <em class="italic">last</em>), are found in the [<em class="italic">first</em>, <em class="italic">middle</em>) subrange and the rest of the elements are in an unspecified order in the [<em class="italic">middle</em>, <em class="italic">last</em>) subrange.</li>
<li class="bulletList"><code class="inlineCode">std::partial_sort_copy()</code> is not a variant of <code class="inlineCode">std::partial_sort()</code>, as the name may suggest, but of <code class="inlineCode">std::sort()</code>. It sorts a range without altering it by copying its elements to an output range. The arguments of the algorithm are the first and last iterators of the input and output ranges. If the output range has a size <em class="italic">M</em> that is greater than or equal to the size <em class="italic">N</em> of the input range, the input range is entirely sorted and copied to the output range; the first <em class="italic">N</em> elements of the output range are overwritten, and the last <em class="italic">M</em> – <em class="italic">N</em> elements are left untouched. If the output range is smaller than the input range, then only the first <em class="italic">M</em> sorted elements from the input range are copied to the output range (which is entirely overwritten in this case).</li>
<li class="bulletList"><code class="inlineCode">std::nth_element()</code> is basically an implementation of a selection algorithm, which is an algorithm for finding the <em class="italic">N</em>th smallest element of a range. This algorithm takes three iterator arguments representing the first, <em class="italic">N</em>th, and last element, and partially sorts the range so that, after sorting, the <em class="italic">N</em>th element is the one that would be in that position if the range had been entirely sorted. In the modified range, all the <em class="italic">N</em> – 1 elements before the <em class="italic">N</em>th one are smaller than it, and all the elements after the <em class="italic">N</em>th element are greater than it. However, there is no guarantee on the order of these other elements.</li>
<li class="bulletList"><code class="inlineCode">std::is_sorted()</code> checks whether the specified range is sorted according to the specified or default comparison function and returns a Boolean value to indicate that.</li>
<li class="bulletList"><code class="inlineCode">std::is_sorted_until()</code> finds a sorted subrange of the specified range, starting from the beginning, using either a provided comparison function or the default <code class="inlineCode">operator&lt;</code>. The returned value is an iterator representing the upper bound of the sorted subrange, which is also the iterator of the one-past-last sorted element.</li>
</ul>
<p class="normal">Some standard <a id="_idIndexMarker614"/>containers, <code class="inlineCode">std::list</code> and <code class="inlineCode">std::forward_list</code>, provide a member function, <code class="inlineCode">sort()</code>, which is optimized for those containers. These member functions should be preferred over the general standard algorithm, <code class="inlineCode">std::sort()</code>.</p>
<h2 class="heading-2" id="_idParaDest-291">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using vector as a default container</em>, to learn how to use the <code class="inlineCode">std::vector</code> standard container.</li>
<li class="bulletList"><em class="italic">Initializing a range</em> to explore the standard algorithms for filling a range with values</li>
<li class="bulletList"><em class="italic">Using set operations on a range</em>, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</li>
<li class="bulletList"><em class="italic">Finding elements in a range</em>, to learn about the standard algorithms for searching through sequences of values</li>
</ul>
<h1 class="heading-1" id="_idParaDest-292">Initializing a range</h1>
<p class="normal">In the <a id="_idIndexMarker615"/>previous recipes, we explored the general standard algorithms for searching in a range and sorting a range. The algorithms library provides many other general algorithms, and among them are several that are intended for filling a range with values. In this recipe, you will learn what these algorithms are and how they should be used.</p>
<h2 class="heading-2" id="_idParaDest-293">Getting ready</h2>
<p class="normal">All the examples <a id="_idIndexMarker616"/>in this recipe use <code class="inlineCode">std::vector</code>. However, like all the general algorithms, the ones we will see in this recipe take iterators to define the bounds of a range and can therefore be used with any standard container, arrays, or custom types representing a sequence that have forward iterators defined.</p>
<p class="normal">Except for <code class="inlineCode">std::iota()</code>, which is available in the <code class="inlineCode">&lt;numeric&gt;</code> header, all the other algorithms are found in the <code class="inlineCode">&lt;algorithm&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-294">How to do it...</h2>
<p class="normal">To assign values to a range, use any of the following standard algorithms:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::fill()</code> to assign a value to all the elements of a range; the range is defined by a first and last forward iterator:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(5);
std::fill(v.begin(), v.end(), 42);
// v = {42, 42, 42, 42, 42}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::fill_n()</code> to assign values to a number of elements of a range; the range is defined by a first forward iterator and a counter that indicates how many elements should be assigned the specified value:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(10);
std::fill_n(v.begin(), 5, 42);
// v = {42, 42, 42, 42, 42, 0, 0, 0, 0, 0}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::generate()</code> to assign the value returned by a function to the elements of a range; the range is defined by a first and last forward iterator, and the function is invoked once for each element in the range:
        <pre class="programlisting code"><code class="hljs-code">std::random_device rd{};
std::mt19937 mt{ rd() };
std::uniform_int_distribution&lt;&gt; ud{1, 10};
std::vector&lt;int&gt; v(5);
std::generate(v.begin(), v.end(),
              [&amp;ud, &amp;mt] {return ud(mt); });
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::generate_n()</code> to assign the value returned by a function to a number of elements of a range; the range is defined by a first forward iterator and a counter that indicates how many elements should be assigned the value from the function that is invoked once for each element:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(5);
auto i = 1;
std::generate_n(v.begin(), v.size(), [&amp;i] { return i*i++; });
// v = {1, 4, 9, 16, 25}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::iota()</code> to assign sequentially increasing values to the elements of a range; the range is defined by a first and last forward iterator, and the values are incremented using the prefix <code class="inlineCode">operator++</code> from an initial specified value:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(5);
std::iota(v.begin(), v.end(), 1);
// v = {1, 2, 3, 4, 5}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-295">How it works...</h2>
<p class="normal"><code class="inlineCode">std::fill()</code> and <code class="inlineCode">std::fill_n()</code> work similarly but differ in the way the range is specified: for<a id="_idIndexMarker617"/> the former by a first and last iterator, for the latter by a first iterator and a count. The second algorithm returns an iterator, representing either the one-past-last assigned element if the counter is greater than zero, or an iterator to the first element of the range otherwise.</p>
<p class="normal"><code class="inlineCode">std::generate()</code> and <code class="inlineCode">std::generate_n()</code> are also similar, differing only in the way the range is specified. The first takes two iterators, defining the range’s lower and upper bounds, while the second takes an iterator to the first element and a count. Like <code class="inlineCode">std::fill_n()</code>, <code class="inlineCode">std::generate_n()</code> also returns an iterator, representing either the one-past-last assigned element if the count is greater than zero, or an iterator to the first element of the range otherwise. These algorithms call a specified function for each element in the range and assign the returned value to the element. The generating function does not take any argument, so the value of the argument cannot be passed to the function. This is because it’s intended as a function to initialize the elements of a range. If you need to use the value of the elements to generate new values, you should use <code class="inlineCode">std::transform()</code>.</p>
<p class="normal"><code class="inlineCode">std::iota()</code> takes its name from the <code class="inlineCode">ι</code> (iota) function from the APL programming language, and though it was a part of the initial STL, it was only included in the standard library in C++11. This function takes a first and last iterator to a range, as well as an initial value that is assigned to the first element of the range. These are then used to generate sequentially increasing values using the prefix <code class="inlineCode">operator++</code> for the rest of the elements in the range.</p>
<div><p class="normal"><strong class="keyWord">STL</strong> stands for the <strong class="keyWord">Standard Template Library</strong>. It is a software library designed by Alexander Stepanov initially for C++ before the standardization of the C++ language. It was later used to model the C++ standard library, providing containers, iterators, algorithms, and functions. It should not be confused with the C++ standard library, as these two are distinct entities.</p>
</div>
<h2 class="heading-2" id="_idParaDest-296">There’s more…</h2>
<p class="normal">The <a id="_idIndexMarker618"/>examples we saw in this recipe used integers so they would be easy to follow. However, we can also provide a real-life example to help you better understand how these algorithms can be used for more complex scenarios.</p>
<p class="normal">Let’s consider a function that given two colors generates a series of intermediary points, representing a gradient. A color object has three values, one for the red, green, and blue channels. We can model it as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct color
{
   unsigned char red   = 0;
   unsigned char blue  = 0;
   unsigned char green = 0;
};
</code></pre>
<p class="normal">We will write a function that takes the start and end color, as well as the number of points to generate, and returns a vector of <code class="inlineCode">color</code> objects. Internally, this uses <code class="inlineCode">std::generate_n()</code> to generate the values:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;color&gt; make_gradient(color const&amp; c1, color const&amp; c2, size_t points)
{
   std::vector&lt;color&gt; colors(points);
   auto rstep = static_cast&lt;double&gt;(c2.red - c1.red) / points;
   auto gstep = static_cast&lt;double&gt;(c2.green - c1.green) / points;
   auto bstep = static_cast&lt;double&gt;(c2.blue - c1.blue) / points;
   auto r = c1.red;
   auto g = c1.green;
   auto b = c1.blue;
   std::generate_n(colors.begin(), 
                   points, 
                   [&amp;r, &amp;g, &amp;b, rstep, gstep, bstep] {
      color c {
         static_cast&lt;unsigned char&gt;(r),
         static_cast&lt;unsigned char&gt;(g),
         static_cast&lt;unsigned char&gt;(b) 
      };
      r += rstep;
      g += gstep;
      b += bstep;
      return c;
   });
   return colors;
}
</code></pre>
<p class="normal">We can use this function as follows:</p>
<pre class="programlisting code"><code class="hljs-code">color white { 255, 255, 255 };
color black { 0, 0, 0 };
std::vector&lt;color&gt; grayscale = make_gradient(white, black, 256);
std::for_each(
   grayscale.begin(), grayscale.end(),
   [](color const&amp; c) {
      std::cout &lt;&lt; 
         static_cast&lt;int&gt;(c.red) &lt;&lt; ", "
         &lt;&lt; static_cast&lt;int&gt;(c.green) &lt;&lt; ", "
         &lt;&lt; static_cast&lt;int&gt;(c.blue) &lt;&lt; '\n';
   });
</code></pre>
<p class="normal">Although<a id="_idIndexMarker619"/> the output of running this snippet has 256 lines (one for each point), we can show an excerpt of it:</p>
<pre class="programlisting con"><code class="hljs-con">255, 255, 255
254, 254, 254
253, 253, 253
…
1, 1, 1
0, 0, 0
</code></pre>
<h2 class="heading-2" id="_idParaDest-297">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Sorting a range</em>, to learn about the standard algorithms for sorting ranges</li>
<li class="bulletList"><em class="italic">Using set operations on a range</em>, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</li>
<li class="bulletList"><em class="italic">Finding elements in a range</em>, to learn about the standard algorithms for searching through sequences of values</li>
<li class="bulletList"><em class="chapterRef">Chapter 2</em>, <em class="italic">Generating pseudo-random numbers</em>, to understand the proper ways for generating pseudo-random numbers in C++</li>
<li class="bulletList"><em class="chapterRef">Chapter 2</em>, <em class="italic">Initializing all bits of internal state of a pseudo-random number generator</em>, to learn how to properly initialize random number engines</li>
</ul>
<h1 class="heading-1" id="_idParaDest-298">Using set operations on a range</h1>
<p class="normal">The<a id="_idIndexMarker620"/> standard library provides several algorithms for set operations that enable us to do unions, intersections, or differences of sorted ranges. In this recipe, we will see what these algorithms are and how they work.</p>
<h2 class="heading-2" id="_idParaDest-299">Getting ready</h2>
<p class="normal">The <a id="_idIndexMarker621"/>algorithms for set operations work with iterators, which means they can be used for standard containers, arrays, or any custom type representing a sequence that has input iterators available. All the examples in this recipe will use <code class="inlineCode">std::vector</code>.</p>
<p class="normal">For all the examples in the next section, we will use the following ranges:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 4, 5 };
std::vector&lt;int&gt; v2{ 2, 3, 3, 4, 6, 8 };
std::vector&lt;int&gt; v3;
</code></pre>
<p class="normal">In the following section, we will explore the use of the standard algorithm for set operations.</p>
<h2 class="heading-2" id="_idParaDest-300">How to do it...</h2>
<p class="normal">Use <a id="_idIndexMarker622"/>the <a id="_idIndexMarker623"/>following general algorithms for set operations:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::set_union()</code> to compute the union of two ranges into a third range:
        <pre class="programlisting code"><code class="hljs-code">std::set_union(v1.cbegin(), v1.cend(),
               v2.cbegin(), v2.cend(),
               std::back_inserter(v3));
// v3 = {1, 2, 3, 3, 4, 4, 5, 6, 8}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::merge()</code> to merge the content of two ranges into a third one; this is similar to <code class="inlineCode">std::set_union()</code> except that it copies the entire content of the input ranges into the output one, not just their union:
        <pre class="programlisting code"><code class="hljs-code">std::merge(v1.cbegin(), v1.cend(),
           v2.cbegin(), v2.cend(),
           std::back_inserter(v3));
// v3 = {1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 8}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::set_intersection()</code> to compute the intersection of the two ranges into a third range:
        <pre class="programlisting code"><code class="hljs-code">std::set_intersection(v1.cbegin(), v1.cend(),
                      v2.cbegin(), v2.cend(),
                      std::back_inserter(v3));
// v3 = {2, 3, 4}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::set_difference()</code> to compute the difference of two ranges into a third range; the output range will contain elements from the first range, which are not present in the second range:
        <pre class="programlisting code"><code class="hljs-code">std::set_difference(v1.cbegin(), v1.cend(),
                    v2.cbegin(), v2.cend(),
                    std::back_inserter(v3));
// v3 = {1, 4, 5}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::set_symmetric_difference()</code> to compute a dual difference of the two ranges into a third range; the output range will contain elements that are present<a id="_idIndexMarker624"/> in any of the input ranges, but only in one:
        <pre class="programlisting code"><code class="hljs-code">std::set_symmetric_difference(v1.cbegin(), v1.cend(),
                              v2.cbegin(), v2.cend(),
                              std::back_inserter(v3));
// v3 = {1, 3, 4, 5, 6, 8}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::includes()</code> to check if one range is a subset of another range (that is, all its <a id="_idIndexMarker625"/>elements are also present in the other range):
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 4, 5 };
std::vector&lt;int&gt; v2{ 2, 3, 3, 4, 6, 8 };
std::vector&lt;int&gt; v3{ 1, 2, 4 };
std::vector&lt;int&gt; v4{ };
auto i1 = std::includes(v1.cbegin(), v1.cend(),
                        v2.cbegin(), v2.cend()); // i1 = false
auto i2 = std::includes(v1.cbegin(), v1.cend(),
                        v3.cbegin(), v3.cend()); // i2 = true
auto i3 = std::includes(v1.cbegin(), v1.cend(),
                        v4.cbegin(), v4.cend()); // i3 = true
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-301">How it works...</h2>
<p class="normal">All the set operations that produce a new range from two input ranges have the same interface and work in a similar way:</p>
<ul>
<li class="bulletList">They take two input ranges, each defined by a first and last input iterator.</li>
<li class="bulletList">They take an output iterator to an output range where elements will be inserted.</li>
<li class="bulletList">They have an overload that takes an extra argument representing a comparison binary function object that must return <code class="inlineCode">true</code> if the first argument is less than the second. When a comparison function object is not specified, <code class="inlineCode">operator&lt;</code> is used.</li>
<li class="bulletList">They return an iterator past the end of the constructed output range.</li>
<li class="bulletList">The input ranges must be sorted using either <code class="inlineCode">operator&lt;</code> or the provided comparison function, depending on the overload that is used.</li>
<li class="bulletList">The output range must not overlap any of the two input ranges.</li>
</ul>
<p class="normal">We will <a id="_idIndexMarker626"/>demonstrate the way they work with additional <a id="_idIndexMarker627"/>examples using vectors of a POD type called <code class="inlineCode">Task</code> that we also used in a previous recipe:</p>
<pre class="programlisting code"><code class="hljs-code">struct Task
{
  int         priority;
  std::string name;
};
bool operator&lt;(Task const &amp; lhs, Task const &amp; rhs) {
  return lhs.priority &lt; rhs.priority;
}
bool operator&gt;(Task const &amp; lhs, Task const &amp; rhs) {
  return lhs.priority &gt; rhs.priority;
}
std::vector&lt;Task&gt; v1{
  { 10, "Task 1.1"s },
  { 20, "Task 1.2"s },
  { 20, "Task 1.3"s },
  { 20, "Task 1.4"s },
  { 30, "Task 1.5"s },
  { 50, "Task 1.6"s },
};
std::vector&lt;Task&gt; v2{
  { 20, "Task 2.1"s },
  { 30, "Task 2.2"s },
  { 30, "Task 2.3"s },
  { 30, "Task 2.4"s },
  { 40, "Task 2.5"s },
  { 50, "Task 2.6"s },
};
</code></pre>
<p class="normal">The particular way each algorithm produces the output range is described here:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::set_union()</code> copies all the elements present in one or both of the input ranges to the output range, producing a new sorted range. If an element is found <em class="italic">M</em> times in the first range and <em class="italic">N</em> times in the second range, then all the <em class="italic">M</em> elements from the first range will be copied to the output range in their existing order, and then the <em class="italic">N</em> – <em class="italic">M</em> elements from the second range are copied to the output range if <em class="italic">N</em> &gt; <em class="italic">M</em>, or <code class="inlineCode">0</code> elements otherwise:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;Task&gt; v3;
std::set_union(v1.cbegin(), v1.cend(),
               v2.cbegin(), v2.cend(),
               std::back_inserter(v3));
// v3 = {{10, "Task 1.1"},{20, "Task 1.2"},{20, "Task 1.3"},
//       {20, "Task 1.4"},{30, "Task 1.5"},{30, "Task 2.3"},
//       {30, "Task 2.4"},{40, "Task 2.5"},{50, "Task 1.6"}}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::merge()</code> copies all the elements from both the input ranges into the output<a id="_idIndexMarker628"/> range, producing a new range sorted<a id="_idIndexMarker629"/> with respect to the comparison function:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;Task&gt; v4;
std::merge(v1.cbegin(), v1.cend(),
           v2.cbegin(), v2.cend(),
           std::back_inserter(v4));
// v4 = {{10, "Task 1.1"},{20, "Task 1.2"},{20, "Task 1.3"},
//       {20, "Task 1.4"},{20, "Task 2.1"},{30, "Task 1.5"},
//       {30, "Task 2.2"},{30, "Task 2.3"},{30, "Task 2.4"},
//       {40, "Task 2.5"},{50, "Task 1.6"},{50, "Task 2.6"}}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::set_intersection()</code> copies all the elements that are found in both the input ranges into the output range, producing a new range sorted with respect to the comparison function:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;Task&gt; v5;
std::set_intersection(v1.cbegin(), v1.cend(),
                      v2.cbegin(), v2.cend(),
                      std::back_inserter(v5));
// v5 = {{20, "Task 1.2"},{30, "Task 1.5"},{50, "Task 1.6"}}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::set_difference()</code> copies to the output range all the elements from the first input range that are not found in the second input range. For equivalent elements that are found in both ranges, the following rule applies: if an element is found <em class="italic">M</em> times in the first range and <em class="italic">N</em> times in the second range, and if <em class="italic">M</em> &gt; <em class="italic">N</em>, then it is copied <em class="italic">M</em> – <em class="italic">N</em> times; otherwise, it is not copied:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;Task&gt; v6;
std::set_difference(v1.cbegin(), v1.cend(),
                    v2.cbegin(), v2.cend(),
                    std::back_inserter(v6));
// v6 = {{10, "Task 1.1"},{20, "Task 1.3"},{20, "Task 1.4"}}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::set_symmetric_difference()</code> copies to the output range all the elements that are found in either of the two input ranges but not in both of them. If an element is found <em class="italic">M</em> times in the first range and <em class="italic">N</em> times in the second range, then if <em class="italic">M</em> &gt; <em class="italic">N</em>, the last <em class="italic">M</em> – <em class="italic">N</em> of those elements from the first range are copied into the output range; otherwise, the last <em class="italic">N</em> – <em class="italic">M</em> of those elements from the second range will be copied into the output range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;Task&gt; v7;
std::set_symmetric_difference(v1.cbegin(), v1.cend(),
                              v2.cbegin(), v2.cend(),
                              std::back_inserter(v7));
// v7 = {{10, "Task 1.1"},{20, "Task 1.3"},{20, "Task 1.4"}
//       {30, "Task 2.3"},{30, "Task 2.4"},{40, "Task 2.5"}}
</code></pre>
</li>
</ul>
<p class="normal">On<a id="_idIndexMarker630"/> the <a id="_idIndexMarker631"/>other hand, <code class="inlineCode">std::includes()</code> does not produce an output range; it only checks whether the second range is included in the first range. It returns a Boolean value that is <code class="inlineCode">true</code> if the second range is empty or all its elements are included in the first range, or <code class="inlineCode">false</code> otherwise. It also has two overloads, one of which specifies a comparison binary function object.</p>
<h2 class="heading-2" id="_idParaDest-302">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using vector as a default container</em>, to learn how to use the <code class="inlineCode">std::vector</code> standard container</li>
<li class="bulletList"><em class="italic">Sorting a range</em> to learn about the standard algorithms for sorting ranges</li>
<li class="bulletList"><em class="italic">Using iterators to insert new elements in a container</em>, to learn how to use iterators and iterator adapters to add elements to a range</li>
<li class="bulletList"><em class="italic">Finding elements in a range</em>, to learn about the standard algorithms for searching through sequences of values</li>
</ul>
<h1 class="heading-1" id="_idParaDest-303">Using iterators to insert new elements into a container</h1>
<p class="normal">When <a id="_idIndexMarker632"/>you’re working with containers, it is often useful to insert new elements at the beginning, end, or somewhere in the middle. There are algorithms, such as the ones we saw in the previous recipe, <em class="italic">Using set operations on a range</em>, that require an iterator to a range to insert into, but if you simply pass an iterator, such as the one returned by <code class="inlineCode">begin()</code>, it will not insert but overwrite the elements of the container. Moreover, it’s not possible to insert at the end by using the iterator returned by <code class="inlineCode">end()</code>. In order to perform such operations, the standard library provides a set of iterators and iterator adapters that enable these scenarios.</p>
<h2 class="heading-2" id="_idParaDest-304">Getting ready</h2>
<p class="normal">The iterators and adapters discussed in this recipe are available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;iterator&gt;</code> header. If you include headers such as <code class="inlineCode">&lt;algorithm&gt;</code>, you do not have to explicitly include <code class="inlineCode">&lt;iterator&gt;</code>.</p>
<h2 class="heading-2" id="_idParaDest-305">How to do it...</h2>
<p class="normal">Use the following iterator adapters to insert new elements into a container:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::back_inserter()</code> to insert elements at the end for containers that have a <code class="inlineCode">push_back()</code> method:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };
std::fill_n(std::back_inserter(v), 3, 0);
// v={1,2,3,4,5,0,0,0}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::front_inserter()</code> to insert elements at the beginning for containers that have a <code class="inlineCode">push_front()</code> method:
        <pre class="programlisting code"><code class="hljs-code">std::list&lt;int&gt; l{ 1,2,3,4,5 };
std::fill_n(std::front_inserter(l), 3, 0);
// l={0,0,0,1,2,3,4,5}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::inserter()</code> to insert anywhere in a container, for containers that have an <code class="inlineCode">insert()</code> method:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };
std::fill_n(std::inserter(v, v.begin()), 3, 0);
// v={0,0,0,1,2,3,4,5}
std::list&lt;int&gt; l{ 1,2,3,4,5 };
auto it = l.begin();
std::advance(it, 3);
std::fill_n(std::inserter(l, it), 3, 0);
// l={1,2,3,0,0,0,4,5}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-306">How it works...</h2>
<p class="normal"><code class="inlineCode">std::back_inserter()</code>, <code class="inlineCode">std::front_inserter()</code>, and <code class="inlineCode">std::inserter()</code> are all helper functions<a id="_idIndexMarker633"/> that create iterator adapters of the types <code class="inlineCode">std::back_insert_iterator</code>, <code class="inlineCode">std::front_insert_iterator</code>, and <code class="inlineCode">std::insert_iterator</code>. These are all output iterators that append, prepend, or insert into the container for which they were constructed. Incrementing and dereferencing these iterators does not do anything. However, upon assignment, these iterators call the following methods from the container:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::back_insterter_iterator</code> calls <code class="inlineCode">push_back()</code></li>
<li class="bulletList"><code class="inlineCode">std::front_inserter_iterator</code> calls <code class="inlineCode">push_front()</code></li>
<li class="bulletList"><code class="inlineCode">std::insert_iterator</code> calls <code class="inlineCode">insert()</code></li>
</ul>
<p class="normal">The following is the oversimplified implementation of <code class="inlineCode">std::back_inserter_iterator</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class C&gt;
class back_insert_iterator {
public:
  typedef back_insert_iterator&lt;C&gt; T;
  typedef typename C::value_type V;
  explicit back_insert_iterator( C&amp; c ) :container( &amp;c ) { }
  T&amp; operator=( const V&amp; val ) {
    container-&gt;push_back( val );
    return *this;
  }
  T&amp; operator*() { return *this; }
  T&amp; operator++() { return *this; }
  T&amp; operator++( int ) { return *this; }
protected:
  C* container;
};
</code></pre>
<p class="normal">Because of the way the assignment operator works, these iterators can only be used with some standard containers:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::back_insert_iterator</code> can be used with <code class="inlineCode">std::vector</code>, <code class="inlineCode">std::list</code>, <code class="inlineCode">std::deque</code>, and <code class="inlineCode">std::basic_string</code>.</li>
<li class="bulletList"><code class="inlineCode">std::front_insert_iterator</code> can be used with <code class="inlineCode">std::list</code>, <code class="inlineCode">std::forward_list</code>, and <code class="inlineCode">std:deque</code>.</li>
<li class="bulletList"><code class="inlineCode">std::insert_iterator</code> can be used with all the standard containers.</li>
</ul>
<p class="normal">The following example inserts three elements with the value <code class="inlineCode">0</code> at the beginning of an <code class="inlineCode">std::vector</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };
std::fill_n(std::inserter(v, v.begin()), 3, 0);
// v={0,0,0,1,2,3,4,5}
</code></pre>
<p class="normal">The <code class="inlineCode">std::inserter()</code> adapter<a id="_idIndexMarker634"/> takes two arguments: the container and the iterator where an element is supposed to be inserted. Upon calling <code class="inlineCode">insert()</code> on the container, <code class="inlineCode">std::insert_iterator</code> increments the iterator, so upon being assigned again, it can insert a new element into the next position. Take a look at the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">T&amp; operator=(const V&amp; v)
{
  iter = container-&gt;insert(iter, v);
  ++iter;
  return (*this);
}
</code>
std::inserter_iterator</code> adapter. You can see that it first calls the <code class="inlineCode">insert()</code> member function of the container and then increments the returned iterator. Because all the standard containers have a method called <code class="inlineCode">insert()</code> with this signature, this adapter can be used with all these containers.</pre>
<h2 class="heading-2" id="_idParaDest-307">There’s more...</h2>
<p class="normal">These iterator adapters are intended to be used with algorithms or functions that insert multiple elements into a range. They can also be used, of course, to insert a single element, but that is rather an anti-pattern, since simply calling <code class="inlineCode">push_back()</code>, <code class="inlineCode">push_front()</code>, or <code class="inlineCode">insert()</code> is much simpler and intuitive in this case. Consider the following snippets:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };
*std::back_inserter(v) = 6; // v = {1,2,3,4,5,6}
std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt; it(v);
*it = 7;                    // v = {1,2,3,4,5,6,7}
</code></pre>
<p class="normal">The<a id="_idIndexMarker635"/> examples shown here, where adaptor iterators are used to insert a single element, should be avoided. They do not provide any benefit; they only make the code cluttered.</p>
<h2 class="heading-2" id="_idParaDest-308">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using set operations on a range</em>, to learn about the standard algorithms used to perform union, intersection, or difference of sorted ranges</li>
</ul>
<h1 class="heading-1" id="_idParaDest-309">Writing your own random-access iterator</h1>
<p class="normal">In the<a id="_idIndexMarker636"/> first chapter, we saw how we can enable range-based for loops for custom types by implementing iterators, as well as free <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions to return iterators to the first and one-past-the-last element of the custom range. You might have noticed that the minimal iterator implementation that we provided in that recipe does not meet the requirements for a standard iterator. This is because it cannot be copy constructible or assigned and cannot be incremented. In this recipe, we will build upon that example and show you how to create a random-access iterator that meets all requirements.</p>
<h2 class="heading-2" id="_idParaDest-310">Getting ready</h2>
<p class="normal">For this recipe, you should know the types of iterators the standard defines and how they are different. A good overview of their requirements is available at <a href="http://www.cplusplus.com/reference/iterator/">http://www.cplusplus.com/reference/iterator/</a>.</p>
<p class="normal">To exemplify how to write a random-access iterator, we will consider a variant of the <code class="inlineCode">dummy_array</code> class used in the <em class="italic">Enabling range-based for loops for custom types</em> recipe of <em class="chapterRef">Chapter 1</em>, <em class="italic">Learning Modern Core Language Features</em>. This is a very simple array concept with no practical value other than serving as a code base for demonstrating iterators:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename Type, size_t const SIZE&gt;
class dummy_array
{
  Type data[SIZE] = {};
public:
  Type&amp; operator[](size_t const index)
  {
    if (index &lt; SIZE) return data[index];
    throw std::out_of_range("index out of range");
  }
  Type const &amp; operator[](size_t const index) const
  {
    if (index &lt; SIZE) return data[index];
    throw std::out_of_range("index out of range");
  }
  size_t size() const { return SIZE; }
};
</code></pre>
<p class="normal">All the <a id="_idIndexMarker637"/>code shown in the next section, the iterator classes, typedefs, and the <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions, will be a part of this class.</p>
<p class="normal">Also, in this recipe, we will look at an example utilizing the following class called <code class="inlineCode">Tag</code>:</p>
<pre class="programlisting code"><code class="hljs-code">struct Tag
{
   int id;
   std::string name;
   Tag(int const id = 0, std::string const&amp; name = ""s) :
      id(id), name(name)
   {}
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-311">How to do it...</h2>
<p class="normal">To provide mutable and constant random-access iterators for the <code class="inlineCode">dummy_array</code> class shown in the previous section, add the following members to the class:</p>
<ul>
<li class="bulletList">An iterator class template, which is parameterized with the type of elements and the size of the array. The class must have the following public typedefs that define standard synonyms:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t const Size&gt;
class dummy_array_iterator
{
public:
  using self_type         = dummy_array_iterator;
  using value_type        = T;
  using reference         = T&amp;;
  using pointer           = T* ;
  using iterator_category = std::random_access_iterator_tag;
  using difference_type   = ptrdiff_t;
};
</code></pre>
</li>
<li class="bulletList">Private <a id="_idIndexMarker638"/>members for the iterator class—a pointer to the array data and a current index into the array:
        <pre class="programlisting code"><code class="hljs-code">private:
  pointer ptr = nullptr;
  size_t index = 0;
</code></pre>
</li>
<li class="bulletList">A private method for the iterator class to check whether two iterator instances point to the same array data:
        <pre class="programlisting code"><code class="hljs-code">private:
  bool compatible(self_type const &amp; other) const
 {
    return ptr == other.ptr;
  }
</code></pre>
</li>
<li class="bulletList">An explicit constructor for the iterator class:
        <pre class="programlisting code"><code class="hljs-code">public:
  explicit dummy_array_iterator(pointer ptr,
 size_t const index)
  : ptr(ptr), index(index) { }
</code></pre>
</li>
<li class="bulletList">Iterator class members to meet common requirements for all iterators—copy-constructible, copy-assignable, destructible, prefix, and postfix incrementable. In this implementation, the post-increment operator is implemented in terms of the pre-increment operator to avoid code duplication:
        <pre class="programlisting code"><code class="hljs-code">dummy_array_iterator(dummy_array_iterator const &amp; o)
    = default;
dummy_array_iterator&amp; operator=(dummy_array_iterator const &amp; o)
    = default;
~dummy_array_iterator() = default;
self_type &amp; operator++ ()
{
  if (index &gt;= Size)
    throw std::out_of_range("Iterator cannot be incremented 
                             past the end of range.");
  ++index;
  return *this;
}
self_type operator++ (int)
{
  self_type tmp = *this;
  ++*this;
  return tmp;
}
</code></pre>
</li>
<li class="bulletList">Iterator <a id="_idIndexMarker639"/>class members to meet input iterator requirements—test for equality/inequality, dereferenceable as <code class="inlineCode">rvalues</code>:
        <pre class="programlisting code"><code class="hljs-code">bool operator== (self_type const &amp; other) const
{
  assert(compatible(other));
  return index == other.index;
}
bool operator!= (self_type const &amp; other) const
{
  return !(*this == other);
}
reference operator* () const
{
  if (ptr == nullptr)
    throw std::bad_function_call();
  return *(ptr + index);
}
reference operator-&gt; () const
{
  if (ptr == nullptr)
    throw std::bad_function_call();
  return *(ptr + index);
}
</code></pre>
</li>
<li class="bulletList">Iterator<a id="_idIndexMarker640"/> class members to meet forward iterator requirements—default constructible:
        <pre class="programlisting code"><code class="hljs-code">dummy_array_iterator() = default;
</code></pre>
</li>
<li class="bulletList">Iterator class members to meet bidirectional iterator requirements—decrementable:
        <pre class="programlisting code"><code class="hljs-code">self_type &amp; operator--()
{
  if (index &lt;= 0)
    throw std::out_of_range("Iterator cannot be decremented
                             past the end of range.");
  --index;
  return *this;
}
self_type operator--(int)
{
  self_type tmp = *this;
  --*this;
  return tmp;
}
</code></pre>
</li>
<li class="bulletList">Iterator class members to meet random access iterator requirements—arithmetic add and subtract, comparable for inequality with other iterators, compound assignments, and offset dereferenceable:
        <pre class="programlisting code"><code class="hljs-code">self_type operator+(difference_type offset) const
{
  self_type tmp = *this;
  return tmp += offset;
}
self_type operator-(difference_type offset) const
{
  self_type tmp = *this;
  return tmp -= offset;
}
difference_type operator-(self_type const &amp; other) const
{
  assert(compatible(other));
  return (index - other.index);
}
bool operator&lt;(self_type const &amp; other) const
{
  assert(compatible(other));
  return index &lt; other.index;
}
bool operator&gt;(self_type const &amp; other) const
{
  return other &lt; *this;
}
bool operator&lt;=(self_type const &amp; other) const
{
  return !(other &lt; *this);
}
bool operator&gt;=(self_type const &amp; other) const
{
  return !(*this &lt; other);
}
self_type &amp; operator+=(difference_type const offset)
{
  if (index + offset &lt; 0 || index + offset &gt; Size)
    throw std::out_of_range("Iterator cannot be incremented 
                             past the end of range.");
  index += offset;
  return *this;
}
self_type &amp; operator-=(difference_type const offset)
{
  return *this += -offset;
}
value_type &amp; operator[](difference_type const offset)
{
  return (*(*this + offset));
}
value_type const &amp; operator[](difference_type const offset)
const
{
  return (*(*this + offset));
}
</code></pre>
</li>
<li class="bulletList">Add typedefs to the <code class="inlineCode">dummy_array</code> class for mutable and constant iterator synonyms:
        <pre class="programlisting code"><code class="hljs-code">public:
  using iterator = dummy_array_iterator&lt;Type, SIZE&gt;;
  using constant_iterator = dummy_array_iterator&lt;Type const, 
                                                 SIZE&gt;;
</code></pre>
</li>
<li class="bulletList">Add<a id="_idIndexMarker641"/> the public <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions to the <code class="inlineCode">dummy_array</code> class to return the iterators to the first and one-past-last elements in the array:
        <pre class="programlisting code"><code class="hljs-code">iterator begin()
{
  return iterator(data, 0);
}
iterator end()
{
  return iterator(data, SIZE);
}
constant_iterator begin() const
{
  return constant_iterator(data, 0);
}
constant_iterator end() const
{
  return constant_iterator(data, SIZE);
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-312">How it works...</h2>
<p class="normal">The<a id="_idIndexMarker642"/> standard library defines five categories of iterators:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Input iterators</strong>: These are <a id="_idIndexMarker643"/>the simplest category and guarantee validity only for single-pass sequential algorithms. After being incremented, the previous copies may become invalid.</li>
<li class="bulletList"><strong class="keyWord">Output iterators</strong>: These <a id="_idIndexMarker644"/>are basically input iterators that can be used to write to the pointed element.</li>
<li class="bulletList"><strong class="keyWord">Forward iterators</strong>: These <a id="_idIndexMarker645"/>can read (and write) data to the pointed element. They satisfy the requirements for input iterators and, in addition, must be default constructible and must support multi-pass scenarios without invalidating the previous copies.</li>
<li class="bulletList"><strong class="keyWord">Bidirectional iterators</strong>: These <a id="_idIndexMarker646"/>are forward iterators that, in addition, support decrementing so that they can move in both directions.</li>
<li class="bulletList"><strong class="keyWord">Random access iterators</strong>: These <a id="_idIndexMarker647"/>support access to any element in the container in constant time. They implement all the requirements for bidirectional iterators, and, in addition, support arithmetic operations <code class="inlineCode">+</code> and <code class="inlineCode">-</code>, compound assignments <code class="inlineCode">+=</code> and <code class="inlineCode">-=</code>, comparisons with other iterators with <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, <code class="inlineCode">&gt;=</code>, and the offset dereference operator.</li>
</ul>
<p class="normal">Forward, bidirectional, and random-access iterators that also implement the requirements of output iterators are called <em class="italic">mutable iterators</em>.</p>
<p class="normal">In the previous section, we saw how to implement random access iterators, with a step-by-step walkthrough of the requirements of each category of iterators (as each iterator category includes the requirements of the previous category and adds new requirements). The iterator class template is common for both constant and mutable iterators, and we have defined two synonyms for it called <code class="inlineCode">iterator</code> and <code class="inlineCode">constant_iterator</code>.</p>
<p class="normal">After implementing the inner iterator class template, we also defined the <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> member functions, which return an iterator to the first and the one-past-last element in the array, respectively. These methods have overloads to return mutable or constant iterators, depending on whether the <code class="inlineCode">dummy_array</code> class instance is mutable or constant.</p>
<p class="normal">With this <a id="_idIndexMarker648"/>implementation of the <code class="inlineCode">dummy_array</code> class and its iterators, we can write the following code:</p>
<pre class="programlisting code"><code class="hljs-code">// defining and initializing an array of integers
dummy_array&lt;int, 3&gt; a;
a[0] = 10;
a[1] = 20;
a[2] = 30;
// modifying the elements of the array
std::transform(a.begin(), a.end(), a.begin(),
               [](int const e) {return e * 2; });
// iterating through and printing the values of the array
for (auto&amp;&amp; e : a) std::cout &lt;&lt; e &lt;&lt; '\n';
</code></pre>
<pre class="programlisting con"><code class="hljs-con">20
40
60
</code></pre>
<pre class="programlisting code"><code class="hljs-code">auto lp = [](dummy_array&lt;int, 3&gt; const &amp; ca)
{
  for (auto const &amp; e : ca)
    std::cout &lt;&lt; e &lt;&lt; '\n';
};
lp(a);
</code></pre>
<pre class="programlisting con"><code class="hljs-con">20
40
60
</code></pre>
<pre class="programlisting code"><code class="hljs-code">// defining and initializing an array of smart pointers
dummy_array&lt;std::unique_ptr&lt;Tag&gt;, 3&gt; ta;
ta[0] = std::make_unique&lt;Tag&gt;(1, "Tag 1");
ta[1] = std::make_unique&lt;Tag&gt;(2, "Tag 2");
ta[2] = std::make_unique&lt;Tag&gt;(3, "Tag 3");
// iterating through and printing the pointed values
for (auto it = ta.begin(); it != ta.end(); ++it)
  std::cout &lt;&lt; it-&gt;id &lt;&lt; " " &lt;&lt; it-&gt;name &lt;&lt; '\n';
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 Tag 1
2 Tag 2
3 Tag 3
</code></pre>
<p class="normal">For more<a id="_idIndexMarker649"/> examples, check the source code that accompanies this book.</p>
<h2 class="heading-2" id="_idParaDest-313">There’s more...</h2>
<p class="normal">Apart from <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code>, a container may have additional methods such as <code class="inlineCode">cbegin()</code>/<code class="inlineCode">cend()</code> (for constant iterators), <code class="inlineCode">rbegin()</code>/<code class="inlineCode">rend()</code> (for mutable reverse iterators), and <code class="inlineCode">crbegin()</code>/ <code class="inlineCode">crend()</code> (for constant reverse iterators). Implementing this is left as an exercise for you.</p>
<p class="normal">On the other hand, in modern C++, these functions that return the first and last iterators do not have to be member functions but can be provided as non-member functions. In fact, this is the topic of the next recipe, <em class="italic">Container access with non-member functions</em>.</p>
<h2 class="heading-2" id="_idParaDest-314">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Enabling range-based for loops for custom types, </em>to learn to execute one or more statements for each element of a collection</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Creating type aliases and alias templates</em>, to learn about aliases for types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-315">Container access with non-member functions</h1>
<p class="normal">Standard containers provide the <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> member functions for retrieving iterators for<a id="_idIndexMarker650"/> the first and one-past-last elements of the container. There are actually four sets of these functions. Apart from <code class="inlineCode">begin()</code>/<code class="inlineCode">end()</code>, containers provide <code class="inlineCode">cbegin()</code>/<code class="inlineCode">cend()</code> to return constant iterators, <code class="inlineCode">rbegin()</code>/<code class="inlineCode">rend()</code> to return mutable reverse iterators, and <code class="inlineCode">crbegin()</code>/<code class="inlineCode">crend()</code> to return constant reverse iterators. In C++11/C++14, all these have non-member equivalents that work with standard containers, arrays, and any custom type that specializes them. In C++17, even more non-member functions have been added: <code class="inlineCode">std::data()</code>, which returns a pointer to the block of memory containing the elements of the container; <code class="inlineCode">std::size()</code>, which returns the size of a container or array; and <code class="inlineCode">std::empty()</code>, which returns whether the given container is empty. These non-member functions are intended for generic code but can be used anywhere in your code. Moreover, in C++20, the <code class="inlineCode">std::ssize()</code> non-member function was introduced to return the size of a container or array as a signed integer.</p>
<h2 class="heading-2" id="_idParaDest-316">Getting ready</h2>
<p class="normal">In this<a id="_idIndexMarker651"/> recipe, we will use the <code class="inlineCode">dummy_array</code> class and its iterators that we implemented in the previous recipe, <em class="italic">Writing your own random-access iterator</em>, as an example. You should read that recipe before continuing <a id="_idIndexMarker652"/>with this one.</p>
<p class="normal">Non-member <code class="inlineCode">begin()</code>/<code class="inlineCode">end()</code> functions and the other variants, as well as non-member <code class="inlineCode">data()</code>, <code class="inlineCode">size()</code>, and <code class="inlineCode">empty() </code>functions are available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;iterator&gt;</code> header, which is implicitly included with any of the following headers: <code class="inlineCode">&lt;array&gt;</code>, <code class="inlineCode">&lt;deque&gt;</code>, <code class="inlineCode">&lt;forward_list&gt;</code>, <code class="inlineCode">&lt;list&gt;</code>, <code class="inlineCode">&lt;map&gt;</code>, <code class="inlineCode">&lt;regex&gt;</code>, <code class="inlineCode">&lt;set&gt;</code>, <code class="inlineCode">&lt;string&gt;</code>, <code class="inlineCode">&lt;unordered_map&gt;</code>, <code class="inlineCode">&lt;unordered_set&gt;</code>, and <code class="inlineCode">&lt;vector&gt;</code>.</p>
<p class="normal">In this recipe, we will refer to the <code class="inlineCode">std::begin()</code>/<code class="inlineCode">std::end()</code> functions, but everything discussed also applies to the other functions: <code class="inlineCode">std::cbegin()</code>/<code class="inlineCode">std::cend()</code>, <code class="inlineCode">std::rbegin()</code>/<code class="inlineCode">std::rend()</code>, and <code class="inlineCode">std::crbegin()</code>/<code class="inlineCode">std::crend()</code>.</p>
<h2 class="heading-2" id="_idParaDest-317">How to do it...</h2>
<p class="normal">Use the non-member <code class="inlineCode">std::begin()</code>/<code class="inlineCode">std::end()</code> function and the other variants, as well as <code class="inlineCode">std::data()</code>, <code class="inlineCode">std::size()</code>, and <code class="inlineCode">std::empty()</code> with:</p>
<ul>
<li class="bulletList">Standard containers:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 5 };
auto sv1 = std::size(v1);  // sv1 = 5
auto ev1 = std::empty(v1); // ev1 = false
auto dv1 = std::data(v1);  // dv1 = v1.data()
for (auto i = std::begin(v1); i != std::end(v1); ++i)
  std::cout &lt;&lt; *i &lt;&lt; '\n';
std::vector&lt;int&gt; v2;
std::copy(std::cbegin(v1), std::cend(v1),
          std::back_inserter(v2));
</code></pre>
</li>
<li class="bulletList">Arrays:
        <pre class="programlisting code"><code class="hljs-code">int a[5] = { 1, 2, 3, 4, 5 };
auto pos = std::find_if(std::crbegin(a), std::crend(a),
                        [](int const n) {return n % 2 == 0; });
auto sa = std::size(a);  // sa = 5
auto ea = std::empty(a); // ea = false
auto da = std::data(a);  // da = a
</code></pre>
</li>
<li class="bulletList">Custom<a id="_idIndexMarker653"/> types that provide <a id="_idIndexMarker654"/>the corresponding member functions; that is, <code class="inlineCode">begin()</code>/<code class="inlineCode">end()</code>, <code class="inlineCode">data()</code>, <code class="inlineCode">empty()</code>, or <code class="inlineCode">size()</code>:
        <pre class="programlisting code"><code class="hljs-code">dummy_array&lt;std::string, 5&gt; sa;
dummy_array&lt;int, 5&gt; sb;
sa[0] = "1"s;
sa[1] = "2"s;
sa[2] = "3"s;
sa[3] = "4"s;
sa[4] = "5"s;
std::transform(
  std::begin(sa), std::end(sa),
  std::begin(sb),
  [](std::string const &amp; s) {return std::stoi(s); });
// sb = [1, 2, 3, 4, 5]
auto sa_size = std::size(sa); // sa_size = 5
</code></pre>
</li>
<li class="bulletList">Generic code where the type of the container is not known:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename C&gt;
void process(F&amp;&amp; f, C const &amp; c)
{
  std::for_each(std::begin(c), std::end(c),
                std::forward&lt;F&gt;(f));
}
auto l = [](auto const e) {std::cout &lt;&lt; e &lt;&lt; '\n'; };
process(l, v1); // std::vector&lt;int&gt;
process(l, a);  // int[5]
process(l, sa); // dummy_array&lt;std::string, 5&gt;
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-318">How it works...</h2>
<p class="normal">These<a id="_idIndexMarker655"/> non-member functions were introduced <a id="_idIndexMarker656"/>in different versions of the standard, but all of them were modified in C++17 to return <code class="inlineCode">constexpr auto</code>:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::begin()</code> and <code class="inlineCode">std::end()</code> in C++11</li>
<li class="bulletList"><code class="inlineCode">std::cbegin()</code>/<code class="inlineCode">std::cend()</code>, <code class="inlineCode">std::rbegin()</code>/<code class="inlineCode">std::rend()</code>, and <code class="inlineCode">std::crbegin()</code>/<code class="inlineCode">std::crend()</code> in C++14</li>
<li class="bulletList"><code class="inlineCode">std::data()</code>, <code class="inlineCode">std::size()</code>, and <code class="inlineCode">std::empty()</code> in C++17</li>
<li class="bulletList"><code class="inlineCode">std::ssize()</code> in C++20</li>
</ul>
<p class="normal">The <code class="inlineCode">begin()</code>/<code class="inlineCode">end()</code> family of functions have overloads for container classes and arrays, and all they do is the following:</p>
<ul>
<li class="bulletList">Return the results of calling the container-corresponding member function for containers</li>
<li class="bulletList">Return a pointer to the first or one-past-last element of the array for arrays</li>
</ul>
<p class="normal">The actual typical implementation for <code class="inlineCode">std::begin()</code>/<code class="inlineCode">std::end()</code> is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class C&gt;
constexpr auto inline begin(C&amp; c) -&gt; decltype(c.begin())
{
  return c.begin();
}
template&lt;class C&gt;
constexpr auto inline end(C&amp; c) -&gt; decltype(c.end())
{
  return c.end();
}
template&lt;class T, std::size_t N&gt;
constexpr T* inline begin(T (&amp;array)[N])
{
  return array;
}
template&lt;class T, std::size_t N&gt;
constexpr T* inline begin(T (&amp;array)[N])
{
  return array+N;
}
</code></pre>
<p class="normal">Custom specialization<a id="_idIndexMarker657"/> can be provided for<a id="_idIndexMarker658"/> containers that do not have corresponding <code class="inlineCode">begin()</code>/<code class="inlineCode">end()</code> members but can still be iterated. The standard library actually provides such specializations for <code class="inlineCode">std::initializer_list</code> and <code class="inlineCode">std::valarray</code>.</p>
<div><p class="normal">Specializations must be defined in the same namespace where the original class or function template has been defined. Therefore, if you want to specialize any of the <code class="inlineCode">std::begin()</code>/<code class="inlineCode">std::end()</code> pairs, you must do so in the <code class="inlineCode">std</code> namespace.</p>
</div>
<p class="normal">The other non-member functions for container access that were introduced in C++17 also have several overloads:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::data()</code> has several overloads; for a class <code class="inlineCode">C</code> it returns <code class="inlineCode">c.data()</code>, for arrays it returns the <code class="inlineCode">array</code>, and for <code class="inlineCode">std::initializer_list&lt;T&gt;</code> it returns the <code class="inlineCode">il.begin()</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class C&gt;
constexpr auto data(C&amp; c) -&gt; decltype(c.data())
{
  return c.data();
}
template &lt;class C&gt;
constexpr auto data(const C&amp; c) -&gt; decltype(c.data())
{
  return c.data();
}
template &lt;class T, std::size_t N&gt;
constexpr T* data(T (&amp;array)[N]) noexcept
{
  return array;
}
template &lt;class E&gt;
constexpr const E* data(std::initializer_list&lt;E&gt; il) noexcept
{
  return il.begin();
}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::size()</code> has two overloads; for a class <code class="inlineCode">C</code> it returns <code class="inlineCode">c.size()</code>, and for arrays it returns<a id="_idIndexMarker659"/> the size <code class="inlineCode">N</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class C&gt;
constexpr auto size(const C&amp; c) -&gt; decltype(c.size())
{
  return c.size();
}
template &lt;class T, std::size_t N&gt;
constexpr std::size_t size(const T (&amp;array)[N]) noexcept
{
  return N;
}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::empty()</code> has <a id="_idIndexMarker660"/>several overloads; for a class <code class="inlineCode">C</code> it returns <code class="inlineCode">c.empty()</code>, for arrays it returns <code class="inlineCode">false</code>, and for <code class="inlineCode">std::initializer_list&lt;T&gt;</code> it returns <code class="inlineCode">il.size() == 0</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class C&gt;
constexpr auto empty(const C&amp; c) -&gt; decltype(c.empty())
{
  return c.empty();
}
template &lt;class T, std::size_t N&gt;
constexpr bool empty(const T (&amp;array)[N]) noexcept
{
  return false;
}
template &lt;class E&gt;
constexpr bool empty(std::initializer_list&lt;E&gt; il) noexcept
{
  return il.size() == 0;
}
</code></pre>
</li>
</ul>
<p class="normal">In C++20, the <code class="inlineCode">std::ssize()</code> non-member function was added as a companion to <code class="inlineCode">std::size()</code> to return the number of elements in a given container or an array as a signed integer. <code class="inlineCode">std::size()</code> returns an unsigned integer, but there are scenarios where a signed value is desired. For instance, the C++20 class <code class="inlineCode">std::span</code>, which represents a view to a contiguous sequence of objects, has a <code class="inlineCode">size()</code> member function that returns a signed integer, unlike<a id="_idIndexMarker661"/> standard library containers where the <code class="inlineCode">size()</code> member function returns an unsigned integer.</p>
<p class="normal">The <a id="_idIndexMarker662"/>reason the function <code class="inlineCode">size()</code> of <code class="inlineCode">std::span</code> returns a signed integer is that the value -1 is supposed to represent a sentinel for types whose size was not known at compile time. Performing mixed signed and unsigned arithmetic can lead to errors in code that are hard to find. <code class="inlineCode">std::ssize()</code> has two overloads: for a class <code class="inlineCode">C</code> it returns <code class="inlineCode">c.size()</code> statically cast to a signed integer (typically <code class="inlineCode">std::ptrdiff_t</code>) and for arrays it returns <code class="inlineCode">N</code>, the number of elements. Take a look at the following code snippets:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class C&gt;
constexpr auto ssize(const C&amp; c)
    -&gt; std::common_type_t&lt;std::ptrdiff_t,
                          std::make_signed_t&lt;decltype(c.size())&gt;&gt;
{
    using R = std::common_type_t&lt;std::ptrdiff_t,
                      std::make_signed_t&lt;decltype(c.size())&gt;&gt;;
    return static_cast&lt;R&gt;(c.size());
}
template &lt;class T, std::ptrdiff_t N&gt;
constexpr std::ptrdiff_t ssize(const T (&amp;array)[N]) noexcept
{
    return N;
}
</code></pre>
<p class="normal">The preceding snippets show possible implementations for the <code class="inlineCode">std::ssize()</code> function for containers and arrays.</p>
<h2 class="heading-2" id="_idParaDest-319">There’s more...</h2>
<p class="normal">These non-member functions are mainly intended for template code where the container is not known and can be a standard container, an array, or a custom type. Using the non-member version of these functions enables us to write simpler and less code that works with all these types of containers.</p>
<p class="normal">However, the <a id="_idIndexMarker663"/>use of these functions is not and should <a id="_idIndexMarker664"/>not be limited to generic code. Though it is rather a matter of personal preference, it can be a good habit to be consistent and use them everywhere in your code. All these methods have lightweight implementations that will most likely be inlined by the compiler, which means that there will be no overhead at all for using the corresponding member functions.</p>
<h2 class="heading-2" id="_idParaDest-320">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing your own random-access iterator</em>, to understand what you need to do to write a custom, random-access iterator</li>
</ul>
<h1 class="heading-1" id="_idParaDest-321">Selecting the right standard containers</h1>
<p class="normal">The<a id="_idIndexMarker665"/> standard library contains a variety of containers for meeting multiple and various needs. There are sequence containers (in which elements are arranged in a certain position), container adapters (that provide a different interface for sequential containers), associative containers (in which the order is given by a key associated with an element), unordered associative containers (in which the elements do not follow a certain order). Selecting the right container for a given task is not always straight forward. This recipe will provide guidelines to help you decide which one to use for what purpose.</p>
<h2 class="heading-2" id="_idParaDest-322">How to do it…</h2>
<p class="normal">To decide which standard container you should use, consider the following guidelines:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">std::vector</code> as the default container, when no other specific requirements exist.</li>
<li class="bulletList">Use <code class="inlineCode">std::array</code> when the length of a sequence is fixed and known at compile time.</li>
<li class="bulletList">Use <code class="inlineCode">std::deque</code> if you frequently need to add or remove elements at the beginning and the end of a sequence.</li>
<li class="bulletList">Use <code class="inlineCode">std::list</code> if you frequently need to add or remove elements in the middle of the sequence (that’s anywhere else other than the beginning and end) and bidirectional traversing of the sequence is required.</li>
<li class="bulletList">Use <code class="inlineCode">std::forward_list</code> if you frequently need to add or remove elements anywhere in the sequence but you only need to traverse the sequence in one direction.</li>
<li class="bulletList">Use <code class="inlineCode">std::stack</code> if you need a sequence with <strong class="keyWord">last-in, first-out</strong> (<strong class="keyWord">LIFO</strong>) semantics.</li>
<li class="bulletList">Use <code class="inlineCode">std::queue</code> if you need a sequence with <strong class="keyWord">first-in, first-out </strong>(<strong class="keyWord">FIFO</strong>) semantics.</li>
<li class="bulletList">Use <code class="inlineCode">std::priority_queue</code> if you need a sequence with FIFO semantics, but in which elements are arranged in a strict weak ordering (the largest – highest priority element comes first).</li>
<li class="bulletList">Use <code class="inlineCode">std::unordered_map</code> if you need to store key-value pairs and the order of the elements is not important but keys must be unique.</li>
<li class="bulletList">Use <code class="inlineCode">std::map</code> if you need to store key-value pairs with unique keys but the order of the elements is given by their keys.</li>
<li class="bulletList">Use <code class="inlineCode">std::unordered_multimap</code> if you need to store key-value pairs, the keys can be duplicated, and the order of the elements is not important.</li>
<li class="bulletList">Use <code class="inlineCode">std::multimap</code> if you need to store key-value pairs, the keys can be duplicated, and the elements are stored in an order given by their keys.</li>
<li class="bulletList">Use <code class="inlineCode">std::unordered_set</code> if you need to store unique values but their order is not important.</li>
<li class="bulletList">Use <code class="inlineCode">std::set</code> if you need to store unique values but the order of the elements is important (the lowest elements are stored first).</li>
<li class="bulletList">Use <code class="inlineCode">std::unordered_multiset</code> if you want to store non-unique values, although their order does not matter, and you want the search capabilities of a set.</li>
<li class="bulletList">Use <code class="inlineCode">std::multiset</code> if you want to store non-unique value, but the order of the elements matter, with those having a lowest key coming first, and you want the search capabilities of a set.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-323">How it works…</h2>
<p class="normal">Containers <a id="_idIndexMarker666"/>are objects that store other objects, internally managing the memory used by the stored objects. They provide access to elements and other functionality defined by standardized interfaces. There are four categories of containers in the standard library:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Sequence containers</strong> store<a id="_idIndexMarker667"/> elements in a certain order but this order does not depend on the value of the element. Sequence containers are typically implemented either as arrays (elements are stored contiguous in memory) or linked lists (elements are stored in nodes that point to others). The standard sequence containers are <code class="inlineCode">std::array</code>, <code class="inlineCode">std::vector</code>, <code class="inlineCode">std::list</code>, <code class="inlineCode">std::forward_list</code>, and <code class="inlineCode">std::deque</code>.</li>
<li class="bulletList"><strong class="keyWord">Container adaptors</strong> define<a id="_idIndexMarker668"/> an adapted interface towards a sequence container. These are <code class="inlineCode">std::stack</code>, <code class="inlineCode">std::queue</code>, and <code class="inlineCode">std::priority_queue</code>.</li>
<li class="bulletList"><strong class="keyWord">Associative containers</strong> store elements in a certain order given by keys associated with<a id="_idIndexMarker669"/> each element. Although they support insertion and deletion, this cannot happen at a specific position but depends on the key. They provide good performance for searching elements, a binary search that has logarithmic complexity being possible for all containers. The standard associative containers are <code class="inlineCode">std::map</code>, <code class="inlineCode">std::set</code>, <code class="inlineCode">std::multimap</code>, and <code class="inlineCode">std::multiset</code>.</li>
<li class="bulletList"><strong class="keyWord">Unordered associative containers</strong> store elements that are not ordered. These<a id="_idIndexMarker670"/> containers are implemented using hash tables, which makes searching elements a constant-time operation. Unlike associated containers, the unordered ones do not support binary search. Hash functions must be implemented for the types of the elements stored in an unordered associative container. The standard containers are <code class="inlineCode">std::unordered_map</code>, <code class="inlineCode">std::unordered_multimap</code>, <code class="inlineCode">std::unordered_set</code>, and <code class="inlineCode">std::unordered_multiset</code>.</li>
</ul>
<p class="normal">The <code class="inlineCode">std::vector</code> container <a id="_idIndexMarker671"/>is perhaps the most used one, as the code snippets in this book also show. A vector stores its elements sequentially in a contiguous memory. A vector can grow and shrink. Although elements can be inserted anywhere in the sequence, the most efficient operations are insertions and removals at the end of the sequence (with <code class="inlineCode">push_back()</code> and <code class="inlineCode">pop_back()</code>):</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8 };
v.push_back(13); // insert at the end
</code></pre>
<p class="normal">Here is a conceptual representation of a vector before and after inserting an element at its end:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_05_01.png"/></figure>
<p class="packt_figref">Figure 5.1: Inserting an element at the end of a vector</p>
<p class="normal">Inserting<a id="_idIndexMarker672"/> or removing elements anywhere other than the end of the sequence (with <code class="inlineCode">insert()</code> and <code class="inlineCode">erase()</code>) is less performant because all of the elements after the insertion/removal position must be moved in memory. If an insert operation would determine capacity of the vector (the number of elements that can be stored in the allocated memory) to be exceeded, a reallocation must occur. In this case, a new, larger contiguous sequence of memory is allocated, and all the stored elements are copied to this new buffer, along with the newly added ones, and the old memory chunk is deleted:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8 };
v.insert(v.begin() + 3, 13); // insert in the middle
</code></pre>
<p class="normal">The next diagram shows a conceptual representation of a vector before and after inserting a new element in the middle:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_05_02.png"/></figure>
<p class="packt_figref">Figure 5.2: Inserting an element in the middle of a vector</p>
<p class="normal">If <a id="_idIndexMarker673"/>frequent insertions or deletion also occur at the beginning of the sequence, a better alternative is the <code class="inlineCode">std::deque</code> container. This allows fast inserts and removals at both ends (with <code class="inlineCode">push_front()</code>/<code class="inlineCode">pop_front()</code> and <code class="inlineCode">push_back()</code>/<code class="inlineCode">pop_back()</code>). Removals at the two ends do not invalidate pointers or references to the rest of the elements. However, unlike <code class="inlineCode">std::vector</code>, <code class="inlineCode">std::deque</code> does not store its elements contiguously in memory, but in a sequence of fixed-length arrays that require extra management. Although indexing elements involve two levels of pointer dereferencing, compared to just one for <code class="inlineCode">std::vector</code>, expanding a <code class="inlineCode">deque</code> is faster than for <code class="inlineCode">vector</code>, because it does not require reallocating all the memory and copying the existing elements:</p>
<pre class="programlisting code"><code class="hljs-code">std::deque&lt;int&gt; d{ 1,2,3,5,8 };
d.push_front(1); // insert at the beginning
d.push_back(13); // insert at the end
</code></pre>
<p class="normal">Neither <code class="inlineCode">std::vector</code> nor <code class="inlineCode">std::deque</code> have a good performance for insertions in the middle of the sequence (middle meaning anywhere other than the ends). A container that does offer constant time insertions in the middle is <code class="inlineCode">std::list</code>. This is implemented as a double-linked list, which means elements are not stored in contiguous memory. The use cases for <code class="inlineCode">std::list</code> are not many though. A typical one is the situations when you need to do many inserts and removals in the middle, more than iterations over the list. You can<a id="_idIndexMarker674"/> also use a <code class="inlineCode">std::list</code> when you have one or more sequences that you need to split and join often. </p>
<p class="normal">If you also need to retain the validity of iterators and references to the elements of the list even after an insert or removal, then <code class="inlineCode">std::list</code> is a good candidate:</p>
<pre class="programlisting code"><code class="hljs-code">std::list&lt;int&gt; l{ 1, 1, 2, 3, 5, 8 };
auto it = std::find(l.begin(), l.end(), 3);
l.insert(it, 13);
</code></pre>
<p class="normal">The next diagram shows a conceptual representation of a (double-linked) list and the insertion of a new element in the middle of it:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_05_03.png"/></figure>
<p class="packt_figref">Figure 5.3: Inserting an element in the middle of a list</p>
<p class="normal">If you want to store values identified by a key, associative containers are the appropriate <a id="_idIndexMarker675"/>solution. Storing key-value pairs is possible with either <code class="inlineCode">std::map</code> and <code class="inlineCode">std::unordered_map</code>. These two containers differ significantly:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::map</code> stores the key-value pairs ordered by the key (using a comparison function, the <a id="_idIndexMarker676"/>default being <code class="inlineCode">std::less</code>), while <code class="inlineCode">std::unordered_map</code>, as the name implies, does not retain any order.</li>
<li class="bulletList"><code class="inlineCode">std::map</code> is implemented with self-balancing <strong class="keyWord">binary search trees</strong> (<strong class="keyWord">BST</strong>) such as red-back trees, while <code class="inlineCode">std::unordered_map</code> is implemented with hash tables. Since hash tables require more book-keeping data, <code class="inlineCode">std::unordered_map</code> uses more memory than <code class="inlineCode">std::map</code> to store the same number of elements.</li>
<li class="bulletList"><code class="inlineCode">std::map</code> provides logarithmic complexity, <em class="italic">O(log(n))</em>, for search operations, and the same plus a rebalancing for inserts and removals, while <code class="inlineCode">std::unordered_map</code> provides constant-time,<em class="italic"> O(1)</em>, on average for inserts, although worst case scenarios decrease to linear complexity, <em class="italic">O(n)</em>, for all search, insert, and remove operations.</li>
</ul>
<p class="normal">Based on these differences, we can identify typical use cases for each of these containers:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::map</code> is recommended when:<ul>
<li class="bulletList">You need to store the elements ordered in the container, so that they can be accessed in their defined order</li>
<li class="bulletList">You need the successor or predecessor of an element</li>
<li class="bulletList">You need to lexicographically compare maps with the <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, or <code class="inlineCode">&gt;=</code> operators</li>
<li class="bulletList">You want to use algorithms such as <code class="inlineCode">binary_search()</code>, <code class="inlineCode">lower_bound()</code>, or <code class="inlineCode">upper_bound()</code></li>
</ul>
</li>
<li class="bulletList"><code class="inlineCode">std::unordered_map</code> is recommended when:<ul>
<li class="bulletList">You don’t need to store the unique objects in a particular order</li>
<li class="bulletList">You perform a lot of inserts/removals and searches</li>
<li class="bulletList">You need to access individual elements and iterating over the entire sequence is not required</li>
</ul>
</li>
</ul>
<p class="normal">In order to use <code class="inlineCode">std::unordered_map</code>, a hash function (either a specialization of <code class="inlineCode">std::hash&lt;T&gt;</code> or a different implementation) must be defined for the type of the stored elements. This is necessary because in an <code class="inlineCode">std::unordered_map</code>, elements are stored in buckets. The bucket to which an element is stored depends on the hash value of the key. A good hashing function can prevent collisions, allowing all operations to take constant time – <em class="italic">O(1)</em>. On the other hand, if the hashing function is not well crafted, it can lead to collisions that degrade searches and inserts/removals to linear complexity – <em class="italic">O(n)</em>.</p>
<p class="normal">When you<a id="_idIndexMarker677"/> want to store unique objects but do not have a key associated with each object, the right standard containers are <code class="inlineCode">std::set</code> and <code class="inlineCode">std::unordered_set</code>. A set is very similar to a map, except that the object is also the key. These two containers, <code class="inlineCode">std::set</code> and <code class="inlineCode">std::unordered_set</code>, have the same differences we saw for <code class="inlineCode">std::map</code> and <code class="inlineCode">std::unordered_map</code>:</p>
<ul>
<li class="bulletList">In a <code class="inlineCode">std::set</code> objects are ordered, while in a <code class="inlineCode">std::unordered_set</code> they are unordered.</li>
<li class="bulletList"><code class="inlineCode">std::set</code> is implemented with red-black trees, while <code class="inlineCode">std::unordered_set</code> is implemented with hash tables.</li>
<li class="bulletList"><code class="inlineCode">std::set</code> provides logarithmic complexity, <em class="italic">O(log(n))</em>, for search operations, and the same plus a rebalancing for inserts and removals, while <code class="inlineCode">std::unordered_set</code> provides constant-time, <em class="italic">O(1)</em>, on average for inserts, although worst case scenarios decrease to linear complexity, <em class="italic">O(n)</em>, for all search, insert, and remove operations.</li>
</ul>
<p class="normal">Taking these differences into consideration and the similarities with the <code class="inlineCode">std::map</code>/<code class="inlineCode">std::unordered_map</code> containers, we can identify the same use-case scenarios for <code class="inlineCode">std::set</code> as we did for <code class="inlineCode">std::map</code> and for <code class="inlineCode">std::unordered_set</code> as we did for <code class="inlineCode">std::unordered_map</code>. Also, for using <code class="inlineCode">std::unordered_set</code>, a hashing function must be defined for the type of the stored objects.</p>
<p class="normal">When you need to store more than one value associated with a key, you can use <code class="inlineCode">std::multimap</code> and <code class="inlineCode">std::unordered_multimap</code>. These two have the same considerations as <code class="inlineCode">std::map</code> and <code class="inlineCode">std::unordered_map</code>. We can say that <code class="inlineCode">std::multimap</code> is to <code class="inlineCode">std::map</code> what <code class="inlineCode">std::unordered_multimap</code> is to <code class="inlineCode">std::unordered_map</code>. Similarly, <code class="inlineCode">std::multiset</code> and <code class="inlineCode">std::unordered_multiset</code> can be used to store duplicates in a set.</p>
<p class="normal">Considering all the various standard container types and their typical use based on their characteristics, we can use the following diagram to select the most appropriate container. The following diagram was created by me, based on the one created by Mikael Persson and shared on StackOverflow: (<a href="https://stackoverflow.com/a/22671607/648078">https://stackoverflow.com/a/22671607/648078</a>).</p>
<figure class="mediaobject"><img alt="" src="img/B21549_05_04.png"/></figure>
<p class="packt_figref">Figure 5.4: Flowchart for selecting the right standard container</p>
<div><p class="normal">Although this recipe is intended as a guide for selecting the right standard container, it does not cover all containers and all possible considerations. When performance is key, the best choice may not be the typical one. In such a situation, you should try different implementations with different choices, benchmark them, and decide on a solution based on the results of your measurements.</p>
</div>
<h2 class="heading-2" id="_idParaDest-324">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using vector as a default container</em>, to learn how you can use the <code class="inlineCode">std::vector</code> class</li>
<li class="bulletList"><em class="italic">Using vector&lt;bool&gt; for variable-size sequences of bits</em>, to understand how this <code class="inlineCode">std::vector</code> specialization for bool can be used to manipulate sequence of bits</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_05.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>