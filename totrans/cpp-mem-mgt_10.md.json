["```cpp\nclass Orc {\n  char name[4]{ 'U', 'R', 'G' };\n  int strength = 100;\n  double smell = 1000.0;\npublic:\n  static constexpr int NB_MAX = 1'000'000;\n  // ...\n};\n```", "```cpp\nstatic_assert(Orc::NB_MAX*sizeof(Orc) <= THRESHOLD);\n```", "```cpp\n#ifndef ORC_H\n#define ORC_H\n// #define HOMEMADE_VERSION\n#include <cstddef>\n#include <new>\nclass Orc {\n  char name[4]{ 'U', 'R', 'G' };\n  int strength = 100;\n  double smell = 1000.0;\npublic:\n  static constexpr int NB_MAX = 1'000'000;\n#ifdef HOMEMADE_VERSION\n   void * operator new(std::size_t);\n   void * operator new[](std::size_t);\n   void operator delete(void *) noexcept;\n   void operator delete[](void *) noexcept;\n#endif\n};\n#endif\n```", "```cpp\n#include \"Orc.h\"\n#ifdef HOMEMADE_VERSION\n#include <cassert>\n#include <cstdlib>\n#include <mutex>\nclass Tribe {\n  std::mutex m;\n  char *p, *cur;\n  Tribe() : p{ static_cast<char*>(\n      std::malloc(Orc::NB_MAX * sizeof(Orc))\n  ) } {\n      assert(p);\n      cur = p;\n  }\n  Tribe(const Tribe&) = delete;\n  Tribe& operator=(const Tribe&) = delete;\npublic:\n  ~Tribe() {\n      std::free(p);\n  }\n  static auto &get() {\n      static Tribe singleton;\n      return singleton;\n  }\n  void * allocate() {\n      std::lock_guard _ { m };\n      auto q = cur;\n      cur += sizeof(Orc);\n      return q;\n  }\n  void deallocate(void *) noexcept {\n  }\n};\n// ...\n```", "```cpp\n// ...\nvoid * Orc::operator new(std::size_t) {\n  return Tribe::get().allocate();\n}\nvoid * Orc::operator new[](std::size_t) {\n  assert(false);\n}\nvoid Orc::operator delete(void *p) noexcept {\n  Tribe::get().deallocate(p);\n}\nvoid Orc::operator delete[](void *) noexcept {\n  assert(false);\n}\n#endif // HOMEMADE_VERSION\n```", "```cpp\n#include <chrono>\n#include <utility>\ntemplate <class F, class ... Args>\n  auto test(F f, Args &&... args) {\n      using namespace std;\n      using namespace std::chrono;\n      auto pre = high_resolution_clock::now();\n      auto res = f(std::forward<Args>(args)...);\n      auto post = high_resolution_clock::now();\n      return pair{ res, post - pre };\n  }\n// ...\n```", "```cpp\n// ...\n#include \"Orc.h\"\n#include <print>\n#include <vector>\nint main() {\n  using namespace std;\n  using namespace std::chrono;\n#ifdef HOMEMADE_VERSION\n  print(\"HOMEMADE VERSION\\n\");\n#else\n  print(\"STANDARD LIBRARY VERSION\\n\");\n#endif\n  vector<Orc*> orcs;\n  auto [r0, dt0] = test([&orcs] {\n      for(int i = 0; i != Orc::NB_MAX; ++i)\n        orcs.push_back(new Orc);\n      return size(orcs);\n  });\n  // ...\n  // CARNAGE (CENSORED)\n  // ...\n  auto [r1, dt1] = test([&orcs] {\n      for(auto p : orcs)\n        delete p;\n      return size(orcs);\n  });\n  print(\"Construction: {} orcs in {}\\n\",\n        size(orcs), duration_cast<microseconds>(dt0));\n  print(\"Destruction:  {} orcs in {}\\n\",\n        size(orcs), duration_cast<microseconds>(dt1));\n}\n```", "```cpp\n// ...\n// \"global\" singleton implementation (the rest of\n// the code remains unchanged)\nclass Tribe {\n  std::mutex m;\n  char *p, *cur;\n  Tribe() : p{ static_cast<char*>(\n      std::malloc(Orc::NB_MAX * sizeof(Orc))\n  ) } {\n      assert(p);\n      cur = p;\n  }\n  Tribe(const Tribe&) = delete;\n  Tribe& operator=(const Tribe&) = delete;\n  static Tribe singleton;\npublic:\n  ~Tribe() {\n      std::free(p);\n  }\nstatic auto &get() {\n      return singleton;\n  }\n  void * allocate() {\n      std::lock_guard _ { m };\n      auto q = cur;\n      cur += sizeof(Orc);\n      return q;\n  }\n  void deallocate(void *) noexcept {\n  }\n};\n// in a .cpp file somewhere, within a block surrounded\n// with #ifdef HOMEMADE_VERSION and #endif\nTribe Tribe::singleton;\n// ...\n```", "```cpp\n#ifndef SIZE_BASED_ARENA_H\n#define SIZE_BASED_ARENA_H\n#include <cassert>\n#include <cstdlib>\n#include <mutex>\ntemplate <class T, std::size_t N>\nclass SizeBasedArena {\n  std::mutex m;\n  char *p, *cur;\n  SizeBasedArena() : p{ static_cast<char*>(\n      std::malloc(N * sizeof(T))\n  ) } {\n      assert(p);\n      cur = p;\n  }\n  SizeBasedArena(const SizeBasedArena&) = delete;\n  SizeBasedArena&\n      operator=(const SizeBasedArena&) = delete;\npublic:\n  ~SizeBasedArena() {\n      std::free(p);\n  }\n  static auto &get() {\n      static SizeBasedArena singleton;\n      return singleton;\n  }\n  void * allocate_one() {\n      std::lock_guard _ { m };\n      auto q = cur;\n      cur += sizeof(T);\n      return q;\n  }\n  void * allocate_n(std::size_t n) {\n      std::lock_guard _ { m };\n      auto q = cur;\n      cur += n * sizeof(T);\n      return q;\n  }\n  void deallocate_one(void *) noexcept {\n  }\n  void deallocate_n(void *) noexcept {\n  }\n};\n#endif\n```", "```cpp\n#include \"Orc.h\"\n#ifdef HOMEMADE_VERSION\n#include \"SizeBasedArena.h\"\nusing Tribe = SizeBasedArena<Orc, Orc::NB_MAX>;\nvoid * Orc::operator new(std::size_t) {\n  return Tribe::get().allocate_one();\n}\nvoid * Orc::operator new[](std::size_t n) {\n  return Tribe::get().allocate_n(n / sizeof(Orc));\n}\nvoid Orc::operator delete(void *p) noexcept {\n  Tribe::get().deallocate_one(p);\n}\nvoid Orc::operator delete[](void *p) noexcept {\n  Tribe::get().deallocate_n(p);\n}\n#endif\n```", "```cpp\nclass MeanOrc : public Orc {\n  float attackBonus; // oops!\n  // ...\n};\n```", "```cpp\nclass Orc final {\n  // ...\n};\n```", "```cpp\n// ...\n#include <type_traits>\ntemplate <class T, std::size_t N>\nclass SizeBasedArena {\n  static_assert(std::is_final_v<T>);\n   // ...\n};\n```", "```cpp\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <memory>\n#include <cassert>\n#include <concepts>\n#include <limits>\n#include <array>\n#include <iterator>\n#include <mutex>\n// ... helper functions (shown below)...\ntemplate <int N, auto ... Sz>\n  class ChunkSizedAllocator {\n      static_assert(is_sorted(make_array(Sz...)));\n      static_assert(sizeof...(Sz) > 0);\n      static_assert(\n        ((Sz >= sizeof(std::max_align_t)) && ...)\n      );\n      static_assert(N > 0);\n      static constexpr unsigned long long sizes[] {\n        next_power_of_two(Sz)...\n      };\n      using raw_ptr = void*;\n      raw_ptr blocks[sizeof...(Sz)];\n      int cur[sizeof...(Sz)] {}; // initialized to zero\n      // ...\n```", "```cpp\n// ...\ntemplate <class T, std::same_as<T> ... Ts>\n  constexpr std::array<T, sizeof...(Ts)+1>\n      make_array(T n, Ts ... ns) {\n        return { n, ns... };\n      }\nconstexpr bool is_power_of_two(std::integral auto n) {\n  return n && ((n & (n - 1)) == 0);\n}\nclass integral_value_too_big {};\nconstexpr auto next_power_of_two(std::integral auto n) {\n  constexpr auto upper_limit =\n      std::numeric_limits<decltype(n)>::max();\n  for(; n != upper_limit && !is_power_of_two(n); ++n)\n       ;\n  if(!is_power_of_two(n)) throw integral_value_too_big{};\n  return n;\n}\ntemplate <class T>\n  constexpr bool is_sorted(const T &c) {\n      return std::is_sorted(std::begin(c), std::end(c));\n  }\n// ...\n```", "```cpp\n      // ...\n      bool within_block(void *p, int i) {\n        void* b = blocks[i];\n        void* e = static_cast<char*>(b) + N * sizes[i];\n        return p == b ||\n                (std::less{}(b, p) && std::less{}(p, e));\n      }\n      // ...\n```", "```cpp\n      // ...\n      std::mutex m;\n  public:\n      ChunkSizedAllocator(const ChunkSizedAllocator&)\n         = delete;\n      ChunkSizedAllocator&\n        operator=(const ChunkSizedAllocator&) = delete;\n      ChunkSizedAllocator() {\n        int i = 0;\n        for(auto sz : sizes)\n            blocks[i++] = std::malloc(N * sz);\n        assert(std::none_of(\nstd::begin(blocks), std::end(blocks),\n            [](auto p) { return !p; }\n        ));\n      }\n      ~ChunkSizedAllocator() {\n        for(auto p : blocks)\n            std::free(p);\n      }\n      // ...\n```", "```cpp\n      // ...\n      auto allocate(std::size_t n) {\n        using std::size;\n        // use smallest block available\n        for(std::size_t i = 0; i != size(sizes); ++i) {\n            if(n < sizes[i]) {\n              std::lock_guard _ { m };\n              if(cur[i] < N) {\n                  void *p = static_cast<char*>(blocks[i]) +\n                            cur[i] * sizes[i];\n                  ++cur[i];\n                  return p;\n              }\n            }\n        }\n        // either no block fits or no block left\n        return ::operator new(n);\n      }\n      void deallocate (void *p) {\n        using std::size;\n        for(std::size_t i = 0; i != size(sizes); ++i) {\n            if(within_block(p, i)) {\n              //std::lock_guard _ { m };\n              // if you want to reuse the memory,\n              // it's in blocks[i]\n              return;\n            }\n        }\n        // p is not in our blocks\n        ::operator delete(p);\n      }\n  };\n  // ...\n```", "```cpp\ntemplate <int N, auto ... Sz>\n  void *operator new(std::size_t n, ChunkSizedAllocator<\n      N, Sz...\n  > &chunks) {\n      return chunks.allocate(n);\n  }\ntemplate <int N, auto ... Sz>\n  void operator delete (void *p, ChunkSizedAllocator<\n      N, Sz...\n  > &chunks) {\n      return chunks.deallocate(p);\n  }\n// new[] and delete[] left as an exercise ;)\n```", "```cpp\n#include <chrono>\n#include <utility>\n#include <functional>\ntemplate <class F, class ... Args>\n  auto test(F f, Args &&... args) {\n      using namespace std;\n      using namespace std::chrono;\n      auto pre = high_resolution_clock::now();\n      auto res = f(std::forward<Args>(args)...);\n      auto post = high_resolution_clock::now();\n      return pair{ res, post - pre };\n  }\ntemplate <int N> struct dummy { char _[N] {}; };\ntemplate <int N> auto test_dummy() {\n  return std::pair<void *, std::function<void(void*)>> {\n      new dummy<N>{},\n      [](void *p) { delete static_cast<dummy<N>*>(p); }\n  };\n}\ntemplate <int N, class T> auto test_dummy(T &alloc) {\n  return std::pair<void *, std::function<void(void*)>> {\n      new (alloc) dummy<N>{},\n[&alloc](void *p) { ::operator delete(p, alloc); }\n  };\n}\n// ...\n```", "```cpp\n// ...\n#include <print>\n#include <vector>\nint main() {\n  using namespace std;\n  using namespace std::chrono;\n  constexpr int N = 100'000;\n  using Alloc = ChunkSizedAllocator<\n      N, 32, 62 /* 64 */, 128\n  >;\n  Alloc chunks; // construct the ChunkSizedAllocator\n  // ...\n```", "```cpp\n  // ...\n  auto [r0, dt0] = test([ptrs = std::vector<\n      std::pair<\n         void*, std::function<void(void*)>\n      >>(N * 3)]() mutable {\n      // allocation\n      for(int i = 0; i != N * 3; i += 3) {\n        ptrs[i] = test_dummy<30>();\n        ptrs[i + 1] = test_dummy<60>();\n        ptrs[i + 2] = test_dummy<100>();\n      }\n      // cleanup\n      for(auto & p : ptrs)\n        p.second(p.first);\n      return std::size(ptrs);\n  });\n  auto [r1, dt1] = test([&chunks, ptrs = std::vector<\n      std::pair<\n        void*, std::function<void(void*)>\n      >>(N * 3)]() mutable {\n      // allocation\n      for(int i = 0; i != N * 3; i += 3) {\n        ptrs[i] = test_dummy<30>(chunks);\n        ptrs[i + 1] = test_dummy<60>(chunks);\n        ptrs[i + 2] = test_dummy<100>(chunks);\n      }\n      // cleanup\n      for(auto & p : ptrs)\n         p.second(p.first);\n      return std::size(ptrs);\n  });\n   std::print(\"Standard version : {}\\n\",\n              duration_cast<microseconds>(dt0));\n  std::print(\"Chunked version  : {}\\n\",\n              duration_cast<microseconds>(dt1));\n}\n```"]