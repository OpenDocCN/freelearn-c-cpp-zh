- en: Chapter 12. You Shall (Not) Pass with QTest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。使用QTest（不）通过
- en: In the previous chapter, we created a drum machine software with some serialization
    feature. In this chapter, we will write the unit tests for this application. To
    achieve this goal, we will use Qt Test, a dedicated test module for Qt applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个具有一些序列化功能的鼓机软件。在本章中，我们将为这个应用程序编写单元测试。为了实现这个目标，我们将使用Qt Test，它是Qt应用程序的专用测试模块。
- en: The example project is a test application using CLI commands to execute and
    generate a test report. We will cover different types of tests including datasets,
    GUI, signals, and benchmarking.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目是一个使用CLI命令执行并生成测试报告的测试应用程序。我们将涵盖包括数据集、GUI、信号和基准测试在内的不同类型的测试。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Qt Test framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Test框架
- en: Project layout for unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的项目布局
- en: Personalize your test execution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性化您的测试执行
- en: Write tests with datasets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据集编写测试
- en: Benchmark your code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试您的代码
- en: Simulating GUI events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟GUI事件
- en: Perform signal introspection with the `QSignalSpy` class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QSignalSpy`类执行信号内省
- en: Discovering Qt Test
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现Qt Test
- en: The Qt framework provides Qt Test, a complete API to create your unit tests
    in C++. A test executes the code of your application and performs verification
    on it. Usually, a test compares a variable with an expected value. If the variable
    does not match the specific value, the test fails. If you wish to go further,
    you can benchmark your code and get the time/CPU tick/events required by your
    code. Clicking over and over on a GUI to test it can quickly become boring. Qt
    Test offers you the possibility to simulate keyboard entries and mouse events
    on your widgets to completely check your software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架提供了Qt Test，这是一个完整的API，用于在C++中创建您的单元测试。测试执行您的应用程序代码并对其进行验证。通常，测试会将一个变量与预期值进行比较。如果变量不匹配特定值，则测试失败。如果您想更进一步，您可以基准测试您的代码，并获取您的代码所需的时间/CPU滴答/事件。不断点击GUI进行测试可能会很快变得无聊。Qt
    Test为您提供在您的小部件上模拟键盘输入和鼠标事件的可能性，以完全检查您的软件。
- en: 'In our case, we want to create a unit test program named `drum-machine-test`.
    This console application will check the code of our famous drum machine from the
    previous chapter. Create a `subdirs` project called `ch12-drum-machine-test` with
    the following topology:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们想要创建一个名为`drum-machine-test`的单元测试程序。这个控制台应用程序将检查上一章中我们著名的鼓机代码。创建一个名为`ch12-drum-machine-test`的`subdirs`项目，其拓扑结构如下：
- en: '`drum-machine`:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drum-machine`:'
- en: '`drum-machine.pro`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drum-machine.pro`'
- en: '`drum-machine-test`:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drum-machine-test`:'
- en: '`drum-machine-test.pro`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drum-machine-test.pro`'
- en: '`ch12-drum-machine-test.pro`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch12-drum-machine-test.pro`'
- en: '`drum-machine-src.pri`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drum-machine-src.pri`'
- en: 'The `drum-machine` and `drum-machine-test` projects share the same source code.
    So all common files are put in a project include file: `drum-machine-src.pri`.
    Here is the updated `drum-machine.pro`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`drum-machine`和`drum-machine-test`项目共享相同的源代码。因此，所有公共文件都放在一个项目包含文件中：`drum-machine-src.pri`。以下是更新的`drum-machine.pro`：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we only perform a refactoring task; the project drum-machine
    is not affected by the drum-machine-test application. You can now create the `drum-machine-test.pro` file
    like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只执行重构任务；鼓机项目不受鼓机测试应用程序的影响。您现在可以创建如下所示的`drum-machine-test.pro`文件：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing to notice is that we need to enable the `testlib` module. Then
    even if we are creating a console application, we want to perform a test on the
    GUI so the modules (`gui`, `multimedia`, and `widgets`) used by the primary application
    are also required here. Finally, we include the project include file with all
    application files (sources, headers, forms, and resources). The `drum-machine-test`
    application will also contain new source files, so we must correctly set the `INCLUDEPATH`
    and `DEPENDPATH` variables to the source files folder.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们需要启用`testlib`模块。然后即使我们正在创建控制台应用程序，我们也想对GUI进行测试，因此还需要使用主要应用程序所使用的模块（`gui`、`multimedia`和`widgets`）。最后，我们将包含所有应用程序文件（源文件、头文件、表单和资源）的项目包含文件。`drum-machine-test`应用程序还将包含新的源文件，因此我们必须正确设置`INCLUDEPATH`和`DEPENDPATH`变量到源文件文件夹。
- en: 'Qt Test is easy to use and relies on some simple assumptions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Test易于使用，并基于一些简单的假设：
- en: A test case is a `QObject` class
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例是一个`QObject`类
- en: A private slot is a test function
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有槽是一个测试函数
- en: A test case can contain several test functions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例可以包含多个测试函数
- en: 'Notice that the private slots with the following names are not test functions,
    but special functions automatically called to initialize and clean up your test:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下名称的私有槽不是测试函数，而是自动调用来初始化和清理测试的特殊函数：
- en: '`initTestCase()`: This function is called before the first test function'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initTestCase()`: 这个函数在第一个测试函数之前被调用'
- en: '`init()`: This function is called before each test function'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()`: 这个函数在每个测试函数之前被调用'
- en: '`cleanup()`: This function is called after each test function'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cleanup()`: 这个函数在每个测试函数之后被调用'
- en: '`cleanupTestCase()`: This function is called after the last test function'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cleanupTestCase()`: 这个函数在最后一个测试函数之后被调用'
- en: 'Alright, we are ready to write our first test case in the `drum-machine-test`
    application. The serialization of the `drum-machine` object is an important part.
    A bad modification on the save feature can easily break the load feature. It can
    produce no errors at compile time, but it can lead to an unusable application.
    That is why tests are important. The first thing is to validate the serialization/deserialization
    process. Create a new C++ class, `DummySerializable`. Here is the header file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经准备好在`drum-machine-test`应用程序中编写第一个测试用例。`drum-machine`对象的序列化是一个重要的部分。对保存功能的错误修改可以轻易地破坏加载功能。它可能在编译时不会产生错误，但它可能导致无法使用的应用程序。这就是为什么测试很重要的原因。首先，我们需要验证序列化/反序列化过程。创建一个新的C++类，`DummySerializable`。以下是头文件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is a simple class implementing our `Serializable` interface created in [Chapter
    11](part0104.xhtml#aid-335QG1 "Chapter 11.  Having Fun with Serialization"), *Having
    Fun with Serialization*. This class will be helpful to validate the lower layer
    in our serialization process. As you can see, the class contains some variables
    with various types to ensure a complete functioning serialization. Let''s see
    the file,  `DummySerializable.cpp`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个简单的类，实现了我们在[第11章](part0104.xhtml#aid-335QG1 "第11章。与序列化一起玩乐")中创建的`Serializable`接口，*与序列化一起玩乐*。这个类将有助于验证我们序列化过程中的底层。正如你所见，该类包含了一些不同类型的变量，以确保完整的序列化功能。让我们看看文件，`DummySerializable.cpp`:'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'No surprise here; we perform our operation with a `QVariantMap`, as already
    performed in the previous chapter. Our dummy class is ready; create a new C++
    class, `TestJsonSerializer`, with the following header:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜；我们使用`QVariantMap`执行操作，就像在上一章中已经执行的那样。我们的虚拟类已经准备好了；创建一个新的C++类，`TestJsonSerializer`，其头文件如下：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we are, our first test case! This test case performs verifications on
    our class, `JsonSerializer`. You can see two test functions, `saveDummy()` and `loadDummy()`.
    The `cleanup()` slot is the special Qt Test slot that we covered earlier, which
    is executed after each test function. We can now write the implementation in `TestJsonSerializer.cpp`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们的第一个测试用例！这个测试用例对我们类`JsonSerializer`进行验证。你可以看到两个测试函数，`saveDummy()`和`loadDummy()`。`cleanup()`槽是之前提到的特殊Qt测试槽，它在每个测试函数之后执行。我们现在可以在`TestJsonSerializer.cpp`中编写实现：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Two constants are created here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里创建了两个常量：
- en: '`FILENAME`: This is the filename used to test the save and load the data'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILENAME`: 这是用于测试保存和加载数据的文件名'
- en: '`DUMMY_FILE_CONTENT`: This is the referential file content used by the test
    functions, `saveDummy()` and `loadDummy()`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DUMMY_FILE_CONTENT`: 这是测试函数`saveDummy()`和`loadDummy()`使用的参考文件内容'
- en: 'Let''s implement the test function, `saveDummy()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们实现测试函数，`saveDummy()`:'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first step is to instantiate a `DummySerializable` class with some fixed
    values. So, we call the function to test, `JsonSerializer::save()`, that will
    serialize our dummy object in the `test.json` file. Then, we call a helper function, `loadFileContent()`,
    to get the text contained in the `test.json` file. Finally, we use a Qt Test macro, `QVERIFY()`,
    to perform the verification that the text saved by the JSON serializer is the
    same as the expected value in `DUMMY_FILE_CONTENT`. If `data` equals the correct
    value, the test function succeeds. Here is the log output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用一些固定值实例化一个`DummySerializable`类。因此，我们调用测试函数，`JsonSerializer::save()`，它将在`test.json`文件中序列化我们的虚拟对象。然后，我们调用一个辅助函数，`loadFileContent()`，以获取`test.json`文件中的文本。最后，我们使用一个Qt测试宏，`QVERIFY()`，来执行验证，即JSON序列化器保存的文本与`DUMMY_FILE_CONTENT`中预期的值相同。如果`data`等于正确的值，则测试函数成功。以下是日志输出：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the data is different than the expected value, the test fails and an error
    is displayed in the console log:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据与预期值不同，则测试失败，并在控制台日志中显示错误：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s briefly see the helper function, `loadFileContent()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们简要看看辅助函数，`loadFileContent()`:'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: No big deal here. We open the file, `test.json`, read all the text content,
    and return the corresponding `QString`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这没什么大不了的。我们打开文件 `test.json`，读取所有文本内容，并返回相应的 `QString`。
- en: 'The macro, `QVERIFY()`, is great to check a Boolean value, but Qt Test provides
    a better macro when you want to compare data to an expected value. Let''s discover `QCOMPARE()`
    with the test function, `loadDummy()`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 宏 `QVERIFY()` 非常适合检查布尔值，但 Qt 测试在你想比较数据与预期值时提供了一个更好的宏。让我们通过测试函数 `loadDummy()`
    来发现 `QCOMPARE()`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first part creates a `test.json` file, with a referential content. Then
    we create an empty `DymmySerializable` and call the function to test `Serializable::load()`.
    Finally, we use the Qt Test macro, `QCOMPARE()`. The syntax is simple:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分创建一个 `test.json` 文件，包含参考内容。然后我们创建一个空的 `DymmySerializable` 并调用函数来测试 `Serializable::load()`。最后，我们使用
    Qt 测试宏 `QCOMPARE()`。语法很简单：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now test each field of the dummy loaded from JSON. The test function,
    `loadDummmy()`, will only succeed if all `QCOMPARE()` calls succeed. An error
    with a `QCOMPARE()` is much more detailed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试从 JSON 加载的模拟对象的每个字段。测试函数 `loadDummmy()` 只有在所有 `QCOMPARE()` 调用都成功时才会成功。`QCOMPARE()`
    错误会更加详细：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each time a test function is executed, the special `cleanup()` slot is called.
    Let''s update your file, `TestJsonSerializable.cpp`, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行测试函数时，都会调用特殊的 `cleanup()` 槽。让我们更新你的文件 `TestJsonSerializable.cpp`，如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a simple security that will remove the `test.json` file after each test
    function and prevent the save and load tests from colliding.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的安全措施，将在每个测试函数之后删除 `test.json` 文件，并防止保存和加载测试冲突。
- en: Executing your tests
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行你的测试
- en: 'We wrote a test case, `TestJsonSerializer`, with some test functions. We need
    a `main()` function in our `drum-machine-test` application. We will explore three
    possibilities:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个测试用例 `TestJsonSerializer`，其中包含一些测试函数。我们在 `drum-machine-test` 应用程序中需要一个
    `main()` 函数。我们将探讨三种可能性：
- en: The `QTEST_MAIN()` function
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTEST_MAIN()` 函数'
- en: Write our own simple `main()` function
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们自己的简单 `main()` 函数
- en: Write our own enhanced `main()` supporting multiple test classes
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们自己的支持多个测试类的增强 `main()`
- en: 'The `QTest` module provides an interesting macro, `QTEST_MAIN()`. This macro
    generates a complete `main()` function for your application. This generated method
    runs all the test functions of your test case. To use it, add the following snippet
    at the end of the `TestJsonSerializer.cpp` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTest` 模块提供了一个有趣的宏，`QTEST_MAIN()`。此宏为你的应用程序生成一个完整的 `main()` 函数。此生成方法运行你的测试用例中的所有测试函数。要使用它，请将以下片段添加到
    `TestJsonSerializer.cpp` 文件末尾：'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Moreover, if you declare and implement your test class only in the `.cpp` file
    (without a header file), you need to include the generated moc file after the `QTEST_MAIN`
    macro:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你仅在 `.cpp` 文件中声明和实现测试类（没有头文件），你需要在 `QTEST_MAIN` 宏之后包含生成的 moc 文件：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you use the `QTEST_MAIN()` macro, do not forget to remove the existing `main.cpp`.
    Otherwise, you will have two `main()` functions and a compilation error will happen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `QTEST_MAIN()` 宏，不要忘记删除现有的 `main.cpp`。否则，你将有两个 `main()` 函数，并且会发生编译错误。
- en: 'You can now try to run your drum-machine-test application and look at the application
    output. You should see something similar to this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以尝试运行你的鼓机测试应用程序并查看应用程序输出。你应该看到类似以下内容：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our test functions, `saveDummy()` and `loadDummy()`, are executed in the declaration
    order. Both succeed with the `PASS` status. The generated test application handles
    some options. Commonly, you can display the help menu executing this command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试函数，`saveDummy()` 和 `loadDummy()`，按照声明顺序执行。两者都成功，状态为 `PASS`。生成的测试应用程序处理了一些选项。通常，你可以通过执行以下命令来显示帮助菜单：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s see some cool features. We can execute only one function with the name.
    The following command only executes the `saveDummy` test function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些酷炫的功能。我们可以通过名称执行单个函数。以下命令仅执行 `saveDummy` 测试函数：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also execute several test functions separating their names with a space.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过空格分隔名称来执行多个测试函数。
- en: 'The QTest application provides log detail options:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: QTest 应用程序提供了日志详细选项：
- en: '`-silent` for silent. Only displays fatal errors and summary messages.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-silent` 用于静默模式。仅显示致命错误和摘要信息。'
- en: '`-v1` for verbose. Shows the test function entered information.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v1` 用于详细输出。显示测试函数输入的信息。'
- en: '`-v2` for extended verbose. Shows each `QCOMPARE()` and `QVERIFY()`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v2` 用于扩展详细输出。显示每个 `QCOMPARE()` 和 `QVERIFY()`。'
- en: '`-vs` for verbose signal. Shows the emitted signal and the connected slot.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-vs` 用于详细信号。显示发出的信号和连接的槽。'
- en: 'For example, we can display details of the execution of `loadDummy` with the
    following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下命令显示 `loadDummy` 执行的详细信息：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another great feature is the logging output format. You can create a test report
    file with various formats `(.txt`, `.xml`, `.csv`, and so on). The syntax requires
    a filename and a file format separated by a comma:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的功能是日志输出格式。您可以使用各种格式（如 `.txt`、`.xml`、`.csv` 等）创建测试报告文件。语法要求一个文件名和一个文件格式，由逗号分隔：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the following example, we create an XML report named `test-report.xml`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建了一个名为 `test-report.xml` 的 XML 报告：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that some log level affects only the plain text output. Moreover, the
    CSV format can be used only with the test macro `QBENCHMARK`, which is covered
    later in this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，某些日志级别仅影响纯文本输出。此外，CSV 格式只能与测试宏 `QBENCHMARK` 一起使用，该宏将在本章后面介绍。
- en: 'If you want to customize the generated test application, you can write the
    `main()` function. Remove the `QTEST_MAIN` macro in `TestJsonSerializer.cpp`.
    Then create a `main.cpp` like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自定义生成的测试应用程序，您可以编写 `main()` 函数。从 `TestJsonSerializer.cpp` 中移除 `QTEST_MAIN`
    宏。然后创建一个类似以下的 `main.cpp`：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, we are using the static function, `QTest::qExec()`, to start a `TestJsonSerializer`
    test. Do not forget to provide the command-line arguments to enjoy the QTest CLI
    options.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用静态函数 `QTest::qExec()` 来启动 `TestJsonSerializer` 测试。不要忘记提供命令行参数以享受
    QTest CLI 选项。
- en: If you wrote your test functions in different test classes, you would have created
    one application by a test class. If you keep one test class by test application
    you can even use the `QTEST_MAIN` macro to generate the main functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将测试函数写在不同的测试类中，您将创建一个由测试类生成的一个应用程序。如果您按测试应用程序保留一个测试类，甚至可以使用 `QTEST_MAIN`
    宏来生成主函数。
- en: Sometimes you want to create only one test application to handle all your test
    classes. In this case, you have multiple test classes in the same application,
    so you cannot use the `QTEST_MAIN` macro because you do not want to generate several
    main functions for each test class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您只想创建一个测试应用程序来处理所有测试类。在这种情况下，您在同一个应用程序中有多个测试类，因此您不能使用 `QTEST_MAIN` 宏，因为您不希望为每个测试类生成多个主函数。
- en: 'Let''s see a simple way to call all your test classes in a unique application:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一种简单的方法来调用所有测试类在一个独特应用程序中：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this simple custom `main()` function, we are executing the `TestFoo` and `TestBar`
    tests. But we are losing the CLI options. Indeed, executing the `QTest::qExec()`
    function with command-line arguments more than once will lead to errors and bad
    behaviors. For example, if you want to execute only one specific test function
    from `TestBar`. The execution of `TestFoo` will not find the test function, display
    an error message, and stop the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的自定义 `main()` 函数中，我们正在执行 `TestFoo` 和 `TestBar` 测试。但我们失去了 CLI 选项。实际上，多次使用带有命令行参数的
    `QTest::qExec()` 函数会导致错误和不良行为。例如，如果您只想从 `TestBar` 中执行一个特定的测试函数。`TestFoo` 的执行将找不到测试函数，显示错误消息，并停止应用程序。
- en: 'Here is a workaround to handle several test classes in a unique application.
    We will create a new CLI option, `-select`, to our test application. This option
    allows you to select a specific test class to execute. Here is a syntax example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个处理一个应用程序中多个测试类的解决方案。我们将为我们的测试应用程序创建一个新的命令行选项 `-select`。此选项允许您选择要执行的特定测试类。以下是一个语法示例：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-select` option, if used, must be at the beginning of the command followed
    by the test class name (`foo` in this example). Then, we can optionally add Qt
    Test options. To achieve this goal, we will create an enhanced `main()` function
    that parses the new `select` option and execute the corresponding test class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `-select` 选项，则必须将其放在命令的开头，后跟测试类名称（在这个例子中是 `foo`）。然后，我们可以选择性地添加 Qt 测试选项。为了实现这个目标，我们将创建一个增强型的
    `main()` 函数，该函数解析新的 `select` 选项并执行相应的测试类。
- en: 'We will create our enhanced `main()` function together:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起创建我们的增强型 `main()` 函数：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `QApplication` will be required later by our other GUI test cases. We retrieve
    the command line arguments for later use. The `std::map` template named `tests`
    contains the smart pointers of the test classes and a `QString` label is used
    as a key. Notice that we are using the `map::emplace()` function that does not
    copy the source to the map, but creates it in place. Using the `map::insert()`
    function leads to an error due to the illegal copy of a smart pointer. Another
    syntax that could be used with a `std::map` template and a `make_unique` is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`QApplication`将在我们之后的其他GUI测试用例中需要。我们检索命令行参数以供以后使用。名为`tests`的`std::map`模板包含测试类的智能指针，而`QString`标签用作键。请注意，我们正在使用`map::emplace()`函数，该函数不会将源复制到映射中，而是在原地创建它。使用`map::insert()`函数会导致错误，因为智能指针的复制是不合法的。还可以使用`std::map`模板和`make_unique`一起使用的另一种语法是：'
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now parse the command line arguments:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以解析命令行参数：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the `-select` option is used, this snippet performs two important tasks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`-select`选项，此代码段执行两个重要任务：
- en: Removes from the map `tests`, the test classes that do not match the test name
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`tests`映射中删除与测试名称不匹配的测试类
- en: Removes the arguments from the `-select` option and the `testName` variable
    to provide cleaned arguments to the `QTest::qExec()` function
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`-select`选项和`testName`变量中删除参数，为`QTest::qExec()`函数提供干净的参数
- en: 'We can now add the final step to execute the test classes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加执行测试类的最后一步：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Without the `-select` option, all the test classes will be performed. If we
    use the `-select` option with a test class name, only this one will be executed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有使用`-select`选项，将执行所有测试类。如果我们使用带有测试类名称的`-select`选项，则只执行这个类。
- en: Writing factorized tests with datasets
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据集编写因子化测试
- en: We will now turn our attention to testing the `Track` class. We will focus specifically
    on the different states a `Track` class can have: `STOPPED`, `PLAYING`, and `RECORDING`.
    For each one of these states, we want to make sure that adding `SoundEvents` works
    only if we are in the proper state (`RECORDING`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将注意力转向测试`Track`类。我们将特别关注`Track`类可以具有的不同状态：`STOPPED`、`PLAYING`和`RECORDING`。对于这些状态中的每一个，我们都要确保只有在正确的状态（`RECORDING`）下添加`SoundEvents`才会生效。
- en: 'To do so, we could write the following test functions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以编写以下测试函数：
- en: '`testAddSoundEvent()`: This function puts the `Track` in the `STOPPED` state,
    calls `track.addSoundEvent(0)`, and checks `track.soundEvents().size == 0`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testAddSoundEvent()`: 这个函数将`Track`置于`STOPPED`状态，调用`track.addSoundEvent(0)`，并检查`track.soundEvents().size
    == 0`'
- en: '`testAddSoundEvent()`: This function puts the `Track` in the `PLAYING` state,
    calls `track.addSoundEvent(0),` and checks `track.soundEvents().size == 0`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testAddSoundEvent()`: 这个函数将`Track`置于`PLAYING`状态，调用`track.addSoundEvent(0)`，并检查`track.soundEvents().size
    == 0`'
- en: '`testAddSoundEvent()`: This function puts the `Track` in the `RECORDING` state,
    calls `track.addSoundEvent(0)`, and checks `track.soundEvents().size == 1`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testAddSoundEvent()`: 这个函数将`Track`置于`RECORDING`状态，调用`track.addSoundEvent(0)`，并检查`track.soundEvents().size
    == 1`'
- en: 'As you can see, the logic is the same, we simply change the inputs and the
    desired outputs. To factorize this, Qt Test provides another module: datasets.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，逻辑是相同的，我们只是更改了输入和期望的输出。为了简化，Qt Test提供了一个另一个模块：数据集。
- en: 'A dataset can be seen as a two-dimensional table where each row is a test,
    and the columns are the inputs and expected outputs. For our `Track` state test,
    it would look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以看作是一个二维表，其中每一行是一个测试，列是输入和期望的输出。对于我们的`Track`状态测试，它看起来会是这样：
- en: '![Writing factorized tests with datasets](img/image00445.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用数据集编写因子化测试](img/image00445.jpeg)'
- en: With this approach, you write a single `addSoundEvent()` test function and Qt
    Test takes care of iterating over this table and comparing the result. Right now,
    it seems like magic. Let's implement it!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你只需编写一个`addSoundEvent()`测试函数，Qt Test就会负责遍历这个表格并比较结果。目前，这看起来像是魔法。让我们来实现它！
- en: 'Create a new C++ class named `TestTrack`, following the same pattern used for
    the `TestJsonSerializer` class (inherits `QObject`, includes `QTest`). Update `TestTrack.h`
    like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`TestTrack`的新C++类，遵循与`TestJsonSerializer`类相同的模式（继承自`QObject`，包含`QTest`）。更新`TestTrack.h`如下：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here we added two functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们添加了两个函数：
- en: '`addSoundEvent_data()`: This is the function that fills the dataset for the
    real test'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSoundEvent_data()`: 这是一个填充真实测试数据集的函数'
- en: '`addSoundEvent()`: This is the function that executes the test'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSoundEvent()`: 这是一个执行测试的函数'
- en: 'As you can see, the function that fills the dataset for a given `xxx()` function
    must be named `xxx_data()`. Let''s see the implementation of `addSoundEvent_data()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为给定 `xxx()` 函数填充数据集的函数必须命名为 `xxx_data()`。让我们看看 `addSoundEvent_data()` 的实现：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, a dataset is constructed like a table. We start by defining
    the structure of the table with the `trackState` and `soundEventCount` columns.
    Note that `QTest::addColumn` relies on templating to know the type of the variable
    (`int` in both cases).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数据集的构建就像一个表格。我们首先使用 `trackState` 和 `soundEventCount` 列定义表格的结构。请注意，`QTest::addColumn`
    依赖于模板来了解变量的类型（两种情况下都是 `int`）。
- en: After that, a row is appended to the table with the `QTest::newRow()` function,
    with the name of the test passed as a parameter. The `QTest::newRow` syntax supports
    the `<<` operator, making it very easy to pack all the data for a given row.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用 `QTest::newRow()` 函数将一行添加到表中，并将测试名称作为参数传递。`QTest::newRow` 语法支持 `<<` 操作符，这使得为给定行打包所有数据变得非常容易。
- en: Note that each row added to the dataset corresponds to an execution of the `addSoundEvent()`
    function in which the data of the row will be available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，添加到数据集的每一行都对应于 `addSoundEvent()` 函数的一次执行，其中该行的数据将可用。
- en: 'We can now turn our attention to `addSoundEvent()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将注意力转向 `addSoundEvent()`：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Because `addSoundEvent()` is executed by QTest and is fed with the dataset
    data, we can safely access the current row of the dataset like we would do with
    a cursor on a database. The `QFETCH(int, trackState)` is a helpful macro that
    does two things:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `addSoundEvent()` 是由 QTest 执行的，并且提供了数据集数据，所以我们可以安全地访问数据集的当前行，就像在数据库中使用游标一样。`QFETCH(int,
    trackState)` 是一个有用的宏，它执行两个操作：
- en: Declares an `int` variable named `trackState`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个名为 `trackState` 的 `int` 变量
- en: Fetches the current column index data of the dataset and stores its content
    in `trackState`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据集当前列索引数据并将其内容存储在 `trackState` 中
- en: 'The same principle is applied to `soundEventCount`. Now that we have our desired
    track state and the expected sound events count, we can proceed to the real test:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也应用于 `soundEventCount`。现在我们已经有了所需的轨道状态和预期的声音事件计数，我们可以继续进行实际测试：
- en: Put the track in the proper state according to `trackState`. Remember that the `Track::setState()`
    function is private, because the `Track` keyword handles the `trackState` variable
    alone, based on the caller instruction (`stop()`, `play()`, `record()`).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 `trackState` 将轨道置于适当的状态。请记住，`Track::setState()` 函数是私有的，因为 `Track` 关键字独立处理
    `trackState` 变量，基于调用者的指令（`stop()`、`play()`、`record()`）。
- en: Try to add a `SoundEvent` to track.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试向轨道添加一个 `SoundEvent`。
- en: Stop the track.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止轨道。
- en: Compare the number of `SoundEvents` in track to what is expected in `soundEventCount`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将轨道中的 `SoundEvents` 数量与 `soundEventCount` 中预期的数量进行比较。
- en: 'Do not forget to add the `TestTrack` class in `main.cpp`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `main.cpp` 中添加 `TestTrack` 类：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can now run the tests and see the three tests of `addSoundEvent()` output
    their result in the console:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行测试，并看到 `addSoundEvent()` 的三个测试在控制台输出其结果：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Datasets make the writing of tests less dull, by factorizing variations of data
    for a single test.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集通过为单个测试的数据变体进行因式分解，使得编写测试不那么枯燥。
- en: 'You can also run a single test for a specific entry of a dataset using the
    command line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用命令行对数据集的特定条目运行单个测试：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s say we want to execute the test function `addSoundEvent()` from `TestTrack`
    with only the `RECORDING` state. Here is the command line to run:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想使用 `RECORDING` 状态执行 `TestTrack` 中的测试函数 `addSoundEvent()`。以下是运行命令行：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Benchmarking your code
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码基准测试
- en: Qt Test also provides a very easy to use semantic to benchmark the execution
    speed of your code. To see it in action, we will benchmark the time it takes to
    save a `Track` in the JSON format. Depending on the track length (the number of `SoundEvents`),
    the serialization should take more or less time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Test 还提供了一个非常易于使用的语义来基准测试代码的执行速度。为了看到它的实际效果，我们将基准测试将 `Track` 保存为 JSON 格式所需的时间。根据轨道长度（`SoundEvents`
    的数量），序列化所需的时间会有所不同。
- en: Of course, it is more interesting to benchmark this feature with different track
    lengths and see if the time saving is linear. Datasets come to the rescue! It
    is not only useful to run the same function with expected inputs and outputs,
    but also to run the same function with different parameters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用不同的轨道长度基准测试此功能更有趣，看看时间节省是否呈线性。数据集可以提供帮助！它不仅适用于运行具有预期输入和输出的相同函数，还适用于运行具有不同参数的相同函数。
- en: 'We will start by creating the dataset function in `TestJsonSerializer`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`TestJsonSerializer`中创建数据集函数：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `saveTrack_data()` function simply stores the number of `SoundEvent` to
    be added to a `Track` class before it is saved. The `"1"`, `"100",` and `"1000"`
    strings are here to have a clear label in the test execution output. These strings
    will be displayed in each execution of `saveTrack()`. Feel free to tweak these
    numbers!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveTrack_data()`函数简单地存储在保存之前要添加到`Track`类中的`SoundEvent`数量。`"1"`、`"100"`和`"1000"`字符串在这里是为了在测试执行输出中有清晰的标签。这些字符串将在每次执行`saveTrack()`时显示。请随意调整这些数字！'
- en: 'Now for the real test with the benchmark call:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行真正的测试，使用基准调用：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `saveTrack()` function starts by fetching the `soundEventCount` column from
    its dataset. After that, it adds the correct number of `soundEvent` (with the
    proper `record()` state!) and finally benchmarks the serialization in the JSON
    format.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveTrack()`函数首先从其数据集中获取`soundEventCount`列。之后，它添加正确数量的`soundEvent`（具有正确的`record()`状态！）并最终在JSON格式中进行序列化基准测试。'
- en: 'You can see that the benchmark itself is simply a macro that looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，基准测试本身只是一个看起来像这样的宏：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The instructions enclosed in the `QBENCHMARK` macro will be measured automatically.
    If you execute the test with the updated `TestJsonSerializer` class, you should
    see an output similar to this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在`QBENCHMARK`宏中的指令将被自动测量。如果你使用更新的`TestJsonSerializer`类执行测试，你应该看到类似以下输出：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, the `QBENCHMARK` macro makes Qt Test output very interesting
    data. To save a `Track` class with a single `SoundEvent`, it took 0.041 milliseconds.
    Qt Test repeated this test 2048 times and it took a total of 84 milliseconds.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`QBENCHMARK`宏使Qt Test输出非常有趣的数据。为了保存一个包含单个`SoundEvent`的`Track`类，花费了0.041毫秒。Qt
    Test重复了这个测试2048次，总共花费了84毫秒。
- en: The power of the `QBENCHMARK` macro starts to be visible in the following test.
    Here, the `saveTrack()` function tried to save a `Track` class with 100 `SoundEvents`.
    It took 0.23 milliseconds to do it and it repeated the instruction 256 times.
    This shows you that the Qt Test benchmark automatically adjusts the number of
    iterations based on the average time a single iteration takes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的测试中，`QBENCHMARK` 宏的力量开始显现。在这里，`saveTrack()` 函数尝试保存一个包含100个`SoundEvents`的`Track`类。完成这个操作花费了0.23毫秒，并且指令重复了256次。这表明Qt
    Test基准会自动根据单次迭代的平均时间调整迭代次数。
- en: The `QBENCHMARK` macro has this behavior because a metric tends to be more accurate
    if it is repeated multiple times (to avoid possible external noise).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`QBENCHMARK`宏有这种行为，因为如果重复多次（以避免可能的外部噪声），指标往往更准确。'
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want your test to be benchmarked without multiple iterations, use `QBENCHMARK_ONCE`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要你的测试在没有多次迭代的情况下进行基准测试，请使用`QBENCHMARK_ONCE`。
- en: 'If you execute the test using the command line, you can provide additional
    metrics to `QBENCHMARK`. Here is the table recapitulating the available options:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用命令行执行测试，你可以向`QBENCHMARK`提供额外的指标。以下是总结可用选项的表格：
- en: '| **Name** | **Command-line argument** | **Availability** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **命令行参数** | **可用性** |'
- en: '| Walltime | (default) | All platforms |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 墙时 | （默认） | 所有平台 |'
- en: '| CPU tick counter | `-tickcounter` | Windows, OS X, Linux, many UNIX-like
    systems. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| CPU tick 计数器 | `-tickcounter` | Windows、OS X、Linux、许多类UNIX系统。|'
- en: '| Event Counter | `-eventcounter` | All platforms |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 事件计数器 | `-eventcounter` | 所有平台 |'
- en: '| Valgrind Callgrind | `-callgrind` | Linux (if installed) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| Valgrind Callgrind | `-callgrind` | Linux（如果已安装）|'
- en: '| Linux Perf | `-perf` | Linux |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| Linux Perf | `-perf` | Linux |'
- en: 'Each one of these options will replace the selected backend used to measure
    the execution time of the benchmarked code. For example, if you run `drum-machine-test`
    with the `-tickcounter` argument:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的每一个都将替换用于测量基准测试代码执行时间的所选后端。例如，如果你使用`-tickcounter`参数运行`drum-machine-test`：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can see that the wall time, measured in milliseconds, has been replaced
    by the number of CPU cycles completed for each iteration.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，以毫秒为单位测量的墙时已经替换为每个迭代完成的CPU周期数。
- en: Another interesting option is `-eventcounter`, which measures the numbers that
    were received by the event loop before they are sent to their corresponding target.
    This could be an interesting way of checking that your code emits the proper number
    of signals.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的选择是`-eventcounter`，它测量在发送到相应目标之前事件循环接收到的数字。这可能是一种检查你的代码是否发出正确数量信号的好方法。
- en: Testing your GUI
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的GUI
- en: It is now time to see how you can test your GUI using the Qt Test API. The `QTest`
    class offers several functions to simulate keys and mouse events.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看你如何使用 Qt 测试 API 测试你的 GUI 了。`QTest`类提供了几个函数来模拟键盘和鼠标事件。
- en: To demonstrate it, we will stay with the notion of testing a `Track` state,
    but on an upper level. Rather than testing the `Track` state itself, we will check
    that the UI state of the `drum-machine` application is properly updated when the `Track`
    state is changed. Namely, the control buttons (play, stop, record) should be in
    a specific state when a recording is started.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它，我们将继续使用测试`Track`状态的概念，但提升到一个更高的层面。而不是测试`Track`状态本身，我们将检查当`Track`状态改变时，`drum-machine`应用程序的
    UI 状态是否被正确更新。具体来说，当开始录音时，控制按钮（播放、停止、录音）应该处于特定的状态。
- en: 'Start by creating a `TestGui` class in the `drum-machine-test` project. Do
    not forget to add the `TestGui` class in the `tests` map of `main.cpp`. As usual,
    make it inherit `QObject` and update `TestGui.h` like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`drum-machine-test`项目中创建一个`TestGui`类。别忘了在`main.cpp`的`tests`映射中添加`TestGui`类。像往常一样，让它继承`QObject`并更新`TestGui.h`如下：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this header, we have a member, `mMainWindow`, which is an instance of the `MainWindow`
    keyword from the `drum-machine` project. Throughout the tests of `TestGui`, a
    single `MainWindow` will be used, in which we will inject events and check how
    it reacts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个头文件中，我们有一个成员`mMainWindow`，它是`drum-machine`项目中的`MainWindow`关键字的实例。在整个`TestGui`测试过程中，将使用单个`MainWindow`，我们将注入事件并检查其反应。
- en: 'Let''s switch to the `TestGui` constructor:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到`TestGui`构造函数：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The constructor initializes the `mMainWindow` variable. Notice that `mMainWindow`
    is never shown (using `mMainWindow.show()`). We do not need to display it, we
    solely want to test its states.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化了`mMainWindow`变量。请注意，`mMainWindow`从未被显示（使用`mMainWindow.show()`）。我们不需要显示它，我们只想测试其状态。
- en: Here, we use a rather obscure function call (`QTestEventLoop` is not documented
    at all) to force the event loop to be started after 1 second.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个相当晦涩的函数调用（`QTestEventLoop`完全没有文档说明）来强制事件循环在1秒后开始。
- en: The reason why we have to do this lies in the `QSoundEffect` class. The `QSoundEffect`
    class is initialized when the `QSoundEffect::setSource()` function is called (in `MainWindow`,
    this is done at the initialization of the `SoundEffectWidgets`). If we omit the
    explicit `enterLoop()` call, the `drum-machine-test` execution will crash with
    a segmentation fault.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须这样做的原因在于`QSoundEffect`类。`QSoundEffect`类在调用`QSoundEffect::setSource()`函数时被初始化（在`MainWindow`中，这是在`SoundEffectWidgets`的初始化时完成的）。如果我们省略显式的`enterLoop()`调用，`drum-machine-test`执行将因段错误而崩溃。
- en: It seems that the event loop has to be explicitly entered to let the `QSoundEffect`
    class properly complete its initialization. We found this undocumented workaround
    by studying the Qt unit tests of the `QSoundEffect` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎必须显式进入事件循环，以便让`QSoundEffect`类正确完成初始化。我们通过研究`QSoundEffect`类的 Qt 单元测试找到了这个未记录的解决方案。
- en: 'Now for the real GUI test! To test the control buttons, update `TestGui`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行真正的 GUI 测试！为了测试控制按钮，更新`TestGui`：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `controlButtonState()` function, we start by retrieving our buttons by
    using the handy `mMainWindow.findChild()` function. This function is available
    in `QObject`, and the passed name corresponds to the `objectName` variable we
    used for each button in Qt Designer when we created `MainWindow.ui`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`controlButtonState()`函数中，我们首先使用方便的`mMainWindow.findChild()`函数检索我们的按钮。这个函数在`QObject`中可用，并且传递的名称对应于我们在
    Qt Designer 中创建`MainWindow.ui`时为每个按钮使用的`objectName`变量。
- en: Once we retrieve all the buttons, we inject a mouse click event using the `QTest::mouseClick()`
    function. It takes a `QWidget*` parameter as a target and the button that should
    be clicked. You can even pass keyboard modifiers (control, shift, and so on) and
    a possible click delay in milliseconds.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们检索到所有按钮，我们使用`QTest::mouseClick()`函数注入一个鼠标点击事件。它需要一个`QWidget*`参数作为目标以及应该被点击的按钮。你甚至可以传递键盘修饰符（控制、shift
    等）和可能的点击延迟（以毫秒为单位）。
- en: Once the `recordButton` has been clicked, we test the states of all the control
    buttons to make sure that they are in the desired enabled state.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击了`recordButton`，我们就测试所有控制按钮的状态，以确保它们处于期望的启用状态。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: This function can be easily extended to test all the states (`PLAYING`, `STOPPED`, `RECORDING`)
    with a dataset where the input is the desired state and the outputs are the expected
    buttons states.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以很容易地扩展以测试所有状态（`PLAYING`、`STOPPED`、`RECORDING`），其中输入是期望的状态，输出是预期的按钮状态。
- en: 'The `QTest` class offers many useful functions to inject events, including:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTest`类提供了许多有用的函数来注入事件，包括：'
- en: '`keyEvent()`: This function is used to simulate a key event'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyEvent()`: 这个函数用于模拟按键事件'
- en: '`keyPress()`: This function is used to simulate a key press event'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyPress()`: 这个函数用于模拟按键按下事件'
- en: '`keyRelease()`: This function is used to simulate a key release event'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyRelease()`: 这个函数用于模拟按键释放事件'
- en: '`mouseClick()`: This function is used to simulate a key click event'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseClick()`: 这个函数用于模拟鼠标点击事件'
- en: '`mouseDClick()`: This function is used to simulate a mouse double click event'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseDClick()`: 这个函数用于模拟鼠标双击事件'
- en: '`mouseMove()`: This function is used to simulate a mouse move event'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseMove()`: 这个函数用于模拟鼠标移动事件'
- en: Spying on your application with QSignalSpy
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QSignalSpy监视你的应用程序
- en: The last part we will cover in the Qt Test framework is the ability to spy on
    signals with `QSignalSpy`. This class allows you to do introspection of the emitted
    signal of any `QObject`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt测试框架中，我们将要讨论的最后一部分是使用`QSignalSpy`监视信号的能力。这个类允许你对任何`QObject`发出的信号进行内省。
- en: Let's see it in action with `SoundEffectWidget`. We will test that when the `SoundEffectWidget::play()`
    function is called, the `soundPlayed` signal is emitted with the correct `soundId`
    parameter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`SoundEffectWidget`来观察它的实际效果。我们将测试当调用`SoundEffectWidget::play()`函数时，`soundPlayed`信号会带有正确的`soundId`参数被触发。
- en: 'Here is the `playSound()` function of `TestGui`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`TestGui`的`playSound()`函数：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We start by initializing a `SoundEffectWidget` widget and a `QSignalSpy` class.
    The `spy` class's constructor takes the pointer to the object to spy and the pointer
    to the member function of the signal to be watched. Here, we want to check the `SoundEffectWidget::soundPlayed()`
    signal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化一个`SoundEffectWidget`小部件和一个`QSignalSpy`类。`spy`类的构造函数接受要监视的对象的指针以及要监视的信号的成员函数的指针。在这里，我们想检查`SoundEffectWidget::soundPlayed()`信号。
- en: Right after, `widget` is configured with an arbitrary `soundId` (`2`) and `widget.play()`
    is called. This is where it gets interesting:`spy` stores the signal's emitted
    parameters in a `QVariantList`. Each time `soundPlayed()` is emitted, a new `QVariantList`
    is created in `spy`, which contains the emitted parameters.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`widget`被配置了一个任意的`soundId`（`2`）并且调用了`widget.play()`。这里变得有趣的是：`spy`将信号触发的参数存储在`QVariantList`中。每次`soundPlayed()`被触发时，`spy`中都会创建一个新的`QVariantList`，其中包含触发的参数。
- en: The first step is to check that the signal is emitted only once, by comparing
    `spy.count()` to `1`. Just after that, we store the parameters of this signal
    in `arguments` and check that it has the value `2`, the initial `soundId` that `widget`
    was configured with.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检查信号只触发一次，通过比较`spy.count()`与`1`。紧接着，我们将这个信号的参数存储在`arguments`中，并检查它的值是否为`2`，这是`widget`配置的初始`soundId`。
- en: As you can see, `QSignalSpy` is simple to use; you can create as many as you
    need for each signal you want to spy on.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`QSignalSpy`使用简单；你可以为每个你想要监视的信号创建任意数量的实例。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Qt Test module gracefully helps us to easily create a test application.
    You learned to organize your project with a standalone test application. You are
    able to compare and verify a specific value in your simple tests. For your complex
    tests, you could use the datasets. You implemented a simple benchmark, recording
    the time or the CPU ticks required to execute a function. You have simulated GUI
    events and spy Qt signals to ensure that your application works well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 测试模块优雅地帮助我们轻松创建测试应用程序。你学会了如何使用独立的测试应用程序来组织你的项目。你能够比较和验证简单测试中的特定值。对于复杂的测试，你可以使用数据集。你实现了一个简单的基准测试，记录执行函数所需的时间或CPU周期数。你已经模拟了GUI事件并监视Qt信号以确保你的应用程序运行良好。
- en: Your application is created and your unit tests indicates a PASS status. In
    the next chapter, we will learn how to deploy your application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序已经创建，单元测试显示通过状态。在下一章中，我们将学习如何部署你的应用程序。
