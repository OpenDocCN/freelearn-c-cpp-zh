- en: Chapter 12. You Shall (Not) Pass with QTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a drum machine software with some serialization
    feature. In this chapter, we will write the unit tests for this application. To
    achieve this goal, we will use Qt Test, a dedicated test module for Qt applications.
  prefs: []
  type: TYPE_NORMAL
- en: The example project is a test application using CLI commands to execute and
    generate a test report. We will cover different types of tests including datasets,
    GUI, signals, and benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt Test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project layout for unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personalize your test execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write tests with datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmark your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating GUI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform signal introspection with the `QSignalSpy` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering Qt Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt framework provides Qt Test, a complete API to create your unit tests
    in C++. A test executes the code of your application and performs verification
    on it. Usually, a test compares a variable with an expected value. If the variable
    does not match the specific value, the test fails. If you wish to go further,
    you can benchmark your code and get the time/CPU tick/events required by your
    code. Clicking over and over on a GUI to test it can quickly become boring. Qt
    Test offers you the possibility to simulate keyboard entries and mouse events
    on your widgets to completely check your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we want to create a unit test program named `drum-machine-test`.
    This console application will check the code of our famous drum machine from the
    previous chapter. Create a `subdirs` project called `ch12-drum-machine-test` with
    the following topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '`drum-machine`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drum-machine.pro`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drum-machine-test`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drum-machine-test.pro`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch12-drum-machine-test.pro`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drum-machine-src.pri`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `drum-machine` and `drum-machine-test` projects share the same source code.
    So all common files are put in a project include file: `drum-machine-src.pri`.
    Here is the updated `drum-machine.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we only perform a refactoring task; the project drum-machine
    is not affected by the drum-machine-test application. You can now create the `drum-machine-test.pro` file
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that we need to enable the `testlib` module. Then
    even if we are creating a console application, we want to perform a test on the
    GUI so the modules (`gui`, `multimedia`, and `widgets`) used by the primary application
    are also required here. Finally, we include the project include file with all
    application files (sources, headers, forms, and resources). The `drum-machine-test`
    application will also contain new source files, so we must correctly set the `INCLUDEPATH`
    and `DEPENDPATH` variables to the source files folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Test is easy to use and relies on some simple assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: A test case is a `QObject` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private slot is a test function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test case can contain several test functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that the private slots with the following names are not test functions,
    but special functions automatically called to initialize and clean up your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initTestCase()`: This function is called before the first test function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init()`: This function is called before each test function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cleanup()`: This function is called after each test function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cleanupTestCase()`: This function is called after the last test function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alright, we are ready to write our first test case in the `drum-machine-test`
    application. The serialization of the `drum-machine` object is an important part.
    A bad modification on the save feature can easily break the load feature. It can
    produce no errors at compile time, but it can lead to an unusable application.
    That is why tests are important. The first thing is to validate the serialization/deserialization
    process. Create a new C++ class, `DummySerializable`. Here is the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a simple class implementing our `Serializable` interface created in [Chapter
    11](part0104.xhtml#aid-335QG1 "Chapter 11.  Having Fun with Serialization"), *Having
    Fun with Serialization*. This class will be helpful to validate the lower layer
    in our serialization process. As you can see, the class contains some variables
    with various types to ensure a complete functioning serialization. Let''s see
    the file,  `DummySerializable.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'No surprise here; we perform our operation with a `QVariantMap`, as already
    performed in the previous chapter. Our dummy class is ready; create a new C++
    class, `TestJsonSerializer`, with the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are, our first test case! This test case performs verifications on
    our class, `JsonSerializer`. You can see two test functions, `saveDummy()` and `loadDummy()`.
    The `cleanup()` slot is the special Qt Test slot that we covered earlier, which
    is executed after each test function. We can now write the implementation in `TestJsonSerializer.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Two constants are created here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FILENAME`: This is the filename used to test the save and load the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DUMMY_FILE_CONTENT`: This is the referential file content used by the test
    functions, `saveDummy()` and `loadDummy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement the test function, `saveDummy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to instantiate a `DummySerializable` class with some fixed
    values. So, we call the function to test, `JsonSerializer::save()`, that will
    serialize our dummy object in the `test.json` file. Then, we call a helper function, `loadFileContent()`,
    to get the text contained in the `test.json` file. Finally, we use a Qt Test macro, `QVERIFY()`,
    to perform the verification that the text saved by the JSON serializer is the
    same as the expected value in `DUMMY_FILE_CONTENT`. If `data` equals the correct
    value, the test function succeeds. Here is the log output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the data is different than the expected value, the test fails and an error
    is displayed in the console log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s briefly see the helper function, `loadFileContent()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: No big deal here. We open the file, `test.json`, read all the text content,
    and return the corresponding `QString`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The macro, `QVERIFY()`, is great to check a Boolean value, but Qt Test provides
    a better macro when you want to compare data to an expected value. Let''s discover `QCOMPARE()`
    with the test function, `loadDummy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part creates a `test.json` file, with a referential content. Then
    we create an empty `DymmySerializable` and call the function to test `Serializable::load()`.
    Finally, we use the Qt Test macro, `QCOMPARE()`. The syntax is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now test each field of the dummy loaded from JSON. The test function,
    `loadDummmy()`, will only succeed if all `QCOMPARE()` calls succeed. An error
    with a `QCOMPARE()` is much more detailed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time a test function is executed, the special `cleanup()` slot is called.
    Let''s update your file, `TestJsonSerializable.cpp`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple security that will remove the `test.json` file after each test
    function and prevent the save and load tests from colliding.
  prefs: []
  type: TYPE_NORMAL
- en: Executing your tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We wrote a test case, `TestJsonSerializer`, with some test functions. We need
    a `main()` function in our `drum-machine-test` application. We will explore three
    possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QTEST_MAIN()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write our own simple `main()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write our own enhanced `main()` supporting multiple test classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `QTest` module provides an interesting macro, `QTEST_MAIN()`. This macro
    generates a complete `main()` function for your application. This generated method
    runs all the test functions of your test case. To use it, add the following snippet
    at the end of the `TestJsonSerializer.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, if you declare and implement your test class only in the `.cpp` file
    (without a header file), you need to include the generated moc file after the `QTEST_MAIN`
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you use the `QTEST_MAIN()` macro, do not forget to remove the existing `main.cpp`.
    Otherwise, you will have two `main()` functions and a compilation error will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now try to run your drum-machine-test application and look at the application
    output. You should see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test functions, `saveDummy()` and `loadDummy()`, are executed in the declaration
    order. Both succeed with the `PASS` status. The generated test application handles
    some options. Commonly, you can display the help menu executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see some cool features. We can execute only one function with the name.
    The following command only executes the `saveDummy` test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also execute several test functions separating their names with a space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The QTest application provides log detail options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-silent` for silent. Only displays fatal errors and summary messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v1` for verbose. Shows the test function entered information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v2` for extended verbose. Shows each `QCOMPARE()` and `QVERIFY()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-vs` for verbose signal. Shows the emitted signal and the connected slot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we can display details of the execution of `loadDummy` with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another great feature is the logging output format. You can create a test report
    file with various formats `(.txt`, `.xml`, `.csv`, and so on). The syntax requires
    a filename and a file format separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we create an XML report named `test-report.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that some log level affects only the plain text output. Moreover, the
    CSV format can be used only with the test macro `QBENCHMARK`, which is covered
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to customize the generated test application, you can write the
    `main()` function. Remove the `QTEST_MAIN` macro in `TestJsonSerializer.cpp`.
    Then create a `main.cpp` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using the static function, `QTest::qExec()`, to start a `TestJsonSerializer`
    test. Do not forget to provide the command-line arguments to enjoy the QTest CLI
    options.
  prefs: []
  type: TYPE_NORMAL
- en: If you wrote your test functions in different test classes, you would have created
    one application by a test class. If you keep one test class by test application
    you can even use the `QTEST_MAIN` macro to generate the main functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you want to create only one test application to handle all your test
    classes. In this case, you have multiple test classes in the same application,
    so you cannot use the `QTEST_MAIN` macro because you do not want to generate several
    main functions for each test class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple way to call all your test classes in a unique application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this simple custom `main()` function, we are executing the `TestFoo` and `TestBar`
    tests. But we are losing the CLI options. Indeed, executing the `QTest::qExec()`
    function with command-line arguments more than once will lead to errors and bad
    behaviors. For example, if you want to execute only one specific test function
    from `TestBar`. The execution of `TestFoo` will not find the test function, display
    an error message, and stop the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a workaround to handle several test classes in a unique application.
    We will create a new CLI option, `-select`, to our test application. This option
    allows you to select a specific test class to execute. Here is a syntax example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `-select` option, if used, must be at the beginning of the command followed
    by the test class name (`foo` in this example). Then, we can optionally add Qt
    Test options. To achieve this goal, we will create an enhanced `main()` function
    that parses the new `select` option and execute the corresponding test class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create our enhanced `main()` function together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QApplication` will be required later by our other GUI test cases. We retrieve
    the command line arguments for later use. The `std::map` template named `tests`
    contains the smart pointers of the test classes and a `QString` label is used
    as a key. Notice that we are using the `map::emplace()` function that does not
    copy the source to the map, but creates it in place. Using the `map::insert()`
    function leads to an error due to the illegal copy of a smart pointer. Another
    syntax that could be used with a `std::map` template and a `make_unique` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now parse the command line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `-select` option is used, this snippet performs two important tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Removes from the map `tests`, the test classes that do not match the test name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes the arguments from the `-select` option and the `testName` variable
    to provide cleaned arguments to the `QTest::qExec()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now add the final step to execute the test classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Without the `-select` option, all the test classes will be performed. If we
    use the `-select` option with a test class name, only this one will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Writing factorized tests with datasets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now turn our attention to testing the `Track` class. We will focus specifically
    on the different states a `Track` class can have: `STOPPED`, `PLAYING`, and `RECORDING`.
    For each one of these states, we want to make sure that adding `SoundEvents` works
    only if we are in the proper state (`RECORDING`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we could write the following test functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testAddSoundEvent()`: This function puts the `Track` in the `STOPPED` state,
    calls `track.addSoundEvent(0)`, and checks `track.soundEvents().size == 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testAddSoundEvent()`: This function puts the `Track` in the `PLAYING` state,
    calls `track.addSoundEvent(0),` and checks `track.soundEvents().size == 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testAddSoundEvent()`: This function puts the `Track` in the `RECORDING` state,
    calls `track.addSoundEvent(0)`, and checks `track.soundEvents().size == 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, the logic is the same, we simply change the inputs and the
    desired outputs. To factorize this, Qt Test provides another module: datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dataset can be seen as a two-dimensional table where each row is a test,
    and the columns are the inputs and expected outputs. For our `Track` state test,
    it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing factorized tests with datasets](img/image00445.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this approach, you write a single `addSoundEvent()` test function and Qt
    Test takes care of iterating over this table and comparing the result. Right now,
    it seems like magic. Let's implement it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class named `TestTrack`, following the same pattern used for
    the `TestJsonSerializer` class (inherits `QObject`, includes `QTest`). Update `TestTrack.h`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we added two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addSoundEvent_data()`: This is the function that fills the dataset for the
    real test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addSoundEvent()`: This is the function that executes the test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, the function that fills the dataset for a given `xxx()` function
    must be named `xxx_data()`. Let''s see the implementation of `addSoundEvent_data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a dataset is constructed like a table. We start by defining
    the structure of the table with the `trackState` and `soundEventCount` columns.
    Note that `QTest::addColumn` relies on templating to know the type of the variable
    (`int` in both cases).
  prefs: []
  type: TYPE_NORMAL
- en: After that, a row is appended to the table with the `QTest::newRow()` function,
    with the name of the test passed as a parameter. The `QTest::newRow` syntax supports
    the `<<` operator, making it very easy to pack all the data for a given row.
  prefs: []
  type: TYPE_NORMAL
- en: Note that each row added to the dataset corresponds to an execution of the `addSoundEvent()`
    function in which the data of the row will be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now turn our attention to `addSoundEvent()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `addSoundEvent()` is executed by QTest and is fed with the dataset
    data, we can safely access the current row of the dataset like we would do with
    a cursor on a database. The `QFETCH(int, trackState)` is a helpful macro that
    does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Declares an `int` variable named `trackState`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetches the current column index data of the dataset and stores its content
    in `trackState`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same principle is applied to `soundEventCount`. Now that we have our desired
    track state and the expected sound events count, we can proceed to the real test:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the track in the proper state according to `trackState`. Remember that the `Track::setState()`
    function is private, because the `Track` keyword handles the `trackState` variable
    alone, based on the caller instruction (`stop()`, `play()`, `record()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to add a `SoundEvent` to track.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the track.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the number of `SoundEvents` in track to what is expected in `soundEventCount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do not forget to add the `TestTrack` class in `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the tests and see the three tests of `addSoundEvent()` output
    their result in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Datasets make the writing of tests less dull, by factorizing variations of data
    for a single test.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run a single test for a specific entry of a dataset using the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we want to execute the test function `addSoundEvent()` from `TestTrack`
    with only the `RECORDING` state. Here is the command line to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Benchmarking your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Test also provides a very easy to use semantic to benchmark the execution
    speed of your code. To see it in action, we will benchmark the time it takes to
    save a `Track` in the JSON format. Depending on the track length (the number of `SoundEvents`),
    the serialization should take more or less time.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is more interesting to benchmark this feature with different track
    lengths and see if the time saving is linear. Datasets come to the rescue! It
    is not only useful to run the same function with expected inputs and outputs,
    but also to run the same function with different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating the dataset function in `TestJsonSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `saveTrack_data()` function simply stores the number of `SoundEvent` to
    be added to a `Track` class before it is saved. The `"1"`, `"100",` and `"1000"`
    strings are here to have a clear label in the test execution output. These strings
    will be displayed in each execution of `saveTrack()`. Feel free to tweak these
    numbers!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the real test with the benchmark call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `saveTrack()` function starts by fetching the `soundEventCount` column from
    its dataset. After that, it adds the correct number of `soundEvent` (with the
    proper `record()` state!) and finally benchmarks the serialization in the JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the benchmark itself is simply a macro that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The instructions enclosed in the `QBENCHMARK` macro will be measured automatically.
    If you execute the test with the updated `TestJsonSerializer` class, you should
    see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `QBENCHMARK` macro makes Qt Test output very interesting
    data. To save a `Track` class with a single `SoundEvent`, it took 0.041 milliseconds.
    Qt Test repeated this test 2048 times and it took a total of 84 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The power of the `QBENCHMARK` macro starts to be visible in the following test.
    Here, the `saveTrack()` function tried to save a `Track` class with 100 `SoundEvents`.
    It took 0.23 milliseconds to do it and it repeated the instruction 256 times.
    This shows you that the Qt Test benchmark automatically adjusts the number of
    iterations based on the average time a single iteration takes.
  prefs: []
  type: TYPE_NORMAL
- en: The `QBENCHMARK` macro has this behavior because a metric tends to be more accurate
    if it is repeated multiple times (to avoid possible external noise).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your test to be benchmarked without multiple iterations, use `QBENCHMARK_ONCE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute the test using the command line, you can provide additional
    metrics to `QBENCHMARK`. Here is the table recapitulating the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Command-line argument** | **Availability** |'
  prefs: []
  type: TYPE_TB
- en: '| Walltime | (default) | All platforms |'
  prefs: []
  type: TYPE_TB
- en: '| CPU tick counter | `-tickcounter` | Windows, OS X, Linux, many UNIX-like
    systems. |'
  prefs: []
  type: TYPE_TB
- en: '| Event Counter | `-eventcounter` | All platforms |'
  prefs: []
  type: TYPE_TB
- en: '| Valgrind Callgrind | `-callgrind` | Linux (if installed) |'
  prefs: []
  type: TYPE_TB
- en: '| Linux Perf | `-perf` | Linux |'
  prefs: []
  type: TYPE_TB
- en: 'Each one of these options will replace the selected backend used to measure
    the execution time of the benchmarked code. For example, if you run `drum-machine-test`
    with the `-tickcounter` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the wall time, measured in milliseconds, has been replaced
    by the number of CPU cycles completed for each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting option is `-eventcounter`, which measures the numbers that
    were received by the event loop before they are sent to their corresponding target.
    This could be an interesting way of checking that your code emits the proper number
    of signals.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to see how you can test your GUI using the Qt Test API. The `QTest`
    class offers several functions to simulate keys and mouse events.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate it, we will stay with the notion of testing a `Track` state,
    but on an upper level. Rather than testing the `Track` state itself, we will check
    that the UI state of the `drum-machine` application is properly updated when the `Track`
    state is changed. Namely, the control buttons (play, stop, record) should be in
    a specific state when a recording is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `TestGui` class in the `drum-machine-test` project. Do
    not forget to add the `TestGui` class in the `tests` map of `main.cpp`. As usual,
    make it inherit `QObject` and update `TestGui.h` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this header, we have a member, `mMainWindow`, which is an instance of the `MainWindow`
    keyword from the `drum-machine` project. Throughout the tests of `TestGui`, a
    single `MainWindow` will be used, in which we will inject events and check how
    it reacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to the `TestGui` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The constructor initializes the `mMainWindow` variable. Notice that `mMainWindow`
    is never shown (using `mMainWindow.show()`). We do not need to display it, we
    solely want to test its states.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use a rather obscure function call (`QTestEventLoop` is not documented
    at all) to force the event loop to be started after 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we have to do this lies in the `QSoundEffect` class. The `QSoundEffect`
    class is initialized when the `QSoundEffect::setSource()` function is called (in `MainWindow`,
    this is done at the initialization of the `SoundEffectWidgets`). If we omit the
    explicit `enterLoop()` call, the `drum-machine-test` execution will crash with
    a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: It seems that the event loop has to be explicitly entered to let the `QSoundEffect`
    class properly complete its initialization. We found this undocumented workaround
    by studying the Qt unit tests of the `QSoundEffect` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the real GUI test! To test the control buttons, update `TestGui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the `controlButtonState()` function, we start by retrieving our buttons by
    using the handy `mMainWindow.findChild()` function. This function is available
    in `QObject`, and the passed name corresponds to the `objectName` variable we
    used for each button in Qt Designer when we created `MainWindow.ui`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we retrieve all the buttons, we inject a mouse click event using the `QTest::mouseClick()`
    function. It takes a `QWidget*` parameter as a target and the button that should
    be clicked. You can even pass keyboard modifiers (control, shift, and so on) and
    a possible click delay in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `recordButton` has been clicked, we test the states of all the control
    buttons to make sure that they are in the desired enabled state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function can be easily extended to test all the states (`PLAYING`, `STOPPED`, `RECORDING`)
    with a dataset where the input is the desired state and the outputs are the expected
    buttons states.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QTest` class offers many useful functions to inject events, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keyEvent()`: This function is used to simulate a key event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyPress()`: This function is used to simulate a key press event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyRelease()`: This function is used to simulate a key release event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseClick()`: This function is used to simulate a key click event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseDClick()`: This function is used to simulate a mouse double click event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseMove()`: This function is used to simulate a mouse move event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spying on your application with QSignalSpy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last part we will cover in the Qt Test framework is the ability to spy on
    signals with `QSignalSpy`. This class allows you to do introspection of the emitted
    signal of any `QObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see it in action with `SoundEffectWidget`. We will test that when the `SoundEffectWidget::play()`
    function is called, the `soundPlayed` signal is emitted with the correct `soundId`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `playSound()` function of `TestGui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We start by initializing a `SoundEffectWidget` widget and a `QSignalSpy` class.
    The `spy` class's constructor takes the pointer to the object to spy and the pointer
    to the member function of the signal to be watched. Here, we want to check the `SoundEffectWidget::soundPlayed()`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: Right after, `widget` is configured with an arbitrary `soundId` (`2`) and `widget.play()`
    is called. This is where it gets interesting:`spy` stores the signal's emitted
    parameters in a `QVariantList`. Each time `soundPlayed()` is emitted, a new `QVariantList`
    is created in `spy`, which contains the emitted parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to check that the signal is emitted only once, by comparing
    `spy.count()` to `1`. Just after that, we store the parameters of this signal
    in `arguments` and check that it has the value `2`, the initial `soundId` that `widget`
    was configured with.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `QSignalSpy` is simple to use; you can create as many as you
    need for each signal you want to spy on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt Test module gracefully helps us to easily create a test application.
    You learned to organize your project with a standalone test application. You are
    able to compare and verify a specific value in your simple tests. For your complex
    tests, you could use the datasets. You implemented a simple benchmark, recording
    the time or the CPU ticks required to execute a function. You have simulated GUI
    events and spy Qt signals to ensure that your application works well.
  prefs: []
  type: TYPE_NORMAL
- en: Your application is created and your unit tests indicates a PASS status. In
    the next chapter, we will learn how to deploy your application.
  prefs: []
  type: TYPE_NORMAL
