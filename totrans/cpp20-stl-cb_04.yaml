- en: '*Chapter 4*: Compatible Iterators'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterators are a fundamental concept in the STL. Iterators are implemented with
    the semantics of C pointers, using the same increment, decrement, and dereference
    operators. The pointer idiom is familiar to most C/C++ programmers, and it allows
    *algorithms* such as `std::sort` and `std::transform` to work on primitive memory
    buffers as well as STL containers.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are fundamental
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The STL uses iterators to navigate the elements of its container classes. Most
    containers include `begin()` and `end()` iterators. These are usually implemented
    as member functions that return an iterator object. The `begin()` iterator points
    to the initial container element, and the `end()` iterator points *past* the final
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The begin() and end() iterators'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – The begin() and end() iterators
  prefs: []
  type: TYPE_NORMAL
- en: The `end()` iterator may function as a *sentinel* for containers of indeterminate
    length. We'll see some examples of that in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most STL containers define their own specific *iterator type*. For example,
    for a `vector` of `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterator type would be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how this could easily get out of hand. If we had a `vector` of
    `vector` of `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Its iterator type would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, C++11 gave us automatic type deduction and the `auto` type. By
    using `auto`, we rarely need to use the full iterator type definition. For example,
    if we need an iterator in a `for` loop, we can use the `auto` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the dereference operator `*` to access the elements from
    the iterator. This is the same syntax you would use to dereference a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means that you can use a range-based `for` loop with either a primitive
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with an STL container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The range-based `for` loop is just a shorthand for a `for` loop with iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because iterators use the same syntax as a primitive pointer, the range-based
    `for` loop works the same with either container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the range-based `for` loop calls `std::begin()` and `std::end()`,
    instead of directly calling the `begin()` and `end()` member functions. The `std::`
    functions call the member functions to get the iterators. So, why not just call
    the member functions? The `std::` non-member functions are designed to also work
    with primitive arrays. That''s why a `for` loop works with an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For most purposes, I tend to favor the member function `begin()` and `end()`
    because they are more explicit. Others favor the `std::` non-member functions
    because they are more general. Six or half-dozen; I suggest you pick a style and
    stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to C++20, iterators were divided into categories based on their capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18267_04_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These categories are hierarchical, where the more capable iterators inherit
    the capabilities of the less capable iterators. In other words, the *input iterator*
    can read and increment once. The *forward iterator* has the capabilities of the
    Input Iterator *plus* it can increment multiple times. The *bidirectional iterator*
    has those capabilities *plus* it can decrement. And on down the list.
  prefs: []
  type: TYPE_NORMAL
- en: The *output iterator* can write and increment once. If any of the other iterators
    can also write, it is considered a *mutable iterator*.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Concepts* and *constraints* are new with C++20\. A concept is simply a named
    constraint that restricts the types of arguments to a template function or class,
    and helps the compiler choose appropriate specializations.'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with C++20, the STL defines iterators in terms of concepts instead
    of categories. Each of these concepts are in the `std::` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18267_04_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use these concepts to constrain the arguments of a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function requires a `random_access_iterator`. If I call it with a `list`,
    which is not a random-access container, the compiler will give me an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `list` iterator type does not support the `random_access_iterator` concept.
    So, the compiler gives me an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is the error output from GCC. Your errors may look different.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I call it with a `vector`, which is a random-access container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it compiles and runs without error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While there are different types of iterators for different types of capabilities
    (and concepts), the complexity is there to support of ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this introduction to iterators, let''s now proceed with the following
    recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an iterable range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your iterators compatible with STL iterator traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use iterator adapters to fill STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a generator as iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use reverse iterator adapters to iterate backward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate objects of unknown length with a sentinel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a zip iterator adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a random-access iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04).
  prefs: []
  type: TYPE_NORMAL
- en: Create an iterable range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes a simple class that generates an iterable range, suitable
    for use with the range-based `for` loop. The idea is to create a *sequence generator*
    that iterates from a beginning value to an ending value.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this task, we need an iterator class, along with the object interface
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's two major parts to this recipe, the main interface, `Seq`, and the `iterator`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define the `Seq` class. It only needs to implement the `begin()`
    and `end()` member functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The constructor sets up the `start_` and `end_` variables. These are used to
    construct the `begin()` and `end()` iterators, respectively. The member functions
    `begin()` and `end()` return `iterator` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iterator` class is normally defined inside the public section of the container
    class. This is called a *member class* or a *nested class*. We''ll insert it right
    after the `Seq` constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's traditional to name the iterator class `iterator`. This allows it to be
    referenced as `Seq<`*type*`>::iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: The `iterator` constructor is qualified `explicit` to avoid implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The `value_` variable is maintained by the iterator. This is used to return
    a value from the pointer dereference.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum requirement for supporting the range-based `for` loop is a dereference
    operator `*`, a pre-increment operator `++`, and the not-equal comparison operator
    `!=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write a `main()` function to test our sequence generator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This constructs a `Seq` object and prints out its sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The point of this recipe is to make a sequence generator that works with a
    range-based `for` loop. Let''s first consider the equivalent code for the range-based
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From this equivalent code, we can deduce the requirements for an object to
    work with the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`begin()` and `end()` iterators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator support for the not-equal comparison `!=` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator support for the prefix increment `++` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator support for the dereference `*` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our main `Seq` class interface only has three public member functions: the
    constructor, and the `begin()` and `end()` iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `Seq::iterator` class carries the actual payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the common configuration because the payload is only accessed through
    iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve implemented only the three operators we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need to support the range-based `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s traditional, but not required, to define the iterator as a member class
    of the container. This allows the `iterator` type to be subordinate to the container
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It's not as important post C++11 because of the `auto` type, but it's still
    considered best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Make your iterators compatible with STL iterator traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many STL algorithms require iterators to conform to certain traits. Unfortunately,
    these requirements are inconsistent across compilers, systems, and C++ versions.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we'll use the class from the *Create an iterable range* recipe
    to illustrate the issue. You may find this makes more sense if you read that recipe
    before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, if I add a call to the `minmax_element()` algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It does not compile. The error messages are vague, cryptic, and cascading, but
    if you look closely, you'll see that our iterator does not meet the requirements
    to be compatible with this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to make a few simple additions to our iterator to make it compatible
    with the algorithm. Our iterator needs to meet the minimum requirements for a
    *forward iterator*, so let''s start there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have almost all the operators necessary for a forward iterator. The only
    one we''re missing is the equality comparison operator `==`. We can easily add
    this to our iterator with an `operator==()` overload:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Interestingly, this makes the code compile and run on some systems, but not
    on *Clang*, where we get the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This tells me that we need to set up the traits in the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iterator_traits` class looks for a set of *type definitions* (implemented
    as `using` aliases) in the `iterator` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I tend to put these at the top of the `public:` section of the `iterator` class,
    where they'll be easy to see.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a fully conforming *forward iterator* class, and the code runs on
    all the compilers I have.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `using` statements are traits that may be used to define what capabilities
    the iterator can perform. Let''s look at each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first two are the *category* and the *concept*, and both are set to `forward_iterator_tag`.
    This value indicates that the iterator conforms to the forward iterator specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some code doesn''t look at those values, and instead looks for individual settings
    and capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `value_type` alias is set to `std::remove_cv_t<T>`, which is the type of
    the value, with any `const` qualifier removed.
  prefs: []
  type: TYPE_NORMAL
- en: The `difference_type` alias is set to `std::ptrdiff_t`, as special type for
    pointer differences.
  prefs: []
  type: TYPE_NORMAL
- en: The `pointer` and `reference` aliases are set to `const`-qualified versions
    of the pointer and reference, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Defining these type aliases is a basic requirement for most iterators.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s worth noting that defining these traits allows us to use concept-restricted
    templates with our iterator. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function that prints our sequence is restricted by the `forward_iterator`
    concept. If our class did not qualify, it wouldn't compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `ranges::` versions of the algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This makes it more convenient to use our iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test for `forward_range` compatibility with a static assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Use iterator adapters to fill STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iterator is essentially an abstraction. It has a specific interface and is
    used in specific ways. But beyond that, it's just code and it can be used for
    other purposes. An *iterator adapter* is a class that looks like an iterator but
    does something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL comes with an assortment of iterator adapters. Often used with the
    `algorithm` library, they are quite useful. The STL iterator adaptors generally
    fall into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert iterators**, or *inserters*, are used to insert elements into a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream iterators** read from and write to a stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse iterators** reverse the direction of an iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll look at a few examples of STL iterator adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a simple function to print the contents of a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `printc()` function allows us to easily view the results of our algorithms.
    It includes an optional `string_view` argument for a description.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function, we''ll define a couple of `deque` containers. We''re
    using `deque` containers so we can insert at both ends:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We defined deque `d1` with five `int` values, and `d2` with space for the same
    number of elements. The `copy()` algorithm will not allocate space, so `d2` must
    have room for the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copy()` algorithm takes three iterators: the *begin* and *end* iterators
    indicate the range of elements to copy from, and the *begin* iterator of the destination
    range. It does not check the iterators to make sure they''re valid. (Try this
    without allocating space in a `vector` and you''ll get a *segmentation fault*
    error.)'
  prefs: []
  type: TYPE_NORMAL
- en: We call `printc()` on both containers to show the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copy()` algorithm is not always convenient for this. Sometimes you want
    to copy and add elements to the end of a container. It would be nice to have an
    algorithm that calls `push_back()` for each element. This is where an iterator
    adapter is useful. Let''s add some code at the end of `main()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`back_inserter()` is an *insert iterator adapter* that calls `push_back()`
    for each item assigned to it. You can use it anywhere an output iterator is expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a `front_inserter()` adapter for when you want to insert at the
    front of a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `front_inserter()` adapter inserts elements at the front using the container's
    `push_front()` method. Notice that the elements in the destination are reversed,
    because each element is inserted before the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to insert in the middle, we can use the `inserter()` adapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `inserter()` adapter takes an iterator for the insertion begin point.
  prefs: []
  type: TYPE_NORMAL
- en: '*Stream iterators* are convenient for reading from and writing to `iostream`
    objects, this is `ostream_iterator()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is `istream_iterator()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `istream_iterator()` adapter will return an end iterator by default, if
    no stream is passed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reverse adapters* are included with most containers, as function members `rbegin()`
    and `rend()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The iterator adapters work by wrapping around an existing container. When you
    call an adapter, like `back_inserter()` with a container object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The adapter returns an object that *mimics* an iterator, in this case a `std::back_insert_iterator`
    object, which calls the `push_back()` method on the container object each time
    a value is assigned to the iterator. This allows the adapter to be used in place
    of an iterator, while performing its useful task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `istream_adapter()` also requires a *sentinel*. A sentinel signals the
    end of an iterator of indeterminate length. When you read from a stream, you don''t
    know how many objects are in the stream until you hit the end. When the stream
    hits the end, the sentinel will compare equal with the iterator, signaling the
    end of the stream. The `istream_adapter()` will create a sentinel when it''s called
    without a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to test for the end of a stream, as you would with any container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Create a generator as iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *generator* is an iterator that generates its own sequence of values. It does
    not use a container. It creates values on the fly, returning one at a time as
    needed. A C++ generator stands on its own; it does not need to wrap around another
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll build a generator for a *Fibonacci sequence*. This is
    a sequence where each number is the sum of the previous two numbers in the sequence,
    starting with 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Definition of a Fibonacci sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Definition of a Fibonacci sequence
  prefs: []
  type: TYPE_NORMAL
- en: 'The first ten values of the Fibonacci sequence, not counting zero, are: 1,
    1, 2, 3, 5, 8, 13, 21, 34, 55\. This is a close approximation of the *golden ratio*
    found in nature.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Fibonacci sequence is often created with a *recursive loop*. Recursion in
    a generator can be difficult and resource-intensive, so instead we'll just save
    the previous two values in the sequence and add them together. This is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s define a function to print the sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've used this `printc()` function before. It prints an iterable range, along
    with a description string, if provided.
  prefs: []
  type: TYPE_NORMAL
- en: Our class begins with a *type alias*, and a few object variables, all in the
    `private` section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `stop_` variable will be used later as a *sentinel*. It's set to the number
    of values to generate. `count_` is used to keep track of how many values we've
    generated. `a_` and `b_` are the previous two sequence values, used for calculating
    the next value.
  prefs: []
  type: TYPE_NORMAL
- en: Still in the `private` section, we have a simple function for calculating the
    next value in the Fibonacci sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now in the `public` section, we have a simple constructor with a default value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This constructor is used without an argument to create a sentinel. The `stop`
    argument initializes the `stop_` variable to represent how many values to generate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the public functions are the operator overloads expected of a *forward
    iterator*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's also a simple `size()` function which can be useful if you need to initialize
    a target container for a copy operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the generator in our main function with a simple call to `printc()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates an anonymous `fib_generator` object to pass to the `printc()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get this output with the first 10 Fibonacci numbers, not including zero:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fib_generator` class operates as a forward iterator, simply because it
    provides all the necessary interface functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As far as the range-based `for` loop is concerned, this is an iterator because
    it looks like an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value is calculated in the `do_fib()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This simply adds `b_ += a_`, stores the result in `b_` and the old `b_` in `a_`,
    setting it up for the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dereference operator `*` returns the value from `b_`, which is the next
    value in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `end()` function creates an object where the `count_` variable is equal
    to the `stop_` variable, creating a *sentinel*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the equality comparison operator can easily detect the end of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to make our generator work with the `algorithm` library, we need
    to provide the `traits` aliases. These go at the top of the `public` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use our generator with algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `ranges::views` version of the `transform()` algorithm to square
    every value. The resulting object can be used wherever you can use an iterator.
    We get this output from the `printc()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Use reverse iterator adapters to iterate backward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *reverse iterator adapter* is an abstraction that reverses the direction of
    an iterator class. It requires a bidirectional iterator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most bidirectional containers in the STL include a reverse iterator adapter.
    Other containers, such as the primitive C-array, do not. Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `printc()` function we''ve used throughout this chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses a range-based `for` loop to print the elements of a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The range-based `for` loop works even with primitive C-arrays, which have no
    iterator class. So, our `printc()` function already works with a C-array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `begin()` and `end()` iterator adapters to create normal forward
    iterators for the C-array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output from the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use the `rbegin()` and `rend()` reverse iterator adapters to create
    reverse iterators for the C-array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now our output is reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even create a modified version of `printc()` that prints in reverse:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we call it with the C-array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this works just as well with any bidirectional STL container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A normal iterator class has a `begin()` iterator that points to the first element,
    and an `end()` iterator that points *past* the last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Forward iterator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Forward iterator
  prefs: []
  type: TYPE_NORMAL
- en: You iterate the container by incrementing the `begin()` iterator with the `++`
    operator, until it reaches the value of the `end()` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'A reverse iterator adapter *intercepts the iterator interface* and turns it
    around so the `begin()` iterator points at to the last element, and `end()` iterator
    points *before* the first element. The `++` and `--` operators are also inverted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Reverse iterator adapter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Reverse iterator adapter
  prefs: []
  type: TYPE_NORMAL
- en: In the reversed iterator, the `++` operator decrements and the `--` operator
    increments.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that most bidirectional STL containers already include a
    reverse iterator adapter, accessible by member functions `rbegin()` and `rend()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: These iterators will operate in reverse and are suitable for many purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Iterate objects of unknown length with a sentinel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some objects don't have a specific length. To know their length, you need to
    iterate through all their elements. For example, elsewhere in this chapter we've
    seen a *generator* that doesn't have a specific length. A more common example
    would be a *C-string*.
  prefs: []
  type: TYPE_NORMAL
- en: A C-string is a primitive C-array of characters, terminated with a null `'\0'`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A C-string with its null terminator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – A C-string with its null terminator
  prefs: []
  type: TYPE_NORMAL
- en: 'We use C-strings all the time, even if we don''t realize it. Any *literal*
    string in C/C++ is a C-string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the STL string `s` is initialized with a literal string. The literal
    string is a C-string. If we look at the individual characters in hexadecimal,
    we''ll see the null terminator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The word "string" has six letters. The output from our loop shows seven elements
    in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The seventh element is the null terminator.
  prefs: []
  type: TYPE_NORMAL
- en: The loop sees the primitive C-array of characters, with seven values. The fact
    that it's a string is an abstraction invisible to the loop. If we want the loop
    to treat it like a string, we'll need an *iterator* and a *sentinel*.
  prefs: []
  type: TYPE_NORMAL
- en: A *sentinel* is an object that signals the end of an iterator of indeterminate
    length. When the iterator hits the end of the data, the sentinel will compare
    equal with the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, let's build an iterator for C-strings!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use a sentinel with a C-string, we need to build a custom iterator. It doesn't
    need to be complicated, just the essentials for use with a range-based `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a couple of convenience definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `using` alias for `sentinel_t` is `const char`. We'll use this for the sentinel
    in our class.
  prefs: []
  type: TYPE_NORMAL
- en: We also define the constant `nullchar` for the null character terminator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define our iterator type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is short and simple. It's the minimum necessary for a range-based `for`
    loop. Notice the `end()` function returns a `nullchar` and the `operator!=()`
    overload compares against the `nullchar`. That's all we need for the sentinel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define a function for printing our C-string using the sentinel:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function we first print the string. Then we use the `format()` function
    to print each individual character as a hexadecimal value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can call `print_cstr()` from our `main()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there are no extraneous characters and no null terminators. This
    is because our sentinel tells the for loop to stop when it sees the `nullchar`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sentinel part of the iterator class is very simple. We can easily use the
    null terminator as the sentinel value by returning it in the `end()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the not-equal comparison operator can test for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the parameter is just a type (`sentinel_t`). A parameter type is
    necessary for the function signature, but we don't need the value. All that's
    necessary is to compare the current iterator with the sentinel.
  prefs: []
  type: TYPE_NORMAL
- en: This technique should be useful whenever you have a type or class that doesn't
    have a predetermined end point for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Build a zip iterator adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many scripting languages include a function for *zipping* two sequences together.
    A typical zip operation will take two input sequences and return a pair of values
    for each position in both inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the case of two sequences – they can be containers, iterators, or
    initialization lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Containers to be zipped'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Containers to be zipped
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to *zip* them together to make a new sequence with pairs of elements
    from the first two sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Zip operation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Zip operation
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will accomplish this task with an iterator adapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we''ll build a zip iterator adapter that takes two containers
    of the same type and zips the values into `std::pair` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function we want to call our adapter with two vectors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to use the `zip_iterator` in place of the individual `vector`
    iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we expect an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Our iterator adapter is in a class called `zip_iterator`. We''ll start with
    some type aliases for convenience:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These allow us to conveniently define objects and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t store any data in our iterator. We only store copies of the target
    containers'' `begin()` and `end()` iterators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ita_` and `itb_` are iterators from the target containers. The other four
    iterators are used to generate the `begin()` and `end()` iterators for the `zip_iterator`
    adapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a private constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is used later to construct adapter objects specifically for `begin()` and
    `end()` iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `public` section, we start with the iterator *traits* type definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor sets up all the private iterator variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the minimum operator overloads to work with a forward iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the `begin()` and `end()` functions return the respective iterators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are made simple by the stored iterators and the private constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s expand our `main()` function for testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the output we''re looking for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *zipped iterator adapter* is an example of how flexible the iterator abstraction
    can be. We can take the iterators of two containers and use them in one aggregated
    iterator. Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: The main constructor for the `zip_iterator` class takes two container objects.
    For the purposes of this discussion, we'll refer to these objects as the *target*
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The constructor initializes the `ita_` and `itb_` variables from the target
    `begin()` iterators. These will be used to navigate the target objects. The target
    `begin()` and `end()` iterators are also saved for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'These variables are defined in the private section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `it_t` type is defined as the type of the target iterator class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The other aliased types are `val_t` for the type of the target value, and `ret_t`
    for the return `pair`. These type definitions are used for convenience throughout
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `begin()` and `end()` functions use a private constructor that only initializes
    the `ita_` and `itb_` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The `private` constructor looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This is a constructor that takes `it_t` iterators for parameters. It only initializes
    `ita_`and `itb_` so they can be used in the comparison operator overloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the class just acts like a normal iterator, but it''s operating
    on iterators from the target class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The dereference operator returns a `std::pair` object (`ret_t` is an alias for
    `std::pair<val_t, val_t>`). This is the interface for retrieving a value from
    the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `zip_iterator` adapter can be used to easily zip objects into a `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add this code to `main()`, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Create a random-access iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is an example of a full-featured contiguous/random-access iterator.
    This is the most complete type of iterator for a container. A random-access iterator
    includes all the features of all the other types of container iterators, along
    with its random-access capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: While I felt it important to include a complete iterator in this chapter, with
    over 700 lines of code this example is somewhat larger than the other examples
    in this book. I'll cover the essential components of the code here. Please see
    the full source at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a container for our iterator. We'll use a simple array for this, and
    we'll call it `Container`. The `iterator` class is nested within the `Container`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is designed to be consistent with the STL container interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '`Container` is defined as a `template` class. Its `private` section has only
    two elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use a `unique_pointer` for the data. We let the *smart pointer* manage its
    own memory. This mitigates the need for a `~Container()` destructor. The `n_elements_`
    variable keeps the size of our container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the public section, we have our constructors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first constructor uses an `initializer_list` to pass elements for the container.
    We call `make_unique` to allocate space and populate the container with a range-based
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a constructor that allocates space without populating the elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `make_unique()` function constructs empty objects for element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `size()` function returns the number of elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `operator[]()` function returns an indexed element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `at()` function returns an indexed element *with bounds checking*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is consistent with STL usage. The `at()` function is the preferred method.
  prefs: []
  type: TYPE_NORMAL
- en: The `begin()` and `end()` functions call the iterator constructor with the address
    of the container data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `unique_ptr::get()` function returns the address from the smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The `iterator` class is nested within the `Container` class as a `public` member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The iterator class has one private member, a pointer that's initialized in the
    `begin()` and `end()` methods of the Container class.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator constructor takes a pointer to the container data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We provide a default value because the standard requires a default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This iterator provides operator overloads for the following operators: `++`,
    *postfix* `++`, `--`, *postfix* `--`, `[]`, *default comparison* `<=>` *(C++20)*,
    `==`, `*`, `->`, `+`, *non-member* `+`, *numeric* `-`, *object* `-`, `+=`, and
    `-=`. We''ll cover a few notable overloads here. See the source code for all of
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++20 default comparison operator `<=>` provides the functionality of the
    full suite of comparison operators, except the equality `==` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a C++20 feature, so it requires a compliant compiler and library.
  prefs: []
  type: TYPE_NORMAL
- en: There are two `+` operator overloads. These support *it + n* and *n + it* operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `friend` declaration is a special case. When used in a template class member
    function, it's the equivalent of a non-member function. This allows a non-member
    function to be defined in the class context.
  prefs: []
  type: TYPE_NORMAL
- en: The `-` operator also has two overloads. We need to support both a numeric operand
    and an iterator operand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows both *it – n* and *it – it* operations. There's no need for a non-member
    function, as *n – it* is not a valid operation.
  prefs: []
  type: TYPE_NORMAL
- en: Validation code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C++20 specification §23.3.4.13 requires a specific set of operations and
    results for a valid random-access iterator. I've included a `unit_tests()` function
    in the source code to validate those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function creates a `Container` object and performs some simple
    validation functions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a `Container<string>` object `x` with ten values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output gives the number of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We display the elements of the container with a range-based `for` loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we test several direct access methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We test the container with a `ranges::views` pipe and `views::reverse`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `Container` object `y` with 10 uninitialized elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it's a lot of code, this iterator is no more complicated than a smaller
    iterator. Most of the code is in the operator overloads, which are mostly one
    or two lines of code each.
  prefs: []
  type: TYPE_NORMAL
- en: The container itself is managed by a *smart pointer*. This is simplified by
    the fact that it's a flat array and doesn't require expansion or compression.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the STL provides a flat `std::array` class, as well as other more
    complex data structures. Still, you may find it valuable to demystify the workings
    of a complete iterator class.
  prefs: []
  type: TYPE_NORMAL
