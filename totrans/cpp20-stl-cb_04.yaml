- en: '*Chapter 4*: Compatible Iterators'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：兼容迭代器'
- en: Iterators are a fundamental concept in the STL. Iterators are implemented with
    the semantics of C pointers, using the same increment, decrement, and dereference
    operators. The pointer idiom is familiar to most C/C++ programmers, and it allows
    *algorithms* such as `std::sort` and `std::transform` to work on primitive memory
    buffers as well as STL containers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是 STL 中的基本概念。迭代器使用与 C 指针相同的语义实现，使用相同的增量、减量和解引用运算符。指针习语对大多数 C/C++ 程序员来说都很熟悉，它允许
    *算法* 如 `std::sort` 和 `std::transform` 在原始内存缓冲区和 STL 容器上工作。
- en: Iterators are fundamental
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器是基本概念
- en: 'The STL uses iterators to navigate the elements of its container classes. Most
    containers include `begin()` and `end()` iterators. These are usually implemented
    as member functions that return an iterator object. The `begin()` iterator points
    to the initial container element, and the `end()` iterator points *past* the final
    element:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: STL 使用迭代器来导航其容器类的元素。大多数容器包括 `begin()` 和 `end()` 迭代器。这些通常被实现为返回迭代器对象的成员函数。`begin()`
    迭代器指向容器中的初始元素，而 `end()` 迭代器指向最终元素之后：
- en: '![Figure 4.1 – The begin() and end() iterators'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – begin() 和 end() 迭代器'
- en: '](img/B18267_04_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_04_01.jpg)'
- en: Figure 4.1 – The begin() and end() iterators
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – begin() 和 end() 迭代器
- en: The `end()` iterator may function as a *sentinel* for containers of indeterminate
    length. We'll see some examples of that in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`end()` 迭代器可以作为不定长度容器的 *哨兵*。我们将在本章中看到一些示例。'
- en: 'Most STL containers define their own specific *iterator type*. For example,
    for a `vector` of `int`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 STL 容器定义了自己的特定 *迭代器类型*。例如，对于一个 `int` 类型的 `vector`：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The iterator type would be defined as:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器类型将被定义为：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see how this could easily get out of hand. If we had a `vector` of
    `vector` of `string`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这很容易失控。如果我们有一个 `vector` 的 `vector` 的 `string`：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Its iterator type would be:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它的迭代器类型将是：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Fortunately, C++11 gave us automatic type deduction and the `auto` type. By
    using `auto`, we rarely need to use the full iterator type definition. For example,
    if we need an iterator in a `for` loop, we can use the `auto` type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++11 给我们带来了自动类型推导和 `auto` 类型。通过使用 `auto`，我们很少需要使用完整的迭代器类型定义。例如，如果我们需要在
    `for` 循环中使用迭代器，我们可以使用 `auto` 类型：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice the use of the dereference operator `*` to access the elements from
    the iterator. This is the same syntax you would use to dereference a pointer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用解引用运算符 `*` 从迭代器访问元素。这与您用于解引用指针的语法相同：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This also means that you can use a range-based `for` loop with either a primitive
    array:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你可以使用基于范围的 `for` 循环与原始数组：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or with an STL container:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 STL 容器：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The range-based `for` loop is just a shorthand for a `for` loop with iterators:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环只是带有迭代器的 `for` 循环的简写：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because iterators use the same syntax as a primitive pointer, the range-based
    `for` loop works the same with either container.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为迭代器使用与原始指针相同的语法，基于范围的 `for` 循环与任何容器都可以同样工作。
- en: 'Notice that the range-based `for` loop calls `std::begin()` and `std::end()`,
    instead of directly calling the `begin()` and `end()` member functions. The `std::`
    functions call the member functions to get the iterators. So, why not just call
    the member functions? The `std::` non-member functions are designed to also work
    with primitive arrays. That''s why a `for` loop works with an array:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到基于范围的 `for` 循环调用 `std::begin()` 和 `std::end()`，而不是直接调用成员函数 `begin()` 和 `end()`。`std::`
    函数调用成员函数以获取迭代器。那么，为什么不直接调用成员函数呢？`std::` 非成员函数被设计为也可以与原始数组一起工作。这就是为什么 `for` 循环可以与数组一起工作：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For most purposes, I tend to favor the member function `begin()` and `end()`
    because they are more explicit. Others favor the `std::` non-member functions
    because they are more general. Six or half-dozen; I suggest you pick a style and
    stick with it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用途，我倾向于更喜欢成员函数 `begin()` 和 `end()`，因为它们更明确。其他人更喜欢 `std::` 非成员函数，因为它们更通用。六或七八个；我建议你选择一种风格并坚持下去。
- en: Iterator categories
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器类别
- en: 'Prior to C++20, iterators were divided into categories based on their capabilities:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，迭代器根据其能力被分为几个类别：
- en: '![](img/B18267_04_Table_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18267_04_Table_01.jpg)'
- en: These categories are hierarchical, where the more capable iterators inherit
    the capabilities of the less capable iterators. In other words, the *input iterator*
    can read and increment once. The *forward iterator* has the capabilities of the
    Input Iterator *plus* it can increment multiple times. The *bidirectional iterator*
    has those capabilities *plus* it can decrement. And on down the list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别是分层的，其中更强大的迭代器继承了较不强大的迭代器的功能。换句话说，*输入迭代器*可以读取和递增一次。*正向迭代器*具有输入迭代器的功能*加上*可以多次递增。*双向迭代器*具有这些功能*加上*可以递减。依此类推。
- en: The *output iterator* can write and increment once. If any of the other iterators
    can also write, it is considered a *mutable iterator*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出迭代器*可以写入和递增一次。如果其他迭代器也可以写入，则被认为是*可变迭代器*。'
- en: Iterator concepts
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器概念
- en: '*Concepts* and *constraints* are new with C++20\. A concept is simply a named
    constraint that restricts the types of arguments to a template function or class,
    and helps the compiler choose appropriate specializations.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*概念*和*约束*是C++20中引入的。概念只是一个命名约束，它限制了模板函数或类的参数类型，并帮助编译器选择合适的特化。'
- en: Beginning with C++20, the STL defines iterators in terms of concepts instead
    of categories. Each of these concepts are in the `std::` namespace.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++20开始，STL以概念而不是类别来定义迭代器。这些概念都在`std::`命名空间中。
- en: '![](img/B18267_04_Table_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18267_04_Table_02.jpg)'
- en: 'You can use these concepts to constrain the arguments of a template:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些概念来约束模板的参数：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function requires a `random_access_iterator`. If I call it with a `list`,
    which is not a random-access container, the compiler will give me an error:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要一个`random_access_iterator`。如果我用`list`（它不是一个随机访问容器）调用它，编译器会给我一个错误：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `list` iterator type does not support the `random_access_iterator` concept.
    So, the compiler gives me an error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`迭代器类型不支持`random_access_iterator`概念。因此，编译器会给我一个错误：'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the error output from GCC. Your errors may look different.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GCC的错误输出。您的错误可能看起来不同。
- en: 'If I call it with a `vector`, which is a random-access container:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我用`vector`（它是一个随机访问容器）调用它：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now it compiles and runs without error:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它编译并运行没有错误：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While there are different types of iterators for different types of capabilities
    (and concepts), the complexity is there to support of ease of use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有不同类型的迭代器用于不同类型的能力（和概念），但复杂性是为了支持易用性。
- en: 'With this introduction to iterators, let''s now proceed with the following
    recipes in this chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了迭代器之后，我们现在继续本章的以下食谱：
- en: Create an iterable range
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可迭代的范围
- en: Make your iterators compatible with STL iterator traits
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的迭代器与STL迭代器特性兼容
- en: Use iterator adapters to fill STL containers
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器适配器填充STL容器
- en: Create a generator as iterators
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成器作为迭代器创建
- en: Use reverse iterator adapters to iterate backward
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向迭代器适配器进行反向迭代
- en: Iterate objects of unknown length with a sentinel
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用哨兵迭代未知长度的对象
- en: Build a zip iterator adapter
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个zip迭代器适配器
- en: Create a random-access iterator
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个随机访问迭代器
- en: Technical requirements
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04)。
- en: Create an iterable range
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可迭代的范围
- en: This recipe describes a simple class that generates an iterable range, suitable
    for use with the range-based `for` loop. The idea is to create a *sequence generator*
    that iterates from a beginning value to an ending value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱描述了一个简单的类，它生成一个可迭代的范围，适用于与基于范围的`for`循环一起使用。想法是创建一个*序列生成器*，它从起始值迭代到结束值。
- en: To accomplish this task, we need an iterator class, along with the object interface
    class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们需要一个迭代器类，以及对象接口类。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: There's two major parts to this recipe, the main interface, `Seq`, and the `iterator`
    class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱有两个主要部分，主接口`Seq`和`iterator`类。
- en: 'First, we''ll define the `Seq` class. It only needs to implement the `begin()`
    and `end()` member functions:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将定义`Seq`类。它只需要实现`begin()`和`end()`成员函数：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The constructor sets up the `start_` and `end_` variables. These are used to
    construct the `begin()` and `end()` iterators, respectively. The member functions
    `begin()` and `end()` return `iterator` objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数设置了 `start_` 和 `end_` 变量。这些变量分别用于构建 `begin()` 和 `end()` 迭代器。成员函数 `begin()`
    和 `end()` 返回 `iterator` 对象。
- en: 'The `iterator` class is normally defined inside the public section of the container
    class. This is called a *member class* or a *nested class*. We''ll insert it right
    after the `Seq` constructor:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类通常定义在容器类的公共部分中。这被称为 *成员类* 或 *嵌套类*。我们将它插入到 `Seq` 构造函数之后：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It's traditional to name the iterator class `iterator`. This allows it to be
    referenced as `Seq<`*type*`>::iterator`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将迭代器类命名为 `iterator`。这允许它被引用为 `Seq<`*类型*`>::iterator`。
- en: The `iterator` constructor is qualified `explicit` to avoid implicit conversions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterator` 构造函数被标记为 `explicit` 以避免隐式转换。'
- en: The `value_` variable is maintained by the iterator. This is used to return
    a value from the pointer dereference.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_` 变量由迭代器维护。这用于从指针解引用返回值。'
- en: The minimum requirement for supporting the range-based `for` loop is a dereference
    operator `*`, a pre-increment operator `++`, and the not-equal comparison operator
    `!=`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 支持基于范围的 `for` 循环的最小要求是一个解引用运算符 `*`、一个前缀增量运算符 `++` 和一个不等比较运算符 `!=`。
- en: 'Now we can write a `main()` function to test our sequence generator:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个 `main()` 函数来测试我们的序列生成器：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This constructs a `Seq` object and prints out its sequence.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这会构建一个 `Seq` 对象并打印出其序列。
- en: 'The output looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The point of this recipe is to make a sequence generator that works with a
    range-based `for` loop. Let''s first consider the equivalent code for the range-based
    `for` loop:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的目的是制作一个与基于范围的 `for` 循环一起工作的序列生成器。让我们首先考虑基于范围的 `for` 循环的等效代码：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From this equivalent code, we can deduce the requirements for an object to
    work with the `for` loop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段等效代码中，我们可以推导出对象与 `for` 循环一起工作的要求：
- en: '`begin()` and `end()` iterators'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin()` 和 `end()` 迭代器'
- en: Iterator support for the not-equal comparison `!=` operator
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对不等比较运算符 `!=` 的迭代器支持
- en: Iterator support for the prefix increment `++` operator
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对前缀增量运算符 `++` 的迭代器支持
- en: Iterator support for the dereference `*` operator
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对解引用运算符 `*` 的迭代器支持
- en: 'Our main `Seq` class interface only has three public member functions: the
    constructor, and the `begin()` and `end()` iterators:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要 `Seq` 类接口只有三个公共成员函数：构造函数，以及 `begin()` 和 `end()` 迭代器：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The implementation of the `Seq::iterator` class carries the actual payload:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq::iterator` 类的实现携带实际的负载：'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the common configuration because the payload is only accessed through
    iterators.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的配置，因为有效负载仅通过迭代器访问。
- en: 'We''ve implemented only the three operators we need:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只实现了所需的三个运算符：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is all we need to support the range-based `for` loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们支持基于范围的 `for` 循环所需的所有内容：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'It''s traditional, but not required, to define the iterator as a member class
    of the container. This allows the `iterator` type to be subordinate to the container
    type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器定义为容器的成员类是传统做法，但不是必需的。这允许 `iterator` 类型从属于容器类型：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's not as important post C++11 because of the `auto` type, but it's still
    considered best practice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `auto` 类型，C++11 之后这并不那么重要，但它仍然被认为是最佳实践。
- en: Make your iterators compatible with STL iterator traits
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使你的迭代器与 STL 迭代器特性兼容
- en: Many STL algorithms require iterators to conform to certain traits. Unfortunately,
    these requirements are inconsistent across compilers, systems, and C++ versions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 STL 算法要求迭代器符合某些特性。不幸的是，这些要求在编译器、系统和 C++ 版本之间不一致。
- en: For our purposes, we'll use the class from the *Create an iterable range* recipe
    to illustrate the issue. You may find this makes more sense if you read that recipe
    before continuing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将使用来自 *创建可迭代范围* 菜谱的类来说明这个问题。如果你在继续之前先阅读那个菜谱，可能会更容易理解。
- en: 'In `main()`, if I add a call to the `minmax_element()` algorithm:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 中，如果添加对 `minmax_element()` 算法的调用：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It does not compile. The error messages are vague, cryptic, and cascading, but
    if you look closely, you'll see that our iterator does not meet the requirements
    to be compatible with this algorithm.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它无法编译。错误信息模糊、晦涩，并且是级联的，但如果你仔细观察，你会发现我们的迭代器不符合与该算法兼容的要求。
- en: Okay, let's fix that.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来修复这个问题。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We need to make a few simple additions to our iterator to make it compatible
    with the algorithm. Our iterator needs to meet the minimum requirements for a
    *forward iterator*, so let''s start there:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们迭代器做一些简单的添加，使其与算法兼容。我们的迭代器需要满足前向迭代器的最低要求，所以让我们从这里开始：
- en: 'We have almost all the operators necessary for a forward iterator. The only
    one we''re missing is the equality comparison operator `==`. We can easily add
    this to our iterator with an `operator==()` overload:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们几乎有所有必要的运算符来支持前向迭代器。我们唯一缺少的是相等比较运算符`==`。我们可以很容易地通过`operator==()`重载来添加这个运算符：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Interestingly, this makes the code compile and run on some systems, but not
    on *Clang*, where we get the error message:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这使得代码在某些系统上编译和运行，但在*Clang*上则不行，我们得到错误信息：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This tells me that we need to set up the traits in the iterator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我我们需要在迭代器中设置特性。
- en: 'The `iterator_traits` class looks for a set of *type definitions* (implemented
    as `using` aliases) in the `iterator` class:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator_traits`类在`iterator`类中寻找一组类型定义（实现为`using`别名）：'
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I tend to put these at the top of the `public:` section of the `iterator` class,
    where they'll be easy to see.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于将这些放在`iterator`类的`public:`部分的顶部，这样它们就很容易看到了。
- en: Now we have a fully conforming *forward iterator* class, and the code runs on
    all the compilers I have.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全符合规范的*前向迭代器*类，代码在所有我有的编译器上都能运行。
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The `using` statements are traits that may be used to define what capabilities
    the iterator can perform. Let''s look at each of them:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句是特性，可以用来定义迭代器可以执行的能力。让我们看看它们中的每一个：'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first two are the *category* and the *concept*, and both are set to `forward_iterator_tag`.
    This value indicates that the iterator conforms to the forward iterator specification.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个是*类别*和*概念*，两者都设置为`forward_iterator_tag`。这个值表示迭代器符合前向迭代器规范。
- en: 'Some code doesn''t look at those values, and instead looks for individual settings
    and capabilities:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码不会查看这些值，而是寻找单个设置和能力：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `value_type` alias is set to `std::remove_cv_t<T>`, which is the type of
    the value, with any `const` qualifier removed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_type`别名设置为`std::remove_cv_t<T>`，这是值的类型，任何`const`限定符都被移除。'
- en: The `difference_type` alias is set to `std::ptrdiff_t`, as special type for
    pointer differences.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference_type`别名设置为`std::ptrdiff_t`，这是一个用于指针差异的特殊类型。'
- en: The `pointer` and `reference` aliases are set to `const`-qualified versions
    of the pointer and reference, respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`指针`和`引用`别名分别设置为指针和引用的`const`限定版本。'
- en: Defining these type aliases is a basic requirement for most iterators.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定义这些类型别名是大多数迭代器的基本要求。
- en: There's more…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'It''s worth noting that defining these traits allows us to use concept-restricted
    templates with our iterator. For example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，定义这些特性允许我们使用概念受限的模板与我们的迭代器一起使用。例如：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function that prints our sequence is restricted by the `forward_iterator`
    concept. If our class did not qualify, it wouldn't compile.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个打印我们序列的函数受`forward_iterator`概念的约束。如果我们的类没有限定，它就不会编译。
- en: 'We can also use the `ranges::` versions of the algorithms:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用算法的`ranges::`版本：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This makes it more convenient to use our iterators.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得使用我们的迭代器更加方便。
- en: 'We can test for `forward_range` compatibility with a static assertion:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用静态断言来测试`forward_range`兼容性：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Use iterator adapters to fill STL containers
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器适配器填充STL容器
- en: An iterator is essentially an abstraction. It has a specific interface and is
    used in specific ways. But beyond that, it's just code and it can be used for
    other purposes. An *iterator adapter* is a class that looks like an iterator but
    does something else.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器本质上是一种抽象。它有一个特定的接口，并且以特定的方式使用。但除此之外，它只是代码，它可以用于其他目的。一个*迭代器适配器*是一个看起来像迭代器但做其他事情的类。
- en: 'The STL comes with an assortment of iterator adapters. Often used with the
    `algorithm` library, they are quite useful. The STL iterator adaptors generally
    fall into three categories:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: STL附带了一系列迭代器适配器。通常与`algorithm`库一起使用，它们非常有用。STL迭代器适配器通常分为三类：
- en: '**Insert iterators**, or *inserters*, are used to insert elements into a container.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入迭代器**，或*插入器*，用于将元素插入到容器中。'
- en: '**Stream iterators** read from and write to a stream.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流迭代器**从流中读取并写入。'
- en: '**Reverse iterators** reverse the direction of an iterator.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向迭代器**反转迭代器的方向。'
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'In this recipe, we''ll look at a few examples of STL iterator adapters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看一些STL迭代器适配器的示例：
- en: 'We''ll start with a simple function to print the contents of a container:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从打印容器内容的一个简单函数开始：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `printc()` function allows us to easily view the results of our algorithms.
    It includes an optional `string_view` argument for a description.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`printc()` 函数使我们能够轻松查看算法的结果。它包括一个可选的 `string_view` 参数用于描述。'
- en: 'In our `main()` function, we''ll define a couple of `deque` containers. We''re
    using `deque` containers so we can insert at both ends:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们将定义几个 `deque` 容器。我们使用 `deque` 容器是因为我们可以在两端插入元素：
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We defined deque `d1` with five `int` values, and `d2` with space for the same
    number of elements. The `copy()` algorithm will not allocate space, so `d2` must
    have room for the elements.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了包含五个 `int` 值的 `deque` 容器 `d1`，以及有相同元素数量的空间用于 `d2`。`copy()` 算法不会分配空间，所以
    `d2` 必须有足够的空间来存放元素。
- en: 'The `copy()` algorithm takes three iterators: the *begin* and *end* iterators
    indicate the range of elements to copy from, and the *begin* iterator of the destination
    range. It does not check the iterators to make sure they''re valid. (Try this
    without allocating space in a `vector` and you''ll get a *segmentation fault*
    error.)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy()` 算法接受三个迭代器：*开始* 和 *结束* 迭代器指示要复制的元素的范围，以及目标范围的开头迭代器。它不会检查迭代器以确保它们是有效的。（在没有在
    `vector` 中分配空间的情况下尝试此操作，你会得到一个 *segmentation fault* 错误。）'
- en: We call `printc()` on both containers to show the results.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个容器上调用 `printc()` 来显示结果。
- en: 'The `copy()` algorithm is not always convenient for this. Sometimes you want
    to copy and add elements to the end of a container. It would be nice to have an
    algorithm that calls `push_back()` for each element. This is where an iterator
    adapter is useful. Let''s add some code at the end of `main()`:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()` 算法并不总是方便用于此。有时你想要在容器的末尾复制并添加元素。有一个算法为每个元素调用 `push_back()` 会很好。这就是迭代器适配器有用的地方。让我们在
    `main()` 函数的末尾添加一些代码：'
- en: '[PRE38]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`back_inserter()` is an *insert iterator adapter* that calls `push_back()`
    for each item assigned to it. You can use it anywhere an output iterator is expected.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`back_inserter()` 是一个 *插入迭代器适配器*，它为分配给它的每个项目调用 `push_back()`。你可以在期望输出迭代器的任何地方使用它。'
- en: 'There''s also a `front_inserter()` adapter for when you want to insert at the
    front of a container:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个 `front_inserter()` 适配器，当你想在容器的开头插入元素时使用：
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `front_inserter()` adapter inserts elements at the front using the container's
    `push_front()` method. Notice that the elements in the destination are reversed,
    because each element is inserted before the previous one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`front_inserter()` 适配器使用容器的 `push_front()` 方法在前面插入元素。注意，目标中的元素是反转的，因为每个元素都是插入在之前元素之前。'
- en: 'If we want to insert in the middle, we can use the `inserter()` adapter:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在中间插入，我们可以使用 `inserter()` 适配器：
- en: '[PRE42]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `inserter()` adapter takes an iterator for the insertion begin point.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`inserter()` 适配器接受一个用于插入起点的迭代器。'
- en: '*Stream iterators* are convenient for reading from and writing to `iostream`
    objects, this is `ostream_iterator()`:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*流迭代器* 对于从和向 `iostream` 对象读写数据非常方便，这是 `ostream_iterator()`：'
- en: '[PRE44]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And here is `istream_iterator()`:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是 `istream_iterator()`：
- en: '[PRE46]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `istream_iterator()` adapter will return an end iterator by default, if
    no stream is passed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递流，`istream_iterator()` 适配器默认会返回一个结束迭代器。
- en: '*Reverse adapters* are included with most containers, as function members `rbegin()`
    and `rend()`:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反向适配器* 通常包含在大多数容器中，作为函数成员 `rbegin()` 和 `rend()`：'
- en: '[PRE48]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The iterator adapters work by wrapping around an existing container. When you
    call an adapter, like `back_inserter()` with a container object:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器适配器通过包装现有的容器来工作。当你调用一个适配器，比如 `back_inserter()` 与一个容器对象一起时：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The adapter returns an object that *mimics* an iterator, in this case a `std::back_insert_iterator`
    object, which calls the `push_back()` method on the container object each time
    a value is assigned to the iterator. This allows the adapter to be used in place
    of an iterator, while performing its useful task.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器返回一个模仿迭代器的对象，在这种情况下是一个 `std::back_insert_iterator` 对象，每次将值分配给迭代器时，它都会在容器对象上调用
    `push_back()` 方法。这允许适配器在执行其有用任务的同时替代迭代器。
- en: 'The `istream_adapter()` also requires a *sentinel*. A sentinel signals the
    end of an iterator of indeterminate length. When you read from a stream, you don''t
    know how many objects are in the stream until you hit the end. When the stream
    hits the end, the sentinel will compare equal with the iterator, signaling the
    end of the stream. The `istream_adapter()` will create a sentinel when it''s called
    without a parameter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream_adapter()`也需要一个*哨兵*。哨兵表示不确定长度迭代器的结束。当你从流中读取时，直到遇到结束，你都不知道流中有多少个对象。当流遇到结束时，哨兵将与迭代器相等，表示流的结束。当`istream_adapter()`不带参数调用时，它将创建一个哨兵：'
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This allows you to test for the end of a stream, as you would with any container:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你测试流的结束，就像测试任何容器一样：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Create a generator as iterators
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将生成器作为迭代器创建
- en: A *generator* is an iterator that generates its own sequence of values. It does
    not use a container. It creates values on the fly, returning one at a time as
    needed. A C++ generator stands on its own; it does not need to wrap around another
    object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器*是一个生成其自己的值序列的迭代器。它不使用容器。它即时创建值，按需一次返回一个。C++生成器独立存在；它不需要包装在另一个对象周围。'
- en: 'In this recipe, we''ll build a generator for a *Fibonacci sequence*. This is
    a sequence where each number is the sum of the previous two numbers in the sequence,
    starting with 0 and 1:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个用于生成*斐波那契序列*的生成器。这是一个序列，其中每个数字都是序列中前两个数字的和，从0和1开始：
- en: '![Figure 4.2 – Definition of a Fibonacci sequence'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 斐波那契序列的定义'
- en: '](img/B18267_04_02.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_04_02.jpg)'
- en: Figure 4.2 – Definition of a Fibonacci sequence
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 斐波那契序列的定义
- en: 'The first ten values of the Fibonacci sequence, not counting zero, are: 1,
    1, 2, 3, 5, 8, 13, 21, 34, 55\. This is a close approximation of the *golden ratio*
    found in nature.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列的前十个值（不计零）是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55。这是自然界中发现的*黄金比例*的近似值。
- en: How to do it…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: A Fibonacci sequence is often created with a *recursive loop*. Recursion in
    a generator can be difficult and resource-intensive, so instead we'll just save
    the previous two values in the sequence and add them together. This is more efficient.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列通常使用*递归循环*创建。生成器中的递归可能很困难且资源密集，所以我们只是保存序列中的前两个值并将它们相加。这更有效。
- en: 'First let''s define a function to print the sequence:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个打印序列的函数：
- en: '[PRE54]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We've used this `printc()` function before. It prints an iterable range, along
    with a description string, if provided.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用过这个`printc()`函数。它打印一个可迭代的范围，如果提供了描述字符串，还会打印描述字符串。
- en: Our class begins with a *type alias*, and a few object variables, all in the
    `private` section.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的这个类从*类型别名*和一些对象变量开始，所有这些都在`private`部分。
- en: '[PRE55]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `stop_` variable will be used later as a *sentinel*. It's set to the number
    of values to generate. `count_` is used to keep track of how many values we've
    generated. `a_` and `b_` are the previous two sequence values, used for calculating
    the next value.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop_`变量将稍后用作*哨兵*。它被设置为要生成的值的数量。`count_`用于跟踪我们已经生成了多少个值。`a_`和`b_`是序列中的前两个值，用于计算下一个值。'
- en: Still in the `private` section, we have a simple function for calculating the
    next value in the Fibonacci sequence.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然在`private`部分，我们有一个用于计算斐波那契序列中下一个值的简单函数。
- en: '[PRE56]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now in the `public` section, we have a simple constructor with a default value:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在在`public`部分，我们有一个带有默认值的简单构造函数：
- en: '[PRE57]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This constructor is used without an argument to create a sentinel. The `stop`
    argument initializes the `stop_` variable to represent how many values to generate.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数在没有参数的情况下使用，用于创建哨兵。`stop`参数初始化`stop_`变量，表示要生成的值的数量。
- en: 'The rest of the public functions are the operator overloads expected of a *forward
    iterator*:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的公共函数是期望的*前向迭代器*的运算符重载：
- en: '[PRE58]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There's also a simple `size()` function which can be useful if you need to initialize
    a target container for a copy operation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个简单的`size()`函数，如果你需要为复制操作初始化目标容器，这可能很有用。
- en: 'Now we can use the generator in our main function with a simple call to `printc()`:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以通过简单的调用`printc()`来在我们的主函数中使用生成器：
- en: '[PRE59]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This creates an anonymous `fib_generator` object to pass to the `printc()` function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个匿名`fib_generator`对象，用于传递给`printc()`函数。
- en: 'We get this output with the first 10 Fibonacci numbers, not including zero:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用前10个斐波那契数字得到这个输出，不包括零：
- en: '[PRE60]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `fib_generator` class operates as a forward iterator, simply because it
    provides all the necessary interface functions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib_generator`类作为一个前向迭代器运行，因为它提供了所有必要的接口函数：'
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As far as the range-based `for` loop is concerned, this is an iterator because
    it looks like an iterator.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就基于范围的`for`循环而言，这是一个迭代器，因为它看起来像迭代器。
- en: 'The value is calculated in the `do_fib()` function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 值是在`do_fib()`函数中计算的：
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This simply adds `b_ += a_`, stores the result in `b_` and the old `b_` in `a_`,
    setting it up for the next iteration.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地添加`b_ += a_`，将结果存储在`b_`中，并将旧的`b_`存储在`a_`中，为下一次迭代做准备。
- en: 'The dereference operator `*` returns the value from `b_`, which is the next
    value in the sequence:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用运算符`*`返回`b_`的值，这是序列中的下一个值：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `end()` function creates an object where the `count_` variable is equal
    to the `stop_` variable, creating a *sentinel*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`end()`函数创建一个对象，其中`count_`变量等于`stop_`变量，创建一个*哨兵*：'
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now the equality comparison operator can easily detect the end of the sequence:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相等比较运算符可以轻松检测序列的结束：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: There's more…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we want to make our generator work with the `algorithm` library, we need
    to provide the `traits` aliases. These go at the top of the `public` section:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的生成器与`algorithm`库一起工作，我们需要提供`traits`别名。这些别名位于`public`部分的顶部：
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we can use our generator with algorithms:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的生成器与算法一起工作：
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This uses the `ranges::views` version of the `transform()` algorithm to square
    every value. The resulting object can be used wherever you can use an iterator.
    We get this output from the `printc()` call:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`ranges::views`版本的`transform()`算法来平方每个值。结果对象可以在任何可以使用迭代器的地方使用。我们从`printc()`调用中获取这个输出：
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Use reverse iterator adapters to iterate backward
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向迭代器适配器向后迭代
- en: A *reverse iterator adapter* is an abstraction that reverses the direction of
    an iterator class. It requires a bidirectional iterator.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*反向迭代器适配器*是一个反转迭代器类方向的抽象。它需要一个双向迭代器。'
- en: How to do it…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Most bidirectional containers in the STL include a reverse iterator adapter.
    Other containers, such as the primitive C-array, do not. Let''s look at some examples:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: STL中的大多数双向容器都包含一个反向迭代器适配器。其他容器，如原始的C数组，则没有。让我们看看一些例子：
- en: 'Let''s start with the `printc()` function we''ve used throughout this chapter:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们从本章中使用的`printc()`函数开始：
- en: '[PRE69]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This uses a range-based `for` loop to print the elements of a container.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用基于范围的`for`循环来打印容器中的元素。
- en: 'The range-based `for` loop works even with primitive C-arrays, which have no
    iterator class. So, our `printc()` function already works with a C-array:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于范围的`for`循环甚至可以与没有迭代器类的原始C数组一起工作。因此，我们的`printc()`函数已经可以与C数组一起使用：
- en: '[PRE70]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We get this output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个输出：
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can use the `begin()` and `end()` iterator adapters to create normal forward
    iterators for the C-array:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`begin()`和`end()`迭代器适配器为C数组创建正常的正向迭代器：
- en: '[PRE72]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Output from the `for` loop:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的输出：'
- en: '[PRE73]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Or we can use the `rbegin()` and `rend()` reverse iterator adapters to create
    reverse iterators for the C-array:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们可以使用`rbegin()`和`rend()`反向迭代器适配器来为C数组创建反向迭代器：
- en: '[PRE74]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now our output is reversed:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的输出是反转的：
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can even create a modified version of `printc()` that prints in reverse:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们甚至可以创建一个修改版的`printc()`，使其反向打印：
- en: '[PRE76]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When we call it with the C-array:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用C数组调用它时：
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We get this output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个输出：
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Of course, this works just as well with any bidirectional STL container:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，这也适用于任何双向STL容器：
- en: '[PRE79]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works…
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A normal iterator class has a `begin()` iterator that points to the first element,
    and an `end()` iterator that points *past* the last element:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的迭代器类有一个指向第一个元素的`begin()`迭代器，以及一个指向最后一个元素之后的`end()`迭代器：
- en: '![Figure 4.3 – Forward iterator'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.3 – Forward iterator](img/B18267_04_03.jpg)'
- en: '](img/B18267_04_03.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18267_04_03.jpg](img/B18267_04_03.jpg)'
- en: Figure 4.3 – Forward iterator
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 前向迭代器
- en: You iterate the container by incrementing the `begin()` iterator with the `++`
    operator, until it reaches the value of the `end()` iterator.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过使用`++`运算符递增`begin()`迭代器来迭代容器，直到它达到`end()`迭代器的值。
- en: 'A reverse iterator adapter *intercepts the iterator interface* and turns it
    around so the `begin()` iterator points at to the last element, and `end()` iterator
    points *before* the first element. The `++` and `--` operators are also inverted:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 反向迭代器适配器会拦截迭代器接口并将其反转，使得`begin()`迭代器指向最后一个元素，而`end()`迭代器指向第一个元素之前。`++`和`--`运算符也被反转：
- en: '![Figure 4.4 – Reverse iterator adapter'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.4 – Reverse iterator adapter](img/B18267_04_04.jpg)'
- en: '](img/B18267_04_04.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18267_04_04.jpg](img/B18267_04_04.jpg)'
- en: Figure 4.4 – Reverse iterator adapter
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 反向迭代器适配器
- en: In the reversed iterator, the `++` operator decrements and the `--` operator
    increments.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向迭代器中，`++` 运算符递减，而 `--` 运算符递增。
- en: 'It''s worth noting that most bidirectional STL containers already include a
    reverse iterator adapter, accessible by member functions `rbegin()` and `rend()`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，大多数双向 STL 容器已经包含了反向迭代器适配器，可以通过成员函数 `rbegin()` 和 `rend()` 访问：
- en: '[PRE81]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These iterators will operate in reverse and are suitable for many purposes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迭代器将反向操作，适用于许多用途。
- en: Iterate objects of unknown length with a sentinel
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用哨兵遍历未知长度的对象
- en: Some objects don't have a specific length. To know their length, you need to
    iterate through all their elements. For example, elsewhere in this chapter we've
    seen a *generator* that doesn't have a specific length. A more common example
    would be a *C-string*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象没有特定的长度。要知道它们的长度，你需要遍历它们的所有元素。例如，在本章的其它地方，我们看到了一个没有特定长度的**生成器**。一个更常见的例子是**C字符串**。
- en: A C-string is a primitive C-array of characters, terminated with a null `'\0'`
    value.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: C 字符串是一个以 null `'\0'` 值终止的字符的原始 C 数组。
- en: '![Figure 4.5 – A C-string with its null terminator'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 带有 null 终止符的 C 字符串]'
- en: '](img/B18267_04_05.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B18267_04_05.jpg]'
- en: Figure 4.5 – A C-string with its null terminator
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 带有 null 终止符的 C 字符串
- en: 'We use C-strings all the time, even if we don''t realize it. Any *literal*
    string in C/C++ is a C-string:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用 C 字符串，即使我们没有意识到这一点。C/C++ 中的任何**字面量**字符串都是一个 C 字符串：
- en: '[PRE82]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here, the STL string `s` is initialized with a literal string. The literal
    string is a C-string. If we look at the individual characters in hexadecimal,
    we''ll see the null terminator:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，STL 字符串 `s` 使用字面量字符串初始化。字面量字符串是一个 C 字符串。如果我们查看单个字符的十六进制表示，我们会看到 null 终止符：
- en: '[PRE83]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The word "string" has six letters. The output from our loop shows seven elements
    in the array:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: “string”这个词有六个字母。我们循环的输出显示了数组中的七个元素：
- en: '[PRE84]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The seventh element is the null terminator.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第七个元素是 null 终止符。
- en: The loop sees the primitive C-array of characters, with seven values. The fact
    that it's a string is an abstraction invisible to the loop. If we want the loop
    to treat it like a string, we'll need an *iterator* and a *sentinel*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 循环看到的是字符的原始 C 数组，有七个值。它是字符串的事实是一个对循环不可见的抽象。如果我们想让循环将其视为字符串，我们需要一个**迭代器**和一个**哨兵**。
- en: A *sentinel* is an object that signals the end of an iterator of indeterminate
    length. When the iterator hits the end of the data, the sentinel will compare
    equal with the iterator.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**哨兵**是一个表示不确定长度迭代器末尾的对象。当迭代器遇到数据末尾时，哨兵将与迭代器比较相等。
- en: To see how this works, let's build an iterator for C-strings!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它是如何工作的，让我们为 C 字符串构建一个迭代器！
- en: How to do it…
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To use a sentinel with a C-string, we need to build a custom iterator. It doesn't
    need to be complicated, just the essentials for use with a range-based `for` loop.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用哨兵与 C 字符串一起使用，我们需要构建一个自定义迭代器。它不需要很复杂，只需要用于基于范围的 `for` 循环的基本要素。
- en: 'We''ll start with a couple of convenience definitions:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从一个方便的定义开始：
- en: '[PRE85]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `using` alias for `sentinel_t` is `const char`. We'll use this for the sentinel
    in our class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`sentinel_t` 的 `using` 别名为 `const char`。我们将在我们的类中使用这个哨兵。'
- en: We also define the constant `nullchar` for the null character terminator.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了用于 null 字符终止符的常量 `nullchar`。
- en: 'Now we can define our iterator type:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的迭代器类型：
- en: '[PRE86]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This is short and simple. It's the minimum necessary for a range-based `for`
    loop. Notice the `end()` function returns a `nullchar` and the `operator!=()`
    overload compares against the `nullchar`. That's all we need for the sentinel.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。这是基于范围的 `for` 循环所必需的最小内容。注意 `end()` 函数返回一个 `nullchar`，而 `operator!=()`
    重载与 `nullchar` 进行比较。这就是我们需要的哨兵。
- en: 'Now we can define a function for printing our C-string using the sentinel:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个函数，使用哨兵打印我们的 C 字符串：
- en: '[PRE87]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this function we first print the string. Then we use the `format()` function
    to print each individual character as a hexadecimal value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先打印字符串。然后我们使用 `format()` 函数打印每个单独的字符作为十六进制值。
- en: 'Now we can call `print_cstr()` from our `main()` function:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `main()` 函数中调用 `print_cstr()`：
- en: '[PRE88]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output looks like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE89]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Notice that there are no extraneous characters and no null terminators. This
    is because our sentinel tells the for loop to stop when it sees the `nullchar`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有多余的字符和空终止符。这是因为我们的哨兵告诉 for 循环在看到 `nullchar` 时停止。
- en: How it works…
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The sentinel part of the iterator class is very simple. We can easily use the
    null terminator as the sentinel value by returning it in the `end()` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器类的哨兵部分非常简单。我们可以通过在 `end()` 函数中返回它来轻松地使用空终止符作为哨兵值：
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then the not-equal comparison operator can test for it:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后不等比较运算符可以用来测试它：
- en: '[PRE91]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Notice that the parameter is just a type (`sentinel_t`). A parameter type is
    necessary for the function signature, but we don't need the value. All that's
    necessary is to compare the current iterator with the sentinel.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数只是一个类型 (`sentinel_t`)。参数类型对于函数签名是必要的，但我们不需要值。所有必要的只是将当前迭代器与哨兵进行比较。
- en: This technique should be useful whenever you have a type or class that doesn't
    have a predetermined end point for comparison.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术应该在你有一个没有预定比较终点的类型或类时非常有用。
- en: Build a zip iterator adapter
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建zip迭代器适配器
- en: 'Many scripting languages include a function for *zipping* two sequences together.
    A typical zip operation will take two input sequences and return a pair of values
    for each position in both inputs:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 许多脚本语言包括一个用于将两个序列 *zip* 在一起的函数。典型的 zip 操作将接受两个输入序列，并为每个输入中的每个位置返回一对值：
- en: 'Consider the case of two sequences – they can be containers, iterators, or
    initialization lists:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个序列的情况 – 它们可以是容器、迭代器或初始化列表：
- en: '![Figure 4.6 – Containers to be zipped'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 要 zip 的容器'
- en: '](img/B18267_04_06.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B18267_04_06.jpg](img/B18267_04_06.jpg)'
- en: Figure 4.6 – Containers to be zipped
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 要 zip 的容器
- en: 'We want to *zip* them together to make a new sequence with pairs of elements
    from the first two sequences:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要 *zip* 它们在一起，以创建一个新的序列，包含来自前两个序列的元素对：
- en: '![Figure 4.7 – Zip operation'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – Zip 操作'
- en: '](img/B18267_04_07.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B18267_04_07.jpg](img/B18267_04_07.jpg)'
- en: Figure 4.7 – Zip operation
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – Zip 操作
- en: In this recipe we will accomplish this task with an iterator adapter.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用迭代器适配器来完成这个任务。
- en: How to do it…
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe we''ll build a zip iterator adapter that takes two containers
    of the same type and zips the values into `std::pair` objects:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个 zip 迭代器适配器，它接受两个相同类型的容器，并将值压缩到 `std::pair` 对象中：
- en: 'In our `main()` function we want to call our adapter with two vectors:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们想要用两个向量调用我们的适配器：
- en: '[PRE92]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This allows us to use the `zip_iterator` in place of the individual `vector`
    iterators.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用 `zip_iterator` 替代单个 `vector` 迭代器。
- en: 'And we expect an output like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望得到这样的输出：
- en: '[PRE93]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Our iterator adapter is in a class called `zip_iterator`. We''ll start with
    some type aliases for convenience:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的迭代器适配器在一个名为 `zip_iterator` 的类中。我们将从一些类型别名开始，以方便起见：
- en: '[PRE94]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: These allow us to conveniently define objects and functions.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许我们方便地定义对象和函数。
- en: 'We don''t store any data in our iterator. We only store copies of the target
    containers'' `begin()` and `end()` iterators:'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在迭代器中不存储任何数据。我们只存储目标容器的 `begin()` 和 `end()` 迭代器的副本：
- en: '[PRE95]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '`ita_` and `itb_` are iterators from the target containers. The other four
    iterators are used to generate the `begin()` and `end()` iterators for the `zip_iterator`
    adapter.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`ita_` 和 `itb_` 是目标容器的迭代器。其他四个迭代器用于为 `zip_iterator` 适配器生成 `begin()` 和 `end()`
    迭代器。'
- en: 'We also have a private constructor:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个私有构造函数：
- en: '[PRE96]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This is used later to construct adapter objects specifically for `begin()` and
    `end()` iterators.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于稍后构建特定于 `begin()` 和 `end()` 迭代器的适配器对象。
- en: 'In the `public` section, we start with the iterator *traits* type definitions:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `public` 部分，我们首先从迭代器 *traits* 类型定义开始：
- en: '[PRE97]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The constructor sets up all the private iterator variables:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数设置所有私有迭代器变量：
- en: '[PRE98]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We define the minimum operator overloads to work with a forward iterator:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了最小操作符重载以与前向迭代器一起工作：
- en: '[PRE99]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'And finally, the `begin()` and `end()` functions return the respective iterators:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`begin()` 和 `end()` 函数返回相应的迭代器：
- en: '[PRE100]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: These are made simple by the stored iterators and the private constructor.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通过存储的迭代器和私有构造函数变得简单。
- en: 'Now let''s expand our `main()` function for testing:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在让我们扩展我们的 `main()` 函数以进行测试：
- en: '[PRE101]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This gives us the output we''re looking for:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这给我们想要的输出：
- en: '[PRE102]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How it works…
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The *zipped iterator adapter* is an example of how flexible the iterator abstraction
    can be. We can take the iterators of two containers and use them in one aggregated
    iterator. Let's see how this works.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*zipped iterator adapter* 是一个例子，说明了迭代器抽象可以有多灵活。我们可以取两个容器的迭代器，并将它们用于一个聚合迭代器中。让我们看看它是如何工作的。'
- en: The main constructor for the `zip_iterator` class takes two container objects.
    For the purposes of this discussion, we'll refer to these objects as the *target*
    objects.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip_iterator` 类的主构造函数接受两个容器对象。为了讨论的目的，我们将把这些对象称为 *目标* 对象。'
- en: '[PRE103]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The constructor initializes the `ita_` and `itb_` variables from the target
    `begin()` iterators. These will be used to navigate the target objects. The target
    `begin()` and `end()` iterators are also saved for later use.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数从目标 `begin()` 迭代器初始化 `ita_` 和 `itb_` 变量。这些将用于导航目标对象。目标 `begin()` 和 `end()`
    迭代器也保存起来以供以后使用。
- en: 'These variables are defined in the private section:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量在 `private` 部分定义：
- en: '[PRE104]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `it_t` type is defined as the type of the target iterator class:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`it_t` 类型被定义为目标迭代器类的类型：'
- en: '[PRE105]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The other aliased types are `val_t` for the type of the target value, and `ret_t`
    for the return `pair`. These type definitions are used for convenience throughout
    the class.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 其他别名类型是 `val_t` 用于目标值的类型，以及 `ret_t` 用于返回 `pair`。这些类型定义在类中用于方便。
- en: 'The `begin()` and `end()` functions use a private constructor that only initializes
    the `ita_` and `itb_` values:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()` 和 `end()` 函数使用一个只初始化 `ita_` 和 `itb_` 值的私有构造函数：'
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `private` constructor looks like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 构造函数看起来是这样的：'
- en: '[PRE107]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This is a constructor that takes `it_t` iterators for parameters. It only initializes
    `ita_`and `itb_` so they can be used in the comparison operator overloads.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受 `it_t` 迭代器作为参数的构造函数。它只初始化 `ita_` 和 `itb_`，以便它们可以在比较运算符重载中使用。
- en: 'The rest of the class just acts like a normal iterator, but it''s operating
    on iterators from the target class:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分就像一个正常的迭代器一样工作，但它操作的是目标类的迭代器：
- en: '[PRE108]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The dereference operator returns a `std::pair` object (`ret_t` is an alias for
    `std::pair<val_t, val_t>`). This is the interface for retrieving a value from
    the iterator.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用运算符返回一个 `std::pair` 对象（`ret_t` 是 `std::pair<val_t, val_t>` 的别名）。这是从迭代器检索值的接口。
- en: '[PRE109]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: There's more…
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `zip_iterator` adapter can be used to easily zip objects into a `map`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip_iterator` 适配器可以用来轻松地将对象压缩到 `map` 中：'
- en: '[PRE110]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If we add this code to `main()`, we get this output:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此代码添加到 `main()` 中，我们得到以下输出：
- en: '[PRE111]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Create a random-access iterator
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个随机访问迭代器
- en: This recipe is an example of a full-featured contiguous/random-access iterator.
    This is the most complete type of iterator for a container. A random-access iterator
    includes all the features of all the other types of container iterators, along
    with its random-access capabilities.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是一个完整的连续/随机访问迭代器的例子。这是容器中最完整类型的迭代器。随机访问迭代器包括所有其他类型容器迭代器的所有功能，以及它的随机访问能力。
- en: While I felt it important to include a complete iterator in this chapter, with
    over 700 lines of code this example is somewhat larger than the other examples
    in this book. I'll cover the essential components of the code here. Please see
    the full source at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我认为在本章中包含一个完整的迭代器很重要，但这个例子有超过 700 行代码，比本书中的其他例子要大得多。在这里，我将介绍代码的必要组件。请参阅完整的源代码[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp)。
- en: How to do it…
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We need a container for our iterator. We'll use a simple array for this, and
    we'll call it `Container`. The `iterator` class is nested within the `Container`
    class.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个容器来存储我们的迭代器。我们将使用一个简单的数组来完成这项工作，并将其称为 `Container`。`iterator` 类嵌套在 `Container`
    类中。
- en: All of this is designed to be consistent with the STL container interfaces.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设计都是为了与 STL 容器接口保持一致。
- en: '`Container` is defined as a `template` class. Its `private` section has only
    two elements:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Container` 被定义为 `template` 类。它的 `private` 部分只有两个元素：'
- en: '[PRE112]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We use a `unique_pointer` for the data. We let the *smart pointer* manage its
    own memory. This mitigates the need for a `~Container()` destructor. The `n_elements_`
    variable keeps the size of our container.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `unique_pointer` 来管理数据。我们让 `smart pointer` 管理自己的内存。这减轻了对 `~Container()`
    析构函数的需求。`n_elements_` 变量保持我们容器的大小。
- en: 'In the public section, we have our constructors:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在公共部分，我们有我们的构造函数：
- en: '[PRE113]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The first constructor uses an `initializer_list` to pass elements for the container.
    We call `make_unique` to allocate space and populate the container with a range-based
    `for` loop.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构造函数使用 `initializer_list` 传递容器中的元素。我们调用 `make_unique` 来分配空间，并通过基于范围的 `for`
    循环填充容器。
- en: 'We also have a constructor that allocates space without populating the elements:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个构造函数，它分配空间但不填充元素：
- en: '[PRE114]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `make_unique()` function constructs empty objects for element.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique()` 函数为元素构造空对象。'
- en: 'The `size()` function returns the number of elements:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()` 函数返回元素的数量：'
- en: '[PRE115]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `operator[]()` function returns an indexed element:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator[]()` 函数返回一个索引元素：'
- en: '[PRE116]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `at()` function returns an indexed element *with bounds checking*:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at()` 函数返回一个带边界检查的索引元素：'
- en: '[PRE117]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This is consistent with STL usage. The `at()` function is the preferred method.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 STL 使用一致。`at()` 函数是首选方法。
- en: The `begin()` and `end()` functions call the iterator constructor with the address
    of the container data.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin()` 和 `end()` 函数调用迭代器构造函数，并传递容器数据的地址。'
- en: '[PRE118]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The `unique_ptr::get()` function returns the address from the smart pointer.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr::get()` 函数从智能指针返回地址。'
- en: The `iterator` class is nested within the `Container` class as a `public` member.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator` 类作为 `public` 成员嵌套在 `Container` 类中。'
- en: '[PRE119]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The iterator class has one private member, a pointer that's initialized in the
    `begin()` and `end()` methods of the Container class.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器类有一个私有成员，一个指针，它在 `Container` 类的 `begin()` 和 `end()` 方法中被初始化。
- en: The iterator constructor takes a pointer to the container data.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器构造函数接受容器数据的指针。
- en: '[PRE120]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We provide a default value because the standard requires a default constructor.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供默认值，因为标准要求有默认构造函数。
- en: Operator overloads
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符重载
- en: 'This iterator provides operator overloads for the following operators: `++`,
    *postfix* `++`, `--`, *postfix* `--`, `[]`, *default comparison* `<=>` *(C++20)*,
    `==`, `*`, `->`, `+`, *non-member* `+`, *numeric* `-`, *object* `-`, `+=`, and
    `-=`. We''ll cover a few notable overloads here. See the source code for all of
    them.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代器为以下运算符提供了运算符重载：`++`、*后缀* `++`、`--`、*后缀* `--`、`[]`、*默认比较* `<=>` *(C++20)*、`==`、`*`、`->`、`+`、*非成员*
    `+`、*数值* `-`、*对象* `-`、`+=` 和 `-=`。我们在这里将介绍一些显著的重载。请参阅源代码以获取所有内容。
- en: 'The C++20 default comparison operator `<=>` provides the functionality of the
    full suite of comparison operators, except the equality `==` operator:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++20 默认比较运算符 `<=>` 提供了完整比较运算符集的功能，除了等式 `==` 运算符：
- en: '[PRE121]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This is a C++20 feature, so it requires a compliant compiler and library.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 C++20 特性，因此它需要一个符合标准的编译器和库。
- en: There are two `+` operator overloads. These support *it + n* and *n + it* operations.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个 `+` 运算符重载。这些支持 *it + n* 和 *n + it* 操作。
- en: '[PRE122]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `friend` declaration is a special case. When used in a template class member
    function, it's the equivalent of a non-member function. This allows a non-member
    function to be defined in the class context.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`friend` 声明是一个特殊情况。当在模板类成员函数中使用时，它等同于一个非成员函数。这允许在类上下文中定义一个非成员函数。'
- en: The `-` operator also has two overloads. We need to support both a numeric operand
    and an iterator operand.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` 运算符也有两个重载。我们需要支持一个数值操作数和一个迭代器操作数。'
- en: '[PRE123]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This allows both *it – n* and *it – it* operations. There's no need for a non-member
    function, as *n – it* is not a valid operation.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许进行 *it – n* 和 *it – it* 操作。不需要非成员函数，因为 *n – it* 不是一个有效的操作。
- en: Validation code
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证代码
- en: The C++20 specification §23.3.4.13 requires a specific set of operations and
    results for a valid random-access iterator. I've included a `unit_tests()` function
    in the source code to validate those requirements.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 规范 §23.3.4.13 要求对有效的随机访问迭代器有一组特定的操作和结果。我在源代码中包含了一个 `unit_tests()` 函数来验证这些要求。
- en: The `main()` function creates a `Container` object and performs some simple
    validation functions.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数创建一个 `Container` 对象并执行一些简单的验证函数。'
- en: First, we create a `Container<string>` object `x` with ten values.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含十个值的 `Container<string>` 对象 `x`。
- en: '[PRE124]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output gives the number of elements:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 输出给出元素的数量：
- en: '[PRE125]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We display the elements of the container with a range-based `for` loop:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用基于范围的 `for` 循环显示容器的元素：
- en: '[PRE126]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Output:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE127]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, we test several direct access methods:'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们测试几个直接访问方法：
- en: '[PRE128]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Output:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE129]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We test the container with a `ranges::views` pipe and `views::reverse`:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `ranges::views` 管道和 `views::reverse` 测试容器：
- en: '[PRE130]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Output:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE131]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Finally, we create a `Container` object `y` with 10 uninitialized elements:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个包含 10 个未初始化元素的 `Container` 对象 `y`：
- en: '[PRE132]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Output:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE133]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: How it works…
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Although it's a lot of code, this iterator is no more complicated than a smaller
    iterator. Most of the code is in the operator overloads, which are mostly one
    or two lines of code each.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码量很大，但这个迭代器并不比一个更小的迭代器复杂。大部分代码都在运算符重载中，这些重载通常是每行一到两行代码。
- en: The container itself is managed by a *smart pointer*. This is simplified by
    the fact that it's a flat array and doesn't require expansion or compression.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 容器本身由一个*智能指针*管理。由于它是一个平铺数组，不需要扩展或压缩，这一点得到了简化。
- en: Of course, the STL provides a flat `std::array` class, as well as other more
    complex data structures. Still, you may find it valuable to demystify the workings
    of a complete iterator class.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，STL提供了平铺的`std::array`类，以及其他更复杂的数据结构。然而，你可能觉得揭示一个完整迭代器类的工作原理是有价值的。
