<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2.       Discovering QMake Secrets      </h1></div></div></div><p>This chapter addresses the issue of creating a cross-platform application that relies on platform-specific code. We will see the impact of qmake on the compilation of your project.</p><p>You will learn how to create a system monitoring application that retrieves the average CPU load and the memory used from Windows, Linux, and Mac. For this kind of OS dependent application, architecture is the key to keeping your application reliable and maintainable.</p><p>At the end of this chapter, you will be able to create and organize a cross-platform application that uses platform-specific code and displays Qt Charts widgets. Moreover, qmake will not be a mystery anymore.</p><p>This chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Platform-specific code organization</li><li class="listitem">Design patterns, strategy, and singleton</li><li class="listitem">Abstract class and pure virtual function</li><li class="listitem">Qt Charts</li><li class="listitem">The qmake tool</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Designing a cross-platform project</h1></div></div></div><p>We want to display some visual gauges and chart widgets, so create a new <strong>Qt widgets Application</strong> called <code class="literal">ch02-sysinfo</code>. As already discussed in <a class="link" title="Chapter 1.  Get Your Qt Feet Wet" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <em>Get Your Qt Feet Wet</em>, Qt Creator will generate some files for us: <code class="literal">main.cpp</code>, <code class="literal">MainWindow.h</code>, <code class="literal">MainWindow.cpp</code>, and <code class="literal">MainWindow.ui</code>.</p><p>Before diving into the C++ code, we must think about the software's architecture. This project will handle multiple desktop platforms. Thanks to the combination of C++ and Qt, most of the source code will be common to all targets. However, to retrieve both the CPU and memory usage from the OS (operating system), we will use some platform-specific code.</p><p>To successfully achieve this task, we will use two design patterns:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Strategy pattern</strong>: This is an interface that describes functionalities (for example, retrieve CPU usage), and specific behaviors (retrieve CPU usage on Windows/Mac OS/Linux) will be performed into subclasses that implement this interface.</li><li class="listitem"><strong>Singleton pattern</strong>: This pattern guarantees a single instance for a given class. This instance will be easily accessible with a unique access point.</li></ul></div><p>As you can see in the following diagram, the class <code class="literal">SysInfo</code> is our interface with the strategy pattern, and is also a singleton. The specific behavior from the strategy pattern is performed in the classes <code class="literal">SysInfoWindowsImpl</code>, <code class="literal">SysInfoMacImpl</code>, and <code class="literal">SysInfoLinuxImpl</code>, subclassing <code class="literal">SysInfo</code>:</p><div><img src="img/image00360.jpeg" alt="Designing a cross-platform project"/></div><p style="clear:both; height: 1em;"> </p><p>The UI part will only know and use the <code class="literal">SysInfo</code> class. The platform-specific implementation class is instantiated by the <code class="literal">SysInfo</code> class, and the caller doesn't need to know anything about the <code class="literal">SysInfo</code> child classes. As the <code class="literal">SysInfo</code> class is a singleton, access will be easier for all widgets.</p><p>Let's begin by creating the <code class="literal">SysInfo</code> class. On Qt Creator, you can create a new C++ class from the contextual menu, accessible with a right click on the project name in the hierarchy view. Then click on the <strong>Add new</strong> option, or from the menu, go to <strong>File</strong> | <strong>New file or project</strong> | <strong>Files and classes</strong>. Then perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to <strong>C++ Class</strong> | <strong>Choose</strong>.</li><li class="listitem">Set the <strong>Class</strong> name field to <code class="literal">SysInfo</code>. As this class does not inherit from another class, we do not need to use the <code class="literal">Base</code> class field.</li><li class="listitem">Click on <strong>Next</strong>, then <strong>Finish</strong> to generate an empty C++ class.</li></ol><div></div><p>We will now specify our interface by adding three pure virtual functions: <code class="literal">init()</code>, <code class="literal">cpuLoadAverage()</code>, and <code class="literal">memoryUsed()</code>:</p><pre class="programlisting">// In SysInfo.h 
class SysInfo 
{ 
public: 
    SysInfo(); 
    virtual ~SysInfo(); 
 
    virtual void init() = 0; 
    virtual double cpuLoadAverage() = 0; 
    virtual double memoryUsed() = 0; 
}; 
 
// In SysInfo.cpp 
#include "SysInfo.h" 
 
SysInfo::SysInfo() 
{ 
} 
 
SysInfo::~SysInfo() 
{ 
} 
</pre><p>Each of these functions has specific roles:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">init()</code>: This function allows the derived class to perform any initialization process depending on the OS platform</li><li class="listitem"><code class="literal">cpuLoadAverage()</code>: This function calls some OS-specific code to retrieve the average CPU load and returns it as a percentage value</li><li class="listitem"><code class="literal">memoryUsed()</code>: This function calls some OS-specific code to retrieve the memory used and returns it as a percentage value</li></ul></div><p>The <code class="literal">virtual</code> keyword indicates that the function can be overridden in a derived class. The <code class="literal">= 0</code> syntax means that this function is pure virtual, and must be overridden in any concrete derived class. Moreover, this makes <code class="literal">SysInfo</code> an abstract class that cannot be instantiated.</p><p>We also added an empty virtual destructor. This destructor must be virtual to ensure that any deletion of an instance of a derived class--from a base class pointer--will call the derived class destructor and not only the base class destructor.</p><p>Now that our <code class="literal">SysInfo</code> class is an abstract class and ready to be derived, we will describe three implementations: Windows, Mac OS, and Linux. You can also perform only one implementation if you would rather not use the other two. We will not make any judgment on this. The <code class="literal">SysInfo</code> class will be transformed into a singleton after adding the implementations.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec5"/>Adding the Windows implementation</h2></div></div></div><p>Remember the UML diagram at the beginning of this chapter? The <code class="literal">SysInfoWindowsImpl</code> class is one of the classes derived from the <code class="literal">SysInfo</code> class. The main purpose of this class is to encapsulate the Windows-specific code to retrieve CPU and memory usage.</p><p>It's time to create the <code class="literal">SysInfoWindowsImpl</code> class. To do that, you need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Right click on the <code class="literal">ch02-sysinfo</code> project name in the hierarchy view.</li><li class="listitem">Click on <strong>Add New</strong> | <strong>C++ Class</strong> | <strong>Choose</strong>.</li><li class="listitem">Set the <strong>Class name</strong> field to <code class="literal">SysInfoWindowsImpl</code>.</li><li class="listitem">Set the <strong>Base class</strong> field to <strong>&lt;Custom&gt;</strong> and write under the <code class="literal">SysInfo</code> class.</li><li class="listitem">Click on <strong>Next</strong> then <strong>Finish</strong> to generate an empty C++ class.</li></ol><div></div><p>These generated files are a good starting point, but we must tune them:</p><pre class="programlisting">#include "SysInfo.h" 
 
class SysInfoWindowsImpl : public SysInfo 
{ 
public: 
    SysInfoWindowsImpl(); 
 
    void init() override; 
    double cpuLoadAverage() override; 
    double memoryUsed() override; 
}; 
</pre><p>The first thing to do is to add the <code class="literal">include</code> directive to our parent class, <code class="literal">SysInfo</code>. You can now override virtual functions defined in the base class.</p><div><h3 class="title"><a id="tip13"/>Tip</h3><p><strong>Qt Tip</strong></p><p>Put your cursor on a derived class name (after the keyword <code class="literal">class</code>) and press <em>Alt</em> + <em>Enter</em> (Windows / Linux) or <em>Command</em> + <em>Enter</em> (Mac) to automatically insert virtual functions of the base class.</p></div><p>The <code class="literal">override</code> keyword comes from C++11. It ensures that the function is declared as virtual in the base class. If the function signature marked as <code class="literal">override</code> does not match any parent class' <code class="literal">virtual</code> function, a compile-time error will be displayed.</p><p>Retrieving the current memory used on Windows is easy. We will begin with this feature in the <code class="literal">SysInfoWindowsImpl.cpp</code> file:</p><pre class="programlisting">#include "SysInfoWindowsImpl.h" 
 
#include &lt;windows.h&gt; 
 
SysInfoWindowsImpl::SysInfoWindowsImpl() : 
    SysInfo(), 
{ 
} 
 
double SysInfoWindowsImpl::memoryUsed() 
{ 
    MEMORYSTATUSEX memoryStatus; 
    memoryStatus.dwLength = sizeof(MEMORYSTATUSEX); 
    GlobalMemoryStatusEx(&amp;memoryStatus); 
    qulonglong memoryPhysicalUsed = 
        memoryStatus.ullTotalPhys - memoryStatus.ullAvailPhys; 
    return (double)memoryPhysicalUsed / 
        (double)memoryStatus.ullTotalPhys * 100.0; 
} 
</pre><p>Don't forget to include the <code class="literal">windows.h</code> file so that we can use the Windows API! Actually, this function retrieves the total and the available physical memory. A simple subtraction gives us the amount of memory used. As required by the base class <code class="literal">SysInfo</code>, this implementation will return the value as a <code class="literal">double</code> type; for example, the value <code class="literal">23.0</code> for 23% memory used on a Windows OS.</p><p>Retrieving the total memory used is a good start, but we cannot stop now. Our class must also retrieve the CPU load. The Windows API can be messy sometimes. To make our code more readable, we will create two private helper functions. Update your <code class="literal">SysInfoWindowsImpl.h</code> file to match the following snippet:</p><pre class="programlisting">#include &lt;QtGlobal&gt; 
#include &lt;QVector&gt; 
 
#include "SysInfo.h" 
 
typedef struct _FILETIME FILETIME; 
 
class SysInfoWindowsImpl : public SysInfo 
{ 
public: 
    SysInfoWindowsImpl(); 
 
    void init() override; 
    double cpuLoadAverage() override; 
    double memoryUsed() override; 
 
private: 
    QVector&lt;qulonglong&gt; cpuRawData(); 
    qulonglong convertFileTime(const FILETIME&amp; filetime) const; 
 
private: 
    QVector&lt;qulonglong&gt; mCpuLoadLastValues; 
}; 
</pre><p>Let's analyze these changes:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">cpuRawData()</code> is the function that will perform the Windows API call to retrieve system timing information and return values in a generic format. We will retrieve and return three values: the amount of time that the system has spent in idle, in Kernel, and in User mode.</li><li class="listitem">The <code class="literal">convertFileTime()</code> function is our second helper. It will convert a Windows <code class="literal">FILETIME struct</code> syntax to a <code class="literal">qulonglong</code> type. The <code class="literal">qulonglong</code> type is a Qt <code class="literal">unsigned long long int</code>. This type is guaranteed by Qt to be 64-bit on all platforms. You can also use the typedef <code class="literal">quint64</code>.</li><li class="listitem">The <code class="literal">mCpuLoadLastValues</code> is a variable that will store system timing (idle, Kernel, and User) at a given moment.</li></ul></div><div><ul class="itemizedlist"><li class="listitem">Don't forget to include the <code class="literal">&lt;QtGlobal&gt;</code> tag to use the <code class="literal">qulonglong</code> type, and the <code class="literal">&lt;QVector&gt;</code> tag to use the <code class="literal">QVector</code> class.</li><li class="listitem">The syntax <code class="literal">typedef struct _FILETIME FILETIME</code> is a kind of forward declaration for <code class="literal">FILENAME</code> syntax. As we only use a reference, we can avoid including the <code class="literal">&lt;windows.h&gt;</code> tag in our file <code class="literal">SysInfoWindowsImpl.h</code> and keep it in the CPP file.</li></ul></div><p>We can now switch to the file <code class="literal">SysInfoWindowsImpl.cpp</code> and implement these functions to finish the CPU load average feature on Windows:</p><pre class="programlisting">#include "SysInfoWindowsImpl.h" 
 
#include &lt;windows.h&gt; 
 
SysInfoWindowsImpl::SysInfoWindowsImpl() : 
    SysInfo(), 
    mCpuLoadLastValues() 
{ 
} 
 
void SysInfoWindowsImpl::init() 
{ 
    mCpuLoadLastValues = cpuRawData(); 
} 
</pre><p>When the <code class="literal">init()</code> function is called, we store the return value from the <code class="literal">cpuRawData()</code> function in our class variable <code class="literal">mCpuLoadLastValues</code>. It will be helpful for the <code class="literal">cpuLoadAverage()</code>function process.</p><p>You may be wondering why we do not perform this task in the initialization list of the constructor. That is because when you call a function from the initialization list, the object is not yet fully constructed! In some circumstances, it may be unsafe because the function can try to access a member variable that has not been constructed yet. However, in this <code class="literal">ch02-sysinfo</code> project, the <code class="literal">cpuRawData</code> function does not use any member variables, so you are safe, if you really want to do it. Add the <code class="literal">cpuRawData()</code> function to the <code class="literal">SysInfoWindowsImpl.cpp</code> file:</p><pre class="programlisting">QVector&lt;qulonglong&gt; SysInfoWindowsImpl::cpuRawData() 
{ 
    FILETIME idleTime; 
    FILETIME kernelTime; 
    FILETIME userTime; 
 
    GetSystemTimes(&amp;idleTime, &amp;kernelTime, &amp;userTime); 
 
    QVector&lt;qulonglong&gt; rawData; 
 
    rawData.append(convertFileTime(idleTime)); 
    rawData.append(convertFileTime(kernelTime)); 
    rawData.append(convertFileTime(userTime)); 
    return rawData; 
} 
</pre><p>Here we are: the Windows API call to the <code class="literal">GetSystemTimes</code> function! This function will give us the amount of time that the system has spent idle, and in the Kernel and User modes. Before filling the <code class="literal">QVector</code> class, we convert each value with our helper <code class="literal">convertFileTime</code> described in the following code:</p><pre class="programlisting">qulonglong SysInfoWindowsImpl::convertFileTime(const FILETIME&amp; filetime) const 
{ 
    ULARGE_INTEGER largeInteger; 
    largeInteger.LowPart = filetime.dwLowDateTime; 
    largeInteger.HighPart = filetime.dwHighDateTime; 
    return largeInteger.QuadPart; 
} 
</pre><p>The Windows structure <code class="literal">FILEFTIME</code> stores 64-bit information on two 32-bit parts (low and high). Our function <code class="literal">convertFileTime</code> uses the Windows structure <code class="literal">ULARGE_INTEGER</code> to correctly build a 64-bit value in a single part before returning it as a <code class="literal">qulonglong</code> type. Last but not least, the <code class="literal">cpuLoadAverage()</code> implementation:</p><pre class="programlisting">double SysInfoWindowsImpl::cpuLoadAverage() 
{ 
    QVector&lt;qulonglong&gt; firstSample = mCpuLoadLastValues; 
    QVector&lt;qulonglong&gt; secondSample = cpuRawData(); 
    mCpuLoadLastValues = secondSample; 
 
    qulonglong currentIdle = secondSample[0] - firstSample[0]; 
    qulonglong currentKernel = secondSample[1] - firstSample[1]; 
    qulonglong currentUser = secondSample[2] - firstSample[2]; 
    qulonglong currentSystem = currentKernel + currentUser; 
 
    double percent = (currentSystem - currentIdle) * 100.0 / 
        currentSystem ; 
    return qBound(0.0, percent, 100.0); 
} 
</pre><p>There are three important points to note here:</p><div><ul class="itemizedlist"><li class="listitem">Keep in mind that a sample is an absolute amount of time, so subtracting two different samples will give us instantaneous values that can be processed to get the current CPU load.</li><li class="listitem">The first sample comes from our member variable <code class="literal">mCpuLoadLastValues</code>, probed the first time by the <code class="literal">init()</code> function. The second one is retrieved when the <code class="literal">cpuLoadAverage()</code> function is called. After initializing the samples, the <code class="literal">mCpuLoadLastValues</code> variable can store the new sample that will be used for the next call.</li><li class="listitem">The <code class="literal">percent</code> equation can be a little tricky because the Kernel value retrieved from the Windows API also contains the idle value.</li></ul></div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>If you want to learn more about the Windows API, take a look at the MSDN documentation at <a class="ulink" href="https://msdn.microsoft.com/library">https://msdn.microsoft.com/library</a>.</p></div><p>The final step to finish the Windows implementation is to edit the file <code class="literal">ch02-sysinfo.pro</code> so that it resembles the following snippet:</p><pre class="programlisting">QT       += core gui 
CONFIG   += C++14 
 
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets 
 
TARGET = ch02-sysinfo 
TEMPLATE = app 
 
SOURCES += main.cpp \ 
    MainWindow.cpp \ 
    SysInfo.cpp 
 
HEADERS += MainWindow.h \ 
    SysInfo.h 
 
windows { 
    SOURCES += SysInfoWindowsImpl.cpp 
    HEADERS += SysInfoWindowsImpl.h 
} 
 
FORMS    += MainWindow.ui 
</pre><p>As we did in the <code class="literal">ch01-todo</code> project, we also use C++14 with the <code class="literal">ch02-sysinfo</code> project. The really new point here is that we removed the files <code class="literal">SysInfoWindowsImpl.cpp</code> and <code class="literal">SysInfoWindowsImpl.h</code> from the common <code class="literal">SOURCES</code> and <code class="literal">HEADERS</code> variables. Indeed, we added them into a <code class="literal">windows</code> platform scope. When building for other platforms, those files will not be processed by qmake. That is why we can safely include a specific header such as <code class="literal">windows.h</code> in the source file <code class="literal">SysInfoWindowsImpl.cpp</code> without harming the compilation on other platforms.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec6"/>Adding the Linux implementation</h2></div></div></div><p>Let's make the Linux implementation of our <code class="literal">ch02-sysinfo</code> project. If you have already done the Windows implementation, it will be a piece of cake! If you have not, you should take a look at it. Some information and tips will not be repeated in this part, such as how to create a <code class="literal">SysInfo</code> implementation class, keyboard shortcuts, and details about the <code class="literal">SysInfo</code> interface.</p><p>Create a new C++ class called <code class="literal">SysInfoLinuxImpl</code> that inherits from the <code class="literal">SysInfo</code> class, and insert virtual functions from the base class:</p><pre class="programlisting">#include "SysInfo.h" 
 
class SysInfoLinuxImpl : public SysInfo 
{ 
public: 
    SysInfoLinuxImpl(); 
 
    void init() override; 
    double cpuLoadAverage() override; 
    double memoryUsed() override; 
}; 
</pre><p>We will start by implementing the <code class="literal">memoryUsed()</code> function in the file <code class="literal">SysInfoLinuxImpl.cpp</code>:</p><pre class="programlisting">#include "SysInfoLinuxImpl.h" 
 
#include &lt;sys/types.h&gt; 
#include &lt;sys/sysinfo.h&gt; 
 
SysInfoLinuxImpl::SysInfoLinuxImpl() : 
    SysInfo(), 
{ 
} 
 
double SysInfoLinuxImpl::memoryUsed() 
{ 
    struct sysinfo memInfo; 
    sysinfo(&amp;memInfo); 
 
    qulonglong totalMemory = memInfo.totalram; 
    totalMemory += memInfo.totalswap; 
    totalMemory *= memInfo.mem_unit; 
 
    qulonglong totalMemoryUsed = memInfo.totalram - memInfo.freeram; 
    totalMemoryUsed += memInfo.totalswap - memInfo.freeswap; 
    totalMemoryUsed *= memInfo.mem_unit; 
 
    double percent = (double)totalMemoryUsed / 
        (double)totalMemory * 100.0; 
    return qBound(0.0, percent, 100.0); 
} 
</pre><p>This function uses Linux-specific API. After adding the required includes, you can use the Linux <code class="literal">sysinfo()</code> function that returns information on the overall system statistics. With the total memory and the total memory used, we can easily return the <code class="literal">percent</code> value. Note that swap memory has been taken into account.</p><p>The CPU load feature is a little more complex than the memory feature. Indeed, we will retrieve from Linux the total amount of time the CPU spent performing different kinds of work. That is not exactly what we want. We must return the instantaneous CPU load. A common way to get it is to retrieve two sample values in a short period of time and use the difference to get the instantaneous CPU load:</p><pre class="programlisting">#include &lt;QtGlobal&gt; 
#include &lt;QVector&gt; 
 
#include "SysInfo.h" 
 
class SysInfoLinuxImpl : public SysInfo 
{ 
public: 
    SysInfoLinuxImpl(); 
 
    void init() override; 
    double cpuLoadAverage() override; 
    double memoryUsed() override; 
 
private: 
    QVector&lt;qulonglong&gt; cpuRawData(); 
 
private: 
    QVector&lt;qulonglong&gt; mCpuLoadLastValues; 
}; 
</pre><p>In this implementation, we will only add one helper function and one member variable:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">cpuRawData()</code> is a function that will perform the Linux API call to retrieve system timing information and return values in a <code class="literal">QVector</code> class of <code class="literal">qulonglong</code> type. We retrieve and return four values containing the time the CPU has spent on the following: normal processes in User mode, nice processes in User mode, processes in Kernel mode, and idle.</li><li class="listitem">The <code class="literal">mCpuLoadLastValues</code> is a variable that will store a sample of system timing at a given moment.</li></ul></div><p>Let's go to the <code class="literal">SysInfoLinuxImpl.cpp</code> file to update it:</p><pre class="programlisting">#include "SysInfoLinuxImpl.h" 
 
#include &lt;sys/types.h&gt; 
#include &lt;sys/sysinfo.h&gt; 
 
#include &lt;QFile&gt; 
 
SysInfoLinuxImpl::SysInfoLinuxImpl() : 
    SysInfo(), 
    mCpuLoadLastValues() 
{ 
} 
 
void SysInfoLinuxImpl::init() 
{ 
    mCpuLoadLastValues = cpuRawData(); 
} 
</pre><p>As discussed before, the <code class="literal">cpuLoadAverage</code> function will need two samples to be able to compute an instantaneous CPU load average. Calling the <code class="literal">init()</code> function allows us to set <code class="literal">mCpuLoadLastValues</code> for the first time:</p><pre class="programlisting">QVector&lt;qulonglong&gt; SysInfoLinuxImpl::cpuRawData() 
{ 
    QFile file("/proc/stat"); 
    file.open(QIODevice::ReadOnly); 
 
    QByteArray line = file.readLine(); 
    file.close(); 
    qulonglong totalUser = 0, totalUserNice = 0, 
        totalSystem = 0, totalIdle = 0; 
    std::sscanf(line.data(), "cpu %llu %llu %llu %llu", 
        &amp;totalUser, &amp;totalUserNice, &amp;totalSystem, 
        &amp;totalIdle); 
 
    QVector&lt;qulonglong&gt; rawData; 
    rawData.append(totalUser); 
    rawData.append(totalUserNice); 
    rawData.append(totalSystem); 
    rawData.append(totalIdle); 
 
    return rawData; 
} 
</pre><p>To retrieve the CPU raw information on a Linux system, we chose to parse information available in the <code class="literal">/proc/stat</code> file. All we need is available on the first line, so a single <code class="literal">readLine()</code> is enough. Even though Qt provides some useful features, sometimes the C standard library functions are simpler. This is the case here; we are using <code class="literal">std::sscanf</code> to extract variables from a string. Now let's look at the <code class="literal">cpuLoadAvearge()</code> body:</p><pre class="programlisting">double SysInfoLinuxImpl::cpuLoadAverage() 
{ 
    QVector&lt;qulonglong&gt; firstSample = mCpuLoadLastValues; 
    QVector&lt;qulonglong&gt; secondSample = cpuRawData(); 
    mCpuLoadLastValues = secondSample; 
 
    double overall = (secondSample[0] - firstSample[0]) 
        + (secondSample[1] - firstSample[1]) 
        + (secondSample[2] - firstSample[2]); 
 
    double total = overall + (secondSample[3] - firstSample[3]); 
    double percent = (overall / total) * 100.0; 
    return qBound(0.0, percent, 100.0); 
} 
</pre><p>This is where the magic happens. In this last function, we put all the puzzle pieces together. This function uses two samples of the CPU raw data. The first sample comes from our member variable <code class="literal">mCpuLoadLastValues</code>, set the first time by the <code class="literal">init()</code> function. The second sample is requested by the <code class="literal">cpuLoadAverage()</code> function. Then the <code class="literal">mCpuLoadLastValues</code> variable will store the new sample that will be used as the first sample on the next <code class="literal">cpuLoadAverage()</code> function call.</p><p>The <code class="literal">percent</code> equation should be easy to understand:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">overall</code> is equal to user + nice + kernel</li><li class="listitem"><code class="literal">total</code> is equal to overall + idle</li></ul></div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>You can find more information about <code class="literal">/proc/stat</code> in the Linux Kernel documentation at <a class="ulink" href="https://www.kernel.org/doc/Documentation/filesystems/proc.txt">https://www.kernel.org/doc/Documentation/filesystems/proc.txt</a>.</p></div><p>Like the other implementations, the last thing to do is to edit the <code class="literal">ch02-sysinfo.pro</code> file like this:</p><pre class="programlisting">QT       += core gui 
CONFIG   += C++14 
 
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets 
 
TARGET = ch02-sysinfo 
TEMPLATE = app 
 
SOURCES += main.cpp \ 
    MainWindow.cpp \ 
    SysInfo.cpp \ 
    CpuWidget.cpp \ 
    MemoryWidget.cpp \ 
    SysInfoWidget.cpp 
 
HEADERS += MainWindow.h \ 
    SysInfo.h \ 
    CpuWidget.h \ 
    MemoryWidget.h \ 
    SysInfoWidget.h 
 
windows { 
    SOURCES += SysInfoWindowsImpl.cpp 
    HEADERS += SysInfoWindowsImpl.h 
} 
 
linux { 
    SOURCES += SysInfoLinuxImpl.cpp 
    HEADERS += SysInfoLinuxImpl.h 
} 
 
FORMS    += MainWindow.ui 
</pre><p>With this Linux scope condition in the <code class="literal">ch02-sysinfo.pro</code> file, our Linux-specific files will not be processed by the <code class="literal">qmake</code> command on other platforms.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec7"/>Adding the Mac OS implementation</h2></div></div></div><p>Let's take a look at the Mac implementation of the <code class="literal">SysInfo</code> class. Start by creating a new C++ class named <code class="literal">SysInfoMacImpl</code> that inherits from the <code class="literal">SysInfo</code> class. Override <code class="literal">SysInfo</code> virtual functions and you should have a <code class="literal">SysInfoMacImpl.h</code> file like this:</p><pre class="programlisting">#include "SysInfo.h" 
 
#include &lt;QtGlobal&gt; 
#include &lt;QVector&gt; 
 
class SysInfoMacImpl : public SysInfo 
{ 
public: 
    SysInfoMacImpl(); 
 
    void init() override; 
    double cpuLoadAverage() override; 
    double memoryUsed() override; 
}; 
</pre><p>The first implementation we will do will be the <code class="literal">memoryUsed()</code> function, in the <code class="literal">SysInfoMacImpl.cpp</code> file:</p><pre class="programlisting">#include &lt;mach/vm_statistics.h&gt; 
#include &lt;mach/mach_types.h&gt; 
#include &lt;mach/mach_init.h&gt; 
#include &lt;mach/mach_host.h&gt; 
#include &lt;mach/vm_map.h&gt; 
 
SysInfoMacImpl::SysInfoMacImpl() : 
    SysInfo() 
{ 
 
} 
 
double SysInfoMacImpl::memoryUsed() 
{ 
    vm_size_t pageSize; 
    vm_statistics64_data_t vmStats; 
 
    mach_port_t machPort = mach_host_self(); 
    mach_msg_type_number_t count = sizeof(vmStats)  
                                  / sizeof(natural_t); 
    host_page_size(machPort, &amp;pageSize); 
 
    host_statistics64(machPort, 
                      HOST_VM_INFO, 
                      (host_info64_t)&amp;vmStats, 
                      &amp;count); 
 
    qulonglong freeMemory = (int64_t)vmStats.free_count  
                            * (int64_t)pageSize; 
 
    qulonglong totalMemoryUsed = ((int64_t)vmStats.active_count + 
                             (int64_t)vmStats.inactive_count + 
                             (int64_t)vmStats.wire_count)  
                             * (int64_t)pageSize; 
 
    qulonglong totalMemory = freeMemory + totalMemoryUsed; 
 
    double percent = (double)totalMemoryUsed  
                     / (double)totalMemory * 100.0; 
    return qBound(0.0, percent, 100.0); 
} 
</pre><p>We start by including the different headers for the Mac OS kernel. Then we initialize <code class="literal">machPort</code> with the call to the <code class="literal">mach_host_self()</code> function. A <code class="literal">machPort</code> is a kind of special connection to the kernel that enables us to request information about the system. We then proceed to prepare other variables so that we can retrieve virtual memory statistics with <code class="literal">host_statistics64()</code>.</p><p>When the <code class="literal">vmStats</code> class is filled with the information needed, we extract the relevant data: the <code class="literal">freeMemory</code> and the <code class="literal">totalMemoryUsed</code>.</p><p>Note that Mac OS has a peculiar way of managing its memory: it keeps a lot of memory in cache, ready to be flushed when needed. This implies that our statistics can be misled; we see the memory as used, whereas it was simply kept "just in case".</p><p>The percentage calculation is straightforward; we still return a min/max clamped value to avoid any crazy values in our future graph.</p><p>Next comes the <code class="literal">cpuLoadAverage()</code> implementation. The pattern is always the same; take samples at regular intervals and compute the growth on this interval. Therefore, we have to store intermediate values to be able to calculate the difference with the next sample:</p><pre class="programlisting">// In SysInfoMacImpl.h 
#include "SysInfo.h" 
 
#include &lt;QtGlobal&gt; 
#include &lt;QVector&gt; 
 
... 
 
private: 
    QVector&lt;qulonglong&gt; cpuRawData(); 
 
private: 
    QVector&lt;qulonglong&gt; mCpuLoadLastValues; 
}; 
 
// In SysInfoMacImpl.cpp 
void SysInfoMacImpl::init() 
{ 
    mCpuLoadLastValues =  cpuRawData(); 
} 
 
QVector&lt;qulonglong&gt; SysInfoMacImpl::cpuRawData() 
{ 
    host_cpu_load_info_data_t cpuInfo; 
    mach_msg_type_number_t cpuCount = HOST_CPU_LOAD_INFO_COUNT; 
    QVector&lt;qulonglong&gt; rawData; 
    qulonglong totalUser = 0, totalUserNice = 0, totalSystem = 0,           totalIdle = 0; 
    host_statistics(mach_host_self(), 
                    HOST_CPU_LOAD_INFO, 
                    (host_info_t)&amp;cpuInfo, 
                    &amp;cpuCount); 
 
    for(unsigned int i = 0; i &lt; cpuCount; i++) { 
        unsigned int maxTicks = CPU_STATE_MAX * i; 
        totalUser += cpuInfo.cpu_ticks[maxTicks + CPU_STATE_USER]; 
        totalUserNice += cpuInfo.cpu_ticks[maxTicks  
                                           + CPU_STATE_SYSTEM]; 
        totalSystem += cpuInfo.cpu_ticks[maxTicks  
                                           + CPU_STATE_NICE]; 
        totalIdle += cpuInfo.cpu_ticks[maxTicks + CPU_STATE_IDLE]; 
    } 
 
    rawData.append(totalUser); 
    rawData.append(totalUserNice); 
    rawData.append(totalSystem); 
    rawData.append(totalIdle); 
    return rawData; 
} 
</pre><p>As you can see, the pattern used is strictly equivalent to the Linux implementation. You can even copy-paste the body of the <code class="literal">cpuLoadAverage()</code> function from the <code class="literal">SysInfoLinuxImpl.cpp</code> file. They do exactly the same thing.</p><p>Now, the implementation is different for the <code class="literal">cpuRawData()</code> function. We load <code class="literal">cpuInfo</code> and <code class="literal">cpuCount</code> with <code class="literal">host_statistics()</code> and then we loop through each CPU to have the <code class="literal">totalUser</code>, <code class="literal">totalUserNice</code>, <code class="literal">totalSystem</code>, and <code class="literal">totalIdle</code> functions filled. Finally, we append all this data to the <code class="literal">rawData</code> object before returning it.</p><p>The very last part is to compile the <code class="literal">SysInfoMacImpl</code> class only on Mac OS. Modify the <code class="literal">.pro</code> file to have the following body:</p><pre class="programlisting">... 
 
linux { 
    SOURCES += SysInfoLinuxImpl.cpp 
    HEADERS += SysInfoLinuxImpl.h 
} 
 
macx { 
    SOURCES += SysInfoMacImpl.cpp 
    HEADERS += SysInfoMacImpl.h 
} 
 
FORMS    += MainWindow.ui 
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Transforming SysInfo into a singleton</h1></div></div></div><p>Promises are made to be kept: we will now transform the <code class="literal">SysInfo</code> class into a singleton. C++ offers many ways to implement the singleton design pattern. We will explain one of them here. Open the <code class="literal">SysInfo.h</code> file and make the following changes:</p><pre class="programlisting">class SysInfo 
{ 
public: 
    static SysInfo&amp; instance(); 
    virtual ~SysInfo(); 
 
    virtual void init() = 0; 
    virtual double cpuLoadAverage() = 0; 
    virtual double memoryUsed() = 0; 
 
protected: 
    explicit SysInfo(); 
 
private: 
    SysInfo(const SysInfo&amp; rhs); 
    SysInfo&amp; operator=(const SysInfo&amp; rhs); 
}; 
</pre><p>The singleton must guarantee that there will be only one instance of the class and that this instance will be easily accessible from a single access point.</p><p>So the first thing to do is to change the visibility of the constructor to <code class="literal">protected</code>. This way, only this class and the child classes will be allowed to call the constructor.</p><p>Since only one instance of the object must exist, allowing the copy constructor and the assignment operator is nonsense. One way to solve the problem is to make them <code class="literal">private</code>.</p><div><h3 class="title"><a id="tip16"/>Tip</h3><p><strong>C++ tip</strong></p><p>Since C++11, you can define a function as deleted with the syntax void <code class="literal">myFunction() = delete</code>. Any use of a deleted function will display a compile-time error. It's another way to prevent the use of the copy constructor and the assignment operator with a singleton.</p></div><p>The last change is the "unique access point" with a <code class="literal">static</code> function instance that will return a reference of the <code class="literal">SysInfo</code> class.</p><p>It is now time to commit singleton changes to the <code class="literal">SysInfo.cpp</code> file:</p><pre class="programlisting">#include &lt;QtGlobal&gt; 
 
#ifdef Q_OS_WIN 
    #include "SysInfoWindowsImpl.h" 
#elif defined(Q_OS_MAC) 
    #include "SysInfoMacImpl.h" 
#elif defined(Q_OS_LINUX) 
    #include "SysInfoLinuxImpl.h" 
#endif 
 
SysInfo&amp; SysInfo::instance() 
{ 
    #ifdef Q_OS_WIN 
        static SysInfoWindowsImpl singleton; 
    #elif defined(Q_OS_MAC) 
        static SysInfoMacImpl singleton; 
    #elif defined(Q_OS_LINUX) 
        static SysInfoLinuxImpl singleton; 
    #endif 
 
    return singleton; 
} 
 
SysInfo::SysInfo() 
{ 
} 
 
SysInfo::~SysInfo() 
{ 
} 
</pre><p>Here you can see another Qt cross-OS trick. Qt provides some macro <code class="literal">Q_OS_WIN</code>, <code class="literal">Q_OS_LINUX</code>, or <code class="literal">Q_OS_MAC</code>. A Qt OS macro will be defined only on the corresponding OS. By combining these macros with a conditional preprocessor directive<code class="literal">#ifdef</code>, we can always include and instantiate the correct <code class="literal">SysInfo</code> implementation on all OSes.</p><p>Declaring the <code class="literal">singleton</code> variable as a static variable in the <code class="literal">instance()</code> function is a way to make a singleton in C++. We tend to prefer this version because you do not need to worry about the singleton memory management. The compiler will handle the instantiation the first time as well as the destruction. Moreover, since C++11 this method is thread safe.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Exploring Qt Charts</h1></div></div></div><p>The core part is ready. It's now time to create a UI for this project, and Qt Charts can help us with this task. Qt Charts is a module that provides a set of easy-to-use chart components, such as line chart, area chart, spline chart, pie chart, and so on.</p><p>Qt Charts was previously a commercial-only Qt module. Since Qt 5.7, the module is now included in Qt on GPLv3 license for open source users. If you are stuck on Qt 5.6, you can build the module by yourself from sources. More information can be found at <a class="ulink" href="https://github.com/qtproject/qtcharts">https://github.com/qtproject/qtcharts</a>.</p><p>The aim now is to create two Qt widgets, <code class="literal">CpuWidget</code> and <code class="literal">MemoryWidget</code>, to display nice Qt charts of the CPU and the memory used. These two widgets will share a lot of common tasks, so we will first create an abstract class, <code class="literal">SysInfoWidget</code>:</p><div><img src="img/image00361.jpeg" alt="Exploring Qt Charts"/></div><p style="clear:both; height: 1em;"> </p><p>Then the two actual widgets will inherit from the <code class="literal">SysInfoWidget</code> class and perform their specific tasks.</p><p>Create a new C++ class called <code class="literal">SysInfoWidget</code> with <code class="literal">QWidget</code> as a base class. Some enhancements must be processed in the <code class="literal">SysInfoWidget.h</code> file:</p><pre class="programlisting">#include &lt;QWidget&gt; 
#include &lt;QTimer&gt; 
#include &lt;QtCharts/QChartView&gt; 
 
class SysInfoWidget : public QWidget 
{ 
    Q_OBJECT 
public: 
    explicit SysInfoWidget(QWidget *parent = 0, 
                           int startDelayMs = 500, 
                           int updateSeriesDelayMs = 500); 
 
protected: 
    QtCharts::QChartView&amp; chartView(); 
 
protected slots: 
    virtual void updateSeries() = 0; 
 
private: 
    QTimer mRefreshTimer; 
    QtCharts::QChartView mChartView; 
}; 
</pre><p>The <code class="literal">QChartView</code> is the generic widget that can display many types of chart. This class will handle the layout and display the <code class="literal">QChartView</code>. A <code class="literal">QTimer</code> will call the slot function <code class="literal">updateSeries()</code> regularly. As you can see, this is a pure virtual slot. That is the reason why the <code class="literal">SysInfoWidget</code> class is abstract. The slot <code class="literal">updateSeries()</code> will be overridden by child classes to retrieve a system value and define how the chart should be drawn. Note that the parameters <code class="literal">startDelayMs</code> and <code class="literal">updateSeriesDelayMs</code> have default values that can be customized by the caller if required.</p><p>We can now proceed to the <code class="literal">SysInfoWidget.cpp</code> file to correctly prepare this <code class="literal">SysInfoWidget</code> class before creating the child widgets:</p><pre class="programlisting">#include &lt;QVBoxLayout&gt; 
 
using namespace QtCharts; 
 
SysInfoWidget::SysInfoWidget(QWidget *parent, 
                             int startDelayMs, 
                             int updateSeriesDelayMs) : 
    QWidget(parent), 
    mChartView(this) 
{ 
    mRefreshTimer.setInterval(updateSeriesDelayMs); 
    connect(&amp;mRefreshTimer, &amp;QTimer::timeout, 
            this, &amp;SysInfoWidget::updateSeries); 
    QTimer::singleShot(startDelayMs,  
        [this] { mRefreshTimer.start(); }); 
 
    mChartView.setRenderHint(QPainter::Antialiasing); 
    mChartView.chart()-&gt;legend()-&gt;setVisible(false); 
 
    QVBoxLayout* layout = new QVBoxLayout(this); 
    layout-&gt;addWidget(&amp;mChartView); 
    setLayout(layout); 
} 
 
QChartView&amp; SysInfoWidget::chartView() 
{ 
    return mChartView; 
} 
</pre><p>All tasks in the <code class="literal">SysInfoWidget</code> constructor are common tasks required by the child widgets, <code class="literal">CpuWidget</code>, and <code class="literal">MemoryWidget</code>. The first step is the <code class="literal">mRefreshTimer</code> initialization to define the timer interval and the slot to call whenever a timeout signal is triggered. Then the static function <code class="literal">QTimer::singleShot()</code> will start the real timer after a delay defined by <code class="literal">startDelayMs</code>. Here again, Qt combined with lambda functions will give us a powerful code in just a few lines. The next part enables the antialiasing to smooth the chart drawing. We hide the chart's legend to get a minimalist display. The last part handles the layout to display the <code class="literal">QChartView</code> widget in our <code class="literal">SysInfoWidget</code> class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>CpuWidget using QCharts</h1></div></div></div><p>Now that the base class <code class="literal">SysInfoWidget</code> is ready, let's implement its first child class: <code class="literal">CpuWidget</code>. We will now use the Qt Charts API to display a good-looking widget. The average CPU load will be displayed in a pie graph with a hole in the center, like a partly eaten donut where the eaten part is the percentage of the CPU used. The first step is to add a new C++ class named <code class="literal">CpuWidget</code> and make it inherit <code class="literal">SysInfoWidget</code>:</p><pre class="programlisting">#include "SysInfoWidget.h" 
 
class CpuWidget : public SysInfoWidget 
{ 
public: 
    explicit CpuWidget(QWidget* parent = 0); 
}; 
</pre><p>In the constructor, the only parameter needed is a <code class="literal">QWidget* parent</code>. Since we provided default values for the <code class="literal">startDelayMs</code> and <code class="literal">updateSeriesDelayMs</code> variables in <code class="literal">SysInfoWidget</code> class, we get the best possible behavior; there is no need to remember it when subclassing <code class="literal">SysInfoWidget</code>, but it is still easy to override it if need be.</p><p>The next step is to override the <code class="literal">updateSeries()</code> function from the <code class="literal">SysInfoWidget</code> class and start using the Qt Charts API:</p><pre class="programlisting">#include &lt;QtCharts/QpieSeries&gt; 
 
#include "SysInfoWidget.h" 
 
class CpuWidget : public SysInfoWidget 
{ 
    Q_OBJECT 
public: 
    explicit CpuWidget(QWidget* parent = 0); 
 
protected slots: 
    void updateSeries() override; 
 
private: 
    QtCharts::QPieSeries* mSeries; 
}; 
</pre><p>Since we overrode the <code class="literal">SysInfoWidget::updateSeries()</code> slot, we have to include the <code class="literal">Q_OBJECT</code> macro to allow <code class="literal">CPUWidget</code> to respond to the <code class="literal">SysInfoWidgetmRefreshTimer::timeout()</code> signal.</p><p>We include <code class="literal">QPieSeries</code> from the Qt Charts module so that we can create a member <code class="literal">QPieSeries*</code> named <code class="literal">mSeries</code>. The <code class="literal">QPieSeries</code> is a subclass of <code class="literal">QAbstractSeries</code>, which is the base class of all Qt Charts series (<code class="literal">QLineSeries</code>, <code class="literal">QAreaSeries</code>, <code class="literal">QPieSeries</code>, and so on). In Qt Charts, a <code class="literal">QAbstractSeries</code> subclass holds the data you want to display and defines how it should be drawn, but it does not define where the data should be displayed inside your layout.</p><p>We can now proceed to <code class="literal">CpuWidget.cpp</code> to investigate how we can tell Qt where the drawing takes place:</p><pre class="programlisting">using namespace QtCharts; 
 
CpuWidget::CpuWidget(QWidget* parent) : 
    SysInfoWidget(parent), 
    mSeries(new QPieSeries(this)) 
{ 
    mSeries-&gt;setHoleSize(0.35); 
    mSeries-&gt;append("CPU Load", 30.0); 
    mSeries-&gt;append("CPU Free", 70.0); 
 
    QChart* chart = chartView().chart(); 
    chart-&gt;addSeries(mSeries); 
    chart-&gt;setTitle("CPU average load"); 
} 
</pre><p>All Qt Charts classes are defined in the <code class="literal">QtCharts</code> namespace. This is why we start with <code class="literal">using namespace QtCharts</code>.</p><p>First, we initialize <code class="literal">mSeries</code> in the constructor initializer list. We then proceed to configure it. We carve the donut with <code class="literal">mSeries-&gt;setHoleSize(0.35)</code> and we append two data sets to <code class="literal">mSeries</code>: a fake <code class="literal">CPU Load</code> and <code class="literal">Cpu Free</code>, which are expressed in percentages. The <code class="literal">mSeries</code> function is now ready to be linked to the class managing its drawing: <code class="literal">QChart</code>.</p><p>The <code class="literal">QChart</code> class is retrieved from the <code class="literal">SysInfoWidget::chartView()</code> function. When calling <code class="literal">chart-&gt;addSeries(mSeries)</code>, <code class="literal">chart</code> takes the ownership of <code class="literal">mSeries</code> and will draw it according to the series type--in our case, a <code class="literal">QPieSeries</code>. <code class="literal">QChart</code> is not a <code class="literal">QWidget</code>: it is a subclass of <code class="literal">QGraphicsWidget</code>. <code class="literal">QGraphicsWidget</code> can be described as a lighter <code class="literal">QWidget</code> with some differences (its coordinates and geometry are defined with <code class="literal">doubles</code> or <code class="literal">floats</code> instead of <code class="literal">integers</code>, a subset of <code class="literal">QWidget</code> attributes are supported: custom drag, drop framework, and so on). The <code class="literal">QGraphicsWidget</code> class is designed to be added in a <code class="literal">QGraphicsScene</code> class, a high-performance Qt component used to draw hundreds of items on screen at the same time.</p><p>In our <code class="literal">SysInfo</code> application, the <code class="literal">QChart</code> has to be displayed in a <code class="literal">QVBoxLayout</code> in <code class="literal">SysInfoWidget</code>. Here, the <code class="literal">QChartView</code> class comes in very handy. It lets us add <code class="literal">chart</code> in a <code class="literal">QWidget</code> layout.</p><p>Up to now, <code class="literal">QPieSeries</code> has seemed rather abstract. Let's add it to the <code class="literal">MainWindow</code> file to see how it looks:</p><pre class="programlisting">// In MainWindow.h 
#include "CpuWidget.h" 
 
... 
 
private: 
    Ui::MainWindow *ui; 
    CpuWidget mCpuWidget; 
}; 
 
// In MainWindow.cpp 
MainWindow::MainWindow(QWidget *parent) : 
    QMainWindow(parent), 
    ui(new Ui::MainWindow), 
    mCpuWidget(this) 
{ 
    ui-&gt;setupUi(this); 
    SysInfo::instance().init(); 
    ui-&gt;centralWidget-&gt;layout()-&gt;addWidget(&amp;mCpuWidget); 
} 
</pre><p>We simply declare <code class="literal">mCpuWidget</code> in the <code class="literal">MainWindow.h</code> file, initialize it, and add it to <code class="literal">MainWindow-&gt;centralWidget-&gt;layout</code>. If you now run the application, you should see something like this:</p><div><img src="img/image00362.jpeg" alt="CpuWidget using QCharts"/></div><p style="clear:both; height: 1em;"> </p><p>Even though it looks cool, this donut is a bit static and does not reflect the CPU usage. Thanks to the architecture we built with the <code class="literal">SysInfo</code> and <code class="literal">SysInfoWidget</code> classes, the remaining part will be implemented swiftly.</p><p>Switch back to the <code class="literal">CpuWidget.cpp</code> file and implement the <code class="literal">updateSeries()</code> function with the following body:</p><pre class="programlisting">void CpuWidget::updateSeries() 
{ 
    double cpuLoadAverage = SysInfo::instance().cpuLoadAverage(); 
    mSeries-&gt;clear(); 
    mSeries-&gt;append("Load", cpuLoadAverage); 
    mSeries-&gt;append("Free", 100.0 - cpuLoadAverage); 
} 
</pre><p>First, we get a reference to our <code class="literal">SysInfo</code> singleton. We then retrieve the current average CPU load in the <code class="literal">cpuLoadAverage</code> variable. We have to feed this data to our <code class="literal">mSeries</code>. The <code class="literal">mSeries</code> object is a <code class="literal">QPieCharts</code>, which implies that we just want a snapshot of the current CPU average load. Past history is not meaningful with this kind of graph; that's why we clear the <code class="literal">mSeries</code> data with the <code class="literal">mSeries-&gt;clear()</code> syntax, and append the <code class="literal">cpuLoadAverage</code> variable and then the free part (<code class="literal">100.0 - cpuLoadAverage</code>).</p><p>The nice thing to note is that, in the <code class="literal">CpuWidget</code> class, we don't have to worry about refreshing. All the work is done in the <code class="literal">SysInfoWidget</code> subclass with all the whistles and bells of the <code class="literal">QTimer</code> class. In a <code class="literal">SysInfoWidget</code> subclass, we only have to concentrate on the valuable specific code: what data should be displayed and what kind of graph is used to display it. If you look at the whole <code class="literal">CpuWidget</code> class, it is very short. The next <code class="literal">SysInfoWidget</code> subclass, <code class="literal">MemoryWidget</code>, will also be very concise, as well as quick to implement.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Memory using Qcharts</h1></div></div></div><p>Our second <code class="literal">SysInfoWidget</code> is a <code class="literal">MemoryWidget</code> class. This widget will display a history of the data so that we can see how the memory consumption evolves over time. To display this data, we will use a <code class="literal">QLineSeries</code> class from the Qt Chart module. Create the <code class="literal">MemoryWidget</code> class and follow the same pattern we used for <code class="literal">CpuWidget</code>:</p><pre class="programlisting">#include &lt;QtCharts/QLineSeries&gt; 
 
#include "SysInfoWidget.h" 
 
class MemoryWidget : public SysInfoWidget 
{ 
    Q_OBJECT 
public: 
    explicit MemoryWidget(QWidget *parent = 0); 
 
protected slots: 
    void updateSeries() override; 
 
private: 
    QtCharts::QLineSeries* mSeries; 
    qint64 mPointPositionX; 
}; 
</pre><p>Instead of a being a <code class="literal">QPieSeries*</code>, <code class="literal">mSeries</code> is a type of <code class="literal">QLineSeries*</code> which will be linked to the <code class="literal">chart</code> object in a very similar fashion to <code class="literal">MemoryWidget.cpp</code>:</p><pre class="programlisting">#include "MemoryWidget.h" 
#include &lt;QtCharts/QAreaSeries&gt; 
 
using namespace QtCharts; 
 
const int CHART_X_RANGE_COUNT = 50; 
const int CHART_X_RANGE_MAX = CHART_X_RANGE_COUNT - 1; 
 
MemoryWidget::MemoryWidget(QWidget *parent) : 
    SysInfoWidget(parent), 
    mSeries(new QlineSeries(this)), 
    mPointPositionX(0) 
{ 
    QAreaSeries* areaSeries = new QAreaSeries(mSeries); 
 
    QChart* chart = chartView().chart(); 
    chart-&gt;addSeries(areaSeries); 
    chart-&gt;setTitle("Memory used"); 
    chart-&gt;createDefaultAxes(); 
    chart-&gt;axisX()-&gt;setVisible(false); 
    chart-&gt;axisX()-&gt;setRange(0, CHART_X_RANGE_MAX); 
    chart-&gt;axisY()-&gt;setRange(0, 100); 
} 
 
void MemoryWidget::updateSeries() 
{ 
} 
</pre><p>The <code class="literal">mSeries</code> data is, as usual, initialized in the initializer list. The <code class="literal">mPointPositionX</code> is an <code class="literal">unsigned long long</code> (using the Qt notation <code class="literal">qint64</code>) variable that will track the last X position of our data set. This huge value is used to make sure that <code class="literal">mPointPositionX</code> never overflows.</p><p>We then use an intermediate <code class="literal">areaSeries</code> that takes ownership of <code class="literal">mSeries</code> upon its initialization in <code class="literal">QAreaSeries* areaSeries = new QareaSeries(mSeries)</code>. <code class="literal">areaSeries</code> is then added to the <code class="literal">chart</code> object at <code class="literal">chart-&gt;addSeries(areaSeries)</code>. We do not want to display a single line in our <code class="literal">QChart</code>; instead we want to display an area that represents the used memory percentage. That is why we use an <code class="literal">areaSeries</code> type. Nonetheless, we will still update the <code class="literal">mSeries</code> data when adding new points to the dataset in the <code class="literal">updateSeries()</code> function. The <code class="literal">areaSeries</code> type will automatically handle them and deliver them to the <code class="literal">chart</code> object.</p><p>After <code class="literal">chart-&gt;addSeries(areaSeries)</code>, we configure the chart display:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">chart-&gt;createDefaultAxes()</code> function creates an <em>X</em> and <em>Y</em> axis based on the <code class="literal">areaSeries</code> type. If we used a 3D series, the <code class="literal">createDefaultAxes()</code> function would have added a <em>Z</em> axis.</li><li class="listitem">Hide the <em>X</em> axis tick values with <code class="literal">chart-&gt;axisX()-&gt;setVisible(false)</code> (intermediate values displayed at the bottom of the axis). In our <code class="literal">MemoryWidget</code> class, this information is not relevant.</li><li class="listitem">To define the number of points we want to display--the size of the display history--we call <code class="literal">chart-&gt;axisX()-&gt;setRange(0, CHART_X_RANGE_MAX)</code>. Here we use a constant to make it easier to modify this value afterwards. Seeing the value at the top of the file, we avoid having to skim through <code class="literal">MemoryWidget.cpp</code>, searching where this value is used to update it.</li><li class="listitem"><code class="literal">chart-&gt;axisY()-&gt;setRange(0, 100)</code> defines the maximum range of the <em>Y</em> axis, which is a percentage, based on the value returned by the <code class="literal">SysInfo::memoryUsed()</code> function.</li></ul></div><p>The chart is now properly configured. We now have to feed it by filling the <code class="literal">updateSeries()</code> body:</p><pre class="programlisting">void MemoryWidget::updateSeries() 
{ 
    double memoryUsed = SysInfo::instance().memoryUsed(); 
    mSeries-&gt;append(mPointPositionX++, memoryUsed); 
    if (mSeries-&gt;count() &gt; CHART_X_RANGE_COUNT) { 
        QChart* chart = chartView().chart(); 
        chart-&gt;scroll(chart-&gt;plotArea().width()  
                      / CHART_X_RANGE_MAX, 0); 
        mSeries-&gt;remove(0); 
    } 
} 
</pre><p>We first retrieve the latest memory percentage used and append it to <code class="literal">mSeries</code> at the <em>X</em> coordinate <code class="literal">mPointPositionX</code> (we post-increment it for the next <code class="literal">updateSeries()</code> call) and <em>Y</em> coordinate <code class="literal">memoryUsed</code>. As we want to keep a history of <code class="literal">mSeries</code>, <code class="literal">mSeries-&gt;clear()</code> is never called. However, what will happen when we add more than <code class="literal">CHART_X_RANGE_COUNT</code> points? The visible "window" on the chart is static and the points will be added outside. This means that we will see the memory usage only for the first <code class="literal">CHART_X_RANGE_MAX</code> points and then, nothing.</p><p>Fortunately, <code class="literal">QChart</code> provides a function to scroll inside the view to move the visible window. We start to handle this case only when the dataset is bigger than the visible window, meaning <code class="literal">if (mSeries-&gt;count() &gt; CHART_X_RANGE_COUNT)</code>. We then remove the point at the index 0 with <code class="literal">mSeries-&gt;remove(0)</code> to ensure that the widget will not store an infinite dataset. A SysInfo application that monitors the memory usage and has itself a memory leak is a bit sad.</p><p>The syntax <code class="literal">chart-&gt;scroll(chart-&gt;plotArea().width() / CHART_X_RANGE_MAX, 0)</code> will then scroll to the latest point on the <em>X</em> axis and nothing on <em>Y</em>. The <code class="literal">chart-&gt;scroll(dx, dy)</code> expects coordinates expressed in our series coordinates. That is the reason why we have to retrieve the <code class="literal">char-&gt;plotArea()</code> divided by <code class="literal">CHART_X_RANGE_MAX</code> , the <em>X</em> axis unit.</p><p>We can now add the <code class="literal">MemoryWidget</code> class in <code class="literal">MainWindow</code>:</p><pre class="programlisting">// In MainWindow.h 
#include "CpuWidget.h" 
#include "MemoryWidget.h" 
 
... 
 
private: 
    Ui::MainWindow *ui; 
    CpuWidget mCpuWidget; 
    MemoryWidget mMemoryWidget; 
}; 
 
// In MainWindow.cpp 
MainWindow::MainWindow(QWidget *parent) : 
    QMainWindow(parent), 
    ui(new Ui::MainWindow), 
    mCpuWidget(this), 
    mMemoryWidget(this) 
{ 
    ui-&gt;setupUi(this); 
    SysInfo::instance().init(); 
    ui-&gt;centralWidget-&gt;layout()-&gt;addWidget(&amp;mCpuWidget); 
    ui-&gt;centralWidget-&gt;layout()-&gt;addWidget(&amp;mMemoryWidget); 
} 
</pre><p>Just as we did for <code class="literal">CPUWidget</code>, add a new member named <code class="literal">mMemoryWidget</code> to <code class="literal">MainWindow</code> and add it to the <code class="literal">centralWidget</code> layout with the <code class="literal">uiâcentralWidget-&gt;layout()-&gt;addWidget(&amp;mMemoryWidget)</code> syntax.</p><p>Compile, run the application, and wait a few seconds. You should see something close to this:</p><div><img src="img/image00363.jpeg" alt="Memory using Qcharts"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">MemoryWidget</code> class works fine, but it looks a bit dull. We can customize it very easily with Qt. The goal is to have a bold line at the top of the memory area and a nice gradient from top to bottom. We just have to modify the <code class="literal">areaSeries</code> class in the <code class="literal">MemoryWidget.cpp</code> file:</p><pre class="programlisting">#include &lt;QtCharts/QAreaSeries&gt; 
#include &lt;QLinearGradient&gt; 
#include &lt;QPen&gt; 
 
#include "SysInfo.h" 
 
using namespace QtCharts; 
 
const int CHART_X_RANGE_MAX = 50; 
const int COLOR_DARK_BLUE = 0x209fdf; 
const int COLOR_LIGHT_BLUE = 0xbfdfef; 
const int PEN_WIDTH = 3; 
 
MemoryWidget::MemoryWidget(QWidget *parent) : 
    SysInfoWidget(parent), 
    mSeries(new QLineSeries(this)) 
{ 
    QPen pen(COLOR_DARK_BLUE); 
    pen.setWidth(PEN_WIDTH); 
 
    QLinearGradient gradient(QPointF(0, 0), QPointF(0, 1)); 
    gradient.setColorAt(1.0, COLOR_DARK_BLUE); 
    gradient.setColorAt(0.0, COLOR_LIGHT_BLUE); 
    gradient.setCoordinateMode(QGradient::ObjectBoundingMode); 
 
    QAreaSeries* areaSeries = new QAreaSeries(mSeries); 
    areaSeries-&gt;setPen(pen); 
    areaSeries-&gt;setBrush(gradient); 
 
    QChart* chart = chartView().chart(); 
    ... 
} 
</pre><p>The <code class="literal">QPen pen</code> function is a part of the <code class="literal">QPainter</code> API. It is the foundation on which Qt relies to do most of the GUI drawing. This includes the whole <code class="literal">QWidget</code> API (<code class="literal">QLabel</code>, <code class="literal">QPushButton</code>, <code class="literal">QLayout</code>, and so on). For the <code class="literal">pen</code>, we just have to specify its color and width, and then apply it to the <code class="literal">areaSeries</code> class with <code class="literal">areaSeries-&gt;setPen(pen)</code>.</p><p>The principle is the same for the gradient. We define the starting point (<code class="literal">QPointF(0, 0)</code>) and the final point (<code class="literal">QPointF(0, 1)</code>) before specifying the color at each end of the vertical gradient. The <code class="literal">QGradient::ObjectBoundingMode</code> parameter defines how the start/final coordinates are mapped to the object. With the <code class="literal">QAreaSeries</code> class, we want the gradient coordinates to match the whole <code class="literal">QareaSeries</code> class. These coordinates are normalized coordinates, meaning that <code class="literal">0</code> is the start and <code class="literal">1</code> is the end of the shape:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">[0.0]</code> coordinates will point to the top left corner of the <code class="literal">QAreaSeries</code> class</li><li class="listitem">The <code class="literal">[1.0]</code> coordinates will point to the bottom left corner of the <code class="literal">QAreaSeries</code> class</li></ul></div><p>A last build and run, and the <code class="literal">SysInfo</code> application will look like this:</p><div><img src="img/image00364.jpeg" alt="Memory using Qcharts"/><div><p>A memory leak or starting a virtual machine is a great way to make your memory go crazy</p></div></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">SysInfo</code> application is now finished, and we even added some visual polish. You can explore the <code class="literal">QGradient</code> classes and the <code class="literal">QPainter</code> API if you want to further customize the widget to your taste.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>The .pro file in depth</h1></div></div></div><p>When you click on the <strong>Build</strong> button, what exactly is Qt Creator doing? How does Qt handle the compilation of the different platforms with a single <code class="literal">.pro</code> file? What does the <code class="literal">Q_OBJECT</code> macro imply exactly? We will dig into each of these questions in the following sections. Our example case will be the <code class="literal">SysInfo</code> application we just completed, and we will study what Qt is doing under the hood.</p><p>We can start this study by digging into the <code class="literal">.pro</code> file. It is the main entry point in compiling any Qt project. Basically, a <code class="literal">.pro</code> file is a <code class="literal">qmake</code> project file describing the sources and headers used by the project. It is a platform-agnostic definition of a <code class="literal">Makefile</code>. First, we can cover the different <code class="literal">qmake</code> keywords used in the <code class="literal">ch02-sysinfo</code> application:</p><pre class="programlisting">#------------------------------------------------- 
# 
# Project created by QtCreator 2016-03-24T16:25:01 
# 
#------------------------------------------------- 
QT += core gui charts 
CONFIG += C++14 
 
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets 
 
TARGET = ch02-sysinfo 
TEMPLATE = app 
</pre><p>Each of these functions has specific roles:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">#</code>: This is the prefix needed to comment on a line. Yes, we generated the project on 2016-03-24-crazy, huh?</li><li class="listitem"><code class="literal">QT</code>: This is a list of the Qt modules used in the project. In the platform-specific Makefile, each of the values will include the module headers and the corresponding library link.</li><li class="listitem"><code class="literal">CONFIG</code>: This is a list of configuration options for the project. Here, we configure the support of C++14 in the Makefile.</li><li class="listitem"><code class="literal">TARGET</code>: This is the name of the target output file.</li><li class="listitem"><code class="literal">TEMPLATE</code>: This is the project template used when generating the <code class="literal">Makefile.app</code> tells <code class="literal">qmake</code> to generate a Makefile targeted for a binary. If you are building a library, use the <code class="literal">lib</code> value.</li></ul></div><p>In the <code class="literal">ch02-sysinfo</code> application, we started to use platform-specific compilation rules using the intuitive scope mechanism:</p><pre class="programlisting">windows { 
    SOURCES += SysInfoWindowsImpl.cpp 
    HEADERS += SysInfoWindowsImpl.h 
} 
</pre><p>If you had to do this with a <code class="literal">Makefile</code>, you would probably lose some hair before doing it right (being bald is not an excuse). This syntax is simple yet powerful, and is also used for conditional statements. Let's say you wanted to build some files on debug only. You would have written the following:</p><pre class="programlisting">windows { 
    SOURCES += SysInfoWindowsImpl.cpp 
    HEADERS += SysInfoWindowsImpl.h 
     
    debug { 
        SOURCES += DebugClass.cpp 
        HEADERS += DebugClass.h 
    } 
} 
</pre><p>Nesting the <code class="literal">debug</code> scope inside <code class="literal">windows</code> is the equivalent of <code class="literal">if (windows &amp;&amp; debug)</code>. The scoping mechanism is even more flexible; you can have the OR Boolean operator condition with this syntax:</p><pre class="programlisting">windows|unix { 
  SOURCES += SysInfoWindowsAndLinux.cpp 
} 
</pre><p>You can even have else if/else statements:</p><pre class="programlisting">windows|unix { 
  SOURCES += SysInfoWindowsAndLinux.cpp 
} else:macx { 
  SOURCES += SysInfoMacImpl.cpp 
} else { 
  SOURCES += UltimateGenericSources.cpp 
} 
</pre><p>In this code snippet, we also see the use of the <code class="literal">+=</code> operator. The qmake tool provides a wide range of operators to modify the behavior of variables:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">=</code>: This operator sets the variable to the value. The syntax <code class="literal">SOURCES = SysInfoWindowsImpl.cpp</code> would have assigned the single<code class="literal">SysInfoWindowsImpl.cpp</code> value to the <code class="literal">SOURCES</code> variable.</li><li class="listitem"><code class="literal">+=</code>: This operator adds the value to a list of values. This is what we commonly use in <code class="literal">HEADERS</code>, <code class="literal">SOURCES</code>, <code class="literal">CONFIG</code>, and so on.</li><li class="listitem"><code class="literal">-=</code>: This operator removes the value from the list. You can, for example, add a <code class="literal">DEFINE = DEBUG_FLAG</code> syntax in the common section and in a platform-specific scope (say a Windows release) remove it with the <code class="literal">DEFINE -= DEBUG_FLAG</code> syntax.</li><li class="listitem"><code class="literal">*=</code>: This operator adds the value to the list only if it is not already present. The <code class="literal">DEFINE *= DEBUG_FLAG</code> syntax adds the <code class="literal">DEBUG_FLAG</code> value only once.</li><li class="listitem"><code class="literal">~=</code>: This operator replaces any values that match a regular expression with the specified value, <code class="literal">DEFINE ~= s/DEBUG_FLAG/debug</code>.</li></ul></div><p>You can also define variables in the <code class="literal">.pro</code> file and reuse them in different places. We can simplify this with the use of the qmake <code class="literal">message()</code> function:</p><pre class="programlisting">COMPILE_MSG = "Compiling on" 
 
windows { 
    SOURCES += SysInfoWindowsImpl.cpp 
    HEADERS += SysInfoWindowsImpl.h 
    message($$COMPILE_MSG windows) 
} 
 
linux { 
    SOURCES += SysInfoLinuxImpl.cpp 
    HEADERS += SysInfoLinuxImpl.h 
    message($$COMPILE_MSG linux) 
} 
 
macx { 
    SOURCES += SysInfoMacImpl.cpp 
    HEADERS += SysInfoMacImpl.h 
    message($$COMPILE_MSG mac) 
} 
</pre><p>If you build the project, you will see your platform-specific message each time you build the project in the <strong>General Messages</strong> tab (you can access this tab from <strong>Window</strong> | <strong>Output Panes</strong> | <strong>General Messages</strong>). Here, we defined a <code class="literal">COMPILE_MSG</code> variable and referenced it when calling <code class="literal">message($$COMPILE_MSG windows)</code>. This offers interesting possibilities when you need to compile external libraries from your <code class="literal">.pro</code> file. You can then aggregate all the sources in a variable, combine it with the call to a specific compiler, and so on.</p><div><h3 class="title"><a id="tip17"/>Tip</h3><p>If your scope-specific statement is a single line, you can use the following syntax to describe it:</p></div><pre class="programlisting">windows:message($$COMPILE_MSG windows) 
</pre><p>Besides <code class="literal">message()</code>, there are a few other helpful functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">error(string)</code>: This function displays the string and exits the compilation immediately.</li><li class="listitem"><code class="literal">exists(filename)</code>: This function tests the existence of the <code class="literal">filename</code>. qmake also provides the <code class="literal">!</code> operator, which means you can write <code class="literal">!exist(myfile) { ... }</code>.</li><li class="listitem"><code class="literal">include(filename)</code>: This function includes the content of another <code class="literal">.pro</code> file. It gives you the ability to slice your <code class="literal">.pro</code> files into more modular components. This will prove very useful when you have multiple <code class="literal">.pro</code> files for a single big project.</li></ul></div><div><h3 class="title"><a id="note18"/>Note</h3><p>All the built-in functions are described at <a class="ulink" href="http://doc.qt.io/qt-5/qmake-test-function-reference.html">http://doc.qt.io/qt-5/qmake-test-function-reference.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Under the hood of qmake</h1></div></div></div><p>As we said earlier, qmake is the foundation of the Qt framework compilation system. In Qt Creator, when you click on the <strong>Build</strong> button, qmake is invoked. Let's study what qmake is exactly doing by calling it ourselves on the <strong>CLI</strong> (<strong>Command Line Interface</strong>).</p><p>Create a temporary directory where you will store the generated files. We are working on a Linux box, but this is transposable on any OS. We chose <code class="literal">/tmp/sysinfo</code>. Using the CLI, navigate to this new directory and execute the following command:</p><pre class="programlisting">
<strong>/path/to/qt/installation/5.7/gcc_64/bin/qmake -makefile -o Makefile /path/to/sysinfoproject/ch02-sysinfo.pro</strong>
</pre><p>This command will execute qmake in the <code class="literal">-makefile</code> mode to generate a Makefile based on your <code class="literal">sysinfo.pro</code> file. If you skim through the Makefile content, you will see many things we covered earlier in the <code class="literal">.pro</code> section. The link to Qt modules, headers of different modules, inclusion of the headers and sources files of your project, and so on.</p><p>Now, let's build this Makefile by simply typing the <code class="literal">make</code> command.</p><p>This command will generate the binary <code class="literal">ch02-sysinfo</code> (based on the <code class="literal">TARGET</code> value of the <code class="literal">.pro</code> file). If you look at the list of files now present in <code class="literal">/tmp/sysinfo</code>:</p><pre class="programlisting">
<strong>$ ls -1</strong>
<strong>ch02-sysinfo</strong>
<strong>CpuWidget.o</strong>
<strong>main.o</strong>
<strong>MainWindow.o</strong>
<strong>Makefile</strong>
<strong>MemoryWidget.o</strong>
<strong>moc_CpuWidget.cpp</strong>
<strong>moc_CpuWidget.o</strong>
<strong>moc_MainWindow.cpp</strong>
<strong>moc_MainWindow.o</strong>
<strong>moc_MemoryWidget.cpp</strong>
<strong>moc_MemoryWidget.o</strong>
<strong>moc_SysInfoWidget.cpp</strong>
<strong>moc_SysInfoWidget.o</strong>
<strong>SysInfoLinuxImpl.o</strong>
<strong>SysInfo.o</strong>
<strong>SysInfoWidget.o</strong>
<strong>ui_MainWindow.h</strong>
</pre><p>Now this is very interesting, we find all our sources compiled in the usual <code class="literal">.o</code> extension (<code class="literal">SysInfo.o</code>, <code class="literal">SysInfoWidget.o</code>, and so on) but there are also a lot of other files prefixed with <code class="literal">moc_</code>. Here lies another keystone of the Qt framework: the Meta Object Compiler.</p><p>Every time you use the signal/slot system, you have to include the macro <code class="literal">Q_OBJECT</code> in your header. Each time you emit a signal or receive one in a slot and you did not write any specific code to handle it, Qt took care of it. This is done by generating an intermediate implementation of your class (the <code class="literal">moc_*.cpp</code> file) containing everything Qt needs to properly handle your signals and slots.</p><p>A picture is worth a thousand words. Here is the complete compilation pipeline for a standard qmake project:</p><div><img src="img/image00365.jpeg" alt="Under the hood of qmake"/></div><p style="clear:both; height: 1em;"> </p><p>The blue boxes refer to commands and the wavy boxes are documents (sources or final binary). Let's walk through the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">qmake</code> command is executed with the project <code class="literal">.pro</code> file. It generates a Makefile based on the project file.</li><li class="listitem">The <code class="literal">make</code> command is executed, which will call other commands to generate intermediate files.</li><li class="listitem">The <code class="literal">uic</code> command stands for User Interface Compiler. It takes all the <code class="literal">.ui</code> files (which are basically an XML description of your interface) and generates the corresponding <code class="literal">ui_*.h</code> header that you include in your own <code class="literal">.cpp</code> (in our <code class="literal">ch02-sysinfo</code> project, it is in <code class="literal">MainWindow.cpp</code>).</li><li class="listitem">The <code class="literal">moc</code> command takes every class containing the <code class="literal">Q_OBJECT</code> macro (paired with the superclass <code class="literal">QObject</code>) and generates the intermediate <code class="literal">moc_*.cpp</code> files, which include everything needed to make the signal/slot framework work.</li><li class="listitem">The <code class="literal">g++</code> command is executed, compiling all your sources' files and intermediate <code class="literal">moc</code> files into <code class="literal">.o</code> files before finally linking everything in the binary <code class="literal">ch02-sysinfo</code>.</li></ol><div></div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>Note that if you add a <code class="literal">Q_OBJECT</code> macro after the creation of a class, sometimes the compiler will complain about your signals and slots. To fix this, simply run the <code class="literal">qmake</code> command from <strong>Build</strong> | <strong>Run qmake</strong>.
You can now see that this stems from the fact that the Makefile has to be regenerated to include the generation of the new intermediate <code class="literal">moc</code> file.</p></div><p>Generally, source code generation is regarded as bad practice in the developer community. Qt has been criticized on this topic for a long time. We always fear that the machines does some kind of voodoo behind our back. Unfortunately, C++ does not offer any practical way of doing code introspection (namely reflection), and the signal and slots mechanism needs some kind of metadata about your class to resolve your signals and slots. This could have been done partly with the C++ template system, but this solution seemed to Qt to be much less readable, portable, usable, and robust. You also need an excellent compiler support for templates. This cannot be assumed in the wild world of C++ compilers.</p><p>The <code class="literal">moc</code> system is now fully mature. There are some very specific edge cases where it could bring trouble (some have reported problems in very specific situations with Visual Studio), but even so, we think that the gain of this feature largely outweighs the possibly encountered issues. The signal/slot system is a marvel to work with, and if you look at the beginnings of Qt, the system has been present from the very first releases. Adding the functor notation in Qt 5 (which gives a compile time check of the validity of your <code class="literal">connect()</code>) combined with C++11 <code class="literal">lambas</code> makes it a real delight.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Beneath Q_OBJECT and signals/slots</h1></div></div></div><p>The Qt building system should be clearer now. Still, the <code class="literal">Q_OBJECT</code> macro and the signal/slot/emit keywords are still black boxes. Let's dive into <code class="literal">Q_OBJECT</code>.</p><p>The truth lies in the source code; <code class="literal">Q_OBJECT</code> is defined in the file <code class="literal">qobjectdefs.h</code> (in Qt 5.7):</p><pre class="programlisting">#define Q_OBJECT \ 
public: \ 
    // skipped details 
    static const QMetaObject staticMetaObject; \ 
    virtual const QMetaObject *metaObject() const; \ 
    virtual void *qt_metacast(const char *); \ 
    virtual int qt_metacall(QMetaObject::Call, int, void **); \ 
    QT_TR_FUNCTIONS \ 
private: \ 
    // skipped details  
qt_static_metacall(QObject *, QMetaObject::Call, int, void **); 
</pre><p>This macro defines some static functions and a <code class="literal">static QMetaObject</code>. The body of these static functions is implemented in the generated <code class="literal">moc</code> file. We will not drown you in the gory details of the <code class="literal">QMetaObject</code> class. The role of this class is to store all the metainformation for the <code class="literal">QObject</code> subclass. It also maintains a correspondence table between the signals and slots of your class, and to the signals and slots of any connected class. Each signal and each slot is assigned with a unique index:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">metaObject()</code> function returns the <code class="literal">&amp;staticMetaObject</code> for a normal Qt class and a <code class="literal">dynamicMetaObject</code> when working with QML objects.</li><li class="listitem">The <code class="literal">qt_metacast()</code> function performs a dynamic cast using the name of the class. This function is required because Qt does not rely on standard C++ <strong>RTTI</strong> (<strong>Runtime Type Information</strong>) to retrieve meta data about an object or a class.</li><li class="listitem">The <code class="literal">qt_metacall()</code>directly calls an internal signal or slot by its index. Because an index is used rather than a pointer, there is no pointer dereferencing, and the generated switch case can be heavily optimized by the compiler (the compiler can directly include the <code class="literal">jump</code> instruction to the specific case very early on, avoiding a lot of branch evaluation). Thus, the execution of the signal/slot mechanism is quite fast.</li></ul></div><p>Qt also adds non-standard C++ keywords to manage the signal/slot mechanism, namely <code class="literal"> signals</code>, <code class="literal">slots</code>, and <code class="literal">emit</code>. Let's see what is behind each one and see how everything fits inside a <code class="literal">connect()</code> function.</p><p>The <code class="literal">slots</code> and <code class="literal">signals</code> keywords are also defined in <code class="literal">qobjectdefs.h</code>:</p><pre class="programlisting">#     define slots 
#     define signals public 
</pre><p>That is right: <code class="literal">slots</code> points to nothing and the <code class="literal">signals</code> keyword is just a placeholder for the <code class="literal">public</code> keyword. All your <code class="literal">signals</code>/<code class="literal">slots</code> are just... functions. The <code class="literal">signals</code> keyword is forced to be <code class="literal">public</code> to make sure that your signal functions are visible outside of your class (what is the point of a <code class="literal">private signal</code> anyway?). The Qt magic is simply the ability to emit a <code class="literal">signal</code> keyword to any connected <code class="literal">slot</code> keyword without knowing the detail of the class implementing this <code class="literal">slot</code>. Everything is done through the <code class="literal">QMetaObject</code> class implementation in the <code class="literal">moc</code> file. When a <code class="literal">signal</code> keyword is emitted, the function <code class="literal">QMetaObject::activate()</code> is called with the changed value and the signals index.</p><p>The last definition to study is <code class="literal">emit</code>:</p><pre class="programlisting"># define emit 
</pre><p>So many definitions of nothing, it is almost absurd! The <code class="literal">emit</code> keyword is completely useless from a code perspective; <code class="literal">moc</code> plainly ignores it and nothing particular happens with it afterwards. It is merely a hint for the developer to notice he is working with signal/slots rather than plain functions.</p><p>To trigger a <code class="literal">slot</code>, you must connect your <code class="literal">signal</code> keyword to it using the <code class="literal">QObject::connect()</code> function. This function creates a new <code class="literal">Connection</code> instance that is defined in <code class="literal">qobject_p.h</code>:</p><pre class="programlisting">struct Connection 
    { 
        QObject *sender; 
        QObject *receiver; 
        union { 
            StaticMetaCallFunction callFunction; 
            QtPrivate::QSlotObjectBase *slotObj; 
        }; 
        // The next pointer for the singly-linked ConnectionList 
        Connection *nextConnectionList; 
        //senders linked list 
        Connection *next; 
        Connection **prev; 
        ... 
    }; 
</pre><p>The <code class="literal">Connection</code> instance stores a pointer to the signal emitter class (<code class="literal">sender</code>), the slot receiver class (<code class="literal">receiver</code>), and the indexes of the connected <code class="literal">signal</code> and <code class="literal">slot</code> keywords. When a signal is emitted, every connected slot must be called. To be able to do this, every <code class="literal">QObject</code> has a linked list of <code class="literal">Connection</code> instances for each of its <code class="literal">signal</code>, and the same linked list of <code class="literal">Connection</code> for each of its <code class="literal">slot</code> keywords.</p><p>This pair of linked lists allows Qt to properly walk through each dependent <code class="literal">slot</code>/<code class="literal">signal</code> couple to trigger the right functions using the indexes. The same reasoning is used to handle the <code class="literal">receiver</code> destruction: Qt walks through the double linked list and removes the object from where it was connected.</p><p>This walk happens in the famous UI thread, where the whole message loop is processed and every connected signal/slot is triggered according to the possible events (mouse, keyboard, network, and so on). Because the <code class="literal">QThread</code> class inherits the <code class="literal">QObject</code>, any <code class="literal">QThread</code> can use the signal/slot mechanism. Additionally, the <code class="literal">signals</code> keyword can be posted to other threads where they will be processed in the receiving threads' event loop.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we created a cross-platform <code class="literal">SysInfo</code> application. We covered the singleton and the strategy pattern to have a neat code organization with platform-specific code. You learned to use the Qt Charts module to display system information in real time. Finally, we took a deep dive into the <code class="literal">qmake</code> command to see how Qt implements the signal/slot mechanism, and to see what is hidden behind Qt-specific keywords (<code class="literal">emit</code>, <code class="literal">signals</code>, and <code class="literal">slots</code>).</p><p>By now, you should have a clear picture of how Qt works and how you can tackle a cross-platform application. In the next chapter, we will look at how you can split a bigger project in order to keep your sanity as a maintainer. We will study a fundamental pattern in Qt--the Model/View--and discover how to use a database with Qt.</p></div></body></html>