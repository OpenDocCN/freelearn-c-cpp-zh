- en: Domain-Driven Design (DDD) Principles and Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）原则和模式
- en: Most of the commercial software application is created with a set of complex
    business requirements to solve the specific business problems or needs. However,
    expecting all the software developers/architects to be experts on business domains
    and expecting them to know entire business functions is also impractical. On the
    other side, how do we create software that brings value and get consumers with
    automated business needs to use the software? Software applications cannot just
    be a showpiece of technical excellence, but in most cases, they also have to have
    a real ease of automated business excellence. The domain-driven design and models
    are the answers to our questions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数商业软件应用都是通过一组复杂业务需求创建的，以解决特定的业务问题或需求。然而，期望所有软件开发者/架构师都是业务领域的专家，并期望他们了解整个业务功能也是不切实际的。另一方面，我们如何创建具有价值的软件，并让具有自动化业务需求的消费者使用该软件？软件应用不能只是技术卓越的展示品，但在大多数情况下，它们也必须具有真正的自动化业务卓越的便利性。领域驱动设计和模型是我们问题的答案。
- en: This section will cover most of DDD aspects and patterns that can help successful
    implementations of DDD-based software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖大多数DDD方面和模式，这些模式有助于成功实施基于DDD的软件。
- en: '![](img/b2d2b6ab-d5ef-40d4-ad36-9b48065c3518.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2d2b6ab-d5ef-40d4-ad36-9b48065c3518.png)'
- en: The preceding diagram is an attempt to visualize a domain-driven software model
    driven by collaborated effort from domain and technology experts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是尝试通过领域和技术专家的协作努力来可视化由领域驱动软件模型。
- en: DDD concepts, principles, and patterns bring technology and business excellence
    together to any sophisticated software applications that can be created and managed.
    DDD was coined by Evan and most of the content of this chapter is the influence
    of his book *Domain-Driven Design - Tackling Complexity in the Heart of Software*
    and also from the book *Pattern-Principles-And Practices* by Scott Millett and
    Nick Tune.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的概念、原则和模式将技术和商业卓越结合到任何复杂的软件应用中，这些应用可以创建和管理。DDD是由Evan提出的，本章的大部分内容受到了他的书籍《领域驱动设计
    - 软件核心的复杂性处理》的影响，同时也受到了Scott Millett和Nick Tune的书籍《模式-原则-实践》的影响。
- en: This section intends to cover a few essential aspects of DDD and also discuss
    a few common domain-driven design patterns in detail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在涵盖DDD的一些基本方面，并详细讨论一些常见的领域驱动设计模式。
- en: Principles, characteristics, and practices of DDD
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDD的原则、特性和实践
- en: Before we delve into various design patterns, let us touch upon the fundamental
    principles of DDD, then few primary characteristics constituents, and also few
    best practices that help teams to adopt and follow DDD.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入各种设计模式之前，让我们先谈谈DDD的基本原则，然后是一些主要特性组成部分，以及一些最佳实践，这些实践有助于团队采用和遵循DDD。
- en: Principles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则
- en: The fundamental principles of DDD are described in the following sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的基本原则在以下章节中描述。
- en: Focusing on the core domain
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专注于核心领域
- en: This principle suggests product development teams to focus more on the core
    domain, that is, the parts that are most important to a business and which need
    more attention than others. So, we need to identify the core domain by distilling
    and decomposing a big problem domain into subdomains. For instance, when designing
    a retail banking software, we should focus on the credit and debit accounting
    instead of the manufacturing and distribution of credit cards and debit cards
    as they support functions and they can be outsourced as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则建议产品开发团队更多地关注核心领域，即对业务最重要的部分，这些部分比其他部分需要更多的关注。因此，我们需要通过提炼和分解一个大问题领域到子领域来识别核心领域。例如，在设计零售银行软件时，我们应该关注信贷和借记会计，而不是信用卡和借记卡的制造和分销，因为它们是支持功能，也可以外包。
- en: Collaborate and learn
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作和学习
- en: As we mentioned in the introduction section, software experts may not know the
    domain, and the domain analysts may not know the technology and software implementations.
    So, collaboration and learning from each other is inevitable for DDD aspects,
    without which the software design or development won't happen at all. For instance,
    to develop a back office software application for an investment bank, the risk
    management experts and Software experts need to work together to learn the systems,
    applicability, usability, banking customer's intentions, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在引言部分提到的，软件专家可能不了解领域，而领域分析师可能不了解技术和软件实现。因此，对于领域驱动设计（DDD）方面，相互协作和学习是不可避免的，没有这种协作，软件开发或开发根本不会发生。例如，为了开发一家投资银行的后台软件应用程序，风险管理专家和软件专家需要一起工作，学习系统、适用性、可用性、银行客户的意图等等。
- en: In recent days, traditional banks are collaborating with financial technology
    startups aka fintech, as they see significant benefits of data analytics, AI,
    and machine learning into core banking systems as they would be able to take accurate
    decisions, innovate faster along with solving banking industry's everyday problems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的日子里，传统银行正在与金融科技公司（fintech）合作，因为他们看到数据分析、人工智能（AI）和机器学习在核心银行系统中的显著益处，这将使他们能够做出准确的决策，更快地进行创新，并解决银行业日常问题。
- en: Model the domain
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模领域
- en: As we now understand the collaboration and learn principle from the previous
    section, the collaboration, deep learning, and get insights of the core domain
    along with fundamental functions, this is inevitable. The output expected out
    of model the domain principle is a domain model, which is well-organized and structured
    knowledge of the problem in the core domain space along with fundamental concepts,
    vocabulary, issues, and relationships among the involved entities. You can seek
    contributions from different stakeholders such as analysts, domain experts, business
    partners, tech savvy users, and core developers and build these domain models,
    so everyone in a team understands the functional concepts and definitions and
    also how the current problem is tackled and solved.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从上一节中理解到的协作和学习原则，协作、深入学习和获取核心领域的洞察力，以及基本功能，这是不可避免的。模型领域原则的预期输出是一个领域模型，它是在核心领域空间中组织良好和结构化的知识，包括基本概念、词汇、问题以及涉及实体的关系。你可以从不同的利益相关者那里寻求贡献，如分析师、领域专家、商业伙伴、技术熟练的用户和核心开发者，并构建这些领域模型，这样团队中的每个人都能理解功能概念和定义，以及当前问题是如何被解决和处理的。
- en: Evolve
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演进
- en: Another critical aspect of the domain model is evolution. Domain models need
    to evolve over time through iterations and feedback. The design team starts with
    one significant problem and traverses through different scopes of the core domain
    along with generated models with incremental changes iteratively. It is critical
    as models need to adjust to feedback from domain experts while delivering domain
    models dealing with complexity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型的关键方面之一是演进。领域模型需要通过迭代和反馈随着时间的推移而演进。设计团队从一个重要问题开始，随着生成模型的增量变化，迭代地穿越核心领域的不同范围。这至关重要，因为模型需要调整以适应领域专家的反馈，同时处理复杂性。
- en: Talk in ubiquitous language
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用语言进行交流
- en: Collaborating, learning, and defining a model brings a lot of initial communication
    barriers between software specialists and domain experts. So, evolving domain
    models by practicing the same type of communications (discussions, writings, and
    diagrams) within a context is paramount for successful implementations, and this
    sort of conversation is called ubiquitous language. It is structured around the
    domain model and extensively used by all the team members within a bounded context.
    It should be the medium or mode to connect all the activities of the team during
    the development of software.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 协作、学习和定义模型会在软件专家和领域专家之间带来许多初始的沟通障碍。因此，通过在特定上下文中实践相同类型的沟通（讨论、写作和图表）来演进领域模型对于成功的实施至关重要，这种对话被称为通用语言。它是围绕领域模型构建的，并在有限上下文中被所有团队成员广泛使用。它应该是连接团队在软件开发过程中所有活动的媒介或方式。
- en: The design team can establish deep understanding, and connect domain jargons
    and software entities with ubiquitous language to keep discovering and evolving
    their domain models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设计团队可以建立深入的理解，并通过通用语言将领域术语和软件实体联系起来，以持续发现和演进他们的领域模型。
- en: Characteristics
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征
- en: 'The following characteristics are the primary constituents and may serve as
    a glossary of items that we will discuss in this chapter. You will see that many
    of these are factored into the patterns that we present in this section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下特征是主要组成部分，可能作为我们将在此章节中讨论的项目词汇表。您将看到其中许多都被纳入了我们在此部分中提出的模式中：
- en: '**Domain model**: Organized and structured knowledge related to the specific
    problem.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域模型**：与特定问题相关的组织化和结构化知识。'
- en: '**Bounded context**: A system fulfils the fundamental goals of the real-world
    complex business problems, provides a clear and shared understanding of what can
    be consistent, and what can be independent.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界上下文**：一个系统满足现实世界复杂业务问题的基本目标，提供对什么是可以一致的以及什么是可以独立的清晰和共享的理解。'
- en: '**Entities**: These are mutable objects, which can change their attributes
    without changing their identity (for example, the employee''s ID doesn''t change
    even when their email ID, address, and name changes).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：这些是可以改变其属性而不改变其身份的可变对象（例如，即使员工的电子邮件ID、地址和姓名发生变化，员工的ID也不会改变）。'
- en: '**Value objects**: These are immutable objects (unlike entities), distinguishable
    only by the state of their properties. The equality of value objects is not based
    on their identity. (Two location objects can be the same by their long and latitude
    values.)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值对象**：这些是不可变对象（与实体不同），只能通过其属性的状态来区分。值对象的等价性不是基于其身份的。（两个位置对象可以通过其经纬度值相同。）'
- en: '**Encapsulation**: Fields of an object are exposed only for private access,
    in other words, detected only through accessor methods (setters and getters).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：对象的字段仅公开供私有访问，换句话说，只能通过访问器方法（设置器和获取器）检测到。'
- en: '**Aggregate**: This is a collection of entities (for example, a computer is
    an aggregate of entities such as software and hardware). The aggregate may not
    work without those objects.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：这是实体（例如，计算机是软件和硬件等实体的聚合）。聚合可能在没有这些对象的情况下无法工作。'
- en: '**Aggregate root**: This is an entry point to aggregates, and only known reference
    to any outside object. This helps to create the precise boundary around aggregates.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合根**：这是聚合的入口点，也是任何外部对象的已知引用。这有助于为聚合创建精确的边界。'
- en: Best practices
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'We have listed a few best practices for a team that intends to dwell in DDD
    for their software product development:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列出了一些针对打算在软件开发产品开发中采用DDD的团队的最佳实践：
- en: Gather requirements and capture required behaviors
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集需求并捕获所需的行为
- en: Focus on what stakeholders want, when, and why
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注利益相关者想要什么、何时以及为什么
- en: Distill the problem space
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提炼问题空间
- en: Be a problem solver first, technologist comes second
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先成为一个问题解决者，其次才是技术专家
- en: Manage the complexity with abstraction and create subdomains
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象和创建子域来管理复杂性
- en: Understand the reality of the landscape with context maps and bounded contexts
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文映射和边界上下文来理解现实世界的景观
- en: Model a solution, tackle ambiguity, and carve out an area of safety
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模解决方案，解决歧义，并划出安全区域
- en: Make implicit concepts explicit
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将隐含的概念明确化
- en: DDD patterns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDD 模式
- en: In this section, we will browse through a set of patterns to build enterprise
    applications from the domain models. Applying these design patterns together with
    OO concepts to a system helps meet the business needs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将浏览一系列模式，从领域模型构建企业应用程序。将这些设计模式与面向对象概念结合应用于系统，有助于满足业务需求。
- en: This section covers significant aspects of DDD design patterns grouped as strategic
    design patterns and tactical design patterns of DDD.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了DDD设计模式的重大方面，分为战略设计模式和战术设计模式。
- en: Strategic patterns
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战略模式
- en: The primary aim of this group is to bring understanding and consensus between
    the business and the software development teams with more emphasis on business
    interests and goals. The strategic patterns help software development team members
    focus on what is more important and critical to the business by identifying a
    core domain. The core domain is a particular area of the company or even a specific
    slice that is critical.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该小组的主要目标是促进业务和软件开发团队之间的理解和共识，更侧重于业务利益和目标。战略模式帮助软件开发团队成员通过识别核心领域来关注对业务更重要和关键的事情。核心领域是公司的一个特定领域，甚至是一个关键的特定部分。
- en: Few primary constituents of strategic patters are ubiquitous language, domain,
    subdomain, core domain, bounded context, and a context map. We will see how one
    can integrate the disparate systems via the strategic design patterns such as
    bounded context, messaging, and REST discussed in this chapter with those constituents.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 战略模式的主要组成部分包括通用语言、领域、子领域、核心领域、边界上下文和上下文映射。我们将看到如何通过本章讨论的战略设计模式，如边界上下文、消息传递和REST，将这些组成部分整合到不同的系统中。
- en: Ubiquitous language
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用语言
- en: 'A model acts as a universal language to manage communication between software
    developers and domain experts. The following table shows the example of ubiquitous
    languages and their equivalent pseudo code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模型充当通用语言，以管理软件开发者和领域专家之间的沟通。以下表格展示了通用语言及其等效伪代码的示例：
- en: '| **Ubiquitous language** | **Equivalent pseudo code** | **Comments** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **通用语言** | **等效伪代码** | **注释** |'
- en: '| We administer vaccines | `AdministerVaccines {}` | Not a core domain—need
    some more specific details |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 我们注射疫苗 | `AdministerVaccines {}` | 不是核心领域——需要更多具体细节 |'
- en: '| We administer flu shots to patients | `patientNeedAFluShot()` | Better, may
    be missing some domain concepts |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 我们向患者注射流感疫苗 | `patientNeedAFluShot()` | 更好，可能缺少一些领域概念 |'
- en: '| Nurse administers flu vaccines to patient in standard doses | `Nurse->administer
    vaccine(patient, Vaccine.getStandardDose())` | Much better, and may be good to
    start with |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 护士以标准剂量向患者注射流感疫苗 | `Nurse->administer vaccine(patient, Vaccine.getStandardDose())`
    | 更好，可能是一个好的开始 |'
- en: Domain, subdomain, and core domain
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域、子领域和核心领域
- en: Domain refers to a problem space that software teams try to create a solution
    for, and represents how the actual business works. The vaccines example from the
    table can be seen as domain, with the end-to-end flow, managing vaccinations,
    preventive medicines, dosages, side effects, and so on. Core domain is the core
    business that the organization does not want to outsource. So, the core domain
    here in this context is vaccination, and other functions like patients management,
    cost of vaccines, vaccination camps, and so on are subdomains and are outside
    of the core domain. Core domains interact with subdomains.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 领域指的是软件团队试图为其创建解决方案的问题空间，并代表实际业务的工作方式。表中的疫苗示例可以被视为领域，具有端到端流程，管理疫苗接种、预防性药物、剂量、副作用等。核心领域是组织不希望外包的核心业务。因此，在这个上下文中，核心领域是疫苗接种，而其他如患者管理、疫苗成本、疫苗接种活动等职能是子领域，并且位于核心领域之外。核心领域与子领域相互作用。
- en: Bounded contexts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界上下文
- en: Bounded contexts are distinctive conceptual lines that define the boundaries
    and separate the contexts from other parts of the system. A bounded context represents
    refined business capabilities, and it is the focus of DDD. It deals with large
    distributed models and teams by dividing them into different bounded contexts
    and being explicit about their interrelationships.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 边界上下文是独特的概念线条，定义了边界并将上下文与其他系统部分区分开来。边界上下文代表了精细的业务能力，并且是领域驱动设计（DDD）的焦点。它通过将它们划分为不同的边界上下文并明确它们的相互关系来处理大型分布式模型和团队。
- en: '![](img/4ca6eb76-6a72-46f1-83ef-1d3175cd3572.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ca6eb76-6a72-46f1-83ef-1d3175cd3572.png)'
- en: Before we go deeper into patterns, let's refresh the idea about bounded contexts.
    The preceding diagram depicts account in both contexts; though the account doesn't
    differ, the contexts do. The following sections deal with patterns that help integrate
    the bounded contexts for any DDD solution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨模式之前，让我们先回顾一下边界上下文的概念。前面的图示显示了两个上下文中的账户；尽管账户没有差异，但上下文是有区别的。以下几节将讨论有助于整合任何DDD解决方案的边界上下文的模式。
- en: Integrating bounded contexts
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成边界上下文
- en: The Bounded contexts help in identifying the  relationships between subsystems
    and so one can choose the communication methods between those subsystems. Selecting
    appropriate communication and establishing relationships with the established
    communication is the responsibility of the designers, which helps them too to
    ensure there is no impact on project delivery timelines and efficiency. An example
    of integration and establishing communication reflecting explicit models could
    be integrating a payment system with an e-commerce sales system. Choosing the
    communication method is critical, and we will see more of integrating bounded
    contexts in the following sections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 边界上下文有助于识别子系统之间的关系，因此可以选择子系统之间的通信方法。选择适当的通信并建立与现有通信的关系是设计者的责任，这也有助于他们确保不会影响项目交付的时间表和效率。一个集成和建立通信的例子可能是将支付系统与电子商务销售系统集成。选择通信方法至关重要，我们将在以下章节中看到更多关于集成边界上下文的内容。
- en: Autonomous bounded context
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主边界上下文
- en: To ensure atomicity, design loosely coupled systems with fewer dependencies;
    solutions can also be developed in isolation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保原子性，设计松散耦合的系统，减少依赖；解决方案也可以独立开发。
- en: The shared-nothing architecture
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无共享架构
- en: 'While guaranteeing bounded contexts to be self-reliant, retaining the integrity
    of the bounded context is also critical. The shared-nothing pattern suggests that
    each bounded context has its own data stores, codebases, and developers, as shown
    in the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在保证边界上下文自给自足的同时，保持边界上下文的完整性也是至关重要的。无共享模式建议每个边界上下文都有自己的数据存储、代码库和开发者，如下面的图所示：
- en: '![](img/f8f15882-8a22-4a16-b5b1-7921ad3f16fd.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8f15882-8a22-4a16-b5b1-7921ad3f16fd.png)'
- en: As each bounded context is physically isolated, it can evolve independently
    for internal reasons, resulting in uncompromised domain model with super-efficient
    and faster delivery of business values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个边界上下文在物理上是隔离的，它可以独立于内部原因进行演变，从而产生无妥协的领域模型，以及超级高效和更快的业务价值交付。
- en: Single responsibility codes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责代码
- en: It's a best practice to partition the software systems according to their business
    capabilities, that is, by isolating separate business capabilities into different
    bounded contexts. For example, the shipping code of the business is not affected
    by a new shipping provider that got added to Sales.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照业务能力对软件系统进行分区是一种最佳实践，即通过将不同的业务能力隔离到不同的边界上下文中。例如，业务中的运输代码不会受到添加到销售的新运输提供商的影响。
- en: Multiple bounded contexts (within a solution)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个边界上下文（在解决方案内）
- en: Depending on the code (language), deployments, and infrastructure, there are
    situations where different bounded context resides in the same code repository
    or a solution with combined contexts to depict one big picture of full business
    use cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码（语言）、部署和基础设施，存在不同边界上下文位于同一代码仓库或具有组合上下文的解决方案中，以描绘完整业务用例的整体图景的情况。
- en: '![](img/40bf1981-ce39-40b0-b26b-c53c86c066fe.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40bf1981-ce39-40b0-b26b-c53c86c066fe.png)'
- en: To maintain the different contexts within a solution, this pattern suggests
    keeping namespaces distinct or recommends projects to keep bounded contexts separate.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了维护解决方案内的不同上下文，此模式建议保持命名空间区分或建议项目将边界上下文分开。
- en: Adoption of SOA principles
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用 SOA 原则
- en: Build highly scalable systems using DDD with SOA concepts and patterns. Build
    bounded context as SOA services to solve the technical and social challenges (integrating
    teams and developing at a high velocity) of bounded context integration. Please
    refer to [Chapter 7](45460494-ac40-47e3-9d76-731dd2a48e12.xhtml), *Service-Oriented
    Architecture (SOA)*, for more details on SOA's principles and practices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DDD 和 SOA 概念和模式构建高度可扩展的系统。将边界上下文作为 SOA 服务构建，以解决边界上下文集成中的技术和社交挑战（集成团队和高速开发）。请参阅[第
    7 章](45460494-ac40-47e3-9d76-731dd2a48e12.xhtml)，*面向服务的架构 (SOA)*，以了解更多关于 SOA 原则和实践的细节。
- en: Integrating with legacy systems
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与遗留系统集成
- en: Legacy systems is always a case in the real world, and they come with exciting
    challenges while we try to incorporate the latest industry improvements into them.
    In DDD, this problem is more interesting to address as there are many handy patterns
    available that help limit the impact of the legacy on the other parts of the system,
    manage complexity, and save designers from having to reduce explicitness (against
    DDD philosophy) of their new code to integrate into legacy modules or components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留系统在现实世界中总是存在，当我们试图将最新的行业改进融入其中时，它们会带来令人兴奋的挑战。在DDD中，这个问题更有趣，因为有许多实用的模式可以帮助限制遗留系统对系统其他部分的影响，管理复杂性，并帮助设计师避免在将新代码集成到遗留模块或组件时降低其显式性（违反DDD哲学）。
- en: We will touch upon bubble context, autonomous bubble context, and expose legacy
    systems as services in this section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论气泡上下文、自主气泡上下文，并将遗留系统作为服务进行展示。
- en: The bubble context
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 气泡上下文
- en: If a team wants to start applying the DDD to the legacy systems but it is not
    yet familiar with DDD practices, then the bubble context pattern can be considered.
    As the bounded context in the legacy may be an isolated codebase, the bubble context
    pattern provides clarity, and directions that to the team to create domain models
    and evolve as well. The bubble context reflects the best of the DDD philosophy
    of iteration, and it progresses by having full control over the domain model.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个团队想要开始将领域驱动设计（DDD）应用于遗留系统，但尚未熟悉DDD实践，那么可以考虑气泡上下文模式。由于遗留系统中的边界上下文可能是一个独立的代码库，气泡上下文模式提供了清晰的方向，帮助团队创建领域模型并不断演进。气泡上下文反映了DDD迭代哲学的最好方面，并通过完全控制领域模型来推进。
- en: It is considered as the best fit to facilitate frequent iterations and get insights
    even when legacy code is involved.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它被认为是最适合促进频繁迭代并在涉及遗留代码的情况下获得洞察力的。
- en: '![](img/51d152a0-ea88-4b0d-a18e-1d7c174f9e7c.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51d152a0-ea88-4b0d-a18e-1d7c174f9e7c.png)'
- en: When you need to integrate with legacy code but do not want to create any dependency
    or tight coupling with a legacy system, as bubble context does, this pattern suggests
    using an anonymous bubble called **autonomous bubble context**. Bubble context
    gets all its data from the legacy system, whereas the autonomous bubble context
    has its own data store and is able to run in isolation of the legacy code or other
    bounded contexts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要与遗留代码集成，但又不想像气泡上下文那样创建任何依赖或紧密耦合时，这种模式建议使用一个名为**自主气泡上下文**的匿名气泡。气泡上下文从遗留系统中获取所有数据，而自主气泡上下文有自己的数据存储，并且能够在与遗留代码或其他边界上下文隔离的情况下运行。
- en: '![](img/eb068434-670e-4196-8d98-7ed13058de43.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb068434-670e-4196-8d98-7ed13058de43.png)'
- en: The preceding diagram depicts the autonomous bubble context, and you may notice
    that the bubble context has dependencies with legacy context. However, the autonomous
    bubble context has its own storage, and so it can run in isolation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了自主气泡上下文，你可能注意到气泡上下文与遗留上下文存在依赖关系。然而，自主气泡上下文有自己的存储，因此它可以独立运行。
- en: The anti-corruption layer
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反腐层
- en: An isolating layer talks to the other systems through its existing interface
    with little or no modifications (to the other systems) and provides clients with
    the functionality of their own domain. This layer is responsible for translating
    communication between the two models in both directions, as needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离层通过其现有的接口与其它系统进行通信，几乎不需要（对其他系统）进行修改，并为客户端提供其自身领域的功能。这一层负责在两个模型之间按需进行双向通信的转换。
- en: Expose as a service
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为服务公开
- en: It may be a good idea to expose legacy system as a service, especially when
    the legacy context needs to be consumed by multiple new contexts. This pattern
    is also known as the **open host pattern**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将遗留系统作为服务公开可能是一个好主意，特别是当遗留上下文需要被多个新的上下文消费时。这种模式也被称为**开放主机模式**。
- en: '![](img/f38594dc-1293-4a6c-9a0a-7f1feb3385bd.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f38594dc-1293-4a6c-9a0a-7f1feb3385bd.png)'
- en: Each new context still has to translate the response from the legacy to its
    internals; however, with simplified open host APIs, one can mitigate the translation
    complexity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的上下文仍然需要将遗留系统的响应转换为内部表示；然而，通过简化的开放主机API，可以减轻转换复杂性。
- en: With this pattern, there is a need for some modifications to the legacy context
    (unlike the bubble context); also, standardization of consumable API SLAs may
    be challenging as it has multiple consumers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，需要对遗留上下文（与气泡上下文不同）进行一些修改；此外，由于有多个消费者，标准化可消费API SLA可能具有挑战性。
- en: We can clearly justify that a lot of legacy systems in the real world would
    like to adopt DDD; however, with the lack of right patterns and given the cost
    and impacts, there are genuine reasons and hesitations to move toward DDD. Recognizing
    and harnessing these models should ease the situations and encourage organizations
    to adopt DDD for their legacy systems and progress toward faster delivery.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地证明，现实世界中许多遗留系统都希望采用领域驱动设计（DDD）；然而，由于缺乏合适的模式和考虑到成本和影响，有真正的理由和犹豫不决去转向DDD。识别和利用这些模型应该会缓解情况，并鼓励组织为他们的遗留系统采用DDD，并朝着更快交付的方向发展。
- en: Distributed bounded context integration strategies
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式边界上下文集成策略
- en: Distribution is inevitable in the modern world for various reasons, and primarily
    for system abilities such as availability, scalability, reliability, and fault
    tolerance. This section briefly touches upon a few integration strategies for
    the distributed bounded context, such as Database integration, Flat file integration,
    Messaging, and REST. We will cover how those patterns help integeratting distributed
    bounded contexts. Also, we will see (briefly) how reactive solutions help in integration
    strategies.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代世界中，由于各种原因，分布是不可避免的，主要是为了系统能力，如可用性、可伸缩性、可靠性和容错性。本节简要介绍了分布式边界上下文的一些集成策略，例如数据库集成、平面文件集成、消息传递和REST。我们将探讨这些模式如何帮助集成分布式边界上下文。此外，我们还将简要了解反应式解决方案如何帮助集成策略。
- en: Database integration
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库集成
- en: The database integration pattern is one of the conventional approaches of using
    a single data source that lets an application write to a specific database location
    and lets another application read from it. The access by another application can
    be made as polling with some frequency. This pattern might come in handy for prototypes
    or even for **most viable product** (**MVP**) delivery.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库集成模式是使用单个数据源的传统方法之一，允许一个应用程序写入特定的数据库位置，并允许另一个应用程序从中读取。另一个应用程序的访问可以通过一定频率的轮询来实现。这种模式对于原型或甚至对于**最具可行性的产品**（**MVP**）的交付可能很有用。
- en: '![](img/151448d8-35a0-4240-b087-b5c825f79970.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/151448d8-35a0-4240-b087-b5c825f79970.png)'
- en: The preceding diagram depicts an example of database integration, where the
    sales team inserts the records and the billing context polls to the same data
    source. If it finds the sales record, it processes and updates the same row.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了数据库集成的一个示例，其中销售团队插入记录，计费上下文轮询相同的数据源。如果它找到销售记录，它将处理并更新同一行。
- en: While this pattern has advantages of loose coupling, it also has a few drawbacks,
    such as single point of failure, and needs a mechanism for efficient fault handling
    and so on. DB down scenario is a SPOF example, and to mitigate, one may need to
    go with a clustered DB, buy more hardware to scale, or consider the cloud infrastructure,
    and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此模式具有松耦合的优点，但也存在一些缺点，例如单点故障，需要有效的故障处理机制等。数据库宕机场景是一个单点故障的例子，为了缓解，可能需要采用集群数据库，购买更多硬件以进行扩展，或者考虑云基础设施等。
- en: Flat file integration
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平面文件集成
- en: The flat file integration pattern is similar to database integration; however,
    instead of having a database to integrate two components, it suggests using flat
    files. The updates, inserts, and polling are needed just as we would in another
    pattern, but this is a little more flexible. However, this comes with some disadvantages
    like managing the file formats, concurrency, and locks, among other things, would
    need more involvement and effort, leading to scalability and reliability issues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 平面文件集成模式类似于数据库集成；然而，它不是使用数据库来集成两个组件，而是建议使用平面文件。更新、插入和轮询的需求就像在其他模式中一样，但这一点更为灵活。然而，这也带来了一些缺点，如管理文件格式、并发性和锁定等问题，需要更多的参与和努力，从而导致可伸缩性和可靠性问题。
- en: '![](img/8bce9704-1c8d-4154-a20c-5a9ee448daf4.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bce9704-1c8d-4154-a20c-5a9ee448daf4.png)'
- en: This diagram is the sample implementation for flat file integration and involves
    polling, update, and delete.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是平面文件集成的示例实现，涉及轮询、更新和删除。
- en: Event-driven architecture and messaging
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构和消息传递
- en: Messaging and event-driven architecture pattern bring the best out of modeling
    communication between bounded contexts with distributed systems. This section
    under DDD intends to ensure you understand the significance of EDA and messaging
    patterns within the context of DDD. And also to emphasize the benefit of implementing
    asynchronous messaging and EDA patterns for communication between the contexts.
    The benefits include increased reliability even on failures of subsystems. We
    have covered most of the EDA and messaging patterns well and in-depth in [Chapter
    8](dd57ac86-dadf-486b-9ecd-068e1f8ffc59.xhtml), *Event-Driven Architecture Patterns,*
    and [Chapter 9](45854889-267b-45bb-b951-a54c22f5d850.xhtml), *Microservices Architecture
    Patterns*, and we encourage you to refer to those chapters and get insights about
    event-driven and messaging patterns.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和事件驱动架构模式将分布式系统中边界上下文之间的建模发挥到极致。在本节中，DDD旨在确保您理解EDA和消息模式在DDD上下文中的重要性。同时，强调在上下文之间实现异步消息和EDA模式的好处。这些好处包括即使在子系统失败的情况下也能提高可靠性。我们在第8章[事件驱动架构模式](dd57ac86-dadf-486b-9ecd-068e1f8ffc59.xhtml)和第9章[微服务架构模式](45854889-267b-45bb-b951-a54c22f5d850.xhtml)中已经很好地覆盖了EDA和消息模式，并鼓励您参考这些章节，以获得关于事件驱动和消息模式的见解。
- en: Tactical patterns
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战术模式
- en: Tactical patterns help manage complexities and provide clarity in behaviors
    of domain models. The primary focus of these patterns is to protect models from
    corruption by offering protection layers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 战术模式有助于管理复杂性，并在域模型的行为中提供清晰性。这些模式的主要重点是保护模型免受损坏，通过提供保护层来实现。
- en: In this section, we will touch upon the few of the common patterns that help
    in creating object-oriented domain models.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍一些有助于创建面向对象域模型的常见模式。
- en: At the end of this section, we will also briefly cover the emerging patterns
    of event sourcing and domain events.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的结尾，我们还将简要介绍事件源和域事件的兴起模式。
- en: Patterns to model the domain
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于建模域的模式
- en: This section will discuss few tactical patterns, and explain how they represent
    the policies and logic within the problem domain. They express elements of models
    in the code, the relationship between the objects and model rules, and bind the
    analysis details to the code implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论一些战术模式，并解释它们如何表示问题域内的策略和逻辑。它们在代码中表达模型元素，对象与模型规则之间的关系，并将分析细节绑定到代码实现。
- en: 'We will discuss the following patterns in details:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论以下模式：
- en: Entities
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体
- en: Value Objects
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象
- en: Domain Services
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域服务
- en: Modules
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Aggregates
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Factories
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂
- en: Repositories
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库
- en: 'The following diagram depicts various tactical patterns and their logical flow:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了各种战术模式及其逻辑流程：
- en: '![](img/79db211f-8530-4ad0-b25d-4283d0b24f4b.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79db211f-8530-4ad0-b25d-4283d0b24f4b.png)'
- en: Entities
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: As stated in the introduction section, an entity is a mutable object. It can
    change its attributes without changing its identity. For example, a product is
    an entity, which is unique and won't change its ID (distinctiveness) once it is
    set.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍部分所述，实体是一个可变对象。它可以改变其属性而不会改变其身份。例如，产品是一个实体，它是唯一的，一旦设置，就不会改变其ID（独特性）。
- en: However, its price, description, and so on, can be changed as many as times
    it needs to.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其价格、描述等可以根据需要更改多次。
- en: '![](img/96f748f2-ac41-4feb-b6d5-d5376530207c.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96f748f2-ac41-4feb-b6d5-d5376530207c.png)'
- en: The preceding diagram depicts an entity along with an example. An employee ID
    is unique and never changes. However, there is a contact detail that can be modified
    by accessor methods.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图展示了实体及其示例。员工ID是唯一的，永远不会改变。然而，有一个可以通过访问器方法修改的联系方式。
- en: 'Entities have the following properties:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实体具有以下属性：
- en: They are defined by their identity
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们由其标识符定义
- en: The identity remains the same throughout its lifetime
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符在其整个生命周期中保持不变
- en: They are responsible for equality checks
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们负责进行等式检查
- en: Value objects
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象
- en: Unlike entities, value objects are immutable and used as descriptors for model
    elements. They are known to the system only by their characteristics, and they
    don't need to have unique identifiers. They are always associated with other objects
    (for example, Delivery Address in the sales order can be a value object) and it
    is consistently associated with sales order context; otherwise, it doesn't have
    any meaning.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与实体不同，值对象是不可变的，用作模型元素的描述符。它们只通过其特征为系统所知，并且不需要有唯一的标识符。它们始终与其它对象相关联（例如，销售订单中的交货地址可以是值对象），并且始终与销售订单上下文相关联；否则，它们没有任何意义。
- en: '![](img/5e0227f1-046c-4230-a4d3-43310452eaa1.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e0227f1-046c-4230-a4d3-43310452eaa1.png)'
- en: 'The preceding diagram depicts the basic concept of a value object along with
    an example, and the following diagram is a sample class representation of entity
    and value object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了值对象的基本概念和示例，以下图示是实体和值对象的示例类表示：
- en: '![](img/5110e924-7c70-440e-8836-b5d28e7666e2.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5110e924-7c70-440e-8836-b5d28e7666e2.png)'
- en: 'The following list describes the characteristics of value objects:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了值对象的特征：
- en: They describe the properties and characteristics within a problem domain
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们描述了问题域内的属性和特征
- en: They do not have an identity
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有标识符
- en: They are immutable, that is, the content of the object cannot be changed; instead,
    properties modeled as value objects must be replaced
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的，也就是说，对象的内容不能被更改；相反，作为值对象建模的属性必须被替换
- en: Domain services
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域服务
- en: In ubiquitous language, there are situations where actions cannot be attributed
    to any specific entity or value object, and those operations can be termed as
    **domain service** (not an application service).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用语言中，存在某些操作无法归因于任何特定实体或值对象的情况，这些操作可以称为**领域服务**（不是应用服务）。
- en: 'Domain services encapsulate the domain logic and concepts that may not be modeled
    as entities or value objects, and they are responsible for orchestrating business
    logic using entities and value objects. The following are a few characteristics/features
    of domain services:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 领域服务封装了可能无法建模为实体或值对象的领域逻辑和概念，并负责使用实体和值对象编排业务逻辑。以下是一些领域服务的特征/功能：
- en: Domain services neither have identity nor state
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域服务既没有标识符也没有状态
- en: Any operation performed by the domain services does not belong to any of the
    existing entities
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域服务执行的任何操作都不属于任何现有实体
- en: Any domain operation in the domain service carry specific objects of the domain
    model
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域服务中的任何领域操作都携带特定领域模型的对象
- en: 'The following class diagram depicts a sample money transfer operation from
    one account to another. As we won''t be knowing in which object we can store the
    transfer operation, we choose domain service for this operation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图展示了从一个账户到另一个账户的示例货币转账操作。由于我们不知道在哪个对象中可以存储转账操作，我们选择领域服务进行此操作：
- en: '![](img/8f5e3c27-0b10-4fb4-9a90-dd8884af7fa9.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f5e3c27-0b10-4fb4-9a90-dd8884af7fa9.png)'
- en: Modules
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Modules are used to decompose the domain model. Naming the modules is part of
    the ubiquitous language, and they represent a distinct part of domain models and
    enable clarity when in isolation. Modules help developers to quickly read and
    understand the domain model in code before deep diving into class development.
    Note that decomposing domain models is different from subdomains' decomposition
    of the domain and bounded context.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 模块用于分解领域模型。命名模块是通用语言的一部分，它们代表领域模型的一个独立部分，并在独立时提供清晰性。模块帮助开发者快速阅读和理解代码中的领域模型，在深入进行类开发之前。请注意，分解领域模型与子域分解领域和边界上下文不同。
- en: '![](img/579f737d-efe5-433f-89e5-fbf1c7c566c9.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/579f737d-efe5-433f-89e5-fbf1c7c566c9.png)'
- en: The preceding diagram depicts a sample module name and a sample template to
    follow.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了示例模块名称和遵循的示例模板。
- en: Aggregates
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: 'In DDD, the concept of an aggregate is a boundary that helps in decomposing
    larger modules into smaller clusters of domain objects, and so the technical complexities
    can be managed as a high level of abstraction. Aggregates help in doing the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DDD 中，聚合的概念是一个边界，有助于将较大的模块分解为较小的领域对象集群，从而可以将技术复杂性作为高级抽象来管理。聚合有助于以下方面：
- en: Reducing and constraining relationships between domain objects
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减缓和约束领域对象之间的关系
- en: Grouping objects of the same business use cases and viewing them as a unified
    model
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将具有相同业务用例的对象分组，并将它们视为一个统一模型
- en: Every aggregate has a specific root and border, and within that particular border,
    all the possible invariants should be satisfied. Domain invariants are statements
    or rules that always need to be adhered to and help preserve consistency (also
    known as **atomic transactional coherence**).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每个聚合体都有一个特定的根和边界，并且在这个特定的边界内，所有可能的不变量都应该得到满足。域不变量是始终需要遵守的陈述或规则，有助于保持一致性（也称为**原子事务一致性**）。
- en: '![](img/93238711-632e-48b8-a34c-44633a53bfa4.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93238711-632e-48b8-a34c-44633a53bfa4.png)'
- en: 'The preceding diagram represents an aggregator sample implementation and brief
    information about each class and its characteristics associated with aggregates
    context as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了一个聚合体示例实现以及每个类及其与聚合体上下文相关的简要信息如下：
- en: '**CreditReport**: This includes user information and links, and saves and stores
    external linkage by **Customer ID** (identifier).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CreditReport**：这包括用户信息和链接，并通过**Customer ID**（标识符）保存和存储外部链接。'
- en: '**CustomerID**: This an independent aggregate that preserves user information'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CustomerID**：这是一个独立的聚合体，用于保留用户信息'
- en: '**CreditScore**: This holds credit rating estimation rule and act as invariants.
    This invariant gets modified/impacted based on credit modifications history.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CreditScore**：这包含信用评分估算规则并作为不变量。这个不变量根据信用修改历史进行修改/影响。'
- en: '**CreditHistoryEntry**: This helps achieve transactional coherence when it''s
    modified.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CreditHistoryEntry**：这有助于在修改时实现事务一致性。'
- en: '**Inquiry**: This can handle specific credit score requests from third-party
    organizations.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Inquiry**：这可以处理第三方组织特定的信用评分请求。'
- en: Factories
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: Factories are a pattern to separate the use (of the object) from the construction
    (of the object). Aggregates, entities, and value objects create some level of
    complexity within a domain model, especially with larger domain models. Factories
    help to express the (creation and use of) complex objects in a better manner.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是一种模式，用于将对象的使用（对象）与构建（对象）分离。聚合体、实体和值对象在域模型中创建了一定程度的复杂性，尤其是在较大的域模型中。工厂有助于以更好的方式表达（创建和使用）复杂对象。
- en: '![](img/0764ab63-8a60-4c70-b081-b79bde8e523f.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0764ab63-8a60-4c70-b081-b79bde8e523f.png)'
- en: 'The preceding diagram might help grasp a quick detail about factory creation
    from the DDD perspective. The following are some characteristics of factories
    that we would want to be refreshed with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图可能有助于从领域驱动设计（DDD）的角度快速了解工厂创建的细节。以下是一些我们希望刷新的工厂特性：
- en: Separating use from construction
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将使用与构建分离
- en: Encapsulating internals (and avoid exposing the internals of aggregate)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装内部（并避免暴露聚合体的内部）
- en: Hiding decisions on the creation type-domain layer factories to abstract the
    type of class to be created
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏在创建类型域层工厂中的决策，以抽象要创建的类的类型
- en: Decluttering complex domain models
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理复杂的域模型
- en: '![](img/b2dd5863-bb9b-4278-8514-721072e32706.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2dd5863-bb9b-4278-8514-721072e32706.png)'
- en: The preceding class diagram intends to give a sample view of the factory implementation
    for car models to be created; the creation complexity is abstract to the domain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图旨在给出创建汽车模型的工厂实现的示例视图；创建复杂性被抽象为域。
- en: Repositories
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: Repositories are patterns to manage aggregate persistence and retrieval while
    ensuring a clear separation between the data model and the domain model. Repositories
    are mediators that act as a collection of facades for storage and persistence.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库是管理聚合体持久化和检索的模型，同时确保数据模型和域模型之间的清晰分离。仓库是充当存储和持久化门面的中介。
- en: '![](img/5ea8b761-2ccd-4cc5-b6a1-611e7cdab2c2.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ea8b761-2ccd-4cc5-b6a1-611e7cdab2c2.png)'
- en: The preceding diagram depicts a sample structure of a repository model. It shows
    the client operation of save and update (persistence) with aggregates, through
    repository, while there is a separate access to the repository (**Deals with Aggregate**
    in the above diagram); a clear separation between the domain and data model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了一个仓库模型的示例结构。它显示了客户端的保存和更新（持久化）操作，通过仓库与聚合体进行，同时存在对仓库的单独访问（上图中的**处理聚合体**）；域和数据模型之间的清晰分离。
- en: 'Repositories differ from traditional data access strategies in the following
    three ways:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库在以下三个方面与传统数据访问策略不同：
- en: They restrict access to domain objects by allowing the retrieval and persistence
    of aggregate roots while ensuring that all the changes and invariants are handled
    by aggregates
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过允许检索和持久化聚合根来限制对领域对象的访问，同时确保所有更改和不变性都由聚合处理
- en: They hide the underlying technology used for persistence and retrieval of aggregates
    from the facades
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们隐藏了用于从外观中持久化和检索聚合的底层技术
- en: They define a boundary between the domain model and the data model
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们定义了领域模型和数据模型之间的边界
- en: 'We have the following two types of repositories:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下两种类型的存储库：
- en: Repositories as collections
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库作为集合
- en: Repositories as permanent data storage
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库作为永久数据存储
- en: '![](img/3371eeb4-6e3f-4210-8c97-a3ac8f7e1442.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3371eeb4-6e3f-4210-8c97-a3ac8f7e1442.png)'
- en: The preceding class diagram depicts a sample structure of a repository class
    and its underlying layer. The repository is within the infrastructure layer and
    extends the domain layer interface (restrict access).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类图描述了存储库类及其底层层的示例结构。存储库位于基础设施层，并扩展了领域层接口（限制访问）。
- en: Emerging patterns
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新兴模式
- en: 'In this section, we will cover the following two emerging patterns:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下两种新兴模式：
- en: '**Domain events**: They enforce consistency between multiple aggregates of
    the same domain'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域事件**：它们强制执行同一领域内多个聚合之间的致性'
- en: '**Event sourcing**: This is a way of persisting the application''s state and
    finding the current state by traversing through the history of those saved states'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件源**：这是一种通过遍历保存状态的历史来持久化应用程序状态并找到当前状态的方法'
- en: Domain events
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域事件
- en: The domain event pattern is a preferred a way to trigger side effects across
    multiple aggregates within the same domain. A domain event is an event that occurs
    in a particular domain, which the other parts of the same domain (subdomain) should
    also be aware of and may need to react to it as well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件模式是触发同一领域内多个聚合的副作用的首选方式。领域事件是在特定领域发生的事件，该领域的其他部分（子领域）也应该了解并可能需要对其做出反应。
- en: '![](img/fdc631d0-c222-41c1-82c3-b5b02d1d8742.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdc631d0-c222-41c1-82c3-b5b02d1d8742.png)'
- en: 'A domain event pattern helps to do the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件模式有助于以下操作：
- en: Express the side effects of an event in a domain explicitly
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确表达事件的副作用
- en: Maintain consistency of the side effects (either all the operations related
    to the business task are performed or none of them are)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护副作用的致性（要么执行与业务任务相关的所有操作，要么一个都不执行）
- en: Enable a better separation of concerns among classes within the same domain
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一领域内的类之间实现更好的关注点分离
- en: Event sourcing
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源
- en: Event sourcing provides simplification of various events, and it is a way of
    persisting an application's state and finding the current state by traversing
    through the history of those saved states. An example could be a seat reservation
    system that scans the completed bookings and finds out how many more seats are
    available when a new booking request arrives.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源简化了各种事件，它是一种通过遍历保存状态的历史来持久化应用程序状态并找到当前状态的方法。一个例子可以是座位预订系统，它扫描完成的预订，并在新的预订请求到达时找出还有多少座位可用。
- en: The seat allocation depends on various events (booking, cancellations, modifications,
    and so on), and it can be handled differently with the event sourcing pattern.
    This is of immense help in some domains where the audit trail is a critical requirement,
    (accounting, financial transactions, flight reservations, and so on), and also
    the pattern helps achieve better performance as events are immutable and support
    append-only operations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 座位分配取决于各种事件（预订、取消、修改等），并且可以使用事件源模式以不同的方式处理。这在某些领域非常有帮助，在这些领域，审计跟踪是一个关键要求（会计、金融交易、航班预订等），并且该模式有助于实现更好的性能，因为事件是不可变的，并支持仅追加操作。
- en: 'The following requirements may hint where we need to use event sourcing as
    a pattern:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要求可能暗示我们需要在哪里使用事件源作为模式：
- en: A simple standalone object to access complex relational storage module
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的独立对象，用于访问复杂的关联存储模块
- en: Audit Trails (these are a critical requirement)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计跟踪（这是一个关键要求）
- en: Integration with other subsystems
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他子系统的集成
- en: Production troubleshooting (by storing the events and replaying)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产故障排除（通过存储事件并回放）
- en: 'We need to be aware of a few general concerns as follows about event sourcing
    so that we can have trade-offs and mitigation plans:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要意识到关于事件源的一些一般性关注点，如下所述，以便我们可以进行权衡和缓解计划：
- en: '**Versioning**: As event sourcing systems are append-only models, they face
    unique versioning challenges. Imagine we need to read an event that was created/written
    years ago into the event-sourcing system. So versioning is necessary to change
    the definition of a specific event type or aggregate at some point in the future,
    and one needs to have clear and definite plans and strategies for managing multiple
    versions for event-source models.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：由于事件源系统是只读模型，它们面临着独特的版本控制挑战。想象一下，我们需要将几年前创建/写入的事件读入事件源系统。因此，版本控制是必要的，以便在未来的某个时刻更改特定事件类型或聚合的定义，并且需要制定清晰和明确的计划与策略来管理事件源模型的多版本。'
- en: '**Querying**: This is a little expensive as it gets deeper. It depends on the
    level and period of the states to be retrieved.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：这有点昂贵，因为它越深。它取决于要检索的状态的级别和时期。'
- en: '**Timeout**: This is the time taken to load the domain object state by querying
    the event store for all the events related to the state of the aggregate.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：这是通过查询事件存储来加载聚合状态所需的时间，查询所有与聚合状态相关的事件。'
- en: Other patterns
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他模式
- en: 'Before concluding this chapter, take a look at the following list of patterns
    that are important as a part of DDD, however, not covered in this chapter. You
    are encouraged to review our references section to get an insight into the following
    topics:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，请查看以下列表，这些模式是作为 DDD 的一部分重要的，但本章没有涵盖。我们鼓励您查看我们的参考文献部分，以深入了解以下主题：
- en: Layered architecture
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层架构
- en: Service layers
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层
- en: Application services
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务
- en: Refactoring toward deeper insight
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向更深入的洞察力重构
- en: Supple design
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的设计
- en: Making behavior visible (intention revealing interfaces)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行为可视化（意图揭示界面）
- en: Side-effect-free functions
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无副作用的函数
- en: '**Representational state transfer** (**REST**)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示状态转移**（**REST**）'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Sometimes, software design experts get into confusion when to and when not
    to use domain models. The following points might help you get an insight into
    DDD for efficient decision making and decide to implement DDD or not:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，软件设计专家会陷入困惑，不知道何时以及何时不使用领域模型。以下要点可能有助于您深入了解 DDD，以便进行有效的决策并决定是否实施 DDD：
- en: Business cases and requirements are particular, specific to domains, and not
    related to technology implementations
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务案例和需求是特定的，特定于领域，与技术实现无关
- en: 'As an independent team, they wanted to go to DDD when:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一支独立的团队，他们希望在以下情况下转向 DDD：
- en: The team has never done earlier that sort of business cases
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队从未做过那种类型的业务案例
- en: The team need help from domain experts
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队需要来自主题专家的帮助
- en: The business cases are more complex
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务案例更加复杂
- en: The team need to start from ground zero, and there are no previous models exists
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队需要从零开始，并且没有先前的模型存在
- en: When the given design problem is important to your business
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当给定的设计问题对你的业务很重要时
- en: Skilled, motivated, and passionate team to execute
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技能、动机和热情的团队来执行
- en: Have greater access to domain experts who are aligned with product vision
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够更容易地接触到与产品愿景一致的主题专家
- en: Willing to follow iterative methodology
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愿意遵循迭代方法
- en: Nontrivial problem domain that is critical to business
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对业务至关重要的非平凡问题域
- en: Great understanding of vision
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对愿景有深刻的理解
- en: Business goals, values, success and failure factors, and how is it going to
    be different from earlier implementations
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务目标、价值观、成功和失败因素，以及它将如何与早期实施不同
- en: To summarize, this chapter has short introductions to core principles, characteristics,
    and best practices for a team to get a head start and adopt DDD. Then, we introduced
    strategic patterns such as ubiquitous language, domain, subdomain, core domain,
    and bounded context in detail. We also covered the most essential aspects of DDD,
    such as autonomous bounded context, shared nothing architecture, single responsibility
    codes, multiple bounded contexts, and a bit of thought process about SOA principles
    concerning DDD aspects as part of integrating bounded contexts. We also saw the
    bubble context, autonomous bubble context, and expose as a service as part of
    the significant real-world problem of integrating with legacy systems. We introduced
    you to database integration, flat file integration, and event-driven messaging
    as part of distributed bounded context integration strategies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章简要介绍了团队为了提前采用 DDD 而需要了解的核心原则、特性和最佳实践。然后，我们详细介绍了战略模式，如通用语言、领域、子领域、核心领域和边界上下文。我们还涵盖了
    DDD 的最基本方面，如自治边界上下文、无共享架构、单一职责代码、多个边界上下文，以及关于 DDD 方面的 SOA 原则的一些思考过程，作为集成边界上下文的一部分。我们还看到了泡沫上下文、自治泡沫上下文以及将服务公开作为与遗留系统集成的重要现实问题的部分。我们介绍了数据库集成、平面文件集成和事件驱动消息作为分布式边界上下文集成策略的一部分。
- en: 'As part of tactical patterns, this chapter covered entity, value objects, domain
    services, modules, aggregates, factories, and repositories and also discussed
    two emerging patterns: domain events and event sourcing.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为战术模式的一部分，本章涵盖了实体、值对象、领域服务、模块、聚合、工厂和存储库，并讨论了两种新兴模式：领域事件和事件溯源。
- en: References and further reading materials
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献和进一步阅读材料
- en: 'For more information, you can refer to the following books:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，您可以参考以下书籍：
- en: '*Domain-Driven DESIGN - Tackling Complexity in the Heart of Software* - Eric
    Evans (Pearson)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域驱动设计 - 软件核心的复杂性处理* - Eric Evans 著（Pearson）'
- en: '*Patterns, Principles, and Practices of Domain-Driven Design* - Scott Millet
    with Nick Tune (Wrox)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域驱动设计的模式、原则和实践* - Scott Millet 与 Nick Tune 著（Wrox）'
- en: 'You can refer to the following online resources, too:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以参考以下在线资源：
- en: DDD quickly: [https://www.infoq.com/minibooks/domain-driven-design-quickly](https://www.infoq.com/minibooks/domain-driven-design-quickly)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD 快速入门：[https://www.infoq.com/minibooks/domain-driven-design-quickly](https://www.infoq.com/minibooks/domain-driven-design-quickly)
- en: Framework and tools: [https://isis.apache.org/documentation.html](https://isis.apache.org/documentation.html)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架和工具：[https://isis.apache.org/documentation.html](https://isis.apache.org/documentation.html)
- en: Three guiding principles: [https://techbeacon.com/get-your-feet-wet-domain-driven-design-3-guiding-principles](https://techbeacon.com/get-your-feet-wet-domain-driven-design-3-guiding-principles)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个指导原则：[https://techbeacon.com/get-your-feet-wet-domain-driven-design-3-guiding-principles](https://techbeacon.com/get-your-feet-wet-domain-driven-design-3-guiding-principles)
- en: Getting started with DDD: [https://dzone.com/storage/assets/1216461-dzone-rc-domain-driven-design.pdf](https://dzone.com/storage/assets/1216461-dzone-rc-domain-driven-design.pdf)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD 入门：[https://dzone.com/storage/assets/1216461-dzone-rc-domain-driven-design.pdf](https://dzone.com/storage/assets/1216461-dzone-rc-domain-driven-design.pdf)
- en: Model evaluation and management: [https://arxiv.org/ftp/arxiv/papers/1409/1409.2361.pdf](https://arxiv.org/ftp/arxiv/papers/1409/1409.2361.pdf)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型评估和管理：[https://arxiv.org/ftp/arxiv/papers/1409/1409.2361.pdf](https://arxiv.org/ftp/arxiv/papers/1409/1409.2361.pdf)
- en: '[https://www.infoq.com/articles/ddd-in-practice](https://www.infoq.com/articles/ddd-in-practice)
    (characteristics of DDD)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.infoq.com/articles/ddd-in-practice](https://www.infoq.com/articles/ddd-in-practice)
    (DDD 的特性)'
- en: '[https://www.codeproject.com/Articles/1158628/Domain-Driven-Design-What-You-Need-to-Know-About-S](https://www.codeproject.com/Articles/1158628/Domain-Driven-Design-What-You-Need-to-Know-About-S)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.codeproject.com/Articles/1158628/Domain-Driven-Design-What-You-Need-to-Know-About-S](https://www.codeproject.com/Articles/1158628/Domain-Driven-Design-What-You-Need-to-Know-About-S)'
- en: '[https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)'
- en: '[https://www.slideshare.net/SpringCentral/ddd-rest-domain-driven-apis-for-the-web](https://www.slideshare.net/SpringCentral/ddd-rest-domain-driven-apis-for-the-web)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.slideshare.net/SpringCentral/ddd-rest-domain-driven-apis-for-the-web](https://www.slideshare.net/SpringCentral/ddd-rest-domain-driven-apis-for-the-web)'
- en: '[https://www.infoq.com/presentations/ddd-rest](https://www.infoq.com/presentations/ddd-rest)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.infoq.com/presentations/ddd-rest](https://www.infoq.com/presentations/ddd-rest)'
- en: '[https://ordina-jworks.github.io/conference/2016/07/10/SpringIO16-DDD-Rest.html](https://ordina-jworks.github.io/conference/2016/07/10/SpringIO16-DDD-Rest.html)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ordina-jworks.github.io/conference/2016/07/10/SpringIO16-DDD-Rest.html](https://ordina-jworks.github.io/conference/2016/07/10/SpringIO16-DDD-Rest.html)'
- en: '[https://www.slideshare.net/canpekdemir/domain-driven-design-71055163](https://www.slideshare.net/canpekdemir/domain-driven-design-71055163)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.slideshare.net/canpekdemir/domain-driven-design-71055163](https://www.slideshare.net/canpekdemir/domain-driven-design-71055163)'
- en: '[https://msdn.microsoft.com/magazine/dn342868.aspx](https://msdn.microsoft.com/magazine/dn342868.aspx)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/magazine/dn342868.aspx](https://msdn.microsoft.com/magazine/dn342868.aspx)'
- en: '[http://mkuthan.github.io/blog/2013/11/04/ddd-architecture-summary/](http://mkuthan.github.io/blog/2013/11/04/ddd-architecture-summary/)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mkuthan.github.io/blog/2013/11/04/ddd-architecture-summary/](http://mkuthan.github.io/blog/2013/11/04/ddd-architecture-summary/)'
