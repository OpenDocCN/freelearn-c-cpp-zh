- en: Sharing Objects with the Flyweight Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用享元模式共享对象
- en: We previously learned about object pools in [Chapter 7](part0112.html#3APV00-04600e4b10ea45a2839ef4fc3675aeb7),
    *Improving Performance with Object Pools*, and that they are great for avoiding
    slowdowns in our game due to dynamic memory allocation. But, there are still other
    steps that we can take to reduce the amount of memory that we use to begin with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](part0112.html#3APV00-04600e4b10ea45a2839ef4fc3675aeb7)“使用对象池提高性能”中学习了对象池，并且知道它们对于避免由于动态内存分配导致的游戏性能下降非常有用。但是，我们还可以采取其他步骤来减少我们最初使用的内存量。
- en: When creating projects, you'll often run into times where you want to have many
    objects on the screen at once. While computers have become much more powerful
    over the past few years, they still can't handle thousands of complex game objects
    on the screen by themselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目时，你经常会遇到想要在屏幕上同时显示许多对象的情况。尽管在过去几年中计算机变得更为强大，但它们仍然无法独立处理屏幕上的数千个复杂游戏对象。
- en: In order to accomplish this feat, programmers need to think of ways to lighten
    the memory load on their program. Using the Flyweight pattern, we abstract the
    common parts of our object and share them with only the data that's unique to
    each instance (such as position and current health) being created.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一壮举，程序员需要考虑如何减轻程序内存负担。使用享元模式，我们将对象的公共部分抽象出来，并仅与每个实例的独特数据（如位置和当前健康）共享。
- en: Chapter overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: 'In this chapter, we will construct a particle system consisting of two parts:
    the particle itself, which will be a simple struct, as well as a particle system
    class that contains the system''s data.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个由两部分组成的粒子系统：粒子本身，它将是一个简单的结构体，以及包含系统数据的粒子系统类。
- en: 'We will construct two different types of particle system: an explosion that
    moves on its own, and a static one that spawns at the position of our player''s
    ship. We will also explore two ways to deal with the system data. The first will
    be for each particle system to contain its own copy of the system data. Then,
    after learning about the Flyweight pattern, we will use it to construct separate
    system data classes that we can assign using files or code. Then, each particle
    system will simply reference an instance of the system data that it needs.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建两种不同类型的粒子系统：一种可以自行移动的爆炸，以及一种在玩家飞船位置生成的静态粒子系统。我们还将探讨两种处理系统数据的方法。第一种是每个粒子系统都包含其自己的系统数据副本。然后，在学习了享元模式之后，我们将使用它来构建可以分配使用文件或代码的独立系统数据类。然后，每个粒子系统将简单地引用它所需的系统数据实例。
- en: Your objectives
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'This chapter will be split into a number of topics. It will contain a simple
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主题。它将包含从开始到结束的简单步骤。以下是我们的任务大纲：
- en: Introduction to particles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子的介绍
- en: Implementing particles in Mach5
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mach5中实现粒子
- en: Why memory is still an issue
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么内存仍然是一个问题
- en: Introduction to the Flyweight pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式的介绍
- en: Transitioning to ParticleSystems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换到粒子系统
- en: Introductions to particles
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子的介绍
- en: In game development, you may have heard of particles. They are typically small
    2D sprites or simple 3D models that are created in order to simulate *fuzzy* things
    such as fires, explosions, and smoke trails to add visual flair to your projects.
    This visual flair is sometimes referred to as *juiciness*. Made popular by indie
    developers *Martin Jonasson* and *Petri Purho*, making a game *juicy* makes it
    more enjoyable to play and increases the feedback the player receives by playing
    the game.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，你可能听说过粒子。它们通常是小型2D精灵或简单的3D模型，创建目的是为了模拟*模糊*事物，如火焰、爆炸和烟雾轨迹，以增加项目的视觉效果。这种视觉效果有时被称为*汁液感*。独立开发者*马丁·约纳森*和*佩特里·普霍*使其流行起来，使游戏*汁液感*更强，使其更具可玩性，并增加了玩家通过玩游戏获得的反馈。
- en: This is usually something worked on more toward the end of development of titles
    in order to polish the project and add more feedback, but it's a good example
    of how we can want to have many things on the screen at one time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是在游戏开发后期为了完善项目并增加更多反馈而进行的工作，但它是一个很好的例子，说明了我们为什么想要在屏幕上同时显示许多事物。
- en: For more information on juiciness and to watch their Martin and Petri's GDC
    talk on the subject, check out [http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php](http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于“juiciness”（生动性）的信息，以及观看Martin和Petri在GDC关于此主题的演讲，请查看[http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php](http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php)。
- en: The reason that these objects are so simple is because they are spawned hundreds
    and sometimes thousands of times, and this is done over and over again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些物体之所以如此简单，是因为它们被生成数百次，有时甚至数千次，而且这个过程反复进行。
- en: Implementing particles in Mach5
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mach5中实现粒子
- en: Now that we know what particles are, let's put them into Mach5 so we can get
    an example of how they work. We will be creating particles to follow our ship
    while it moves in a similar fashion to a smoke trail. This will be a great way
    to show an example of particles on the screen but, to have something to show,
    we will first need to bring a new archetype into the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了粒子的概念，让我们将它们放入Mach5中，以便我们可以得到一个它们如何工作的例子。我们将创建粒子来跟随我们的飞船，使其移动方式类似于烟雾轨迹。这将是一个展示屏幕上粒子示例的好方法，但为了展示内容，我们首先需要将一个新的原型引入到游戏中。
- en: To do that, open up the `Example Code` folder for this chapter and bring the
    `particle.tga` file into the `EngineTest/Textures` folder of your Visual Studio
    project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，打开本章的`Example Code`文件夹，并将`particle.tga`文件拖入你的Visual Studio项目的`EngineTest/Textures`文件夹中。
- en: 'After that, open up the `EngineTest/ArcheTypes` folder, create a new text file
    called `Particle.ini`, and fill it with the following info:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，打开`EngineTest/ArcheTypes`文件夹，创建一个名为`Particle.ini`的新文本文件，并填写以下信息：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, we need the Mach5 engine to support our new object, so go to the
    `EngineTest` folder and then double-click on the `PreBuild.bat` file. The `M5ArcheTypes.h`
    file will be updated to include our particle:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要Mach5引擎支持我们的新对象，因此转到`EngineTest`文件夹，然后双击`PreBuild.bat`文件。`M5ArcheTypes.h`文件将被更新以包含我们的粒子：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nice! Now that we have the object in the game, there's still the issue of putting
    in the Particle component. Since this component is not exclusive to our game,
    let's move over to the Core/Components filter and create a new filter called `ParticleComp`.
    From there, create two new files, `ParticleComponent.h` and `ParticleComponent.cpp`,
    making sure their locations are set to the `Mach5-master\EngineTest\EngineTest\Source\`
    folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经将物体放入了游戏中，但仍有一个问题需要解决，那就是添加粒子组件。由于这个组件并不专属于我们的游戏，让我们转到Core/Components过滤器，并创建一个新的过滤器，命名为`ParticleComp`。从那里，创建两个新的文件，`ParticleComponent.h`和`ParticleComponent.cpp`，确保它们的路径设置为`Mach5-master\EngineTest\EngineTest\Source\`文件夹。
- en: 'In the `.h` file, use the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.h`文件中，使用以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class looks similar to other components that we've added in the past, but
    this time we've added a `startScale` property to keep track of what scale our
    object had at the start of its life, and an `endScale` property to be a modifier
    on how to change the scale. We also have `lifeTime`, which will be how long this
    object should live before we remove it, and `lifeLeft`, which will be how much
    longer this object has to live. Finally, since we are going to change our scale,
    we added another function, `Lerp`, to linearly interpolate between a starting
    and ending value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来与其他我们过去添加的组件相似，但这次我们增加了一个`startScale`属性来跟踪物体在其生命周期开始时的规模，以及一个`endScale`属性来作为改变规模的修饰符。我们还有一个`lifeTime`，它将是我们移除该物体之前它应该存在的时长，以及`lifeLeft`，它将是我们移除该物体之前它还剩多少时长。最后，由于我们将改变规模，我们添加了另一个函数`Lerp`，用于在起始值和结束值之间进行线性插值。
- en: 'In the `.cpp` file, use the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中，使用以下代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code will modify the object''s scale by using the `Lerp` function to interpolate
    between the starting and ending scale. We also will modify how much life the particle
    has left, and if it has none, mark the particle for deletion:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将通过使用`Lerp`函数在起始和结束规模之间进行插值来修改物体的规模。我们还将修改粒子的剩余寿命，如果没有剩余寿命，则标记粒子以供删除：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Linear interpolation** (**Lerp**) allows us to obtain a value between `start`
    and `end` using the `fraction` property for how far along the transition it should
    be. If `fraction` is `0`, we would get the value of `start`. If we give `1`, we
    will get the value of `end`. If it''s `.5`, then we would get the half-way point
    between `start` and `end`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性插值**（**Lerp**）允许我们使用 `fraction` 属性来获取 `start` 和 `end` 之间的值，以确定过渡进行到多远。如果
    `fraction` 是 `0`，我们将得到 `start` 的值。如果我们给出 `1`，我们将得到 `end` 的值。如果是 `.5`，那么我们将得到 `start`
    和 `end` 之间的中点。'
- en: For more information on interpolation including linear interpolation, check
    out *Keith Maggio*'s notes on the topic at [https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/](https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于插值（包括线性插值）的信息，请查看 *Keith Maggio* 在 [https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/](https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/)
    主题上的笔记。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Clone` function allows us to create a copy of this object. It will create
    a new version of this component, and we will initialize the values of the new
    component with the values we currently have. This is used by the Mach5 engine
    in the creation of new game objects:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone` 函数允许我们创建该对象的副本。它将创建该组件的新版本，我们将使用当前拥有的值来初始化新组件的值。这在 Mach5 引擎创建新游戏对象时被使用：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just like before, the `FromFile` function will read in our `ini` file we created
    previously and will use the values from it to set the properties of this component.
    In our case, here we set `lifeTime`, `lifeLeft`, and `endScale`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，`FromFile` 函数将读取我们之前创建的 `ini` 文件，并使用其中的值来设置该组件的属性。在我们的例子中，这里我们设置了 `lifeTime`、`lifeLeft`
    和 `endScale`。
- en: 'Finally, let''s start putting these objects into our game. Open up the `PlayerInputComponent.cpp`
    file and add the following to the top of the `Update` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们开始将这些对象放入我们的游戏中。打开 `PlayerInputComponent.cpp` 文件，并在 `Update` 函数的顶部添加以下内容：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will cause a particle to get spawned in every single frame and have the
    same position as our ship. Now, if we run the game, we should see some cool stuff!
    We can see this in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每一帧中产生一个粒子，并且其位置与我们的飞船相同。现在，如果我们运行游戏，我们应该能看到一些酷炫的东西！我们可以在以下屏幕截图中看到：
- en: '![](img/00057.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: As you can see, our ship now has a trail following behind it. Each part is a
    particle!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的飞船现在后面跟着一条轨迹。每个部分都是一个粒子！
- en: Why memory is still an issue
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么内存仍然是一个问题
- en: The particle system that we are currently showing is probably running well enough
    on some computers, but note that a large number of the variables that we have
    created hold data that will never change once we've initialized them. Now, generally
    in programming we would mark a variable that wouldn't change as `const`, but we
    don't set the variable until we read from a file. We could potentially make the
    variables static, but there's also the chance that we may want to have more particle
    systems in the future and I don't want to create an archetype for each one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前展示的粒子系统在某些计算机上可能运行得足够好，但请注意，我们创建的大量变量在初始化后永远不会改变其数据。通常在编程中，我们会将不会改变的变量标记为
    `const`，但我们不会在读取文件之前设置变量。我们可能将变量设置为静态的，但也有可能我们将来可能想要有更多的粒子系统，我不想为每个系统创建一个原型。
- en: If we continue to spawn many particles, the memory that it takes up will increase
    and we will be wasting valuable space in memory that we could be using for other
    purposes. To solve this issue, we will employ the Flyweight pattern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续产生许多粒子，它所占据的内存将增加，我们将浪费宝贵的空间在内存中，这些空间本可以用于其他目的。为了解决这个问题，我们将采用享元模式。
- en: Introduction to the Flyweight pattern
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元模式简介
- en: The Gang of Four states that a Flyweight is a shared object that can be used
    in multiple contexts simultaneously. Similarly to flyweight in boxing, which is
    the lightweight boxing category, we can have a lighter object that can be used
    in different places in our system simultaneously.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 四大设计模式指出，享元是一个可以在多个上下文中同时使用的共享对象。类似于拳击中的轻量级拳击类别，我们可以在系统的不同地方同时使用一个更轻的对象。
- en: While not used terribly often nowadays, the Flyweight pattern can be very helpful
    in scenarios when memory is constrained.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在使用得不是很频繁，但在内存受限的场景中，享元模式可以非常有帮助。
- en: 'A Flyweight will consist of two parts: the intrinsic state and the extrinsic
    state. The intrinsic state is the part that can be shared. The extrinsic state
    is modified based on the context it''s being used in and, as such, cannot be shared.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 将由两部分组成：内部状态和外部状态。内部状态是可以共享的部分。外部状态基于其使用的上下文进行修改，因此不能共享。
- en: 'Let''s take a look at a UML diagram to see a closer look:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个 UML 图来更仔细地看看：
- en: '![](img/00058.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.jpeg)'
- en: We have the **FlyweightFactory** class, which is used to manage the Flyweights.
    Whenever we request one, we will either give one that's been created or create
    a new one ourselves.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 **FlyweightFactory** 类，用于管理 Flyweight。每次我们请求一个时，我们要么提供一个已经创建的，要么自己创建一个新的。
- en: The **Flyweight** object itself has data that is of whatever type is needed,
    as long as it won't change depending on the object that we're working with.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flyweight** 对象本身具有所需类型的数据，只要它不会根据我们正在处理的对象而改变。'
- en: Finally, we have the **ConcreteFlyweight**, which acts as our extrinsic information
    that can access and use our **Flyweight** via the **FlyweightFactory**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 **ConcreteFlyweight**，它充当我们的外部信息，可以通过 **FlyweightFactory** 访问和使用 **Flyweight**。
- en: Transitioning to ParticleSystems
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向 ParticleSystems
- en: 'So with that in mind, what we will do is separate the information that will
    be shared by each particle, which we will call a `ParticleSystem`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这一点，我们将做的是将每个粒子将共享的信息分开，我们将称之为 `ParticleSystem`：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The class acts as our intrinsic state, which is shared. Since the starting scale,
    end scale, and lifetime of our object never change, it makes sense for these variables
    to be shared instead of each object having one. In our previous example, we only
    had one particle system, but we may want the ability to have more as well, and
    it's when we start using it that some of the benefits of the Flyweight pattern
    become even more apparent. That's why we gave this class two virtual functions: `Init`
    and `Update`. We can have our extrinsic state call these functions, giving the
    function information about the particular object we're dealing with, and then
    we can modify it using these properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类充当我们的内部状态，它是共享的。由于对象的起始比例、结束比例和寿命永远不会改变，因此这些变量共享而不是每个对象都有自己的变量是有意义的。在我们的上一个例子中，我们只有一个粒子系统，但我们可能希望有更多的能力，而且当我们开始使用它时，Flyweight
    模式的某些好处变得更加明显。这就是为什么我们给了这个类两个虚拟函数：`Init` 和 `Update`。我们可以让外部状态调用这些函数，给函数提供关于我们正在处理的具体对象的信息，然后我们可以使用这些属性来修改它。
- en: Creating different system types
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建不同的系统类型
- en: 'Let''s add a new type of particle system in addition to our current one that
    doesn''t move. Let''s call it `Moving` and our previous one, `Static`. To differentiate
    between the two, let''s add an `enum`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们当前不动的系统类型外，让我们添加一种新的粒子系统类型。让我们称它为 `Moving`，而我们之前的类型为 `Static`。为了区分这两种类型，让我们添加一个
    `enum`：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now modify the original `ParticleComponent` class, by removing the previously
    created variables and instead including a reference to the kind of `ParticleSystem`
    we wish to use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过删除之前创建的变量，并包括我们希望使用的 `ParticleSystem` 类型的引用来修改原始的 `ParticleComponent`
    类：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `ParticleComponent` class acts as our extrinsic state, holding information
    about how much time it has left and the properties from the `M5Component` class,
    such as a reference to the object we want to create.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleComponent` 类充当我们的外部状态，持有关于剩余时间以及来自 `M5Component` 类的属性的信息，例如我们想要创建的对象的引用。'
- en: 'At this point, we need to create two classes to refer to each of these:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要创建两个类来引用这些：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Developing the ParticleFactory
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 ParticleFactory
- en: 'We need some way for our `ParticleComponent` to access this information. With
    that in mind, we will make use of the Factory design pattern that we learned about
    in [Chapter 5](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7), *Decoupling
    Code via the Factory Method Pattern*, and create a `ParticleFactory` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式让我们的 `ParticleComponent` 访问这些信息。考虑到这一点，我们将利用我们在 [第 5 章](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7)
    中学到的工厂设计模式，即通过工厂方法模式解耦代码，并创建一个 `ParticleFactory` 类：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `ParticleFactory` class is what we use to manage the creation of these
    Flyweights and to ensure that, if the object is already located in our map, we
    will return it. Otherwise, we will create a new object to be able to access it.
    I also added an `objectCount` variable to help us know how many objects currently
    exist and to verify that no memory leaks are occurring.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ParticleFactory`类是我们用来管理这些Flyweights的创建，并确保如果对象已经位于我们的map中，我们将返回它。否则，我们将创建一个新的对象以便能够访问它。我还添加了一个`objectCount`变量，帮助我们了解当前存在多少对象，并验证没有内存泄漏发生。
- en: The `ParticleSystems` variable is of type map, which is actually one of my favorite
    containers in the `stl` and can be considered an *associative array*. By that,
    I mean instead of memorizing numbers in order to access certain indexes of an
    array, you can use a different type, such as a `string,` or in this case, an `enum`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystems`变量是map类型，这实际上是我最喜欢的`stl`容器之一，可以被认为是*关联数组*。换句话说，您不需要记住数字来访问数组的特定索引，您可以使用不同的类型，例如`string`，或者在这种情况下，使用`enum`。'
- en: For more information on the map container, check out [http://www.cprogramming.com/tutorial/stl/stlmap.html](http://www.cprogramming.com/tutorial/stl/stlmap.html).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于map容器的信息，请查看[http://www.cprogramming.com/tutorial/stl/stlmap.html](http://www.cprogramming.com/tutorial/stl/stlmap.html)。
- en: 'After this, we will need to define the two static variables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义两个静态变量：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the ParticleFactory
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ParticleFactory`
- en: Next, we will need to adjust our previously created Particle archetype and component
    to reflect these changes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调整我们之前创建的粒子原型和组件以反映这些更改。
- en: 'First, we want to change our `.ini` file. Since the `Particle` object is meant
    for all particle types, instead of having the properties being set there, we will
    instead set a base type for us to use:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要更改我们的`.ini`文件。由于`Particle`对象适用于所有粒子类型，我们不会在那里设置属性，而是设置一个基类型供我们使用：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This simplifies the particle object itself, but it''s for a good cause. We
    will now update the code of the `ParticleComponent` class as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了粒子对象本身，但这是出于好原因。我们现在将更新`ParticleComponent`类的代码如下：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this instance, you''ll notice that instead of modifying the scale and/or
    movement being done here, we use the `ParticleFactory` to update our code based
    on the `particleType` property:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您会注意到，我们不是在这里修改缩放和/或移动，而是使用`ParticleFactory`根据`particleType`属性来更新我们的代码：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we call the `Init` function for our particle system based on its type
    from the factory:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据工厂中粒子的类型调用`Init`函数：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are now going to set our particle type based on what is marked on the `ini`
    file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将根据`ini`文件上的标记来设置我们的粒子类型。
- en: 'But, of course, now that we are using the `GetParticleSystem` function, we
    need to implement it for our code to compile:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，现在我们正在使用`GetParticleSystem`函数，我们需要为我们的代码实现它以便编译：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this script, we make use of the `particleSystems` map that we talked about
    earlier. The first thing that we do is check if there is an object in the map
    that has our `ParticleType` in it. If not, then we need to create one. In this
    case, I added a `switch` statement that will assign different values depending
    on the value mentioned in the `case` statement, but you could easily read these
    values from a text file in a similar manner to how files are read for archetypes.
    You''ll notice that we are calling new in order to create these, so we will need
    to call `delete` on them as well in order to avoid any memory leaks. To accomplish
    this, I''ve added in a destructor for the `ParticleFactory` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用了之前提到的`particleSystems` map。我们首先做的事情是检查map中是否有包含我们的`ParticleType`的对象。如果没有，那么我们需要创建一个。在这种情况下，我添加了一个`switch`语句，它将根据`case`语句中提到的值分配不同的值，但您也可以以类似读取原型的文件的方式轻松地从文本文件中读取这些值。您会注意到我们正在调用`new`来创建这些，因此我们还需要调用`delete`以避免任何内存泄漏。为了实现这一点，我为`ParticleFactory`类添加了一个析构函数：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we need to write the implementations for our different `ParticleSystems`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为我们的不同`ParticleSystems`编写实现：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Lerp` function does the same for either particle type, so it''s fine the
    way it was:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lerp`函数对两种粒子类型都做同样的事情，所以它保持原样是好的：'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The static version of the `Init` and `Update` functions will just set our velocity
    to `0` so we don''t move:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Init`和`Update`函数的静态版本将只设置我们的速度为`0`，这样我们就不会移动：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For our moving particle system, we will set our velocity to a random number
    in the *x* and *y* axis, causing a nice explosion effect!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的运动粒子系统，我们将速度设置为*x*轴和*y*轴上的随机数，从而产生一个漂亮的爆炸效果！
- en: 'Now, instead of creating a copy of this data each time, we will have one copy
    that we will access, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再每次都创建数据的副本，而将有一个副本供我们访问，如下面的截图所示：
- en: '![](img/00059.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.jpeg)'
- en: As we play, you'll notice that we now have a new particle system working and
    it's doing its job quite well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏过程中，你会发现我们现在有一个新的粒子系统正在运行，并且它的工作相当出色。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we learned about particles and how they can
    be used in order to improve the polish of our game project. We learned how we
    can implement a particle system inside of the Mach5 engine, and then learned about
    the Flyweight pattern and how it can be used effectively in order to reduce the
    memory usage on your projects. We saw how to do this by making use of the Factory
    pattern too, while making it a lot easier for us to create new particle system
    types as well. Keeping this in mind, it will be a lot easier in the future to
    break apart pieces of your programs that stay consistent and only create additional
    variables when you need to!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们学习了粒子以及如何利用它们来提升我们的游戏项目的品质。我们学习了如何在Mach5引擎中实现粒子系统，然后学习了Flyweight模式以及如何有效地使用它来减少项目中的内存使用。我们还看到了如何通过使用工厂模式来实现这一点，同时使创建新的粒子系统类型变得更加容易。考虑到这一点，未来在需要时，将更容易拆分保持一致性的程序部分，并且只创建额外的变量！
- en: Moving forward, in the next chapter we will dive into graphics and the concepts
    needed to understand how our code will affect moving and animating game objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨图形以及理解我们的代码如何影响移动和动画游戏对象所需的概念。
