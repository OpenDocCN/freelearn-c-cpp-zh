["```cpp\n    template<typename T>\n    class unique_ptr {\n      T *m_ptr = nullptr;\n    public:\n      constexpr unique_ptr() noexcept = default;\n      constexpr unique_ptr(T *p) noexcept : m_ptr(p) {}\n\n      T *get() const noexcept { return m_ptr; }\n      operator bool() const noexcept { return bool(get()); }\n      T& operator*() const noexcept { return *get(); }\n      T* operator->() const noexcept { return get(); }\n```", "```cpp\n      void reset(T *p = nullptr) noexcept {\n        T *old_p = std::exchange(m_ptr, p);\n        delete old_p;\n      }\n\n      T *release() noexcept {\n        return std::exchange(m_ptr, nullptr);\n      }\n```", "```cpp\n      unique_ptr(unique_ptr&& rhs) noexcept {\n        this->reset(rhs.release());\n      }\n\n      unique_ptr& operator=(unique_ptr&& rhs) noexcept {\n        reset(rhs.release());\n        return *this;\n      }\n\n      ~unique_ptr() {\n        reset();\n      }\n    };\n```", "```cpp\n    template<typename T, typename... Args>\n    unique_ptr<T> make_unique(Args&&... args)\n    {\n      return unique_ptr<T>(new T(std::forward<Args>(args)...));\n    }\n```", "```cpp\n    struct Widget {\n      virtual ~Widget();\n    };\n    struct WidgetImpl : Widget {\n      WidgetImpl(int size);\n    };\n    struct WidgetHolder {\n      void take_ownership_of(Widget *) noexcept;\n    };\n    void use(WidgetHolder&);\n\n    void test() {\n      Widget *w = new WidgetImpl(30);\n      WidgetHolder *wh;\n      try {\n        wh = new WidgetHolder();\n      } catch (...) {\n        delete w;\n        throw;\n      }\n      wh->take_ownership_of(w);\n      try {\n        use(*wh);\n      } catch (...) {\n        delete wh;\n        throw;\n      }\n      delete wh;\n    }\n```", "```cpp\n    void test() {\n      auto w = std::make_unique<WidgetImpl>(30);\n      auto wh = std::make_unique<WidgetHolder>();\n      wh->take_ownership_of(w.release());\n      use(*wh);\n    }\n```", "```cpp\n    std::unique_ptr<Widget> bad(new WidgetImpl(30));\n    bad.reset(new WidgetImpl(40));\n\n    std::unique_ptr<Widget> good = std::make_unique<WidgetImpl>(30);\n    good = std::make_unique<WidgetImpl>(40);\n```", "```cpp\n    try {\n      use(*wh);\n    } catch (...) {\n      delete wh;\n      throw;\n    }\n    delete wh;\n```", "```cpp\n    try {\n      use(*wh);\n    } finally {\n      delete wh;\n    }\n```", "```cpp\n    struct fcloser {\n      void operator()(FILE *fp) const {\n        fclose(fp);\n      }\n\n      static auto open(const char *name, const char *mode) {\n        return std::unique_ptr<FILE, fcloser>(fopen(name, mode));\n      }\n    };\n\n    void use(FILE *);\n\n    void test() {\n      auto f = fcloser::open(\"test.txt\", \"r\");\n      use(f.get());\n      // f will be closed even if use() throws\n    }\n```", "```cpp\n    std::shared_ptr<X> pa, pb, pc;\n\n    pa = std::make_shared<X>();\n    // use-count always starts at 1\n\n    pb = pa;\n    // make a copy of the pointer; use-count is now 2\n\n    pc = std::move(pa);\n    assert(pa == nullptr);\n    // moving the pointer keeps the use-count at 2\n\n    pb = nullptr;\n    // decrement the use-count back to 1\n    assert(pc.use_count() == 1);\n```", "```cpp\n    struct Super {\n      int first, second;\n      Super(int a, int b) : first(a), second(b) {}\n      ~Super() { puts(\"destroying Super\"); }\n    };\n\n    auto get_second() {\n      auto p = std::make_shared<Super>(4, 2);\n      return std::shared_ptr<int>(p, &p->second);\n    }\n\n    void test() {\n      std::shared_ptr<int> q = get_second();\n      puts(\"accessing Super::second\");\n      assert(*q == 2);\n    }\n```", "```cpp\n    std::shared_ptr<X> pa, pb, pc;\n\n    pa = std::make_shared<X>();\n      // use-count always starts at 1\n\n    pb = pa;\n      // make a copy of the pointer; use-count is now 2\n\n    pc = std::shared_ptr<X>(pb.get()); // WRONG!\n      // give the same pointer to shared_ptr again,\n      // which tells shared_ptr to manage it -- twice!\n    assert(pb.use_count() == 2);\n    assert(pc.use_count() == 1);\n\n    pc = nullptr;\n      // pc's use-count drops to zero and shared_ptr\n      // calls \"delete\" on the X object\n\n    *pb; // accessing the freed object yields undefined behavior\n```", "```cpp\n    struct DangerousWatcher {\n      int *m_ptr = nullptr;\n\n      void watch(const std::shared_ptr<int>& p) {\n        m_ptr = p.get();\n      }\n      int current_value() const {\n        // By now, *m_ptr might have been deallocated!\n        return *m_ptr;\n      }\n    };\n```", "```cpp\n    struct NotReallyAWatcher {\n      std::shared_ptr<int> m_ptr;\n\n      void watch(const std::shared_ptr<int>& p) {\n        m_ptr = p;\n      }\n      int current_value() const {\n        // Now *m_ptr cannot ever be deallocated; our\n        // mere existence is keeping *m_ptr alive!\n        return *m_ptr;\n      }\n    };\n```", "```cpp\n    struct CorrectWatcher {\n      std::weak_ptr<int> m_ptr;\n\n      void watch(const std::shared_ptr<int>& p) {\n        m_ptr = std::weak_ptr<int>(p);\n      }\n      int current_value() const {\n        // Now we can safely ask whether *m_ptr has been\n        // deallocated or not.\n        if (auto p = m_ptr.lock()) {\n            return *p;\n        } else {\n          throw \"It has no value; it's been deallocated!\";\n        }\n      }\n    };\n```", "```cpp\n    template<class T>\n    class enable_shared_from_this {\n      weak_ptr<T> m_weak;\n    public:\n      enable_shared_from_this(const enable_shared_from_this&) {}\n      enable_shared_from_this& operator=(const enable_shared_from_this&) {}\n      shared_ptr<T> shared_from_this() const {\n        return shared_ptr<T>(m_weak);\n      }\n    };\n```", "```cpp\n    struct Widget : std::enable_shared_from_this<Widget> {\n      template<class F>\n      void call_on_me(const F& f) {\n        f(this->shared_from_this());\n      }\n    };\n\n    void test() {\n      auto sa = std::make_shared<Widget>();\n\n      assert(sa.use_count() == 1);\n      sa->call_on_me([](auto sb) {\n        assert(sb.use_count() == 2);\n      });\n\n      Widget w;\n      try {\n        w.call_on_me([](auto) {});\n      } catch (const std::bad_weak_ptr&) {\n        puts(\"Caught!\");\n      }\n    }\n```", "```cpp\n    template<class Derived>\n    class addable {\n    public:\n      auto operator+(const Derived& rhs) const {\n        Derived lhs = static_cast<const Derived&>(*this);\n        lhs += rhs;\n        return lhs;\n      }\n    };\n```", "```cpp\n    template<class Derived>\n    class addable {\n    public:\n      friend auto operator+(Derived lhs, const Derived& rhs) {\n        lhs += rhs;\n        return lhs;\n      }\n    };\n```", "```cpp\n    void remusnoc(std::unique_ptr<Widget> p);\n\n    std::unique_ptr<Widget> recudorp();\n```", "```cpp\n    void suougibma(Widget *p);\n```", "```cpp\n    template<typename T>\n    class observer_ptr {\n      T *m_ptr = nullptr;\n      public:\n      constexpr observer_ptr() noexcept = default;\n      constexpr observer_ptr(T *p) noexcept : m_ptr(p) {}\n\n      T *get() const noexcept { return m_ptr; }\n      operator bool() const noexcept { return bool(get()); }\n      T& operator*() const noexcept { return *get(); }\n      T* operator->() const noexcept { return get(); }\n    };\n\n    void revresbo(observer_ptr<Widget> p);\n```"]