<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finalizing Our VR Game and Next Steps</h1>
                </header>
            
            <article>
                
<p><em>Server 17</em> has come a long way from the idea we conceived at the beginning of <a href="926e8e71-f556-43b2-b4f8-47dc017c7a38.xhtml">Chapter 1</a>, <em>Introducing VR Technology in Unreal Engine 4</em>. From our initial designs and discussions with users, we have created a game prototype with flexible systems that puts player fun and comfort first. <span><span>In <a href="7c6f9794-be36-40be-9cd0-f6d0e09171bd.xhtml">Chapter 5</a>, <em>Creating Optimized Game Art for VR in UE4</em></span></span>, we discussed the limitations of game art in VR and some best practices that can be used to build the visuals that this game demands. So, where do we go from here? It's time to test!</p>
<p>Once we have a working prototype, it is time to test with our users and see whether some of our design ideas are right. Only the players can tell us whether we are on the right track. No design is ever perfect right out of production, and our game will often undergo several rounds of testing and redesign before we hit a version that is a winner. This is why we must test, and test often. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The importance of game testing</li>
<li>Collecting test data</li>
<li>Preparing for distribution</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The importance of game testing</h1>
                </header>
            
            <article>
                
<p>The testing phase is an essential part of the HCD process:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/283c3665-5297-4094-8f65-dd28f18ca202.png" style="width:10.92em;height:10.25em;" width="1243" height="1149"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Testing is the fifth step of the HCD process</div>
<p>In this phase, the goal is to gain real and meaningful feedback from our players with the hopes of going over our design and improving it based on this feedback. This phase is the most important part of the process, since there is no way of knowing whether our game is fun without getting it in the hands of the players. This is also the phase where many first-time developers struggle. Many creators feel very connected to their work and view criticism of it—even constructive criticism—as criticism of them or their abilities. It is important that we separate ourselves from our work so that we can accept ideas that will improve the project. Approach all feedback with an open mind and understand that, ultimately, we get to decide which feedback we use and which we ignore. The goal is always to make the product better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Collecting testing data</h1>
                </header>
            
            <article>
                
<p>The data for testing can be collected in the following ways:</p>
<ul>
<li>Usability testing</li>
<li>Card sort</li>
<li>Expert review</li>
</ul>
<p>There are several methods that we can use to collect feedback on our game. These methods are all designed to gather specific data from the players that can be used to improve all aspects of the game, from user interfaces to level designs. Some of them are high tech and utilize advanced methods of recording the player, such as eye movement-tracking tests. Others are very low tech and might involve having the players sort cards with certain keywords on them into categories or simply having the player try the game while you and your colleagues record the results.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Usability testing </h1>
                </header>
            
            <article>
                
<p>The first method that many of us are the most familiar with is usability testing. Usability testing involves bringing testers to your location and having them test your design while you and others observe and record the results. Observing the test is similar to recording notes during an interview. Pay attention to what the user says, but also to their body language and what they do.</p>
<p>Here is an example: Let's say you have created a puzzle game that takes place in a labyrinth. You give ten players that fit your target demographic a chance to try the game during the alpha stage. During testing, nearly every player decides to try to jump a barrier that was placed in the level. When asked about it afterward, four players express frustration that they couldn't get over the barrier, since they thought it might be a shortcut. Nearly all thought that the barrier looked like something they should have been able to pass. How could we use this information to improve the game? One option might be to change the look of the barrier to something more impassible—maybe a wall instead of a fence. This would certainly solve the problem, but it doesn't really take advantage of what we have learned. We could build a secret reward into the area. We could adjust the barrier a bit to make it passable to a determined player and hide a reward on the other side. We could also play to the player's expectations by adding a shortcut just past the barrier if they can get past it. Finally, we always have the option to ignore this particular piece of player feedback if we felt that the change was unnecessary. Which would you choose?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Card sorting</h1>
                </header>
            
            <article>
                
<p>Another method that was designed to gather player data is card sorting, which can be useful for understanding player perceptions of key features or decided what the focus of a game should be. This method comes to us from the world of psychological testing and is designed to help us understand user expectations and their understanding of your idea. Card sorting involves writing 50–60 keywords or ideas on some note cards and asking players to sort them into categories or rank them based on their importance. These could be game features such as leveling, weapon modification, or multiplayer. They could also be more abstract ideas such as what is an acceptable game time or how important is player comfort to the experience.</p>
<p>There are two types of card-sorting activities. Open-card sorting asks the player to organize the cards into categories and then name those categories in a way that accurately describes what is in them, while closed-card sorting is a method where players sort the cards into predefined categories to show you their knowledge of the content. Both methods have their benefits. The first allows you to test how players perceive your ideas. The second allows you to label the ideas and test your labeling, with real users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Expert review</h1>
                </header>
            
            <article>
                
<p>The final method I would like to discuss is expert review. This involves sending your game to an expert and gathering their opinions. In games, this may mean having several different experts try your product and give you feedback on specific features. This would include having a level designer test your game and give you feedback on the levels, or a UX designer giving you feedback on your interfaces and interaction systems. This method allows you to gain professional insight into areas where your team's design expertise might be weak, as often members of small teams wear multiple hats and are asked to take on tasks they know little about. However, it is important to note that this is not a substitute for having players test our game, since player feedback is always the most important type of insight we can get.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Preparing for distribution</h1>
                </header>
            
            <article>
                
<p>So, we have gathered player data, reworked the design, and tested again. We might have been through this part of the design cycle several times already, but now our game is perfect and ready for release to the masses. So, it is time to cook and package a release version of the application. This process has several steps:</p>
<ol>
<li>Adjust our <span class="packt_screen">Project Settings.</span></li>
<li>Launch the <span class="packt_screen">ProjectLauncher.</span></li>
<li>Set up a <span class="packt_screen">Custom Launch Profile.</span></li>
<li>Test the game build.</li>
</ol>
<p>Our journey to release starts by adjusting some <span class="packt_screen">Packaging</span> settings in our <span class="packt_screen">Project Settings</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bf45b14f-5730-4388-88bf-5c4bb1a90ab0.png" style="width:76.25em;height:10.58em;" width="1167" height="161"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Project Settings, showing the Blueprint Nativization option</div>
<p>Let's turn on <span class="packt_screen">Blueprint Nativization</span>. This option converts our existing blueprints into C++ code, which will give us a bump in performance:</p>
<ol>
<li>Find the <span><span class="packt_screen">Blueprint Nativization</span> option in the <span class="packt_screen">Packaging</span> section of the <span class="packt_screen">Project Settings</span> menu.</span></li>
<li><span>Click the dropdown menu and choose the <span class="packt_screen">Inclusive</span> option.</span></li>
</ol>
<p class="mce-root"/>
<p>Next, choose the <span class="packt_screen">Windows</span> option in the <span class="packt_screen">Platforms</span> section of the menu along the left-hand side. Here, you can use your custom splash screen or a custom icon for your game. This is definitely something we should do before our game is released.</p>
<p>Now, we need to head over to the <span class="packt_screen">ProjectLauncher</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f3395114-e6e7-4ae6-8cc4-e3cfc6a61597.png" style="width:43.92em;height:40.08em;" width="1462" height="1330"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The Project Launcher window</div>
<p>From here, we can choose one of the default profiles for our launch preferences or we can create our own. Though the <span class="packt_screen">WindowsNoEditor</span> option will likely work for us, let's try creating our own custom profile down at the bottom:</p>
<ol>
<li>Toward the bottom of the launcher, click the <span class="packt_screen">+</span> button to create a custom launch profile.</li>
<li>At the top of the window, double-click on the <span class="packt_screen">New Profile 0</span> name and name this profile <kbd>VRQuickStart</kbd>.</li>
<li>Double-click on the words <span class="packt_screen">Enter a description here</span> and provide a description for this profile.</li>
<li>In the project section, we can specify that we would like to use this profile for a specific project. Leave this on the default option for now.</li>
<li>Head to the <span class="packt_screen">Cook</span> section and use the dropdown menu to choose the <span class="packt_screen">By the book</span> option. Cooking our content removes any content that is not used and prepares our files for the specified platform.</li>
<li>Under <span class="packt_screen">Cooked Platforms</span>, make sure that the checkbox for <span class="packt_screen">WindowsNoEditor</span> is selected.</li>
<li>Under <span class="packt_screen">Cooked Cultures</span>, make sure that any cultures you would like to localize for are selected. I have chosen <span class="packt_screen">en-US</span>.</li>
<li>For <span class="packt_screen">Cooked Maps</span>, choose the prototype map you created.</li>
<li>In the <span class="packt_screen">Deploy</span> section of the menu, make sure that your computer is selected. Under <span class="packt_screen">Variant</span>, choose the <span class="packt_screen">WindowsNoEditor</span> option.</li>
<li>Finally, click the <span class="packt_screen">Back</span> option to head back to the <span class="packt_screen">Project Launcher</span>.</li>
</ol>
<p>With our profile set up, it is finally time to launch our custom profile and allow Unreal to prepare our game for distribution! Click the <span class="packt_screen">Launch</span> button for our custom profile and watch our game go through the process. Since there isn't much to our game beyond a prototype right now, the whole process will only take a few minutes. As we move to having a more complete game with art, multiple levels, and a greater degree of custom code, this process will take longer. Once it is complete, it is time to enjoy our demo!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>Congratulations! We now have a packaged and complete game prototype! So, where do we go from here? With what we have learned throughout the chapters of this book, the future of our game seems vast and infinite. For some of you, you may want to continue with some of the themes that we have created with <em>Server 17. </em>For others, the goal might be to take the systems that we have designed and build and start a new game. Each system we programmed in <a href="ec4818ac-6582-4488-ba15-e48ef829466f.xhtml">Chapter 3</a>, <em>Exploring Riveting Gameplay in Virtual Reality</em>, and <a href="29fcf580-f5fc-48d4-a315-2975e97705c2.xhtml">Chapter 4</a>, <em>User Interface and User Experience inside VR</em>, were designed to be generic and flexible, allowing the reader to take them in any direction that they wished. I can see the same systems that I interpreted as perfect for a hacking puzzle game reimagined for use in a shooter game, vehicle experience, or even a cartoon cooking game. Once you have settled on a design, build your gameplay and test with the players you have chosen to build for. Refine your idea, build some amazing looking art, and release it into the wild.</span></p>
<p><span>Ultimately, it is up to you to decide what becomes of this prototype. Yet, whatever you decide to do, never stop creating. We become good at what we spend our time doing. If you want to expand your skills in game design, never stop making games.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>