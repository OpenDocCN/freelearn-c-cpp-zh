<html><head></head><body>
        

                            
                    <h1 class="header-title">Blueprint Review and When to Use BP Scripting</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Welcome to our next chapter. This will be our first departure from focusing on C++ code, but not the last. Unreal has many systems with great capabilities that exist in a form you can access from the editor without writing any code. The most flexible and most closely related to actually writing code will be explored here, delving into UE4's blueprint system and its capabilities and limitations. Up until now, most of our work has been implementing things in C++ and minimally showing how these are interacted with as blueprint objects in the editor. Blueprint is capable of much more, including making whole games.  In this chapter we'll cover:</p>
<ul>
<li>Blueprint review/overview</li>
<li>Blueprint-only games, pros and cons</li>
<li>Scritping an object with blueprint (elevator)</li>
<li>Blueprint tips &amp; tricks</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>Like last time, the work in this chapter will be done by utilizing what was finished in <a href="5cc3645d-8420-4178-9897-2c71100caeac.xhtml" target="_blank">Chapter 2</a>, <em>Inventory and Weapons for the Player</em>. This, however, is not strictly required and the contents here should be implementable with the <a href="dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml" target="_blank">Chapter 1</a>, <em>Making a C++ Project for a First-Person Shooter</em>, project or even a new UE4 template.</p>
<p class="mce-root"/>
<p>As usual, the GitHub branch for this chapter is here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3">https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3</a></p>
<p>Engine version used: 4.19.0.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blueprint review and Blueprint-only games</h1>
                
            
            
                
<p>It's fair to ask: just what exactly is "blueprint?" There are really two main areas to be concerned with. The first we have already touched on previously and used: integrating C++ classes with the UE4 editor. Classes used in the editor are typically derived from <kbd>UObject</kbd> at some level, and this allows for them to utilize things such as the <kbd>UPROPERTY</kbd> and <kbd>UFUNCTION</kbd> macros that then allow these to be accessed by blueprint instances of those classes, such as <kbd>StealthCharacter</kbd>. With a few exceptions of some basic geometry and other essential game objects, almost everything placed directly in a level by yourself or designers or artists will be an instance of a blueprint class, such as our character in the level now. The other area to be aware of that every project should evaluate for its needs is the <strong>blueprint visual scripting</strong> (<strong>BVS</strong>) system. Almost all gameplay concepts you can think of doing in C++ are possible in blueprint scripting. It also has an integrated debugger you can use with breakpoints during runtime. Here, we will delve into these concepts a bit more deeply and look at some of the advantages and limitations for scripting.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Blueprint overview</h1>
                
            
            
                
<p>As we have shown multiple times in our previous chapters, the advantages of exposing variables that will be iterated upon or made unique in many instances of the same class type is fairly obvious: these variables can be modified while running the editor by content creators with no programming knowledge whatsoever. System designers in particular depend on having the right variables exposed so they can tune and build variants of systems quickly and test them equally quickly. Doing this almost entirely from C++ as the FPS template begins means that changing those values at best requires compiling and doing a hot-reload of the game while in the editor, and at worst, shutting down the editor, building, and restarting it. Much like scripting in blueprint, discussed in the next paragraph, much of blueprint's exposure and utilization in your game comes down, once again, to your team's and project's needs. If the design of a class for your game is almost certain to never change or change very minimally over the course of the project, and you have plenty of C++ programmers as resources, maybe it makes sense to get things done in a very direct way like the FPS template's character started for us. However, if you have designers (system-level or otherwise) who are anxious to get started building a variety of game objects and are constantly changing them, adding new variations, and testing these quickly in levels, the more blueprint flexibility you can give them, the better!  As noted previously, at the most basic level, blueprint classes are excellent data containers: even if designers or artists are never going to use them, programmers directly benefit from having access to view and often modify as much data as possible in classes while staying in the editor. The iteration time is instantaneous, and you can always check your values without switching context from the editor to Visual Studio or other windows. Of course, there are sensitive, critical values that you may not want anyone arbitrarily modifying from blueprint, but with <kbd>UPROPERTY</kbd> flags such as <kbd>BlueprintReadOnly</kbd>, you can easily give people the availability to view what is currently set for a property without letting someone accidentally modify it and save a bad value. Hopefully the point is made well enough here that other than making sure you keep inexperienced people from changing critical data, there is almost no downside to exposing any interesting variables of a class that can be viewed in the editor as <kbd>UPROPERTY</kbd> types.</p>
<p>Now, on to visual scripting. This is so far wholly untouched in our prject, but that is about to change with a fully utilized example in the next section (<em>Blueprint scripting and performance</em>). For those new to using blueprint scripting, as it's possible also to make entire games while never using it at all, don't worry, there will be lots of screenshots and direct work in it in that section. For now, though, we will simply discuss from a high level the capabilities and drawbacks of using scripting. First, what are some major things that you can do in blueprint scripting?</p>
<ul>
<li>Game logic: Including <kbd>for</kbd>/<kbd>while</kbd> loops, using local and class variables of most types, and access to huge numbers of functions in existing UE4 classes.</li>
<li>Game mechanics: Interaction between objects in the world, collision responses, movement, and even pathfinding.</li>
<li>Access shareable Blueprint Function Libraries: These are groups of stateless/static utility functions you can write in both C++ or blueprint scripting, and share with different teams or projects.</li>
<li>Easily integrate with UI in the UMG editor, often crucial for UI/UX designers' workflow.</li>
<li>No rebuilding any executable or code, and easy referencing of one object to another: as will be discussed in the section immediately following this one, you can (and people do) make whole games just using scripting for logic.</li>
</ul>
<p>Sounds great, right!? Well, before you think there's a very big <em>but</em> coming, let's be clear: blueprint scripting <em>is</em> quite great, and powerful. Here is a quick list of some drawbacks to be aware of, but comparing those to the capabilities blueprint scripting gives out of the box to teams who invest in getting familiar and comfortable with it, well, the drawbacks are overall very minor:</p>
<ul>
<li>Performance costs can be significant: It's generally possible to minimize these, but profiling them and determining problem areas is harder and requires a different skillset than profiling C++ code for issues.</li>
<li>Loss of access to certain data types: C++ is only dependent on your platform compiler settings, but blueprints must be usable and accessible across all platforms UE4 supports (32 and 64 bit, mobile, web, and so on).</li>
<li>Debugging can be... buggy: Often, the context of how you got to a breakpoint is missing, or certain variables won't be available when you hover over them. It's great to have the debugger, but when it doesn't work, you're on your own.</li>
<li>Anyone can modify or add things to blueprints: <em>anyone!</em><strong>  </strong>This means your team needs to have very well-defined roles for who can modify what types of things, to prevent someone without expertise introducing bugs that are hard to find.</li>
</ul>
<ul>
<li>Switching back and forth between C++ code and blueprint scripting can be distracting: Often, to get the whole picture of what's going on, you need data from both, and switching contexts can slow down development.</li>
</ul>
<p>First, a brief discussion of a few of these points and how to mitigate them. For performance profiling, the editor has a very good tool built into it that if you're not already familiar with, take some time and see what it can do. This is the Profiler in the Session Frontend window, which can be accessed from the Window toolbar under Development Tools:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b51d360a-c291-4c51-88fc-ee4a44c9cebd.png"/></p>
<p>If a team is disciplined about tracking performance from the start, it is usually a bit easier to track down what has changed and caused a problem. But again, keep in mind, something as simple as changing a value of one variable might be detrimental to performance, and if you use compiled blueprints, there may be no way to easily search for that change in version tracking history. Two strategies to mitigate this are to integrate source control to the editor, and "nativize" blueprints. If you have a supported source control package (this book's project is using Git), you can enable source control integration by right-clicking any blueprint asset in the editor, and at the bottom of the popup is the option to connect to source control.</p>
<p>Once it's set up, you can right-click on any blueprint asset again, such as the FirstPersonCharacter, and different. versions of it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/50c96fb5-a61e-4085-8987-388f6e7f3947.png" style="width:44.50em;height:44.92em;"/></p>
<p>Finding data changes can be difficult at times (look closely and you'll see where Can Crouch was changed in the preceding screenshot), but when it works right, showing script changes as visual graphs side by side can be incredibly helpful in tracking down where a new change may have caused a problem.</p>
<p>A tutorial on setting this up for Git can be found in the <em>Further reading</em> section of this chapter. Nativizing blueprints can be enabled under Project Settings | Packaging | Blueprints.  This turns all blueprint classes in the editor into intermediate C++ classes, and packages them to your project. You may have a few reasons to do this. It's something to experiment with if your project is having trouble understanding why some blueprints are not working as expected, but we won't spend further time on this option here.</p>
<p>Lastly, regarding the loss of data types, it's entirely possible with Blueprint Function Libraries. You can use native (compiler) types for your platform and return results in types that blueprint can then use. For example, if you had some UI using the existing UE4 <kbd>FDateTime</kbd> values and want the difference between them in seconds, this is not doable in blueprint directly because the values of those date-time <kbd>structs</kbd> is natively in <kbd>int64</kbd> format. So you could easily make a function such as this, which takes the two dates from blueprint, does the math natively (<kbd>ToUnixTimestamp</kbd> returns an <kbd>int64</kbd>) and then returns the result as an <kbd>int32</kbd>, which blueprint can then access (and thus the UI can display):</p>
<pre>UCLASS()
class UDateTime : public UBlueprintFunctionLibrary
{
        GENERATED_BODY()
 
public:
 
        UFUNCTION(BlueprintPure, Category = "Date and Time")
        static int32 SecondsBetweenDateTimes(FDateTime time1, FDateTime time2);</pre>
<p>And then the simple C++ implementation:</p>
<pre>int32 UDateTime::SecondsBetweenDateTimes(FDateTime time1, FDateTime time2)
{
        return time2.ToUnixTimestamp() - time1.ToUnixTimestamp();
}</pre>
<p>So, in the C++, we use a type that isn't allowed to be used directly in a blueprint, but this works across all modern C++ compilers. Of course, if the dates are very far apart, you could lose some data in this calculation/truncation, but so long as it can be assumed that there is no case where dates would be near that level of separation, it is an easy solution to an <kbd>int64</kbd> calculation that can now be accessed from anywhere in blueprints.</p>
<p>Right before the list of drawbacks mentioned previously, it was stated that these issues overall are very minor, but keep in mind that this was in the context of the power blueprint gives you. For example, you can set up a multiplayer game session, have other players search for and connect to it, and begin playing a match together, all from just a few existing blueprint nodes UE4 provides to you. This is incredibly powerful and could take a programmer who's unfamiliar with that workflow days or even weeks to get correct using <kbd>FAsyncTask</kbd> tasks and <kbd>OnlineSubsystem</kbd> calls, all triggered from the right events in the <kbd>GameMode</kbd>, or the like. So is this the way to go 100%, and let's forget this whole C++ business for your project?  That's what we'll finally discuss next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blueprint-only games – is this right for you?</h1>
                
            
            
                
<p>We have established that blueprints are required at some level for any game, and blueprint scripting is a very powerful tool that can save a ton of time when implementing systems or reusable pieces that would otherwise be written with dozens, hundreds, or potentially many thousands of lines of C++ code. We have now also discussed the risks and drawbacks to using blueprint scripting, but now keep in mind that in a project that is blueprint only, you are stuck with these choices. As soon as you hit a problem that seemingly can't be solved and have to add as much as one new C++ class to your project, well, you might as well have started with a basic C++ project from day one in hindsight, and that is a very common outcome. Teams that are very experienced with blueprint scripting and its limitations when starting a project can navigate these things in their design up-front. If you're unsure whether you can do all of what needs to be done for your game's design at the start of your project, make it C++ and then you can use as much from blueprint and C++ as your team's bandwidth and developers prefer, but converting a very large blueprint-only project to C++ will be a great deal more work later in a project's workflow.  Adding C++ builds may be very disruptive and distracting to a team used to never having to do them if you are farther along in development, so again, when in doubt, just start with C++ capabilities in your flow and balance your workload between the two systems in whichever way is optimal. A team with very little C++ code that changes or is added over time will find their workflow then to mostly be the same quick iterations as a blueprint-only project anyway, but have all the infrastructure available and workflow established to add C++ as needed.</p>
<p class="mce-root"/>
<p>iOS developers! There is a huge reason for you to consider staying blueprint-only for a long time, if not for a whole project, depending on its scope: UE4 can package, run, and test on iOS device builds from a Windows PC, <em>if </em>they are blueprint only. This can be a huge advantage to proving out an iOS concept quickly, or to massively reduce build times when iterating quickly on gameplay ideas. You will still eventually need at least a Mac that can run a version of Xcode, and an Apple Developer License, to ultimately submit to Apple, but blueprint-only is a great way to quickly prove what your game can do on an iPhone or iPad.</p>
<p>As a rule of thumb, there are generally two types of teams that will want to go blueprint-only:</p>
<ul>
<li>Those with no one available to handle difficult C++ development, problems, or set up the workflow</li>
<li>Those with a very simple design, or a very experienced set of blueprint-developers who know its limits</li>
</ul>
<p>Often indie-teams fall into a bit of each of these, and again, there is nothing wrong with prototyping a game quickly in blueprint only and if you find you must switch later, it can be done. For those with some experience on a few different teams, though, always weigh the preceding topics and decide wisely before starting, if at all possible.</p>
<p>Going <em>back</em> to a blueprint-only game after some (even not so significant/major) C++ work has been done can be a very difficult to downright-impractical process. It's also another good rule of thumb to just accept once you open the C++ box, do not have any expectation you will shut it again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blueprint scripting and performance</h1>
                
            
            
                
<p>So you may be thinking at this point: we sure have talked a lot about the benefits and drawbacks of blueprint scripting and blueprint-only problems, but we still haven't just sat down and <em>made</em> any to see how it goes and how we can profile its performance. Let's do so now, and get a real-world game system built that we can investigate with: in this case, a game's classic moving platform.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blueprint scripting example – moving platform and elevator</h1>
                
            
            
                
<p>As I'm sure you can imagine after all of this talk, this class, and the work implementing its gameplay, will be done almost exclusively in the editor (there are ways you can always hook C++ to blueprint, which will be discussed near the end). So, start off by opening the editor and going in the content browser tab to our Content | FirstPersonCPP | Blueprints and right-click, like we have done before, to make a new class:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b345a7ac-f962-4d3b-9fcc-8511c2313585.png"/></p>
<p class="mce-root"/>
<p>Click Actor as the parent class for the blueprint, and name it MovingPlatform. Now, we have a completely bare-bones actor we could place in our world, but it doesn't even have any geometry, of course. Let's quickly fix this. Panning around the level, you'll see two gray rectangular boxes (not the white boxes, but those actually work fine too): click one and then right-click on it and select Browse to Asset (<em>Ctrl</em> + <em>B</em>) (note, you can also find this when editing most assets from the menu bar under Asset), and you should be in Content | Geometry | Meshes now with 1M_Cube selected. So, now that we know how to find this simple piece of geometry, let's go back to our MovingPlatform and double-click it. You may notice, since we made this as a blueprint class from the start, you get the full blueprint editor automatically, and not the minimal interface it normally starts with for native classes that don't use scripting, as we often had before. For our platform object, we now need to add a component. Note that you could just add a simple cube or plane as a static mesh component. It is great that these things are available, again, especially for quick prototyping. Just to get used to the workflow, however, which is more typical of professional games, we will use the static mesh cube we were just looking at. So, type to filter or just scroll for Static Mesh in the components drop-down and add one. Now notice in the hierarchy how this is added under the default scene component (named DefaultSceneRoot). Once we have an actor component in our case, that can <em>be</em> the root component of our actor object here, the default is really just a placeholder. So, rename the mesh component to Platform and drag it on top of the scene component to replace it.</p>
<p>Now we'll do two more quick moves to get this platform looking right, click the mesh component and on the right in its properties, under Static Mesh | Static Mesh, select 1M_Cube, which we found earlier, and click the unlock icon to the right of Transsform | Scale and things should be coming together:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/51b4acd1-05eb-48ea-8d0b-5cfc5c3e2ea3.png"/></p>
<p>We can now drag these into our scene, but of course, it won't do anything other than block our player, as the step-height is too high for its collision to handle. You will also notice it need to compile and save, good steps any time you are making progress on a blueprint, though if its scripting is not ready to successfully compile, obviously hold off until it is. You can save and use blueprints with broken scripting, but their warning messages can be very distracting and allow people to not notice other broken blueprint issues that may be critical.</p>
<p class="mce-root"/>
<p>Before we can really use and script this platform, however, we need to add one more component. Unreal keeps blocking (hit) and overlap (touch) collisions separate, and in this case we need a bit of both. So, click Add Component, and this time we simply will add a cube from its list. Notice it should be parented to Platform and because of this, its size is the same since the scale from Platform propagates to our new cube. Now, raise it up a few centimeters by either dragging in the viewport along the Z axis or typing in a value in its transform until you can see it is above but is still basically touching our original platform (I found a Z value of 50 worked for 5 cm since our Z scale is 0.1). Now, scroll down until you see the Collision flyout and make sure Generate Overlap Events is checked. Click in the drop-down for preset to OverlapOnlyPawn, and down in the Rendering flyout, uncheck Visible as we don't want to see this piece because it is only there to detect our character walking on it. In the Platform component's collision events, you can leave this as BlockAllDynamic, and note that generating overlap events is irrelevant as hit events supersede overlap, so you will receive events when projectiles or the player hit the platform, but we would never get the overlap events we need with these filters.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/962489d1-4b3c-4d6f-bdfd-0b232062fce8.png" style="width:44.42em;height:33.67em;"/></p>
<p>This is how everything should look right before clicking the Visible box at the bottom of this screenshot.</p>
<p>And finally, to some blueprint scripting! Click over to the Event Graph tab and you'll see the existing events are grayed out with notes about how to enable them. In our case, we want the overlap box. Click and drag from the blue Other Actor pin (from here on, we'll just call this a <em>pull</em> from the pin), and you will see a list of many things we can add that are context-sorted (so long as the checkbox remains checked) to things that take an actor as input, the way that pin from the event is supplying it as an output. Filter for <kbd>GetClass</kbd>, and you see it has been added now. For those familiar with blueprint scripting, just check out the following screenshot for the progress. Here are the steps (after adding <kbd>GetClass</kbd>) to have that in place:</p>
<ol>
<li>Pull the return value for Get Class, and find Is Child Of in the list. These should now be wired. In the Is Child Of box, in its dropdown, select our MasteringCharacter class as the type so only our player gives a true result here.</li>
<li>Pull the red result pin from is child of and filter or find Branch, then wire this from the white triangle output pin of the actor begin overlap event, and in to the input white pin of the Branch.</li>
<li>Pull the white output (which points right) pin from the branch's True result and filter and add a MoveComponentTo block.</li>
<li>Pull left from the MoveComponentTo block's blue component pin and type to filter for GetPlatform (a reference to our root component).</li>
<li>Pull left from the TargetRelativeLocation yellow pin and type + or otherwise filter/scroll for vector + vector in the list.</li>
<li>Pull from its top left pin and type/filter for GetActorLocation, and you can leave the input pin on that node as self (that's what we want).</li>
<li>Set the bottom vector's destination to what you want. In my test case, a Z value of 300 puts us up even with these other large gray blocks around the map.</li>
</ol>
<p>The TargetRelativeLocation variable seems a bit poorly named, as what it wants for a proper motion is a world location. And lastly, on that MoveToLocation node, set the time to whatever you like: 4 seconds as here is a little slow and boring, but great for demonstrating that this all works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e147bd98-1250-4ba5-ac1b-2233b7c687b6.png"/></p>
<p class="mce-root"/>
<p>Don't forget to compile and save.</p>
<p>Note that running the game in play-in-editor mode will always try to compile any edited blueprints before running (and give errors to the output log if there are any), but it will <em>not</em> save those assets!  You still have to do this with a save-all or Ctrl + S on your blueprints and level editing windows! If you shut down your editor directly via Visual Studio, you won't even get prompted to save any unsaved levels or assets, so it's usually best when working in editor to close via its window 's X button.</p>
<p>Now all that's left to show this off is to drag one of our Moving it into the world on the floor somewhere, and walk over and step on it. Off you go in the air! Note that if you step on it again by hopping off and on, it takes you up further. We'll make this thing a bit better shortly, but right now, this is a good checkpoint for the GitHub version of the project. Here you can see where it is placed in the book's project's map (again, by dragging the MovingPlatform blueprint icon into the main level window itself):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2591cbb9-b7a8-46f6-a226-a3a8f469c185.png"/></p>
<p>There are many, many more options that we could do with something like this now. It's possible to add all kinds of logic, including other components, allowing this platform to do pathfinding navigation, or adding a spline to the world that in the level blueprint for the platform uses (from the main editor window, click Blueprints | Open Editor Blueprint to access individual blueprints that can reference each other in the level). There is a massive amount of very valuable work that can be done in these areas. For now, we will make the platform head back to its start point when the player steps off, and the same when it reaches the top of its movement:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e3ea792d-aecf-4d1e-92b4-1f5c03cb02a5.png"/></p>
<p class="mce-root"/>
<p>Note that this uses a couple of blueprint variables added to the class, too, a short reference to which is added in the <em>Further reading</em> section. The short version is under the My Blueprint tab on the left. There is Add New, and under that is Variable. Once you add one, you can change the type and default value. Here, we added one we renamed under My Blueprint | Variables as StartPosition, and on the right under details, set its type to vector, and also add GoingHome as a boolean. You can always then access these types, like C++ exposed variables too, in get/set blocks in blueprint scripting windows. Note, though, that unless you make a specific accessor (and here is an example that is <em>not</em> used, but you could implement) these variables cannot be accessed in C++:</p>
<pre>UFUNCTION(BlueprintImplementableEvent)
FVector GetStartPosition();<br/></pre>
<p>Making this a blueprint-implementable event that means for a hybrid C++/blueprint class you could add this as an event type function in blueprint and then simply have it return StartPosition. This way, a variable that is only defined in blueprint could be accessed by C++. Similarly, to make native functions in C++ that can do work as we have before, be sure to keep in mind BlueprintCallable as a <kbd>UFUNCTION</kbd> keyword, as these can be accessed <em>by</em> blueprint any time you are in or using an instance of the class that implements it.  Spoiler alert: we will be doing this quite a bit in the next chapter, <a href="eadb37a8-4ecb-4fc9-b391-e65671c99fc0.xhtml" target="_blank">Chapter 4</a>, <em>U.I. Necessities: Menus, HUD, and Load/Save</em>, similar to this:</p>
<pre>UFUNCTION(BlueprintCallable, Category="Appearance")
void SetColorAndOpacity(FSlateColor InColorAndOpacity);</pre>
<p>These functions do work in C++, but can be directly called by blueprint. Note also that these calls from C++ to blueprint and vice versa have a fairly significant call-stack overhead. On previous hardware this was a major performance issue, but to save you time here and now, on most platforms these days, the overhead really is minimal. Keep this in mind that if you switch between the two frequently, but there is no longer the same level of stress that was caused in UE3's similar systems.</p>
<p>OK, so these asides about how to call back and forth from C++ to blueprint notwithstanding, let's get back to our quick logic to get this elevator in a finished state. As you can see, there are several steps, and once again for brevity, let's just add them here in an ordered list:</p>
<ol>
<li>First, we need our two new variables, so as noted earlier, in the My Blueprint tab, click add new twice and pick variable from the list for each.</li>
<li>For the first one, rename it GoingHome, and its type can remain as-is, as a boolean.</li>
</ol>
<ol start="3">
<li>For the second, also as noted, name it StartPosition and give it the type of a vector.</li>
<li>Now, pull from the event for BeginPlay in the scripting window and filter to Set Start Position.</li>
<li>Pull left from its vector and pick GetActorLocation like we did earlier, again leaving self as the object. Now, when we begin playing, this platform will mark its initial location and save it in a blueprint-only variable we just made.</li>
<li>Now pull from our existing MoveComponentTo node and filter to Set Going Home, and check its box to true.</li>
<li>Pull from that node, and make a new MoveComponentTo node similar to how we did before. Use Platform again as the input component, but as the TargetRelativeLocation, drag from it and filter to GetStartPosition.</li>
<li>Pull from the new MoveComponentTo node's output and filter to SetGoingHome, making sure this time the node is unchecked so it's set to false.</li>
<li>We need a new event: right-click anywhere and filter to ActorEndOverlap.</li>
<li>Drag from its output and add another branch. Pull that branch's condition and do the same logic we did before, pulling the end-overlap's OtherActor to a <kbd>GetClass</kbd> node, then that return to a ClassIsChildOf MasteringCharacter, or just copy and paste those nodes with a multi or shift/control select from the begin-overlap and save yourself some trouble.</li>
<li>When that branch is true (this means our player's character is no longer on the platform), pull from the true, filter to SetGoingHome, and check its box.</li>
<li>Pull from that to a branch, pull from its condition to and filter to GetGoingHome.</li>
<li>Pull from the branch's true and add the same set of logic as before with MoveComponentTo (to StartPosition, clearing GoingHome to false after completion).</li>
</ol>
<p>What you should have now should match both the preceding screenshot and the final check-in for GitHub in the <kbd>chapter 3</kbd> branch. This elevator pad should now reliably get you up to the next floor, but also return to its start once it arrives there or is abandoned. Ideally there should probably be a timer when reaching the top before it auto-returns, and there's no reason most games could not generally just rely on the end-overlap path to reset the platform. Again, this is just showing a hint of what blueprint can do for you and is a great starting point for further experimentation!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blueprint tips, tricks, and performance hits</h1>
                
            
            
                
<p>The last real question with blueprints is how to see where your performance problems may arise and what can make life easier. As has already been noted, you can use the built-in UE4 profiling tools. This is always a good place to start. Also listed at the end of this section in additional reading is a Stack Overflow discussion of profiling tools. I highly recommend VTune from Intel, and if you have a hardware device that's compatible, the NVIDIA Visual Profiler is also an excellent tool. However, note that these items will show you in C++ classes what the hot-spots are. When you see K2 classes (or for older types, classes with <em>Kismet</em> in the name) from C++, you can be assured those are things spending time in blueprint doing work, but other things such as pathfinding, physics, or collisions may be less obvious. You may then have to work backwards to find what these mean in blueprint. A faster but cruder way to test performance with blueprints is simply to unhook (make pieces of blueprint not be called) and compare previous profiling with current profiling (or even just look at your frames per second!). There may be obvious areas of blueprint that are causing you performance pain, and fixing them or changing them will mitigate the problem. Keep especially in mind, though, like in the example of what's possible: pathfinding, or modifying the NavMesh, is entirely possible from blueprint objects. If our elevator platform modifies the NavMesh (this is a fairly simple setting, but beyond the scope of this chapter), it can be a significant performance hit as it moves! Know your tools and use what works best, but always have an eye on performance. Every game has to run smoothly on your target platforms to be a success.</p>
<p>One last rule of thumb for this chapter: if you <em>can</em> do it in blueprint, <em>do</em> it in blueprint first. Prove a mechanic works and is fun there in short order. Get players joining and starting multiplayer games together with blueprint nodes and not huge amounts of new C++ code. Use what is there, and find when it finally hits the limits of your requirements before you write your own C++ versions. Blueprint can't do everything, but it can do a huge amount of things quite well, with very minimal effort for those who know it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we've learned to do some blueprint scripting, seen some examples thereof, and some of the limitations and performance problems that it brings. It's vastly powerful and easy to learn compared to writing C++ code, but using it late in a complex project it can be a big headache. Know your team, know your options, and know your limitations: these are the keys to making the right decisions when it comes to blueprint and your project. Additionally, this blueprint knowledge will be invaluable when doing even basic UI work as we will in the next chapter. UMG (the editing interface primarily used by UE4) is heavily ingrained in blueprint work, and blueprint has a relatively easy time integrating from the game back into that UI. These are, like most things in UE4, not specifically required to have to work together, but now that there is a solid foundation and understanding of the strengths of blueprint, the benefits reaped in getting UI working quickly and to desired specifications will be easy to see!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What two systems from UE3 did blueprint grow from, giving in the K2_ prefix for most of its C++ classes?</li>
<li>What is a huge advantage of having source control integration in the editor?</li>
<li>Why are <kbd>UFUNCTIONS</kbd> and <kbd>UPROPERTIES</kbd> so valuable?</li>
<li>What is a good estimate of the time it would take to add session joining via C++?</li>
<li>What are some tools to use to profile the performance of work done in blueprint?</li>
<li>What are some drawbacks to building gameplay in blueprint and not C++?</li>
<li>Why is blueprint at some level absolutely required for any UE4 project?</li>
<li>What do you also need to do if you let running the PIE game compile your blueprints?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>Git integration in UE4 editor:</p>
<p><a href="https://wiki.unrealengine.com/Git_source_control_(Tutorial)">https://wiki.unrealengine.com/Git_source_control_(Tutorial)</a></p>
<p>Quick overview of blueprint online session nodes. Be sure to read the link about online subsystems if you're unfamiliar with them:</p>
<p><a href="https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes">https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes</a></p>
<p>Blueprint variables overview:</p>
<p><a href="https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables">https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables</a></p>
<p>C++ profiling tools:</p>
<p><a href="https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows">https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows</a></p>


            

            
        
    </body></html>