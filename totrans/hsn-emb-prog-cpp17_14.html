<html><head></head><body>
        

                            
                    <h1 class="header-title">Developing for Hybrid SoC/FPGA Systems</h1>
                
            
            
                
<p>In addition to standard CPU-based embedded systems, an increasingly common approach has been to combine CPUs in the form of SoCs with <strong>Field Programmable Gate Arrays</strong> (<strong>FGPAs</strong>). This allows CPU-intensive algorithms and processing, including DSP and image processing, to be implemented on the FPGA part of the system, with the CPU side handling less intensive tasks, such as user interaction, storage, and networking.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to communicate with the FPGA side of a hybrid FPGA/SoC system</li>
<li>Learning how a variety of algorithms are implemented in FPGA and used from the SoC side</li>
<li>How to implement a basic oscilloscope on a hybrid FPGA/SoC system</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Going extremely parallel</h1>
                
            
            
                
<p>When it comes to performance, executing a single instruction at a time on a single-core processor is essentially the slowest way you can implement an algorithm or other functionality. From here, you can scale this singular execution flow to multiple flows using simultaneous scheduling on a single processor core's individual functional units.</p>
<p>The next step to increase performance is to add more cores, which of course complicates the scheduling even more, and introduces potential latency issues with critical tasks being postponed because less critical tasks are blocking resources. The use of general purpose processors is also very limiting for certain tasks, especially those that are embarrassingly parallel.</p>
<p class="mce-root"/>
<p>For tasks where a single large dataset has to be processed using the same algorithm applied to each element in the set, the use of <strong>general-purpose graphical processor unit-based</strong> processing (<strong>GPGPU</strong>) has become very popular, along with the use of <strong>Digital Signal Processors</strong> (<strong>DSPs</strong>) to massively speed up a range of operations by using specialized hardware.</p>
<p>On the other side of this issue are the tasks, which are massively parallel, but involve many dissimilar operations being performed on incoming data, internal data, or both. This is level of complexity that it would be extremely hard to get any reasonable performance for if implemented purely in software for a range of microprocessor cores.</p>
<p>The use of expensive DSP hardware might help here, but even that would not be optimized for the task. Traditionally, this would be the point where a company might consider having a custom <strong>integrated circuit</strong> (<strong>IC</strong>) designed and produced as an <strong>application-specific integrated circuit</strong> (<strong>ASIC</strong>). The costs for this are, however, extremely high, and only realistic for large-volume production where it could compete with other options.</p>
<p>Over time, different solutions were invented to make such custom hardware implementations more realistic, one of which was the development of the programmable logic chip. A system like the Commodore 64, for example, contained a <strong>PLA</strong> (short for <strong>Programmable Logic Array</strong>, originally a Signetics 82S100) chip, which was a one-time programmable array of combinatorial logic elements. It allowed the processor to reconfigure the on-board routing of the address bus to change what parts of the DRAM memory chips, ROM chips, and other peripherals were in the active addressing space.</p>
<p>After programming the PLA, it functioned in essentially the same way as a large number of 74-logic chips (discrete logic chips), but in a fraction of the space required for such a discrete solution. This approach essentially gave Commodore their very own custom ASIC, but without having to invest money in having to design and produce it. Instead, they used an off-the-shelf part, and were free to make improvements to the logic burned into the PLA chip during the lifetime of the Commodore 64.</p>
<p>Over time, PLAs (also referred to as PAL<strong>s</strong>) became more advanced, developing into <strong>Complex Programmable Logic Devices</strong> (<strong>CPLDs</strong>), which are based around macrocells, which allow for the implementation of more advanced features instead of just simple combinatorial logic. These eventually evolved into FPGAs, which again add more advanced features and peripherals.</p>
<p>These days, FPGAs are found almost everywhere where some kind of advanced processing or control is required. Video and audio-processing equipment often use FPGAs alongside DSPs, with an MCU or SoC handling the user interface and other low-priority functionality.</p>
<p class="mce-root"/>
<p>Today, devices such as oscilloscopes are implemented with an analog (and digital, if supported) frontend, with DSPs doing the raw converting of data and the initial processing of this data prior to handing it over to one or more FPGAs , which perform further processing and analysis of the data. After processing, this data can be stored in a buffer (the "digital storage" part of a <strong>digital storage oscilloscope</strong> (<strong>DSO</strong>) as well as handed over to the frontend, where the software running on the SoC will render it in the user interface and allow the user to input commands manipulation the displayed data.</p>
<p>In this chapter, we will look at a basic oscilloscope project that will be implemented using simple hardware and an FPGA programmed using VHDL code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hardware description languages</h1>
                
            
            
                
<p>As the complexity of <strong>Very Large Scale Integrated</strong> (<strong>VLSI</strong>) circuits increased over the past decades, it became more and more crucial to find ways to improve the development process, including the ability to verify the design. This led to the development of <strong>hardware description languages</strong> (<strong>HDL</strong><strong>s</strong>), of which today VHDL and Verilog are the two most commonly used ones.</p>
<p>The main purpose of HDLs is to allow a developer to easily describe hardware circuits of the type that would be integrated into ASICs or used to program FPGAs with. In addition, these HDLs also make it possible to simulate the design and to validate its functional correctness.</p>
<p>In this chapter, we will look at an example that uses VHDL for the side of the programming that is implemented on the FPGA. <strong>VHSIC Hardware Description Language</strong> (<strong>VHDL</strong>) as a language first appeared in 1983, when it was developed by the US Department of Defense. It was intended to act as a way to document the behavior of ASICs that suppliers would provide with equipment.</p>
<p>Over time, the idea was broached that these documentation files could be used to simulate the behavior of the ASICs. This development was soon followed by the development of synthesis tools, to create a functional hardware implementation that could be used to create ASICs.</p>
<p>VHDL is heavily based on the Ada programming language, which itself also has its roots in the US military. Although VHDL is primarily used as an HDL, it can also be used as a generic programming language, much like Ada and its kin.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">FPGA architecture</h1>
                
            
            
                
<p>Though not every FPGA is structured the same way, the general principle remains the same: they are arrays of logic elements that can be configured to form specific circuits. The complexity of these <strong>logic elements</strong> (<strong>LEs</strong>) therefore determines what kind of logic circuits can be formed, which has to be taken into account when writing VHDL code for a specific FPGA architecture.</p>
<p>The terms <strong>logic elements</strong> (<strong>LEs</strong>) and <strong>logic cells</strong> (<strong>LCs</strong>) are used interchangeably. An LE consists of one or more <strong>look-up tables</strong> (<strong>LUTs</strong>), with an LUT usually having between four and six inputs. Regardless of the exact configuration, each LE is surrounded by interconnection logic, which allows different LEs to be connected to each other, and the LE itself is programmed to a specific configuration, thus forming the intended circuit.</p>
<p>This potential pitfalls of developing for FPGAs include the strong assumption by FPGA manufacturers that FPGAs will be used with clocked designs (using a central clock source and clock domains), instead of combinatorial (unclocked) logic. In general, it's a good idea to familiarize yourself with a target FPGA system prior to including it in a new project to see how well it can support the features that you need.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hybrid FPGA/SoC chips</h1>
                
            
            
                
<p>Although systems that include both an FPGA and SoC have been very common for years, a more recent addition has been hybrid FPGA/SoC chips, which include the dies for both an FPGA and an SoC (usually ARM based) in the same package. These are then linked together with a bus so that both can efficiently communicate with each other using memory-mapped I/O and similar.</p>
<p>Common examples of such FPGAs currently include Altera (now Intel), Cyclone V SoC, and Xilinx Zynq. The Cyclone V SoC's block diagram from the official datasheet gives a good overview of how such a system works:</p>
<div><img src="img/00dec7ee-3feb-4111-97b6-898f96f9b83c.png"/></div>
<p>Here, we can see that there are a number of ways that the <strong>Hard Processor System</strong> (<strong>HPS</strong>) and FPGA sides can communicate with each other, such as via a shared SDRAM controller, two point-to-point links, and a number of other interfaces. For the Cyclone V SoC, either the FPGA or SoC side can be the first side that boots when the system starts, allowing for a wide range of system configuration options.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Example – basic oscilloscope</h1>
                
            
            
                
<p>This example gives a basic overview of how one could use an FPGA in an embedded project. It uses the FPGA to sample an input and measure a voltage or similar, the way an oscilloscope would. The resulting ADC data is then sent over a serial link to a C++/Qt-based application, which displays the data.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The hardware</h1>
                
            
            
                
<p>For the project, we will use a Fleasystems FleaFPGA Ohm board (<a href="http://fleasystems.com/fleaFPGA_Ohm.html">http://fleasystems.com/fleaFPGA_Ohm.html</a>). This is a small, sub-$50, sub-€40 FPGA development board in a Raspberry Pi Zero form factor:</p>
<div><img src="img/0fb4d23c-b3e9-437b-8891-ac36d9abeb84.png"/></div>
<p>It has the following specifications:</p>
<ul>
<li><strong>Lattice ECP5 FPGA</strong> with 24K LUT elements and 112KB Block RAM.</li>
<li><strong>256-Mbit SDRAM</strong>, 16 bits wide and 167 MHz clock.</li>
<li><strong>8-Mbit SPI Flash ROM</strong> for FPGA configuration storage.</li>
<li>25 MHz Crystal oscillator.</li>
<li><strong>HDMI video</strong> out (up to 1080p30 or 720p60 screen modes possible).</li>
<li><strong>μSD card slot</strong>.</li>
<li>Two micro USB host ports with alternate PS/2 host port functionality.</li>
<li>29 user GPIO, including 4 x medium-speed ADC inputs and 12 x LVDS signal pairs available from the (Raspberry Pi compatible) 40-pin expansion, and 2-pin reset headers, respectively.</li>
<li>One micro USB slave port. Provides +5V supply feed to the Ohm, serial console/UART communications, as well as access to the on-board JTAG programming interface (for configuring the ECP5 FPGA).</li>
<li>Provision for an external JTAG programming pod to allow real-time debugging.</li>
</ul>
<p>To this board, we connect circuit which will allow us to connect an oscilloscope probe:</p>
<div><img src="img/be8609a6-c88d-4c76-95aa-3bfdebfdb919.png" style="width:41.75em;height:33.50em;"/></div>
<p>This circuit will be connected to pin number 29 on the Ohm board's GPIO header, corresponding to GPIO 5. It allows us to measure 0 to 3V DC signals, and 1.5V AC (RMS), in 1 x probe measurement mode. Bandwidth is a little over 10 MHz.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The VHDL code</h1>
                
            
            
                
<p>In this section, we will take a look at the top-level entity in the VHDL project, to get an idea of what it does. This starts with the standard library includes for VHDL as shown:</p>
<pre>library IEEE; 
use IEEE.STD_LOGIC_1164.ALL; 
use IEEE.std_logic_unsigned.ALL; 
use IEEE.numeric_std.all; 
 
entity FleaFPGA_Ohm_A5 is   
   port( 
   sys_clock         : in        std_logic;  -- 25MHz clock input from external xtal oscillator. 
   sys_reset         : in        std_logic;  -- master reset input from reset header. </pre>
<p>This maps to the underlying FPGA's system clock and reset line. We can also see the way that port mapping works, defining the direction of the entity port and the type. Here, the type is <kbd>std_logic</kbd>, which is a standard logic signal of either a binary one or zero:</p>
<pre>   n_led1                  : buffer    std_logic; 
  
   LVDS_Red          : out       std_logic_vector(0 downto 0); 
   LVDS_Green        : out       std_logic_vector(0 downto 0); 
   LVDS_Blue         : out       std_logic_vector(0 downto 0); 
   LVDS_ck                 : out       std_logic_vector(0 downto 0); 
    
   slave_tx_o        : out       std_logic; 
   slave_rx_i        : in        std_logic; 
   slave_cts_i       : in        std_logic;  -- Receive signal from #RTS pin on FT230x </pre>
<p>We also use the status LED on the board, map the HDMI's video pins (LVDS signaling), and the UART interface, which uses the FDTI USB-UART chip on the board. The latter is what we will be using to send the data from the FPGA to the C++ application.</p>
<p>Next, the Raspberry Pi compatible header mapping, as shown in the following code:</p>
<pre>   GPIO_2                  : inout           std_logic; 
   GPIO_3                  : inout           std_logic; 
   GPIO_4                  : inout           std_logic; 
   -- GPIO_5               : inout           std_logic; 
   GPIO_6                  : inout           std_logic;   
   GPIO_7                  : inout           std_logic;   
   GPIO_8                  : inout           std_logic;   
   GPIO_9                  : inout           std_logic;   
   GPIO_10                 : inout           std_logic; 
   GPIO_11                 : inout           std_logic;   
   GPIO_12                 : inout           std_logic;   
   GPIO_13                 : inout           std_logic;   
   GPIO_14                 : inout           std_logic;   
   GPIO_15                 : inout           std_logic;   
   GPIO_16                 : inout           std_logic;   
   GPIO_17                 : inout           std_logic; 
   GPIO_18                 : inout           std_logic;   
   GPIO_19                 : inout           std_logic;   
   GPIO_20                 : in        std_logic; 
   GPIO_21                 : in        std_logic;   
   GPIO_22                 : inout           std_logic;   
   GPIO_23                 : inout           std_logic; 
   GPIO_24                 : inout           std_logic; 
   GPIO_25                 : inout           std_logic;   
   GPIO_26                 : inout           std_logic;   
   GPIO_27                 : inout           std_logic; 
   GPIO_IDSD         : inout           std_logic; 
   GPIO_IDSC         : inout           std_logic; </pre>
<p>The reason that GPIO 5 is commented out is because we want to use it for the ADC functionality and not general-purpose input/output.</p>
<p>Instead, we enable the sigma-delta-capable ADC3 peripheral to work on that pin as follows:</p>
<pre>   --ADC0_input      : in        std_logic; 
   --ADC0_error      : buffer    std_logic; 
   --ADC1_input      : in        std_logic; 
   --ADC1_error      : buffer    std_logic; 
   --ADC2_input      : in        std_logic; 
   --ADC2_error      : buffer    std_logic; 
   ADC3_input  : in        std_logic; 
   ADC3_error  : buffer    std_logic; </pre>
<p>Here, we see that we have another three ADC peripherals that we could use if we wanted to add additional channels to the oscilloscope , as shown in the following code:</p>
<pre>   mmc_dat1          : in        std_logic; 
   mmc_dat2          : in        std_logic; 
   mmc_n_cs          : out       std_logic; 
   mmc_clk           : out       std_logic; 
   mmc_mosi          : out       std_logic; 
   mmc_miso          : in        std_logic; 
 
   PS2_enable        : out       std_logic; 
   PS2_clk1          : inout           std_logic; 
   PS2_data1         : inout           std_logic; 
    
   PS2_clk2          : inout           std_logic; 
   PS2_data2         : inout           std_logic 
   ); 
end FleaFPGA_Ohm_A5; </pre>
<p>The entity definition for the top-level ends with the MMC (SD card) and PS2 interfaces.</p>
<p>Next is the architecture definition of the module. This part is akin to the source file of a C++ application, with the entity definition functioning like a header as shown:</p>
<pre>architecture arch of FleaFPGA_Ohm_A5 is 
   signal clk_dvi  : std_logic := '0'; 
   signal clk_dvin : std_logic := '0'; 
   signal clk_vga  : std_logic := '0'; 
   signal clk_50  : std_logic := '0'; 
   signal clk_pcs   : std_logic := '0'; 
 
   signal vga_red     : std_logic_vector(3 downto 0) := (others =&gt; '0'); 
   signal vga_green   : std_logic_vector(3 downto 0) := (others =&gt; '0'); 
   signal vga_blue    : std_logic_vector(3 downto 0) := (others =&gt; '0'); 
    
   signal ADC_lowspeed_raw     : std_logic_vector(7 downto 0) := (others =&gt; '0'); 
    
   signal red     : std_logic_vector(7 downto 0) := (others =&gt; '0'); 
   signal green   : std_logic_vector(7 downto 0) := (others =&gt; '0'); 
   signal blue    : std_logic_vector(7 downto 0) := (others =&gt; '0'); 
   signal hsync   : std_logic := '0'; 
   signal vsync   : std_logic := '0'; 
   signal blank   : std_logic := '0'; </pre>
<p>A number of signals are defined here. These allow us to connect the ports, entities, processes, and other elements of a VHDL module with each other.</p>
<p>We can see that some signals are defined here for VGA support. This allows compatibility with VGA-enabled FPGA boards, but parts of it are also compatible with the HDMI (or a DVI) peripheral, as we will see in a moment. Let's look at the following code:</p>
<pre>begin 
 Dram_CKE &lt;= '0';    -- DRAM Clock disable. 
 Dram_n_cs &lt;= '1';   -- DRAM Chip disable. 
 PS2_enable &lt;= '1'; -- Configures both USB host ports for legacy PS/2 mode. 
 mmc_n_cs &lt;= '1';    -- Micro SD card chip disable. </pre>
<p>With the <kbd>begin</kbd> keyword, we indicate that this is the point where we want to start executing the commands in the architecture definition. Everything after this keyword and the terminating keyword (<kbd>end architecture</kbd>) will be executed simultaneously, unless a block of instructions is encapsulated within a <kbd>process</kbd> (not shown in this code).</p>
<p class="mce-root"/>
<p>We disable a number of hardware features by writing to the appropriate pins. We omitted the DRAM (external memory) section in the earlier entity definition for brevity's sake. The DRAM and SD card functionality are disabled, while PS2 (keyboard, mouse) functionality is enabled. This allows us to connect a PS2 input device if we wanted to:</p>
<pre> user_module1 : entity work.FleaFPGA_DSO 
    port map( 
         rst =&gt; not sys_reset, 
         clk =&gt; clk_50, 
         ADC_1 =&gt; n_led1, 
         ADC_lowspeed_raw =&gt; ADC_lowspeed_raw, 
         Sampler_Q =&gt; ADC3_error, 
         Sampler_D =&gt; ADC3_input, 
         Green_out =&gt; vga_green, 
         Red_out =&gt; vga_red, 
         Blue_out =&gt; vga_blue, 
         VGA_HS =&gt; hsync, 
         VGA_VS =&gt; vsync, 
         blank =&gt; blank, 
         samplerate_adj =&gt; GPIO_20, 
         trigger_adj =&gt; GPIO_21 
    ); </pre>
<p>Here, we define that we will be using an instance of the FleaFPGA Digital Storage Oscilloscope module. Only the first channel is mapped, though the module could support four channels. This simplification helps to demonstrate the principle of operation.</p>
<p>The DSO module is responsible for reading out the data from the ADC as it samples the signal we're measuring with the probe, and both renders it to a local cache for display on a local (HDMI or VGA) monitor and send it over the serial interface to the UART module (shown at the end of this section). . Let's look at the following code:</p>
<pre>   red &lt;= vga_red &amp; "0000"; 
   green &lt;= vga_green &amp; "0000"; 
   blue &lt;= vga_blue &amp; "0000"; </pre>
<p>Here, the final colors for the display output are determined with the HDMI output signal:</p>
<pre><strong>   u0 : entity work.DVI_clkgen 
   port map( 
         CLKI              =&gt;    sys_clock, 
         CLKOP             =&gt;    clk_dvi, 
         CLKOS                   =&gt;  clk_dvin, 
         CLKOS2                  =&gt;  clk_vga, 
         CLKOS3                  =&gt;  clk_50 
         );   
 
   u100 : entity work.dvid PORT MAP( 
      clk       =&gt; clk_dvi, 
      clk_n     =&gt; clk_dvin, 
      clk_pixel =&gt; clk_vga, 
      red_p     =&gt; red, 
      green_p   =&gt; green, 
      blue_p    =&gt; blue, 
      blank     =&gt; blank, 
      hsync     =&gt; hsync, 
      vsync     =&gt; vsync, 
      -- outputs to TMDS drivers 
      red_s     =&gt; LVDS_Red, 
      green_s   =&gt; LVDS_Green, 
      blue_s    =&gt; LVDS_Blue, 
      clock_s   =&gt; LVDS_ck 
   );</strong> </pre>
<p>This whole section serves to output the video signal that gets generated by the DSO module, allowing us to also use the FPGA board as a standalone oscilloscope unit:</p>
<pre>   myuart : entity work.simple_uart 
 
         port map( 
               clk =&gt; clk_50, 
               reset =&gt; sys_reset, -- active low 
               txdata =&gt; ADC_lowspeed_raw, 
               --txready =&gt; ser_txready, 
               txgo =&gt; open, 
               --rxdata =&gt; ser_rxdata, 
               --rxint =&gt; ser_rxint, 
               txint =&gt; open, 
               rxd =&gt; slave_rx_i, 
               txd =&gt; slave_tx_o 
         ); 
end architecture; </pre>
<p>Finally, the simple UART implementation that allows the DSO module to communicate with our C++ application.</p>
<p>The UART is configured to work at a baud rate of 19,200, 8 bits, 1 stop bit, and no parity. After building this VHDL project and programming the FPGA board with it, we can connect to it over this serial connection.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The C++ code</h1>
                
            
            
                
<p>While the VHDL code implements a simple display output with basic input options, if we want to have a large (high-resolution) display, perform signal analysis, make recordings of multiple minutes or even hours, and so on, it will be very convenient to be able to do this on an SBC.</p>
<p>The following code is written as a C++/Qt graphical application that takes in the raw ADC data from the FPGA board and displays it in a graph. While barebones, it provides the framework for a full-featured, SoC-based system.</p>
<p>First, the header is shown, as follows:</p>
<pre>#include &lt;QMainWindow&gt; 
 
#include &lt;QSerialPort&gt; 
#include &lt;QChartView&gt; 
#include &lt;QLineSeries&gt; 
 
 
namespace Ui { 
    class MainWindow; 
} 
 
class MainWindow : public QMainWindow { 
    Q_OBJECT 
     
public: 
    explicit MainWindow(QWidget *parent = nullptr); 
    ~MainWindow(); 
     
public slots: 
    void connectUart(); 
    void disconnectUart(); 
    void about(); 
    void quit(); 
     
private: 
    Ui::MainWindow *ui; 
     
    QSerialPort serialPort; 
    QtCharts::QLineSeries* series; 
    quint64 counter = 0; 
     
private slots: 
    void uartReady(); 
}; </pre>
<p>Here, we can see that we will be using the serial port implementation in Qt, along with the QChart module, for the visualization part.</p>
<p class="mce-root"/>
<p>The implementation is shown in the following code:</p>
<pre>#include "mainwindow.h" 
#include "ui_mainwindow.h" 
 
#include &lt;QSerialPortInfo&gt; 
#include &lt;QInputDialog&gt; 
#include &lt;QMessageBox&gt; 
 
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), 
    ui(new Ui::MainWindow) { 
    ui-&gt;setupUi(this); 
     
    // Menu connections. 
    connect(ui-&gt;actionQuit, SIGNAL(triggered()), this, SLOT(quit())); 
    connect(ui-&gt;actionConnect, SIGNAL(triggered()), this, SLOT(connectUart())); 
    connect(ui-&gt;actionDisconnect, SIGNAL(triggered()), this, SLOT(disconnectUart())); 
    connect(ui-&gt;actionInfo, SIGNAL(triggered()), this, SLOT(about())); 
     
    // Other connections 
    connect(&amp;serialPort, SIGNAL(readyRead()), this, SLOT(uartReady())); 
     
    // Configure the chart view. 
    QChart* chart = ui-&gt;chartView-&gt;chart(); 
    chart-&gt;setTheme(QChart::ChartThemeBlueIcy); 
    chart-&gt;createDefaultAxes(); 
    series = new QtCharts::QLineSeries(chart); 
    chart-&gt;setAnimationOptions(QChart::NoAnimation);         
    chart-&gt;addSeries(series); 
} </pre>
<p>In the constructor, we create the connections with the menu options in the GUI, which allow us to quit the application, connect to a serial port, disconnect from a serial port if we are connected, or get information about the application.</p>
<p>We connect the serial port instance to a slot that will be called whenever new data is ready to be read.</p>
<p>Finally, we configure the chart view in the GUI, obtaining a reference to the QChart instance inside the QChartView widget. On this reference, we set a theme for the chart, add default axes, and finally, add an empty series, which we will be filling up with the incoming data from the FPGA , as shown in the following code:</p>
<pre>MainWindow::~MainWindow() { 
    delete ui; 
} 
 
 
void MainWindow::connectUart() { 
    QList&lt;QSerialPortInfo&gt; comInfo = QSerialPortInfo::availablePorts(); 
    QStringList comNames; 
    for (QSerialPortInfo com: comInfo) { 
        comNames.append(com.portName()); 
    } 
     
    if (comNames.size() &lt; 1) { 
        QMessageBox::warning(this, tr("No serial port found"), tr("No serial port was found on the system. Please check all connections and try again.")); 
        return; 
    } 
     
    QString comPort = QInputDialog::getItem(this, tr("Select serial port"), tr("Available ports:"), comNames, 0, false); 
     
    if (comPort.isEmpty()) { return; } 
     
    serialPort.setPortName(comPort); 
    if (!serialPort.open(QSerialPort::ReadOnly)) { 
        QMessageBox::critical(this, tr("Error"), tr("Failed to open the serial port.")); 
        return; 
    } 
     
    serialPort.setBaudRate(19200); 
    serialPort.setParity(QSerialPort::NoParity); 
    serialPort.setStopBits(QSerialPort::OneStop); 
    serialPort.setDataBits(QSerialPort::Data8); 
} </pre>
<p>When the user wishes to connect to the FPGA via the UART, the serial connection on which the FPGA is connected has to be selected, after which a connection will be established, with the 19,200 baud, 8N1 settings we established previously in the VHDL section of the project.</p>
<p>For a fixed configuration where the serial port is always the same, one could consider automating the following part when the system boots:</p>
<pre>void MainWindow::disconnectUart() { 
    serialPort.close(); 
} </pre>
<p>Disconnecting from the serial port is quite straightforward:</p>
<pre>void MainWindow::uartReady() { 
    QByteArray data = serialPort.readAll(); 
     
    for (qint8 value: data) { 
        series-&gt;append(counter++, value); 
    } 
} </pre>
<p class="mce-root"/>
<p>When the UART receives new data from the FPGA board, this slot gets called. In it, we read all of the data from the UART buffer, appending it to the series that we added to the graph widget, which updates the displayed trace. The counter variable is used to provide an increasing time base for the graph. This functions as a simplistic timestamp here.</p>
<p>At some point, we should start removing data from the series to prevent it from getting too large, along with the ability to search through it and save the data. The counter-based timestamp could report the actual time at which we received the signal, though ideally this should be part of the data that we received from the FPGA:</p>
<pre>void MainWindow::about() { 
    QMessageBox::aboutQt(this, tr("About")); 
} 
 
 
void MainWindow::quit() { 
    exit(0); 
} </pre>
<p>We end with a few simple slots. For the information dialog, we simply show the standard Qt information dialog. This could be replaced with a custom help or information dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the project</h1>
                
            
            
                
<p>The VHDL project can be built and programmed onto the Ohm FPGA board using the free Lattice Semiconductor Diamond IDE software (<a href="http://www.latticesemi.com/latticediamond">http://www.latticesemi.com/latticediamond</a>). Programming the board requires that the FleaFPGA JTAG utility from <a href="https://github.com/Basman74/FleaFPGA-Ohm">https://github.com/Basman74/FleaFPGA-Ohm</a> is installed so that Diamond can use it.</p>
<p>By following the instructions for the FleaFPGA Ohm board as described in the quick start guide, it should be relatively easy to get that part of the project up and running. For the C++ side, one has to make sure that the FPGA board and SBC (or equivalent) are connected so that the latter can access the UART on the former.</p>
<p>With this in place, simply compiling the C++ project with the Qt framework (directly on the SBC or preferably cross-compiling on a desktop system) suffices. After this, one can run the application with the flashed FPGA board active, connect to the UART, and observe the trace being drawn on the application window.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at what role FPGAs play in embedded development, how they have changed in importance over the past decades, and how they are now being used. We looked at a simple implementation of an oscilloscope that uses both an FPGA and an SBC-based component. Having read through this chapter, you should now know when to pick an FPGA for a new embedded project and understand how one can use and communicate with such a device.</p>


            

            
        
    </body></html>