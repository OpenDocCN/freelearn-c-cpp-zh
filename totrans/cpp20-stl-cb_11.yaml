- en: '*Chapter 11*: A Few More Ideas'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned some useful techniques in this book, including optional values,
    containers, iterators, algorithms, smart pointers, and more. We've seen examples
    of these concepts in use, and we've had the opportunity to experiment and apply
    them to some small projects. Let's now apply these techniques to a few more practical
    ideas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a trie class for search suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the error sum of two vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build your own algorithm: `split`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leverage existing algorithms: `gather`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove consecutive whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert numbers to words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11).
  prefs: []
  type: TYPE_NORMAL
- en: Create a trie class for search suggestions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *trie*, sometimes called a *prefix tree*, is a type of search tree, commonly
    used for predictive text and other search applications. A trie is a recursive
    structure designed for depth-first searches, where each *node* is both a key and
    another trie.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case is a *trie of strings*, where each node is a string in a
    sentence. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – A trie of strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – A trie of strings
  prefs: []
  type: TYPE_NORMAL
- en: 'We often start a search at the *head* of a trie, looking for sentences that
    begin with a specific word. In this example, when I search for `all`, I get three
    nodes: `you`, `the`, and `along`. If I search for `love`, I get `me` and `is`.'
  prefs: []
  type: TYPE_NORMAL
- en: A string trie is commonly used for creating search suggestions. Here we will
    implement a string trie using `std::map` for the trie structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we create a recursive `trie` class that stores nodes in a `std::map`
    container. It's a simple solution for a small in-memory trie. This is a rather
    large class, so we'll only show the important parts here.
  prefs: []
  type: TYPE_NORMAL
- en: For the full class, please see the source code at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one convenience alias:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `ilcstr` in for searching the `trie`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll put this class in a private namespace to avoid collisions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have a few `using` statements in this namespace for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class itself is called `trie`. It has three data members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `trie` class has a few local type aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_t` is a `deque` of `deque` of `string`, used for string results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodes_t` is a map of `trie` classes with `string` keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result_t` is an `optional` of a pointer to a `trie`, for returning search
    results. An empty `trie` is a valid result, so we use an `optional` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `nodes` object is used for holding a recursive `map` of nodes, where each
    node on a `trie` is another `trie`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The public interface often calls utility functions in the private interface.
    For example, the `insert()` method takes an `initializer_list` object and calls
    the private function `_insert()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The private `_insert()` function does the work of inserting elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This facilitates the recursive function calls necessary to navigate the `trie`.
    Note that referencing a key that does not appear in a `map` creates an empty element
    with that key. So, the line that calls `_insert()` on a `nodes` element creates
    an empty `trie` object if the element doesn't already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get()` method returns a `get_t` object, which is an alias for a `deque`
    of `deque` of `string`. This allows us to return multiple sets of results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `get()` method calls the private `_get()` function, which recursively traverses
    the `trie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `find_prefix()` function returns a `deque` with all matches to a partial
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The public interface calls the private function `_find_prefix()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The private `_find_prefix()` function traverses the `trie` recursively, comparing
    the prefix with beginning of each key. The `starts_with()` method is new with
    C++20\. With an older STL, you could use the `find()` method and check the return
    value for `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `search()` function returns an `optional<const trie*>`, aliased as `result_t`.
    It has two overloads:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These methods pass iterators to the private member function `_search()`, which
    does the work of the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `_search()` function searches recursively until it finds a match, then returns
    a node in the `result_t` object. If it finds no match, it returns the non-value
    `optional`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have two overloads of a `print_trie_prefix()` function. This function
    prints the contents of a `trie` from a prefix, used as a search key. One version
    uses a `string` for the prefix, the other uses an `initializer_list` of C-strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These functions call the `get()` member function to retrieve the results from
    the `trie`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test the `trie` class in the `main()` function. First, we declare
    a `trie` and insert some sentences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `insert()` calls pass an `initializer_list` with all the strings of a sentence.
    Each of the strings of a sentence are inserted into the hierarchy of the `trie`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can search the trie. Here's a simple search for the single string `"love"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This calls `ts.search()` with an `initializer_list` of one C-string, called
    `prefix`. The result, along with the `prefix`, is then passed to the `print_trie_prefix()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a search for a two-string prefix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a search for a partial prefix, using the `find_prefix()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `find_prefix()` search returned several results, each of which we passed
    to a search of its own, resulting in several results for each result.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data for the `trie` class is stored in recursive `map` containers. Each
    node in the `map` contains another `trie` object, which in turn has its own `map`
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_insert()` function takes `begin` and `end` iterators, and uses them to
    recursively call `_insert()` on new nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `_search()` function recursively calls `_search()` on the nodes
    it finds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This recursive approach using `std::map` allows us to implement a trie class
    concisely and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the error sum of two vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given two similar vectors that differ only by quantization or resolution, we
    can use the `inner_product()` algorithm to calculate an *error sum*, defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Error sum definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Error sum definition
  prefs: []
  type: TYPE_NORMAL
- en: Where *e* is the error sum, the sum of the square of the difference between
    a series of points in two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `inner_product()` algorithm, from the `<numeric>` header, to
    calculate the error sum between two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we define two vectors, each with a *sine wave*. One `vector`
    has values of type `double` and the other has type `int`. This gives us vectors
    that differ in quantization, because the `int` type cannot represent fractional
    values. We then use `inner_product()` to calculate the error sum between the two
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function we define our vectors and a handy `index` variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ds` is the `vector` of `double` sine waves and `is` is the `vector` of `int`
    sine waves. Each `vector` has 100 elements to hold a sine wave. The `index` variable
    is used to initialize the `vector` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate the sine wave in the `vector` of `double`, using a loop and a lambda:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The lambda captures a reference to the `index` variable so it can be incremented.
  prefs: []
  type: TYPE_NORMAL
- en: The `pi` constant is from the `std::numbers` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a `double` sine wave and we can use it to derive the `int` version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This takes each point from `ds`, rounds it, casts it to an `int`, and updates
    it in position in the `is` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We display our sine waves with a simple loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our output is the sine waves as data points in the two containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we calculate the error sum using `inner_product()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The lambda expression returns the (*a*i – *b*i)2 part of the formula. The `std::plus()`
    algorithm performs the sum operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `inner_product()` algorithm computes a sum of products on the first input
    range. Its signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The function takes two binary operator functors, `op1` and `op2`. The first
    `op1` is for the *sum* and the second `op2` is for the *product*. We use `std::plus()`
    as the sum operator, and a lambda as the product operator.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` parameter can be used as a starting value or bias. We pass it the
    literal value, `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is the accumulated sum of the products.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can calculate an accumulated error sum by putting `inner_product()` in a
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This may be useful in some statistical applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build your own algorithm: split'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL has a rich `algorithm` library. Yet, on occasion you may find it missing
    something you need. One common need is a `split` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `split` function splits a string on a character separator. For example, here''s
    a Unix `/etc/passwd` file from a standard Debian installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Each field is separated by a colon `:` character, where the fields are:'
  prefs: []
  type: TYPE_NORMAL
- en: Login name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optional encrypted password
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User ID
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group ID
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Username or comment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Home directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optional command interpreter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a standard file in POSIX-based operating systems, and there are others
    like it. Most scripting languages include a built-in function for splitting a
    string on a separator. There are simple ways to do this in C++. Still, `std::string`
    is just another container in the STL, and a generic algorithm that splits a container
    on a separator could be a useful addition to the toolbox. So, let's build one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we build a generic algorithm that splits a container on a separator
    and puts the results in a target container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our algorithm is in the `bw` namespace, to avoid collisions with `std`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `split()` algorithm searches a container for separators and collects the
    separated slices into a new output container, where each slice is a container
    within the output container.
  prefs: []
  type: TYPE_NORMAL
- en: We want the `split()` algorithm to be as generic as possible, just like those
    in the `algorithm` library. This means that all the parameters are templated,
    and the code will work with a comprehensive variety of parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`It` is the input iterator type for the source container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Oc` is the output container type. This is a container of containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V` is the separator type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pred` is for the predicate functor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our output type is a container of containers. It needs to hold containers of
    slices. It could be `vector<string>`, where the string values are slices, or `vector<vector<int>>`,
    where the inner `vector<int>` contains the slices. This means we need to derive
    the type of the inner container from the output container type. We do that with
    the `using` declaration in the body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is also why we cannot use an output iterator for the output parameter.
    By definition, an output iterator cannot determine the type of its contents and
    its `value_type` is set to `void`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `SliceContainer` to define a temporary container that is added to the
    output container with the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The predicate is a binary operator that compares an input element with the
    separator. We include a default equality operator in the `bw` namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also include a specialization of `split()` that uses the `eq` operator by
    default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because splitting `string` objects is a common use case for this algorithm,
    we include a helper function for that specific purpose:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We test our split algorithm `main()`, starting with a `string` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use a string from the `/etc/passwd` file to test our algorithm, with this
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s even simpler using our `strsplit()` helper function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This would make it easy to parse the `/etc/passwd` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can use the same algorithm with any container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The split algorithm itself is relatively simple. The magic in this recipe is
    in the use of templates to make it as generic as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The derived type in the `using` declaration allows us to create a container
    for use with the output container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a `SliceContainer` type that we can use to create a container
    for the slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a temporary container that is added to the output container for each
    slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Leverage existing algorithms: gather'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`gather()` is an example of an algorithm that leverages existing algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: The `gather()` algorithm takes a pair of container iterators and moves the elements
    that satisfy a predicate toward a *pivot* position within the sequence, returning
    a `pair` of iterators that contains the elements that satisfy the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could use a `gather` algorithm to sort all the even numbers
    to the mid-point of a `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the even numbers are all in the middle of the output.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement a `gather` algorithm using standard STL algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `gather` algorithm uses the `std::stable_partition()` algorithm to move
    items before the pivot iterator and again to move items past the pivot.
  prefs: []
  type: TYPE_NORMAL
- en: We put the algorithm in the `bw` namespace to avoid collisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `gather()` algorithm returns a `pair` of iterators, returned from two calls
    to `stable_partition()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also include some helper lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These three lambdas are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`midit` returns an iterator at the midpoint of a container, for use as a pivot
    point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_even` returns Boolean `true` if the value is even, for use as a predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_even_char` returns Boolean `true` if the value is a character between `''0''`
    and `''9''` and is even, for use as a predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call `gather()` from the `main()` function with a vector of `int` like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our output shows that the even numbers have been gathered in the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gather()` function returns a `pair` of iterators that contain just the
    even values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the pivot point to the `begin()` or `end()` iterators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `gather()` is iterator-based, we can use it with any container. Here''s
    a string of character digits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This moves all the even digits to the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gather()` function uses the `std::stable_partition()` algorithm to move
    the elements that match the predicate to the pivot point.
  prefs: []
  type: TYPE_NORMAL
- en: '`gather()` has two calls to `stable_partition()`, one with the predicate, and
    one with the predicate negated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The iterators returned from the two `stable_partition()` calls are returned
    in the `pair`.
  prefs: []
  type: TYPE_NORMAL
- en: Remove consecutive whitespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When receiving input from users, it's common to end up with excessive consecutive
    whitespace characters in your strings. This recipe presents a function for removing
    consecutive spaces, even when it includes tabs or other whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function leverages the `std::unique()` algorithm to remove consecutive
    whitespace characters from a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `bw` namespace, we start with a function to detect whitespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This templated `isws()` function should work with any character type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delws()` function uses `std::unique()` to erase consecutive whitespace
    in a `string`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`delws()` makes a copy of the input string, removes consecutive whitespace,
    and returns the new string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call it with a `string` from `main()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function uses the `std::unique()` algorithm with a comparison lambda to
    find consecutive whitespace in a `string` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparison lambda calls our own `isws()` function to determine if we have
    found consecutive whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We could use the `isspace()` function from the standard library, but it's a
    standard C function that depends on a narrowing type conversion from `int` to
    `char`. This may issue warnings on some modern C++ compilers and is not guaranteed
    to work without an explicit cast. Our `isws()` function uses a templated type
    and should work on any system, and with any specialization of `std::string`.
  prefs: []
  type: TYPE_NORMAL
- en: Convert numbers to words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of my career, I've used a lot of programming languages. When
    learning a new language, I like to have a project to work on that exposes me to
    the nuances of the language. The `numwords` class is one of my favorite exercises
    for this purpose. I have written it in dozens of languages over the years, including
    several times in C and C++.
  prefs: []
  type: TYPE_NORMAL
- en: '`numwords` is a class that spells out a number in words. It can be useful for
    banking and accounting applications. It looks like this in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe originated as an exercise in creating production-ready code. For
    that reason, it''s in three different files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numword.h` is the header/interface file for the `numwords` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numword.cpp` is the implementation file for the `numwords` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numword-test.cpp` is the application file for testing the `numword` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class itself is about 180 lines of code so we'll just cover the highlights
    here. You can find the full source code at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `numword.h` file, we put the class in the `bw` namespace and start with
    some `using` statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `string` and `string_view` objects throughout the code.
  prefs: []
  type: TYPE_NORMAL
- en: '`uint64_t` is our primary integer type because it will hold very large numbers.
    Because the class is called `numword`, I like `numnum` for the integer type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`_bufstr` is the main output buffer. It''s a `string` wrapped in a `unique_ptr`,
    which handles the memory management for automatic RAII compliance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a few constants for various purposes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `maxnum` constant translates to "nine hundred ninety-nine quadrillion nine
    hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine
    million nine hundred ninety-nine thousand nine hundred ninety-nine," which should
    be sufficient for most purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the `numnum` constants are used to avoid literals in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main data structures are `constexpr` arrays of `string_view` objects, representing
    the words used in the output. The `string_view` class is perfect for these constants,
    as it provides encapsulation with minimum overhead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The words are grouped into sections, useful in translating numbers to words.
    Many languages use a similar breakdown so this structure should translate easily
    to those languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `numword` class has a few private members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`_buf` is the output string buffer. Its memory is managed by a `unique_ptr`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_num` holds the current numeric value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_hyphen_flag` is used during the translation process to insert a hyphen between
    words, rather than a space character.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These private methods are used to manipulate the output buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also a `pow_i()` private method used to calculate *x*y with `numnum`
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`pow_i()` is used to discriminate parts of the numeric value for word output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The public interface includes constructors and various ways to call the `words()`
    method, which does the work of translating a `numnum` to a `string` of words:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the implementation file, `numword.cpp`, the bulk of the work is handled
    in the `words()` member function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each part of the function peels off part of the number with a *modulus of a
    power of ten*, recursively in the case of the thousands, and appends strings from
    the `string_view` constant arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three overloads of `appendbuf()`. One appends a `string`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another appends a `string_view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And the third appends a single character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `appendspace()` method appends a space character or a hyphen, depending
    on the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `numword-test.cpp` file is the testing environment for `bw::numword`. It
    includes a `formatter` specialization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to pass a `bw::numword` object directly to `format()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a `print()` function that sends `formatter` output directly to
    `stdout`, bypassing `cout` and the `iostream` library entirely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to use `print("{}\n", nw)` instead of piping `format()` through
    `cout`. A function like this will be included in the C++23 standard. It's simple
    enough to include it like this for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, we declare a `bw::numword` object and a `uint64_t` for use in
    testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `numword` object is initialized to zero, giving us this output from our
    `print()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We test a variety of ways to call `numword`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class is significantly driven by the data structures. By organizing `string_view`
    objects into arrays, we can easily translate scalar values into corresponding
    words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of it is mostly the math:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I also have a utility that uses the `numwords` class to tell time in words.
    Its output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In test mode, it gives this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: I leave its implementation as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
