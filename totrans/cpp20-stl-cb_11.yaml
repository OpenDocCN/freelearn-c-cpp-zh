- en: '*Chapter 11*: A Few More Ideas'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：一些更多想法'
- en: We've learned some useful techniques in this book, including optional values,
    containers, iterators, algorithms, smart pointers, and more. We've seen examples
    of these concepts in use, and we've had the opportunity to experiment and apply
    them to some small projects. Let's now apply these techniques to a few more practical
    ideas.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中学到了一些有用的技术，包括可选值、容器、迭代器、算法、智能指针等。我们看到了这些概念的应用示例，并有机会进行实验并将它们应用于一些小型项目。现在让我们将这些技术应用于一些更多实际的想法。
- en: 'In this chapter, we cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Create a trie class for search suggestions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为搜索建议创建一个 trie 类
- en: Calculate the error sum of two vectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个向量的误差和
- en: 'Build your own algorithm: `split`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的算法：`split`
- en: 'Leverage existing algorithms: `gather`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用现有算法：`gather`
- en: Remove consecutive whitespace
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除连续空白
- en: Convert numbers to words
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字转换为文字
- en: Technical requirement
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件 [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11)。
- en: Create a trie class for search suggestions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为搜索建议创建一个 trie 类
- en: A *trie*, sometimes called a *prefix tree*, is a type of search tree, commonly
    used for predictive text and other search applications. A trie is a recursive
    structure designed for depth-first searches, where each *node* is both a key and
    another trie.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*trie*，有时称为 *前缀树*，是一种搜索树类型，常用于预测文本和其他搜索应用。trie 是一种递归结构，旨在进行深度优先搜索，其中每个 *节点*
    既是键又是另一个 trie。'
- en: 'A common use case is a *trie of strings*, where each node is a string in a
    sentence. For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是 *字符串 trie*，其中每个节点是句子中的一个字符串。例如：
- en: '![Figure 11.1 – A trie of strings'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 字符串 trie'
- en: '](img/B18267_11_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_11_01.jpg)'
- en: Figure 11.1 – A trie of strings
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 字符串 trie
- en: 'We often start a search at the *head* of a trie, looking for sentences that
    begin with a specific word. In this example, when I search for `all`, I get three
    nodes: `you`, `the`, and `along`. If I search for `love`, I get `me` and `is`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常从 trie 的 *头部* 开始搜索，寻找以特定单词开头的句子。在这个例子中，当我搜索 `all` 时，我得到三个节点：`you`、`the`
    和 `along`。如果搜索 `love`，我得到 `me` 和 `is`。
- en: A string trie is commonly used for creating search suggestions. Here we will
    implement a string trie using `std::map` for the trie structure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 trie 通常用于创建搜索建议。在这里，我们将使用 `std::map` 来实现字符串 trie 的结构。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In this recipe, we create a recursive `trie` class that stores nodes in a `std::map`
    container. It's a simple solution for a small in-memory trie. This is a rather
    large class, so we'll only show the important parts here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个递归 `trie` 类，它在一个 `std::map` 容器中存储节点。这是一个针对小内存 trie 的简单解决方案。这是一个相当大的类，所以我们只在这里展示重要的部分。
- en: For the full class, please see the source code at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的类，请参阅源代码 [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp)。
- en: 'We have one convenience alias:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个便利别名：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use `ilcstr` in for searching the `trie`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在搜索 `trie` 时使用 `ilcstr`。
- en: 'We''ll put this class in a private namespace to avoid collisions:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把这个类放在一个私有命名空间中，以避免冲突：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have a few `using` statements in this namespace for convenience.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命名空间中，我们为了方便起见有一些 `using` 语句。
- en: 'The class itself is called `trie`. It has three data members:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类本身被称为 `trie`。它有三个数据成员：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `trie` class has a few local type aliases:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`trie` 类有几个局部类型别名：'
- en: '`get_t` is a `deque` of `deque` of `string`, used for string results.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_t` 是一个 `deque` 的 `deque` 的 `string`，用于字符串结果。'
- en: '`nodes_t` is a map of `trie` classes with `string` keys.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodes_t` 是一个以 `string` 为键的 `trie` 类的映射。'
- en: '`result_t` is an `optional` of a pointer to a `trie`, for returning search
    results. An empty `trie` is a valid result, so we use an `optional` value.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result_t` 是一个指向 `trie` 的指针的 `optional`，用于返回搜索结果。一个空的 `trie` 是一个有效的结果，所以我们使用
    `optional` 值。'
- en: The `nodes` object is used for holding a recursive `map` of nodes, where each
    node on a `trie` is another `trie`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodes` 对象用于存储节点的递归 `map`，其中 `trie` 上的每个节点都是另一个 `trie`。'
- en: 'The public interface often calls utility functions in the private interface.
    For example, the `insert()` method takes an `initializer_list` object and calls
    the private function `_insert()`:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共接口经常调用私有接口中的实用函数。例如，`insert()` 方法接受一个 `initializer_list` 对象并调用私有函数 `_insert()`：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The private `_insert()` function does the work of inserting elements:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的 `_insert()` 函数执行插入元素的工作：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This facilitates the recursive function calls necessary to navigate the `trie`.
    Note that referencing a key that does not appear in a `map` creates an empty element
    with that key. So, the line that calls `_insert()` on a `nodes` element creates
    an empty `trie` object if the element doesn't already exist.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这便于进行必要的递归函数调用以导航 `trie`。注意，引用 `map` 中未出现的关键字会创建一个具有该键的空元素。因此，在 `nodes` 元素上调用
    `_insert()` 的行，如果该元素不存在，将创建一个空的 `trie` 对象。
- en: 'The `get()` method returns a `get_t` object, which is an alias for a `deque`
    of `deque` of `string`. This allows us to return multiple sets of results:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()` 方法返回一个 `get_t` 对象，它是 `deque` 的 `deque` 的 `string` 的别称。这允许我们返回多组结果：'
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `get()` method calls the private `_get()` function, which recursively traverses
    the `trie`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 方法调用私有的 `_get()` 函数，该函数递归遍历 `trie`：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `find_prefix()` function returns a `deque` with all matches to a partial
    string.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_prefix()` 函数返回一个包含所有与部分字符串匹配的 `deque`。'
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The public interface calls the private function `_find_prefix()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 公共接口调用私有函数 `_find_prefix()`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The private `_find_prefix()` function traverses the `trie` recursively, comparing
    the prefix with beginning of each key. The `starts_with()` method is new with
    C++20\. With an older STL, you could use the `find()` method and check the return
    value for `0`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的 `_find_prefix()` 函数递归遍历 `trie`，将前缀与每个键的开头进行比较。`starts_with()` 方法是 C++20
    中的新功能。在较旧的 STL 中，您可以使用 `find()` 方法并检查返回值是否为 `0`：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `search()` function returns an `optional<const trie*>`, aliased as `result_t`.
    It has two overloads:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()` 函数返回一个 `optional<const trie*>`，别名为 `result_t`。它有两个重载版本：'
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These methods pass iterators to the private member function `_search()`, which
    does the work of the search:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法将迭代器传递给私有成员函数 `_search()`，该函数执行搜索工作：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `_search()` function searches recursively until it finds a match, then returns
    a node in the `result_t` object. If it finds no match, it returns the non-value
    `optional`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`_search()` 函数递归搜索，直到找到匹配项，然后返回 `result_t` 对象中的一个节点。如果没有找到匹配项，它返回非值 `optional`。'
- en: 'We also have two overloads of a `print_trie_prefix()` function. This function
    prints the contents of a `trie` from a prefix, used as a search key. One version
    uses a `string` for the prefix, the other uses an `initializer_list` of C-strings:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有两个重载版本的 `print_trie_prefix()` 函数。此函数从用作搜索键的前缀打印 `trie` 的内容。一个版本使用 `string`
    作为前缀，另一个使用 C-字符串的 `initializer_list`：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These functions call the `get()` member function to retrieve the results from
    the `trie`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数调用 `get()` 成员函数从 `trie` 中检索结果。
- en: 'Now we can test the `trie` class in the `main()` function. First, we declare
    a `trie` and insert some sentences:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `main()` 函数中测试 `trie` 类。首先，我们声明一个 `trie` 并插入一些句子：
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `insert()` calls pass an `initializer_list` with all the strings of a sentence.
    Each of the strings of a sentence are inserted into the hierarchy of the `trie`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 调用传递一个包含句子中所有字符串的 `initializer_list`。句子中的每个字符串都插入到 `trie` 的层次结构中。'
- en: Now we can search the trie. Here's a simple search for the single string `"love"`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以搜索 `trie`。这里是一个简单的搜索，搜索单个字符串 `"love"`。
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This calls `ts.search()` with an `initializer_list` of one C-string, called
    `prefix`. The result, along with the `prefix`, is then passed to the `print_trie_prefix()`
    function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `ts.search()` 与一个包含一个 C-字符串的 `initializer_list`（称为 `prefix`）一起调用。然后，将结果以及
    `prefix` 传递给 `print_trie_prefix()` 函数。
- en: 'The output is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s a search for a two-string prefix:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个搜索两个字符串前缀的例子：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here''s a search for a partial prefix, using the `find_prefix()` function:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个使用 `find_prefix()` 函数搜索部分前缀的例子：
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `find_prefix()` search returned several results, each of which we passed
    to a search of its own, resulting in several results for each result.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_prefix()` 搜索返回了几个结果，我们将每个结果传递给其自己的搜索，从而为每个结果产生了多个结果。'
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The data for the `trie` class is stored in recursive `map` containers. Each
    node in the `map` contains another `trie` object, which in turn has its own `map`
    node.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`trie` 类的数据存储在递归的 `map` 容器中。`map` 中的每个节点都包含另一个 `trie` 对象，该对象反过来又有一个自己的 `map`
    节点。'
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `_insert()` function takes `begin` and `end` iterators, and uses them to
    recursively call `_insert()` on new nodes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Likewise, the `_search()` function recursively calls `_search()` on the nodes
    it finds:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This recursive approach using `std::map` allows us to implement a trie class
    concisely and efficiently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the error sum of two vectors
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given two similar vectors that differ only by quantization or resolution, we
    can use the `inner_product()` algorithm to calculate an *error sum*, defined as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Error sum definition'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_11_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Error sum definition
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Where *e* is the error sum, the sum of the square of the difference between
    a series of points in two vectors.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `inner_product()` algorithm, from the `<numeric>` header, to
    calculate the error sum between two vectors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we define two vectors, each with a *sine wave*. One `vector`
    has values of type `double` and the other has type `int`. This gives us vectors
    that differ in quantization, because the `int` type cannot represent fractional
    values. We then use `inner_product()` to calculate the error sum between the two
    vectors:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function we define our vectors and a handy `index` variable:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`ds` is the `vector` of `double` sine waves and `is` is the `vector` of `int`
    sine waves. Each `vector` has 100 elements to hold a sine wave. The `index` variable
    is used to initialize the `vector` objects.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate the sine wave in the `vector` of `double`, using a loop and a lambda:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The lambda captures a reference to the `index` variable so it can be incremented.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The `pi` constant is from the `std::numbers` library.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a `double` sine wave and we can use it to derive the `int` version:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This takes each point from `ds`, rounds it, casts it to an `int`, and updates
    it in position in the `is` container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'We display our sine waves with a simple loop:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our output is the sine waves as data points in the two containers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we calculate the error sum using `inner_product()`:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The lambda expression returns the (*a*i – *b*i)2 part of the formula. The `std::plus()`
    algorithm performs the sum operation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `inner_product()` algorithm computes a sum of products on the first input
    range. Its signature is:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The function takes two binary operator functors, `op1` and `op2`. The first
    `op1` is for the *sum* and the second `op2` is for the *product*. We use `std::plus()`
    as the sum operator, and a lambda as the product operator.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The `init` parameter can be used as a starting value or bias. We pass it the
    literal value, `0.0`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The return value is the accumulated sum of the products.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can calculate an accumulated error sum by putting `inner_product()` in a
    loop:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This may be useful in some statistical applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Build your own algorithm: split'
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL has a rich `algorithm` library. Yet, on occasion you may find it missing
    something you need. One common need is a `split` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'A `split` function splits a string on a character separator. For example, here''s
    a Unix `/etc/passwd` file from a standard Debian installation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `split` 函数在字符分隔符上拆分字符串。例如，这是一个来自标准 Debian 安装的 Unix `/etc/passwd` 文件：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Each field is separated by a colon `:` character, where the fields are:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段由冒号 `:` 字符分隔，字段包括：
- en: Login name
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录名
- en: Optional encrypted password
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选加密密码
- en: User ID
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户ID
- en: Group ID
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组ID
- en: Username or comment
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户名或注释
- en: Home directory
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主目录
- en: Optional command interpreter
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选命令解释器
- en: This is a standard file in POSIX-based operating systems, and there are others
    like it. Most scripting languages include a built-in function for splitting a
    string on a separator. There are simple ways to do this in C++. Still, `std::string`
    is just another container in the STL, and a generic algorithm that splits a container
    on a separator could be a useful addition to the toolbox. So, let's build one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于 POSIX 的操作系统中的标准文件，还有其他类似文件。大多数脚本语言都包含一个用于在分隔符上拆分字符串的内置函数。在 C++ 中有简单的方法来做这件事，尽管
    `std::string` 只是 STL 中的另一个容器，一个在分隔符上拆分容器的通用算法可以作为工具箱中的一个有用的补充。所以，让我们构建一个。
- en: How to do it…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In this recipe, we build a generic algorithm that splits a container on a separator
    and puts the results in a target container.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们构建了一个通用算法，该算法在分隔符上拆分容器并将结果放入目标容器中。
- en: 'Our algorithm is in the `bw` namespace, to avoid collisions with `std`:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们算法位于 `bw` 命名空间中，以避免与 `std` 冲突：
- en: '[PRE34]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `split()` algorithm searches a container for separators and collects the
    separated slices into a new output container, where each slice is a container
    within the output container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 算法在容器中搜索分隔符，并将分离的片段收集到一个新的输出容器中，其中每个片段都是输出容器内的容器。'
- en: We want the `split()` algorithm to be as generic as possible, just like those
    in the `algorithm` library. This means that all the parameters are templated,
    and the code will work with a comprehensive variety of parameter types.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `split()` 算法尽可能通用，就像 `algorithm` 库中的那些一样。这意味着所有参数都是模板化的，代码将能够与各种参数类型一起工作。
- en: 'First, let''s look at the template parameters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看模板参数：
- en: '`It` is the input iterator type for the source container.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`It` 是源容器的输入迭代器类型。'
- en: '`Oc` is the output container type. This is a container of containers.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Oc` 是输出容器类型。这是一个容器容器。'
- en: '`V` is the separator type.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V` 是分隔符类型。'
- en: '`Pred` is for the predicate functor.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pred` 用于谓词函数。'
- en: Our output type is a container of containers. It needs to hold containers of
    slices. It could be `vector<string>`, where the string values are slices, or `vector<vector<int>>`,
    where the inner `vector<int>` contains the slices. This means we need to derive
    the type of the inner container from the output container type. We do that with
    the `using` declaration in the body of the function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出类型是一个容器容器。它需要容纳切片容器。它可以是 `vector<string>`，其中字符串值是切片，或者 `vector<vector<int>>`，其中内层的
    `vector<int>` 包含切片。这意味着我们需要从输出容器类型派生出内部容器的类型。我们通过函数体内的 `using` 声明来实现这一点。
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is also why we cannot use an output iterator for the output parameter.
    By definition, an output iterator cannot determine the type of its contents and
    its `value_type` is set to `void`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我们不能使用输出迭代器作为输出参数的原因。根据定义，输出迭代器无法确定其内容的类型，其 `value_type` 被设置为 `void`。
- en: 'We use `SliceContainer` to define a temporary container that is added to the
    output container with the statement:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `SliceContainer` 定义一个临时容器，该容器通过语句添加到输出容器中：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The predicate is a binary operator that compares an input element with the
    separator. We include a default equality operator in the `bw` namespace:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谓词是一个二元运算符，它比较输入元素与分隔符。我们在 `bw` 命名空间中包含了一个默认的相等运算符：
- en: '[PRE37]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also include a specialization of `split()` that uses the `eq` operator by
    default:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还包括一个使用默认 `eq` 操作符的 `split()` 特殊化：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because splitting `string` objects is a common use case for this algorithm,
    we include a helper function for that specific purpose:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为拆分 `string` 对象是这个算法的常见用例，所以我们包括一个用于该特定目的的辅助函数：
- en: '[PRE39]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We test our split algorithm `main()`, starting with a `string` object:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过 `main()` 函数测试我们的拆分算法，从一个 `string` 对象开始：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We use a string from the `/etc/passwd` file to test our algorithm, with this
    result:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `/etc/passwd` 文件中的字符串来测试我们的算法，得到以下结果：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It''s even simpler using our `strsplit()` helper function:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的 `strsplit()` 辅助函数甚至更简单：
- en: '[PRE42]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This would make it easy to parse the `/etc/passwd` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使解析 `/etc/passwd` 文件变得容易。
- en: 'Of course, we can use the same algorithm with any container:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，我们可以使用相同的算法来处理任何容器：
- en: '[PRE44]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The split algorithm itself is relatively simple. The magic in this recipe is
    in the use of templates to make it as generic as possible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 分割算法本身相对简单。这个菜谱中的魔法在于使用模板使其尽可能通用。
- en: 'The derived type in the `using` declaration allows us to create a container
    for use with the output container:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 声明中定义的派生类型允许我们创建一个用于输出容器的容器：'
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This gives us a `SliceContainer` type that we can use to create a container
    for the slices:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个 `SliceContainer` 类型，我们可以用它来创建切片的容器：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is a temporary container that is added to the output container for each
    slice:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个临时容器，它被添加到输出容器中的每个切片：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Leverage existing algorithms: gather'
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用现有算法：聚集
- en: '`gather()` is an example of an algorithm that leverages existing algorithms.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather()` 是利用现有算法的算法示例。'
- en: The `gather()` algorithm takes a pair of container iterators and moves the elements
    that satisfy a predicate toward a *pivot* position within the sequence, returning
    a `pair` of iterators that contains the elements that satisfy the predicate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather()` 算法接受一对容器迭代器，并将满足谓词的元素移动到序列中的枢轴位置，返回一个包含满足谓词的元素的迭代器对。'
- en: 'For example, we could use a `gather` algorithm to sort all the even numbers
    to the mid-point of a `vector`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 `gather` 算法将所有偶数排序到 `vector` 的中点：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our output is:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出的是：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that the even numbers are all in the middle of the output.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有的偶数都位于输出的中间。
- en: In this recipe, we will implement a `gather` algorithm using standard STL algorithms.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用标准 STL 算法实现一个 `gather` 算法。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Our `gather` algorithm uses the `std::stable_partition()` algorithm to move
    items before the pivot iterator and again to move items past the pivot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `gather` 算法使用 `std::stable_partition()` 算法将元素移动到枢轴迭代器之前，然后再移动到枢轴之后。
- en: We put the algorithm in the `bw` namespace to avoid collisions.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将算法放在 `bw` 命名空间中，以避免冲突。
- en: '[PRE51]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `gather()` algorithm returns a `pair` of iterators, returned from two calls
    to `stable_partition()`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather()` 算法返回一个迭代器对，这是从两次调用 `stable_partition()` 返回的。'
- en: 'We also include some helper lambdas:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还包含了一些辅助的 lambda 表达式：
- en: '[PRE52]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'These three lambdas are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个 lambda 表达式如下：
- en: '`midit` returns an iterator at the midpoint of a container, for use as a pivot
    point.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`midit` 返回一个在容器中点位置的迭代器，用作枢轴点。'
- en: '`is_even` returns Boolean `true` if the value is even, for use as a predicate.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_even` 如果值是偶数，则返回布尔值 `true`，用作谓词。'
- en: '`is_even_char` returns Boolean `true` if the value is a character between `''0''`
    and `''9''` and is even, for use as a predicate.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_even_char` 如果值是介于 `''0''` 和 `''9''` 之间的字符且为偶数，则返回布尔值 `true`，用作谓词。'
- en: 'We call `gather()` from the `main()` function with a vector of `int` like this:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从 `main()` 函数中调用 `gather()`，传递一个 `int` 类型的向量，如下所示：
- en: '[PRE53]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our output shows that the even numbers have been gathered in the middle:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出显示偶数已经被聚集在中间：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `gather()` function returns a `pair` of iterators that contain just the
    even values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather()` 函数返回一个包含仅偶数值的迭代器对：'
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can set the pivot point to the `begin()` or `end()` iterators:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将枢轴点设置为 `begin()` 或 `end()` 迭代器：
- en: '[PRE57]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Because `gather()` is iterator-based, we can use it with any container. Here''s
    a string of character digits:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `gather()` 是基于迭代器的，所以我们可以用它与任何容器一起使用。这里是一个字符数字的字符串：
- en: '[PRE59]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This moves all the even digits to the end of the string:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将所有偶数位移动到字符串的末尾：
- en: 'Output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `gather()` function uses the `std::stable_partition()` algorithm to move
    the elements that match the predicate to the pivot point.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather()` 函数使用 `std::stable_partition()` 算法将匹配谓词的元素移动到枢轴点。'
- en: '`gather()` has two calls to `stable_partition()`, one with the predicate, and
    one with the predicate negated:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather()` 函数调用了两次 `stable_partition()`，一次是使用谓词，另一次是使用否定谓词：'
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The iterators returned from the two `stable_partition()` calls are returned
    in the `pair`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个 `stable_partition()` 调用返回的迭代器在 `pair` 中返回。
- en: Remove consecutive whitespace
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除连续空白
- en: When receiving input from users, it's common to end up with excessive consecutive
    whitespace characters in your strings. This recipe presents a function for removing
    consecutive spaces, even when it includes tabs or other whitespace characters.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当从用户接收输入时，字符串中经常会有过多的连续空白字符。这个菜谱提供了一个用于删除连续空格的函数，即使它包括制表符或其他空白字符。
- en: How to do it…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: This function leverages the `std::unique()` algorithm to remove consecutive
    whitespace characters from a string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数利用 `std::unique()` 算法从字符串中移除连续的空白字符。
- en: 'In the `bw` namespace, we start with a function to detect whitespace:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `bw` 命名空间中，我们从一个检测空白的函数开始：
- en: '[PRE62]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This templated `isws()` function should work with any character type.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板化的 `isws()` 函数应该可以与任何字符类型一起工作。
- en: 'The `delws()` function uses `std::unique()` to erase consecutive whitespace
    in a `string`:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delws()` 函数使用 `std::unique()` 来擦除字符串中的连续空白字符：'
- en: '[PRE63]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`delws()` makes a copy of the input string, removes consecutive whitespace,
    and returns the new string.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`delws()` 函数会复制输入的字符串，移除连续的空白字符，并返回新的字符串。'
- en: 'We call it with a `string` from `main()`:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `main()` 中使用一个 `string` 来调用它：
- en: '[PRE64]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This function uses the `std::unique()` algorithm with a comparison lambda to
    find consecutive whitespace in a `string` object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用 `std::unique()` 算法和比较 lambda 表达式来在一个 `string` 对象中找到连续的空白字符。
- en: 'The comparison lambda calls our own `isws()` function to determine if we have
    found consecutive whitespace:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 lambda 调用我们自己的 `isws()` 函数来确定我们是否找到了连续的空白字符：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We could use the `isspace()` function from the standard library, but it's a
    standard C function that depends on a narrowing type conversion from `int` to
    `char`. This may issue warnings on some modern C++ compilers and is not guaranteed
    to work without an explicit cast. Our `isws()` function uses a templated type
    and should work on any system, and with any specialization of `std::string`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准库中的 `isspace()` 函数，但它是一个依赖于从 `int` 到 `char` 的类型缩窄转换的标准 C 函数。这可能在某些现代
    C++ 编译器上引发警告，并且不能保证在没有显式转换的情况下工作。我们的 `isws()` 函数使用模板类型，应该可以在任何系统上工作，并且与任何 `std::string`
    的特化一起工作。
- en: Convert numbers to words
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字转换为文字
- en: Over the course of my career, I've used a lot of programming languages. When
    learning a new language, I like to have a project to work on that exposes me to
    the nuances of the language. The `numwords` class is one of my favorite exercises
    for this purpose. I have written it in dozens of languages over the years, including
    several times in C and C++.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我使用过很多编程语言。在学习一门新语言时，我喜欢有一个项目来工作，这样我可以接触到语言的细微差别。`numwords` 类是我最喜欢的这种用途的练习之一。多年来，我曾在数十种语言中编写过它，包括几次在
    C 和 C++ 中。
- en: '`numwords` is a class that spells out a number in words. It can be useful for
    banking and accounting applications. It looks like this in use:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`numwords` 是一个将数字转换为文字的类。它在应用中的样子如下：'
- en: '[PRE67]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How to do it…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This recipe originated as an exercise in creating production-ready code. For
    that reason, it''s in three different files:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱最初是作为一个创建生产就绪代码的练习而出现的。因此，它分布在三个不同的文件中：
- en: '`numword.h` is the header/interface file for the `numwords` class.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numword.h` 是 `numwords` 类的头文件/接口文件。'
- en: '`numword.cpp` is the implementation file for the `numwords` class.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numword.cpp` 是 `numwords` 类的实现文件。'
- en: '`numword-test.cpp` is the application file for testing the `numword` class.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numword-test.cpp` 是用于测试 `numword` 类的应用程序文件。'
- en: The class itself is about 180 lines of code so we'll just cover the highlights
    here. You can find the full source code at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 类本身大约有 180 行代码，所以我们只概述一下亮点。你可以在 [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword)
    找到完整的源代码。
- en: 'In the `numword.h` file, we put the class in the `bw` namespace and start with
    some `using` statements:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `numword.h` 文件中，我们将类放在 `bw` 命名空间中，并开始使用一些 `using` 语句：
- en: '[PRE69]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We use `string` and `string_view` objects throughout the code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用了 `string` 和 `string_view` 对象。
- en: '`uint64_t` is our primary integer type because it will hold very large numbers.
    Because the class is called `numword`, I like `numnum` for the integer type.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint64_t` 是我们的主要整数类型，因为它可以存储非常大的数字。由于类名为 `numword`，我喜欢 `numnum` 作为整数类型。'
- en: '`_bufstr` is the main output buffer. It''s a `string` wrapped in a `unique_ptr`,
    which handles the memory management for automatic RAII compliance.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`_bufstr` 是主要输出缓冲区。它是一个 `string`，被 `unique_ptr` 包装，这处理了内存管理以实现自动 RAII 兼容。'
- en: 'We also have a few constants for various purposes:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一些用于各种目的的常量：
- en: '[PRE70]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `maxnum` constant translates to "nine hundred ninety-nine quadrillion nine
    hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine
    million nine hundred ninety-nine thousand nine hundred ninety-nine," which should
    be sufficient for most purposes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxnum` 常数翻译为 "九百九十九兆九百九十九万亿九百九十九亿九百九十九千万九百九十九"，对于大多数用途来说应该足够了。'
- en: The rest of the `numnum` constants are used to avoid literals in the code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的 `numnum` 常数用于避免代码中的字面量。
- en: 'The main data structures are `constexpr` arrays of `string_view` objects, representing
    the words used in the output. The `string_view` class is perfect for these constants,
    as it provides encapsulation with minimum overhead:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要数据结构是 `constexpr` 数组，包含 `string_view` 对象，代表输出中使用的单词。`string_view` 类对于这些常量来说非常完美，因为它提供了最小开销的封装：
- en: '[PRE71]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The words are grouped into sections, useful in translating numbers to words.
    Many languages use a similar breakdown so this structure should translate easily
    to those languages.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 单词被分组到各个部分，这对于将数字转换为单词很有用。许多语言使用类似的分解，因此这种结构应该很容易翻译到那些语言。
- en: 'The `numword` class has a few private members:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numword` 类有几个私有成员：'
- en: '[PRE72]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`_buf` is the output string buffer. Its memory is managed by a `unique_ptr`.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_buf` 是输出字符串缓冲区。其内存由 `unique_ptr` 管理。'
- en: '`_num` holds the current numeric value.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_num` 保存当前的数值。'
- en: '`_hyphen_flag` is used during the translation process to insert a hyphen between
    words, rather than a space character.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_hyphen_flag` 在翻译过程中用于在单词之间插入连字符，而不是空格字符。'
- en: These private methods are used to manipulate the output buffer.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些私有方法用于操作输出缓冲区。
- en: '[PRE73]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'There is also a `pow_i()` private method used to calculate *x*y with `numnum`
    types:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于计算 `numnum` 类型中 *x*y 的私有方法 `pow_i()`：
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`pow_i()` is used to discriminate parts of the numeric value for word output.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow_i()` 用于区分数字值的部分以进行单词输出。'
- en: 'The public interface includes constructors and various ways to call the `words()`
    method, which does the work of translating a `numnum` to a `string` of words:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共接口包括构造函数和调用 `words()` 方法的各种方式，该方法是翻译 `numnum` 到单词字符串的工作：
- en: '[PRE75]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the implementation file, `numword.cpp`, the bulk of the work is handled
    in the `words()` member function:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现文件 `numword.cpp` 中，大部分工作是在 `words()` 成员函数中处理的：
- en: '[PRE76]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Each part of the function peels off part of the number with a *modulus of a
    power of ten*, recursively in the case of the thousands, and appends strings from
    the `string_view` constant arrays.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的每个部分都递归地使用十的幂的模数剥离数字的一部分，并在千位的情况下追加来自 `string_view` 常量数组的字符串。
- en: 'There are three overloads of `appendbuf()`. One appends a `string`:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendbuf()` 有三个重载。一个添加一个 `string`：'
- en: '[PRE77]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Another appends a `string_view`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个添加一个 `string_view`：
- en: '[PRE78]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And the third appends a single character:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个添加单个字符：
- en: '[PRE79]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `appendspace()` method appends a space character or a hyphen, depending
    on the context:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendspace()` 方法根据上下文添加空格字符或连字符：'
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `numword-test.cpp` file is the testing environment for `bw::numword`. It
    includes a `formatter` specialization:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numword-test.cpp` 文件是 `bw::numword` 的测试环境。它包括一个 `formatter` 特化：'
- en: '[PRE81]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This allows us to pass a `bw::numword` object directly to `format()`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们直接将 `bw::numword` 对象传递给 `format()`。
- en: 'There''s also a `print()` function that sends `formatter` output directly to
    `stdout`, bypassing `cout` and the `iostream` library entirely:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个 `print()` 函数，它将 `formatter` 输出直接发送到 `stdout`，完全绕过 `cout` 和 `iostream`
    库：
- en: '[PRE82]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This allows us to use `print("{}\n", nw)` instead of piping `format()` through
    `cout`. A function like this will be included in the C++23 standard. It's simple
    enough to include it like this for now.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用 `print("{}\n", nw)` 而不是通过 `cout` 管道 `format()`。这样的函数将被包含在 C++23 标准。现在可以像这样简单地包含它。
- en: 'In `main()`, we declare a `bw::numword` object and a `uint64_t` for use in
    testing:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 中，我们声明一个 `bw::numword` 对象和一个 `uint64_t` 用于测试：
- en: '[PRE83]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `numword` object is initialized to zero, giving us this output from our
    `print()` statement:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`numword` 对象初始化为零，这使得我们的 `print()` 语句产生以下输出：'
- en: '[PRE84]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We test a variety of ways to call `numword`:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试了调用 `numword` 的各种方式：
- en: '[PRE85]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE86]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This class is significantly driven by the data structures. By organizing `string_view`
    objects into arrays, we can easily translate scalar values into corresponding
    words:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在很大程度上是由数据结构驱动的。通过将 `string_view` 对象组织成数组，我们可以轻松地将标量值转换为相应的单词：
- en: '[PRE87]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The rest of it is mostly the math:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分主要是数学：
- en: '[PRE88]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: There's more…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'I also have a utility that uses the `numwords` class to tell time in words.
    Its output looks like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我还有一个使用 `numwords` 类来用文字报时的实用工具。它的输出看起来像这样：
- en: '[PRE89]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In test mode, it gives this output:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试模式下，它给出以下输出：
- en: '[PRE90]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: I leave its implementation as an exercise for the reader.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其实现留给读者作为练习。
