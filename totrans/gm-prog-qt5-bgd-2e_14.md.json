["```cpp\nWindow {\n    //...\n    Flickable {\n        id: uiFlickable\n        anchors.centerIn: parent\n        contentWidth: ui.width\n        contentHeight: ui.height\n\n        width: parent.width >= contentWidth ?\n               contentWidth : parent.width\n        height: parent.height >= contentHeight ?\n                contentHeight : parent.height\n\n        UI {\n            id: ui\n        }\n    }\n}\n```", "```cpp\nimport QtQuick 2.0\nRectangle {\n    width: 300\n    height: 300\n    gradient: Gradient {\n        GradientStop { position: 0.0; color: \"lightsteelblue\" }\n        GradientStop { position: 1.0; color: \"blue\" }\n    }\n}\n```", "```cpp\nWindow {\n    //...\n    UI {\n        id: ui\n        anchors.centerIn: parent\n        scale: Math.min(parent.width / width,\n                        parent.height / height)\n    }\n}\n```", "```cpp\nWindow {\n    //...\n    Item {\n anchors {\n fill: parent\n margins: 10\n }\n        UI {\n            id: ui\n            anchors.centerIn: parent\n            scale: Math.min(parent.width / width,\n                            parent.height / height)\n        }\n }\n}\n```", "```cpp\nimport QtQuick 2.9\nimport QtQuick.Window 2.2\nimport QtGraphicalEffects 1.0\n\nWindow {\n    //...\n    HeartBeat {\n        id: heartBeat\n        anchors.centerIn: parent\n        visible: false\n    }\n    DropShadow {\n        source: heartBeat\n        anchors.fill: heartBeat\n        horizontalOffset: 3\n        verticalOffset: 3\n        radius: 8\n        samples: 16\n        color: \"black\"\n    }\n}\n```", "```cpp\nGaussianBlur {\n    source: heartBeat\n    anchors.fill: heartBeat\n    radius: 12\n    samples: 20\n    transparentBorder: true\n}\n```", "```cpp\nWindow {\n    //...\n    Badge {\n        id: importantBadge\n        anchors.centerIn: parent\n    }\n    Glow {\n        source: importantBadge\n        anchors.fill: source\n        samples: 64\n        color: \"red\"\n\n        SequentialAnimation on radius {\n            loops: Animation.Infinite\n            running: true\n\n            NumberAnimation { from: 0; to: 30; duration: 500 }\n            PauseAnimation { duration: 100 }\n            NumberAnimation { from: 30; to: 0; duration: 500 }\n            PauseAnimation { duration: 1000 }\n        }\n    }\n}\n```", "```cpp\nimport QtQuick 2.0\nimport QtQuick.Window 2.2\nimport QtQuick.Particles 2.0\n\nWindow {\n    visible: true\n    width: 360\n    height: 360\n    title: qsTr(\"Particle system\")\n\n    ParticleSystem {\n        id: particleSystem\n        anchors.fill: parent\n\n        Emitter { anchors.fill: parent }\n        ImageParticle { source: \"star.png\" }\n    }\n}\n```", "```cpp\nEmitter {\n    anchors.fill: parent\n    emitRate: 350\n    lifeSpan: 1500\n    lifeSpanVariation: 400 // effective: 1100-1900 ms\n} \n```", "```cpp\nEmitter {\n    anchors.fill: parent\n    emitRate: 50\n    size: 12\n    sizeVariation: 6\n    endSize: 2\n}\n```", "```cpp\nEmitter {\n    anchors.fill: parent\n    emitRate: 1600\n    shape: MaskShape { source: \"star.png\" }\n}\n```", "```cpp\nImageParticle {\n    source: \"star_white.png\"\n    colorVariation: 1\n}\n```", "```cpp\nEmitter {\n    anchors.centerIn: parent\n    width: 50; height: 50\n    emitRate: 50\n\n    velocity: AngleDirection {\n        angleVariation: 45\n        angle: 180\n        magnitude: 200\n    }\n}\n```", "```cpp\nEmitter {\n    anchors.right: parent.right\n    anchors.verticalCenter: parent.verticalCenter\n    emitRate: 15\n    lifeSpan: 5000\n\n    velocity: AngleDirection {\n        angle: 180\n        magnitude: 200\n    }\n    acceleration: AngleDirection {\n        angle: 90 // local left = global down\n        magnitude: 100\n    }\n}\n```", "```cpp\nItem {\n    Image {\n        id: image\n        source: \"rocket.png\"\n    }\n    Emitter {\n        anchors.right: image.right\n        anchors.verticalCenter: image.verticalCenter\n        emitRate: 500\n        lifeSpan: 3000\n        lifeSpanVariation: 1000\n        velocityFromMovement: -20\n\n        velocity: AngleDirection {\n            magnitude: 100\n            angleVariation: 40\n        }\n    }\n    NumberAnimation on x {\n        ...\n    }\n}\n```", "```cpp\nAge { \n    once: true \n    lifeLeft: 500 \n    shape: EllipseShape { fill: true }\n    anchors.fill: parent \n}\n```", "```cpp\nParticleSystem {\n    id: coinParticles\n    anchors.fill: parent // scene is the parent\n\n    ImageParticle {\n        source: \"images/particle.png\"\n        colorVariation: 1\n        rotationVariation: 180\n        rotationVelocityVariation: 10\n    }\n} \n```", "```cpp\nEmitter {\n    id: emitter\n    system: coinParticles\n    emitRate: 0\n    lifeSpan: 1500\n    lifeSpanVariation: 100\n    velocity: AngleDirection {\n        angleVariation: 180\n        magnitude: 10\n    }\n    acceleration: AngleDirection {\n        angle: 270\n        magnitude: 30\n    }\n}\n```", "```cpp\nfunction hit() {\n    emitter.burst(50);\n    hitAnim.start();\n} \n```", "```cpp\nclass RegularPolygon : public QQuickItem\n{\n    Q_OBJECT\n    Q_PROPERTY(int vertices READ vertices WRITE setVertices \n               NOTIFY verticesChanged)\n    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)\npublic:\n    RegularPolygon();\n    ~RegularPolygon();\n    int vertices() const;\n    void setVertices(int v);\n\n    QColor color() const;\n    void setColor(const QColor &c);\n\n    QSGNode *updatePaintNode(QSGNode *, UpdatePaintNodeData *);\n\nsignals:\n    void verticesChanged(int);\n    void colorChanged(QColor);\n\nprivate:\n     int m_vertexCount;\n     QColor m_color;\n};\n```", "```cpp\nRegularPolygon::RegularPolygon()\n{\n    setFlag(ItemHasContents, true);\n    m_vertexCount = 6;\n}\n```", "```cpp\nvoid RegularPolygon::setVertices(int v) {\n    v = qMax(3, v);\n    if(v == vertices()) return;\n    m_vertexCount = v;\n    emit verticesChanged(v);\n    update();\n}\n\nvoid RegularPolygon::setColor(const QColor &c) {\n    if(color() == c) return;\n    m_color = c;\n    emit colorChanged(c);\n    update();\n}\n```", "```cpp\nQSGNode *RegularPolygon::updatePaintNode(\n    QSGNode *oldNode, QQuickItem::UpdatePaintNodeData *) { \n```", "```cpp\n  QSGGeometryNode *node = nullptr;\n  QSGGeometry *geometry = nullptr;\n```", "```cpp\n    if (!oldNode) {\n        node = new QSGGeometryNode;\n        geometry = new QSGGeometry(\n            QSGGeometry::defaultAttributes_Point2D(), m_vertexCount + 2);\n        geometry->setDrawingMode(GL_TRIANGLE_FAN);\n        node->setGeometry(geometry);\n        node->setFlag(QSGNode::OwnsGeometry);\n```", "```cpp\n        QSGFlatColorMaterial *material = new QSGFlatColorMaterial;\n        material->setColor(m_color);\n        node->setMaterial(material);\n        node->setFlag(QSGNode::OwnsMaterial);\n```", "```cpp\n    } else {\n        node = static_cast<QSGGeometryNode *>(oldNode);\n        geometry = node->geometry();\n        geometry->allocate(m_vertexCount + 2);\n    }\n```", "```cpp\n    QSGMaterial *material = node->material();\n    QSGFlatColorMaterial *flatMaterial =\n            static_cast<QSGFlatColorMaterial*>(material);\n    if(flatMaterial->color() != m_color) {\n        flatMaterial->setColor(m_color);\n        node->markDirty(QSGNode::DirtyMaterial);\n    }\n```", "```cpp\n    QRectF bounds = boundingRect();\n    QSGGeometry::Point2D *vertices = geometry->vertexDataAsPoint2D();\n\n    // first vertex is the shared one (middle)\n    QPointF center = bounds.center();\n\n    vertices[0].set(center.x(), center.y());\n\n    // vertices are distributed along circumference of a circle\n\n    qreal angleStep = 360.0 / m_vertexCount;\n\n    qreal radius = qMin(width(), height()) / 2;\n\n    for (int i = 0; i < m_vertexCount; ++i) {\n        qreal rads = angleStep * i * M_PI / 180;\n        qreal x = center.x() + radius * std::cos(rads);\n        qreal y = center.y() + radius * std::sin(rads);\n        vertices[1 + i].set(x, y);\n    }\n    vertices[1 + m_vertexCount] = vertices[1];\n```", "```cpp\n  node->markDirty(QSGNode::DirtyGeometry);\n  return node;\n} \n```", "```cpp\nWindow {\n    width: 600\n    height: 600\n    visible: true\n    RegularPolygon {\n        id: poly\n        anchors {\n            fill: parent\n            bottomMargin: 20\n        }\n        vertices: 5\n        color: \"blue\"\n    }\n}\n```", "```cpp\nint main(int argc, char **argv) {\n    QGuiApplication app(argc, argv);\n    QSurfaceFormat format = QSurfaceFormat::defaultFormat();\n format.setSamples(16); // enable multisampling\n QSurfaceFormat::setDefaultFormat(format);\n\n    qmlRegisterType<RegularPolygon>(\"RegularPolygon\", 1, 0, \"RegularPolygon\");\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n    if (engine.rootObjects().isEmpty())\n      return -1;\n    return app.exec();\n}\n```", "```cpp\nimport QtQuick 2.9\nimport QtQuick.Window 2.3\nimport OutlineTextItem 1.0\n\nWindow {\n    visible: true\n    width: 800\n    height: 400\n    title: qsTr(\"Hello World\")\n\n    Rectangle {\n        anchors.fill: parent\n        OutlineTextItem {\n            anchors.centerIn: parent\n            text: \"This is outlined text\"\n            fontFamily: \"Arial\"\n            fontPixelSize: 64\n            color: \"#33ff0000\"\n            antialiasing: true\n            border {\n                color: \"blue\"\n                width: 2\n                style: Qt.DotLine\n            }\n        }\n    }\n}\n```", "```cpp\nclass OutlineTextItemBorder : public QObject {\n    Q_OBJECT\n    Q_PROPERTY(int width MEMBER m_width NOTIFY widthChanged)\n    Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)\n    Q_PROPERTY(Qt::PenStyle style MEMBER m_style NOTIFY styleChanged)\npublic:\n    OutlineTextItemBorder(QObject *parent = 0);\n\n    int width() const;\n    QColor color() const;\n    Qt::PenStyle style() const;\n    QPen pen() const;\nsignals:\n    void widthChanged(int);\n    void colorChanged(QColor);\n    void styleChanged(int);\nprivate:\n    int m_width;\n    QColor m_color;\n    Qt::PenStyle m_style;\n};\n```", "```cpp\nQPen OutlineTextItemBorder::pen() const {\n    QPen p;\n    p.setColor(m_color);\n    p.setWidth(m_width);\n    p.setStyle(m_style);\n    return p;\n}\n```", "```cpp\nclass OutlineTextItem : public QQuickPaintedItem\n{\n    Q_OBJECT\n    Q_PROPERTY(QString text MEMBER m_text\n                            NOTIFY textChanged)\n    Q_PROPERTY(QColor color MEMBER m_color\n                            NOTIFY colorChanged)\n    Q_PROPERTY(OutlineTextItemBorder* border READ border\n                            NOTIFY borderChanged)\n    Q_PROPERTY(QString fontFamily MEMBER m_fontFamily\n                            NOTIFY fontFamilyChanged)\n    Q_PROPERTY(int fontPixelSize MEMBER m_fontPixelSize\n                            NOTIFY fontPixelSizeChanged)\npublic:\n    OutlineTextItem(QQuickItem *parent = 0);\n    void paint(QPainter *painter);\n    OutlineTextItemBorder* border() const;\n    QPainterPath shape(const QPainterPath &path) const;\nprivate slots:\n    void updateItem();\nsignals:\n    void textChanged(QString);\n    void colorChanged(QColor);\n    void borderChanged();\n    void fontFamilyChanged(QString);\n    void fontPixelSizeChanged(int);\nprivate:\n    OutlineTextItemBorder* m_border;\n    QPainterPath m_path;\n    QRectF m_boundingRect;\n    QString m_text;\n    QColor m_color;\n    QString m_fontFamily;\n    int m_fontPixelSize;\n};\n```", "```cpp\nOutlineTextItem::OutlineTextItem(QQuickItem *parent) : \n    QQuickPaintedItem(parent) \n{\n    m_border = new OutlineTextItemBorder(this);\n    connect(this, &OutlineTextItem::textChanged,\n            this, &OutlineTextItem::updateItem);\n    connect(this, &OutlineTextItem::colorChanged,\n            this, &OutlineTextItem::updateItem);\n    connect(this, &OutlineTextItem::fontFamilyChanged,\n            this, &OutlineTextItem::updateItem);\n    connect(this, &OutlineTextItem::fontPixelSizeChanged,\n            this, &OutlineTextItem::updateItem);\n    connect(m_border, &OutlineTextItemBorder::widthChanged,\n            this, &OutlineTextItem::updateItem);\n    connect(m_border, &OutlineTextItemBorder::colorChanged,\n            this, &OutlineTextItem::updateItem);\n    connect(m_border, &OutlineTextItemBorder::styleChanged,\n            this, &OutlineTextItem::updateItem);\n    updateItem();\n}\n```", "```cpp\nvoid OutlineTextItem::updateItem() {\n    QFont font(m_fontFamily, m_fontPixelSize);\n    m_path = QPainterPath();\n    m_path.addText(0, 0, font, m_text);\n    m_boundingRect = borderShape(m_path).controlPointRect();\n    setImplicitWidth(m_boundingRect.width());\n    setImplicitHeight(m_boundingRect.height());\n    update();\n}\n```", "```cpp\nQPainterPath OutlineTextItem::borderShape(const QPainterPath &path) const\n{\n    QPainterPathStroker pathStroker;\n    pathStroker.setWidth(m_border->width());\n    QPainterPath p = pathStroker.createStroke(path);\n    p.addPath(path);\n    return p;\n}\n```", "```cpp\nvoid OutlineTextItem::paint(QPainter *painter) {\n    if(m_text.isEmpty()) return;\n    painter->setPen(m_border->pen());\n    painter->setBrush(m_color);\n    painter->setRenderHint(QPainter::Antialiasing, true);\n    painter->translate(-m_boundingRect.topLeft());\n    painter->drawPath(m_path);\n}\n```", "```cpp\nqmlRegisterUncreatableType<OutlineTextItemBorder>(\n     \"OutlineTextItem\", 1, 0, \"OutlineTextItemBorder\", \"\");\nqmlRegisterType<OutlineTextItem>(\n     \"OutlineTextItem\", 1, 0, \"OutlineTextItem\");\n```"]