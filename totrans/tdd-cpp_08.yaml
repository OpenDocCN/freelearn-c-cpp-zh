- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: What Makes a Good Test?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是一个好的测试？
- en: A project developed with TDD will have a lot of tests. But don’t assume that
    more or longer tests are always better. You need to have good tests. But what
    makes a good test?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD开发的项目将有很多测试。但不要假设更多的或更长的测试总是更好的。你需要有好的测试。但什么是好的测试？
- en: We’re not going to be writing more code in this chapter. This chapter is more
    of a look back at some of the situations we’ve already encountered as well as
    referring to some tests in upcoming chapters. This is a chance to reflect on what
    you’ve learned so far and to look forward to upcoming topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个章节中不会编写更多的代码。这个章节更多的是回顾我们已经遇到的一些情况，以及参考即将到来的章节中的某些测试。这是一个反思你到目前为止所学内容并展望即将到来的主题的机会。
- en: 'A good test should incorporate the following elements:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试应该包含以下元素：
- en: Be easy to understand – a good understanding will lead to better ideas for more
    tests and make tests easier to maintain.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易理解——良好的理解将导致更多测试的更好想法，并使测试更容易维护。
- en: Be focused on a specific scenario – don’t try to test everything in one giant
    test. Doing too much in a test will break the first guidance of understandability.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于特定的场景——不要试图在一个巨大的测试中测试一切。在测试中做太多事情会破坏可理解性的第一条指导原则。
- en: Be repeatable – tests that use random behavior to sometimes catch problems can
    miss issues at the worst times.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复——使用随机行为来有时捕捉问题的测试可能在最糟糕的时候错过问题。
- en: Be kept close to the project – make sure that tests belong to the project they
    are testing.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持与项目紧密相关——确保测试属于它们正在测试的项目。
- en: Should test what should happen instead of how it happens – if a test relies
    too much on internal workings, then it will be brittle and cause more work when
    the code is refactored.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该测试应该发生的事情而不是如何发生的事情——如果一个测试过于依赖内部工作原理，那么它将是脆弱的，当代码重构时将造成更多的工作。
- en: Each of these topics will be explained in this chapter with examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将用示例解释这些主题。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter comes from other chapters in this book and is used
    here as example code to reinforce ideas that make good tests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都来自本书的其他章节，并在此用作示例代码，以加强好的测试的想法。
- en: Making tests easy to understand
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使测试易于理解
- en: 'Using descriptive test names is probably the single best thing you can do to
    improve your tests. I like to name my tests using simple sentences whenever possible.
    For example, one of the earliest tests we created is called `"Test will pass without
    any confirms"` and looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用描述性的测试名称可能是你可以做的单件最好的事情来改进你的测试。我尽可能喜欢使用简单的句子来命名我的测试。例如，我们最早创建的测试之一叫做 `"Test
    will pass without any confirms"`，看起来像这样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A good pattern to follow is this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模式是这样的：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of the three sections should be replaced with something specific to what
    you’re doing. For the example just given, `<object>` is `Test`, `<does something>`
    is `will pass`, and `<qualification>` is `without` `any confirms`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都应该替换为你正在做的事情的具体内容。对于刚刚给出的例子，`<object>` 是 `Test`，`<does something>` 是 `will
    pass`，而 `<qualification>` 是 `without` `any confirms`。
- en: 'I don’t always follow this pattern, especially when testing an object or a
    type for several different and related results. For example, a simple test immediately
    following the previous test looks like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不总是遵循这个模式，尤其是在测试一个对象或类型以获得几个不同且相关结果时。例如，紧随上一个测试之后的简单测试看起来像这样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For this simple test, there are only two possibilities. The bool is either false
    or true. The test is focused on the bool type, and the name fully describes what
    the test does. My advice is to follow the naming pattern when it makes sense.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的测试，只有两种可能性。布尔值要么是假的，要么是真的。测试专注于布尔类型，名称完全描述了测试做了什么。我的建议是，当有道理的时候，遵循命名模式。
- en: 'The following are ways in which descriptive names help improve your tests:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些描述性名称如何帮助改进你的测试的方法：
- en: The name is what you see in the summary description and will help anyone understand
    what is being tested with just a glance.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是你将在摘要描述中看到的，它将帮助任何人仅通过一眼就能理解正在测试的内容。
- en: A descriptive name will help you spot holes in your testing because it’s easier
    to see what’s missing when you can clearly see what is already being tested.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述性的名称将帮助你发现测试中的漏洞，因为当你能清楚地看到已经测试了什么时，更容易看到缺少了什么。
- en: A descriptive name that follows the pattern given will help you focus when writing
    the test. It’s easy to lose track of what a test is supposed to do and start including
    other things. A descriptive name will help you put related checks in their own
    tests where they will no longer clutter what is being tested and will have their
    own descriptive name, which will help them stand out.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个遵循给定模式的描述性名称将帮助你专注于编写测试。很容易失去对测试应该做什么的跟踪，并开始包括其他事情。描述性名称将帮助你将相关的检查放在它们自己的测试中，这样它们就不会再使被测试的内容变得杂乱，并将有自己的描述性名称，这有助于它们脱颖而出。
- en: Putting all three benefits together, you get a feedback loop that reinforces
    the need for good naming. You’ll naturally create more tests because each one
    is focused. This leads to a better understanding of what is being tested, which
    helps you to find missing tests. And then, when writing the new tests, you’ll
    stay on track and create yet more tests as new ideas come to mind.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个好处结合起来，你将得到一个增强良好命名需求的反馈循环。你将自然地创建更多测试，因为每个测试都是专注的。这有助于你更好地理解正在测试的内容，从而帮助你找到缺失的测试。然后，在编写新测试时，你将保持方向，并在新想法出现时继续创建更多测试。
- en: Imagine if, instead, we had taken a different approach and created a test called
    `"Confirm"`. What would it do? Does it inspire you to think of more tests? And
    what code would you write in the test? This is a name that stops the cycle of
    better tests. No one will know what the test does without reading the code. No
    one will think of new scenarios because the focus is dragged into the code. And
    the test code itself will likely be all over the place yet still not cover everything
    that should be tested.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们采取了不同的方法，创建了一个名为“确认”的测试。它会做什么？这能激发你想到更多测试吗？你会在测试中编写什么代码？这是一个阻止更好测试循环的名称。没有人会知道测试做什么，除非阅读代码。没有人会想到新的场景，因为焦点被拖入了代码。而且测试代码本身可能散落在各处，但仍未能覆盖所有应该测试的内容。
- en: And let’s not forget that using TDD is supposed to help drive our designs, improve
    the quality of our software, and let us refactor and enhance the code with confidence.
    Descriptive names help with all of this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要忘记，使用TDD的目的是为了帮助我们驱动设计，提高软件质量，并让我们有信心重构和增强代码。描述性名称有助于所有这些。
- en: You might find that after a major refactoring, certain tests are no longer applicable.
    That’s fine, and they can be deleted. Descriptive names will help us spot these
    outdated tests. Sometimes, instead of deleting tests, they can be updated, and
    tests that are focused will be easier to update.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，在重大重构之后，某些测试可能不再适用。这是正常的，它们可以被删除。描述性名称将帮助我们识别这些过时的测试。有时，与其删除测试，不如更新它们，专注于的测试将更容易更新。
- en: The next step to creating good tests is to keep them simple. A complicated test
    is usually a symptom of a bad design. TDD helps improve designs. So when you find
    a complicated test, that’s your signal to simplify the design of the project being
    tested.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建良好测试的下一步是保持它们的简单性。复杂的测试通常是一个糟糕设计的症状。TDD有助于改进设计。所以当你发现一个复杂的测试时，那就是你简化被测试项目设计的信号。
- en: If you can make changes that simplify the tests, then that’s usually a double
    win. You get tests that are easier to understand, which leads to higher quality
    software that is easier to use. Remember that a test is a consumer of your software,
    just like any other component. So when you can simplify a test, you’re also simplifying
    other code that uses the same code being tested.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够进行简化测试的更改，那么这通常是一个双赢的局面。你得到的是更容易理解的测试，这导致软件质量更高，更容易使用。记住，测试是软件的消费者，就像任何其他组件一样。所以当你能够简化测试时，你也在简化使用相同代码的其他代码。
- en: A big part of simplifying tests is to make use of setup and teardown code. This
    lets the test focus on what it needs to do and lets us read and understand the
    main point of the test without getting distracted with other code that just gets
    things ready.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简化测试的一个重要部分是利用设置和清理代码。这使测试能够专注于它需要做的事情，并让我们能够阅读和理解测试的主要点，而不会被其他准备工作的代码分散注意力。
- en: 'For example, in [*Chapter 14*](B18567_14.xhtml#_idTextAnchor139), *How To Test
    Services*, I show you the test that I first created to test a service. The test
    created a local instance of the service and called `start`. I realized that other
    tests would likely need to start a service, so they might as well share the same
    service that has already been started with some setup code. The new test uses
    a test suite that allows multiple tests to share the same setup and teardown code.
    The test looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[*第14章*](B18567_14.xhtml#_idTextAnchor139)，“如何测试服务”，我向你展示了最初创建来测试服务的测试。该测试创建了一个服务本地实例并调用`start`。我意识到其他测试可能需要启动服务，因此它们可以共享已经启动的服务和一些设置代码。新的测试使用一个允许多个测试共享相同设置和拆卸代码的测试套件。测试看起来像这样：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This test has a descriptive name and focuses on what needs to be tested instead
    of what is needed to create and start the service. The test uses the global `gService1`
    instance, which exposes the already running service through the `service` method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试有一个描述性的名称，并专注于需要测试的内容，而不是创建和启动服务所需的内容。该测试使用全局`gService1`实例，通过`service`方法公开已运行的服务。
- en: By providing descriptive names and keeping your tests as simple as possible,
    you’ll find better results with TDD that will lead to better software designs.
    The next section goes into more detail about how to focus on specific scenarios.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供描述性名称并尽可能简化你的测试，你将发现使用TDD（测试驱动开发）可以获得更好的结果，这将导致更好的软件设计。下一节将更详细地介绍如何专注于特定场景。
- en: Keeping tests focused on specific scenarios
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将测试集中在特定场景
- en: The previous section explained that one of the benefits of descriptive names
    is that they help keep your tests focused. We’re going to explore in this section
    various scenarios that will give you ideas for what to focus on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节解释了描述性名称的一个好处是它们有助于保持测试的集中。在本节中，我们将探讨各种场景，这将为你提供关于要集中注意力的想法。
- en: Saying that a test should be focused is great. But if you don’t know how to
    figure out what to focus on, then it won’t help you. The advice becomes empty
    and frustrating.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个测试应该集中是很不错的。但如果不知道如何确定要集中什么，那么这不会对你有帮助。建议变得空洞且令人沮丧。
- en: 'These five cases will make the advice more meaningful. Not all of them may
    apply to all situations. But having these will help you, sort of like a checklist.
    All you need to do is think about each one and write specific tests that cover
    the case. The cases are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个案例将使建议更有意义。并非所有这些案例都适用于所有情况。但拥有这些案例将对你有所帮助，有点像清单。你只需要思考每一个案例，并编写覆盖该案例的具体测试。案例如下：
- en: '**Happy or normal**: This is a common use case.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**正常或愉快**：这是一个常见的用例。'
- en: '**Edge**: This is a case near the transition between normal and error cases.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边缘**：这是正常和错误情况之间过渡的案例。'
- en: '**Error**: This is a common problem that needs to be handled.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误**：这是一个需要处理的常见问题。'
- en: '**Not normal**: This is a valid but uncommon use case.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非正常**：这是一个有效但不太常见的用例。'
- en: '**Deliberate misuse**: This is an error case designed to cause problems on
    purpose.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**故意误用**：这是一个故意设计来造成问题的错误案例。'
- en: Let’s start with the happy or normal case first. This one should be easy, but
    it often gets over-complicated by including some of the other cases in the same
    test. Or another way it can be over-complicated is by creating a test that is
    too vague or not clear that it’s the happy or normal case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从正常或愉快的情况开始。这个应该很简单，但通常会被包括其他一些案例而变得过于复杂。或者，另一种可能使其过于复杂的方式是创建一个过于模糊或不清晰表明它是正常或愉快情况的测试。
- en: 'The actual name for this should probably be the normal case since that matches
    the style of the other cases. But I so often think of this as the happy case that
    I included both names. You might also think of this as a typical case. However
    you think of it, all you need to do is pick a scenario that best describes a common
    way that your code will be used. I think of it as a happy case because there should
    not be any errors. This should represent usage that is expected and typical and
    should succeed. For example, in [*Chapter 13*](B18567_13.xhtml#_idTextAnchor131),
    *How to Test Floating Point and Custom Values*, there’s a test for float values
    that covers 1,000 typical values from 0.1 up to 100 in increments of 0.1\. The
    test looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实际的名称可能应该是正常情况，因为这与其他情况的风格相匹配。但我经常把这个想成愉快的情况，所以我包括了两个名称。你也可以把它想成典型情况。无论你怎么想，你只需要选择一个最能描述你的代码通常使用方式的场景。我认为它是愉快的情况，因为不应该有任何错误。这应该代表预期的和典型的情况，并且应该成功。例如，在[*第13章*](B18567_13.xhtml#_idTextAnchor131)，*如何测试浮点数和自定义值*中，有一个测试浮点值的测试，它涵盖了从0.1到100的1000个典型值，增量是0.1。测试看起来像这样：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An edge case is right on the borderline between a happy case and a problem or
    error case. You might often need two edge cases where one represents the most
    extreme usage that is still within normal bounds, and the other is the beginning
    of the error conditions. An edge case is a transition between good and bad results.
    And there can often be multiple edge cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 边界情况位于一个愉快的情况和问题或错误情况之间的边界。你可能经常需要两个边界情况，其中一个代表最极端的使用方式，但仍然在正常范围内，另一个则是错误条件的开始。边界情况是良好和不良结果之间的过渡。通常会有多个边界情况。
- en: Edge cases are extremely valuable to include in your testing because they tend
    to find a lot of bugs, and maybe even more importantly, they make you think about
    your design. When you consider edge cases, you’ll often either accept the edge
    case or change your design so that the edge case doesn’t apply anymore.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 边界情况在测试中非常重要，因为它们往往能发现很多错误，也许更重要的是，它们能让你思考你的设计。当你考虑边界情况时，你通常会接受边界情况或者改变你的设计，使得边界情况不再适用。
- en: 'The edge cases for the previous float comparisons are to test a very small
    float value and a very large float value. These are two separate tests and look
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个浮点比较的边界情况是为了测试一个非常小的浮点值和一个非常大的浮点值。这两个测试是分开的，看起来像这样：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Edge cases can sometimes be a bit more technical because there’s usually a reason
    for the test to be an edge case. For float values, the edge cases are based on
    the *epsilon* value. Epsilon values are explained in [*Chapter 13*](B18567_13.xhtml#_idTextAnchor131),
    *How to Test Floating Point Values*. Adding tests for small and large floating
    point values will cause us to change the entire way that we compare floating point
    values in [*Chapter 13*](B18567_13.xhtml#_idTextAnchor131). This is why edge cases
    are so valuable in testing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 边界情况有时可能更技术性，因为通常有一个原因使得测试成为边界情况。对于浮点值，边界情况基于*epsilon*值。Epsilon值在[*第13章*](B18567_13.xhtml#_idTextAnchor131)，*如何测试浮点值*中有解释。为小和大浮点值添加测试将导致我们改变[*第13章*](B18567_13.xhtml#_idTextAnchor131)中比较浮点值的方式。这就是为什么边界情况在测试中如此有价值。
- en: The error case is like the happy case turned sad. Think of a typical problem
    that your code might need to handle and write a test for that specific problem.
    Just like how the happy case can sometimes be over-complicated, this one, too,
    can be over-complicated. You don’t need to include minor variations of an error
    case just for the sake of variation alone. Just pick what you think represents
    the most common or middle case that should result in an error and create a test
    for just that one case. Of course, you will want to name the test with a descriptive
    name that explains the case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 错误情况就像愉快的情况变得悲伤。想想你的代码可能需要处理的典型问题，并为该特定问题编写一个测试。就像愉快的情况有时可能过于复杂一样，这个测试也可能过于复杂。你不需要为了变化本身而包括错误情况的微小变化。只需选择你认为最能代表最常见或中间情况，并导致错误的情况，并为该单一情况创建一个测试。当然，你希望用描述性的名称命名测试，以解释情况。
- en: 'For example, in [*Chapter 11*](B18567_11.xhtml#_idTextAnchor114), *Managing
    Dependencies*, there’s a normal test to make sure that tags *can* be used to filter
    messages. An error case is almost the opposite and makes sure that an overridden
    default tag is *not* used to filter the message. The test might not make sense
    without first reading [*Chapter 11*](B18567_11.xhtml#_idTextAnchor114). I’m including
    it here as an example of an error case. Notice `CONFIRM_FALSE` at the end of the
    test, which is the part that ensures the log message does not appear in the log
    file. The test looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[*第11章*](B18567_11.xhtml#_idTextAnchor114) *管理依赖*中，有一个正常测试来确保标签*可以*用于过滤消息。一个错误情况几乎正好相反，确保覆盖的默认标签*不*用于过滤消息。如果没有先阅读[*第11章*](B18567_11.xhtml#_idTextAnchor114)，这个测试可能没有意义。我将其包括在这里，作为一个错误情况的例子。注意测试末尾的`CONFIRM_FALSE`，这是确保日志消息不会出现在日志文件中的部分。测试看起来是这样的：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If there are multiple error cases that you think are all important enough to
    be included, put them in separate tests and ask what makes each one different.
    This will lead to the insight that might cause you to change your design or might
    lead to more tests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为有多个错误情况都足够重要，应该包含在内，请将它们放入单独的测试中，并询问每个情况的不同之处。这可能会让你产生洞察力，从而改变你的设计或导致更多的测试。
- en: I like to include a few tests that are just outside of a normal case but not
    borderline or edge. These are still within valid use that should succeed but might
    cause your code to do a little extra work. This case can be valuable in helping
    to catch regressions. A regression is a bug that is new and represents a problem
    that used to work previously. A regression is most common after making a large
    design change. Having some tests that are not normal but still expected to succeed
    will improve your confidence in your code continuing to work after major changes
    are made.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢包含一些测试，这些测试超出了正常情况，但不是边界或边缘情况。这些测试仍然在有效使用范围内，应该成功，但可能会让你的代码做一点额外的工作。这种情况在帮助捕捉回归中可能很有价值。回归是一个新的错误，它代表了一个以前曾经工作过的问题。回归在做出重大设计变更后最为常见。有一些非正常但仍然预期会成功的测试将提高你在做出重大变更后对代码继续工作的信心。
- en: The last case is deliberate misuse and is important for security reasons. This
    is not just an error case; it’s an error case crafted to try to cause your code
    to fail in predictable ways that an attacker can use for their own purposes. For
    cases like this, instead of creating tests that you know will fail, try to think
    of what would cause your code to fail spectacularly. Maybe your code treats negative
    numbers as errors. Then for deliberate misuse, maybe consider using really large
    negative numbers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个情况是有意误用，出于安全原因很重要。这不仅仅是一个错误情况；这是一个精心设计的错误情况，旨在以攻击者可以用于自己目的的预测方式导致你的代码失败。对于这种情况，与其创建你知道会失败的测试，不如考虑什么会导致你的代码以惊人的方式失败。也许你的代码将负数视为错误。那么，对于有意误用，也许可以考虑使用非常大的负数。
- en: In [*Chapter 14*](B18567_14.xhtml#_idTextAnchor139), *How to Test Services*,
    there is mention of a possible test for deliberate misuse. We don’t actually create
    this test, but I do describe what the test would look like. In the service, there
    is a string value that represents the request being made. The code handles unrecognized
    request strings, and I mentioned that a good test would try to call the service
    with some request that doesn’t exist to make sure that the service properly handles
    the ill-formed request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第14章*](B18567_14.xhtml#_idTextAnchor139) *如何测试服务*中，提到了一个关于有意误用的可能测试。我们实际上并没有创建这个测试，但我确实描述了这个测试可能的样子。在服务中，有一个表示正在进行的请求的字符串值。代码处理未识别的请求字符串，我提到一个好的测试会尝试使用一些不存在的请求调用服务，以确保服务正确处理格式不正确的请求。
- en: For a final piece of advice about focusing on specific scenarios, I’d like to
    recommend that you avoid retesting. This is not one of the five cases just mentioned
    because it applies to all of them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于专注于特定场景的最后一条建议，我想推荐你避免重复测试。这不是前面提到的五种情况之一，因为它适用于所有这些情况。
- en: Retesting is where you check the same thing or make the same confirmations over
    and over in many tests. You don’t need to do this, and it just distracts you from
    what each test should be focused on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重复测试是指你在许多测试中反复检查相同的事情或做出相同的确认。你不需要这样做，这只会让你分心，无法专注于每个测试应该关注的内容。
- en: If there’s a property or result that you need to confirm works, then create
    a test for it. And then you can trust that it will be tested. You don’t need to
    confirm again and again that the property works as expected each time it’s used.
    Once you have a test for something, then you don’t need to verify it works in
    other tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要确认某个属性或结果是否正常工作，那么就为它创建一个测试。然后你可以相信它将会被测试。你不需要每次使用时都再次确认属性是否按预期工作。一旦你为某事创建了测试，那么你就不需要在其他测试中验证它是否工作。
- en: Use random behavior only in this way
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只以这种方式使用随机行为
- en: The previous chapter mentioned using random behavior in tests, and it’s important
    for you to understand more about this so that your tests are predictable and repeatable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章提到了在测试中使用随机行为，了解这一点对于你的测试可预测和可重复非常重要。
- en: Predictability and randomness are about as opposite as you can get. How should
    we reconcile these two properties? The first thing to understand is that the tests
    you write should be predictable. If a test passes, then it should always pass
    unless something outside of your control fails, such as a hard drive crashing
    in the middle of your tests. There’s no way to predictably handle accidents like
    that, and that’s not what I’m talking about. I mean that if a test passes, then
    it should continue to pass until some code change causes it to fail.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测性和随机性几乎是你能想象到的最相反的两个属性。我们应该如何调和这两个属性呢？首先，你需要理解的是，你编写的测试应该是可预测的。如果一个测试通过了，那么除非你无法控制的外部因素失败，例如在测试过程中硬盘崩溃，否则它应该总是通过。没有办法可预测地处理这样的意外，这也不是我在谈论的。我的意思是，如果一个测试通过了，那么它应该继续通过，直到某些代码更改导致它失败。
- en: And when a test fails, then it should continue to fail until the problem is
    fixed. The last thing you want is to add random behavior to your tests so that
    you sometimes do one thing and other times do another. That’s because the first
    behavior might pass, while the second behavior goes down a different code path
    that fails.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，它应该继续失败，直到问题得到解决。你最不希望的是向测试中添加随机行为，以便有时做一件事，有时做另一件事。这是因为第一种行为可能会通过，而第二种行为可能会走不同的代码路径而失败。
- en: If you get a failure, make a change that you think fixes the problem, and then
    get a pass, you might think that your change fixed the problem. But what if the
    second test run just happened to use the random behavior that was always passing?
    It makes it hard to verify that a code change actually fixed a problem.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到失败，进行你认为可以解决问题的更改，然后通过测试，你可能会认为你的更改解决了问题。但如果是第二次测试运行恰好使用了总是通过的那个随机行为呢？这会使验证代码更改实际上是否解决问题变得困难。
- en: And worse yet, what happens when some random failure condition never gets run?
    You think all possible code path combinations are being run, but by chance, one
    or more conditions are skipped. This can cause you to miss a bug that should have
    been caught.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，当某些随机失败条件从未被执行时会发生什么？你认为所有可能的代码路径组合都在运行，但偶然之间，一个或多个条件被跳过了。这可能导致你错过应该被捕获的bug。
- en: I hope I’ve convinced you to stay away from random test behavior. If you want
    to test different scenarios, then write multiple tests so that each scenario is
    covered by its own test that will reliably be run.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我已经说服你远离随机测试行为。如果你想测试不同的场景，那么编写多个测试，以便每个场景都由其自己的测试来可靠地运行。
- en: 'Why, then, did I mention using randomness in the previous chapter? I actually
    do suggest that you use randomness but not in a way that determines what a test
    does; rather, in a way that helps prevent collisions between different test runs.
    The random behavior is mentioned in one of the helper functions to create a temporary
    table like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我在上一章提到了使用随机性呢？我实际上确实建议你使用随机性，但不是用来决定测试做什么的方式；而是用来帮助防止不同测试运行之间的冲突。这种随机行为在创建临时表的辅助函数中提到：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s say that you have a test that needs some data. You create the data in
    setup and delete it when the test is done in teardown. What happens if the test
    program crashes during the test and the teardown never gets a chance to delete
    the data? The next time you run your test, it’s likely that the setup will fail
    because the data still exists. This is the collision I’m talking about.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个需要一些数据的测试。你在设置中创建数据，在测试完成后在清理中删除它。如果测试程序在测试期间崩溃，并且清理没有机会删除数据会发生什么？下次你运行测试时，很可能设置会失败，因为数据仍然存在。这就是我所说的冲突。
- en: Maybe you think that you can just enhance the setup to succeed if it finds the
    data already exists. Well, you can also get collisions in other ways, such as
    when writing code in a team and two team members happen to run the tests at almost
    the same time. Both setup steps run, and one of them finds the data already exists
    and continues. But before the test can begin to use the data, the other team member
    finished, and the teardown code deletes the data. The team member that is still
    running tests will now fail because the data no longer exists.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你认为，如果你增强设置以成功找到已存在的数据，那么你可以。你也可以通过其他方式得到冲突，例如在团队中编写代码时，两个团队成员几乎同时运行测试。两个设置步骤都会运行，其中一个发现数据已存在并继续。但在测试开始使用数据之前，另一个团队成员已经完成，并且清理代码删除了数据。仍在运行测试的团队成员现在会失败，因为数据不再存在。
- en: You can almost entirely eliminate this problem by generating random data. Not
    so random that the behavior of the test is affected. But just random enough to
    avoid conflicts. Maybe the data is identified by a name. As long as the name is
    not part of what is being tested, the name can be changed slightly so that each
    time the test is run, the data will have a different name. The `createTestTable`
    function returns a hardcoded name, but the comment mentions that a random name
    might be better.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过生成随机数据几乎完全消除这个问题。但不要随机到影响测试行为。只需随机到足以避免冲突。也许数据是通过一个名称来标识的。只要名称不是测试的一部分，名称可以稍微改变，以便每次运行测试时，数据都有一个不同的名称。`createTestTable`函数返回一个硬编码的名称，但注释提到随机名称可能更好。
- en: There is a place for using full random behavior in tests, such as when performing
    random penetration testing, and you need to fuzz or alter the data to simulate
    scenarios that you otherwise would not be able to write specific test cases for.
    The number of possible combinations could be too many to handle with specific
    named test cases. So in these situations, it is a good idea to write tests that
    use random data that can change the behavior and outcome of the tests. But these
    types of tests won’t help you with TDD to improve your designs. They have a place
    that supplements TDD.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用完全随机行为的地方，例如在执行随机渗透测试时，你需要模糊或更改数据来模拟你否则无法为特定场景编写测试用例的情况。可能的组合数量可能太多，无法用特定的命名测试用例处理。因此，在这些情况下，编写使用随机数据来改变测试行为和结果的测试是个好主意。但这类测试不会帮助你通过TDD来改进你的设计。它们有补充TDD的位置。
- en: When writing tests that use random behavior, such as when handling uncountable
    combinations, you’ll need to capture the failures because each one will need to
    be analyzed to find the problem. This is a time-consuming process. It’s valuable,
    but not what you need when writing a test to help you figure out what design to
    use or when evaluating the results of a major design change to see if anything
    was broken.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写使用随机行为的测试时，例如处理不可计数的组合时，你需要捕获失败，因为每个失败都需要分析以找出问题。这是一个耗时过程。虽然很有价值，但当你编写测试来帮助你确定要使用的设计或评估重大设计变更的结果以查看是否有什么东西被破坏时，这不是你需要的。
- en: For the types of tests that are most beneficial to TDD, avoid any random behavior
    that can change the outcome of the tests. This will keep your tests reproducible
    and predictable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对TDD最有益的测试类型，应避免任何可能改变测试结果的随机行为。这将确保你的测试可重复和可预测。
- en: Only test your project
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只测试你的项目
- en: Other components and libraries will be used and might fail. How should you handle
    these failures in your tests? My advice is to assume that only your code needs
    to be tested. You should assume that the components and libraries you are using
    have already been tested and are working correctly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其他组件和库将被使用，可能会失败。你应该如何处理测试中的这些失败？我的建议是假设只有你的代码需要被测试。你应该假设你使用的组件和库已经过测试并且正在正常工作。
- en: For one thing, remember that we are using TDD to improve our own code. If you
    were to write a test for some code that you bought or found online, how would
    this affect your own code?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，记住我们使用TDD来改进我们自己的代码。如果你为一些你购买或在网上找到的代码编写测试，这会如何影响你自己的代码？
- en: There’s always a possibility that you are using an open source library and you
    have a good idea for improvement. That’s great! But that improvement belongs in
    that other project. It has no place in your own project’s tests. Even if you find
    a bug in a commercial software package, all you can do is report the problem and
    hope it gets fixed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有这样的可能性，你正在使用一个开源库，并且你有一个很好的改进想法。那太好了！但是这个改进应该属于那个其他项目。它不应该出现在你自己的项目测试中。即使你在商业软件包中找到一个错误，你所能做的就是报告问题并希望它得到修复。
- en: The last thing you want to do is put a confirmation in your own test project
    that confirms some other code is working as expected. This not only does not affect
    your own designs, it actually makes your tests less focused. It takes away from
    the clarity you should be aiming for by adding distractions that don’t directly
    benefit your own project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你最不想做的事情就是在自己的测试项目中添加一个确认，确认其他代码按预期工作。这不仅不会影响你自己的设计，实际上会使你的测试变得不那么专注。它通过添加一些对你的项目没有直接好处的干扰，削弱了你应该追求的清晰度。
- en: The next chapter of this book begins *Part 2*, where we’ll build a logging library.
    The logging library will be a separate project with its own set of tests. The
    logging library will also use the testing library we’ve been building. Imagine
    how confusing it would be if we were to add a new feature to the testing library
    and then test that new feature from the logging library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本书下一章开始是**第二部分**，我们将构建一个日志库。日志库将是一个独立的项目，有自己的测试集。日志库还将使用我们一直在构建的测试库。想象一下，如果我们向测试库添加一个新功能，然后从日志库测试这个新功能，那会多么令人困惑。
- en: Test what should happen instead of how
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应该发生的事情，而不是如何发生
- en: A common problem I see is when a test tries to verify expected results by checking
    internal steps along the way. The test is checking how something is done. This
    type of test is fragile and often needs frequent updates and changes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我常见的一个问题是，当测试试图通过检查过程中的内部步骤来验证预期结果时。测试正在检查如何做某事。这种类型的测试很脆弱，通常需要频繁的更新和更改。
- en: A better approach is to test what happens as a final result. Because then the
    internal steps can change and adapt as needed. The test remains valid the entire
    time without further maintenance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是测试最终结果会发生什么。因为这样，内部步骤可以根据需要改变和适应。测试在整个过程中保持有效，无需进一步维护。
- en: If you find yourself going through your tests and frequently updating them,
    so the tests pass again, then your tests might be testing how something is done
    instead of what is done.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在频繁地更新测试，以便它们再次通过，那么你的测试可能是在测试如何做某事，而不是做了什么。
- en: For example, in [*Chapter 10*](B18567_10.xhtml#_idTextAnchor096), *The TDD Process
    in Depth*, there’s a section called *When is testing too much?* that explains
    the idea of what to test in greater detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[*第10章*](B18567_10.xhtml#_idTextAnchor096)“深入理解TDD过程”中，有一个名为*何时测试过多？*的部分，详细解释了应该测试什么的概念。
- en: The general idea is this. Let’s say you have a function that adds a filter to
    a collection. If you write a test that’s focused on how the code works, then you
    might go through the items in the collection to make sure the filter that was
    just added really appears in the collection. The problem with this approach is
    that the collection is an internal step and might change, which will cause the
    test to fail. A better approach is to first add the filter and then try to perform
    an operation that would be affected by the filter. Make sure that the filter affects
    the code as you expect, and leave the internal details of how it works to the
    code being tested. This is testing what should happen and is a much better approach.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的想法是这样的。假设你有一个向集合添加过滤器的函数。如果你写一个专注于代码如何工作的测试，那么你可能会遍历集合中的项目，以确保刚刚添加的过滤器确实出现在集合中。这种方法的缺点是集合是一个内部步骤，可能会改变，这会导致测试失败。更好的方法是首先添加过滤器，然后尝试执行一个会受到过滤器影响的操作。确保过滤器按你预期的方式影响代码，并将它如何工作的内部细节留给被测试的代码。这是测试应该发生的事情，是一个更好的方法。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This has been more of a reflective chapter where you learned some tips to help
    you write better tests. Examples from earlier and later chapters were used to
    help reinforce the ideas and guidance. You’ll write better tests if you make sure
    to consider the following items:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是一个反思性的章节，你学到了一些有助于你编写更好测试的技巧。早期和后期章节的例子被用来帮助加强这些想法和指导。如果你确保考虑以下事项，你会写出更好的测试：
- en: The tests should be easy to understand with descriptive names.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该易于理解，具有描述性的名称。
- en: Prefer small and focused tests instead of large tests that try to do everything.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宁愿使用小型且专注的测试，而不是试图做所有事情的庞大测试。
- en: Make sure that tests are repeatable. If a test fails once, then it should continue
    to fail until the code is fixed.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试是可重复的。如果一个测试失败了一次，那么它应该继续失败，直到代码被修复。
- en: Once you test something, you don’t need to keep testing the same thing. And
    if you have some useful code that other tests can share, then consider putting
    the code in its own project with its own set of tests. Only test the code that
    is in your project.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你测试了某个东西，你就不需要继续测试相同的东西。如果你有一些其他测试可以共享的有用代码，那么考虑将这些代码放入自己的项目，并为其设置自己的测试集。只测试你项目中的代码。
- en: Test what should happen instead of how it should happen. In other words, focus
    less on the internal steps and instead verify the results you are most interested
    in.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该发生的事情，而不是它应该如何发生。换句话说，减少对内部步骤的关注，而是验证你最感兴趣的结果。
- en: There are many ways to write better tests. This chapter should not be considered
    to include the only things you need to consider. Instead, this chapter identifies
    some common issues that cause problems with tests and gives you tips and advice
    to improve your tests. In the next chapter, we’re going to use TDD to create something
    that will use a unit test library just like any other project you’ll be working
    on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以编写更好的测试。本章不应被视为包含你需要考虑的唯一事项。相反，本章确定了导致测试问题的常见问题，并为你提供了改进测试的技巧和建议。在下一章中，我们将使用TDD来创建一个将使用单元测试库的项目，就像你将在自己的项目中做的那样。
- en: 'Part 2: Using TDD to Create a Logging Library'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用TDD创建日志库
- en: This book is divided into three parts. In this second part, we’re going to use
    the unit test library to design and build a logging library. Along the way, you’ll
    see how to use TDD in a different project just as you’ll need to do when working
    on your own projects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本书分为三部分。在本第二部分中，我们将使用单元测试库来设计和构建一个日志库。在这个过程中，你将看到如何在不同项目中使用TDD，就像你将在自己的项目中做的那样。
- en: 'The following chapters are covered in this part:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖了以下章节：
- en: '[*Chapter 9*](B18567_09.xhtml#_idTextAnchor085), *Using Tests*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18567_09.xhtml#_idTextAnchor085), *使用测试*'
- en: '[*Chapter 10*](B18567_10.xhtml#_idTextAnchor096), *The TDD Process in Depth*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18567_10.xhtml#_idTextAnchor096), *深入理解TDD过程*'
- en: '[*Chapter 11*](B18567_11.xhtml#_idTextAnchor114), *Managing Dependencies*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18567_11.xhtml#_idTextAnchor114), *管理依赖*'
