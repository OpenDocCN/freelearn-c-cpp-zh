- en: Bluetooth Classic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth LE, which we saw in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml),
    *Bluetooth LE*, is an excellent choice when we need two devices to communicate
    wirelessly in short data bursts and where power consumption is a concern. There
    have been changes with Bluetooth LE with versions 4.2 and 5.0\. That make it more
    appealing for devices that need to transfer large amounts of data or even stream
    data. However, there is another Bluetooth technology that has been doing this
    for very successfully for many years, this technology is known as Bluetooth Classic.
    While the name may imply that this technology is out of date, don't let the name
    fool you as Bluetooth Classic is used in many Bluetooth devices, and until there
    are more Bluetooth 5.0 modules available for the Arduino that also support some
    of the newer features, Bluetooth Classic will remain an excellent choice when
    we need to transfer large amounts of data between two devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What the version numbers of Bluetooth Classic mean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Bluetooth radio works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network topology of a Bluetooth network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the HC-05 Bluetooth module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth is a wireless technology standard that is used by two devices to transmit
    or receive data over short distances using a 2.4GHz wireless connection. While
    the design goal of Bluetooth LE was to create a low-power wireless protocol, Bluetooth
    Classic had different design goals. Bluetooth Classic was created by engineers
    that work at Ericsson Mobile in Lund, Sweden, as a wireless alternative to serial
    (RS232) cables. This meant that this new protocol would be required to transmit
    large amounts of data, or even stream data, over short distances.
  prefs: []
  type: TYPE_NORMAL
- en: The Bluetooth Classic specifications are managed by the **Bluetooth Special
    Interest Group** (**Bluetooth SIG**) as part of the Bluetooth core specifications.
    As we mentioned in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth
    LE*, you can find information about both Bluetooth LE and Bluetooth Classic by
    downloading the specifications form from the Bluetooth SIG site at [https://www.bluetooth.com](https://www.bluetooth.com).
  prefs: []
  type: TYPE_NORMAL
- en: At first, it may seem strange to cover the newer technology (Bluetooth LE 4.0)
    prior to covering the older technology (Bluetooth Classic). The reason Bluetooth
    LE was covered first is that you will find that it is appropriate to use it in
    the more significant majority of projects that you will be creating with the Arduino,
    as most projects will want to send short bursts of data, which is what Bluetooth
    LE is designed for. Bluetooth LE is also easier to integrate with smartphones
    using Bluetooth LE because every smartphone OS has an easy to use and well documented
    Bluetooth LE API, which is not the case for Bluetooth Classic. For the cases where
    you will want to stream data or share large amounts of data between two custom
    devices, Bluetooth Classic may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'When purchasing a Bluetooth Classic module for your project, you will have
    a choice of three different Bluetooth versions. These versions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bluetooth 2.0 + EDR**: The core specifications for this version were released
    in 2004\. This update to the Bluetooth core specifications contained a number
    of minor improvements to the Bluetooth standard. The only significant improvement
    was **EDR** (**Enhanced Data Rate**), which increased the data transfer rate to
    3Mbits/sec from 1Mbits/sec. The name of the standard reads Bluetooth 2.0 + EDR,
    which means that the EDR feature is optional. The HC-05 Bluetooth module that
    we will be using for this chapter is Bluetooth 2.0, compatible which means it
    does not include the EDR feature. For the vast majority of projects that you will
    build with the Arduino, Bluetooth 2.0-compatible modules will be fine and are
    actually preferable since we are able to avoid the secure pairing feature that
    was introduced with Bluetooth 2.1\. While the new pairing feature may be called
    Simple Secure Pairing, it usually requires human interaction for the pairing process,
    which we may want to avoid since a lot of Arduino projects do not have the input
    capabilities to do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth 2.1 + EDR**: The core specifications for this version was released
    in 2007\. This version of the Bluetooth core specifications also offered a number
    of improvements on the previous version, with the featured improvement being the
    introduction of **SSP** (**Simple Secure Pairing**). SSP overhauled the pairing
    process, making it both simple and more secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth 3.0 + HS**: The core specifications for this version were released
    in 2009\. The HS in the specification name stands for High Speed. Bluetooth 3.0
    + HS can have a theoretical data transfer speed of 24 Mbits/sec, however the data
    is not transmitted over a Bluetooth connection. When in high-speed mode the data
    is actually transmitted over an 801.11 (Wi-Fi) connection. The Bluetooth link
    is only used to negotiate and establish the Wi-Fi connection. As with the Bluetooth
    2.X + EDR specification, the HS feature is optional, and you will see devices
    that only meet the Bluetooth 3.0 standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with Bluetooth LE, to really understand when to use Bluetooth Classic we
    need to understand the technology itself, so let's dive into in a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth radio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The range of a Bluetooth radio is dependent on the class. The following chart
    shows the range of a Bluetooth radio by the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Power (mW)** | **Power (dBm)** | **Range in meters** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 100 | 20 | ~100 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2.5 | 4 | ~10 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 0 | ~1 |'
  prefs: []
  type: TYPE_TB
- en: As with any radio technology the area surrounding the radio has a substantial
    effect on the range of the radio. The range listed in the previous chart is the
    theoretical maximum range with ideal conditions. The typical range is usually
    less than this theoretical maximum range.
  prefs: []
  type: TYPE_NORMAL
- en: Where the Bluetooth LE radio operates from 2,402 MHz to 2,480 MHz with each
    channel being 2 MHz apart, the Bluetooth Classic radio uses 79 channels from 2,402
    MHz to 2,480 MHz with each channel being 1 MHz apart. As with Bluetooth LE, the
    Bluetooth Classic radio uses frequency hopping, where the radio changes channels
    1,600 times a second, to reduce interference.
  prefs: []
  type: TYPE_NORMAL
- en: With Bluetooth LE, the radio continuously turns itself off to reduce power,
    Bluetooth Classic does not do this. This makes the Bluetooth LE radio technology
    better at short bursts of data with low power while the Bluetooth Classic radio
    is better at transmitting large amounts of data or data streaming because the
    radio is continuously on.
  prefs: []
  type: TYPE_NORMAL
- en: All Bluetooth devices have a unique 48-bit address that is assigned to the Bluetooth
    radio by the manufacturer. The upper half of the address (the most significant
    24 bits) is known as the **Organizationally Unique Identifier** and consists of
    two parts. These parts are the **Non-Significant Address** (**NAP**) and the **Upper
    Address Part** (**UAP**).
  prefs: []
  type: TYPE_NORMAL
- en: The NAP is the first 16 bits of the address and is used in frequency hopping
    synchronization. The UAP is the next 8 bits and is assigned to the radio manufacturer
    by the IEEE organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last 24-bits of the address is known as the **Lower Address Part** (**LAP**).
    The LAP is assigned by the manufacturer to identify the radio uniquely. The following
    diagram shows how the Bluetooth address is made up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aeb2940-c65e-438e-8855-71499af8f2d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's look that the network topology for Bluetooth Classic.
  prefs: []
  type: TYPE_NORMAL
- en: Network topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The topology of a Bluetooth Classic piconet is very similar to the topology
    of a Bluetooth LE network where one device acts as a master and the other devices
    act as slaves to the master. In a Bluetooth Classic piconet, one master can have
    up to seven slaves for a total of eight devices in the piconet. The following
    diagram shows a Bluetooth classic piconet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9fe22df-97db-48f3-a094-143fa3824def.png)'
  prefs: []
  type: TYPE_IMG
- en: Piconets can interact with other piconets to form what is known as scatternets.
    A scatternet is one where the master of one piconet acts as a slave in another
    piconet. This does allow devices in one piconet to share data with devices in
    other piconets; however, this does require complex synchronization and bandwidth
    sharing, making these networks more complex and less efficient. It is good to
    know that we can create scatternets, but it is something that, in my experience,
    is rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to Bluetooth than what is described here; however, for the
    vast majority of use cases you will want to use Bluetooth LE as described in [Chapter
    20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth LE*. With the Arduino,
    we would use Bluetooth Classic when we want to connect two devices and stream
    data between them. Let's look at how we would do this with three projects. For
    the first project we will configure the Bluetooth modules, the second project
    we will learn how to send and receive data from the Bluetooth module, and in the
    third project, we will see how we can stream data from one radio to another. We
    will start off by looking at the components that we will need for these projects.
  prefs: []
  type: TYPE_NORMAL
- en: Components needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these projects you will need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: Two Arduino Uno or compatible boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two HC-05 Bluetooth modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One Joystick breakout module for the Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at the circuit diagram for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be writing code for three projects. In the first project
    we will be configuring the Bluetooth modules, in the second project we will create
    an application that will send data, in byte format, from one Bluetooth radio to
    another and in the last project we will attach a joystick to one of the Arduinos
    and stream the joystick position to the other Arduino through the Bluetooth connection.
    The following shows the circuit diagram for our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5ecaaaf-a9c5-44e3-8b5d-b8f4c7a51393.png)'
  prefs: []
  type: TYPE_IMG
- en: The two Arduino circuits are completely isolated from each other, therefore
    they do not need a common ground. Both HC-06 Bluetooth modules are connected to
    the Arduino in the same way where the VCC pin on the HC-06 Bluetooth module is
    connected to 5V out, and the GND pin is connected to the ground out on the Arduino.
    The key pin on the Bluetooth module is connected to the digital 9 pin on the Arduino,
    the RX pin is connected to the digital 10 pin, and the TX pin is connected to
    the digital 11 pin.
  prefs: []
  type: TYPE_NORMAL
- en: We will want to connect a joystick breakout module to one of the Arduinos. To
    do this, we will want to connect the VCC pin on the breakout board to the 5V out
    on the Arduino and the GND pin to the ground out on the Arduino. We will connect
    the SEK or SW pin, depending on your joystick module, to the digital 2 pin on
    the Arduino. Finally, we will connect the HOR or *x *axis pin on the breakout
    board to the Analog 0 pin on the Arduino and the VER or *y *axis pin to the Analog
    1 pin.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look start with our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Project 1 – configuring the Bluetooth modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To communicate with the HC-05 Bluetooth module, we will use the same `SoftwareSerial`
    library that we used in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml),
    *Bluetooth LE*. The code that is used to communicate is very similar between the
    HM-10 (Bluetooth LE) and the HC-05 (Bluetooth Classic). How the two radios transmit
    and receive the data is a lot different, therefore understanding how the radios
    work and what they should be used for will define when to use the different technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this first project, we will be writing an application that will allow us
    to configure the Bluetooth modules. This code will start off exactly as we did
    with the Bluetooth LE code by including the `SoftwareSerial` library and creating
    an instance of the `SoftwareSerial` type. The following code shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line includes the `SoftwareSerial` library and the second line creates
    an instance of the type. The Boolean variable in the last line will be used to
    tell the application when to add a new line in the serial console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add code to the `setup()` function that will configure the serial
    console and the `SoftwareSerial` instance. The following code shows the `setup()`
    function for this first project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by setting up the serial console with a baud rate of `9600`
    and then define that the digital 9 pin will be an output pin and set it to high.
    The digital 9 pin is connected to the key pin on the HC-05\. We pull this pin
    high to enable the Bluetooth module. We then configure the `HC05` instance of
    the `SoftwareSerial` type with a baud rate of `38400` and print a message to the
    serial console letting the user know that everything is configured and ready to
    go.
  prefs: []
  type: TYPE_NORMAL
- en: You will note, in this first project we set the baud rate of the `SoftwareSerial`
    instance to `38400` because we are configuring the Bluetooth module. In the next
    two projects, we set the baud rate to `9600` because we will be sending and receiving
    data to/from the Bluetooth module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `loop()` function, just like in the Bluetooth LE code, we will take
    any input from the Bluetooth module and print it to the serial console and any
    input from the serial console we will send out through the Bluetooth module. The
    following code will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the first thing we do is to see if there is any data available
    from the `HC05` `SoftwareSerial` instance (the Bluetooth module) by using the
    `available()` function. If there is data available we check to see if we need
    to add a new line to the serial console by checking the `addNewLine` Boolean variable.
    If we need to add a new line, we write a carriage return and line feed to the
    serial console and then set the `addNewLine` Boolean variable to `false`. We then
    write the data that was received from the Bluetooth module to the serial console.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check to see if there is any data available from the serial console,
    also using the `available()` function and if so we write that data to the Bluetooth
    module which is then transmitted to the connected device. We also set the `addNewLine`
    Boolean variable to true, so that the next time data is received from the connected
    device, we will add a carriage return and line feed to the serial console.
  prefs: []
  type: TYPE_NORMAL
- en: Before we plug the Arduino and run this code, we will need to set the HC-05
    Bluetooth module into configuration mode. To do this, we will need to press and
    hold down the button on the Bluetooth module and then plug the Arduino into the
    computer giving power to the Bluetooth module. In just a couple of seconds, the
    light on the Bluetooth module will start to blink very slowly; the light will
    be on for two seconds and then turn off for two seconds. Once the light starts
    to blink, we can release the button, and the Bluetooth module is ready to be configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the Bluetooth module, we issue AT commands similar to how we did
    it with the Bluetooth LE module. To send an AT command, you would use the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To set an item, you type in the letters AT followed by the plus sign, the command
    and the new setting without any spaces. For example, to set the role of the Bluetooth
    module to a salve role we would issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**: AT commands are case insensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the item, we would type in the letters `at` followed by the plus sign,
    the command and then a question mark. For example, to query the role of the Bluetooth
    module, we would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To issue the command, we type the command into the input box on the serial
    console and press *Enter*. We will need to set the serial console to add both
    an NL (new line) and a CR (carriage return). The following screenshot shows how
    to issue an AT command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e21481a-3e96-407a-b53d-df53fac17ba4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After we type in the `at+role?` command, we press the *Enter* key or the Send
    button to send the command to the Bluetooth module. The Bluetooth module will
    respond with the results of the query, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71003801-57d4-45e0-92a5-8b9fc754b50f.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we configure the modules, let's look at some of the commands that we
    can issue to the HC-05 Bluetooth module.
  prefs: []
  type: TYPE_NORMAL
- en: Test command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT` | `OK` | None | This is a test command that can be used to test theconnection
    to the Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: Reset command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+RESET` | `OK` | None | This command will reset the Bluetooth module.
    |'
  prefs: []
  type: TYPE_TB
- en: Query firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+VERSION?` | `+VERSION:<Param>` | None | Returns the version of the firmware
    on theHC-05 Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: Restore defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ORGL` | `OK` | None | Restores the HC-05 Bluetooth module to thedefault
    settings. |'
  prefs: []
  type: TYPE_TB
- en: Query module address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ADDR?` | `+ADDR:<Param>` | None | Returns the address of the HC-05 Bluetoothmodule.
    |'
  prefs: []
  type: TYPE_TB
- en: Set/Query module mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ROLE?` | `+ROLE:<Param>` | `0` Slave`1` Master | Queries the role of
    the HC-05 Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ROLE=<Param>` | `OK` | `0` Slave`1` Master | Sets the role of the HC-05
    Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: Set/Query UART parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+UART?` | `+UART:<Param1>, <Param2>, <Param3>` | `Param1` = Baud Rate`Param2`
    = Stop Bit`Param3` = Parity | Queries the UARTparameters. |'
  prefs: []
  type: TYPE_TB
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+UART=<Param1>, <Param2>, <Param3>` | `OK` | `Param1` = Baud Rate`Param2`
    = Stop Bit`Param3` = Parity | Sets the UARTparameters. |'
  prefs: []
  type: TYPE_TB
- en: Set/Query connection mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+CMODE?` | `+UART:<Param>` | `0` Connect to Fixed Address`1` Connect to
    any address`2` Slave-loop | Queries the connection mode ofthe HC-05 Bluetooth
    module. |'
  prefs: []
  type: TYPE_TB
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+CMODE=<Param>` | `OK` | `0` Connect to Fixed Address`1` Connect to any
    address`2` Slave-loop | Sets the connection mode forthe HC-05 Bluetooth module.
    |'
  prefs: []
  type: TYPE_TB
- en: Set/Query bind address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+BIND?` | `+BIND:<Param>` | None | Queries the address that the module
    is configuredto bind to. |'
  prefs: []
  type: TYPE_TB
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+BIND=<Param>` | `OK` | Fixed address | Sets the address to bind to. |'
  prefs: []
  type: TYPE_TB
- en: Now that we have seen most of the AT commands let's configure the two Bluetooth
    modules. We are going to need to configure one of the Bluetooth modules as the
    master and the other one as a slave. For the purposes of the next two projects,
    I configured the Bluetooth module that is connected to the same Arduino as the
    joystick as the slave. This, however, is not necessary and either module can be
    the master or slave.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start off by configuring the slave device. To do this connect one of the
    Arduinos to the computer, run the application that we wrote at the beginning of
    this section and then run through the command that we will outline in the next
    few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will want to do is to issue the test `AT` command to the
    Bluetooth module. The module should respond back with an `OK` message. If you
    do not get a response back, check to make sure that the serial console is configured
    to send both the NL and CR. If you receive an error response, try issuing the
    `AT` command again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are sure that the serial monitor and the Bluetooth module are talking,
    we will want to see what the UART settings are currently set to for this module.
    To do this send the `AT+UART?` command. For the examples in this chapter, we are
    going to assume that the UART settings are 9600 Baud, 0 stop bits, and 0 parity.
    If this is not how your module is configured then issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we want to do is to set the role of the device to a slave role.
    To do this, we issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will want to retrieve the address of this Bluetooth module. The
    following command will retrieve the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the address is written down because we will be using it when we configure
    the master device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands that we ran to configure the slave module are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Response** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT` | `OK` |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+UART?` | `+UART:9600,0,0` (if not, set it to this) |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ROLE=0` | `OK` |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ADDR?` | `+ADDR:{address}` |'
  prefs: []
  type: TYPE_TB
- en: Now let's configure the master. To do this, connect the other Arduino to the
    computer (remember to press and hold the button as you power up the module), run
    the code we wrote at the beginning of this section and issue the commands that
    we will go through in the next few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: As with the slave device, the first thing we will want to do is to issue the
    `AT` command to the Bluetooth module. The module should respond back with an `OK`
    message. If you do not get a response back, check to make sure that the serial
    console is configured to send both the NL and CR. If you receive an error response,
    try issuing the `AT` command again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will want to see what the UART settings are for the module. To do this
    send the `AT+UART?` command. For the examples in this chapter, we are going to
    assume that the UART settings are 9600 Baud, 0 stop bits, and 0 parity. If this
    is not how your module is configured then issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we want to do is to set the role of the device to a master role.
    To do this, we issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will want to set the connection mode to connect to a fixed address (mode
    0). To do this issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since we are telling the Bluetooth module to connect to a fixed address, we
    need to give it the address of the slave device we need it to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The question marks are the address of the slave device. When we queried the
    address of the slave device the address was returned separated with colons like
    this, `98d3:31:300e42`. When entering the address in the `BIND` command, the address
    needs to be separated by commas like this `98d3,31,300e42`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands that we used to configure the master device are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Response** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT` | `OK` |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+UART?` | `+UART:9600,0,0` (if not, set it to this) |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ROLE=1` | `OK` |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+CMODE=0` | `OK` |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+BIND=????,??,??????` (question marks are the address of the slave device)
    | `OK` |'
  prefs: []
  type: TYPE_TB
- en: Now if we reset both devices by recycling the power, the two Bluetooth modules
    should connect. Start off by recycling the power on the slave device, and you
    will see the LED blinking rapidly. Then recycle the power on the master and once
    the two devices connect the LED on both devices will blink rapidly twice, then
    turn off for two seconds and then repeat. This light sequence indicates that the
    two devices are connected.
  prefs: []
  type: TYPE_NORMAL
- en: If the devices do not connect, the most common mistake that is made is to type
    in the wrong address in the `AT+BIND` command. I would start off by checking that
    by running the `AT+BIND?` command and verifying the address is correct. If that
    is correct, then verify the `AT+CMODE`, and `AT+ROLE` commands ran properly by
    running the `AT+CMODE?` and `AT+ROLE?` commands. Now that we have the two Bluetooth
    modules connected let's go on to project two.
  prefs: []
  type: TYPE_NORMAL
- en: Project 2 – serial connection, sending data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, in order to see the data going from one device to the other,
    you will need two computers. One connected to the master device and one connected
    to the slave device. If you do not have two computers, it is still worth reading
    through this section to understand the protocol that we are creating because we
    will be using the same protocol for the third project as well.
  prefs: []
  type: TYPE_NORMAL
- en: When we are streaming data or sending large amounts of variable length data,
    we need some way to tell the receiving device where a new message starts and where
    it ends. Luckily for us, there are built-in ASCII codes that allow for this. The
    `0x01` **SOH** (**Start Of Heading**) and the `0x04` **EOT** (**End Of Transmission**)
    codes can be used to tell the receiving device when a message starts and when
    it ends.
  prefs: []
  type: TYPE_NORMAL
- en: In this project and the next one, the protocol that we will define is when the
    receiving device receives a `0x01` ASCII character, it will know that a new message
    has started. When it receives a `0x04` ASCII character, it will know that the
    message has ended and everything between the `0x01` and the `0x04` characters
    are the message itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with ASCII codes, the following chart shows the ASCII
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b021a1bb-fa89-4560-947b-5e88de99afef.png)'
  prefs: []
  type: TYPE_IMG
- en: Basically, when we transmit character data between two Bluetooth Classic devices,
    we are actually sending the ASCII codes. For example, if we send the word "Dog,"
    we are actually sending three bytes of data, which are `0x44` (D), `0x111` (o),
    and `0x67` (g). With the protocol that we are defining, if we send the word Dog,
    we would send five bytes of data because we need to start with the `0x01` character
    and end with the `0x04` character. The five bytes that we would send would be
    `0x01`, `0x44`, `0x111`, `0x67` and `0x04`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the code to send and receive the messages between the two
    Bluetooth modules. This code will run on both the master and the slave devices.
    We will start off by including the `SoftwareSerial` library in the project and
    creating an instance of the `SoftwareSerial` type. The following code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first line includes the `SoftwareSerial` library in the project, and then
    the next line creates an instance of the `SoftwareSerial` type. The third line
    creates a global variable that will define when a new message is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will need to configure the serial console and the `HC05` `SoftwareSerial`
    instance in the `setup()` method. The following code will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we start off by configuring the serial console with a baud rate
    of 9600\. We then define that the digital 9 pin will be an output pin and set
    it to high. The digital 9 pin is connected to the key pin on the HC-05 Bluetooth
    module. We pull this pin high to enable it. We configure the `HC05` instance of
    the `SoftwareSerial` type with a baud rate of 9600 and then print a message to
    the serial console letting the user know that everything is configured and ready
    to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loop()` function will need to monitor both the serial console and the
    `HC05` `SoftwareSerial` instance for new data coming in. If it receives new data
    from the serial console, it will need to transmit it out through the Bluetooth
    module, and if it receives new data from the Bluetooth module, it will need to
    display the data in the serial console. The following code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we check to see if there is any data available from the `HC05`
    `SoftwareSerial` instance and if so, it is read into the `val` variable. The `val`
    variable is then written to the serial console. We then see if the `val` variable
    is equal to `0x04` and if so we write a carriage return and line feed to the serial
    console because that particular message has ended.
  prefs: []
  type: TYPE_NORMAL
- en: Now we check to see if there is any data available from the serial console and
    if so, we check to see if we are starting a new message by checking if the `newMessage`
    variable is equal to `true`. If the `newMessage` variable is equal to `true`,
    we write a `0x01` character to the `HC05` `SoftwareSerial` instance and then set
    the `newMessage` variable to `false`. We then read the character from the serial
    console and see if it is equal to the tilde (`~`) character. We are going to use
    the tilde character to specify that the message has ended therefore when the user
    types in a tilde we will write the `0x04` character to the `HC05` `SoftwareSerial`
    instance and set the `newMessage` variable to `true` because this particular message
    has ended. If the character does not equal a tilde, we write the character to
    the `SoftwareSerial` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we run this code on both the master and slave device, whatever we type
    into the serial console on one device will be transmitted to the other device
    through the Bluetooth modules. The message will continue to be printed on one
    line of the serial console until the user types in a tilde signifying the end
    of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting text back and forth is good but we can do that with Bluetooth LE
    as we saw in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth
    LE*. Let's do something that is a bit more useful by looking at how this can be
    used as a remote control by connecting an Arduino joystick module to one of the
    devices and streaming the joystick position to the other device.
  prefs: []
  type: TYPE_NORMAL
- en: Project 3 – joystick remote control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not connected the joystick breakout module to one of the Arduino's
    you will need to do it before you start this project. Once the joystick breakout
    module is connected to the Arduino, we will write the code that will read the
    position of the joystick and transmit it to the other Arduino via the HC-05 Bluetooth
    modules; however, before we do this we need to figure out the protocol that we
    are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will use the same protocol that we used in the previous
    project, where the message will start off with a `0x01` byte and end with a `0x04`
    byte and everything in between is the message itself. The message itself will
    contain two bytes, one that indicates the *x* position of the joystick and one
    that indicates the *y* position. Therefore, a complete transmission will contain
    a total of four bytes likes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the protocol that will be used to transmit the joystick position
    from one Arduino to the other let's begin by writing the code that will run on
    the Arduino that the joystick breakout module is connected to. The position of
    the joystick is read through the two analog pins that are connected to it. We
    also need to bring the SEL pin, which is connected to the digital 2 pin, high.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will need to do in the code is to include the `SoftwareSerial`
    library for the Bluetooth module, create an instance of the `SoftwareSerial` type
    and define the pins that the joystick module is connected to. The following code
    will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we define the SEL pin for the joystick to be the digital 2 pin,
    the key pin on the Bluetooth module to be the digital 9 pin and the *x*/*y* axes
    to be the analog 0 and 1 pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `setup()` function we will need bring both the `SW_PIN` and the `BT_PIN`
    high and initialize both the serial console and the instance of the `SoftwareSerial`
    instance. Here is the code for the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code should look very familiar by now. The first four lines initialize
    the digital pins and pull them high. The next two lines initialize the `SoftwareSerial`
    instance and the serial console with baud rates of 9600\. Finally, a message is
    printed to the serial console letting the user know that everything is ready to
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `loop()` function, we will need to read the position of the joystick
    and then write the message to the Bluetooth module. The following code will do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines read the *x* and *y* axes of the joystick module. When reading
    an analog pin the values that are returned range from 0 to 1024; however, we only
    want to send a single byte to represent the position of the joystick. A single
    byte can have a range from 0 to 255, therefore we divide the value from the analog
    read by `4`.
  prefs: []
  type: TYPE_NORMAL
- en: After we retrieve the values for the *x* and *y* axes of the joystick, we need
    to send the message through the Bluetooth module with these values. The next four
    lines of code writes a `0x01` (SOH), the value of the *x* axis, the value of the
    *y *axis and finally a `0x04` (EOT). After the message is sent, we pause for 500
    milliseconds and then loops back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the code that will run on the Arduino that the joystick is
    connected to, we need to write the code that will run on the Arduino that will
    receive the data. This code will need to start off by including the `SoftwareSerial`
    library for the Bluetooth module and create an instance of the `SoftwareSerial`
    type. We will also need to define a buffer that will be used to store the data
    as it comes in through the Bluetooth module. The following code will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by including the `SoftwareSerial` library and then defines
    the max size for the input buffer, which is `255`. While we could limit the size
    of the buffer to four because we know that each message will be four bytes in
    size, we always want to have extra space in the buffer, especially with wireless
    communication, in case the message gets messed up in transmission. If this was
    a production system, I would probably limit the size of the buffer to 12 or 16
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: We define that the key pin on the Bluetooth module is connected to the digital
    9 pin on the Arduino. We then create an instance of the `SoftwareSerial` type
    and a `byte` array for the input buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `setup()` function we will initialize the serial console and the `SoftwareSerial`
    instance. We will also need to pull the key pin for that Bluetooth module high.
    The following code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `loop()` function we will want to continuously read the input from
    the Bluetooth module until we receive and EOT (`0x04`) byte. As we read the data
    in, it will be stored in the byte array and once the `0x04` byte is read in we
    will print out the message and then loop back. Here is the code for the `loop()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function starts off by using the `memset()` function to initialize the
    buffer with all zeros. We then create an integer variable that will count how
    many bytes are read in.
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop is used to continuously loop until the maximum number of bytes
    have been read. Within the `while` loop, we use the `available()` function from
    the `HC05` `SoftwareSerial` instance to see if there are any values to read from
    the Bluetooth module. If there is a value to read, we use the `read()` function
    to read the value in, store it in the `buf` byte array and increments the counter.
    We then check to see if the value that was read in is equal to `0x04` and if so
    we use the `break` statement to break out of the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a `for` loop that will loop through the values in the buffer
    and print them to the serial console. If we execute the code on both Arduinos
    and move the joystick around, we will see output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82c6a280-e172-4231-9b8b-54cf6aca98dd.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the output, each message starts with the `0x01` byte and
    ends with the `0x04` byte. In between these two bytes are the joystick position
    on the *x* axis and the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the packets are supposed to be four bytes in length. In a production
    environment we would want to toss out any messages that were not four bytes in
    length because we know that if the message is not four bytes in length, then the
    message got messed up in transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also use a checksum to ensure that the message was received correctly.
    A checksum is some value that is calculated using the data that is sent. One of
    the easiest ways to generate a checksum is to add up all of the data bytes, storing
    the value in a byte that will cause the value to wrap around when it is greater
    than 255\. Here is an example of a function that would generate a checksum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a pointer to a `byte` array and the size of the array as
    parameters. It then loops through the array and adds each byte to the checksum
    and then returns the value. A byte can have a maximum value of 255, therefore
    once the value gets above 255 the value will loop around. For example, if the
    checksum byte had a value of 252 and a value of 10 was added to it, the checksum
    value would then be 7\. We could then send the checksum before the `0x04` value,
    and the device that receives the message could verify the message integrity by
    calculating the checksum on the receiving end and verifying that the two values
    match.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a lot about Bluetooth Classic, starting with a brief
    introduction on how the radio works and the network topology for Bluetooth Classic
    connections. We demonstrated how we could configure the Bluetooth HC-05 Bluetooth
    module as both a slave and master. We also saw how we could configure the Bluetooth
    modules to connect to each other on startup automatically. Finally, we saw how
    we could stream data from one device to another using Bluetooth classic.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth LE*,
    and this chapter we looked at two different Bluetooth technologies, but the question
    may still be when to use which one. When we have a use case that defines that
    we want one device to ask another device for information periodically, like a
    weather station, we generally want to use Bluetooth LE. When we want to stream
    data from one device to another without waiting for the receiving device to ask
    for it, we generally want to use Bluetooth Classic.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this book, we have looked at many different items from a
    microcontroller to sensors and from motors to wireless communication modules.
    The idea was to expose you to a number of different items to hopefully give you
    ideas for your own projects. The best thing about the Arduino, is the projects
    that you do are only limited by your imagination, so start imagining what super
    awesome projects you can do and then create them.
  prefs: []
  type: TYPE_NORMAL
