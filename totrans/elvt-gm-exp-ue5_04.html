<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer149">
<h1 class="chapter-number" id="_idParaDest-77"><a id="_idTextAnchor099"/>4</h1>
<h1 id="_idParaDest-78"><a id="_idTextAnchor100"/>Getting Started with Player Input<a id="_idTextAnchor101"/></h1>
<p>In the previous chapter, we created our C++ class, which inherits from the <strong class="source-inline">Character</strong> class, and added all the necessary <strong class="source-inline">Actor</strong> components to be able to see the game from the character’s perspective, as well as being able to see the character itself. We then created a <strong class="source-inline">Blueprint</strong> class that inherits from that C++ class in order to visually set up all of its necessary components.</p>
<p>In this chapter, we will be looking at these topics in more depth, as well as covering their C++ usage. We will learn about how player input works in UE5, how the engine handles input events (<em class="italic">key presses and releases</em>), and how we can use them to control logic in our game.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding Input Actions  and Contexts</li>
<li>Processing Player Input</li>
<li>Pivoting the camera around the character</li>
</ul>
<p>By the end of this chapter, you will know about <strong class="bold">Input Actions</strong> and <strong class="bold">Input Contexts</strong>, how to create and modify them, how to listen to each of those mappings, and how to execute in-game actions when they’re pressed and released.</p>
<p class="callout- eading">Note</p>
<p class="callout">In this chapter, we will be using an alternative version of the <strong class="source-inline">Character</strong> blueprint we created called <strong class="source-inline">BP_MyTPC</strong> in the previous chapter. This chapter’s version will have the default UE5 Mannequin mesh, not the one from Mixamo.</p>
<p>Let’s start this chapter by getting to know how UE5 abstracts the keys pressed by a player to make it easier for you to be notified of those events.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>The project for this chapter can be found in the Chapter04 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor103"/>Understanding Input Actions and Contexts</h1>
<p>Player input is the thing that distinguishes video games from other forms of entertainment <a id="_idIndexMarker311"/>media – the fact that they’re interactive. For a video game to be interactive, it must take into account a player’s input. Many games do this by allowing the player to control a virtual character that acts upon the virtual world it’s in, depending on the keys and buttons that the player presses, which is exactly what we’ll be doing in this chapter.</p>
<p class="callout- eading">Note</p>
<p class="callout">It’s important to note that UE5 has two input systems – the Legacy Input System, used since the start of UE4, and the new Enhanced Input System, introduced only in the last version of UE5 as an experimental system and now as a complete plugin in UE5. We will be using the new Enhanced Input System in this book. If you wish to know more about UE5’s Legacy <a id="_idIndexMarker312"/>Input System, you can do so by accessing this link: <a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/">https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/</a></p>
<p>Most game development tools nowadays allow you to abstract keypresses into <strong class="bold">actions</strong>, which allow you to associate a name (for example, <em class="italic">Jump</em>) with several different player <a id="_idIndexMarker313"/>inputs (pressing a button, flicking a thumbstick, and so on). In UE5, the way in which you can specify this is through the use of <strong class="bold">Input Actions</strong> combined with <strong class="bold">Input Contexts </strong>(also referred to as <strong class="bold">Input Mapping Contexts</strong>).</p>
<p><strong class="bold">Input Contexts</strong> contain <strong class="bold">Input Actions</strong> that are associated with them, along with which keys will execute them, and <strong class="bold">Input Actions</strong> contain specifications as to how they will be executed. The combination of both of these assets allows you to do something when an <strong class="bold">Input Action</strong> is triggered but also easily change how that <strong class="bold">Input Action</strong> is triggered and by which keys.</p>
<p>In order to better understand how <strong class="bold">Input Contexts</strong> and <strong class="bold">Input Actions</strong> work together, let’s think of a game, such as <em class="italic">GTA</em>, where you have different gameplay contexts in which you control different people/objects with different keys.</p>
<p>For instance, when you’re controlling your player character running around the city, you use the movement keys to move the character around, and you use a different key to make your character jump. However, when you enter a car, the controls will change. The movement keys will now steer the car instead, and the same key that was used for jumping will now be used, for instance, for braking.</p>
<p>In this example, you <a id="_idIndexMarker314"/>have two different Input Contexts (controlling the character and controlling the vehicle), each with its own set of Input Actions. Some <a id="_idIndexMarker315"/>of those Input Actions are triggered by the same key, but that’s fine, because they’re done in different Input Contexts (for example, using the same key to cause your character to jump and to stop the vehicle).</p>
<p>Before we start looking into some of the Enhanced Input-related assets, because it’s a plugin, we’ll have to enable it. To enable it, follow these steps:</p>
<ol>
<li>Go to <strong class="bold">Edit</strong> | <strong class="bold">Plugins</strong> | <strong class="bold">Built-In</strong> | <strong class="bold">Input</strong> and tick the <strong class="bold">Enabled</strong> box for the <strong class="bold">Enhanced Input</strong> plugin. After you have done so, you’ll be prompted to restart the editor.   </li>
<li>Click the <strong class="bold">Restart Now</strong> button when this happens. After the editor restarts, and now that the <strong class="bold">Enhanced Input</strong> plugin has been enabled, you’ll need to tell the engine to use its classes to handle the player’s input. </li>
<li>To do this, go to <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Engine</strong> | <strong class="bold">Input</strong>, and then, inside the <strong class="bold">Default Classes</strong> category (near the end), set the <strong class="bold">Default Player Input Class</strong> property to <strong class="source-inline">EnhancedPlayerInput</strong> and the <strong class="bold">Default Input Component Class</strong> property to <strong class="source-inline">EnhancedInputComponent</strong>. Now that the <strong class="bold">Enhanced Input</strong> plugin has been enabled and its classes are being used, we can proceed with this chapter’s content.</li>
</ol>
<p>In order to know more about Input Contexts and Input Actions, let’s inspect them. Follow these steps:</p>
<ol>
<li value="1">Right-click on the <strong class="bold">Context Browser</strong> and select <strong class="bold">Input</strong> | <strong class="bold">Input Action</strong>. Name the newly created Input Ac<a id="_idTextAnchor104"/>tion <strong class="source-inline">IA_Movement</strong>, and then open it. You should see the Input Action window, which has the following properties:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer129">
<img alt="Figure 4.1 – The Action window" height="348" src="image/Figure_4.01_B18531.jpg" width="839"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Action window</p>
<p>Now, let’s <a id="_idIndexMarker316"/>take a look at its options in detail:</p>
<ul>
<li><strong class="bold">Consume Input</strong>: This specifies whether this Input Action will block other actions that are triggered by the same key simultaneously. If it’s set to <strong class="source-inline">true</strong>, another Input Action with a lower priority that will be triggered by the same key won’t be triggered.</li>
<li><strong class="bold">Trigger when Paused</strong>: This specifies whether this Input Action can be triggered if the game is paused.</li>
<li><strong class="bold">Reserve All Mappings</strong>: This specifies whether a higher priority Input Action will be triggered if it’s triggered by the same key.</li>
<li><strong class="bold">Value Type</strong>: This specifies the type of value for this Input Action. Its values can be the following:<ul><li><strong class="bold">Digital (bool)</strong>: Used for Input Actions that have a binary state – for instance, a jumping Input Action, in which the player is either pressing it or not, would use this value.</li><li><strong class="bold">Axis 1D (float)</strong>: Used for Input Actions that have a scalar state in one dimension – for instance, accelerating in a racing game, where you can use the gamepad’s triggers to control the throttle.</li><li><strong class="bold">Axis 2D (Vector2D)</strong>: Used for Input Actions that have a scalar state in two dimensions – for instance, actions for moving your character, which are done using two axes (the forward axis and the sideways axis), would be good candidates for using this value.</li></ul></li>
<li><strong class="bold">Axis 3D (Vector)</strong>: Used for <a id="_idIndexMarker317"/>Input Actions that have a scalar state in three dimensions. This value isn’t as likely to be used as the others, but you may find a use for it.</li>
<li><strong class="bold">Triggers</strong>: This specifies the key events that will execute this Input Action. The values for this can be a combination of the following:<ul><li><strong class="bold">Chorded Action</strong>: The Input Action is triggered as long as a different specified Input Action is also triggered.</li><li><strong class="bold">Down</strong>: The Input Action is triggered for every frame that the key exceeds the actuation threshold.</li></ul></li>
</ul>
<p class="callout- eading">Note</p>
<p class="callout">The actuation threshold is the value at which a key’s input will be considered for executing an action. Binary keys (like the ones on a keyboard) have an input value of either <strong class="source-inline">0</strong> (not pressed) or <strong class="source-inline">1</strong> (pressed), while scalar keys, like the triggers on a gamepad, have an input value that goes continuously from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> or, like the individual axes of the thumbsticks, that go continuously from <strong class="source-inline">–1</strong> to <strong class="source-inline">1</strong>.</p>
<ul>
<li><strong class="bold">Hold</strong>: The Input Action is triggered when the key has exceeded the actuation threshold for a specified amount of time. You can optionally specify whether it’s triggered once or for every frame.</li>
<li><strong class="bold">Hold and Release</strong>: The Input Action is triggered when the key has exceeded the actuation threshold for a specified amount of time and then stops exceeding that actuation threshold.</li>
<li><strong class="bold">Pressed</strong>: The Input Action is triggered once the key exceeds the actuation threshold and won’t be triggered again until it’s released.</li>
<li><strong class="bold">Pulse</strong>: The Input Action is triggered at a specified interval as long as the key exceeds the actuation threshold. You can specify whether the first pulse triggers the Input Action and whether there’s a limit to how many times it can be called.</li>
<li><strong class="bold">Released</strong>: The Input Action is triggered once the key stops exceeding the actuation threshold.</li>
<li><strong class="bold">Tap</strong>: The Input Action <a id="_idIndexMarker318"/>is triggered when the key starts and then stops exceeding the Actuation Threshold, as long as it’s done within the specified amount of time.</li>
<li><strong class="bold">Modifiers</strong>: This specifies the ways in which this Input Action’s input will be modified:</li>
<li><strong class="bold">Dead Zone</strong>: The key’s input will be read as <strong class="source-inline">0</strong> if it’s lower than the lower threshold and as <strong class="source-inline">1</strong> if it’s higher than the upper threshold.</li>
<li><strong class="bold">FOV Scaling</strong>: The key’s input will be scaled alongside the FOV (if the FOV increases, the key’s input will increase, and vice versa).</li>
<li><strong class="bold">Modifier Collection</strong>: The key’s input will be modified according to the specified list of modifiers.</li>
<li><strong class="bold">Negate</strong>: The key’s input will be inverted.</li>
<li><strong class="bold">Response Curve – Exponential</strong>: An exponential curve will be applied on the key’s input.</li>
<li><strong class="bold">Response Curve – User Defined</strong>: A user-defined curve will be applied on the key’s input.</li>
<li><strong class="bold">Scalar</strong>: The key’s input will be scaled at each axis according to the scalar specified.</li>
<li><strong class="bold">Smooth</strong>: The key’s input will be smoothed out across multiple frames.</li>
<li><strong class="bold">Swizzle Input Axis Values</strong>: The key’s axis order will be switched.</li>
<li><strong class="bold">To World Space</strong>: The key’s axes will be converted toworld space.</li>
</ul>
<ol>
<li value="2"> After doing this, right-click on <strong class="bold">Context Browser</strong> and select <strong class="bold">Input</strong> | <strong class="bold">Input Context</strong>. Name the newly created<a id="_idTextAnchor105"/> input context <strong class="source-inline">IC_Character</strong> and open it.</li>
</ol>
<p>You should see the Input Action window pop up. Note that it has an empty <strong class="bold">MAPPINGS</strong> property. </p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<img alt="Figure 4.2 – The MAPPINGS property " height="99" src="image/Figure_4.02_B18531.jpg" width="188"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The MAPPINGS property</p>
<ol>
<li value="3">Let’s now <a id="_idIndexMarker319"/>add a new mapping. Press the <strong class="bold">+</strong> button next to the <strong class="bold">Mappings</strong> property. You’ll notice a new property show up where you can specify the Input Action this mapping will be associated with.</li>
</ol>
<p>This action can be triggered by several different keys, each of which can have its own triggers and modifiers, which work the same as the corresponding properties in the Input Action asset.</p>
<p class="callout- eading">Note</p>
<p class="callout">When it comes to modifying the <strong class="bold">Triggers</strong> and <strong class="bold">Modifiers</strong> properties, the usual practice is to change the modifiers in the Input Context asset and the triggers in the Input Action asset.</p>
<p class="callout- eading">Note</p>
<p class="callout">We will not be using these properties in this book, but for each Input Mapping Context, you can specify whether it can be modified by a player by ticking the <strong class="bold">Is Player Mappable</strong> property and specifying <strong class="bold">Player Mappable Options</strong>.</p>
<p>When we generated the <strong class="source-inline">Third Person</strong> template project back in <a href="B18531_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Unreal Engine</em></p>
<p>, it came with some inputs already configured, which were the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys, as well as the <strong class="source-inline">left thumbstick</strong> for movement, the <em class="italic">spacebar</em> key, and the <strong class="source-inline">gamepad bottom face</strong> button for jumping.</p>
<p>For context, let’s <a id="_idIndexMarker320"/>consider an Xbox One controller, which can be broken down into the following:</p>
<ul>
<li>The <strong class="bold">left analog stick</strong>, usually used for controlling movement in games</li>
<li>The <strong class="bold">D-pad</strong>, which can control movement and also has a variety of other uses</li>
<li>The <strong class="bold">right analog stick</strong>, usually used for controlling the camera and view perspective</li>
<li>The <strong class="bold">face buttons</strong> (<strong class="bold">X</strong>, <strong class="bold">Y</strong>, <strong class="bold">A</strong>, and <strong class="bold">B</strong>), which can have various uses depending on the game but usually allow the player to perform actions in the game world</li>
<li>The <strong class="bold">bumpers and triggers</strong> (<strong class="bold">LB</strong>, <strong class="bold">RB</strong>, <strong class="bold">LT</strong>, and <strong class="bold">RT</strong>), which can be used for actions such as aiming and shooting or accelerating and braking</li>
</ul>
<p>Now that we’ve learned how to set up <strong class="source-inline">Input Actions</strong>, let’s add some of them in the next exercise.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor106"/>Exercise 4.01 – creating the movement and jump input actions</h2>
<p>In this <a id="_idIndexMarker321"/>exercise, we’ll be adding the mappings <a id="_idIndexMarker322"/>for the <em class="italic">Movement</em> and <em class="italic">Jump</em> Input Actions. </p>
<p>To achieve this, follow these steps:</p>
<ol>
<li value="1">Open the <strong class="bold">IA_Movement</strong> Input Action.</li>
<li>Set its value type as <strong class="bold">Axis2D</strong>. We’ll make this an Input Action of type <strong class="bold">Axis2D</strong> because the character’s movement is done on two axes – the forward axis (the <em class="italic">Y</em> axis for this Input Action) and the sideways or right axis (the <em class="italic">X</em> axis for this Input Action): </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer131">
<img alt="Figure 4.3 – The Value Type options " height="345" src="image/Figure_4.03_B18531.jpg" width="525"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The Value Type options</p>
<ol>
<li value="3">Add a <a id="_idIndexMarker323"/>new trigger of type <strong class="bold">Down</strong> with <a id="_idIndexMarker324"/>an actuation threshold of <strong class="bold">0,1</strong>. This will ensure that this Input Action is called when one of its keys has an actuation threshold of at least <strong class="bold">0,1</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer132">
<img alt="Figure 4.4 – The Down trigger " height="139" src="image/Figure_4.04_B18531.jpg" width="907"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The Down trigger</p>
<ol>
<li value="4">Open the <strong class="bold">IC_Character</strong> Input Context.</li>
<li>Click the <strong class="bold">+</strong> icon to the right of the <strong class="bold">Mappings</strong> property to create a new mapping:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer133">
<img alt="Figure 4.5 – Adding a new action mapping " height="150" src="image/Figure_4.05_B18531.jpg" width="219"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Adding a new action mapping</p>
<ol>
<li value="6">When you’ve done so, you should see a new empty mapping with its properties either empty or set to <strong class="bold">None</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer134">
<img alt="Figure 4.6 – The default settings of a new action mapping " height="179" src="image/Figure_4.06_B18531.jpg" width="469"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The default settings of a new action mapping</p>
<ol>
<li value="7">Set the <a id="_idIndexMarker325"/>Input Action of this mapping (the <a id="_idIndexMarker326"/>first property that’s set to <strong class="bold">None</strong>) to <strong class="bold">IA_Movement</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer135">
<img alt="Figure 4.7 – The new IA_Movement mapping " height="178" src="image/Figure_4.07_B18531.jpg" width="452"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The new IA_Movement mapping</p>
<ol>
<li value="8">Set the first key in this mapping to <strong class="bold">Gamepad Left Thumbstick Y-Axis</strong>.</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer136">
<img alt="Figure 4.8 – The Gamepad Left Thumbstick Y-Axis key " height="135" src="image/Figure_4.08_B18531.jpg" width="411"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The Gamepad Left Thumbstick Y-Axis key</p>
<p class="callout- eading">Note</p>
<p class="callout">If the key you want to set is from one of the input devices you have connected (for example, mouse, keyboard, or gamepad), you can click the button to the left of the key dropdown and then press the actual key you want to set, instead of searching for it in the list. For instance, if you want to set a mapping to use the <em class="italic">F</em> key on the keyboard, you can click that button, then press the <em class="italic">F</em> key, and then that key will be set for that mapping.</p>
<p>Because <a id="_idIndexMarker327"/>we want this key to control <a id="_idIndexMarker328"/>the Input Action’s <em class="italic">Y</em> axis instead of its <em class="italic">X</em> axis, we need to add the <strong class="bold">Swizzle Input Axis Values</strong> modifier with the <strong class="bold">YXZ</strong> value.</p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<img alt="Figure 4.9 – The Swizzle Input Axis modifier " height="124" src="image/Figure_4.09_B18531.jpg" width="668"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – The Swizzle Input Axis modifier</p>
<ol>
<li value="9">Click the <strong class="bold">+</strong> button to the right of the Input Action set for this mapping in order to add a new key and execute that Input Action:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer138">
<img alt="Figure 4.10 – The + button to the right of IA_Movement " height="80" src="image/Figure_4.10_B18531.jpg" width="434"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – The + button to the right of IA_Movement</p>
<ol>
<li value="10">Set the new key to <strong class="bold">Gamepad Left Thumbstick X-Axis</strong>. Because this will already control the movement Input Action’s <em class="italic">X</em> axis, we won’t need to add any modifiers.</li>
<li>Add <a id="_idIndexMarker329"/>another key to the Input Action, this <a id="_idIndexMarker330"/>time the <em class="italic">W</em> key. Because this key will be used for moving forward, and therefore use the <em class="italic">Y</em> axis, it will need the same modifier that we added before – the <strong class="bold">Swizzle Input Axis</strong> modifier with the <strong class="bold">YXZ</strong> value.</li>
<li>Add another key to the Input Action, this time the <em class="italic">S</em> key. Because this key will be used for moving backward, and therefore use the <em class="italic">Y</em> axis, it will need the same modifier we added before – the <strong class="bold">Swizzle Input Axis</strong> modifier with the <strong class="bold">YXZ</strong> value, as well as a new modifier – <strong class="bold">Negate</strong>. The reason for this is that we want the value of the movement Input Action to be <strong class="source-inline">–1</strong> on the <em class="italic">Y</em> axis when this key is pressed (that is, when its input is <strong class="source-inline">1</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer139">
<img alt="Figure 4.11 – The Swizzle Input Axis Values and Negate modifiers " height="220" src="image/Figure_4.11_B18531.jpg" width="618"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – The Swizzle Input Axis Values and Negate modifiers</p>
<ol>
<li value="13">Add another key to the Input Action, this time the <em class="italic">D</em> key. Because this key will be used for moving right, and therefore use the positive end of the <em class="italic">X</em> axis, it won’t need any modifiers.</li>
<li>Add <a id="_idIndexMarker331"/>another key to the Input Action, this <a id="_idIndexMarker332"/>time the <em class="italic">A</em> key. Because this key will be used for moving left, and therefore use the negative end of the <em class="italic">X</em> axis, it will need the <strong class="source-inline">Negate</strong> modifier, just like the <em class="italic">S</em> key.</li>
<li>Create a new Input Action asset called <strong class="source-inline">IA_Jump</strong>, and then open it.</li>
<li>Add a <strong class="bold">Down</strong> trigger and leave its actuation threshold as <strong class="bold">0,5</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer140">
<img alt="Figure 4.12 – The Down trigger " height="112" src="image/Figure_4.12_B18531.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – The Down trigger</p>
<ol>
<li value="17">Go back to the <strong class="bold">IC_Character</strong> Input Context asset and add a new Input Action to the <strong class="bold">Mapping</strong>s property – this time, the <strong class="bold">IA_Jump</strong> Input Action we just created:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer141">
<img alt="Figure 4.13 – The IA_Jump mapping " height="147" src="image/Figure_4.13_B18531.jpg" width="806"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – The IA_Jump mapping</p>
<ol>
<li value="18">Add two keys to this mapping – <strong class="bold">Space Bar</strong> and <strong class="bold">Gamepad Face Button Bottom</strong>. If you’re using an Xbox controller, this will be the <em class="italic">A</em> button, and if you’re using a PlayStation controller, this will be the <em class="italic">X</em> button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer142">
<img alt="Figure 4.14 – The IA_Jump mapping keys " height="116" src="image/Figure_4.14_B18531.jpg" width="429"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – The IA_Jump mapping keys</p>
<p>And with <a id="_idIndexMarker333"/>those steps completed, we’ve <a id="_idIndexMarker334"/>completed this chapter’s first exercise, where you’ve learned how you can specify Input Action Mappings in UE5, allowing you to abstract which keys are responsible for which in-game actions.</p>
<p>Let’s now take a look at how UE5 handles player input and processes it within the game.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor107"/>Processing Player Input</h1>
<p>Let’s think <a id="_idIndexMarker335"/>about a situation where the player presses the <strong class="bold">Jump</strong> Input Action, which is associated with the <em class="italic">spacebar</em> key, to get the player character to jump. Between the moment the player presses the <em class="italic">Spacebar</em> key and the moment the game makes the player character jump, quite a few things have to happen to connect those two events.</p>
<p>Let’s take a look at all of the necessary steps that lead from one event to the other:</p>
<ol>
<li value="1"><strong class="source-inline">Hardware Input</strong>: The player presses the <em class="italic">spacebar</em> key. UE5 will be listening to this keypress event.</li>
<li>The <strong class="source-inline">PlayerInput</strong> class: After the key is pressed or released, this class will translate that key into an Input Action. If there is a corresponding Input Action, it will notify all classes that are listening to the action that it was just pressed, released, or updated. In this case, it will know that the <em class="italic">Spacebar</em> key is associated with the <em class="italic">Jump</em> Input Action.</li>
<li>The <strong class="source-inline">Player Controller</strong> class: This is the first class to receive these keypress events, given that it’s used to represent a player in the game.</li>
<li>The <strong class="source-inline">Pawn</strong> class: This class (and consequently the <strong class="source-inline">Character</strong> class, which inherits from it) can also listen to those keypress events, as long as they are possessed by a Player Controller. If so, it will receive these events after that class. In this chapter, we will be using our <strong class="source-inline">Character</strong> C++ class to listen to action and axis events.</li>
</ol>
<p>Now that <a id="_idIndexMarker336"/>we know how UE5 handles player inputs, let’s see how we can listen to Input Actions in C++ in the next exercise.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor108"/>Exercise 4.02 – listening to movement and jump input actions</h2>
<p>In this exercise, we will register the Input Actions we created in the previous section with <a id="_idIndexMarker337"/>our character class by binding them <a id="_idIndexMarker338"/>to specific functions in our character class using C++.</p>
<p>The main way for a <strong class="bold">Player Controller</strong> or <strong class="bold">Character</strong> to listen to Input Actions is by registering the Input Action delegates using the <strong class="source-inline">SetupPlayerInputComponent</strong> function. The <strong class="source-inline">MyThirdPersonChar</strong> class should already have a declaration and an implementation for this function. Let’s have our character class listen to those events by following these steps:</p>
<ol>
<li value="1">Open the <strong class="source-inline">MyThirdPersonChar</strong> class header file in Visual Studio, and make sure there’s a declaration for a <strong class="source-inline">protected</strong> function called <strong class="source-inline">SetupPlayerInputComponent</strong> that returns nothing and receives a <strong class="source-inline">class UInputComponent* PlayerInputComponent</strong> property as a parameter. This function should be marked as both <strong class="source-inline">virtual</strong> and <strong class="source-inline">override</strong>:<p class="source-code">virtual void SetupPlayerInputComponent(class UInputComponent*</p><p class="source-code">PlayerInputComponent) override;</p></li>
<li>Add a declaration for a <strong class="source-inline">public</strong> <strong class="source-inline">class UInputMappingContext*</strong> property called <strong class="source-inline">IC_Character</strong>. This property must be a <strong class="source-inline">UPROPERTY</strong> and have the <strong class="source-inline">EditAnywhere</strong> and <strong class="source-inline">Category = Input</strong> tags. This will be the Input Context we’ll be adding for the character’s input:<p class="source-code">UPROPERTY(EditAnywhere, Category = Input)</p><p class="source-code">class UInputMappingContext* IC_Character;</p></li>
<li>After that, we’ll need to add the Input Actions to listen for the character’s input. Add three <strong class="source-inline">public</strong> <strong class="source-inline">class UInputAction*</strong> properties, all of which must be <strong class="source-inline">UPROPERTY</strong> and have the <strong class="source-inline">EditAnywhere</strong> and <strong class="source-inline">Category = Input</strong> tags. Those two properties will be called the following:<ul><li><strong class="source-inline">IA_Move</strong><p class="source-code"><strong class="source-inline">IA_Jump</strong>UPROPERTY(EditAnywhere, Category = Input)</p><p class="source-code">class UInputAction* IA_Move;</p><p class="source-code">UPROPERTY(EditAnywhere, Category = Input)</p><p class="source-code">class UInputAction* IA_Jump</p></li></ul></li>
<li>Open <a id="_idIndexMarker339"/>this class’s <a id="_idIndexMarker340"/><strong class="source-inline">source</strong> file and make sure that this function has an implementation:<p class="source-code">void AMyThirdPersonChar::SetupPlayerInputComponent(class </p><p class="source-code">UInputComponent* PlayerInputComponent)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Because in UE5 you can use either the legacy Input Component or the Enhanced Input Component, we need to account for this. Inside the previous function’s implementation, start by casting the <strong class="source-inline">PlayerInputComponent</strong> parameter to the <strong class="source-inline">UEnhancedInputComponent</strong> class and saving it inside a new <strong class="source-inline">EnhancedPlayerInputComponent</strong> property of type <strong class="source-inline">UEnhancedInputComponent*</strong>:<p class="source-code">UEnhancedInputComponent* EnhancedPlayerInputComponent =</p><p class="source-code">Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent);</p></li>
</ol>
<p>Because we’ll be using <strong class="source-inline">UEnhancedInputComponent</strong>, we need to include it:</p>
<p class="source-code">#include "EnhancedInputComponent.h"</p>
<ol>
<li value="6">If it’s not <strong class="source-inline">nullptr</strong>, cast the <strong class="source-inline">Controller</strong> property to <strong class="source-inline">APlayerController</strong> and save it in a local <strong class="source-inline">PlayerController</strong> property:<p class="source-code">if (EnhancedPlayerInputComponent != nullptr)</p><p class="source-code">{</p><p class="source-code"> APlayerController* PlayerController =</p><p class="source-code"> Cast&lt;APlayerController&gt;(GetController());</p><p class="source-code">}</p></li>
</ol>
<p>If <a id="_idIndexMarker341"/>the newly created <strong class="source-inline">PlayerController</strong> property isn’t <strong class="source-inline">nullptr</strong>, then we’ll need to fetch <strong class="source-inline">UEnhancedLocalPlayerSubsystem</strong> so that we can tell it to add the <strong class="source-inline">IC_Character</strong> Input Context and activate its Input Actions.</p>
<ol>
<li value="7">To <a id="_idIndexMarker342"/>do this, create a new <strong class="source-inline">UEnhancedLocalPlayerSubsystem*</strong> property called <strong class="source-inline">EnhancedSubsystem</strong> and set it to return the value of the <strong class="source-inline">ULocalPlayer::GetSubsystem</strong> function. This function receives a template parameter representing the subsystem we want to fetch, which is <strong class="source-inline">UEnhancedLocalPlayerSubsystem</strong>, and a normal parameter of type <strong class="source-inline">ULocalPlayer*</strong>. This last parameter’s type is a representation of a player who’s controlling a pawn in the current instance of the game, and we’ll pass it by calling <strong class="source-inline">PlayerController-&gt;GetLocalPlayer()</strong>:<p class="source-code">UEnhancedInputLocalPlayerSubsystem* EnhancedSubsystem =</p><p class="source-code">ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PlayerController-&gt;GetLocalPlayer());</p></li>
</ol>
<p>Because we’ll be using the <strong class="source-inline">UEnhancedLocalPlayerSubsystem</strong>, we need to include it:</p>
<p class="source-code">#include "EnhancedInputSubsystems.h"</p>
<ol>
<li value="8">If the <strong class="source-inline">EnhancedSubsystem</strong> property isn’t <strong class="source-inline">nullptr</strong>, call its <strong class="source-inline">AddMappingContext</strong> function, which receives the following parameters:<ul><li><strong class="source-inline">UInputMappingContext* Mapping Context</strong>: The Input Context we want to activate – in this case, the <strong class="source-inline">IC_Character</strong> property</li><li><strong class="source-inline">int32 Priority</strong>: The priority we want this Input Context to have, which we’ll pass as <strong class="source-inline">1</strong><p class="source-code">EnhancedSubsystem-&gt;AddMappingContext(IC_Character, 1);</p></li></ul></li>
<li>Because <a id="_idIndexMarker343"/>we’ll be using <strong class="source-inline">UInputMappingContext</strong>, we need to include it:<p class="source-code">#include "InputMappingContext.h"</p></li>
<li>Now <a id="_idIndexMarker344"/>that we’ve added the logic to activate the Input Context, let’s add the logic for listening to the Input Actions. Add the code for the following steps after we check whether <strong class="source-inline">PlayerController</strong> is <strong class="source-inline">nullptr</strong>, but still inside the brackets where we check whether <strong class="source-inline">EnhancedPlayerInputComponent</strong> is <strong class="source-inline">nullptr</strong>:<p class="source-code">if (EnhancedPlayerInputComponent != nullptr)</p><p class="source-code">{</p><p class="source-code"> APlayerController* PlayerController = </p><p class="source-code"> Cast&lt;APlayerController&gt;(GetController());</p><p class="source-code"> if (PlayerController != nullptr)</p><p class="source-code"> {</p><p class="source-code">  ...</p><p class="source-code"> }</p><p class="source-code"> // Continue here</p><p class="source-code">}</p></li>
</ol>
<p>In order <a id="_idIndexMarker345"/>to listen to the <strong class="source-inline">IA_Movement</strong> Input <a id="_idIndexMarker346"/>Action, we’ll call the <strong class="source-inline">EnhancedPlayer InputComponent</strong> <strong class="source-inline">BindAction</strong> function, which receives as parameters the following:</p>
<ul>
<li><strong class="source-inline">UInputAction* Action</strong>: The Input Action to listen to, which we’ll pass as the <strong class="source-inline">IA_Movement</strong> property.</li>
<li><strong class="source-inline">ETriggerEvent TriggerEvent</strong>: The input event that will cause the function to be called. Because this Input Action is triggered for every frame in which it’s being used, and it’s triggered using the <strong class="source-inline">Down</strong> trigger, we’ll pass this as the <strong class="source-inline">Triggered</strong> event.</li>
<li><strong class="source-inline">UserClass* Object</strong>: The object that the <strong class="source-inline">callback</strong> function will be called on – in our case, that’s the <strong class="source-inline">this</strong> pointer.</li>
<li><strong class="source-inline">HANDLER_SIG::TUObjectMethodDelegate &lt;UserClass&gt; ::FMethodPtr Func</strong>: This property is a bit wordy, but it’s essentially a pointer to the function that will be called when this event happens, which we can specify by typing <strong class="source-inline">&amp;</strong>, followed by the class’s name, then <strong class="source-inline">::</strong>, and finally, the function’s name. In our case, we want this to be the <strong class="source-inline">Move</strong> function, which we’ll be creating in a following step, so we’ll specify it with <strong class="source-inline">&amp; AMyThirdPersonChar::Move</strong>:<p class="source-code">EnhancedPlayerInputComponent-&gt;BindAction(IA_Move,</p><p class="source-code">ETriggerEvent::Triggered, this, &amp;AMyThirdPersonChar</p><p class="source-code">::Move);</p></li>
</ul>
<p>Because we’ll be using <strong class="source-inline">UInputAction</strong>, we need to include it:</p>
<p class="source-code">#include "InputAction.h"</p>
<ol>
<li value="11">Let’s now bind the function that will make the player character start jumping. In order to do this, duplicate the <strong class="source-inline">BindAction</strong> function call we added for the <strong class="source-inline">IA_Move</strong> Input Action, but make the following changes:<ul><li>Instead of passing the <strong class="source-inline">IA_Move</strong> Input Action, pass the <strong class="source-inline">IA_Jump</strong> Input Action.</li><li>Instead of passing the <strong class="source-inline">&amp;AMyThirdPersonChar::Move</strong> function, pass <strong class="source-inline">&amp;ACharacter::Jump</strong>. This is the function that will make the character jump.</li><li>Instead of passing <strong class="source-inline">ETriggerEvent::Trigger</strong>, pass <strong class="source-inline">ETriggerEvent::Started</strong>. This is so that we can be notified when the key starts and stops being pressed:<p class="source-code">EnhancedPlayerInputComponent-&gt;BindAction(IA_Jump,</p><p class="source-code">ETriggerEvent::Started, this, &amp;ACharacter::Jump);</p></li></ul></li>
<li>In order <a id="_idIndexMarker347"/>to bind the function that will <a id="_idIndexMarker348"/>make the player character stop jumping, let’s now duplicate the last <strong class="source-inline">BindAction</strong> function call that we did, but make the following changes to it:<ul><li>Instead of passing the <strong class="source-inline">ETriggerEvent::Started</strong>, we’ll pass <strong class="source-inline">ETriggerEvent::Completed</strong>, so that the function gets called when this Input Action stops being triggered.</li><li>Instead of passing the <strong class="source-inline">&amp;ACharacter::Jump</strong> function, pass <strong class="source-inline">&amp;ACharacter::StopJumping</strong>. This is the function that will make the <a id="_idTextAnchor109"/>character stop jumping:<p class="source-code">EnhancedPlayerInputComponent-&gt;BindAction(IA_Jump,</p><p class="source-code">ETriggerEvent::Completed, this, &amp;ACharacter::StopJumping);</p></li></ul></li>
</ol>
<p class="callout- eading">Note</p>
<p class="callout">All functions used to listen to Input Actions must receive either no parameters or a parameter of type <strong class="source-inline">FInputActionValue&amp;</strong>. You can use this to check its value type and fetch the right one. For instance, if the Input Action that triggers this function has a <strong class="source-inline">Digital</strong> value type, its value will be of type <strong class="source-inline">bool</strong>, but if it has an <strong class="source-inline">Axis2D</strong> value type, its value will be of type <strong class="source-inline">FVector2D</strong>. The latter is the type we’ll be using for the <strong class="source-inline">Move</strong> function because that’s its corresponding value type.</p>
<p class="callout">Another option for listening to Input Actions is to use <strong class="source-inline">Delegates</strong>, which is outside the scope of this book.</p>
<ol>
<li value="13">Let’s now <a id="_idIndexMarker349"/>create the <strong class="source-inline">Move</strong> function <a id="_idIndexMarker350"/>that we referenced in a previous step. Go to the class’s header file and add a declaration for a <strong class="source-inline">protected</strong> function called <strong class="source-inline">Move</strong>, which returns nothing and receives a <strong class="source-inline">const FInputActionValue&amp; Value</strong> parameter:<p class="source-code">void Move(const FInputActionValue&amp; Value);</p></li>
<li>Because we’re using <strong class="source-inline">FInputActionValue</strong>, we have to include it:<p class="source-code">#include "InputActionValue.h"</p></li>
<li>In the class’s source file, add this function’s implementation, where we’ll start by fetching the <strong class="source-inline">Value</strong> parameter’s input as <strong class="source-inline">FVector2D</strong>. We’ll do this by calling its <strong class="source-inline">Get</strong> function, passing as a template parameter the <strong class="source-inline">FVector2D</strong> type. We’ll also save its return value in a local variable called <strong class="source-inline">InputValue</strong>:<p class="source-code">void AMyThirdPersonChar::Move(const FInputActionValue&amp;</p><p class="source-code">Value)</p><p class="source-code">{</p><p class="source-code"> FVector2D InputValue = Value.Get&lt;FVector2D&gt;();</p><p class="source-code">}</p></li>
<li>Next, check whether the <strong class="source-inline">Controller</strong> property is valid (not <strong class="source-inline">nullptr</strong>) and whether the <strong class="source-inline">InputValue</strong> property’s <strong class="source-inline">X</strong> or <strong class="source-inline">Y</strong> value is different to <strong class="source-inline">0</strong>:<p class="source-code">if (Controller != nullptr &amp;&amp; (InputValue.X != 0.0f ||</p><p class="source-code">InputValue.Y != 0.0f))</p></li>
</ol>
<p>If all of these conditions are <strong class="source-inline">true</strong>, we’ll then get the camera’s rotation on the <em class="italic">z</em> axis (yaw), so that we can move the character relative to where the camera is facing. To <a id="_idIndexMarker351"/>achieve this, we can create a <a id="_idIndexMarker352"/>new <strong class="source-inline">FRotator</strong> property called <strong class="source-inline">YawRotation</strong> with a value of <strong class="source-inline">0</strong> for pitch (rotation along the <em class="italic">y</em> axis) and roll (rotation along the <em class="italic">x</em> axis) and the value of the camera’s current yaw for the property’s yaw. To get the camera’s yaw value, we can call the Player Controller’s <strong class="source-inline">GetControlRotation</strong> function and then access its <strong class="source-inline">Yaw</strong> property:</p>
<p class="source-code">const FRotator YawRotation(0, Controller-&gt;</p>
<p class="source-code">  GetControlRotation().Yaw, 0);</p>
<p class="callout- eading">Note</p>
<p class="callout">The <strong class="source-inline">FRotator</strong> property’s constructor receives the <strong class="source-inline">Pitch</strong> value, the <strong class="source-inline">Yaw</strong> value, and then the <strong class="source-inline">Roll</strong> value.</p>
<ul>
<li>After that, we’ll check whether the <strong class="source-inline">InputValue</strong>’s <strong class="source-inline">X</strong> property is different to <strong class="source-inline">0</strong>:<p class="source-code">if (InputValue.X != 0.0f)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>If it is, get the right vector of <strong class="source-inline">YawRotation</strong> and store it in an <strong class="source-inline">Fvector RightDirection</strong> property. You can get a rotator’s right vector by calling the <strong class="source-inline">KistemMathLibrary</strong> object’s <strong class="source-inline">GetRightVector</strong> function. A rotator or vector’s right vector is simply its perpendicular vector that points to its right. The result of this will be a vector that points to the right of where the camera is currently facing:<p class="source-code">const Fvector RightDirection = </p><p class="source-code">  UkismetMathLibrary::GetRightVector(YawRotation);</p></li>
<li>We can now call the <strong class="source-inline">AddMovementInput</strong> function, which will make our character move in the direction we specify, passing as parameters the <strong class="source-inline">RightDirection</strong> and <strong class="source-inline">InputValue</strong> <strong class="source-inline">X</strong> properties:<p class="source-code">AddMovementInput(RightDirection, InputValue.X);</p></li>
<li>Because we’ll be using both the <strong class="source-inline">KismetMathLibrary</strong> and <strong class="source-inline">Controller</strong> objects, we’ll need to include them at the top of this source file:<p class="source-code">#include "Kismet/KismetMathLibrary.h"</p><p class="source-code">#include "GameFramework/Controller.h"</p></li>
</ul>
<ol>
<li value="17">After <a id="_idIndexMarker353"/>checking whether the <strong class="source-inline">X</strong> property <a id="_idIndexMarker354"/>of <strong class="source-inline">InputValue</strong> is different to <strong class="source-inline">0</strong>, check whether its <strong class="source-inline">Y</strong> property is different to <strong class="source-inline">0</strong>:<p class="source-code">if (InputValue.X != 0.0f)</p><p class="source-code">{</p><p class="source-code"> ...</p><p class="source-code">}</p><p class="source-code">if (InputValue.Y != 0.0f)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>If it is, call the <strong class="source-inline">YawRotation</strong> property’s <strong class="source-inline">Vector</strong> function and store its return value in an <strong class="source-inline">FVector ForwardDirection</strong> property. This function will convert <strong class="source-inline">FRotator</strong> to <strong class="source-inline">FVector</strong>, which is equivalent to getting a rotator’s <strong class="source-inline">ForwardVector</strong>. The result of this will be a vector that points forward of where the camera is currently facing:<p class="source-code">const FVector ForwardDirection = YawRotation.Vector();</p></li>
</ol>
<p>We can now call the <strong class="source-inline">AddMovementInput</strong> function, passing as parameters the <strong class="source-inline">ForwardDirection</strong> and <strong class="source-inline">InputValue</strong> <strong class="source-inline">Y</strong> properties:</p>
<p class="source-code">AddMovementInput(ForwardDirection, InputValue.Y);</p>
<ol>
<li value="19">Before we compile our code, add the <strong class="source-inline">EnhancedInput</strong> plugin to our project’s <strong class="source-inline">Build.cs</strong> file in order to notify UE5 that we’ll be using this plugin in our project. If we don’t do this, parts of our project won’t compile.</li>
<li>Open <a id="_idIndexMarker355"/>the <strong class="source-inline">.Build.cs</strong> file inside <a id="_idIndexMarker356"/>your project’s <strong class="source-inline">Source/&lt;ProjectName&gt;</strong> folder, which is a C# file and not a C++ file, located inside your project’s source folder.</li>
<li>Open the file, and you’ll find the <strong class="source-inline">AddRange</strong> function from the <strong class="source-inline">PublicDependencyModuleNames</strong> property being called. This is the function that tells the engine which modules this project intends to use. As a parameter, an array of strings is sent with the names of all the intended modules for the project. Given that we intend on using UMG, we’ll need to add the <strong class="source-inline">EnhancedInput</strong> module after the <strong class="source-inline">InputCore</strong> module:<p class="source-code">PublicDependencyModuleNames.AddRange(new string[] { "Core",</p><p class="source-code">"CoreUObject", "Engine", "InputCore", "EnhancedInput",</p><p class="source-code">"HeadMountedDisplay" });</p></li>
<li>Now that you’ve notified the engine that we’ll be using the <strong class="source-inline">EnhancedInput</strong> module, compile your code, open the editor, and open your <strong class="source-inline">BP_MyTPS</strong> blueprint asset. Delete the <strong class="source-inline">InputAction Jump</strong> event, as well as the nodes connected to it. Do the same for the <strong class="bold">InputAxis MoveForward</strong> and <strong class="bold">InputAxis MoveRight</strong> events. We will be replicating this logic in C++ and need to remove its Blueprint functionality so that there are no conflicts when handling input.</li>
<li>Next, set the <strong class="bold">IC Character</strong> property to the <strong class="bold">IC_Character</strong> Input Context, the <strong class="bold">IA Move </strong> property to the <strong class="bold">IA_Movement</strong> Input Action, and the <strong class="bold">IA Jump</strong> property to the <strong class="bold">IA_Jump</strong> Input Action:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer143">
<img alt="Figure 4.15 – The IC Character, IA Move, and IA Jump properties " height="252" src="image/Figure_4.15_B18531.jpg" width="450"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – The IC Character, IA Move, and IA Jump properties</p>
<ol>
<li value="24">Now, play <a id="_idIndexMarker357"/>the level. You should be able <a id="_idIndexMarker358"/>to move the character using the keyboard’s <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys or the controller’s <em class="italic">left thumbstick</em>, as well as jumping with the <em class="italic">Spacebar</em> key or <em class="italic">gamepad face button bottom</em>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer144">
<img alt="Figure 4.16 – The player character moving  " height="597" src="image/Figure_4.16_B18531.jpg" width="601"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – The player character moving </p>
<p>After following all these steps, you will have concluded this exercise. You now know how to create and listen to your own <strong class="bold">Input Action</strong> events using C++ in UE5. Doing <a id="_idIndexMarker359"/>this is one of the most <a id="_idIndexMarker360"/>important aspects of game development, so you’ve just completed an important step in your game development journey.</p>
<p>Now that we’ve set up all of the logic necessary to have our character move and jump, let’s add the logic responsible for rotating the camera around our character.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor110"/>Turning the camera around the character</h1>
<p>Cameras are an extremely important part of games, as they dictate what and how the player will see in <a id="_idIndexMarker361"/>your game throughout the play session. When it comes to third-person games, which is what this project is about, the camera allows a player not only to see the world around them but also the character they’re controlling. Whether the character is taking damage, falling, or something else, it’s important for the player to always know the state of the character they are controlling and to be able to have the camera face the direction they choose. </p>
<p>Like every modern third-person game, we will always have the camera rotate around our player character. To have our camera rotate around our character, after setting up the <strong class="bold">Camera</strong> and <strong class="bold">Spring Arm</strong> components in <a href="B18531_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Unreal Engine</em>, let’s continue by adding a new <strong class="bold">Look</strong> Input Action. Follow these steps:</p>
<ol>
<li value="1">Do this by duplicating the <strong class="bold">IA_Move</strong> Input Action (by either selecting it in <strong class="bold">Content Browser</strong> and pressing <em class="italic">Ctrl</em> + D, or by <em class="italic">right-clicking</em> it and selecting <strong class="bold">Duplicate</strong>) and name the new asset <strong class="source-inline">IA_Look</strong>. Because this new Input Action’s setup is similar to that of the <strong class="bold">IA_Move</strong> Input Action, we’ll leave this duplicated asset as is.</li>
<li>Then, open the <strong class="bold">IA_Character</strong> Input Context and add a new mapping for the <strong class="bold">IA_Look</strong> Input Action. </li>
<li>Add the following keys to this new mapping – <strong class="bold">Mouse X</strong>, <strong class="bold">Mouse Y</strong>, <strong class="bold">Gamepad Right Thumbstick X-Axis</strong>, and <strong class="bold">Gamepad Right Thumbstick Y-Axis</strong>. Because the <em class="italic">Y</em> keys will be controlling the Input Action’s <em class="italic">Y</em> axis, we’ll have to add the <strong class="bold">Swizzle Input Axis Values</strong> modifier to them (the <strong class="bold">Mouse Y</strong> and <strong class="bold">Gamepad Right Thumbstick Y-Axis</strong> keys). Additionally, because the <strong class="bold">Mouse Y</strong> key will <a id="_idIndexMarker362"/>make the camera go down when you mose the mouse up, we’ll have to also add a <strong class="bold">Negate</strong> modifier to it:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer145">
<img alt="Figure 4.17 – The mappings for the IA_Look Input Action" height="657" src="image/Figure_4.17_B18531.jpg" width="634"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – The mappings for the IA_Look Input Action</p>
<p>Let’s now add the C++ logic responsible for turning the camera with the player’s input:</p>
<ol>
<li value="1">Go to the <strong class="source-inline">MyThirdPersonChar</strong> class’s header file and add a <strong class="source-inline">public</strong> <strong class="source-inline">class UInputAction* IA_Look</strong> property, which must be <strong class="source-inline">UPROPERTY</strong> and have the <strong class="source-inline">EditAnywhere</strong> and <strong class="source-inline">Category = Input</strong> tags:<p class="source-code">UPROPERTY(EditAnywhere, Category = Input)</p><p class="source-code">class UInputAction* IA_Look;</p></li>
<li>Next, add <a id="_idIndexMarker363"/>a declaration for a <strong class="source-inline">protected</strong> function called <strong class="source-inline">Look</strong>, which returns nothing and receives a <strong class="source-inline">const FInputActionValue&amp; Value</strong> parameter:<p class="source-code">void Look(const FInputActionValue&amp; Value);</p></li>
<li>Next, go to the <strong class="source-inline">SetupPlayerInputComponent</strong> function implementation, in the class’s source file, and duplicate the line responsible for listening to the <strong class="source-inline">IA_Move</strong> Input Action. In this duplicated line, change the first parameter to <strong class="source-inline">IA_Look</strong> and the last parameter to <strong class="source-inline">&amp;AMyThirdPersonChar::Look</strong>:<p class="source-code">EnhancedPlayerInputComponent-&gt;BindAction(IA_Look,</p><p class="source-code">ETriggerEvent::Triggered, this, &amp;AMyThirdPersonChar::Look);</p></li>
<li>Then, add the <strong class="source-inline">Look</strong> function’s implementation, where we’ll start by fetching the <strong class="source-inline">Value</strong> parameter’s input as <strong class="source-inline">FVector2D</strong>. We’ll do this by calling its <strong class="source-inline">Get</strong> function, passing as a <strong class="source-inline">template</strong> parameter the <strong class="source-inline">FVector2D</strong> type. We’ll also save its <strong class="source-inline">return</strong> value in a local variable called <strong class="source-inline">InputValue</strong>:<p class="source-code">void AMyThirdPersonChar::Look(const FInputActionValue&amp; Value)</p><p class="source-code">{</p><p class="source-code"> FVector2D InputValue = Value.Get&lt;FVector2D&gt;();</p><p class="source-code">}</p></li>
<li>If the <strong class="source-inline">InputValue</strong> <strong class="source-inline">X</strong> property is different to <strong class="source-inline">0</strong>, we’ll call the <strong class="source-inline">AddControllerYawInput</strong> function, passing this property as a parameter. After that, check whether the <strong class="source-inline">InputValue</strong> <strong class="source-inline">Y</strong> property is different to <strong class="source-inline">0</strong>, and then we’ll <a id="_idIndexMarker364"/>call the <strong class="source-inline">AddControllerPitchInput</strong> function, passing this property as a parameter:<p class="source-code">if (InputValue.X != 0.0f)</p><p class="source-code">{</p><p class="source-code">  AddControllerYawInput(InputValue.X);</p><p class="source-code">}</p><p class="source-code">if (InputValue.Y != 0.0f)</p><p class="source-code">{</p><p class="source-code">  AddControllerPitchInput(InputValue.Y);</p><p class="source-code">}</p></li>
</ol>
<p class="callout- eading">Note</p>
<p class="callout">The <strong class="source-inline">AddControllerYawInput</strong> and <strong class="source-inline">AddControllerPitchInput</strong> functions are responsible for adding rotation input around the <em class="italic">z</em> (turning left and right) and <em class="italic">y</em> (looking up and down) axes respectively.</p>
<ol>
<li value="6">After you’ve done this, compile your code, open the editor, and open your <strong class="bold">BP_MyTPS</strong> Blueprint asset. Set its <strong class="bold">IA_Look</strong> property to the <strong class="bold">IA_Look</strong> Input Action:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer146">
<img alt="Figure 4.18 – The camera is rotated around the player " height="341" src="image/Figure_4.18_B18531.jpg" width="420"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – The camera is rotated around the player</p>
<p>When you <a id="_idIndexMarker365"/>play the level, you should now be able to move the camera by rotating the mouse or by tilting the controller’s <em class="italic">right thumbstick</em>:</p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<img alt="Figure 4.19 – The camera is rotated around the player " height="637" src="image/Figure_4.19_B18531.jpg" width="535"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – The camera is rotated around the player</p>
<p>And that concludes the logic for rotating the camera around the player character with the player’s input. Now that we’ve learned how to add inputs to our game and associate them with in-game actions, such as jumping and moving the player character, let’s consolidate what we’ve learned in this chapter by going through how to add a new <strong class="source-inline">Walk</strong> action to our game from start to finish in the next activity.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor111"/>Activity 4.01 – adding walking logic to our character</h1>
<p>In the current game, our character runs by default when we use the movement keys, but we <a id="_idIndexMarker366"/>need to reduce the character’s speed and make it walk.</p>
<p>So, in this activity, we’ll be adding logic that will make our character walk when we move it while holding the <em class="italic">Shift</em> key on the keyboard or the <strong class="bold">Gamepad Face Button Right</strong> key (<em class="italic">B</em> for the Xbox controller and <em class="italic">O</em> for the PlayStation controller).</p>
<p>To do this, follow these steps:</p>
<ol>
<li value="1">Duplicate the <strong class="bold">IA_Jump</strong> Input Action and name the new asset <strong class="source-inline">IA_Walk</strong>. Because this new Input Action’s setup is similar to that of the <strong class="bold">IA_Jump</strong> Input Action, we’ll leave this duplicated asset as is.</li>
<li>Then, open the <strong class="bold">IA_Character</strong> Input Context and add a new mapping for the <strong class="bold">IA_Walk</strong> Input Action. Add the following keys to this new mapping – <strong class="bold">Left Shift</strong>, and <strong class="bold">Gamepad Face Button Right</strong>.</li>
<li>Open the <strong class="source-inline">MyThirdPersonChar</strong> class’s header file and add a <strong class="source-inline">class UInputAction* IA_Walk</strong> property, which must be <strong class="source-inline">UPROPERTY</strong> and have the <strong class="source-inline">EditAnywhere</strong> and <strong class="source-inline">Category = Input</strong> tags.</li>
<li>Then, add declarations for two <strong class="source-inline">protected</strong> functions that return nothing and receive no parameters, called <strong class="source-inline">BeginWalking</strong> and <strong class="source-inline">StopWalking</strong>.</li>
<li>Add the implementations for both these functions in the class’s source file. In the implementation of the <strong class="source-inline">BeginWalking</strong> function, change the character’s speed to 40% of its value by modifying the <strong class="source-inline">CharacterMovementComponent</strong> property’s <strong class="source-inline">MaxWalkSpeed</strong> property accordingly. To access the <strong class="source-inline">CharacterMovementComponent</strong> property, use the <strong class="source-inline">GetCharacterMovement</strong> function.</li>
</ol>
<p>The implementation of the <strong class="source-inline">StopWalking</strong> function will be the inverse of that of the <strong class="source-inline">BeginWalking</strong> function, which will increase the character’s walk speed by 250%.</p>
<ol>
<li value="6">Listen to the <strong class="source-inline">Walk</strong> action by going to the <strong class="source-inline">SetupPlayerInputComponent</strong> function’s implementation and adding two calls to the <strong class="source-inline">BindAction</strong> function, the first one of which passes as parameters the <strong class="source-inline">IA_Walk</strong> property, the <strong class="source-inline">ETriggerEvent::Started</strong> event, the <strong class="source-inline">this</strong> pointer, and this class’s <strong class="source-inline">BeginWalking</strong> function, while the second passes the <strong class="source-inline">IA_Walk</strong> property, the <strong class="source-inline">ETriggerEvent::Completed</strong> event, the <strong class="source-inline">this</strong> pointer, and this class’s <strong class="source-inline">StopWalking</strong> function.</li>
<li>Compile <a id="_idIndexMarker367"/>your code, open the editor, open your <strong class="source-inline">BP_MyTPS</strong> Blueprint asset, and set the <strong class="bold">IA_Walk</strong> property to the <strong class="bold">IA_Walk</strong> Input Action.</li>
</ol>
<p>After following these steps, you should be able to have your character walk, which decreases its speed and slightly changes its animation, by pressing either the keyboard’s <em class="italic">Left Shift</em> key or the controller’s <strong class="bold">Face Button Right</strong> key:</p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<img alt="Figure 4.20 – The character running (left) and walking (right)" height="668" src="image/Figure_4.20_B18531.jpg" width="1027"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – The character running (left) and walking (right)</p>
<p>And that concludes our activity. Our character should now be able to walk slowly as long as the <a id="_idIndexMarker368"/>player is holding the <strong class="bold">Walk</strong> Input Action.</p>
<p class="callout- eading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor112"/>Summary</h1>
<p>In this chapter, you’ve learned how to create and modify <strong class="bold">Input Actions</strong>, as well as add their mappings to an <strong class="bold">Input Context</strong>, which gives you some flexibility when determining which keys trigger a specific action or axis, how to listen to them, and how to execute in-game logic when they’re pressed and released.</p>
<p>Now that you know how to handle the player’s input, you can allow the player to interact with your game and offer the agency that video games are so well known for.</p>
<p>In the next chapter, we’ll start making our own game from scratch. It’ll be called <strong class="bold">Dodgeball</strong> and will consist of the player controlling a character trying to run away from enemies that are throwing dodgeballs at it. In that chapter, we will have the opportunity to start learning about many important topics, with a heavy focus on collisions.</p>
</div>
</div></body></html>