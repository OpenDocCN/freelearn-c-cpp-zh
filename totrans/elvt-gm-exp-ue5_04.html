<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-77"><a id="_idTextAnchor099"/>4</h1>
<h1 id="_idParaDest-78"><a id="_idTextAnchor100"/>Getting Started with Player Input<a id="_idTextAnchor101"/></h1>
<p>In the previous chapter, we created our C++ class, which inherits from the <code>Character</code> class, and added all the necessary <code>Actor</code> components to be able to see the game from the character’s perspective, as well as being able to see the character itself. We then created a <code>Blueprint</code> class that inherits from that C++ class in order to visually set up all of its necessary components.</p>
<p>In this chapter, we will be looking at these topics in more depth, as well as covering their C++ usage. We will learn about how player input works in UE5, how the engine handles input events (<em class="italic">key presses and releases</em>), and how we can use them to control logic in our game.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding Input Actions  and Contexts</li>
<li>Processing Player Input</li>
<li>Pivoting the camera around the character</li>
</ul>
<p>By the end of this chapter, you will know about <strong class="bold">Input Actions</strong> and <strong class="bold">Input Contexts</strong>, how to create and modify them, how to listen to each of those mappings, and how to execute in-game actions when they’re pressed and released.</p>
<p class="callout- eading">Note</p>
<p class="callout">In this chapter, we will be using an alternative version of the <code>Character</code> blueprint we created called <code>BP_MyTPC</code> in the previous chapter. This chapter’s version will have the default UE5 Mannequin mesh, not the one from Mixamo.</p>
<p>Let’s start this chapter by getting to know how UE5 abstracts the keys pressed by a player to make it easier for you to be notified of those events.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>The project for this chapter can be found in the Chapter04 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor103"/>Understanding Input Actions and Contexts</h1>
<p>Player input is the thing that distinguishes video games from other forms of entertainment <a id="_idIndexMarker311"/>media – the fact that they’re interactive. For a video game to be interactive, it must take into account a player’s input. Many games do this by allowing the player to control a virtual character that acts upon the virtual world it’s in, depending on the keys and buttons that the player presses, which is exactly what we’ll be doing in this chapter.</p>
<p class="callout- eading">Note</p>
<p class="callout">It’s important to note that UE5 has two input systems – the Legacy Input System, used since the start of UE4, and the new Enhanced Input System, introduced only in the last version of UE5 as an experimental system and now as a complete plugin in UE5. We will be using the new Enhanced Input System in this book. If you wish to know more about UE5’s Legacy <a id="_idIndexMarker312"/>Input System, you can do so by accessing this link: <a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/">https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/</a></p>
<p>Most game development tools nowadays allow you to abstract keypresses into <strong class="bold">actions</strong>, which allow you to associate a name (for example, <em class="italic">Jump</em>) with several different player <a id="_idIndexMarker313"/>inputs (pressing a button, flicking a thumbstick, and so on). In UE5, the way in which you can specify this is through the use of <strong class="bold">Input Actions</strong> combined with <strong class="bold">Input Contexts </strong>(also referred to as <strong class="bold">Input Mapping Contexts</strong>).</p>
<p><strong class="bold">Input Contexts</strong> contain <strong class="bold">Input Actions</strong> that are associated with them, along with which keys will execute them, and <strong class="bold">Input Actions</strong> contain specifications as to how they will be executed. The combination of both of these assets allows you to do something when an <strong class="bold">Input Action</strong> is triggered but also easily change how that <strong class="bold">Input Action</strong> is triggered and by which keys.</p>
<p>In order to better understand how <strong class="bold">Input Contexts</strong> and <strong class="bold">Input Actions</strong> work together, let’s think of a game, such as <em class="italic">GTA</em>, where you have different gameplay contexts in which you control different people/objects with different keys.</p>
<p>For instance, when you’re controlling your player character running around the city, you use the movement keys to move the character around, and you use a different key to make your character jump. However, when you enter a car, the controls will change. The movement keys will now steer the car instead, and the same key that was used for jumping will now be used, for instance, for braking.</p>
<p>In this example, you <a id="_idIndexMarker314"/>have two different Input Contexts (controlling the character and controlling the vehicle), each with its own set of Input Actions. Some <a id="_idIndexMarker315"/>of those Input Actions are triggered by the same key, but that’s fine, because they’re done in different Input Contexts (for example, using the same key to cause your character to jump and to stop the vehicle).</p>
<p>Before we start looking into some of the Enhanced Input-related assets, because it’s a plugin, we’ll have to enable it. To enable it, follow these steps:</p>
<ol>
<li>Go to <strong class="bold">Edit</strong> | <strong class="bold">Plugins</strong> | <strong class="bold">Built-In</strong> | <strong class="bold">Input</strong> and tick the <strong class="bold">Enabled</strong> box for the <strong class="bold">Enhanced Input</strong> plugin. After you have done so, you’ll be prompted to restart the editor.   </li>
<li>Click the <strong class="bold">Restart Now</strong> button when this happens. After the editor restarts, and now that the <strong class="bold">Enhanced Input</strong> plugin has been enabled, you’ll need to tell the engine to use its classes to handle the player’s input. </li>
<li>To do this, go to <code>EnhancedPlayerInput</code> and the <code>EnhancedInputComponent</code>. Now that the <strong class="bold">Enhanced Input</strong> plugin has been enabled and its classes are being used, we can proceed with this chapter’s content.</li>
</ol>
<p>In order to know more about Input Contexts and Input Actions, let’s inspect them. Follow these steps:</p>
<ol>
<li value="1">Right-click on the <code>IA_Movement</code>, and then open it. You should see the Input Action window, which has the following properties:</li>
</ol>
<div><div><img alt="Figure 4.1 – The Action window" height="348" src="img/Figure_4.01_B18531.jpg" width="839"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Action window</p>
<p>Now, let’s <a id="_idIndexMarker316"/>take a look at its options in detail:</p>
<ul>
<li><code>true</code>, another Input Action with a lower priority that will be triggered by the same key won’t be triggered.</li>
<li><strong class="bold">Trigger when Paused</strong>: This specifies whether this Input Action can be triggered if the game is paused.</li>
<li><strong class="bold">Reserve All Mappings</strong>: This specifies whether a higher priority Input Action will be triggered if it’s triggered by the same key.</li>
<li><strong class="bold">Value Type</strong>: This specifies the type of value for this Input Action. Its values can be the following:<ul><li><strong class="bold">Digital (bool)</strong>: Used for Input Actions that have a binary state – for instance, a jumping Input Action, in which the player is either pressing it or not, would use this value.</li><li><strong class="bold">Axis 1D (float)</strong>: Used for Input Actions that have a scalar state in one dimension – for instance, accelerating in a racing game, where you can use the gamepad’s triggers to control the throttle.</li><li><strong class="bold">Axis 2D (Vector2D)</strong>: Used for Input Actions that have a scalar state in two dimensions – for instance, actions for moving your character, which are done using two axes (the forward axis and the sideways axis), would be good candidates for using this value.</li></ul></li>
<li><strong class="bold">Axis 3D (Vector)</strong>: Used for <a id="_idIndexMarker317"/>Input Actions that have a scalar state in three dimensions. This value isn’t as likely to be used as the others, but you may find a use for it.</li>
<li><strong class="bold">Triggers</strong>: This specifies the key events that will execute this Input Action. The values for this can be a combination of the following:<ul><li><strong class="bold">Chorded Action</strong>: The Input Action is triggered as long as a different specified Input Action is also triggered.</li><li><strong class="bold">Down</strong>: The Input Action is triggered for every frame that the key exceeds the actuation threshold.</li></ul></li>
</ul>
<p class="callout- eading">Note</p>
<p class="callout">The actuation threshold is the value at which a key’s input will be considered for executing an action. Binary keys (like the ones on a keyboard) have an input value of either <code>0</code> (not pressed) or <code>1</code> (pressed), while scalar keys, like the triggers on a gamepad, have an input value that goes continuously from <code>0</code> to <code>1</code> or, like the individual axes of the thumbsticks, that go continuously from <code>–1</code> to <code>1</code>.</p>
<ul>
<li><strong class="bold">Hold</strong>: The Input Action is triggered when the key has exceeded the actuation threshold for a specified amount of time. You can optionally specify whether it’s triggered once or for every frame.</li>
<li><strong class="bold">Hold and Release</strong>: The Input Action is triggered when the key has exceeded the actuation threshold for a specified amount of time and then stops exceeding that actuation threshold.</li>
<li><strong class="bold">Pressed</strong>: The Input Action is triggered once the key exceeds the actuation threshold and won’t be triggered again until it’s released.</li>
<li><strong class="bold">Pulse</strong>: The Input Action is triggered at a specified interval as long as the key exceeds the actuation threshold. You can specify whether the first pulse triggers the Input Action and whether there’s a limit to how many times it can be called.</li>
<li><strong class="bold">Released</strong>: The Input Action is triggered once the key stops exceeding the actuation threshold.</li>
<li><strong class="bold">Tap</strong>: The Input Action <a id="_idIndexMarker318"/>is triggered when the key starts and then stops exceeding the Actuation Threshold, as long as it’s done within the specified amount of time.</li>
<li><strong class="bold">Modifiers</strong>: This specifies the ways in which this Input Action’s input will be modified:</li>
<li><code>0</code> if it’s lower than the lower threshold and as <code>1</code> if it’s higher than the upper threshold.</li>
<li><strong class="bold">FOV Scaling</strong>: The key’s input will be scaled alongside the FOV (if the FOV increases, the key’s input will increase, and vice versa).</li>
<li><strong class="bold">Modifier Collection</strong>: The key’s input will be modified according to the specified list of modifiers.</li>
<li><strong class="bold">Negate</strong>: The key’s input will be inverted.</li>
<li><strong class="bold">Response Curve – Exponential</strong>: An exponential curve will be applied on the key’s input.</li>
<li><strong class="bold">Response Curve – User Defined</strong>: A user-defined curve will be applied on the key’s input.</li>
<li><strong class="bold">Scalar</strong>: The key’s input will be scaled at each axis according to the scalar specified.</li>
<li><strong class="bold">Smooth</strong>: The key’s input will be smoothed out across multiple frames.</li>
<li><strong class="bold">Swizzle Input Axis Values</strong>: The key’s axis order will be switched.</li>
<li><strong class="bold">To World Space</strong>: The key’s axes will be converted toworld space.</li>
</ul>
<ol>
<li value="2"> After doing this, right-click on <code>IC_Character</code> and open it.</li>
</ol>
<p>You should see the Input Action window pop up. Note that it has an empty <strong class="bold">MAPPINGS</strong> property. </p>
<div><div><img alt="Figure 4.2 – The MAPPINGS property " height="99" src="img/Figure_4.02_B18531.jpg" width="188"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The MAPPINGS property</p>
<ol>
<li value="3">Let’s now <a id="_idIndexMarker319"/>add a new mapping. Press the <strong class="bold">+</strong> button next to the <strong class="bold">Mappings</strong> property. You’ll notice a new property show up where you can specify the Input Action this mapping will be associated with.</li>
</ol>
<p>This action can be triggered by several different keys, each of which can have its own triggers and modifiers, which work the same as the corresponding properties in the Input Action asset.</p>
<p class="callout- eading">Note</p>
<p class="callout">When it comes to modifying the <strong class="bold">Triggers</strong> and <strong class="bold">Modifiers</strong> properties, the usual practice is to change the modifiers in the Input Context asset and the triggers in the Input Action asset.</p>
<p class="callout- eading">Note</p>
<p class="callout">We will not be using these properties in this book, but for each Input Mapping Context, you can specify whether it can be modified by a player by ticking the <strong class="bold">Is Player Mappable</strong> property and specifying <strong class="bold">Player Mappable Options</strong>.</p>
<p>When we generated the <code>Third Person</code> template project back in <a href="B18531_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Unreal Engine</em></p>
<p>, it came with some inputs already configured, which were the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys, as well as the <code>left thumbstick</code> for movement, the <em class="italic">spacebar</em> key, and the <code>gamepad bottom face</code> button for jumping.</p>
<p>For context, let’s <a id="_idIndexMarker320"/>consider an Xbox One controller, which can be broken down into the following:</p>
<ul>
<li>The <strong class="bold">left analog stick</strong>, usually used for controlling movement in games</li>
<li>The <strong class="bold">D-pad</strong>, which can control movement and also has a variety of other uses</li>
<li>The <strong class="bold">right analog stick</strong>, usually used for controlling the camera and view perspective</li>
<li>The <strong class="bold">face buttons</strong> (<strong class="bold">X</strong>, <strong class="bold">Y</strong>, <strong class="bold">A</strong>, and <strong class="bold">B</strong>), which can have various uses depending on the game but usually allow the player to perform actions in the game world</li>
<li>The <strong class="bold">bumpers and triggers</strong> (<strong class="bold">LB</strong>, <strong class="bold">RB</strong>, <strong class="bold">LT</strong>, and <strong class="bold">RT</strong>), which can be used for actions such as aiming and shooting or accelerating and braking</li>
</ul>
<p>Now that we’ve learned how to set up <code>Input Actions</code>, let’s add some of them in the next exercise.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor106"/>Exercise 4.01 – creating the movement and jump input actions</h2>
<p>In this <a id="_idIndexMarker321"/>exercise, we’ll be adding the mappings <a id="_idIndexMarker322"/>for the <em class="italic">Movement</em> and <em class="italic">Jump</em> Input Actions. </p>
<p>To achieve this, follow these steps:</p>
<ol>
<li value="1">Open the <strong class="bold">IA_Movement</strong> Input Action.</li>
<li>Set its value type as <strong class="bold">Axis2D</strong>. We’ll make this an Input Action of type <strong class="bold">Axis2D</strong> because the character’s movement is done on two axes – the forward axis (the <em class="italic">Y</em> axis for this Input Action) and the sideways or right axis (the <em class="italic">X</em> axis for this Input Action): </li>
</ol>
<div><div><img alt="Figure 4.3 – The Value Type options " height="345" src="img/Figure_4.03_B18531.jpg" width="525"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The Value Type options</p>
<ol>
<li value="3">Add a <a id="_idIndexMarker323"/>new trigger of type <strong class="bold">Down</strong> with <a id="_idIndexMarker324"/>an actuation threshold of <strong class="bold">0,1</strong>. This will ensure that this Input Action is called when one of its keys has an actuation threshold of at least <strong class="bold">0,1</strong>:</li>
</ol>
<div><div><img alt="Figure 4.4 – The Down trigger " height="139" src="img/Figure_4.04_B18531.jpg" width="907"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The Down trigger</p>
<ol>
<li value="4">Open the <strong class="bold">IC_Character</strong> Input Context.</li>
<li>Click the <strong class="bold">+</strong> icon to the right of the <strong class="bold">Mappings</strong> property to create a new mapping:</li>
</ol>
<div><div><img alt="Figure 4.5 – Adding a new action mapping " height="150" src="img/Figure_4.05_B18531.jpg" width="219"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Adding a new action mapping</p>
<ol>
<li value="6">When you’ve done so, you should see a new empty mapping with its properties either empty or set to <strong class="bold">None</strong>:</li>
</ol>
<div><div><img alt="Figure 4.6 – The default settings of a new action mapping " height="179" src="img/Figure_4.06_B18531.jpg" width="469"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The default settings of a new action mapping</p>
<ol>
<li value="7">Set the <a id="_idIndexMarker325"/>Input Action of this mapping (the <a id="_idIndexMarker326"/>first property that’s set to <strong class="bold">None</strong>) to <strong class="bold">IA_Movement</strong>:</li>
</ol>
<div><div><img alt="Figure 4.7 – The new IA_Movement mapping " height="178" src="img/Figure_4.07_B18531.jpg" width="452"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The new IA_Movement mapping</p>
<ol>
<li value="8">Set the first key in this mapping to <strong class="bold">Gamepad Left Thumbstick Y-Axis</strong>.</li>
</ol>
<div><div><img alt="Figure 4.8 – The Gamepad Left Thumbstick Y-Axis key " height="135" src="img/Figure_4.08_B18531.jpg" width="411"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The Gamepad Left Thumbstick Y-Axis key</p>
<p class="callout- eading">Note</p>
<p class="callout">If the key you want to set is from one of the input devices you have connected (for example, mouse, keyboard, or gamepad), you can click the button to the left of the key dropdown and then press the actual key you want to set, instead of searching for it in the list. For instance, if you want to set a mapping to use the <em class="italic">F</em> key on the keyboard, you can click that button, then press the <em class="italic">F</em> key, and then that key will be set for that mapping.</p>
<p>Because <a id="_idIndexMarker327"/>we want this key to control <a id="_idIndexMarker328"/>the Input Action’s <em class="italic">Y</em> axis instead of its <em class="italic">X</em> axis, we need to add the <strong class="bold">Swizzle Input Axis Values</strong> modifier with the <strong class="bold">YXZ</strong> value.</p>
<div><div><img alt="Figure 4.9 – The Swizzle Input Axis modifier " height="124" src="img/Figure_4.09_B18531.jpg" width="668"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – The Swizzle Input Axis modifier</p>
<ol>
<li value="9">Click the <strong class="bold">+</strong> button to the right of the Input Action set for this mapping in order to add a new key and execute that Input Action:</li>
</ol>
<div><div><img alt="Figure 4.10 – The + button to the right of IA_Movement " height="80" src="img/Figure_4.10_B18531.jpg" width="434"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – The + button to the right of IA_Movement</p>
<ol>
<li value="10">Set the new key to <strong class="bold">Gamepad Left Thumbstick X-Axis</strong>. Because this will already control the movement Input Action’s <em class="italic">X</em> axis, we won’t need to add any modifiers.</li>
<li>Add <a id="_idIndexMarker329"/>another key to the Input Action, this <a id="_idIndexMarker330"/>time the <em class="italic">W</em> key. Because this key will be used for moving forward, and therefore use the <em class="italic">Y</em> axis, it will need the same modifier that we added before – the <strong class="bold">Swizzle Input Axis</strong> modifier with the <strong class="bold">YXZ</strong> value.</li>
<li>Add another key to the Input Action, this time the <em class="italic">S</em> key. Because this key will be used for moving backward, and therefore use the <em class="italic">Y</em> axis, it will need the same modifier we added before – the <code>–1</code> on the <em class="italic">Y</em> axis when this key is pressed (that is, when its input is <code>1</code>):</li>
</ol>
<div><div><img alt="Figure 4.11 – The Swizzle Input Axis Values and Negate modifiers " height="220" src="img/Figure_4.11_B18531.jpg" width="618"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – The Swizzle Input Axis Values and Negate modifiers</p>
<ol>
<li value="13">Add another key to the Input Action, this time the <em class="italic">D</em> key. Because this key will be used for moving right, and therefore use the positive end of the <em class="italic">X</em> axis, it won’t need any modifiers.</li>
<li>Add <a id="_idIndexMarker331"/>another key to the Input Action, this <a id="_idIndexMarker332"/>time the <em class="italic">A</em> key. Because this key will be used for moving left, and therefore use the negative end of the <em class="italic">X</em> axis, it will need the <code>Negate</code> modifier, just like the <em class="italic">S</em> key.</li>
<li>Create a new Input Action asset called <code>IA_Jump</code>, and then open it.</li>
<li>Add a <strong class="bold">Down</strong> trigger and leave its actuation threshold as <strong class="bold">0,5</strong>:</li>
</ol>
<div><div><img alt="Figure 4.12 – The Down trigger " height="112" src="img/Figure_4.12_B18531.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – The Down trigger</p>
<ol>
<li value="17">Go back to the <strong class="bold">IC_Character</strong> Input Context asset and add a new Input Action to the <strong class="bold">Mapping</strong>s property – this time, the <strong class="bold">IA_Jump</strong> Input Action we just created:</li>
</ol>
<div><div><img alt="Figure 4.13 – The IA_Jump mapping " height="147" src="img/Figure_4.13_B18531.jpg" width="806"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – The IA_Jump mapping</p>
<ol>
<li value="18">Add two keys to this mapping – <strong class="bold">Space Bar</strong> and <strong class="bold">Gamepad Face Button Bottom</strong>. If you’re using an Xbox controller, this will be the <em class="italic">A</em> button, and if you’re using a PlayStation controller, this will be the <em class="italic">X</em> button:</li>
</ol>
<div><div><img alt="Figure 4.14 – The IA_Jump mapping keys " height="116" src="img/Figure_4.14_B18531.jpg" width="429"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – The IA_Jump mapping keys</p>
<p>And with <a id="_idIndexMarker333"/>those steps completed, we’ve <a id="_idIndexMarker334"/>completed this chapter’s first exercise, where you’ve learned how you can specify Input Action Mappings in UE5, allowing you to abstract which keys are responsible for which in-game actions.</p>
<p>Let’s now take a look at how UE5 handles player input and processes it within the game.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor107"/>Processing Player Input</h1>
<p>Let’s think <a id="_idIndexMarker335"/>about a situation where the player presses the <strong class="bold">Jump</strong> Input Action, which is associated with the <em class="italic">spacebar</em> key, to get the player character to jump. Between the moment the player presses the <em class="italic">Spacebar</em> key and the moment the game makes the player character jump, quite a few things have to happen to connect those two events.</p>
<p>Let’s take a look at all of the necessary steps that lead from one event to the other:</p>
<ol>
<li value="1"><code>Hardware Input</code>: The player presses the <em class="italic">spacebar</em> key. UE5 will be listening to this keypress event.</li>
<li>The <code>PlayerInput</code> class: After the key is pressed or released, this class will translate that key into an Input Action. If there is a corresponding Input Action, it will notify all classes that are listening to the action that it was just pressed, released, or updated. In this case, it will know that the <em class="italic">Spacebar</em> key is associated with the <em class="italic">Jump</em> Input Action.</li>
<li>The <code>Player Controller</code> class: This is the first class to receive these keypress events, given that it’s used to represent a player in the game.</li>
<li>The <code>Pawn</code> class: This class (and consequently the <code>Character</code> class, which inherits from it) can also listen to those keypress events, as long as they are possessed by a Player Controller. If so, it will receive these events after that class. In this chapter, we will be using our <code>Character</code> C++ class to listen to action and axis events.</li>
</ol>
<p>Now that <a id="_idIndexMarker336"/>we know how UE5 handles player inputs, let’s see how we can listen to Input Actions in C++ in the next exercise.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor108"/>Exercise 4.02 – listening to movement and jump input actions</h2>
<p>In this exercise, we will register the Input Actions we created in the previous section with <a id="_idIndexMarker337"/>our character class by binding them <a id="_idIndexMarker338"/>to specific functions in our character class using C++.</p>
<p>The main way for a <code>SetupPlayerInputComponent</code> function. The <code>MyThirdPersonChar</code> class should already have a declaration and an implementation for this function. Let’s have our character class listen to those events by following these steps:</p>
<ol>
<li value="1">Open the <code>MyThirdPersonChar</code> class header file in Visual Studio, and make sure there’s a declaration for a <code>protected</code> function called <code>SetupPlayerInputComponent</code> that returns nothing and receives a <code>class UInputComponent* PlayerInputComponent</code> property as a parameter. This function should be marked as both <code>virtual</code> and <code>override</code>:<pre>virtual void SetupPlayerInputComponent(class UInputComponent*
PlayerInputComponent) override;</pre></li>
<li>Add a declaration for a <code>public</code> <code>class UInputMappingContext*</code> property called <code>IC_Character</code>. This property must be a <code>UPROPERTY</code> and have the <code>EditAnywhere</code> and <code>Category = Input</code> tags. This will be the Input Context we’ll be adding for the character’s input:<pre>UPROPERTY(EditAnywhere, Category = Input)
class UInputMappingContext* IC_Character;</pre></li>
<li>After that, we’ll need to add the Input Actions to listen for the character’s input. Add three <code>public</code> <code>class UInputAction*</code> properties, all of which must be <code>UPROPERTY</code> and have the <code>EditAnywhere</code> and <code>Category = Input</code> tags. Those two properties will be called the following:<ul><li><code>IA_Move</code><pre><code>IA_Jump</code>UPROPERTY(EditAnywhere, Category = Input)
class UInputAction* IA_Move;
UPROPERTY(EditAnywhere, Category = Input)
class UInputAction* IA_Jump</pre></li></ul></li>
<li>Open <a id="_idIndexMarker339"/>this class’s <a id="_idIndexMarker340"/><code>source</code> file and make sure that this function has an implementation:<pre>void AMyThirdPersonChar::SetupPlayerInputComponent(class 
UInputComponent* PlayerInputComponent)
{
}</pre></li>
<li>Because in UE5 you can use either the legacy Input Component or the Enhanced Input Component, we need to account for this. Inside the previous function’s implementation, start by casting the <code>PlayerInputComponent</code> parameter to the <code>UEnhancedInputComponent</code> class and saving it inside a new <code>EnhancedPlayerInputComponent</code> property of type <code>UEnhancedInputComponent*</code>:<pre>UEnhancedInputComponent* EnhancedPlayerInputComponent =
Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent);</pre></li>
</ol>
<p>Because we’ll be using <code>UEnhancedInputComponent</code>, we need to include it:</p>
<pre>#include "EnhancedInputComponent.h"</pre>
<ol>
<li value="6">If it’s not <code>nullptr</code>, cast the <code>Controller</code> property to <code>APlayerController</code> and save it in a local <code>PlayerController</code> property:<pre>if (EnhancedPlayerInputComponent != nullptr)
{
 APlayerController* PlayerController =
 Cast&lt;APlayerController&gt;(GetController());
}</pre></li>
</ol>
<p>If <a id="_idIndexMarker341"/>the newly created <code>PlayerController</code> property isn’t <code>nullptr</code>, then we’ll need to fetch <code>UEnhancedLocalPlayerSubsystem</code> so that we can tell it to add the <code>IC_Character</code> Input Context and activate its Input Actions.</p>
<ol>
<li value="7">To <a id="_idIndexMarker342"/>do this, create a new <code>UEnhancedLocalPlayerSubsystem*</code> property called <code>EnhancedSubsystem</code> and set it to return the value of the <code>ULocalPlayer::GetSubsystem</code> function. This function receives a template parameter representing the subsystem we want to fetch, which is <code>UEnhancedLocalPlayerSubsystem</code>, and a normal parameter of type <code>ULocalPlayer*</code>. This last parameter’s type is a representation of a player who’s controlling a pawn in the current instance of the game, and we’ll pass it by calling <code>PlayerController-&gt;GetLocalPlayer()</code>:<pre>UEnhancedInputLocalPlayerSubsystem* EnhancedSubsystem =
ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PlayerController-&gt;GetLocalPlayer());</pre></li>
</ol>
<p>Because we’ll be using the <code>UEnhancedLocalPlayerSubsystem</code>, we need to include it:</p>
<pre>#include "EnhancedInputSubsystems.h"</pre>
<ol>
<li value="8">If the <code>EnhancedSubsystem</code> property isn’t <code>nullptr</code>, call its <code>AddMappingContext</code> function, which receives the following parameters:<ul><li><code>UInputMappingContext* Mapping Context</code>: The Input Context we want to activate – in this case, the <code>IC_Character</code> property</li><li><code>int32 Priority</code>: The priority we want this Input Context to have, which we’ll pass as <code>1</code><pre>EnhancedSubsystem-&gt;AddMappingContext(IC_Character, 1);</pre></li></ul></li>
<li>Because <a id="_idIndexMarker343"/>we’ll be using <code>UInputMappingContext</code>, we need to include it:<pre>#include "InputMappingContext.h"</pre></li>
<li>Now <a id="_idIndexMarker344"/>that we’ve added the logic to activate the Input Context, let’s add the logic for listening to the Input Actions. Add the code for the following steps after we check whether <code>PlayerController</code> is <code>nullptr</code>, but still inside the brackets where we check whether <code>EnhancedPlayerInputComponent</code> is <code>nullptr</code>:<pre>if (EnhancedPlayerInputComponent != nullptr)
{
 APlayerController* PlayerController = 
 Cast&lt;APlayerController&gt;(GetController());
 if (PlayerController != nullptr)
 {
  ...
 }
 // Continue here
}</pre></li>
</ol>
<p>In order <a id="_idIndexMarker345"/>to listen to the <code>IA_Movement</code> Input <a id="_idIndexMarker346"/>Action, we’ll call the <code>EnhancedPlayer InputComponent</code> <code>BindAction</code> function, which receives as parameters the following:</p>
<ul>
<li><code>UInputAction* Action</code>: The Input Action to listen to, which we’ll pass as the <code>IA_Movement</code> property.</li>
<li><code>ETriggerEvent TriggerEvent</code>: The input event that will cause the function to be called. Because this Input Action is triggered for every frame in which it’s being used, and it’s triggered using the <code>Down</code> trigger, we’ll pass this as the <code>Triggered</code> event.</li>
<li><code>UserClass* Object</code>: The object that the <code>callback</code> function will be called on – in our case, that’s the <code>this</code> pointer.</li>
<li><code>HANDLER_SIG::TUObjectMethodDelegate &lt;UserClass&gt; ::FMethodPtr Func</code>: This property is a bit wordy, but it’s essentially a pointer to the function that will be called when this event happens, which we can specify by typing <code>&amp;</code>, followed by the class’s name, then <code>::</code>, and finally, the function’s name. In our case, we want this to be the <code>Move</code> function, which we’ll be creating in a following step, so we’ll specify it with <code>&amp; AMyThirdPersonChar::Move</code>:<pre>EnhancedPlayerInputComponent-&gt;BindAction(IA_Move,
ETriggerEvent::Triggered, this, &amp;AMyThirdPersonChar
::Move);</pre></li>
</ul>
<p>Because we’ll be using <code>UInputAction</code>, we need to include it:</p>
<pre>#include "InputAction.h"</pre>
<ol>
<li value="11">Let’s now bind the function that will make the player character start jumping. In order to do this, duplicate the <code>BindAction</code> function call we added for the <code>IA_Move</code> Input Action, but make the following changes:<ul><li>Instead of passing the <code>IA_Move</code> Input Action, pass the <code>IA_Jump</code> Input Action.</li><li>Instead of passing the <code>&amp;AMyThirdPersonChar::Move</code> function, pass <code>&amp;ACharacter::Jump</code>. This is the function that will make the character jump.</li><li>Instead of passing <code>ETriggerEvent::Trigger</code>, pass <code>ETriggerEvent::Started</code>. This is so that we can be notified when the key starts and stops being pressed:<pre>EnhancedPlayerInputComponent-&gt;BindAction(IA_Jump,
ETriggerEvent::Started, this, &amp;ACharacter::Jump);</pre></li></ul></li>
<li>In order <a id="_idIndexMarker347"/>to bind the function that will <a id="_idIndexMarker348"/>make the player character stop jumping, let’s now duplicate the last <code>BindAction</code> function call that we did, but make the following changes to it:<ul><li>Instead of passing the <code>ETriggerEvent::Started</code>, we’ll pass <code>ETriggerEvent::Completed</code>, so that the function gets called when this Input Action stops being triggered.</li><li>Instead of passing the <code>&amp;ACharacter::Jump</code> function, pass <code>&amp;ACharacter::StopJumping</code>. This is the function that will make the <a id="_idTextAnchor109"/>character stop jumping:<pre>EnhancedPlayerInputComponent-&gt;BindAction(IA_Jump,
ETriggerEvent::Completed, this, &amp;ACharacter::StopJumping);</pre></li></ul></li>
</ol>
<p class="callout- eading">Note</p>
<p class="callout">All functions used to listen to Input Actions must receive either no parameters or a parameter of type <code>FInputActionValue&amp;</code>. You can use this to check its value type and fetch the right one. For instance, if the Input Action that triggers this function has a <code>Digital</code> value type, its value will be of type <code>bool</code>, but if it has an <code>Axis2D</code> value type, its value will be of type <code>FVector2D</code>. The latter is the type we’ll be using for the <code>Move</code> function because that’s its corresponding value type.</p>
<p class="callout">Another option for listening to Input Actions is to use <code>Delegates</code>, which is outside the scope of this book.</p>
<ol>
<li value="13">Let’s now <a id="_idIndexMarker349"/>create the <code>Move</code> function <a id="_idIndexMarker350"/>that we referenced in a previous step. Go to the class’s header file and add a declaration for a <code>protected</code> function called <code>Move</code>, which returns nothing and receives a <code>const FInputActionValue&amp; Value</code> parameter:<pre>void Move(const FInputActionValue&amp; Value);</pre></li>
<li>Because we’re using <code>FInputActionValue</code>, we have to include it:<pre>#include "InputActionValue.h"</pre></li>
<li>In the class’s source file, add this function’s implementation, where we’ll start by fetching the <code>Value</code> parameter’s input as <code>FVector2D</code>. We’ll do this by calling its <code>Get</code> function, passing as a template parameter the <code>FVector2D</code> type. We’ll also save its return value in a local variable called <code>InputValue</code>:<pre>void AMyThirdPersonChar::Move(const FInputActionValue&amp;
Value)
{
 FVector2D InputValue = Value.Get&lt;FVector2D&gt;();
}</pre></li>
<li>Next, check whether the <code>Controller</code> property is valid (not <code>nullptr</code>) and whether the <code>InputValue</code> property’s <code>X</code> or <code>Y</code> value is different to <code>0</code>:<pre>if (Controller != nullptr &amp;&amp; (InputValue.X != 0.0f ||
InputValue.Y != 0.0f))</pre></li>
</ol>
<p>If all of these conditions are <code>true</code>, we’ll then get the camera’s rotation on the <em class="italic">z</em> axis (yaw), so that we can move the character relative to where the camera is facing. To <a id="_idIndexMarker351"/>achieve this, we can create a <a id="_idIndexMarker352"/>new <code>FRotator</code> property called <code>YawRotation</code> with a value of <code>0</code> for pitch (rotation along the <em class="italic">y</em> axis) and roll (rotation along the <em class="italic">x</em> axis) and the value of the camera’s current yaw for the property’s yaw. To get the camera’s yaw value, we can call the Player Controller’s <code>GetControlRotation</code> function and then access its <code>Yaw</code> property:</p>
<pre>const FRotator YawRotation(0, Controller-&gt;
  GetControlRotation().Yaw, 0);</pre>
<p class="callout- eading">Note</p>
<p class="callout">The <code>FRotator</code> property’s constructor receives the <code>Pitch</code> value, the <code>Yaw</code> value, and then the <code>Roll</code> value.</p>
<ul>
<li>After that, we’ll check whether the <code>InputValue</code>’s <code>X</code> property is different to <code>0</code>:<pre>if (InputValue.X != 0.0f)
{
}</pre></li>
<li>If it is, get the right vector of <code>YawRotation</code> and store it in an <code>Fvector RightDirection</code> property. You can get a rotator’s right vector by calling the <code>KistemMathLibrary</code> object’s <code>GetRightVector</code> function. A rotator or vector’s right vector is simply its perpendicular vector that points to its right. The result of this will be a vector that points to the right of where the camera is currently facing:<pre>const Fvector RightDirection = 
  UkismetMathLibrary::GetRightVector(YawRotation);</pre></li>
<li>We can now call the <code>AddMovementInput</code> function, which will make our character move in the direction we specify, passing as parameters the <code>RightDirection</code> and <code>InputValue</code> <code>X</code> properties:<pre>AddMovementInput(RightDirection, InputValue.X);</pre></li>
<li>Because we’ll be using both the <code>KismetMathLibrary</code> and <code>Controller</code> objects, we’ll need to include them at the top of this source file:<pre>#include "Kismet/KismetMathLibrary.h"
#include "GameFramework/Controller.h"</pre></li>
</ul>
<ol>
<li value="17">After <a id="_idIndexMarker353"/>checking whether the <code>X</code> property <a id="_idIndexMarker354"/>of <code>InputValue</code> is different to <code>0</code>, check whether its <code>Y</code> property is different to <code>0</code>:<pre>if (InputValue.X != 0.0f)
{
 ...
}
if (InputValue.Y != 0.0f)
{
}</pre></li>
<li>If it is, call the <code>YawRotation</code> property’s <code>Vector</code> function and store its return value in an <code>FVector ForwardDirection</code> property. This function will convert <code>FRotator</code> to <code>FVector</code>, which is equivalent to getting a rotator’s <code>ForwardVector</code>. The result of this will be a vector that points forward of where the camera is currently facing:<pre>const FVector ForwardDirection = YawRotation.Vector();</pre></li>
</ol>
<p>We can now call the <code>AddMovementInput</code> function, passing as parameters the <code>ForwardDirection</code> and <code>InputValue</code> <code>Y</code> properties:</p>
<pre>AddMovementInput(ForwardDirection, InputValue.Y);</pre>
<ol>
<li value="19">Before we compile our code, add the <code>EnhancedInput</code> plugin to our project’s <code>Build.cs</code> file in order to notify UE5 that we’ll be using this plugin in our project. If we don’t do this, parts of our project won’t compile.</li>
<li>Open <a id="_idIndexMarker355"/>the <code>.Build.cs</code> file inside <a id="_idIndexMarker356"/>your project’s <code>Source/&lt;ProjectName&gt;</code> folder, which is a C# file and not a C++ file, located inside your project’s source folder.</li>
<li>Open the file, and you’ll find the <code>AddRange</code> function from the <code>PublicDependencyModuleNames</code> property being called. This is the function that tells the engine which modules this project intends to use. As a parameter, an array of strings is sent with the names of all the intended modules for the project. Given that we intend on using UMG, we’ll need to add the <code>EnhancedInput</code> module after the <code>InputCore</code> module:<pre>PublicDependencyModuleNames.AddRange(new string[] { "Core",
"CoreUObject", "Engine", "InputCore", "EnhancedInput",
"HeadMountedDisplay" });</pre></li>
<li>Now that you’ve notified the engine that we’ll be using the <code>EnhancedInput</code> module, compile your code, open the editor, and open your <code>BP_MyTPS</code> blueprint asset. Delete the <code>InputAction Jump</code> event, as well as the nodes connected to it. Do the same for the <strong class="bold">InputAxis MoveForward</strong> and <strong class="bold">InputAxis MoveRight</strong> events. We will be replicating this logic in C++ and need to remove its Blueprint functionality so that there are no conflicts when handling input.</li>
<li>Next, set the <strong class="bold">IC Character</strong> property to the <strong class="bold">IC_Character</strong> Input Context, the <strong class="bold">IA Move </strong> property to the <strong class="bold">IA_Movement</strong> Input Action, and the <strong class="bold">IA Jump</strong> property to the <strong class="bold">IA_Jump</strong> Input Action:</li>
</ol>
<div><div><img alt="Figure 4.15 – The IC Character, IA Move, and IA Jump properties " height="252" src="img/Figure_4.15_B18531.jpg" width="450"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – The IC Character, IA Move, and IA Jump properties</p>
<ol>
<li value="24">Now, play <a id="_idIndexMarker357"/>the level. You should be able <a id="_idIndexMarker358"/>to move the character using the keyboard’s <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys or the controller’s <em class="italic">left thumbstick</em>, as well as jumping with the <em class="italic">Spacebar</em> key or <em class="italic">gamepad face button bottom</em>:</li>
</ol>
<div><div><img alt="Figure 4.16 – The player character moving  " height="597" src="img/Figure_4.16_B18531.jpg" width="601"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – The player character moving </p>
<p>After following all these steps, you will have concluded this exercise. You now know how to create and listen to your own <strong class="bold">Input Action</strong> events using C++ in UE5. Doing <a id="_idIndexMarker359"/>this is one of the most <a id="_idIndexMarker360"/>important aspects of game development, so you’ve just completed an important step in your game development journey.</p>
<p>Now that we’ve set up all of the logic necessary to have our character move and jump, let’s add the logic responsible for rotating the camera around our character.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor110"/>Turning the camera around the character</h1>
<p>Cameras are an extremely important part of games, as they dictate what and how the player will see in <a id="_idIndexMarker361"/>your game throughout the play session. When it comes to third-person games, which is what this project is about, the camera allows a player not only to see the world around them but also the character they’re controlling. Whether the character is taking damage, falling, or something else, it’s important for the player to always know the state of the character they are controlling and to be able to have the camera face the direction they choose. </p>
<p>Like every modern third-person game, we will always have the camera rotate around our player character. To have our camera rotate around our character, after setting up the <strong class="bold">Camera</strong> and <strong class="bold">Spring Arm</strong> components in <a href="B18531_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Unreal Engine</em>, let’s continue by adding a new <strong class="bold">Look</strong> Input Action. Follow these steps:</p>
<ol>
<li value="1">Do this by duplicating the <code>IA_Look</code>. Because this new Input Action’s setup is similar to that of the <strong class="bold">IA_Move</strong> Input Action, we’ll leave this duplicated asset as is.</li>
<li>Then, open the <strong class="bold">IA_Character</strong> Input Context and add a new mapping for the <strong class="bold">IA_Look</strong> Input Action. </li>
<li>Add the following keys to this new mapping – <strong class="bold">Mouse X</strong>, <strong class="bold">Mouse Y</strong>, <strong class="bold">Gamepad Right Thumbstick X-Axis</strong>, and <strong class="bold">Gamepad Right Thumbstick Y-Axis</strong>. Because the <em class="italic">Y</em> keys will be controlling the Input Action’s <em class="italic">Y</em> axis, we’ll have to add the <strong class="bold">Swizzle Input Axis Values</strong> modifier to them (the <strong class="bold">Mouse Y</strong> and <strong class="bold">Gamepad Right Thumbstick Y-Axis</strong> keys). Additionally, because the <strong class="bold">Mouse Y</strong> key will <a id="_idIndexMarker362"/>make the camera go down when you mose the mouse up, we’ll have to also add a <strong class="bold">Negate</strong> modifier to it:</li>
</ol>
<div><div><img alt="Figure 4.17 – The mappings for the IA_Look Input Action" height="657" src="img/Figure_4.17_B18531.jpg" width="634"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – The mappings for the IA_Look Input Action</p>
<p>Let’s now add the C++ logic responsible for turning the camera with the player’s input:</p>
<ol>
<li value="1">Go to the <code>MyThirdPersonChar</code> class’s header file and add a <code>public</code> <code>class UInputAction* IA_Look</code> property, which must be <code>UPROPERTY</code> and have the <code>EditAnywhere</code> and <code>Category = Input</code> tags:<pre>UPROPERTY(EditAnywhere, Category = Input)
class UInputAction* IA_Look;</pre></li>
<li>Next, add <a id="_idIndexMarker363"/>a declaration for a <code>protected</code> function called <code>Look</code>, which returns nothing and receives a <code>const FInputActionValue&amp; Value</code> parameter:<pre>void Look(const FInputActionValue&amp; Value);</pre></li>
<li>Next, go to the <code>SetupPlayerInputComponent</code> function implementation, in the class’s source file, and duplicate the line responsible for listening to the <code>IA_Move</code> Input Action. In this duplicated line, change the first parameter to <code>IA_Look</code> and the last parameter to <code>&amp;AMyThirdPersonChar::Look</code>:<pre>EnhancedPlayerInputComponent-&gt;BindAction(IA_Look,
ETriggerEvent::Triggered, this, &amp;AMyThirdPersonChar::Look);</pre></li>
<li>Then, add the <code>Look</code> function’s implementation, where we’ll start by fetching the <code>Value</code> parameter’s input as <code>FVector2D</code>. We’ll do this by calling its <code>Get</code> function, passing as a <code>template</code> parameter the <code>FVector2D</code> type. We’ll also save its <code>return</code> value in a local variable called <code>InputValue</code>:<pre>void AMyThirdPersonChar::Look(const FInputActionValue&amp; Value)
{
 FVector2D InputValue = Value.Get&lt;FVector2D&gt;();
}</pre></li>
<li>If the <code>InputValue</code> <code>X</code> property is different to <code>0</code>, we’ll call the <code>AddControllerYawInput</code> function, passing this property as a parameter. After that, check whether the <code>InputValue</code> <code>Y</code> property is different to <code>0</code>, and then we’ll <a id="_idIndexMarker364"/>call the <code>AddControllerPitchInput</code> function, passing this property as a parameter:<pre>if (InputValue.X != 0.0f)
{
  AddControllerYawInput(InputValue.X);
}
if (InputValue.Y != 0.0f)
{
  AddControllerPitchInput(InputValue.Y);
}</pre></li>
</ol>
<p class="callout- eading">Note</p>
<p class="callout">The <code>AddControllerYawInput</code> and <code>AddControllerPitchInput</code> functions are responsible for adding rotation input around the <em class="italic">z</em> (turning left and right) and <em class="italic">y</em> (looking up and down) axes respectively.</p>
<ol>
<li value="6">After you’ve done this, compile your code, open the editor, and open your <strong class="bold">BP_MyTPS</strong> Blueprint asset. Set its <strong class="bold">IA_Look</strong> property to the <strong class="bold">IA_Look</strong> Input Action:</li>
</ol>
<div><div><img alt="Figure 4.18 – The camera is rotated around the player " height="341" src="img/Figure_4.18_B18531.jpg" width="420"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – The camera is rotated around the player</p>
<p>When you <a id="_idIndexMarker365"/>play the level, you should now be able to move the camera by rotating the mouse or by tilting the controller’s <em class="italic">right thumbstick</em>:</p>
<div><div><img alt="Figure 4.19 – The camera is rotated around the player " height="637" src="img/Figure_4.19_B18531.jpg" width="535"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – The camera is rotated around the player</p>
<p>And that concludes the logic for rotating the camera around the player character with the player’s input. Now that we’ve learned how to add inputs to our game and associate them with in-game actions, such as jumping and moving the player character, let’s consolidate what we’ve learned in this chapter by going through how to add a new <code>Walk</code> action to our game from start to finish in the next activity.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor111"/>Activity 4.01 – adding walking logic to our character</h1>
<p>In the current game, our character runs by default when we use the movement keys, but we <a id="_idIndexMarker366"/>need to reduce the character’s speed and make it walk.</p>
<p>So, in this activity, we’ll be adding logic that will make our character walk when we move it while holding the <em class="italic">Shift</em> key on the keyboard or the <strong class="bold">Gamepad Face Button Right</strong> key (<em class="italic">B</em> for the Xbox controller and <em class="italic">O</em> for the PlayStation controller).</p>
<p>To do this, follow these steps:</p>
<ol>
<li value="1">Duplicate the <code>IA_Walk</code>. Because this new Input Action’s setup is similar to that of the <strong class="bold">IA_Jump</strong> Input Action, we’ll leave this duplicated asset as is.</li>
<li>Then, open the <strong class="bold">IA_Character</strong> Input Context and add a new mapping for the <strong class="bold">IA_Walk</strong> Input Action. Add the following keys to this new mapping – <strong class="bold">Left Shift</strong>, and <strong class="bold">Gamepad Face Button Right</strong>.</li>
<li>Open the <code>MyThirdPersonChar</code> class’s header file and add a <code>class UInputAction* IA_Walk</code> property, which must be <code>UPROPERTY</code> and have the <code>EditAnywhere</code> and <code>Category = Input</code> tags.</li>
<li>Then, add declarations for two <code>protected</code> functions that return nothing and receive no parameters, called <code>BeginWalking</code> and <code>StopWalking</code>.</li>
<li>Add the implementations for both these functions in the class’s source file. In the implementation of the <code>BeginWalking</code> function, change the character’s speed to 40% of its value by modifying the <code>CharacterMovementComponent</code> property’s <code>MaxWalkSpeed</code> property accordingly. To access the <code>CharacterMovementComponent</code> property, use the <code>GetCharacterMovement</code> function.</li>
</ol>
<p>The implementation of the <code>StopWalking</code> function will be the inverse of that of the <code>BeginWalking</code> function, which will increase the character’s walk speed by 250%.</p>
<ol>
<li value="6">Listen to the <code>Walk</code> action by going to the <code>SetupPlayerInputComponent</code> function’s implementation and adding two calls to the <code>BindAction</code> function, the first one of which passes as parameters the <code>IA_Walk</code> property, the <code>ETriggerEvent::Started</code> event, the <code>this</code> pointer, and this class’s <code>BeginWalking</code> function, while the second passes the <code>IA_Walk</code> property, the <code>ETriggerEvent::Completed</code> event, the <code>this</code> pointer, and this class’s <code>StopWalking</code> function.</li>
<li>Compile <a id="_idIndexMarker367"/>your code, open the editor, open your <code>BP_MyTPS</code> Blueprint asset, and set the <strong class="bold">IA_Walk</strong> property to the <strong class="bold">IA_Walk</strong> Input Action.</li>
</ol>
<p>After following these steps, you should be able to have your character walk, which decreases its speed and slightly changes its animation, by pressing either the keyboard’s <em class="italic">Left Shift</em> key or the controller’s <strong class="bold">Face Button Right</strong> key:</p>
<div><div><img alt="Figure 4.20 – The character running (left) and walking (right)" height="668" src="img/Figure_4.20_B18531.jpg" width="1027"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – The character running (left) and walking (right)</p>
<p>And that concludes our activity. Our character should now be able to walk slowly as long as the <a id="_idIndexMarker368"/>player is holding the <strong class="bold">Walk</strong> Input Action.</p>
<p class="callout- eading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor112"/>Summary</h1>
<p>In this chapter, you’ve learned how to create and modify <strong class="bold">Input Actions</strong>, as well as add their mappings to an <strong class="bold">Input Context</strong>, which gives you some flexibility when determining which keys trigger a specific action or axis, how to listen to them, and how to execute in-game logic when they’re pressed and released.</p>
<p>Now that you know how to handle the player’s input, you can allow the player to interact with your game and offer the agency that video games are so well known for.</p>
<p>In the next chapter, we’ll start making our own game from scratch. It’ll be called <strong class="bold">Dodgeball</strong> and will consist of the player controlling a character trying to run away from enemies that are throwing dodgeballs at it. In that chapter, we will have the opportunity to start learning about many important topics, with a heavy focus on collisions.</p>
</div>
</div></body></html>