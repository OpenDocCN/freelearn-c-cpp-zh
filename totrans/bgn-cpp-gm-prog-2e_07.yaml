- en: '*Chapter 6*: Object-Oriented Programming – Starting the Pong Game'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, there's quite a large amount of theory, but the theory will
    give us the knowledge that we need to start using **object-oriented programming**
    (**OOP**) with some expertise. Furthermore, we will not waste any time in putting
    that theory to good use as we will use it to code the next project, a Pong game.
    We will get to look behind the scenes at how we can create new types that we can
    use as objects by coding a class. First, we will look at a simplified Pong scenario
    so that we can learn about some class basics, and then we will start again and
    code a Pong game for real using the principles we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about OOP and classes using a hypothetical `Bat` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start working on the Pong game and code a real class to represent the player's
    bat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming is a programming paradigm that we could consider
    to be almost the standard way to code. It is true there are non-OOP ways to code
    and there are even some non-OOP game coding languages/libraries. However, since
    we are starting from scratch, there is no reason to do things in any other way.
  prefs: []
  type: TYPE_NORMAL
- en: 'OOP will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make our code easier to manage, change, or update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make our code quicker and more reliable to write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it possible to easily use other people's code (like we have with SFML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already seen the third benefit in action. Let's discuss exactly what
    OOP is.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole. Each chunk is self-contained yet
    potentially reusable by other programs, while working together as a whole with
    the other chunks. These chunks are what we have been referring to as objects.
  prefs: []
  type: TYPE_NORMAL
- en: When we plan and code an object, we do so with a **class**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A class can be thought of as the blueprint of an object.
  prefs: []
  type: TYPE_NORMAL
- en: We implement an object *of* a class. This is called an **instance** of a class.
    Think about a house blueprint. You can't live in it, but you can build a house
    from it. You build an instance of the house. Often, when we design classes for
    our games, we write them to represent real-world *things*. In the next project,
    we will write classes for a bat that the player controls and a ball that the player
    can bounce around the screen with the bat. However, OOP is more than this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: OOP is a *way* of doing things, a methodology that defines best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The three core principles of OOP are **encapsulation**, **polymorphism**, and
    **inheritance**. This might sound complex but, taken a step at a time, this is
    reasonably straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Encapsulation** means keeping the internal workings of your code safe from
    interference from the code that uses it. You can achieve this by allowing only
    the variables and functions you choose to be accessed. This means your code can
    always be updated, extended, or improved without affecting the programs that use
    it, provided the exposed parts are still accessed in the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, with proper encapsulation, it wouldn't matter whether the SFML
    team needed to update the way their `Sprite` class works. If the function signatures
    remain the same, they don't have to worry about what goes on inside. The code
    that we wrote before the update will still work after the update.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Polymorphism** allows us to write code that is less dependent on the *types*
    we are trying to manipulate. This will make our code clearer and more efficient.
    Polymorphism means *different forms*. If the objects that we code can be more
    than one type of thing, then we can take advantage of this. Polymorphism might
    sound a little bit like black magic at this point. We will use polymorphism in
    the fourth project, which we will start in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292),
    *Abstraction and Code Management – Making Better Use of OOP*. Everything will
    become clearer.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like it sounds, **inheritance** means we can harness all the features and
    benefits of other peoples' classes, including encapsulation and polymorphism,
    while further refining their code specifically to our situation. We will use inheritance
    for the first time at the same time as we use polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Why use OOP?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When written properly, OOP allows you to add new features without worrying about
    how they interact with existing features. When you do have to change a class,
    its self-contained (encapsulated) nature means less or perhaps even zero consequences
    for other parts of the program.
  prefs: []
  type: TYPE_NORMAL
- en: You can use other people's code (like the SFML classes) without knowing or perhaps
    even caring for how it works inside.
  prefs: []
  type: TYPE_NORMAL
- en: OOP and, by extension, SFML, allows you to write games that use complicated
    concepts such as multiple cameras, multiplayer, OpenGL, directional sound, and
    more besides—all of this without breaking a sweat.
  prefs: []
  type: TYPE_NORMAL
- en: You can create multiple, similar, yet different versions of a class without
    starting the class from scratch by using inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: You can still use the functions intended for the original type of object with
    your new object because of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: All this makes sense really. And as we know, C++ was designed from the start
    with all this OOP in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate key to success with OOP and making games (or any other type of
    app), other than the determination to succeed, is planning and design. It is not
    so much just "knowing" all the C++, SFML, and OOP topics that will help you to
    write great code, but rather applying all that knowledge to write code that is
    well-structured/designed. The code in this book is presented in an order and manner
    that's appropriate for learning about the various C++ topics in a gaming context.
    The art and science of structuring your code is called **design patterns**. As
    your code gets longer and more complex, effective use of design patterns will
    become more important. The good news is that we don't need to invent these design
    patterns ourselves. We will need to learn about them as our projects get more
    complex. As our projects become more complex, our design patterns will evolve
    too.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we will learn about and use basic classes and encapsulation.
    As this book progresses, we will get a bit more daring and use inheritance, polymorphism,
    and other OOP-related C++ features too.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is a class?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class is a bunch of code that can contains functions, variables, loops, and
    all the other C++ syntax we have already learned about. Each new class will be
    declared in its own `.h` code file with the same name as the class, while its
    functions will be defined in their own `.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have written a class, we can use it to make as many objects from it
    as we want. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the blueprint, just like the object isn't the class.
    It is an object made *from* the class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can think of an object as a variable and the class as a type.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with all this talk of OOP and classes, we haven't actually seen any
    code. Let's fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: The theory of a Pong Bat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What follows is a hypothetical discussion of how we might use OOP to get started
    with the Pong project by coding a Bat class. Don't add any code to the project
    just yet as what follows is over-simplified in order to explain the theory. Later
    in this chapter, we will code it for real. When we get to coding the class for
    real, it will actually be quite different, but the principles we will learn about
    here will prepare us for success.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by exploring variables and functions as part of a class.
  prefs: []
  type: TYPE_NORMAL
- en: The class variable and function declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bat that bounces a ball would be an excellent first candidate for a class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t know what Pong is, then take a look at this link: [https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a hypothetical `Bat.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, the code might appear a little complex, but when it has been
    explained, we will see there are very few concepts we haven't already covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to notice is that a new class is declared using the `class`
    keyword, followed by the name of the class and that the entire declaration is
    enclosed in curly braces, followed by a closing semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the variable declarations and their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All the names are prefixed with `m_`. This `m_` prefix is not compulsory, but
    it is a good convention. Variables that are declared as part of the class are
    called `m_` makes it plain when we are dealing with a member variable. When we
    write functions for our classes, we will start to see local (non-member) variables
    and parameters as well. The `m_` convention will then prove itself useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that all the variables are in a section of the code headed with
    the `private:` keyword. Scan your eyes over the previous code and note that the
    body of the class code is separated into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `public` and `private` keywords control the encapsulation of our class.
    Anything that is private cannot be accessed directly by the user of an instance/object
    of the class. If you are designing a class for others to use, you don't want them
    to be able to alter anything at will. Note that member variables do not have to
    be private, but good encapsulation is achieved by making them private whenever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: This means that our four member variables (`m_Length`, `m_Height`, `m_XPosition`,
    and `m_YPosition`) cannot be accessed directly by our game engine from the `main`
    function. They can only be accessed indirectly by the code of the class. This
    is encapsulation in action. For the `m_Length` and `m_Height` variables, this
    is fairly easy to accept as long as we don't need to change the size of the bat.
    The `m_XPosition` and `m_YPosition` member variables, however, need to be accessed,
    or how on earth will we move the bat?
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is solved in the `public:` section of the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The class provides two functions that are public and will be usable with an
    object of the `Bat` type. When we look at the definitions of these functions,
    we will see how exactly these functions manipulate the private variables.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we have a bunch of inaccessible (private) variables that cannot
    be used from the `main` function. This is good because encapsulation makes our
    code less error-prone and more maintainable. We then solve the problem of moving
    the bat by providing indirect access to the `m_XPosition` and `m_YPosition` variables
    by providing two public functions.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `main` function can call these functions using an instance of
    the class, but the code inside the functions control exactly how the variables
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The class function definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function definitions we will write in this book will all go in a separate
    file to the class and function declarations. We will use files with the same name
    as the class and the `.cpp` file extension. So, for example, the following code
    would go in a file called `Bat.cpp`. Look at the following code, which has just
    one new concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that we must use an include directive to include
    the class and function declarations from the `Bat.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: The new concept we can see here is the use of the `::`. Since the functions
    belong to a class, we must write the signature part by prefixing the function
    name with the class name, as well as `::`. `void Bat::moveLeft()` and `void Bat::moveRight`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Actually, we have briefly seen the scope resolution operator before, that is,
    whenever we declare an object of a class, and we have not previously used `using
    namespace..`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we could have put the function definitions and declarations in one
    file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, when our classes get longer (as they will with our first Zombie Arena
    class), it is more organized to separate the function definitions into their own
    file. Furthermore, header files are considered "public", and are often used for
    documentation purposes if other people will be using the code that we write.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we use a class once we have coded it?
  prefs: []
  type: TYPE_NORMAL
- en: Using an instance of a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite all the code we have seen related to classes, we haven't actually used
    the class. We already know how to do this as we have used the SFML classes many
    times already.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we would create an instance of the `Bat` class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bat` object has all the variables we declared in `Bat.h`. We just can''t
    access them directly. We can, however, move our bat using its public functions,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can move it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `bat` *is a* `Bat`, and as such it has all the member variables
    and has all of the functions available to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we may decide to make our Pong game multiplayer. In the `main` function,
    we could change the code so that the game has two bats, perhaps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is vitally important to realize that each of these instances of `Bat` are
    separate objects with their very own set of variables. There are more ways to
    initialize an instance of a class, and we will see an example of this when we
    code the `Bat` class for real, next.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start the project for real.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Pong project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since setting up a project is a fiddly process, we will go through it a step
    by step, like we did for the Timber!!! project. I won''t show you the same screenshots
    that I did for the Timber!!! project, but the process is the same, so flip back
    to [*Chapter 1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017), *C++, SFML,
    Visual Studio, and Starting the First Game* if you want a reminder of the locations
    of the various project properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio and click on the **Create New Project** button. Or, if you
    still have the Timber!!! project open, you can select **File** | **New project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window shown next, choose **Console app** and click the **Next** button.
    You will then see the **Configure your new project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Pong` in the **Project** **name** field. Note that this causes Visual
    Studio to automatically configure the **Solution name** field so that it has the
    same name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `VS Projects` folder that we created in Chapter 1\. Like the Timber!!!
    project, this will be the location that all our project files will be kept.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the option to **Place solution and project in the same directory**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you have completed these steps, click `main.cpp` file, like it was previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now configure the project to use the SFML files that we put in the `SFML`
    folder. From the main menu, select **Project** | **Pong properties…**. At this
    stage, you should have the **Pong Property Pages** window open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Pong Property Pages** window, select **All Configurations** from the
    **Configuration:** drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select **C/C++** and then **General** from the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After, locate the `\SFML\include`. The full path to type, if you located your
    `SFML` folder on your D drive, is `D:\SFML\include`. Change your path if you installed
    SFML on a different drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply** to save your configurations so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, still in the same window, perform these steps. From the left-hand menu,
    select **Linker** and then **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, find the `SFML` folder is, followed by `\SFML\lib`. So, the full path to
    type if you located your `SFML` folder on your D drive is `D:\SFML\lib`. Change
    your path if you installed SFML on a different drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply** to save your configurations so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, still in the same window, perform these steps. Switch the **Configuration:**
    drop-down to **Debug** as we will be running and testing Pong in debug mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Linker** and then **Input**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`.
    Be extra careful to place the cursor exactly at the start of the edit box's current
    content so that you don't overwrite any of the text that is already there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply** and then **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to copy the SFML `.dll` files into the main project directory.
    My main project directory is `D:\VS Projects\Pong`. It was created by Visual Studio
    in the previous steps. If you put your `VS Projects` folder somewhere else, then
    perform this step there instead. The files we need to copy into the project folder
    are located in our `SFML\bin` folder. Open a window for each of the two locations
    and highlight all the files in the `SFML\bin` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, copy and paste the highlighted files into the project folder, that is,
    `D:\VS Projects\Pong`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the project properties configured and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: We will be displaying some text for a HUD (Heads Up Display) in this game that
    will show the player's score and remaining lives. For this, we need a font.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Download this free-for-personal-use font from [http://www.dafont.com/theme.php?cat=302](http://www.dafont.com/theme.php?cat=302)
    and unzip the download. Or feel free to use a font of your choice. You will just
    need to make some minor changes to the code when we load the font.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `fonts` in the `VS Projects\Pong` folder and add
    the `DS-DIGIT.ttf` file into the `VS Projects\Pong\fonts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to code our first C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Bat class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simple Pong bat example was a good way of introducing the basics of classes.
    Classes can be simple and short, like the preceding `Bat` class, but they can
    also be longer and more complicated and contain other objects made from other
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to making games, there is a few vital things missing from the
    hypothetical `Bat` class. It might be fine for all these private member variables
    and public functions, but how will we draw anything? Our Pong bat needs a sprite,
    and in some games, they will also need a texture. Furthermore, we need a way to
    control the rate of animation of all our game objects, just like we did with the
    bee and the clouds in the previous project. We can include other objects in our
    class in exactly the same way that we included them in the `main.cpp` file. Let's
    code our `Bat` class for real so that we can see how we can solve all these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Bat.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we will code the header file. Right-click on `Bat.h`. Click
    the **Add** button. We are now ready to code the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `Bat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, note the `#pragma once` declaration at the top of the file. This prevents
    the file from being processed by the compiler more than once. As our games get
    more complicated with perhaps dozens of classes, this will speed up compilation
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Note the names of the member variables and the parameters and return types of
    the functions. We have a `Vector2f` called `m_Position`, which will hold the horizontal
    and vertical position of the player's bat. We also have an SFML `RectangleShape`,
    which will be the actual bat that appears on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There are two Boolean members that will track which direction, if any, the bat
    is currently moving in, and we have a `float` called `m_Speed` that tells us the
    number of pixels per second that the bat can move at when the player decides to
    move it left or right.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the code needs some explanation since we have a function called
    `Bat`; this is the exact same name as the class. This is called a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a class is coded, a special function is created by the compiler. We don't
    see this function in our code, but it is there. It is called a constructor. It
    is the function that would have been called if we used our hypothetical `Bat`
    class example.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to write some code to prepare an object for use, often a good place
    to do this is in the constructor. When we want the constructor to do anything
    other than simply create an instance, we must replace the default (unseen) constructor
    provided by the compiler. This is what we will do with the `Bat` constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `Bat` constructor takes two `float` parameters. This is perfect
    for initializing the position on the screen when we first create a `Bat` object.
    Also note that constructors have no return type, not even `void`.
  prefs: []
  type: TYPE_NORMAL
- en: We will soon use the constructor function, `Bat`, to put this game object into
    its starting position. Remember that this function is called at the time that
    an object of the `Bat` type is declared.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the Bat.h explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next is the `getPosition` function, which returns a `FloatRect`, the four points
    that define a rectangle. Then, we have `getShape`, which returns a `RectangleShape`.
    This will be used so that we can return to the main game loop,  `m_Shape`, so
    that it can be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `moveLeft`, `moveRight`, `stopLeft`, and `stopRight` functions,
    which are for controlling if, when, and in which direction the bat will be in
    motion.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `update` function, which takes a `Time` parameter. This
    function will be used to calculate how to move the bat each frame. As a bat and
    a ball will both move quite differently to each other, it makes sense to encapsulate
    the movement code inside the class. We will call the `update` function once each
    frame of the game from the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can probably guess that the `Ball` class will also have an `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can code `Bat.cpp`, which will implement all the definitions and use
    the member variables.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Bat.cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create the file, and then we can start discussing the code. Right-click
    the `Bat.cpp` in the **Name:** field. Click the **Add** button and our new file
    will be created for us.
  prefs: []
  type: TYPE_NORMAL
- en: We will divide the code for this file into two parts to make discussing it simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, code the `Bat` constructor function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that we include the `bat.h` file. This makes
    all the functions and variables that were declared previously in `bat.h` available
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: We implement the constructor because we need to do some work to get the instance
    set up, and the default unseen empty constructor provided by the compiler is not
    sufficient. Remember that the constructor is the code that runs when we initialize
    an instance of `Bat`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we use the `Bat::Bat` syntax as the function name to make it clear
    we are using the `Bat` function from the `Bat` class.
  prefs: []
  type: TYPE_NORMAL
- en: This constructor receives two `float` values, `startX` and `startY`. The next
    thing that happens is we assign these values to `m_Position.x` and `m_Position.y`.
    The `Vector2f` named `m_Position` now holds the values that were passed in, and
    because `m_Position` is a member variable, these values are accessible throughout
    the class. Note, however, that `m_Position` was declared as `private` and will
    not accessible in our `main` function file—not directly, anyway. We will see how
    we can resolve this issue soon.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the constructor, we initialize the `RectangleShape` called `m_Shape`
    by setting its size and position. This is different to how we coded the hypothetical
    `Bat` class in the *The theory of a Pong Bat* section. The SFML `Sprite` class
    has convenient variables for size and position that we can access using the `setSize`
    and `setPosition` functions, so we don't need the hypothetical `m_Length` and
    `m_Height` anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, note that we will need to vary how we initialize the `Bat` class
    (compared to the hypothetical `Bat` class) to suit our custom constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to implement the remaining five functions of the `Bat` class. Add the
    following code to `Bat.cpp` after the constructor we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the code we have just added.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the `getPosition` function. All it does is return a `FloatRect`
    to the code that called it. The `m_Shape.getGlobalBounds` line of code returns
    a `FloatRect` that is initialized with the coordinates of the four corners of
    the `RectangleShape`, that is, `m_Shape`. We will call this function from the
    `main` function when we are determining whether the ball has hit the bat.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `getShape` function. All this function does is pass a copy
    of `m_Shape` to the calling code. This is necessary so that we can draw the bat
    in the `main` function. When we code a public function with the sole purpose of
    passing back private data from a class, we call it a getter function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can look at the `moveLeft`, `moveRight`, `stopLeft`, and `stopRight`
    functions. All they do is set the `m_MovingLeft` and `m_MovingRight` Boolean variables
    appropriately so that they keep track of the player's current intentions. Note,
    however, that they don't do anything to the `RectangleShape` instance or the `FloatRect`
    instance that determine the position. This is just what we need.
  prefs: []
  type: TYPE_NORMAL
- en: The last function in the `Bat` class is `update`. We will call this function
    once per frame of the game. The `update` function will grow in complexity as our
    game projects get more complicated. For now, all we need to do is tweak `m_Position`,
    depending on whether the player is moving left or right. Note that the formula
    that's used to do this tweak is the same one that we used for updating the bee
    and the clouds in the Timber!!! project. The code multiplies the speed by the
    delta time and then adds or subtracts it from the position. This causes the bat
    to move relative to how long the frame took to update. Next, the code sets the
    position of `m_Shape` with whatever the latest values held in `m_Position` happen
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: Having an `update` function in our `Bat` class rather than the `main` function
    is encapsulation. Rather than updating the positions of all the game objects in
    the `main` function like we did in the Timber!!! project, each object will be
    responsible for updating themselves. As we will do next, however, we will call
    this `update` function from the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Bat class and coding the main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switch to the `main.cpp` file that was automatically generated when we created
    the project. Delete all its auto-generated code and add the code that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code the `Pong.cpp` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the structure is similar to the one we used in the Timber!!!
    project. The first exception, however, is when we create an instance of the `Bat`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls the constructor function to create a new instance of
    the `Bat` class. The code passes in the required arguments and allows the `Bat`
    class to initialize its position in the center of the screen near the bottom.
    This is the perfect position for our bat to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that I have used comments to indicate where the rest of the code
    will eventually be placed. It is all within the game loop, just like it was in
    the Timber!!! project. Here is where the rest of the code will go again, just
    to remind you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the code to the `Handle the player input` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code handles the player quitting the game by pressing the *Escape*
    key, exactly like it did in the Timber!!! project. Next, there are two `if` –
    `else` structures that handle the player moving the bat. Let''s analyze the first
    of these two structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will detect whether the player is holding down the left arrow
    cursor key on the keyboard. If they are, then the `moveLeft` function is called
    on the `Bat` instance. When this function is called, the `true` value is set to
    the `m_MovingLeft` private Boolean variable. If, however, the left arrow key is
    not being held down, then the `stopLeft` function is called and the `m_MovingLeft`
    is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The exact same process is then repeated in the next `if` – `else` block of code
    to handle the player pressing (or not pressing) the right arrow key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following code to the `Update the bat the ball and the HUD` section,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the exact same timing technique that we used for
    the Timber!!! project, only this time, we call `update` on the `Bat` instance
    and pass in the delta time. Remember that, when the `Bat` class receives the delta
    time, it will use the value to move the bat based on the previously received movement
    instructions from the player and the desired speed of the bat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following code to the `Draw the bat, the ball and the HUD` section,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we clear the screen, draw the text for the HUD, and use
    the `bat.getShape` function to grab the `RectangleShape` instance from the `Bat`
    instance and draw it to the screen. Finally, we call `window.display`, just like
    we did in the previous project, to draw the bat in its current position.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, you can run the game and you will see the HUD and a bat. The
    bat can be moved smoothly left and right using the arrow/cursor keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image86209.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! That is the first class, all coded and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered the basics of OOP, such as how to code and use
    a class, including making use of encapsulation to control how code outside of
    our classes can access the member variables, but only to the extent and in the
    manner that we want it to. This is just like SFML classes, which allow us to create
    and use `Sprite` and `Text` instances, but only in the way they were designed
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Don't concern yourself too much if some of the details around OOP and classes
    are not entirely clear. The reason I say this is because we will spend the rest
    of this book coding classes and the more we use them, the clearer they will become.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we have a working bat and a HUD for our Pong game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will code the `Ball` class and get it bouncing around
    the screen. We will then be able to add collision detection and finish the game.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) I have learned other languages and OOP seems much simpler in C++. Is this
    a correct assessment?
  prefs: []
  type: TYPE_NORMAL
- en: A) This was an introduction to OOP and its basic fundamentals. There is more
    to it than this. We will learn about more OOP concepts and details throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
