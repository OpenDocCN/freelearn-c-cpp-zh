["```cpp\n    cocos new MiniPool -p com.rengelbert.MiniPool -l cpp -d /Users/rengelbert/Desktop/MiniPool\n    ```", "```cpp\n    class HelloWorld : public cocos2d::Layer {\n    public:\n        virtual ~HelloWorld();\n        HelloWorld();\n\n       static cocos2d::Scene* scene();\n\n        void initPhysics();\n        void update(float dt);\n        virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;\n\n    private:\n       GLESDebugDraw * _debugDraw;\n        b2World* world;\n        Mat4 _modelViewMV;\n        void onDraw();\n        CustomCommand _customCommand;\n    };\n    ```", "```cpp\n    #include \"GLES-Render.h\"\n    ```", "```cpp\n    #define PTM_RATIO 32\n\n    HelloWorld::HelloWorld()\n    {\n        this->initPhysics();\n        scheduleUpdate();\n    }\n\n    HelloWorld::~HelloWorld()\n    {\n        delete world;\n        world = nullptr;\n\n        delete _debugDraw;\n       _debugDraw = nullptr;\n    }\n\n    void HelloWorld::initPhysics() {\n\n        b2Vec2 gravity;\n        gravity.Set(0.0f, -10.0f);\n        world = new b2World(gravity);\n\n        // Do we want to let bodies sleep?\n        world->SetAllowSleeping(true);\n        world->SetContinuousPhysics(true);\n\n        _debugDraw = new (std::nothrow) GLESDebugDraw( PTM_RATIO );\n        world->SetDebugDraw(_debugDraw);\n\n        uint32 flags = 0;\n        flags += b2Draw::e_shapeBit;\n        //        flags += b2Draw::e_jointBit;\n        //        flags += b2Draw::e_aabbBit;\n        //        flags += b2Draw::e_pairBit;\n        //        flags += b2Draw::e_centerOfMassBit;\n        _debugDraw->SetFlags(flags);\n\n    }\n    void HelloWorld::update(float dt)\n    {\n        world->Step(dt, 8, 1);\n\n    }\n    ```", "```cpp\n    void GameLayer::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)\n    {\n       //\n        // IMPORTANT:\n        // This is only for debug purposes\n        // It is recommended to disable it\n        //\n       Layer::draw(renderer, transform, flags);\n      GL::enableVertexAttribs( cocos2d::GL::VERTEX_ATTRIB_FLAG_POSITION );\n        auto director = Director::getInstance();\n        CCASSERT(nullptr != director, \"Director is null when setting matrix stack\");\n        director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n\n        _modelViewMV = director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n\n        _customCommand.init(_globalZOrder);\n        _customCommand.func = CC_CALLBACK_0(GameLayer::onDraw, this);\n        renderer->addCommand(&_customCommand);\n\n        director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n\n    }\n\n    void GameLayer::onDraw()\n    {\n       auto director = Director::getInstance();\n       Mat4 oldMV;\n        oldMV = director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n        director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewMV);\n        _world->DrawDebugData();\n        director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, oldMV);\n    }\n    ```", "```cpp\nb2Vec2 gravity;\ngravity.Set(0.0f, -10.0f);\nworld = new b2World(gravity);\n\n// Do we want to let bodies sleep?\nworld->SetAllowSleeping(true);\nworld->SetContinuousPhysics(true);\n\n_debugDraw = new (std::nothrow) GLESDebugDraw( PTM_RATIO );\nworld->SetDebugDraw(_debugDraw);\n\nuint32 flags = 0;\nflags += b2Draw::e_shapeBit;\n//        flags += b2Draw::e_jointBit;\n//        flags += b2Draw::e_aabbBit;\n//        flags += b2Draw::e_pairBit;\n//        flags += b2Draw::e_centerOfMassBit;\n_debugDraw->SetFlags(flags);\n```", "```cpp\nworld->Step(dt, 8, 1);\n```", "```cpp\nHelloWorld::~HelloWorld(){\n    delete world;\n    world = nullptr;\n\n    delete _debugDraw;\n   _debugDraw = nullptr;\n}\n```", "```cpp\nb2BodyDef bodyDef;\nbodyDef.type = b2_dynamicBody;\n//or make it static bodyDef.type = b2_staticBody;\nb2Body * body = world->CreateBody(&bodyDef);\n\n//create circle shape\nb2CircleShape  circle;\ncircle.m_radius = 20.0/PTM_RATIO;\n\n//define fixture\nb2FixtureDef fixtureDef;\nfixtureDef.shape = &circle;\nfixtureDef.density = 1;\nfixtureDef.restitution = 0.7;\nfixtureDef.friction = 0.4;\n\nbody->CreateFixture(&fixtureDef);\n```", "```cpp\n//create body\nb2BodyDef bodyDef;\nbodyDef.type = b2_dynamicBody;\nb2Body * body = world->CreateBody(&bodyDef);\n\n//define shape\nb2PolygonShape box;\nbox.SetAsBox(20 /PTM_RATIO, 20 / PTM_RATIO);\n\n//Define fixture\nb2FixtureDef fixtureDef;\nfixtureDef.shape = &box;\nfixtureDef.density = 2;\nfixtureDef.restitution = 0;\nbody->CreateFixture(&fixtureDef);\n```", "```cpp\n//in AppDelegate.cpp\nauto screenSize = glview->getFrameSize();\nauto designSize = Size(320, 480);\n\nglview->setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy::SHOW_ALL);\nstd::vector<std::string> searchPaths;\n   if (screenSize.width > 640) {\n      searchPaths.push_back(\"ipadhd\");\n      director->setContentScaleFactor(1280/designSize.width);\n   } else if (screenSize.width > 320) {\n      searchPaths.push_back(\"ipad\");\n      director->setContentScaleFactor(640/designSize.width);\n   } else {\n      searchPaths.push_back(\"iphone\");\n      director->setContentScaleFactor(320/designSize.width);\n   }\n   auto fileUtils = FileUtils::getInstance();\n   fileUtils->setSearchPaths(searchPaths);\n```", "```cpp\nb2Body * pocket;\nb2CircleShape circle;\nfloat startX = _screenSize.width * 0.07;\nfloat startY = _screenSize.height * 0.92f;\nfor (int i = 0; i < 6; i++) {\n   bodyDef.type = b2_staticBody;\n   if (i < 3) {\n      bodyDef.position.Set(startX/PTM_RATIO,\n(startY - i * (_screenSize.height * 0.84f * 0.5f))/PTM_RATIO);\n\n    } else {\n        bodyDef.position.Set(\n        (startX + _screenSize.width * 0.85f)/PTM_RATIO,\n        (startY - (i-3) * (_screenSize.height * 0.84f * 0.5f))/PTM_RATIO);\n    }\n    pocket = _world->CreateBody(&bodyDef);\n    fixtureDef.isSensor = true;\n    circle.m_radius = (float) (1.5 * BALL_RADIUS) / PTM_RATIO;\n    fixtureDef.shape = &circle;\n\n    pocket->CreateFixture(&fixtureDef);\n    auto pocketData = new b2Sprite(this, kSpritePocket);\n    pocket->SetUserData(pocketData);\n}\n```", "```cpp\nfixtureDef.isSensor = true;\n```", "```cpp\nb2BodyDef tableBodyDef;\ntableBodyDef.position.Set(0, 0);\nb2Body* tableBody = _world->CreateBody(&tableBodyDef);\n\n// Define the table edges\nb2EdgeShape tableBox;\n\n// bottom edge\ntableBox.Set(b2Vec2(_screenSize.width * 0.14f/PTM_RATIO, _screenSize.height * 0.09f/PTM_RATIO),\nb2Vec2(_screenSize.width * 0.86f/PTM_RATIO, _screenSize.height * 0.09f/PTM_RATIO));\ntableBody->CreateFixture(&tableBox,0);\n\n// top edge\ntableBox.Set(b2Vec2(_screenSize.width * 0.14f/PTM_RATIO, _screenSize.height * 0.91f/PTM_RATIO),\n    b2Vec2(_screenSize.width * 0.86f/PTM_RATIO, _screenSize.height * 0.91f/PTM_RATIO));\ntableBody->CreateFixture(&tableBox,0);\n```", "```cpp\n//create Box2D body\nb2BodyDef bodyDef;\nbodyDef.type = b2_dynamicBody;\n\n_body = _game->getWorld()->CreateBody(&bodyDef);\n_body->SetLinearDamping(1.2f);\n_body->SetAngularDamping(0.2f);\n\n//create circle shape\nb2CircleShape  circle;\ncircle.m_radius = BALL_RADIUS/PTM_RATIO;\n\n//define fixture\nb2FixtureDef fixtureDef;\nfixtureDef.shape = &circle;\nfixtureDef.density = 5;\nfixtureDef.restitution = 0.7f;\n\n//add collision filters so only white ball can be hit by cue\nif (_type == kSpriteBall) {\n    fixtureDef.filter.categoryBits = 0x0010;\n} else if (_type == kSpritePlayer) {\n//white ball is tracked as bullet by simulation\n    _body->SetBullet(true);\n    fixtureDef.filter.categoryBits = 0x0100;\n}\n\n//set sprite texture\nswitch (_color) {\n    case kColorBlack:\n        this->initWithSpriteFrameName(\"ball_black.png\");\n        break;\n    case kColorRed:\n        this->initWithSpriteFrameName(\"ball_red.png\");\n        break;\n    case kColorYellow:\n        this->initWithSpriteFrameName(\"ball_yellow.png\");\n        break;\n    case kColorWhite:\n        this->initWithSpriteFrameName(\"ball_white.png\");\n        break;\n}\n\n_body->CreateFixture(&fixtureDef);\n//store the b2Sprite as the body's userData\n_body->SetUserData(this);\n```", "```cpp\n_body->SetLinearDamping(1.2);\n```", "```cpp\n_body->SetAngularDamping(0.2);\n```", "```cpp\n_body->SetBullet(true);\n```", "```cpp\nfixtureDef.filter.categoryBits = 0x0100;\n```", "```cpp\nfixtureDef.filter.maskBits = 0x0100;\n```", "```cpp\nfixtureDef.filter.maskBits = 0x0100 | 0x0010;\n```", "```cpp\nfixtureDef.filter.maskBits = 0xFFFF & ~0x0100;\n```", "```cpp\n//create body\nb2BodyDef bodyDef;\nbodyDef.type = b2_dynamicBody;\n\n_body = _game->getWorld()->CreateBody(&bodyDef);\n_body->SetLinearDamping(8);\n_body->SetAngularDamping(5);\n\n//Define shape\nb2PolygonShape box;\nbox.SetAsBox(BALL_RADIUS * 21 /PTM_RATIO, BALL_RADIUS * 0.2 / PTM_RATIO);\n\n//Define fixture\nb2FixtureDef fixtureDef;\nfixtureDef.shape = &box;\nfixtureDef.filter.maskBits = 0x0100;\nfixtureDef.density = 10;\nfixtureDef.restitution = 1;\n_body->CreateFixture(&fixtureDef);\n_body->SetUserData(this);\n```", "```cpp\nb2Vec2 vertices[3];\nvertices[0].Set(0.0f, 0.0f);\nvertices[1].Set(1.0f, 0.0f);\nvertices[2].Set(0.0f, 1.0f);\nint32 count = 3;\n\nb2PolygonShape triangle;\ntriangle.Set(vertices, count);\n```", "```cpp\nb2Vec2 gravity;\ngravity.Set(0.0f, 0.0f);\n_world = new b2World(gravity);\n\n_world->SetAllowSleeping(true);\n_world->SetContinuousPhysics(true);\n_collisionListener = new CollisionListener();\n_world->SetContactListener(_collisionListener);\n```", "```cpp\nvoid CollisionListener::BeginContact(b2Contact* contact) {\n    b2Body * bodyA = contact->GetFixtureA()->GetBody();\n    b2Body * bodyB = contact->GetFixtureB()->GetBody();\n\n    b2Sprite * spriteA = (b2Sprite *) bodyA->GetUserData();\n    b2Sprite * spriteB = (b2Sprite *) bodyB->GetUserData();\n\n    if (spriteA && spriteB) {\n        //track collision between balls and pockets\n        if (spriteA->getType() == kSpritePocket) {\n            spriteB->setVisible(false);\n        } else if (spriteB->getType() == kSpritePocket) {\n            spriteA->setVisible(false);\n        } else if (spriteA->getType() == kSpriteBall &&\n            spriteB->getType() == kSpriteBall) {\n            if (spriteA->mag() > 10 || spriteB->mag() > 10) {\n            SimpleAudioEngine::getInstance()->playEffect(\"ball.wav\");\n            }\n        } else if ((spriteA->getType() == kSpriteBall &&\n                    spriteB->getType() == kSpritePlayer) ||\n                    (spriteB->getType() == kSpriteBall &&\n                    spriteA->getType() == kSpritePlayer)) {\n            if (spriteA->mag() > 10 || spriteB->mag() > 10) {\n               SimpleAudioEngine::getInstance()->playEffect(\"ball.wav\");\n            }\n        }\n    }\n}\n```", "```cpp\nvoid CollisionListener::PreSolve(b2Contact* contact, const b2Manifold* oldManifold)  {\n\n    b2Body * bodyA = contact->GetFixtureA()->GetBody();\n    b2Body * bodyB = contact->GetFixtureB()->GetBody();\n\n    b2Sprite * spriteA = (b2Sprite *) bodyA->GetUserData();\n    b2Sprite * spriteB = (b2Sprite *) bodyB->GetUserData();\n\n    if (spriteA && spriteB) {\n\n    //track collision between player and cue ball\n        if (spriteA->getType() == kSpriteCue && spriteA->mag() > 2) {\n            if (spriteB->getType() == kSpritePlayer && spriteA->isVisible()) {\n                SimpleAudioEngine::getInstance()->playEffect(\"hit.wav\");\n                spriteA->setVisible(false);\n                spriteB->getGame()->setCanShoot(false);\n            }\n        } else if (spriteB->getType() == kSpriteCue && spriteA->mag()> 2) {\n            if (spriteA->getType() == kSpritePlayer && spriteB->isVisible()) {\n                SimpleAudioEngine::getInstance()->playEffect(\"hit.wav\");\n                spriteB->setVisible(false);\n                spriteA->getGame()->setCanShoot(false);\n            }\n        } \n\n    }\n}\n```", "```cpp\n    bool GameLayer::onTouchBegan(Touch * touch, Event * event) {\n\n        if (!_running) return true;\n\n        if (_gameState == kGameOver) {\n            if (_gameOver->isVisible()) _gameOver->setVisible(false);\n            resetGame();\n            return true;\n        }\n    ```", "```cpp\n    if (!_canShoot) return true;\n    ```", "```cpp\n    if (touch) {\n\n        auto tap = touch->getLocation();\n        auto playerPos = _player->getPosition();\n        float diffx = tap.x - playerPos.x;\n        float diffy = tap.y - playerPos.y;\n        float diff = pow(diffx, 2) + pow(diffy, 2);\n        if (diff < pow(BALL_RADIUS * 4, 2)) {\n            if (_gameState != kGamePlay) {\n                _gameState = kGamePlay;\n                if (_intro->isVisible()) _intro->setVisible(false);\n                _timer->setVisible(true);\n            }\n        }\n    }\n    ```", "```cpp\n    //make point lie within ball\n    if (diff > pow(BALL_RADIUS * 2, 2)) {\n        float angle = atan2(diffy, diffx);\n        _cueStartPoint = Vec2(\n                playerPos.x + BALL_RADIUS * 0.8f * cos(angle),\n                playerPos.y + BALL_RADIUS * 0.8f * sin(angle));\n    } else {\n        _cueStartPoint = playerPos;\n    }\n    ```", "```cpp\n    _lineContainer->setBallPoint(_cueStartPoint);\n    _cue->getBody()->SetLinearVelocity(b2Vec2(0,0));\n    _cue->getBody()->SetAngularVelocity(0.0);\n    _touch = touch;\n    ```", "```cpp\n    void GameLayer::onTouchMoved(Touch * touch, Event * event) {\n       if (touch && touch == _touch) {\n             Point tap = touch->getLocation();\n             float diffx = tap.x - _player->getPositionX();\n             float diffy = tap.y - _player->getPositionY();\n             if (pow(diffx,2) + pow(diffy,2) < pow(BALL_RADIUS * 2,2)) {\n                _usingCue = false;\n                _lineContainer->setDrawing(false);\n                _cue->setVisible(false);\n               _cue->getBody()->SetAwake(false);\n             } else {\n               _usingCue = true;\n               _cue->setVisible(true);\n               _lineContainer->setDrawing(true);\n              placeCue(tap);\n              _cue->getBody()->SetAwake(true);\n             }\n       }\n    }\n    ```", "```cpp\n    void GameLayer::placeCue(Point position) {\n        float diffx = _cueStartPoint.x - position.x;\n        float diffy = _cueStartPoint.y - position.y;\n\n        float angle = atan2(diffy, diffx);\n       float distance = sqrt(pow (diffx, 2) + pow(diffy, 2));\n\n        _pullBack = distance * 0.5f;\n        Point cuePosition = Vec2(\n            _cueStartPoint.x - (BALL_RADIUS * 21 + _pullBack) * cos(angle),\n            _cueStartPoint.y - (BALL_RADIUS * 21 + _pullBack) * sin(angle)\n        );\n\n        _cue->getBody()->SetTransform(\n            b2Vec2(cuePosition.x/PTM_RATIO, cuePosition.y/PTM_RATIO), \n            angle);\n\n        _lineContainer->setCuePoint(Vec2(\n            _cueStartPoint.x - ( _pullBack) * cos(angle),\n         _cueStartPoint.y - ( _pullBack) * sin(angle)));\n    }\n    ```", "```cpp\n    void GameLayer::onTouchEnded(Touch* touch, Event* event) {\n\n        if (_usingCue && _touch) {\n            auto cueBody = _cue->getBody();\n            float angle = cueBody->GetAngle();\n\n            //release cue!\n            cueBody->ApplyLinearImpulse(\n                b2Vec2 (_pullBack * cos(angle) * SHOT_POWER,\n                _pullBack * sin(angle) * SHOT_POWER),\n                cueBody->GetWorldCenter());\n        }\n\n        _usingCue = false;\n        _touch = nullptr;\n        _lineContainer->setDrawing(false);\n    }\n    ```", "```cpp\nvoid b2Sprite::update(float dt) {\n    if (_body && this->isVisible()) {\n        this->setPositionX(_body->GetPosition().x * PTM_RATIO);\n        this->setPositionY(_body->GetPosition().y * PTM_RATIO);\n        this->setRotation(_RADIANS_TO_DEGREES(-1 * _body->GetAngle()));\n    }\n}\n```", "```cpp\n    void GameLayer::update(float dt) {\n\n       if (!_running) return;\n       if (_gameState == kGameOver) return;\n        _world->Step(dt, 10, 10);\n    ```", "```cpp\n    //track invisible objects\n    for (auto ball : _balls) {\n       if (!ball->isVisible() && ball->getInPlay()) {\n            ball->setInPlay(false);\n            ball->hide();\n            //count down balls\n            _ballsInPlay--;\n            SimpleAudioEngine::getInstance()->playEffect(\"drop.wav\");\n            if (_ballsInPlay == 0) {\n                _gameState = kGameOver;\n                _gameOver->setVisible(true);\n            }\n        } else {\n            ball->update(dt);\n        }\n    }\n    ```", "```cpp\n    if (!_cue->isVisible())  {\n        _cue->hide();\n    } else {\n        _cue->update(dt);\n    }\n    if (!_player->isVisible()) {\n        _player->reset();\n        _player->setVisible(true);\n        SimpleAudioEngine::getInstance()->playEffect(\"whitedrop.wav\");\n    }\n    _player->update(dt);\n    ```", "```cpp\n    //check to see if player ball is slow enough for a new shot\n    if (_player->mag() < 0.5f && !_canShoot) {\n        _player->getBody()->SetLinearVelocity(b2Vec2_zero);\n        _player->getBody()->SetAngularVelocity(0);\n        _canShoot = true;\n    }\n    ```", "```cpp\n    this->schedule(CC_SCHEDULE_SELECTOR(GameLayer::ticktock), 1.5f);\n    ```", "```cpp\n    void GameLayer::ticktock(float dt) {\n        if (_gameState == kGamePlay) {\n            _time++;\n            _timer->setString(std::to_string(_time));\n        }\n    }\n    ```", "```cpp\n    LOCAL_SRC_FILES := hellocpp/main.cpp \\\n                       ../../Classes/AppDelegate.cpp \\\n                      ../../Classes/GLES-Render.cpp \\\n                       ../../Classes/b2Sprite.cpp \\\n                       ../../Classes/Ball.cpp \\\n                       ../../Classes/CollisionListener.cpp \\\n                       ../../Classes/Cue.cpp \\\n                       ../../Classes/LineContainer.cpp \\\n                       ../../Classes/GameLayer.cpp \n    ```"]