["```cpp\n    class Customer; \n\n    class Book { \n      public: \n      Book(); \n      Book(const string& author, const string& title); \n\n      const string& author() const { return m_author; } \n      const string& title() const { return m_title; } \n\n      void read(ifstream& inStream); \n      void write(ofstream& outStream) const; \n\n      int reserveBook(Customer* customerPtr); \n      void removeReservation(Customer* customerPtr); \n      void returnBook(); \n```", "```cpp\n    Customer*& borrowerPtr() { return m_borrowerPtr; } \n    const Customer* borrowerPtr() const { return m_borrowerPtr; } \n```", "```cpp\n    list<Customer*>& reservationPtrList() \n                     { return m_reservationPtrList; } \n    const list<Customer*> reservationPtrList() const \n                          { return m_reservationPtrList; } \n```", "```cpp\n    friend ostream& operator<<(ostream& outStream, \n          const Book& book); \n```", "```cpp\n    private: \n      string m_author, m_title; \n```", "```cpp\n    Customer* m_borrowerPtr = nullptr; \n```", "```cpp\n    list<Customer*> m_reservationPtrList; \n      }; \n```", "```cpp\n    #include <Set> \n    #include <Map> \n    #include <String> \n    #include <FStream> \n    #include <Algorithm> \n    using namespace std; \n\n    #include \"Book.h\" \n    #include \"Customer.h\" \n    #include \"Library.h\" \n```", "```cpp\n    Book::Book() { \n      // Empty. \n    } \n```", "```cpp\n    Book::Book(const string& author, const string& title) \n    :m_author(author), \n    m_title(title) { \n      // Empty. \n    } \n```", "```cpp\n    void Book::read(ifstream& inStream) { \n      getline(inStream, m_author); \n      getline(inStream, m_title); \n    } \n\n    void Book::write(ofstream& outStream) const { \n      outStream << m_author << endl; \n      outStream << m_title << endl; \n    }\n```", "```cpp\n    int Book::reserveBook(Customer* borrowerPtr) { \n      m_reservationPtrList.push_back(borrowerPtr); \n      return m_reservationPtrList.size(); \n    } \n```", "```cpp\n    void Book::returnBook() { \n      m_borrowerPtr = nullptr; \n    } \n```", "```cpp\n    void Book::removeReservation(Customer* customerPtr) { \n      m_reservationPtrList.remove(customerPtr); \n    } \n```", "```cpp\n    ostream& operator<<(ostream& outStream, const Book& book) { \n     outStream << \"\"\" << book.m_title << \"\" by \" << book.m_author; \n```", "```cpp\n    if (book.m_borrowerPtr != nullptr) { \n        outStream << endl << \"  Borrowed by: \" \n              << book.m_borrowerPtr->name() << \".\"; \n    } \n```", "```cpp\n    if (!book.m_reservationPtrList.empty()) { \n      outStream << endl << \"  Reserved by: \"; \n\n      bool first = true; \n      for (Customer* customerPtr : book.m_reservationPtrList) { \n        outStream << (first ? \"\" : \",\") << customerPtr->name(); \n        first = false; \n      } \n\n      outStream << \".\"; \n    } \n\n    return outStream; \n```", "```cpp\nclass Customer { \n  public: \n    Customer(); \n    Customer(const string& name, const string& address); \n\n    const string& name() const { return m_name; } \n    const string& address() const { return m_address; } \n\n    void read(ifstream& inStream); \n    void write(ofstream& outStream) const; \n```", "```cpp\n    void borrowBook(Book* bookPtr); \n    void returnBook(Book* bookPtr); \n    void reserveBook(Book* bookPtr); \n    void unreserveBook(Book* bookPtr); \n```", "```cpp\n    set<Book*>& loanPtrSet() { return m_loanPtrSet; } \n    const set<Book*> loanPtrSet() const { return m_loanPtrSet; } \n\n    set<Book*>& reservationPtrSet(){ return m_reservationPtrSet; } \n    const set<Book*> reservationPtrSet() const \n                     { return m_reservationPtrSet; } \n```", "```cpp\n    friend ostream& operator<<(ostream& outStream, \n                               const Customer& customer); \n```", "```cpp\n  private: \n    string m_name, m_address; \n```", "```cpp\n    set<Book*> m_loanPtrSet, m_reservationPtrSet; \n      }; \n```", "```cpp\n    #include <Set> \n    #include <Map> \n    #include <String> \n    #include <FStream> \n    using namespace std; \n\n    #include \"Book.h\" \n    #include \"Customer.h\" \n    #include \"Library.h\" \n```", "```cpp\n    Customer::Customer() { \n     // Empty. \n    } \n```", "```cpp\n    Customer::Customer(const string& name, const string& address) \n    :m_name(name), \n    m_address(address) { \n       // Empty. \n    } \n```", "```cpp\n    void Customer::read(ifstream& inStream) { \n      getline(inStream, m_name); \n      getline(inStream, m_address); \n    } \n\n    void Customer::write(ofstream& outStream) const { \n     outStream << m_name << endl; \n     outStream << m_address << endl; \n    } \n```", "```cpp\n    void Customer::borrowBook(Book* bookPtr) { \n      m_loanPtrSet.insert(bookPtr); \n      m_reservationPtrSet.erase(bookPtr); \n    } \n```", "```cpp\n    void Customer::reserveBook(Book* bookPtr) { \n      m_reservationPtrSet.insert(bookPtr); \n    } \n\n    void Customer::returnBook(Book* bookPtr) { \n      m_loanPtrSet.erase(bookPtr); \n    } \n\n    void Customer::unreserveBook(Book* bookPtr) { \n      m_reservationPtrSet.erase(bookPtr); \n    } \n```", "```cpp\n    ostream& operator<<(ostream& outStream, const Customer& customer){ \n      outStream << customer.m_name << \", \" \n      << customer.m_address << \".\"; \n```", "```cpp\n    if (!customer.m_loanPtrSet.empty()) { \n      outStream << endl << \"  Borrowed books: \"; \n\n      bool first = true; \n      for (const Book* bookPtr : customer.m_loanPtrSet) { \n        outStream << (first ? \"\" : \", \") << bookPtr->author(); \n        first = false; \n      } \n    } \n```", "```cpp\n    if (!customer.m_reservationPtrSet.empty()) { \n      outStream << endl << \"  Reserved books: \"; \n\n      bool first = true; \n      for (Book* bookPtr : customer.m_reservationPtrSet) { \n        outStream << (first ? \"\" : \", \") << bookPtr->author(); \n        first = false; \n      } \n    } \n\n    return outStream;\n```", "```cpp\nclass Library { \n  public: \n    Library(); \n```", "```cpp\n    ~Library(); \n\n    private: \n      static string s_binaryPath; \n```", "```cpp\n    Book* lookupBook(const string& author, const string& title); \n    Customer* lookupCustomer(const string& name, \n                             const string& address); \n\n    void addBook(); \n    void deleteBook(); \n    void listBooks(); \n    void addCustomer(); \n    void deleteCustomer(); \n    void listCustomers(); \n    void borrowBook(); \n    void reserveBook(); \n    void returnBook(); \n```", "```cpp\n    int lookupBookIndex(const Book* bookPtr); \n    int lookupCustomerIndex(const Customer* customerPtr);\n```", "```cpp\n    Book* lookupBookPtr(int bookIndex); \n    Customer* lookupCustomerPtr(int customerIndex); \n```", "```cpp\n    void save(); \n    void load(); \n```", "```cpp\n      list<Book*> m_bookPtrList; \n      list<Customer*> m_customerPtrList; \n      }; \n```", "```cpp\n   #include <Set> \n   #include <Map> \n   #include <List> \n   #include <String> \n   #include <FStream> \n   #include <IOStream> \n   #include <CAssert> \n   using namespace std; \n\n   #include \"Book.h\" \n   #include \"Customer.h\" \n   #include \"Library.h\" \n\n   string Library::s_binaryPath(\"C:\\Users\\Stefan\\Library.binary\"); \n```", "```cpp\n    Library::Library() { \n      load(); \n\n      bool quit = false; \n      while (!quit) { \n        cout << \"1\\. Add Book\" << endl \n          << \"2\\. Delete Book\" << endl \n          << \"3\\. List Books\" << endl \n          << \"4\\. Add Customer\" << endl \n          << \"5\\. Delete Customer\" << endl \n          << \"6\\. List Customers\" << endl \n          << \"7\\. Borrow Book\" << endl \n          << \"8\\. Reserve Book\" << endl \n          << \"9\\. Return Book\" << endl \n          << \"0\\. Quit\" << endl \n          << \": \"; \n\n        int choice; \n        cin >> choice; \n        cout << endl; \n\n        switch (choice) { \n          case 1: \n          addBook(); \n          break; \n\n          case 2: \n          deleteBook(); \n          break; \n\n          case 3: \n          listBooks(); \n          break; \n\n          case 4: \n          addCustomer(); \n          break; \n\n          case 5: \n          deleteCustomer(); \n          break; \n\n          case 6: \n          listCustomers(); \n          break; \n\n          case 7: \n          borrowBook(); \n          break; \n\n          case 8: \n          reserveBook(); \n          break; \n\n          case 9: \n          returnBook(); \n          break; \n\n          case 0: \n          quit = true; \n          break; \n        } \n\n       cout << endl; \n     } \n\n    save(); \n    } \n```", "```cpp\n    Book* Library::lookupBook(const string& author, \n                          const string& title) { \n    for (Book* bookPtr : m_bookPtrList) { \n      if ((bookPtr->author() == author) && \n         (bookPtr->title() == title)) { \n        return bookPtr; \n      } \n    } \n\n    return nullptr; \n   } \n```", "```cpp\n    Customer* Library::lookupCustomer(const string& name, \n         const string& address) { \n    for (Customer* customerPtr : m_customerPtrList) { \n      if ((customerPtr->name() == name) && \n         (customerPtr->address() == address)) { \n         return customerPtr; \n      } \n    } \n    return nullptr; \n```", "```cpp\n    void Library::addBook() { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n     string title; \n     cout << \"Title: \"; \n     cin >> title; \n```", "```cpp\n      if (lookupBook(author, title) != nullptr) { \n        cout << endl << \"The book \"\" << title << \"\" by \" \n          << author << \" already exists.\" << endl; \n        return; \n      } \n```", "```cpp\n      Book* bookPtr = new Book(author, title); \n      assert(bookPtr != nullptr); \n      m_bookPtrList.push_back(bookPtr); \n      cout << endl << \"Added.\" << endl; \n    } \n```", "```cpp\n     void Library::deleteBook() { \n       string author; \n       cout << \"Author: \"; \n       cin >> author; \n\n       string title; \n       cout << \"Title: \"; \n       cin >> title; \n```", "```cpp\n     Book* bookPtr = lookupBook(author, title); \n```", "```cpp\n       if (bookPtr == nullptr) { \n         cout << endl << \"The book \"\" << title << \"\" by \" \n           << author << \" does not exist.\" << endl; \n         return; \n       } \n```", "```cpp\n        Customer* borrowerPtr = bookPtr->borrowerPtr(); \n```", "```cpp\n  if (borrowerPtr != nullptr) { \n    borrowerPtr->returnBook(bookPtr); \n  } \n```", "```cpp\n    list<Customer*> reservationPtrList = \n      bookPtr->reservationPtrList(); \n```", "```cpp\n      for (Customer* reserverPtr : reservationPtrList) { \n        reserverPtr->unreserveBook(bookPtr); \n      }\n```", "```cpp\n      m_bookPtrList.remove(bookPtr); \n        n cout << endl << \"Deleted:\" << bookPtr << endl; \n        delete bookPtr; \n      } \n```", "```cpp\n    void Library::listBooks() { \n      if (m_bookPtrList.empty()) { \n       cout << \"No books.\" << endl; \n       return; \n      } \n    }\n```", "```cpp\n      for (const Book* bookPtr : m_bookPtrList) { \n        cout << (*bookPtr) << endl; \n        } \n    } \n```", "```cpp\n    void Library::addCustomer() { \n      string name; \n       cout << \"Name: \"; \n       cin >> name; \n\n       string address; \n       cout << \"Address: \"; \n       cin >> address;\n```", "```cpp\n      if (lookupCustomer(name, address) != nullptr) { \n        cout << endl << \"A customer with name \" << name \n         << \" and address \" << address << \" already exists.\" \n         << endl; \n       return; \n      } \n```", "```cpp\n      Customer* customerPtr = new Customer(name, address); \n        assert(customerPtr != nullptr); \n        m_customerPtrList.push_back(customerPtr); \n        cout << endl << \"Added.\" << endl; \n      } \n```", "```cpp\n    void Library::deleteCustomer() { \n      string name; \n      cout << \"Customer name: \"; \n      cin >> name; \n\n      string address; \n      cout << \"Address: \"; \n      cin >> address; \n\n      Customer* customerPtr = lookupCustomer(name, address); \n```", "```cpp\n    if (customerPtr == nullptr) { \n      cout << endl << \"Customer \" << name \n         << \" does not exists.\" << endl; \n      return; \n    }\n```", "```cpp\n     if (!customerPtr->loanPtrSet().empty()) { \n      cout << \"The customer \" << customerPtr->name() \n         << \" has borrowed books and cannot be deleted.\" << endl; \n      return; \n     } \n```", "```cpp\n     for (Book* bookPtr : m_bookPtrList) { \n       bookPtr->removeReservation(customerPtr); \n     } \n```", "```cpp\n      m_customerPtrList.remove(customerPtr); \n      cout << endl << \"Deleted.\" << (*customerPtr) << endl; \n      delete customerPtr; \n    } \n```", "```cpp\n    void Library::listCustomers() { \n      if (m_customerPtrList.empty()) { \n        cout << \"No customers.\" << endl; \n        return; \n      } \n\n      for (const Customer* customerPtr: m_customerPtrList) { \n        cout << (*customerPtr) << endl; \n      } \n    }\n```", "```cpp\n    void Library::borrowBook() { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n```", "```cpp\n     Book* bookPtr = lookupBook(author, title); \n\n     if (bookPtr == nullptr) { \n       cout << endl << \"There is no book \"\" << title \n         << \"\" by \" << author << \".\" << endl; \n       return; \n     } \n```", "```cpp\n    if (bookPtr->borrowerPtr() != nullptr) { \n      cout << endl << \"The book \"\" << title << \"\" by \" << author  \n         << \" has already been borrowed.\" << endl; \n      return; \n    } \n```", "```cpp\n     string name; \n     cout << \"Customer name: \"; \n     cin >> name; \n\n     string address; \n     cout << \"Address: \"; \n     cin >> address; \n\n     Customer* customerPtr = lookupCustomer(name, address);\n```", "```cpp\n     if (customerPtr == nullptr) { \n      cout << endl << \"No customer with name \" << name \n         << \" and address \" << address << \" exists.\"  << endl; \n      return; \n     } \n```", "```cpp\n     bookPtr->borrowerPtr() = customerPtr; \n     customerPtr->borrowBook(bookPtr); \n     cout << endl << \"Borrowed.\" << endl; \n   } \n```", "```cpp\n    void Library::reserveBook() { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n\n    Book* bookPtr = lookupBook(author, title); \n```", "```cpp\n    if (bookPtr == nullptr) { \n      cout << endl << \"There is no book \"\" << title \n         << \"\" by \" << author << \".\" << endl; \n      return; \n    } \n```", "```cpp\n     if (bookPtr->borrowerPtr() == nullptr) { \n       cout << endl << \"The book \"\" << title << \"\" by \" \n         << author << \" has not been not borrowed. \" \n         << \"Please borrow the book instead of reserving it.\" \n         << endl; \n      return; \n    } \n```", "```cpp\n     string name; \n     cout << \"Customer name: \"; \n     cin >> name; \n\n     string address; \n     cout << \"Address: \"; \n     cin >> address; \n\n     Customer* customerPtr = lookupCustomer(name, address); \n```", "```cpp\n     if (customerPtr == nullptr) { \n      cout << endl << \"There is no customer with name \" << name \n         << \" and address \" << address << \".\" << endl; \n      return; \n     } \n```", "```cpp\n     if (bookPtr->borrowerPtr() == customerPtr) { \n      cout << endl << \"The book has already been borrowed by \" \n         << name << \".\" << endl; \n      return; \n     } \n```", "```cpp\n     int position = bookPtr->reserveBook(customerPtr); \n     customerPtr->reserveBook(bookPtr); \n```", "```cpp\n     cout << endl << position << \"nd reserve.\" << endl; \n     }\n```", "```cpp\n    void Library::returnBook() { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n\n      Book* bookPtr = lookupBook(author, title); \n```", "```cpp\n     if (bookPtr == nullptr) { \n      cout << endl << \"There is no book \"\" << title << \"\" by \" \n         << author << \".\" << endl; \n      return; \n     } \n\n     Customer* customerPtr = bookPtr->borrowerPtr(); \n```", "```cpp\n     if (customerPtr == nullptr) { \n      cout << endl << \"The book \"\" << title << \"\" by \" \n         << author << \" has not been borrowed.\" << endl; \n      return; \n     } \n\n     bookPtr->returnBook(); \n     customerPtr->returnBook(bookPtr); \n     cout << endl << \"Returned.\" << endl; \n```", "```cpp\n     list<Customer*>& reservationPtrList = \n       bookPtr->reservationPtrList();\n```", "```cpp\n     if (!reservationPtrList.empty()) { \n       Customer* newCustomerPtr = reservationPtrList.front(); \n       reservationPtrList.erase(reservationPtrList.begin()); \n\n       bookPtr->borrowBook(newCustomerPtr); \n       newCustomerPtr->borrowBook(bookPtr); \n       cout << endl << \"Borrowed by \" \n          << newCustomerPtr->name() << endl; \n       } \n     } \n```", "```cpp\n    int Library::lookupBookIndex(const Book* bookPtr) { \n      int index = 0; \n\n      for (Book* testPtr : m_bookPtrList) { \n        if (bookPtr == testPtr) { \n        return index; \n      } \n\n      ++index; \n    } \n```", "```cpp\n     assert(false); \n      return -1; \n     }\n```", "```cpp\n    Book* Library::lookupBookPtr(int bookIndex) { \n      assert((bookIndex >= 0) && \n       (bookIndex < ((int) m_bookPtrList.size()))); \n\n      auto iterator = m_bookPtrList.begin(); \n      for (int count = 0; count < bookIndex; ++count) { \n        ++iterator; \n      } \n\n      return *iterator; \n    }  \n```", "```cpp\n    int Library::lookupCustomerIndex(const Customer* customerPtr) { \n      int index = 0; \n\n      for (Customer* testPtr : m_customerPtrList) { \n        if (customerPtr == testPtr) { \n        return index; \n      } \n\n      ++index; \n     } \n\n     assert(false); \n     return -1; \n    } \n```", "```cpp\n    Customer* Library::lookupCustomerPtr(int customerIndex) { \n      assert((customerIndex >= 0) && \n       (customerIndex < ((int) m_customerPtrList.size()))); \n\n      auto iterator = m_customerPtrList.begin(); \n      for (int count = 0; count < customerIndex; ++count) { \n        ++iterator; \n      }  \n\n      return *iterator; \n    } \n```", "```cpp\n    void Library::save() { \n      ofstream outStream(s_binaryPath); \n```", "```cpp\n    if (outStream) { \n      { int bookPtrListSize = m_bookPtrList.size(); \n         outStream.write((char*) &bookPtrListSize, \n           sizeof bookPtrListSize); \n```", "```cpp\n      for (const Book* bookPtr : m_bookPtrList) { \n        bookPtr->write(outStream); \n    } \n   } \n```", "```cpp\n    { int customerPtrListSize = m_customerPtrList.size(); \n      outStream.write((char*) &customerPtrListSize, \n                      sizeof customerPtrListSize); \n```", "```cpp\n      for (const Customer* customerPtr : m_customerPtrList) { \n        customerPtr->write(outStream); \n      } \n    } \n```", "```cpp\n    for (const Book* bookPtr : m_bookPtrList) { \n      { const Customer* borrowerPtr = bookPtr->borrowerPtr(); \n```", "```cpp\n        if (borrowerPtr != nullptr) { \n          bool borrowed = true; \n          outStream.write((char*) &borrowed, sizeof borrowed); \n```", "```cpp\n          int loanIndex = lookupCustomerIndex(borrowerPtr); \n          outStream.write((char*) &loanIndex, sizeof loanIndex); \n        } \n```", "```cpp\n        else { \n          bool borrowed = false; \n          outStream.write((char*) &borrowed, sizeof borrowed); \n        } \n      } \n```", "```cpp\n      { const list<Customer*>& reservationPtrList = \n          bookPtr->reservationPtrList(); \n```", "```cpp\n        int reserveSetSize = reservationPtrList.size(); \n        outStream.write((char*) &reserveSetSize, \n                        sizeof reserveSetSize); \n```", "```cpp\n        for (const Customer* customerPtr : reservationPtrList) { \n          int customerIndex = lookupCustomerIndex(customerPtr); \n          outStream.write((char*) &customerIndex, \n                          sizeof customerIndex); \n        } \n      } \n    }\n```", "```cpp\n    for (const Customer* customerPtr : m_customerPtrList) { \n      { const set<Book*>& loanPtrSet = \n          customerPtr->loanPtrSet(); \n```", "```cpp\n        int loanPtrSetSize = loanPtrSet.size(); \n        outStream.write((char*) &loanPtrSetSize, \n                        sizeof loanPtrSetSize); \n```", "```cpp\n        for (const Book* customerPtr : loanPtrSet) { \n          int customerIndex = lookupBookIndex(customerPtr); \n          outStream.write((char*) &customerIndex, \n                          sizeof customerIndex); \n        } \n      } \n```", "```cpp\n      { const set<Book*>& reservedPtrSet = \n          customerPtr->reservationPtrSet(); \n```", "```cpp\n        int reservationPtrSetSize = reservationPtrSet.size(); \n        outStream.write((char*) &reservationPtrSetSize, \n                        sizeof reservationPtrSetSize); \n```", "```cpp\n        for (const Book* reservedPtr : reservationPtrSet) { \n          int customerIndex = lookupBookIndex(reservedPtr); \n          outStream.write((char*) &customerIndex, \n                          sizeof customerIndex); \n        } \n      } \n    } \n  } \n} \n```", "```cpp\n    void Library::load() { \n      ifstream inStream(s_binaryPath); \n```", "```cpp\n    if (inStream) { \n      { int bookPtrListSize; \n```", "```cpp\n        inStream.read((char*) &bookPtrListSize, \n                    sizeof bookPtrListSize); \n```", "```cpp\n      for (int count = 0; count < bookPtrListSize; ++count) { \n        Book *bookPtr = new Book(); \n        assert(bookPtr != nullptr); \n        bookPtr->read(inStream); \n        m_bookPtrList.push_back(bookPtr); \n      } \n    }\n```", "```cpp\n    { int customerPtrListSize; \n```", "```cpp\n      inStream.read((char*) &customerPtrListSize, \n                    sizeof customerPtrListSize); \n```", "```cpp\n      for (int count = 0; count < customerPtrListSize; ++count) { \n        Customer *customerPtr = new Customer(); \n        assert(customerPtr != nullptr); \n        customerPtr->read(inStream); \n        m_customerPtrList.push_back(customerPtr); \n      } \n    } \n```", "```cpp\n    for (Book* bookPtr : m_bookPtrList) { \n      { bool borrowed; \n        inStream.read((char*) &borrowed, sizeof borrowed); \n```", "```cpp\n        if (borrowed) { \n          int loanIndex; \n          inStream.read((char*) &loanIndex, sizeof loanIndex); \n          bookPtr->borrowerPtr() = lookupCustomerPtr(loanIndex); \n        }\n```", "```cpp\n        else { \n          bookPtr->borrowerPtr() = nullptr; \n        } \n      } \n```", "```cpp\n      { list<Customer*>& reservationPtrList = \n          bookPtr->reservationPtrList(); \n        int reservationPtrListSize; \n```", "```cpp\n        inStream.read((char*) &reservationPtrListSize, \n                      sizeof reservationPtrListSize); \n```", "```cpp\n        for (int count = 0; count < reservationPtrListSize; \n             ++count) { \n          int customerIndex; \n          inStream.read((char*) &customerIndex, \n                        sizeof customerIndex); \n          Customer* customerPtr = \n            lookupCustomerPtr(customerIndex); \n          reservationPtrList.push_back(customerPtr); \n        } \n      } \n    } \n```", "```cpp\n    for (Customer* customerPtr : m_customerPtrList) { \n      { set<Book*>& loanPtrSet = customerPtr->loanPtrSet(); \n        int loanPtrSetSize = loanPtrSet.size();\n```", "```cpp\n        inStream.read((char*) &loanPtrSetSize, \n                      sizeof loanPtrSetSize); \n```", "```cpp\n        for (int count = 0; count < loanPtrSetSize; ++count) { \n          int bookIndex; \n          inStream.read((char*) &bookIndex, sizeof bookIndex); \n          Book* bookPtr = lookupBookPtr(bookIndex); \n          loanPtrSet.insert(bookPtr); \n        } \n      } \n```", "```cpp\n      { set<Book*>& reservationPtrSet = \n          customerPtr->reservationPtrSet(); \n```", "```cpp\n        int reservationPtrSetSize = reservationPtrSet.size(); \n        inStream.read((char*) &reservationPtrSetSize, \n                      sizeof reservationPtrSetSize); \n```", "```cpp\n        for (int count = 0; count < reservationPtrSetSize; \n             ++count) { \n          int bookIndex; \n          inStream.read((char*) &bookIndex, sizeof bookIndex); \n          Book* bookPtr = lookupBookPtr(bookIndex); \n          reservationPtrSet.insert(bookPtr); \n        } \n      } \n    } \n  } \n}\n```", "```cpp\n    Library::~Library() { \n      for (const Book* bookPtr : m_bookPtrList) { \n        delete bookPtr; \n      } \n\n      for (const Customer* customerPtr : m_customerPtrList) { \n        delete customerPtr; \n      } \n    } \n```", "```cpp\n    #include <Set> \n    #include <Map> \n    #include <String> \n    #include <FStream> \n    #include <IOStream> \n    using namespace std; \n\n    #include \"Book.h\" \n    #include \"Customer.h\" \n    #include \"Library.h\" \n\n    void main() { \n      Library(); \n    }\n```"]