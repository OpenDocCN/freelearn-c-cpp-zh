<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer056">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 class="chapterTitle" id="_idParaDest-87"><span class="koboSpan" id="kobo.2.1">Working with Numbers and Strings</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Numbers </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.4.1">and strings are </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.5.1">the fundamental types of any programming language; all other types are based on or composed of these. </span><span class="koboSpan" id="kobo.5.2">Developers are confronted all the time with tasks such as converting between numbers and strings, parsing and formatting strings, and generating random numbers. </span><span class="koboSpan" id="kobo.5.3">This chapter is focused on providing useful recipes for these common tasks using modern C++ language and library features.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">The recipes included in this chapter are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Understanding the various numeric types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Limits and other properties of numeric types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Converting between numeric and string types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Understanding the various character and string types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Printing Unicode characters to the output console</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Generating pseudo-random numbers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Properly initializing a pseudo-random number generator</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Creating cooked user-defined literals</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Creating raw user-defined literals</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Using raw string literals to avoid escaping characters</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Creating a library of string helpers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Verifying the format of a string using regular expressions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Parsing the content of a string using regular expressions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Replacing the content of a string using regular expressions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">std::string_view</span></code><span class="koboSpan" id="kobo.23.1"> instead of constant string references</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Formatting and printing text with </span><code class="inlineCode"><span class="koboSpan" id="kobo.25.1">std::format</span></code><span class="koboSpan" id="kobo.26.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.27.1">std::print</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.29.1">std::format</span></code><span class="koboSpan" id="kobo.30.1"> with user-defined types</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.31.1">Let’s start this chapter by looking at the different numeric types that exist in the C++ programming language.</span></p>
<h1 class="heading-1" id="_idParaDest-88"><span class="koboSpan" id="kobo.32.1">Understanding the various numeric types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.33.1">The C++ programming language </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.34.1">defines a multitude of arithmetic types; these are types on which arithmetic operations (addition, subtraction, multiplication, division, modulo) can be performed. </span><span class="koboSpan" id="kobo.34.2">This category includes character, integral, and floating-point types. </span><span class="koboSpan" id="kobo.34.3">Many of these types are inherited from the C programming languages, while some have been added to C++ in recent versions of the standard. </span><span class="koboSpan" id="kobo.34.4">A typical problem with the arithmetic types is that, unlike many other programming languages, most of them don’t have a fixed size. </span><span class="koboSpan" id="kobo.34.5">The size varies with the target platform and the standard only guarantees a minimum one. </span><span class="koboSpan" id="kobo.34.6">In this recipe, we will learn about the various integral and floating-point types.</span></p>
<h2 class="heading-2" id="_idParaDest-89"><span class="koboSpan" id="kobo.35.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.36.1">Use one of the</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.37.1"> available numeric types depending on the kind of value you need to represent:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.38.1">To represent an integral value (when the range doesn’t really matter), use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">int</span></code><span class="koboSpan" id="kobo.40.1"> type. </span><span class="koboSpan" id="kobo.40.2">This is the default basic (signed) integer type, typically with a size of 32 bits, but not guaranteed. </span><span class="koboSpan" id="kobo.40.3">You can use it for values such as the age of a person, the day, month, and year in a date, the rating of a movie or book, the number of items in a collection, and countless other things:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.41.1">int</span></span><span class="koboSpan" id="kobo.42.1"> age = </span><span class="hljs-number"><span class="koboSpan" id="kobo.43.1">42</span></span><span class="koboSpan" id="kobo.44.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.45.1">int</span></span><span class="koboSpan" id="kobo.46.1"> attendance = </span><span class="hljs-number"><span class="koboSpan" id="kobo.47.1">96321</span></span><span class="koboSpan" id="kobo.48.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.49.1">Use signedness (</span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">signed</span></code><span class="koboSpan" id="kobo.51.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.52.1">unsigned</span></code><span class="koboSpan" id="kobo.53.1">) and size (</span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">short</span></code><span class="koboSpan" id="kobo.55.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">long</span></code><span class="koboSpan" id="kobo.57.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">long long</span></code><span class="koboSpan" id="kobo.59.1">) modifiers when you need to impose restrictions on the range of possible values or the memory representation. </span><span class="koboSpan" id="kobo.59.2">For instance, you may want to use unsigned integers to represent values that cannot have negative values. </span><span class="koboSpan" id="kobo.59.3">Mixing signed and unsigned integers should be avoided. </span><span class="koboSpan" id="kobo.59.4">On the other hand, you may want to optimize the memory used for storing some values, such as those representing a date, in which case you could use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.60.1">short int</span></code><span class="koboSpan" id="kobo.61.1">, guaranteed to be at least 16 bits. </span><span class="koboSpan" id="kobo.61.2">If you need to represent large values, such as the size of a file, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.62.1">unsigned long long int</span></code><span class="koboSpan" id="kobo.63.1">, which is guaranteed to be at least 64 bits:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.64.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.65.1">int</span></span><span class="koboSpan" id="kobo.66.1"> length = </span><span class="hljs-number"><span class="koboSpan" id="kobo.67.1">32</span></span><span class="koboSpan" id="kobo.68.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.69.1">short</span></span><span class="koboSpan" id="kobo.70.1"> year = </span><span class="hljs-number"><span class="koboSpan" id="kobo.71.1">2023</span></span><span class="koboSpan" id="kobo.72.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.73.1">// same as short int</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.74.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.75.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.76.1">long</span></span><span class="koboSpan" id="kobo.77.1"> filesize = </span><span class="hljs-number"><span class="koboSpan" id="kobo.78.1">3'758'096'384</span></span><span class="koboSpan" id="kobo.79.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.80.1">To </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.81.1">represent </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">std::array</span></code><span class="koboSpan" id="kobo.83.1"> indexes (which cannot be negative), the number of elements in a collection (such as standard containers), or the result of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">sizeof</span></code><span class="koboSpan" id="kobo.85.1"> operator, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.86.1">std::size_t</span></code><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">This is an unsigned integer type of at least 16 bits. </span><span class="koboSpan" id="kobo.87.3">The standard containers defined a member type alias called </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">size_type</span></code><span class="koboSpan" id="kobo.89.1"> for size and indexing the container, and this type is typically a synonym for </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">std::size_t</span></code><span class="koboSpan" id="kobo.91.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.92.1">std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.93.1">size_t</span></span><span class="koboSpan" id="kobo.94.1"> items = arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.95.1">size</span></span><span class="koboSpan" id="kobo.96.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.97.1">To store the result of a pointer arithmetic operation, or present a C-like array index (which can be negative), use </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">std::ptrdiff_t</span></code><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">The C++ standard containers define a member type alias called </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">difference_type</span></code><span class="koboSpan" id="kobo.101.1"> to store differences between iterators, and this is typically defined as a synonym for </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">std::ptrdiff_t</span></code><span class="koboSpan" id="kobo.103.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.104.1">When you need to store a value that needs a guaranteed range, use one of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">std::int8_t</span></code><span class="koboSpan" id="kobo.106.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">std::int16_t</span></code><span class="koboSpan" id="kobo.108.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">std::int32_t</span></code><span class="koboSpan" id="kobo.110.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">std::int64_t</span></code><span class="koboSpan" id="kobo.112.1"> types. </span><span class="koboSpan" id="kobo.112.2">Although these are optional, they are defined for all modern architectures.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.113.1">When you need to store non-negative values or perform bit manipulations on values of a guaranteed range, use one of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">std::uint8_t</span></code><span class="koboSpan" id="kobo.115.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">std::uint16_t</span></code><span class="koboSpan" id="kobo.117.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">std::uint32_t</span></code><span class="koboSpan" id="kobo.119.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">std::uint64_t</span></code><span class="koboSpan" id="kobo.121.1"> types.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.122.1">When you need to store a value that needs a guaranteed range and, at the same time, you want to optimize for fastest access, use one of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">std::int_fast8_t</span></code><span class="koboSpan" id="kobo.124.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">std::int_fast16_t</span></code><span class="koboSpan" id="kobo.126.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">std::int_fast32_t</span></code><span class="koboSpan" id="kobo.128.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">std::int_fast64_t</span></code><span class="koboSpan" id="kobo.130.1"> types (or their unsigned counterparts). </span><span class="koboSpan" id="kobo.130.2">These are guaranteed to be available on all target architectures.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.131.1">When you need to store a value that needs a guaranteed range and, at the same time, you want to optimize the memory usage, use one of </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">std::int_least8_t</span></code><span class="koboSpan" id="kobo.133.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">std::int_last16_t</span></code><span class="koboSpan" id="kobo.135.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">std::int_least32_t</span></code><span class="koboSpan" id="kobo.137.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">std::int_least64_t</span></code><span class="koboSpan" id="kobo.139.1"> (or their unsigned counterparts). </span><span class="koboSpan" id="kobo.139.2">These are also guaranteed to be available on all target architectures.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.140.1">To represent a real number, use the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">double</span></code><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">This is the default floating-point type, with a size of 64 bits. </span><span class="koboSpan" id="kobo.142.3">The name indicates a double precision type, as </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.143.1">opposed to a single precision type (using 32 bits), implemented with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">float</span></code><span class="koboSpan" id="kobo.145.1"> type. </span><span class="koboSpan" id="kobo.145.2">An extended precision type, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">long double</span></code><span class="koboSpan" id="kobo.147.1">, is also available. </span><span class="koboSpan" id="kobo.147.2">The standard does not specify its actual precision but requires that it’s at least the same as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">double</span></code><span class="koboSpan" id="kobo.149.1"> type. </span><span class="koboSpan" id="kobo.149.2">On some compilers, this can be a quadruple precision (using 128 bits), although some, such as VC++, treat it as equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">double</span></code><span class="koboSpan" id="kobo.151.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.152.1">double</span></span><span class="koboSpan" id="kobo.153.1"> price = </span><span class="hljs-number"><span class="koboSpan" id="kobo.154.1">4.99</span></span><span class="koboSpan" id="kobo.155.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.156.1">float</span></span><span class="koboSpan" id="kobo.157.1"> temperature = </span><span class="hljs-number"><span class="koboSpan" id="kobo.158.1">36.5</span></span><span class="koboSpan" id="kobo.159.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.160.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.161.1">double</span></span><span class="koboSpan" id="kobo.162.1"> pi = </span><span class="hljs-number"><span class="koboSpan" id="kobo.163.1">3.14159265358979323846264338327950288419716939937510L</span></span><span class="koboSpan" id="kobo.164.1">;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-90"><span class="koboSpan" id="kobo.165.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.166.1">The C++ language </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.167.1">has one basic integral type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.168.1">int</span></code><span class="koboSpan" id="kobo.169.1">, and several modifiers that can be applied to it, for signedness and size. </span><span class="koboSpan" id="kobo.169.2">The type </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">int</span></code><span class="koboSpan" id="kobo.171.1"> is a signed one, so </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">int</span></code><span class="koboSpan" id="kobo.173.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">signed int</span></code><span class="koboSpan" id="kobo.175.1"> are the same type. </span><span class="koboSpan" id="kobo.175.2">The use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.176.1">int</span></code><span class="koboSpan" id="kobo.177.1"> is actually optional when using a modifier. </span><span class="koboSpan" id="kobo.177.2">Therefore, the following types are equivalent:</span></p>
<table class="table-container" id="table001-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.178.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.179.1">Equivalent to</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">signed</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">unsigned</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">unsigned int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.184.1">short</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">short int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">signed short</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">short int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">signed short int</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">short int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">long</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">long int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">long long</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">long long int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">unsigned short</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">unsigned short int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">unsigned long </span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">unsigned long int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">unsigned long long</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">unsigned long long int</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.200.1">Table 2.1: Integral type equivalence</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">This table</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.202.1"> does </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.203.1">not list all the possible combinations, only several examples. </span><span class="koboSpan" id="kobo.203.2">The order of the type modifiers is not specified; therefore, any order is permitted. </span><span class="koboSpan" id="kobo.203.3">The following table lists several types that represent the same type:</span></p>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.204.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.205.1">Equivalent type</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">long long unsigned int</span></code></p>
</td>
<td class="table-cell" rowspan="5">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">unsigned long long int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">long unsigned long int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">int long long unsigned</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">unsigned long long int</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">int long unsigned long</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.212.1">Table 2.2: Integral type equivalence with modifiers</span></p>
<p class="normal"><span class="koboSpan" id="kobo.213.1">Even though the</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.214.1"> order is undefined, it is a common practice to start with the signedness modifier, then the size modifier, and finally the </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">int</span></code><span class="koboSpan" id="kobo.216.1"> type. </span><span class="koboSpan" id="kobo.216.2">Therefore, the canonical form for the types on the left column in the previous table is </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">unsigned long long int</span></code><span class="koboSpan" id="kobo.218.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.219.1">Regardless of the signedness or size of an integral type, a</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.220.1"> process called </span><em class="italic"><span class="koboSpan" id="kobo.221.1">overflow</span></em><span class="koboSpan" id="kobo.222.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.223.1">underflow</span></em><span class="koboSpan" id="kobo.224.1"> can </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.225.1">occur. </span><span class="koboSpan" id="kobo.225.2">Overflow occurs when an attempt to store a value greater than the maximum value of the data type happens. </span><span class="koboSpan" id="kobo.225.3">Underflow occurs in the opposite case, when an attempt to store a value smaller than the minimum value of the data type happens.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.226.1">Let’s consider the case of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">short</span></code><span class="koboSpan" id="kobo.228.1"> type. </span><span class="koboSpan" id="kobo.228.2">This is a signed integer type that can store values in the range of -32,768 to 32,767. </span><span class="koboSpan" id="kobo.228.3">What happens if we want to store 32,768? </span><span class="koboSpan" id="kobo.228.4">Since this is greater than the maximum, an overflow occurs. </span><span class="koboSpan" id="kobo.228.5">The decimal 32,767 is 01111111 11111111 in binary and the next value is 10000000 00000000, which, on a 16-bit representation, is -32,768 in decimal. </span><span class="koboSpan" id="kobo.228.6">The following table shows overflows and underflows:</span></p>
<table class="table-container" id="table003">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.229.1">Value to store</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.230.1">Stored value</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.231.1">-32771</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.232.1">32765</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.233.1">-32770</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.234.1">32766</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.235.1">-32769</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.236.1">32767</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.237.1">-32768</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.238.1">-32768</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.239.1">…</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.240.1">…</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.241.1">32767</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.242.1">32767</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.243.1">32768</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.244.1">-32768</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.245.1">32769</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.246.1">-32767</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.247.1">32770</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.248.1">-32765</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.249.1">Table 2.3: Examples of short int values with overflow and underflow</span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">The same</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.251.1"> examples are shown in a different form in the following image, which you might find simpler to understand:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.252.1"><img alt="" src="../Images/B21549_02_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.253.1">Figure 2.1: Example of short int values with overflow and underflow</span></p>
<p class="normal"><span class="koboSpan" id="kobo.254.1">If, instead </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.255.1">of </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">short</span></code><span class="koboSpan" id="kobo.257.1">, we consider the </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">unsigned short</span></code><span class="koboSpan" id="kobo.259.1"> type, the same problems occur, although they might be easier to understand. </span><span class="koboSpan" id="kobo.259.2">The range for </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">unsigned short</span></code><span class="koboSpan" id="kobo.261.1"> is 0 to 65,535. </span><span class="koboSpan" id="kobo.261.2">Attempting to store 65,536 will result in the value 0 being stored. </span><span class="koboSpan" id="kobo.261.3">Similarly, attempting to store 65,537 will result in the value 1 being stored instead. </span><span class="koboSpan" id="kobo.261.4">This is the result of the modulo operation between the value to be stored and the number of values that can be stored by the data type. </span><span class="koboSpan" id="kobo.261.5">In the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">unsigned short</span></code><span class="koboSpan" id="kobo.263.1">, this is 2^16 or 62,536. </span><span class="koboSpan" id="kobo.263.2">For underflow, the result happens in a similar way. </span><span class="koboSpan" id="kobo.263.3">The value -1 becomes 65,535, -2 becomes 65,534, and so forth. </span><span class="koboSpan" id="kobo.263.4">This is the same as adding the negative value to 65,536 and then performing the modulo 65,536 operation. </span><span class="koboSpan" id="kobo.263.5">The overflows and underflows are shown in the following table:</span></p>
<table class="table-container" id="table004">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.264.1">Value to store</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.265.1">Stored value</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.266.1">-2</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.267.1">65534</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.268.1">-1</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.269.1">65535</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.270.1">0</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.271.1">0</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.272.1">…</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.273.1">…</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.274.1">65535</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.275.1">65535</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.276.1">65536</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.277.1">0</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.278.1">65537</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.279.1">1</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.280.1">Table 2.4: Examples of unsigned short int with overflow and underflow</span></p>
<p class="normal"><span class="koboSpan" id="kobo.281.1">Similarly, the</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.282.1"> same</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.283.1"> values are exemplified in the next image:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.284.1"><img alt="" src="../Images/B21549_02_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.285.1">Figure 2.2: Examples of unsigned short int with overflow and underflow</span></p>
<p class="normal"><span class="koboSpan" id="kobo.286.1">A significant problem with integral types in C++ is the lack of specification for their size. </span><span class="koboSpan" id="kobo.286.2">The only well-defined size is for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">char</span></code><span class="koboSpan" id="kobo.288.1"> type (and its </span><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">signed</span></code><span class="koboSpan" id="kobo.290.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">unsigned</span></code><span class="koboSpan" id="kobo.292.1"> modifiers), which must be 1. </span><span class="koboSpan" id="kobo.292.2">For the rest, the following relation applies:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-number"><span class="koboSpan" id="kobo.293.1">1</span></span><span class="koboSpan" id="kobo.294.1"> == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.295.1">sizeof</span></span><span class="koboSpan" id="kobo.296.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.297.1">char</span></span><span class="koboSpan" id="kobo.298.1">) &lt;= </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.299.1">sizeof</span></span><span class="koboSpan" id="kobo.300.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.301.1">short</span></span><span class="koboSpan" id="kobo.302.1">) &lt;= </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.303.1">sizeof</span></span><span class="koboSpan" id="kobo.304.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.305.1">int</span></span><span class="koboSpan" id="kobo.306.1">) &lt;= </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.307.1">sizeof</span></span><span class="koboSpan" id="kobo.308.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.309.1">long</span></span><span class="koboSpan" id="kobo.310.1">) &lt;= </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.311.1">sizeof</span></span><span class="koboSpan" id="kobo.312.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.313.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.314.1">long</span></span><span class="koboSpan" id="kobo.315.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.316.1">In practice, on most platforms, </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">short</span></code><span class="koboSpan" id="kobo.318.1"> is 16-bit, </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">int</span></code><span class="koboSpan" id="kobo.320.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">long</span></code><span class="koboSpan" id="kobo.322.1"> are both 32-bit, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.323.1">long long</span></code><span class="koboSpan" id="kobo.324.1"> is 64-bit. </span><span class="koboSpan" id="kobo.324.2">However, there are platforms where </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">long</span></code><span class="koboSpan" id="kobo.326.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">long long</span></code><span class="koboSpan" id="kobo.328.1"> are both 64-bit or where </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">int</span></code><span class="koboSpan" id="kobo.330.1"> is 16-bit. </span><span class="koboSpan" id="kobo.330.2">To overcome this heterogeneity, the C++11 standard introduced a series of fixed-width integer types. </span><span class="koboSpan" id="kobo.330.3">These are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">&lt;cstdint&gt;</span></code><span class="koboSpan" id="kobo.332.1"> header and are grouped into</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.333.1"> two categories:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.334.1">A category of types that are optional and might not be available on some platforms. </span><span class="koboSpan" id="kobo.334.2">These types have an exact number of bits, as specified by their name:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">int8_t</span></code><span class="koboSpan" id="kobo.336.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">uint8_t</span></code><span class="koboSpan" id="kobo.338.1"> are 8-bit</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">int16_t</span></code><span class="koboSpan" id="kobo.340.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">uint16_t</span></code><span class="koboSpan" id="kobo.342.1"> are 16-bit</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">int32_t</span></code><span class="koboSpan" id="kobo.344.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">uint32_t</span></code><span class="koboSpan" id="kobo.346.1"> are 32-bit</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">int64_t</span></code><span class="koboSpan" id="kobo.348.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">uint64_t</span></code><span class="koboSpan" id="kobo.350.1"> are 64-bit</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.351.1">There are also </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">intptr_t</span></code><span class="koboSpan" id="kobo.353.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">uintptr_t</span></code><span class="koboSpan" id="kobo.355.1"> that have a size large enough to store a pointer to void</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.356.1">A category of types that are mandatory and, therefore, available on all platforms. </span><span class="koboSpan" id="kobo.356.2">These, in turn, are grouped into two categories:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.357.1">One that is optimized for fast access; these are called </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">int_fastX_t</span></code><span class="koboSpan" id="kobo.359.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">uint_fastX_t</span></code><span class="koboSpan" id="kobo.361.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">X</span></code><span class="koboSpan" id="kobo.363.1"> is 8, 16, 32, or 64, representing the number of bits. </span><span class="koboSpan" id="kobo.363.2">These types provide the integral type that is fastest to access on a particular architecture that also has a width at least the size </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">X</span></code><span class="koboSpan" id="kobo.365.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.366.1">One that is optimized for memory consumption; these are called </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">int_leastX_t</span></code><span class="koboSpan" id="kobo.368.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">uint_leastX_t</span></code><span class="koboSpan" id="kobo.370.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.371.1">X</span></code><span class="koboSpan" id="kobo.372.1"> is 8, 16, 32, or 64, representing the number of bits. </span><span class="koboSpan" id="kobo.372.2">These types provide the integral type that is the smallest to represent on a particular architecture but that also has a width of at least the size </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">X</span></code><span class="koboSpan" id="kobo.374.1">.</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.375.1">In practice, most compilers treat the 8-bit types (</span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">int8_t</span></code><span class="koboSpan" id="kobo.377.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">uint8_t</span></code><span class="koboSpan" id="kobo.379.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">int_least8_t</span></code><span class="koboSpan" id="kobo.381.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">uint_least8_t</span></code><span class="koboSpan" id="kobo.383.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">int_fast8_t</span></code><span class="koboSpan" id="kobo.385.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">uint_fast8_t</span></code><span class="koboSpan" id="kobo.387.1">) as identical to </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">signed char</span></code><span class="koboSpan" id="kobo.389.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">unsigned char</span></code><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">This means that on different systems, a program using them may behave differently from a program using the other fixed-width integer types. </span><span class="koboSpan" id="kobo.391.3">Here is an example to demonstrate this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.392.1">std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.393.1">int8_t</span></span><span class="koboSpan" id="kobo.394.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.395.1">42</span></span><span class="koboSpan" id="kobo.396.1">;
std::cout &lt;&lt; x &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.397.1">'\n'</span></span><span class="koboSpan" id="kobo.398.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.399.1">// [1] prints *</span></span><span class="koboSpan" id="kobo.400.1">
std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.401.1">int16_t</span></span><span class="koboSpan" id="kobo.402.1"> y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.403.1">42</span></span><span class="koboSpan" id="kobo.404.1">;
std::cout &lt;&lt; y &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.405.1">'\n'</span></span><span class="koboSpan" id="kobo.406.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.407.1">// [2] prints 42</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.408.1">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">x</span></code><span class="koboSpan" id="kobo.410.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">y</span></code><span class="koboSpan" id="kobo.412.1"> are of fixed-width integer types and both are assigned the value 42. </span><span class="koboSpan" id="kobo.412.2">However, when </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.413.1">printing their value to the console, </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">x</span></code><span class="koboSpan" id="kobo.415.1"> will be printed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">*</span></code><span class="koboSpan" id="kobo.417.1"> instead of 42. </span><span class="koboSpan" id="kobo.417.2">Keep in mind, though, that this is not a guarantee as the behavior is system-dependent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.418.1">Therefore, you might want to avoid using the 8-bit fixed-width integer types and prefer </span><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">int16_t</span></code><span class="koboSpan" id="kobo.420.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">uint16_t</span></code><span class="koboSpan" id="kobo.422.1"> or one of the fast/least variants.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.423.1">When writing numerical literals, you can use the single quotation mark (</span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">'</span></code><span class="koboSpan" id="kobo.425.1">) as a digit separator. </span><span class="koboSpan" id="kobo.425.2">This makes it easier to read large numbers, and perhaps compare them visually. </span><span class="koboSpan" id="kobo.425.3">It can be used for decimal, hexadecimal, octal, and binary numbers, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.426.1">auto a = 4'234'871'523ll;        // 4234871523
auto b = 0xBAAD'F00D;            // 3131961357
auto c = 00'12'34;               // 668
auto d = 0b1011'01011'0001'1001; // 46361
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.427.1">The digit separators are ignored when determining the numerical value, so their position is irrelevant. </span><span class="koboSpan" id="kobo.427.2">This means you can write numbers in formats that have no practical meaning without producing an error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.428.1">auto e = 1'2'3'4'5;
</span></code></pre>
</div>
<h2 class="heading-2" id="_idParaDest-91"><span class="koboSpan" id="kobo.429.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.430.1">Understanding the various character and string types</span></em><span class="koboSpan" id="kobo.431.1">, to learn about the different character and string types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-92"><span class="koboSpan" id="kobo.432.1">Limits and other properties of numeric types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.433.1">Sometimes, it is </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.434.1">necessary to know and use the minimum and maximum values </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.435.1">that can be represented with a numeric type, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">char</span></code><span class="koboSpan" id="kobo.437.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">int</span></code><span class="koboSpan" id="kobo.439.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">double</span></code><span class="koboSpan" id="kobo.441.1">. </span><span class="koboSpan" id="kobo.441.2">Many developers use standard C macros for this, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">CHAR_MIN</span></code><span class="koboSpan" id="kobo.443.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">CHAR_MAX</span></code><span class="koboSpan" id="kobo.445.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.446.1">INT_MIN</span></code><span class="koboSpan" id="kobo.447.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">INT_MAX</span></code><span class="koboSpan" id="kobo.449.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">DBL_MIN</span></code><span class="koboSpan" id="kobo.451.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">DBL_MAX</span></code><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">C++ provides a class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">numeric_limits</span></code><span class="koboSpan" id="kobo.455.1"> with specializations for every numeric type, which enables you to query the minimum and maximum value of a type. </span><span class="koboSpan" id="kobo.455.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">numeric_limits</span></code><span class="koboSpan" id="kobo.457.1"> is not limited to that functionality and offers additional constants for type property querying, such as whether a type is signed or not, how many bits it needs for representing</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.458.1"> its values, whether it can represent infinity for floating-point types, and many others. </span><span class="koboSpan" id="kobo.458.2">Prior to C++11, the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">numeric_limits&lt;T&gt;</span></code><span class="koboSpan" id="kobo.460.1"> was limited because it could not be used in places where constants were needed (examples include the size of arrays and switch cases). </span><span class="koboSpan" id="kobo.460.2">Due to that, developers preferred to use C macros throughout their code. </span><span class="koboSpan" id="kobo.460.3">In C++11, that is no longer the case, as all the static members of </span><code class="inlineCode"><span class="koboSpan" id="kobo.461.1">numeric_limits&lt;T&gt;</span></code><span class="koboSpan" id="kobo.462.1"> are now </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">constexpr</span></code><span class="koboSpan" id="kobo.464.1">, which means they can be used everywhere a constant expression is expected.</span></p>
<h2 class="heading-2" id="_idParaDest-93"><span class="koboSpan" id="kobo.465.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.466.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">numeric_limits&lt;T&gt;</span></code><span class="koboSpan" id="kobo.468.1"> class template is available in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">std</span></code><span class="koboSpan" id="kobo.470.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">&lt;limits&gt;</span></code><span class="koboSpan" id="kobo.472.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-94"><span class="koboSpan" id="kobo.473.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.474.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">std::numeric_limits&lt;T&gt;</span></code><span class="koboSpan" id="kobo.476.1"> to query various properties of a numeric type </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">T</span></code><span class="koboSpan" id="kobo.478.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.479.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">min()</span></code><span class="koboSpan" id="kobo.481.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">max()</span></code><span class="koboSpan" id="kobo.483.1"> static methods to get the smallest and largest finite numbers of a type. </span><span class="koboSpan" id="kobo.483.2">The following are examples of how these could be used:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.484.1">// example 1</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.485.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.486.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.487.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.488.1"> T, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.489.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.490.1"> Iter&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.491.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.492.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.493.1">(Iter </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.494.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.495.1"> start, Iter </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.496.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.497.1"> end)</span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.498.1">// finds the</span></span>
<span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.499.1">// minimum value</span></span>
<span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.500.1">// in a range</span></span><span class="koboSpan" id="kobo.501.1">
{
  T minval = std::numeric_limits&lt;T&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.502.1">max</span></span><span class="koboSpan" id="kobo.503.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.504.1">for</span></span><span class="koboSpan" id="kobo.505.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.506.1">auto</span></span><span class="koboSpan" id="kobo.507.1"> i = start; i &lt; end; ++i)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.508.1">if</span></span><span class="koboSpan" id="kobo.509.1"> (*i &lt; minval)
      minval = *i;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.510.1">return</span></span><span class="koboSpan" id="kobo.511.1"> minval;
}
// example 2
</span><span class="hljs-type"><span class="koboSpan" id="kobo.512.1">int</span></span><span class="koboSpan" id="kobo.513.1"> range[std::numeric_limits&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.514.1">char</span></span><span class="koboSpan" id="kobo.515.1">&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.516.1">max</span></span><span class="koboSpan" id="kobo.517.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.518.1">1</span></span><span class="koboSpan" id="kobo.519.1">] = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.520.1">0</span></span><span class="koboSpan" id="kobo.521.1"> };
// example 3
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.522.1">switch</span></span><span class="koboSpan" id="kobo.523.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.524.1">get_value</span></span><span class="koboSpan" id="kobo.525.1">())
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.526.1">case</span></span><span class="koboSpan" id="kobo.527.1"> std::numeric_limits&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.528.1">int</span></span><span class="koboSpan" id="kobo.529.1">&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.530.1">min</span></span><span class="koboSpan" id="kobo.531.1">():
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.532.1">// do something</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.533.1">break</span></span><span class="koboSpan" id="kobo.534.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.535.1">Use </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.536.1">other static methods and static constants to retrieve other properties of a numeric type. </span><span class="koboSpan" id="kobo.536.2">In the following example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">bits</span></code><span class="koboSpan" id="kobo.538.1"> variable is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">std::bitset</span></code><span class="koboSpan" id="kobo.540.1"> object that contains a sequence of bits that are necessary to represent the numerical value represented by the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">n</span></code><span class="koboSpan" id="kobo.542.1"> (which is an integer):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.543.1">auto</span></span><span class="koboSpan" id="kobo.544.1"> n = </span><span class="hljs-number"><span class="koboSpan" id="kobo.545.1">42</span></span><span class="koboSpan" id="kobo.546.1">;
std::bitset&lt;std::numeric_limits&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.547.1">decltype</span></span><span class="koboSpan" id="kobo.548.1">(n)&gt;::digits&gt;
   bits { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.549.1">static_cast</span></span><span class="koboSpan" id="kobo.550.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.551.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.552.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.553.1">long</span></span><span class="koboSpan" id="kobo.554.1">&gt;(n) };
</span></code></pre>
</li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.555.1">In C++11, there is no limitation to where </span><code class="inlineCode"><span class="koboSpan" id="kobo.556.1">std::numeric_limits&lt;T&gt;</span></code><span class="koboSpan" id="kobo.557.1"> can be used; therefore, preferably, use it over C macros in your modern C++ code.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-95"><span class="koboSpan" id="kobo.558.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.559.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">std::numeric_limits&lt;T&gt;</span></code><span class="koboSpan" id="kobo.561.1"> class template enables developers to query properties of numeric types. </span><span class="koboSpan" id="kobo.561.2">Actual values are available through specializations, and the standard library provides specializations for all the built-in numeric types (</span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">char</span></code><span class="koboSpan" id="kobo.563.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">short</span></code><span class="koboSpan" id="kobo.565.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">int</span></code><span class="koboSpan" id="kobo.567.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.568.1">long</span></code><span class="koboSpan" id="kobo.569.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.570.1">float</span></code><span class="koboSpan" id="kobo.571.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.572.1">double</span></code><span class="koboSpan" id="kobo.573.1">, and so on). </span><span class="koboSpan" id="kobo.573.2">In addition, third parties may provide additional implementations for other types. </span><span class="koboSpan" id="kobo.573.3">An example could be a numeric library that implements a </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">bigint</span></code><span class="koboSpan" id="kobo.575.1"> type and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.576.1">decimal</span></code><span class="koboSpan" id="kobo.577.1"> type and provides specializations of </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">numeric_limits</span></code><span class="koboSpan" id="kobo.579.1"> for these types (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">numeric_limits&lt;bigint&gt;</span></code><span class="koboSpan" id="kobo.581.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">numeric_limits&lt;decimal&gt;</span></code><span class="koboSpan" id="kobo.583.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.584.1">The following specializations of numeric types are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">&lt;limits&gt;</span></code><span class="koboSpan" id="kobo.586.1"> header. </span><span class="koboSpan" id="kobo.586.2">Note that specializations for </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">char16_t</span></code><span class="koboSpan" id="kobo.588.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">char32_t</span></code><span class="koboSpan" id="kobo.590.1"> are new in C++11; the others were available previously. </span><span class="koboSpan" id="kobo.590.2">Apart from the specializations listed ahead, the library also includes specializations for every </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">cv-qualified</span></code><span class="koboSpan" id="kobo.592.1"> version of these numeric types, and they are identical to the unqualified specialization. </span><span class="koboSpan" id="kobo.592.2">For example, consider the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.593.1">int</span></code><span class="koboSpan" id="kobo.594.1">; there are four actual specializations (and they are identical): </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">numeric_limits&lt;int&gt;</span></code><span class="koboSpan" id="kobo.596.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">numeric_limits&lt;const int&gt;</span></code><span class="koboSpan" id="kobo.598.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">numeric_limits&lt;volatile int&gt;</span></code><span class="koboSpan" id="kobo.600.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.601.1">numeric_limits&lt;const volatile int&gt;</span></code><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">You can find the entire list of specializations at </span><a href="https://en.cppreference.com/w/cpp/types/numeric_limits"><span class="url"><span class="koboSpan" id="kobo.603.1">https://en.cppreference.com/w/cpp/types/numeric_limits</span></span></a><span class="koboSpan" id="kobo.604.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.605.1">As mentioned </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.606.1">earlier, in C++11, all static members of </span><code class="inlineCode"><span class="koboSpan" id="kobo.607.1">std::numeric_limits</span></code><span class="koboSpan" id="kobo.608.1"> are </span><code class="inlineCode"><span class="koboSpan" id="kobo.609.1">constexpr</span></code><span class="koboSpan" id="kobo.610.1">, which means they can be used in all the places where constant expressions are needed. </span><span class="koboSpan" id="kobo.610.2">These have several major advantages over C++ macros:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.611.1">They are easier to remember, as the only thing you need to know is the name of the type, which you should know anyway, and not countless names of macros.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.612.1">They support types that are not available in C, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.613.1">char16_t</span></code><span class="koboSpan" id="kobo.614.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.615.1">char32_t</span></code><span class="koboSpan" id="kobo.616.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.617.1">They are the only possible solutions for templates where you don’t know the type.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.618.1">min</span></code><span class="koboSpan" id="kobo.619.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.620.1">max</span></code><span class="koboSpan" id="kobo.621.1"> are only two of the various properties of types it provides; therefore, its actual use is beyond the numeric limits shown. </span><span class="koboSpan" id="kobo.621.2">As a side note, for this reason, the class should have been perhaps called </span><em class="italic"><span class="koboSpan" id="kobo.622.1">numeric_properties</span></em><span class="koboSpan" id="kobo.623.1">, instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">numeric_limits</span></code><span class="koboSpan" id="kobo.625.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.626.1">The following function template, </span><code class="inlineCode"><span class="koboSpan" id="kobo.627.1">print_type_properties()</span></code><span class="koboSpan" id="kobo.628.1">, prints the minimum and maximum finite values of the type, as well as other information:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.629.1">template</span></span><span class="koboSpan" id="kobo.630.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.631.1">typename</span></span><span class="koboSpan" id="kobo.632.1"> T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.633.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.634.1">print_type_properties</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.635.1">()</span></span><span class="koboSpan" id="kobo.636.1">
{
  std::cout
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.637.1">"min="</span></span><span class="koboSpan" id="kobo.638.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.639.1">min</span></span><span class="koboSpan" id="kobo.640.1">()        &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.641.1">'\n'</span></span><span class="koboSpan" id="kobo.642.1">
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.643.1">"max="</span></span><span class="koboSpan" id="kobo.644.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.645.1">max</span></span><span class="koboSpan" id="kobo.646.1">()        &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.647.1">'\n'</span></span><span class="koboSpan" id="kobo.648.1">
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.649.1">"bits="</span></span><span class="koboSpan" id="kobo.650.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::digits       &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.651.1">'\n'</span></span><span class="koboSpan" id="kobo.652.1">
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.653.1">"decdigits="</span></span><span class="koboSpan" id="kobo.654.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::digits10     &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.655.1">'\n'</span></span><span class="koboSpan" id="kobo.656.1">
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.657.1">"integral="</span></span><span class="koboSpan" id="kobo.658.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::is_integer   &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.659.1">'\n'</span></span><span class="koboSpan" id="kobo.660.1">
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.661.1">"signed="</span></span><span class="koboSpan" id="kobo.662.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::is_signed    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.663.1">'\n'</span></span><span class="koboSpan" id="kobo.664.1">
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">"exact="</span></span><span class="koboSpan" id="kobo.666.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::is_exact     &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.667.1">'\n'</span></span><span class="koboSpan" id="kobo.668.1">
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">"infinity="</span></span><span class="koboSpan" id="kobo.670.1">
    &lt;&lt; std::numeric_limits&lt;T&gt;::has_infinity &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.671.1">'\n'</span></span><span class="koboSpan" id="kobo.672.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.673.1">If we call</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.674.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">print_type_properties()</span></code><span class="koboSpan" id="kobo.676.1"> function for </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">unsigned</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.678.1">short</span></code><span class="koboSpan" id="kobo.679.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">int</span></code><span class="koboSpan" id="kobo.681.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.682.1">double</span></code><span class="koboSpan" id="kobo.683.1">, we will get the following output:</span></p>
<table class="table-container" id="table005">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.684.1">unsigned short</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.685.1">int</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.686.1">double</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.687.1">min=0
max=65535
bits=16
decdigits=4
integral=1
signed=0
exact=1
infinity=0
</span></code></pre>
</td>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.688.1">min=-2147483648
max=2147483647
bits=31
decdigits=9
integral=1
signed=1
exact=1
infinity=0
</span></code></pre>
</td>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.689.1">min=2.22507e-308
max=1.79769e+308
bits=53
decdigits=15
integral=0
signed=1
exact=0
infinity=1
</span></code></pre>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.690.1">Table 2.5: The output of print_type_properties() for unsigned short, int, and double</span></p>
<p class="normal"><span class="koboSpan" id="kobo.691.1">Please note that there is a difference between the </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">digits</span></code><span class="koboSpan" id="kobo.693.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">digits10</span></code><span class="koboSpan" id="kobo.695.1"> constants:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.696.1">digits</span></code><span class="koboSpan" id="kobo.697.1"> represents the number of bits (excluding the sign bit if present) and padding bits (if any) for integral types and the number of bits of the mantissa for floating-point types.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">digits10</span></code><span class="koboSpan" id="kobo.699.1"> is the number of decimal digits that can be represented by a type without a change. </span><span class="koboSpan" id="kobo.699.2">To understand this better, let’s consider the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">unsigned short</span></code><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">This is a 16-bit integral type. </span><span class="koboSpan" id="kobo.701.3">It can represent numbers between 0 and 65,536. </span><span class="koboSpan" id="kobo.701.4">It can represent numbers up to five decimal digits, 10,000 to 65,536, but it cannot represent all five decimal digit numbers, as numbers from 65,537 to 99,999 require more bits. </span><span class="koboSpan" id="kobo.701.5">Therefore, the largest numbers that it can represent without requiring more bits have four decimal digits (numbers from 1,000 to 9,999). </span><span class="koboSpan" id="kobo.701.6">This is the value indicated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">digits10</span></code><span class="koboSpan" id="kobo.703.1">. </span><span class="koboSpan" id="kobo.703.2">For integral types, it has a direct relationship to constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">digits</span></code><span class="koboSpan" id="kobo.705.1">; for an integral type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">T</span></code><span class="koboSpan" id="kobo.707.1">, the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">digits10</span></code><span class="koboSpan" id="kobo.709.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">std::numeric_limits&lt;T&gt;::digits * std::log10(2)</span></code><span class="koboSpan" id="kobo.711.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.712.1">It’s worth </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.713.1">mentioning that the standard library types that are aliases of arithmetic types (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">std::size_t</span></code><span class="koboSpan" id="kobo.715.1">) may also be inspected with </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">std::numeric_limits</span></code><span class="koboSpan" id="kobo.717.1">. </span><span class="koboSpan" id="kobo.717.2">On the other hand, other standard types that are not arithmetic types, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">std::complex&lt;T&gt;</span></code><span class="koboSpan" id="kobo.719.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">std::nullptr_t</span></code><span class="koboSpan" id="kobo.721.1">, do not have </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">std::numeric_limits</span></code><span class="koboSpan" id="kobo.723.1"> specializations.</span></p>
<h2 class="heading-2" id="_idParaDest-96"><span class="koboSpan" id="kobo.724.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.725.1">Converting between numeric and string types</span></em><span class="koboSpan" id="kobo.726.1">, to learn how to convert between numbers and strings</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-97"><span class="koboSpan" id="kobo.727.1">Converting between numeric and string types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.728.1">Converting between number and string types is a ubiquitous operation. </span><span class="koboSpan" id="kobo.728.2">Prior to C++11, there was little support for converting numbers to strings and back, so developers had to resort</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.729.1"> mostly to type-unsafe functions, and they usually wrote their own utility functions in order to avoid writing the same code over </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.730.1">and over again. </span><span class="koboSpan" id="kobo.730.2">With C++11, the standard library provides utility functions for converting between numbers and strings. </span><span class="koboSpan" id="kobo.730.3">In this recipe, you will learn how to convert between numbers and strings and the other way around using modern C++ standard functions.</span></p>
<h2 class="heading-2" id="_idParaDest-98"><span class="koboSpan" id="kobo.731.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.732.1">All the utility functions mentioned in this recipe are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.733.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.734.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-99"><span class="koboSpan" id="kobo.735.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.736.1">Use the </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.737.1">following standard conversion functions when you need to convert between numbers and strings:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.738.1">To convert</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.739.1"> from an integer or floating-point type to a string type, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">std::to_string()</span></code><span class="koboSpan" id="kobo.741.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">std::to_wstring()</span></code><span class="koboSpan" id="kobo.743.1">, as shown in the following code snippet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.744.1">auto</span></span><span class="koboSpan" id="kobo.745.1"> si = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.746.1">to_string</span></span><span class="koboSpan" id="kobo.747.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.748.1">42</span></span><span class="koboSpan" id="kobo.749.1">);      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.750.1">// si="42"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.751.1">auto</span></span><span class="koboSpan" id="kobo.752.1"> sl = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.753.1">to_string</span></span><span class="koboSpan" id="kobo.754.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.755.1">42L</span></span><span class="koboSpan" id="kobo.756.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.757.1">// sl="42"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.758.1">auto</span></span><span class="koboSpan" id="kobo.759.1"> su = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.760.1">to_string</span></span><span class="koboSpan" id="kobo.761.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.762.1">42u</span></span><span class="koboSpan" id="kobo.763.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.764.1">// su="42"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.765.1">auto</span></span><span class="koboSpan" id="kobo.766.1"> sd = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.767.1">to_wstring</span></span><span class="koboSpan" id="kobo.768.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.769.1">42.0</span></span><span class="koboSpan" id="kobo.770.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.771.1">// sd=L"42.000000"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.772.1">auto</span></span><span class="koboSpan" id="kobo.773.1"> sld = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.774.1">to_wstring</span></span><span class="koboSpan" id="kobo.775.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.776.1">42.0L</span></span><span class="koboSpan" id="kobo.777.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.778.1">// sld=L"42.000000"</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.779.1">To convert from a string type to an integer type, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.780.1">std::stoi()</span></code><span class="koboSpan" id="kobo.781.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.782.1">std::stol()</span></code><span class="koboSpan" id="kobo.783.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.784.1">std::stoll()</span></code><span class="koboSpan" id="kobo.785.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.786.1">std::stoul()</span></code><span class="koboSpan" id="kobo.787.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.788.1">std::stoull()</span></code><span class="koboSpan" id="kobo.789.1">, as shown in the following code snippet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.790.1">auto</span></span><span class="koboSpan" id="kobo.791.1"> i1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.792.1">stoi</span></span><span class="koboSpan" id="kobo.793.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.794.1">"42"</span></span><span class="koboSpan" id="kobo.795.1">);                  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.796.1">// i1 = 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.797.1">auto</span></span><span class="koboSpan" id="kobo.798.1"> i2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.799.1">stoi</span></span><span class="koboSpan" id="kobo.800.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.801.1">"101010"L</span></span><span class="koboSpan" id="kobo.802.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.803.1">nullptr</span></span><span class="koboSpan" id="kobo.804.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.805.1">2</span></span><span class="koboSpan" id="kobo.806.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.807.1">// i2 = 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.808.1">auto</span></span><span class="koboSpan" id="kobo.809.1"> i3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.810.1">stoi</span></span><span class="koboSpan" id="kobo.811.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.812.1">"052"</span></span><span class="koboSpan" id="kobo.813.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.814.1">nullptr</span></span><span class="koboSpan" id="kobo.815.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.816.1">8</span></span><span class="koboSpan" id="kobo.817.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.818.1">// i3 = 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.819.1">auto</span></span><span class="koboSpan" id="kobo.820.1"> i4 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.821.1">stoi</span></span><span class="koboSpan" id="kobo.822.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.823.1">"0x2A"L</span></span><span class="koboSpan" id="kobo.824.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.825.1">nullptr</span></span><span class="koboSpan" id="kobo.826.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.827.1">16</span></span><span class="koboSpan" id="kobo.828.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.829.1">// i4 = 42</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.830.1">To convert from a string type to a floating-point type, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.831.1">std::stof()</span></code><span class="koboSpan" id="kobo.832.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.833.1">std::stod()</span></code><span class="koboSpan" id="kobo.834.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.835.1">std::stold()</span></code><span class="koboSpan" id="kobo.836.1">, as shown in the following code snippet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.837.1">// d1 = 123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.838.1">auto</span></span><span class="koboSpan" id="kobo.839.1"> d1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.840.1">stod</span></span><span class="koboSpan" id="kobo.841.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.842.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.843.1">123.45"</span></span><span class="koboSpan" id="kobo.844.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.845.1">// d2 = 123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.846.1">auto</span></span><span class="koboSpan" id="kobo.847.1"> d2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.848.1">stod</span></span><span class="koboSpan" id="kobo.849.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.850.1">"1.2345e+2"</span></span><span class="koboSpan" id="kobo.851.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.852.1">// d3 = 123.44999980926514</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.853.1">auto</span></span><span class="koboSpan" id="kobo.854.1"> d3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.855.1">stod</span></span><span class="koboSpan" id="kobo.856.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.857.1">"0xF.6E6666p3"</span></span><span class="koboSpan" id="kobo.858.1">);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-100"><span class="koboSpan" id="kobo.859.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.860.1">To convert </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.861.1">an integral or floating-point type </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.862.1">to a string type, you can use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.863.1">std::to_string()</span></code><span class="koboSpan" id="kobo.864.1"> function (which converts to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.865.1">std::string</span></code><span class="koboSpan" id="kobo.866.1">) or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.867.1">std::to_wstring()</span></code><span class="koboSpan" id="kobo.868.1"> function (which converts to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.869.1">std::wstring</span></code><span class="koboSpan" id="kobo.870.1">). </span><span class="koboSpan" id="kobo.870.2">These functions are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.871.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.872.1"> header and have overloads for signed and unsigned integer and real types. </span><span class="koboSpan" id="kobo.872.2">They produce the same result as </span><code class="inlineCode"><span class="koboSpan" id="kobo.873.1">std::sprintf()</span></code><span class="koboSpan" id="kobo.874.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.875.1">std::swprintf()</span></code><span class="koboSpan" id="kobo.876.1"> would produce when called with the appropriate format specifier for each type. </span><span class="koboSpan" id="kobo.876.2">The following code snippet lists the overload for </span><code class="inlineCode"><span class="koboSpan" id="kobo.877.1">int</span></code><span class="koboSpan" id="kobo.878.1"> of these two functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.879.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.880.1">to_string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.881.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.882.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.883.1"> value)</span></span><span class="koboSpan" id="kobo.884.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.885.1">std::wstring </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.886.1">to_wstring</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.887.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.888.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.889.1"> value)</span></span><span class="koboSpan" id="kobo.890.1">;
</span></code></pre>
<p class="normal"><span class="hljs-function"><span class="koboSpan" id="kobo.891.1">In addition </span></span><span class="hljs-function"><a id="_idIndexMarker167"/></span><span class="hljs-function"><span class="koboSpan" id="kobo.892.1">to </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.893.1">int</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.894.1">, these two functions have overloads for </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">long</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.896.1">, </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">long long</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.898.1">, </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">unsigned int</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.900.1">, </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.901.1">unsigned long</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.902.1">, </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.903.1">unsigned long long</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.904.1">, </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.905.1">float</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.906.1">, </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.907.1">double</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.908.1">, and </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">long double</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.910.1">.</span></span></p>
<p class="normal"><span class="koboSpan" id="kobo.911.1">When it comes</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.912.1"> to the opposite conversion, there is an entire set of functions that have a name with the format </span><strong class="keyWord"><span class="koboSpan" id="kobo.913.1">sto</span></strong><em class="italic"><span class="koboSpan" id="kobo.914.1">n</span></em><span class="koboSpan" id="kobo.915.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.916.1">string to number</span></strong><span class="koboSpan" id="kobo.917.1">), where </span><em class="italic"><span class="koboSpan" id="kobo.918.1">n</span></em><span class="koboSpan" id="kobo.919.1"> stands for </span><strong class="keyWord"><span class="koboSpan" id="kobo.920.1">i</span></strong><span class="koboSpan" id="kobo.921.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">integer</span></code><span class="koboSpan" id="kobo.923.1">), </span><strong class="keyWord"><span class="koboSpan" id="kobo.924.1">l</span></strong><span class="koboSpan" id="kobo.925.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">long</span></code><span class="koboSpan" id="kobo.927.1">), </span><strong class="keyWord"><span class="koboSpan" id="kobo.928.1">ll</span></strong><span class="koboSpan" id="kobo.929.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">long long</span></code><span class="koboSpan" id="kobo.931.1">), </span><strong class="keyWord"><span class="koboSpan" id="kobo.932.1">ul</span></strong><span class="koboSpan" id="kobo.933.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">unsigned long</span></code><span class="koboSpan" id="kobo.935.1">), or </span><strong class="keyWord"><span class="koboSpan" id="kobo.936.1">ull</span></strong><span class="koboSpan" id="kobo.937.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">unsigned long long</span></code><span class="koboSpan" id="kobo.939.1">). </span><span class="koboSpan" id="kobo.939.2">The following list shows the </span><code class="inlineCode"><span class="koboSpan" id="kobo.940.1">stoi</span></code><span class="koboSpan" id="kobo.941.1"> function with its two overloads—one that takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.942.1">std::string</span></code><span class="koboSpan" id="kobo.943.1"> and one that takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">std::wstring</span></code><span class="koboSpan" id="kobo.945.1"> as the first parameter. </span><span class="koboSpan" id="kobo.945.2">In addition, there are similar functions called </span><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">stol</span></code><span class="koboSpan" id="kobo.947.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">stoll</span></code><span class="koboSpan" id="kobo.949.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.950.1">stoul</span></code><span class="koboSpan" id="kobo.951.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.952.1">stoull</span></code><span class="koboSpan" id="kobo.953.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.954.1">stof</span></code><span class="koboSpan" id="kobo.955.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.956.1">stod</span></code><span class="koboSpan" id="kobo.957.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.958.1">stold</span></code><span class="koboSpan" id="kobo.959.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.960.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.961.1">stoi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.962.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.963.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.964.1"> std::string&amp; str, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.965.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.966.1">* pos = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.967.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.968.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.969.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.970.1"> base = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.971.1">10</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.972.1">)</span></span><span class="koboSpan" id="kobo.973.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.974.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.975.1">stoi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.976.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.977.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.978.1"> std::wstring&amp; str, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.979.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.980.1">* pos = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.981.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.982.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.983.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.984.1"> base = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.985.1">10</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.986.1">)</span></span><span class="koboSpan" id="kobo.987.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.988.1">The way the string to integral type functions work is by discarding all white spaces before a non-whitespace character, then taking as many characters as possible to form a signed or unsigned number (depending on the case), and then converting that to the requested integral type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">stoi()</span></code><span class="koboSpan" id="kobo.990.1"> will return an </span><code class="inlineCode"><span class="koboSpan" id="kobo.991.1">integer</span></code><span class="koboSpan" id="kobo.992.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.993.1">stoul()</span></code><span class="koboSpan" id="kobo.994.1"> will return an </span><code class="inlineCode"><span class="koboSpan" id="kobo.995.1">unsigned long</span></code><span class="koboSpan" id="kobo.996.1">, and so on). </span><span class="koboSpan" id="kobo.996.2">In all the following examples, the result is the integer </span><code class="inlineCode"><span class="koboSpan" id="kobo.997.1">42</span></code><span class="koboSpan" id="kobo.998.1">, except for the last example, where the result is </span><code class="inlineCode"><span class="koboSpan" id="kobo.999.1">-42</span></code><span class="koboSpan" id="kobo.1000.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1001.1">auto</span></span><span class="koboSpan" id="kobo.1002.1"> i1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1003.1">stoi</span></span><span class="koboSpan" id="kobo.1004.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1005.1">"42"</span></span><span class="koboSpan" id="kobo.1006.1">);             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1007.1">// i1 = 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1008.1">auto</span></span><span class="koboSpan" id="kobo.1009.1"> i2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1010.1">stoi</span></span><span class="koboSpan" id="kobo.1011.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1012.1">"   42"</span></span><span class="koboSpan" id="kobo.1013.1">);          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1014.1">// i2 = 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1015.1">auto</span></span><span class="koboSpan" id="kobo.1016.1"> i3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1017.1">stoi</span></span><span class="koboSpan" id="kobo.1018.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1019.1">"   42fortytwo"</span></span><span class="koboSpan" id="kobo.1020.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1021.1">// i3 = 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1022.1">auto</span></span><span class="koboSpan" id="kobo.1023.1"> i4 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1024.1">stoi</span></span><span class="koboSpan" id="kobo.1025.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1026.1">"+42"</span></span><span class="koboSpan" id="kobo.1027.1">);            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1028.1">// i4 = 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1029.1">auto</span></span><span class="koboSpan" id="kobo.1030.1"> i5 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1031.1">stoi</span></span><span class="koboSpan" id="kobo.1032.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1033.1">"-42"</span></span><span class="koboSpan" id="kobo.1034.1">);            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1035.1">// i5 = -42</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1036.1">A valid integral number may consist of the following parts:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1037.1">A sign, plus (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1038.1">+</span></code><span class="koboSpan" id="kobo.1039.1">) or minus (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1040.1">-</span></code><span class="koboSpan" id="kobo.1041.1">) (optional)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1042.1">The prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.1043.1">0</span></code><span class="koboSpan" id="kobo.1044.1"> to indicate an octal base (optional)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1045.1">The prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.1046.1">0x</span></code><span class="koboSpan" id="kobo.1047.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1048.1">0X</span></code><span class="koboSpan" id="kobo.1049.1"> to indicate a hexadecimal base (optional)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1050.1">A sequence of digits</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1051.1">The optional prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">0</span></code><span class="koboSpan" id="kobo.1053.1"> (for octal) is applied only when the specified base is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1054.1">8</span></code><span class="koboSpan" id="kobo.1055.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1056.1">0</span></code><span class="koboSpan" id="kobo.1057.1">. </span><span class="koboSpan" id="kobo.1057.2">Similarly, the optional prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.1058.1">0x</span></code><span class="koboSpan" id="kobo.1059.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">0X</span></code><span class="koboSpan" id="kobo.1061.1"> (for hexadecimal) is applied only when the specified base is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">16</span></code><span class="koboSpan" id="kobo.1063.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1064.1">0</span></code><span class="koboSpan" id="kobo.1065.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1066.1">The functions that convert a string to an integer have three parameters:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1067.1">The input string.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1068.1">A pointer that, when not null, will receive the number of characters that were processed. </span><span class="koboSpan" id="kobo.1068.2">This can include any leading white spaces that were discarded, the sign, and the base prefix, so it should not be confused with the number of digits the integral value has.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1069.1">A number indicating the base; by default, this is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1070.1">10</span></code><span class="koboSpan" id="kobo.1071.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1072.1">The</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.1073.1"> valid</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.1074.1"> digits in the input string depend on the base. </span><span class="koboSpan" id="kobo.1074.2">For base </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">2</span></code><span class="koboSpan" id="kobo.1076.1">, the only valid digits are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">0</span></code><span class="koboSpan" id="kobo.1078.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">1</span></code><span class="koboSpan" id="kobo.1080.1">; for base </span><code class="inlineCode"><span class="koboSpan" id="kobo.1081.1">5</span></code><span class="koboSpan" id="kobo.1082.1">, they are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1083.1">01234</span></code><span class="koboSpan" id="kobo.1084.1">. </span><span class="koboSpan" id="kobo.1084.2">For base </span><code class="inlineCode"><span class="koboSpan" id="kobo.1085.1">11</span></code><span class="koboSpan" id="kobo.1086.1">, the valid digits are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1087.1">0</span></code><span class="koboSpan" id="kobo.1088.1">-</span><code class="inlineCode"><span class="koboSpan" id="kobo.1089.1">9</span></code><span class="koboSpan" id="kobo.1090.1"> and the characters </span><code class="inlineCode"><span class="koboSpan" id="kobo.1091.1">A</span></code><span class="koboSpan" id="kobo.1092.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">a</span></code><span class="koboSpan" id="kobo.1094.1">. </span><span class="koboSpan" id="kobo.1094.2">This continues until we reach base </span><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">36</span></code><span class="koboSpan" id="kobo.1096.1">, which has the valid characters </span><code class="inlineCode"><span class="koboSpan" id="kobo.1097.1">0</span></code><span class="koboSpan" id="kobo.1098.1">-</span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">9</span></code><span class="koboSpan" id="kobo.1100.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">A</span></code><span class="koboSpan" id="kobo.1102.1">-</span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">Z</span></code><span class="koboSpan" id="kobo.1104.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">a</span></code><span class="koboSpan" id="kobo.1106.1">-</span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">z</span></code><span class="koboSpan" id="kobo.1108.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1109.1">The following are additional examples of strings with numbers in various bases converted to decimal integers. </span><span class="koboSpan" id="kobo.1109.2">Again, in all cases, the result is either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1110.1">42</span></code><span class="koboSpan" id="kobo.1111.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1112.1">-42</span></code><span class="koboSpan" id="kobo.1113.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1114.1">auto</span></span><span class="koboSpan" id="kobo.1115.1"> i6 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1116.1">stoi</span></span><span class="koboSpan" id="kobo.1117.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1118.1">"052"</span></span><span class="koboSpan" id="kobo.1119.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1120.1">nullptr</span></span><span class="koboSpan" id="kobo.1121.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1122.1">8</span></span><span class="koboSpan" id="kobo.1123.1">);      // i6 = 42
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1124.1">auto</span></span><span class="koboSpan" id="kobo.1125.1"> i7 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1126.1">stoi</span></span><span class="koboSpan" id="kobo.1127.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1128.1">"052"</span></span><span class="koboSpan" id="kobo.1129.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1130.1">nullptr</span></span><span class="koboSpan" id="kobo.1131.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1132.1">0</span></span><span class="koboSpan" id="kobo.1133.1">);      // i7 = 42
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1134.1">auto</span></span><span class="koboSpan" id="kobo.1135.1"> i8 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1136.1">stoi</span></span><span class="koboSpan" id="kobo.1137.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1138.1">"0x2A"</span></span><span class="koboSpan" id="kobo.1139.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1140.1">nullptr</span></span><span class="koboSpan" id="kobo.1141.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1142.1">16</span></span><span class="koboSpan" id="kobo.1143.1">);    // i8 = 42
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1144.1">auto</span></span><span class="koboSpan" id="kobo.1145.1"> i9 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1146.1">stoi</span></span><span class="koboSpan" id="kobo.1147.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1148.1">"0x2A"</span></span><span class="koboSpan" id="kobo.1149.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1150.1">nullptr</span></span><span class="koboSpan" id="kobo.1151.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1152.1">0</span></span><span class="koboSpan" id="kobo.1153.1">);     // i9 = 42
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1154.1">auto</span></span><span class="koboSpan" id="kobo.1155.1"> i10 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1156.1">stoi</span></span><span class="koboSpan" id="kobo.1157.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1158.1">"101010"</span></span><span class="koboSpan" id="kobo.1159.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1160.1">nullptr</span></span><span class="koboSpan" id="kobo.1161.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1162.1">2</span></span><span class="koboSpan" id="kobo.1163.1">); // i10 = 42
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1164.1">auto</span></span><span class="koboSpan" id="kobo.1165.1"> i11 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1166.1">stoi</span></span><span class="koboSpan" id="kobo.1167.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1168.1">"22"</span></span><span class="koboSpan" id="kobo.1169.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1170.1">nullptr</span></span><span class="koboSpan" id="kobo.1171.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1172.1">20</span></span><span class="koboSpan" id="kobo.1173.1">);    // i11 = 42
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1174.1">auto</span></span><span class="koboSpan" id="kobo.1175.1"> i12 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1176.1">stoi</span></span><span class="koboSpan" id="kobo.1177.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1178.1">"-22"</span></span><span class="koboSpan" id="kobo.1179.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1180.1">nullptr</span></span><span class="koboSpan" id="kobo.1181.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1182.1">20</span></span><span class="koboSpan" id="kobo.1183.1">);  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1184.1">// i12 = -42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1185.1">auto</span></span><span class="koboSpan" id="kobo.1186.1"> pos = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1187.1">size_t</span></span><span class="koboSpan" id="kobo.1188.1">{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1189.1">0</span></span><span class="koboSpan" id="kobo.1190.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1191.1">auto</span></span><span class="koboSpan" id="kobo.1192.1"> i13 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1193.1">stoi</span></span><span class="koboSpan" id="kobo.1194.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1195.1">"42"</span></span><span class="koboSpan" id="kobo.1196.1">, &amp;pos);      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1197.1">// i13 = 42,  pos = 2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1198.1">auto</span></span><span class="koboSpan" id="kobo.1199.1"> i14 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1200.1">stoi</span></span><span class="koboSpan" id="kobo.1201.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1202.1">"-42"</span></span><span class="koboSpan" id="kobo.1203.1">, &amp;pos);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1204.1">// i14 = -42, pos = 3</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1205.1">auto</span></span><span class="koboSpan" id="kobo.1206.1"> i15 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1207.1">stoi</span></span><span class="koboSpan" id="kobo.1208.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1209.1">"  +42dec"</span></span><span class="koboSpan" id="kobo.1210.1">, &amp;pos);</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1211.1">// i15 = 42,  pos = 5</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1212.1">An important thing to note is that these conversion functions throw an exception if the conversion fails. </span><span class="koboSpan" id="kobo.1212.2">There are two exceptions that can be thrown:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1213.1">std::invalid_argument</span></code><span class="koboSpan" id="kobo.1214.1"> if the conversion cannot be performed:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1215.1">try</span></span><span class="koboSpan" id="kobo.1216.1">
{
  auto i16 = std::stoi(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1217.1">""</span></span><span class="koboSpan" id="kobo.1218.1">);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">catch</span></span><span class="koboSpan" id="kobo.1220.1"> (std::exception </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">const</span></span><span class="koboSpan" id="kobo.1222.1"> &amp; e)
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1223.1">// prints "invalid stoi argument"</span></span><span class="koboSpan" id="kobo.1224.1">
  std::cout &lt;&lt; e.what() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1225.1">'\n'</span></span><span class="koboSpan" id="kobo.1226.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1227.1">std::out_of_range</span></code><span class="koboSpan" id="kobo.1228.1"> if the converted value is outside the range of the result type (or if the underlying function sets </span><code class="inlineCode"><span class="koboSpan" id="kobo.1229.1">errno</span></code><span class="koboSpan" id="kobo.1230.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1231.1">ERANGE</span></code><span class="koboSpan" id="kobo.1232.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1233.1">try</span></span><span class="koboSpan" id="kobo.1234.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1235.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1236.1">auto</span></span><span class="koboSpan" id="kobo.1237.1"> i17 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1238.1">stoll</span></span><span class="koboSpan" id="kobo.1239.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1240.1">"12345678901234"</span></span><span class="koboSpan" id="kobo.1241.1">);
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1242.1">// throws std::out_of_range</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1243.1">auto</span></span><span class="koboSpan" id="kobo.1244.1"> i18 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1245.1">stoi</span></span><span class="koboSpan" id="kobo.1246.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1247.1">"12345678901234"</span></span><span class="koboSpan" id="kobo.1248.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1249.1">catch</span></span><span class="koboSpan" id="kobo.1250.1"> (std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.1251.1">const</span></span><span class="koboSpan" id="kobo.1252.1"> &amp; e)
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1253.1">// prints "stoi argument out of range"</span></span><span class="koboSpan" id="kobo.1254.1">
  std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1255.1">what</span></span><span class="koboSpan" id="kobo.1256.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1257.1">'\n'</span></span><span class="koboSpan" id="kobo.1258.1">;
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1259.1">The </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.1260.1">other</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.1261.1"> set of functions that convert a string to a floating-point type are very similar, except that they don’t have a parameter for the numeric base. </span><span class="koboSpan" id="kobo.1261.2">A valid floating-point value can have different representations in the input string:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1262.1">Decimal floating-point expression (optional sign, sequence of decimal digits with optional point, optional </span><code class="inlineCode"><span class="koboSpan" id="kobo.1263.1">e</span></code><span class="koboSpan" id="kobo.1264.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1265.1">E</span></code><span class="koboSpan" id="kobo.1266.1">, followed by exponent with optional sign)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1267.1">Binary floating-point expression (optional sign, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1268.1">0x</span></code><span class="koboSpan" id="kobo.1269.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1270.1">0X</span></code><span class="koboSpan" id="kobo.1271.1"> prefix, sequence of hexadecimal digits with optional point, optional </span><code class="inlineCode"><span class="koboSpan" id="kobo.1272.1">p</span></code><span class="koboSpan" id="kobo.1273.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1274.1">P</span></code><span class="koboSpan" id="kobo.1275.1">, followed by exponent with optional sign)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1276.1">Infinity expression (optional sign followed by case-insensitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.1277.1">INF</span></code><span class="koboSpan" id="kobo.1278.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1279.1">INFINITY</span></code><span class="koboSpan" id="kobo.1280.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1281.1">A non-number expression (optional sign followed by case-insensitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.1282.1">NAN</span></code><span class="koboSpan" id="kobo.1283.1"> and possibly other alphanumeric characters)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1284.1">Apart from these formats, additional ones supported by the currently installed C locale may also be supported.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1285.1">The following are various examples of converting strings to doubles:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1286.1">auto</span></span><span class="koboSpan" id="kobo.1287.1"> d1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1288.1">stod</span></span><span class="koboSpan" id="kobo.1289.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1290.1">"123.45"</span></span><span class="koboSpan" id="kobo.1291.1">);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1292.1">// d1 =  123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1293.1">auto</span></span><span class="koboSpan" id="kobo.1294.1"> d2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1295.1">stod</span></span><span class="koboSpan" id="kobo.1296.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1297.1">"+123.45"</span></span><span class="koboSpan" id="kobo.1298.1">);        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1299.1">// d2 =  123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1300.1">auto</span></span><span class="koboSpan" id="kobo.1301.1"> d3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1302.1">stod</span></span><span class="koboSpan" id="kobo.1303.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1304.1">"-123.45"</span></span><span class="koboSpan" id="kobo.1305.1">);        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1306.1">// d3 = -123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1307.1">auto</span></span><span class="koboSpan" id="kobo.1308.1"> d4 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1309.1">stod</span></span><span class="koboSpan" id="kobo.1310.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1311.1">"  123.45"</span></span><span class="koboSpan" id="kobo.1312.1">);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1313.1">// d4 =  123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1314.1">auto</span></span><span class="koboSpan" id="kobo.1315.1"> d5 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1316.1">stod</span></span><span class="koboSpan" id="kobo.1317.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1318.1">"  -123.45abc"</span></span><span class="koboSpan" id="kobo.1319.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1320.1">// d5 = -123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1321.1">auto</span></span><span class="koboSpan" id="kobo.1322.1"> d6 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1323.1">stod</span></span><span class="koboSpan" id="kobo.1324.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1325.1">"1.2345e+2"</span></span><span class="koboSpan" id="kobo.1326.1">);      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1327.1">// d6 =  123.45000000000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1328.1">auto</span></span><span class="koboSpan" id="kobo.1329.1"> d7 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1330.1">stod</span></span><span class="koboSpan" id="kobo.1331.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1332.1">"0xF.6E6666p3"</span></span><span class="koboSpan" id="kobo.1333.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1334.1">// d7 =  123.44999980926514</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1335.1">auto</span></span><span class="koboSpan" id="kobo.1336.1"> d8 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1337.1">stod</span></span><span class="koboSpan" id="kobo.1338.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1339.1">"INF"</span></span><span class="koboSpan" id="kobo.1340.1">);            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1341.1">// d8 = inf</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1342.1">auto</span></span><span class="koboSpan" id="kobo.1343.1"> d9 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1344.1">stod</span></span><span class="koboSpan" id="kobo.1345.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1346.1">"-infinity"</span></span><span class="koboSpan" id="kobo.1347.1">);      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1348.1">// d9 = -inf</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1349.1">auto</span></span><span class="koboSpan" id="kobo.1350.1"> d10 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1351.1">stod</span></span><span class="koboSpan" id="kobo.1352.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1353.1">"NAN"</span></span><span class="koboSpan" id="kobo.1354.1">);           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1355.1">// d10 = nan</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1356.1">auto</span></span><span class="koboSpan" id="kobo.1357.1"> d11 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1358.1">stod</span></span><span class="koboSpan" id="kobo.1359.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1360.1">"-nanabc"</span></span><span class="koboSpan" id="kobo.1361.1">);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1362.1">// d11 = -nan</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1363.1">The </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.1364.1">floating-point base 2 scientific notation, seen </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.1365.1">earlier in the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.1366.1">0xF.6E6666p3</span></code><span class="koboSpan" id="kobo.1367.1">, is not the topic of this recipe. </span><span class="koboSpan" id="kobo.1367.2">However, for a clear understanding, a short description is provided, but it is recommended that you look at additional references for details (such as </span><a href="https://en.cppreference.com/w/cpp/language/floating_literal"><span class="url"><span class="koboSpan" id="kobo.1368.1">https://en.cppreference.com/w/cpp/language/floating_literal</span></span></a><span class="koboSpan" id="kobo.1369.1">). </span><span class="koboSpan" id="kobo.1369.2">A floating-point constant in the base 2 scientific notation is composed of several parts:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1370.1">The hexadecimal prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.1371.1">0x</span></code><span class="koboSpan" id="kobo.1372.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1373.1">An integer part; in this example, it was </span><code class="inlineCode"><span class="koboSpan" id="kobo.1374.1">F</span></code><span class="koboSpan" id="kobo.1375.1">, which in decimal is 15.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1376.1">A fractional part, which, in this example, was </span><code class="inlineCode"><span class="koboSpan" id="kobo.1377.1">6E6666</span></code><span class="koboSpan" id="kobo.1378.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1379.1">011011100110011001100110</span></code><span class="koboSpan" id="kobo.1380.1"> in binary. </span><span class="koboSpan" id="kobo.1380.2">To convert that into decimal, we need to add inverse powers of two: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1381.1">1/4 + 1/8 + 1/32 + 1/64 + 1/128 + ...</span></code><span class="koboSpan" id="kobo.1382.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1383.1">A suffix, representing a power of 2; in this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1384.1">p3</span></code><span class="koboSpan" id="kobo.1385.1"> means 2 at the power of 3.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1386.1">The value of the decimal equivalent is determined by multiplying the significant (composed of the integer and fractional parts) and the base at the power of the exponent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1387.1">For the given hexadecimal base 2 floating-point literal, the significant is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1388.1">15.4312499...</span></code><span class="koboSpan" id="kobo.1389.1"> (please note that digits after the seventh one are not shown), the base is 2, and the exponent is 3. </span><span class="koboSpan" id="kobo.1389.2">Therefore, the result is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1390.1">15.4212499... </span><span class="koboSpan" id="kobo.1390.2">* 8</span></code><span class="koboSpan" id="kobo.1391.1">, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1392.1">123.44999980926514</span></code><span class="koboSpan" id="kobo.1393.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-101"><span class="koboSpan" id="kobo.1394.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1395.1">Limits and other properties of numeric types</span></em><span class="koboSpan" id="kobo.1396.1">, to learn about the minimum and maximum values, as well as the other properties of numerical types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-102"><span class="koboSpan" id="kobo.1397.1">Understanding the various character and string types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1398.1">In the previous recipe, we looked at the variety of integral and floating-point types. </span><span class="koboSpan" id="kobo.1398.2">Another category of types, character types, is often a source of misunderstanding and confusion. </span><span class="koboSpan" id="kobo.1398.3">As of C++20, there are five character data types in the C++ language: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">char</span></code><span class="koboSpan" id="kobo.1400.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">wchar_t</span></code><span class="koboSpan" id="kobo.1402.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">char8_t</span></code><span class="koboSpan" id="kobo.1404.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1405.1">char16_t</span></code><span class="koboSpan" id="kobo.1406.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1407.1">char32_t</span></code><span class="koboSpan" id="kobo.1408.1">. </span><span class="koboSpan" id="kobo.1408.2">In this recipe, we will look at how these types differ and how they are meant to be used. </span></p>
<h2 class="heading-2" id="_idParaDest-103"><span class="koboSpan" id="kobo.1409.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1410.1">Use the available </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.1411.1">character types as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1412.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1413.1">char</span></code><span class="koboSpan" id="kobo.1414.1"> type to </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.1415.1">store ASCII characters, Latin character sets (defined in the ISO-8859 standard), or even individual bytes of UTF-8 encoded characters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1416.1">char</span></span><span class="koboSpan" id="kobo.1417.1"> c = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1418.1">'C'</span></span><span class="koboSpan" id="kobo.1419.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1420.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1421.1">char</span></span><span class="koboSpan" id="kobo.1422.1">* s = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1423.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1424.1">C++"</span></span><span class="koboSpan" id="kobo.1425.1">;
std::cout &lt;&lt; c &lt;&lt;  s &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1426.1">'\n'</span></span><span class="koboSpan" id="kobo.1427.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1428.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1429.1">wchar_t</span></code><span class="koboSpan" id="kobo.1430.1"> type with </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.1431.1">the Windows API to store and manipulate UTF-16LE encoded characters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1432.1">wchar_t</span></span><span class="koboSpan" id="kobo.1433.1"> c = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1434.1">L'Ʃ'</span></span><span class="koboSpan" id="kobo.1435.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1436.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1437.1">wchar_t</span></span><span class="koboSpan" id="kobo.1438.1">* s = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1439.1">L"δῆμος"</span></span><span class="koboSpan" id="kobo.1440.1">;
std::wcout &lt;&lt; c &lt;&lt; s &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1441.1">'\n'</span></span><span class="koboSpan" id="kobo.1442.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1443.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1444.1">char8_t</span></code><span class="koboSpan" id="kobo.1445.1"> type to store </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.1446.1">individual bytes of UTF-8 encoded code points:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1447.1">char8_t</span></span><span class="koboSpan" id="kobo.1448.1"> c = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1449.1">u8'A'</span></span><span class="koboSpan" id="kobo.1450.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1451.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1452.1">char8_t</span></span><span class="koboSpan" id="kobo.1453.1">* s = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1454.1">u8"Æthelflæd"</span></span><span class="koboSpan" id="kobo.1455.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1456.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1457.1">char16_t</span></code><span class="koboSpan" id="kobo.1458.1"> type </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.1459.1">to store UTF-16 encoded characters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1460.1">char16_t</span></span><span class="koboSpan" id="kobo.1461.1"> c = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1462.1">u'Æ'</span></span><span class="koboSpan" id="kobo.1463.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1464.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1465.1">char16_t</span></span><span class="koboSpan" id="kobo.1466.1">* s = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1467.1">u"Æthelflæd"</span></span><span class="koboSpan" id="kobo.1468.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1469.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1470.1">char32_t</span></code><span class="koboSpan" id="kobo.1471.1"> type to </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.1472.1">store UTF-32 encoded characters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1473.1">char32_t</span></span><span class="koboSpan" id="kobo.1474.1"> c = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1475.1">U'</span><span class="koboSpan" id="kobo.1476.1"><img alt="" src="../Images/4th_GLYPS.png"/></span><span class="koboSpan" id="kobo.1477.1">'</span></span><span class="koboSpan" id="kobo.1478.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1479.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1480.1">char32_t</span></span><span class="koboSpan" id="kobo.1481.1">* s = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1482.1">U"</span><span class="koboSpan" id="kobo.1483.1"><img alt="" src="../Images/3rd_GLYPS.png"/></span><span class="koboSpan" id="kobo.1484.1">"</span></span><span class="koboSpan" id="kobo.1485.1">;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-104"><span class="koboSpan" id="kobo.1486.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1487.1">The built-in data type for storing characters from the early days of the C++ language was the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1488.1">char</span></code><span class="koboSpan" id="kobo.1489.1"> type. </span><span class="koboSpan" id="kobo.1489.2">This is an 8-bit data type that is different from both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1490.1">signed char</span></code><span class="koboSpan" id="kobo.1491.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1492.1">unsigned char</span></code><span class="koboSpan" id="kobo.1493.1">. </span><span class="koboSpan" id="kobo.1493.2">It is not a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1494.1">typedef</span></code><span class="koboSpan" id="kobo.1495.1"> of any of these two data types. </span><span class="koboSpan" id="kobo.1495.2">You can test that using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1496.1">std::is_same</span></code><span class="koboSpan" id="kobo.1497.1"> type trait:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1498.1">std::cout &lt;&lt; std::is_same_v&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1499.1">char</span></span><span class="koboSpan" id="kobo.1500.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1501.1">signed</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1502.1">char</span></span><span class="koboSpan" id="kobo.1503.1">&gt; &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1504.1">'\n'</span></span><span class="koboSpan" id="kobo.1505.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1506.1">// prints 0</span></span><span class="koboSpan" id="kobo.1507.1">
std::cout &lt;&lt; std::is_same_v&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1508.1">char</span></span><span class="koboSpan" id="kobo.1509.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1510.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1511.1">char</span></span><span class="koboSpan" id="kobo.1512.1">&gt; &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1513.1">'\n'</span></span><span class="koboSpan" id="kobo.1514.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1515.1">// prints 0</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1516.1">Both of these lines will print 0. </span><span class="koboSpan" id="kobo.1516.2">This means you can have function overloads for all these three data types, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1517.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1518.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1519.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1520.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1521.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1522.1">{}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1523.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1524.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1525.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1526.1">signed</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1527.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1528.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1529.1">{}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1530.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1531.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1532.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1533.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1534.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1535.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1536.1">{}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1537.1">The standard does</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.1538.1"> not specify whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.1539.1">char</span></code><span class="koboSpan" id="kobo.1540.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1541.1">signed</span></code><span class="koboSpan" id="kobo.1542.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1543.1">unsigned</span></code><span class="koboSpan" id="kobo.1544.1"> type. </span><span class="koboSpan" id="kobo.1544.2">Therefore, its signedness depends on the compiler or target platform. </span><span class="koboSpan" id="kobo.1544.3">The type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1545.1">char</span></code><span class="koboSpan" id="kobo.1546.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1547.1">signed</span></code><span class="koboSpan" id="kobo.1548.1"> type on x86 and x64 systems and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1549.1">unsigned</span></code><span class="koboSpan" id="kobo.1550.1"> on ARM.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1551.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1552.1">char</span></code><span class="koboSpan" id="kobo.1553.1"> data type can be used to store the characters from the ASCII character set and other 8-bit Latin character sets such as Latin-1, Latin-2, Latin/Cyrillic, Latin Nordic, and so on. </span><span class="koboSpan" id="kobo.1553.2">It can also be used to store individual bytes of multi-byte character sets, the most widely used being the UTF-8 encoding of the Unicode set.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1554.1">For dealing with fixed-width multi-byte character sets, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1555.1">wchar_t</span></code><span class="koboSpan" id="kobo.1556.1"> type was introduced in C++98. </span><span class="koboSpan" id="kobo.1556.2">This is also a unique data type (not a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1557.1">typedef</span></code><span class="koboSpan" id="kobo.1558.1"> of some integral type). </span><span class="koboSpan" id="kobo.1558.2">Its size is not specified and, therefore, also varies: it is 2 bytes on Windows and typically 4 bytes on Unix systems. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1559.1">This means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1560.1">wchar_t</span></code><span class="koboSpan" id="kobo.1561.1"> should not be used when writing portable code. </span><span class="koboSpan" id="kobo.1561.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1562.1">wchar_t</span></code><span class="koboSpan" id="kobo.1563.1"> type is mostly used on Windows where it was adopted for storing 16-bit characters of the UTF-16LE encoding of the Unicode character set. </span><span class="koboSpan" id="kobo.1563.2">This is the native character set of the Windows operating system. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1564.1">In newer versions of the standard, three new character data types have been introduced. </span><span class="koboSpan" id="kobo.1564.2">In C++11, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1565.1">char32_t</span></code><span class="koboSpan" id="kobo.1566.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1567.1">char16_t</span></code><span class="koboSpan" id="kobo.1568.1"> were added to represent 32-bit and 16-bit wide characters. </span><span class="koboSpan" id="kobo.1568.2">They are intended to represent UTF-32 and UTF-16 encoded Unicode characters. </span><span class="koboSpan" id="kobo.1568.3">Although they are each distinctive types, they are equal in size, signedness, and alignment with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1569.1">uint_least32_t</span></code><span class="koboSpan" id="kobo.1570.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1571.1">uint_least16_t</span></code><span class="koboSpan" id="kobo.1572.1">, respectively. </span><span class="koboSpan" id="kobo.1572.2">In C++20, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1573.1">char8_t</span></code><span class="koboSpan" id="kobo.1574.1"> data type was added. </span><span class="koboSpan" id="kobo.1574.2">This is intended to store UTF-8 code units (which are 8-bit). </span><span class="koboSpan" id="kobo.1574.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1575.1">char8_t</span></code><span class="koboSpan" id="kobo.1576.1"> type is a distinctive 8-bit type and has the same size, signedness, and alignment as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1577.1">unsigned char</span></code><span class="koboSpan" id="kobo.1578.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1579.1">We can summarize all this information in the following table:</span></p>
<table class="table-container" id="table006">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1580.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1581.1">C++ Standard</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1582.1">Size (bytes)</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1583.1">Sign</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1584.1">char</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1585.1">All versions</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1586.1">1</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1587.1">unspecified</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1588.1">wchar_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1589.1">C++98</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1590.1">Unspecified</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1591.1">(typically, 2 or 4)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1592.1">unspecified</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1593.1">char8_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1594.1">C++20</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1595.1">1</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1596.1">unsigned</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1597.1">char16_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1598.1">C++11</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1599.1">2</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1600.1">unsigned</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1601.1">char32_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1602.1">C++11</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1603.1">4</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1604.1">unsigned</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1605.1">Table 2.6: Summary of size and signedness of the C++ character types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1606.1">Strings of </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.1607.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1608.1">char</span></code><span class="koboSpan" id="kobo.1609.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1610.1">char8_t</span></code><span class="koboSpan" id="kobo.1611.1"> types are called </span><em class="italic"><span class="koboSpan" id="kobo.1612.1">narrow strings</span></em><span class="koboSpan" id="kobo.1613.1">, and strings of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1614.1">wchar_t</span></code><span class="koboSpan" id="kobo.1615.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1616.1">char16_t</span></code><span class="koboSpan" id="kobo.1617.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1618.1">char32_t</span></code><span class="koboSpan" id="kobo.1619.1"> types are called </span><em class="italic"><span class="koboSpan" id="kobo.1620.1">wide strings</span></em><span class="koboSpan" id="kobo.1621.1">. </span><span class="koboSpan" id="kobo.1621.2">The C++ standard provides a container for storing and manipulating sequences of characters. </span><span class="koboSpan" id="kobo.1621.3">This is a class template that has several type aliases defined to simplify usage, as shown in the following table:</span></p>
<table class="table-container" id="table007">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1622.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1623.1">Definition</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1624.1">C++ Standard</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1625.1">std::string</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1626.1">std::basic_string&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1627.1">C++98</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1628.1">std::wstring</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1629.1">std::basic_string&lt;wchar_t&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1630.1">C++98</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1631.1">std::u8string</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1632.1">std::basic_string&lt;char8_t&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1633.1">C++20</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1634.1">std::u16string</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1635.1">std::basic_string&lt;char16_t&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1636.1">C++11</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1637.1">std::u32string</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1638.1">std::basic_string&lt;char32_t&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1639.1">C++11</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1640.1">Table 2.7: The various type aliases for std::basic_string</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1641.1">Like the other standard containers, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1642.1">std::basic_string</span></code><span class="koboSpan" id="kobo.1643.1"> provides a multitude of member functions to construct, access elements, iterate, search, or perform various operations with the contained sequence of characters. </span><span class="koboSpan" id="kobo.1643.2">A particular mention needs to be made about how data is stored in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1644.1">basic_string</span></code><span class="koboSpan" id="kobo.1645.1">. </span><span class="koboSpan" id="kobo.1645.2">In C++11, it is guaranteed to be contiguous, like in an array. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1646.1">On the other hand, it may be a bit confusing how it handles string termination. </span><span class="koboSpan" id="kobo.1646.2">Let’s take an example to explain it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1647.1">std::string s = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1648.1">"demo"</span></span><span class="koboSpan" id="kobo.1649.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1650.1">The elements</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.1651.1"> stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1652.1">basic_string</span></code><span class="koboSpan" id="kobo.1653.1"> object are the characters </span><code class="inlineCode"><span class="koboSpan" id="kobo.1654.1">'d</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1655.1">'</span></code><span class="koboSpan" id="kobo.1656.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1657.1">'e</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1658.1">'</span></code><span class="koboSpan" id="kobo.1659.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1660.1">'m</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1661.1">'</span></code><span class="koboSpan" id="kobo.1662.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1663.1">'o</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1664.1">'</span></code><span class="koboSpan" id="kobo.1665.1">. </span><span class="koboSpan" id="kobo.1665.2">This is what you get if you iterate over the object (e.g., </span><code class="inlineCode"><span class="koboSpan" id="kobo.1666.1">for (auto c : s)</span></code><span class="koboSpan" id="kobo.1667.1">). </span><span class="koboSpan" id="kobo.1667.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1668.1">size()</span></code><span class="koboSpan" id="kobo.1669.1"> member will return 4. </span><span class="koboSpan" id="kobo.1669.2">However, both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1670.1">c_str()</span></code><span class="koboSpan" id="kobo.1671.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1672.1">data()</span></code><span class="koboSpan" id="kobo.1673.1"> member functions will return a null terminator. </span><span class="koboSpan" id="kobo.1673.2">That means that it’s guaranteed that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1674.1">s[s.size()]</span></code><span class="koboSpan" id="kobo.1675.1"> is 0.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1676.1">Characters and strings are often provided as literals in source code. </span><span class="koboSpan" id="kobo.1676.2">There are different prefixes for the different character types, as listed in the following table:</span></p>
<table class="table-container" id="table008">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1677.1">Literal</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1678.1">C++ Standard</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1679.1">Character type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1680.1">String type</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1681.1">none</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1682.1">All versions</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1683.1">char</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1684.1">const char*</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1685.1">L</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1686.1">C++98</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1687.1">wchar_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1688.1">const wchar_t*</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1689.1">u8</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1690.1">C++11</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1691.1">char</span></code><span class="koboSpan" id="kobo.1692.1"> (until C++20)</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1693.1">char8_t</span></code><span class="koboSpan" id="kobo.1694.1"> (since C++20)</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1695.1">const char*</span></code><span class="koboSpan" id="kobo.1696.1"> (until C++20)</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1697.1">const char8_t*</span></code><span class="koboSpan" id="kobo.1698.1"> (since C++20)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1699.1">u</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1700.1">C++11</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1701.1">char16_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1702.1">const char16_t*</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1703.1">U</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1704.1">C++11</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1705.1">char32_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">const char32_t*</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1707.1">Table 2.8: Prefixes for the different character and string types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1708.1">We can demonstrate this with the following snippet (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1709.1">auto</span></code><span class="koboSpan" id="kobo.1710.1"> is used didactically to explain the deduction rules):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1711.1">auto</span></span><span class="koboSpan" id="kobo.1712.1"> c1 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1713.1">'a'</span></span><span class="koboSpan" id="kobo.1714.1">;     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1715.1">// char</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1716.1">auto</span></span><span class="koboSpan" id="kobo.1717.1"> c2 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1718.1">L'b'</span></span><span class="koboSpan" id="kobo.1719.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1720.1">// wchar_t</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1721.1">auto</span></span><span class="koboSpan" id="kobo.1722.1"> c3 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1723.1">u8'c'</span></span><span class="koboSpan" id="kobo.1724.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1725.1">// char until C++20, char8_t in C++20</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1726.1">auto</span></span><span class="koboSpan" id="kobo.1727.1"> c4 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1728.1">u'd'</span></span><span class="koboSpan" id="kobo.1729.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1730.1">// char16_t</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1731.1">auto</span></span><span class="koboSpan" id="kobo.1732.1"> c5 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1733.1">U'e'</span></span><span class="koboSpan" id="kobo.1734.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1735.1">// char32_t</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1736.1">auto</span></span><span class="koboSpan" id="kobo.1737.1"> sa1 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1738.1">"a"</span></span><span class="koboSpan" id="kobo.1739.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1740.1">// const char*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1741.1">auto</span></span><span class="koboSpan" id="kobo.1742.1"> sa2 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1743.1">L"a"</span></span><span class="koboSpan" id="kobo.1744.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1745.1">// const wchar_t*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1746.1">auto</span></span><span class="koboSpan" id="kobo.1747.1"> sa3 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1748.1">u8"a"</span></span><span class="koboSpan" id="kobo.1749.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1750.1">// const char* until C++20</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1751.1">// const char8_t* in C++20</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1752.1">auto</span></span><span class="koboSpan" id="kobo.1753.1"> sa4 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1754.1">u"a"</span></span><span class="koboSpan" id="kobo.1755.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1756.1">// const char16_t*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1757.1">auto</span></span><span class="koboSpan" id="kobo.1758.1"> sa5 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1759.1">U"a"</span></span><span class="koboSpan" id="kobo.1760.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1761.1">// const char32_t*</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1762.1">In the first part, because </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.1763.1">single quotes are used, character types are deduced for variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.1764.1">c1</span></code><span class="koboSpan" id="kobo.1765.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1766.1">c5</span></code><span class="koboSpan" id="kobo.1767.1">, depending on the literal prefix (the deduced type is mentioned on the right side in the comments). </span><span class="koboSpan" id="kobo.1767.2">In the second part, because double quotes are used, string types are deduced for variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.1768.1">sa1</span></code><span class="koboSpan" id="kobo.1769.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1770.1">sa5</span></code><span class="koboSpan" id="kobo.1771.1">, again, depending on the literal prefix. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1772.1">The deduced type for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1773.1">"a"</span></code><span class="koboSpan" id="kobo.1774.1"> is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.1775.1">std::string</span></code><span class="koboSpan" id="kobo.1776.1"> but </span><code class="inlineCode"><span class="koboSpan" id="kobo.1777.1">const char*</span></code><span class="koboSpan" id="kobo.1778.1">. </span><span class="koboSpan" id="kobo.1778.2">If you want to use any of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1779.1">basic_string</span></code><span class="koboSpan" id="kobo.1780.1"> typedefs, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1781.1">std::string</span></code><span class="koboSpan" id="kobo.1782.1">, you must either define the type explicitly (and not use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1783.1">auto</span></code><span class="koboSpan" id="kobo.1784.1">) or use a standard user-defined literal suffix, available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1785.1">std::string_literals</span></code><span class="koboSpan" id="kobo.1786.1"> namespace. </span><span class="koboSpan" id="kobo.1786.2">This is shown in the next snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1787.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1788.1">namespace</span></span><span class="koboSpan" id="kobo.1789.1"> std::string_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1790.1">auto</span></span><span class="koboSpan" id="kobo.1791.1"> s1 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1792.1">"a"</span></span><span class="koboSpan" id="kobo.1793.1">s;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1794.1">// std::string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1795.1">auto</span></span><span class="koboSpan" id="kobo.1796.1"> s2 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1797.1">L"a"</span></span><span class="koboSpan" id="kobo.1798.1">s;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1799.1">// std::wstring</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1800.1">auto</span></span><span class="koboSpan" id="kobo.1801.1"> s3 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1802.1">u8"a"</span></span><span class="koboSpan" id="kobo.1803.1">s;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1804.1">// std::u8string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1805.1">auto</span></span><span class="koboSpan" id="kobo.1806.1"> s4 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1807.1">u"a"</span></span><span class="koboSpan" id="kobo.1808.1">s;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1809.1">// std::u16string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1810.1">auto</span></span><span class="koboSpan" id="kobo.1811.1"> s5 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1812.1">U"a"</span></span><span class="koboSpan" id="kobo.1813.1">s;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1814.1">// std::u32string</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1815.1">To avoid confusion, the following table explains the meaning of various pointer types:</span></p>
<table class="table-container" id="table009">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1816.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1817.1">Meaning</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1818.1">char*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1819.1">A mutable pointer to a mutable character. </span><span class="koboSpan" id="kobo.1819.2">Both the pointer and the pointed character can be modified. </span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1820.1">const char*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1821.1">A mutable pointer to a constant character. </span><span class="koboSpan" id="kobo.1821.2">The pointer can be modified, but not the content of the location it points to.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1822.1">char * const</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1823.1">A constant pointer to a mutable character. </span><span class="koboSpan" id="kobo.1823.2">The pointer cannot be modified, but the content of the location it points to can be.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1824.1">const char * const</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1825.1">A constant pointer to a constant character. </span><span class="koboSpan" id="kobo.1825.2">Neither the pointer nor the content of the location it points to can be modified.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1826.1">char[]</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1827.1">An array of characters.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1828.1">Table 2.9: The meaning of various pointer types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1829.1">You must have noticed that, in the previous table, the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.1830.1">u8</span></code><span class="koboSpan" id="kobo.1831.1"> had different behavior with different standards:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1832.1">Since C++11, when it was introduced, until C++20, it defined a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1833.1">char</span></code><span class="koboSpan" id="kobo.1834.1"> literal.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1835.1">Since C++20, when it was repurposed with the introduction of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1836.1">char8_t</span></code><span class="koboSpan" id="kobo.1837.1">, it defines a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1838.1">char8_t</span></code><span class="koboSpan" id="kobo.1839.1"> literal.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1840.1">This C++20 change</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.1841.1"> is a breaking change. </span><span class="koboSpan" id="kobo.1841.2">It was preferred over the introduction of yet another literal prefix that could have the potential of complicating things even further.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1842.1">A character or string literal may contain code point values instead of actual characters. </span><span class="koboSpan" id="kobo.1842.2">These must be escaped with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1843.1">\u</span></code><span class="koboSpan" id="kobo.1844.1"> (for 4 hexadecimal digit code points) or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1845.1">\U</span></code><span class="koboSpan" id="kobo.1846.1"> (for 8 hexadecimal digit code points). </span><span class="koboSpan" id="kobo.1846.2">Here is an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1847.1">std::u16string hb = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1848.1">u"Harald Bluetooth \u16BC\u16d2"</span></span><span class="koboSpan" id="kobo.1849.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1850.1">// </span><span class="koboSpan" id="kobo.1851.1"><img alt="" src="../Images/1ST_GLYPS.png"/></span></span><span class="koboSpan" id="kobo.1852.1">
std::u32string eh = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1853.1">U"Egyptian hieroglyphs \U00013000 \U000131B2"</span></span><span class="koboSpan" id="kobo.1854.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1855.1">// </span><span class="koboSpan" id="kobo.1856.1"><img alt="" src="../Images/2nd_GLYPS.png"/></span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1857.1">In C++23, it is possible to use Unicode instead of code point values. </span><span class="koboSpan" id="kobo.1857.2">That is done using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1858.1">\N{xxx}</span></code><span class="koboSpan" id="kobo.1859.1"> escape sequence, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1860.1">xxx</span></code><span class="koboSpan" id="kobo.1861.1"> is the Unicode assigned name. </span><span class="koboSpan" id="kobo.1861.2">Therefore, the snippet above can also be written as follows in C++23:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1862.1">std::u16string hb = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1863.1">u"Harald Bluetooth \N{Runic Letter Long-Branch-Hagall H}\N{Runic Letter Berkanan Beorc Bjarkan B}"</span></span><span class="koboSpan" id="kobo.1864.1">;
std::u32string eh = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1865.1">U"Egyptian hieroglyphs \N{EGYPTIAN HIEROGLYPH A001} \N{EGYPTIAN HIEROGLYPH M003A}"</span></span><span class="koboSpan" id="kobo.1866.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1867.1">Also, in C++23, it is possible to use code point values with an arbitrary number of hexadecimal digits. </span><span class="koboSpan" id="kobo.1867.2">In the previous example, the string containing Egyptian hieroglyphs contained the codepoint 13000, which has 5 hexadecimal digits. </span><span class="koboSpan" id="kobo.1867.3">However, since the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1868.1">\U</span></code><span class="koboSpan" id="kobo.1869.1"> escape sequence requires 8 hexadecimal digits, we had to include three leading zeros </span><code class="inlineCode"><span class="koboSpan" id="kobo.1870.1">(\U00013000</span></code><span class="koboSpan" id="kobo.1871.1">). </span><span class="koboSpan" id="kobo.1871.2">This is no longer necessary in C++23, but it requires the syntax </span><code class="inlineCode"><span class="koboSpan" id="kobo.1872.1">\u{n…}</span></code><span class="koboSpan" id="kobo.1873.1"> (with lowercase </span><code class="inlineCode"><span class="koboSpan" id="kobo.1874.1">u</span></code><span class="koboSpan" id="kobo.1875.1">), where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1876.1">n…</span></code><span class="koboSpan" id="kobo.1877.1"> is an arbitrary number of hexadecimal digits. </span><span class="koboSpan" id="kobo.1877.2">Therefore, this string can also be written as follows in C++23:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1878.1">std::u32string eh = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1879.1">U"Egyptian hieroglyphs \u{13000} \u{131B2}"</span></span><span class="koboSpan" id="kobo.1880.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1881.1">// </span><span class="koboSpan" id="kobo.1882.1"><img alt="" src="../Images/2nd_GLYPS.png"/></span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1883.1">Printing characters and strings to the console can be done in multiple ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1884.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1885.1">std::cout</span></code><span class="koboSpan" id="kobo.1886.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1887.1">std::wcout</span></code><span class="koboSpan" id="kobo.1888.1"> global objects</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1889.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1890.1">printf</span></code><span class="koboSpan" id="kobo.1891.1"> family of functions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1892.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1893.1">std::print</span></code><span class="koboSpan" id="kobo.1894.1"> family of functions in C++23</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1895.1">Using a third-party text processing library, such as the widely-used </span><strong class="keyWord"><span class="koboSpan" id="kobo.1896.1">fmt</span></strong><span class="koboSpan" id="kobo.1897.1"> library (which was the source for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1898.1">std::format</span></code><span class="koboSpan" id="kobo.1899.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1900.1">std::print</span></code><span class="koboSpan" id="kobo.1901.1"> standard utilities included in C++20 and C++23)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1902.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1903.1">std::cout</span></code><span class="koboSpan" id="kobo.1904.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1905.1">std::wcout</span></code><span class="koboSpan" id="kobo.1906.1"> global objects can be used to print </span><code class="inlineCode"><span class="koboSpan" id="kobo.1907.1">char</span></code><span class="koboSpan" id="kobo.1908.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.1909.1">const char*</span></code><span class="koboSpan" id="kobo.1910.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.1911.1">std::string</span></code><span class="koboSpan" id="kobo.1912.1"> values and, respectively, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1913.1">wchar_t</span></code><span class="koboSpan" id="kobo.1914.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.1915.1">const wchar_t*</span></code><span class="koboSpan" id="kobo.1916.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.1917.1">std::wstring</span></code><span class="koboSpan" id="kobo.1918.1"> values to the standard </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.1919.1">output console. </span><span class="koboSpan" id="kobo.1919.2">Printing ASCII characters does not pose problems but the handling of other character sets and encodings, such as UTF-8, is more problematic, as there is no standard support and different platforms require different solutions. </span><span class="koboSpan" id="kobo.1919.3">You can learn more about this topic in the next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.1920.1">Printing Unicode characters to the output console</span></em><span class="koboSpan" id="kobo.1921.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-105"><span class="koboSpan" id="kobo.1922.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1923.1">Understanding the various numeric types</span></em><span class="koboSpan" id="kobo.1924.1">, to learn about the available integral and floating-point types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1925.1">Formatting and printing text with std::format and std::print</span></em><span class="koboSpan" id="kobo.1926.1">, to learn about how to format and print text using modern utilities</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-106"><span class="koboSpan" id="kobo.1927.1">Printing Unicode characters to the output console</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1928.1">In the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.1929.1">Understanding the various character and string types</span></em><span class="koboSpan" id="kobo.1930.1">, we looked at the various </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.1931.1">data types for storing characters and strings of characters. </span><span class="koboSpan" id="kobo.1931.2">This multitude of types was necessary because there are a multitude of character sets that have been developed over time. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1932.1">The most widely </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.1933.1">used character sets are ASCII and Unicode. </span><span class="koboSpan" id="kobo.1933.2">Although support for the former has been available on all compilers and target platforms since the creation of the language, the support for the latter has evolved at a different pace and in different forms for Windows and Unix/Linux systems. </span><span class="koboSpan" id="kobo.1933.3">In this recipe, we will look at how to print texts in different encodings to the standard output console.</span></p>
<h2 class="heading-2" id="_idParaDest-107"><span class="koboSpan" id="kobo.1934.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1935.1">To write text to the standard output console, you can use the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1936.1">For writing ASCII characters, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1937.1">std::cout</span></code><span class="koboSpan" id="kobo.1938.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1939.1">std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1940.1">"C++\n"</span></span><span class="koboSpan" id="kobo.1941.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1942.1">For writing UTF-8 encoded Unicode characters on Linux, also use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1943.1">std::cout</span></code><span class="koboSpan" id="kobo.1944.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1945.1">std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1946.1">"Erling Håland\n"</span></span><span class="koboSpan" id="kobo.1947.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1948.1">"Thomas Müller\n"</span></span><span class="koboSpan" id="kobo.1949.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1950.1">"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.1951.1">;
std::string monkeys = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1952.1">"</span><span class="koboSpan" id="kobo.1953.1"><img alt="" src="../Images/3rd_GLYPS.png"/></span><span class="koboSpan" id="kobo.1954.1">"</span></span><span class="koboSpan" id="kobo.1955.1">;
std::cout &lt;&lt; monkeys &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1956.1">'\n'</span></span><span class="koboSpan" id="kobo.1957.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1958.1">For UTF-8 strings stored using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1959.1">char8_t</span></code><span class="koboSpan" id="kobo.1960.1"> data type, you can still use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1961.1">std::cout</span></code><span class="koboSpan" id="kobo.1962.1"> but must reinterpret the underlying type as an array of chars:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1963.1">std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1964.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1965.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1966.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1967.1">char</span></span><span class="koboSpan" id="kobo.1968.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1969.1">u8"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.1970.1">);
</span></code></pre></li>
</ul>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1971.1">For writing UTF-8 encoded Unicode characters on a Windows system, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">char8_t</span></code><span class="koboSpan" id="kobo.1973.1"> characters, and respectively, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1974.1">std::u8string</span></code><span class="koboSpan" id="kobo.1975.1"> strings in C++20. </span><span class="koboSpan" id="kobo.1975.2">In prior versions, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1976.1">char</span></code><span class="koboSpan" id="kobo.1977.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1978.1">std::string</span></code><span class="koboSpan" id="kobo.1979.1">. </span><span class="koboSpan" id="kobo.1979.2">Make sure to call the Windows API </span><code class="inlineCode"><span class="koboSpan" id="kobo.1980.1">SetConsoleOutputCP(CP_UTF8)</span></code><span class="koboSpan" id="kobo.1981.1"> before writing to the standard output:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1982.1">SetConsoleOutputCP</span></span><span class="koboSpan" id="kobo.1983.1">(CP_UTF8);
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1984.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1985.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1986.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1987.1">char</span></span><span class="koboSpan" id="kobo.1988.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1989.1">u8"Erling Håland\n"</span></span><span class="koboSpan" id="kobo.1990.1">);
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1991.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1992.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1993.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1994.1">char</span></span><span class="koboSpan" id="kobo.1995.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1996.1">u8"Thomas Müller\n"</span></span><span class="koboSpan" id="kobo.1997.1">);
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1998.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1999.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2000.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2001.1">char</span></span><span class="koboSpan" id="kobo.2002.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2003.1">u8"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.2004.1">);
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2005.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2006.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2007.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2008.1">char</span></span><span class="koboSpan" id="kobo.2009.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2010.1">u8"</span><span class="koboSpan" id="kobo.2011.1"><img alt="" src="../Images/3rd_GLYPS.png"/></span><span class="koboSpan" id="kobo.2012.1">\n"</span></span><span class="koboSpan" id="kobo.2013.1">);
</span></code></pre>
</li>
</ul>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2014.1"><img alt="" src="../Images/B21549_02_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2015.1">Figure 2.3: Output of the previous snippet</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2016.1">For </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.2017.1">writing UTF-16 encoded Unicode </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.2018.1">characters on a Windows system, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2019.1">wchar_t</span></code><span class="koboSpan" id="kobo.2020.1"> characters and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2021.1">std::wstring</span></code><span class="koboSpan" id="kobo.2022.1"> strings. </span><span class="koboSpan" id="kobo.2022.2">Make sure to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.2023.1">_setmode(_fileno(stdout), _O_U16TEXT)</span></code><span class="koboSpan" id="kobo.2024.1"> before writing to the standard output:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2025.1">auto</span></span><span class="koboSpan" id="kobo.2026.1"> mode = _setmode(_fileno(stdout), _O_U16TEXT);
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2027.1">L"Erling Håland\n"</span></span><span class="koboSpan" id="kobo.2028.1">;
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2029.1">L"Thomas Müller\n"</span></span><span class="koboSpan" id="kobo.2030.1">;
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2031.1">L"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.2032.1">;
_setmode(_fileno(stdout), mode);
</span></code></pre>
</li>
</ul>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2033.1"><img alt="" src="../Images/B21549_02_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2034.1">Figure 2.4: Output of the previous snippet</span></p>
<h2 class="heading-2" id="_idParaDest-108"><span class="koboSpan" id="kobo.2035.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2036.1">The</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.2037.1"> ASCII encoding has been the most common character encoding format for half a century. </span><span class="koboSpan" id="kobo.2037.2">It contains 128 characters including the lower</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.2038.1"> and uppercase letters of the English language, the 10 decimal digits, and symbols. </span><span class="koboSpan" id="kobo.2038.2">The first 32 characters of the set are non-printable and</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.2039.1"> are called </span><em class="italic"><span class="koboSpan" id="kobo.2040.1">control characters</span></em><span class="koboSpan" id="kobo.2041.1">. </span><span class="koboSpan" id="kobo.2041.2">The C++ language has full support for the ASCII character set. </span><span class="koboSpan" id="kobo.2041.3">You can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2042.1">std::cout</span></code><span class="koboSpan" id="kobo.2043.1"> to print ASCII characters to the standard output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2044.1">Since the </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.2045.1">ASCII encoding only includes the letters of the English alphabet, various attempts have been made to support other languages and alphabets. </span><span class="koboSpan" id="kobo.2045.2">One approach is the </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.2046.1">concept of </span><em class="italic"><span class="koboSpan" id="kobo.2047.1">code pages</span></em><span class="koboSpan" id="kobo.2048.1">. </span><span class="koboSpan" id="kobo.2048.2">The ASCII encoding requires only 7 bits for encoding the 128 characters. </span><span class="koboSpan" id="kobo.2048.3">Therefore, an additional 128 characters are available to encode using an 8-bit data type. </span><span class="koboSpan" id="kobo.2048.4">That means that the characters in the index 128–255 can be mapped to other languages or alphabets. </span><span class="koboSpan" id="kobo.2048.5">Such a mapping is called a code page. </span><span class="koboSpan" id="kobo.2048.6">There are a variety of code pages, such as IBM code pages, DOS code pages, Windows code pages, and others. </span><span class="koboSpan" id="kobo.2048.7">You can read more about this at </span><a href="https://en.wikipedia.org/wiki/Code_page"><span class="url"><span class="koboSpan" id="kobo.2049.1">https://en.wikipedia.org/wiki/Code_page</span></span></a><span class="koboSpan" id="kobo.2050.1">. </span><span class="koboSpan" id="kobo.2050.2">The following table lists several Windows code pages:</span></p>
<table class="table-container" id="table010">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2051.1">Code page</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2052.1">Name</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2053.1">Languages supported</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2054.1">1250</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2055.1">Windows Central Europe</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2056.1">Czech, Polish, Slovak, Hungarian, Slovene, Serbo-Croatian, Romanian, Albanian</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2057.1">1251</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2058.1">Windows Cyrillic</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2059.1">Russian, Belarusian, Ukrainian, Bulgarian, Macedonian, Serbian</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2060.1">1252</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2061.1">Windows Western</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2062.1">Spanish, Portuguese, French, German, Danish, Norwegian, Swedish, Finnish, Icelandic, Faroese, etc.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2063.1">1253</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2064.1">Windows Greek</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2065.1">Greek</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2066.1">1254</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2067.1">Windows Turkish</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2068.1">Turkish</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2069.1">1255</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2070.1">Windows Hebrew</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2071.1">Hebrew</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2072.1">1256</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2073.1">Windows Arabic</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2074.1">Arabic, Persian, Urdu, English, French</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2075.1">1257</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2076.1">Windows Baltic</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2077.1">Estonian, Latvian, Lithuanian</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2078.1">1258</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2079.1">Windows Vietnamese</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2080.1">Vietnamese</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2081.1">Table 2.10: A listing of a subset of Windows code pages</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2082.1">To understand how this </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.2083.1">works, let’s exemplify with a code snippet. </span><span class="koboSpan" id="kobo.2083.2">The index 224 or 0xE0 (in hexadecimal) is mapped to different characters in different code pages, as shown in the following table:</span></p>
<table class="table-container" id="table011">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2084.1">1250</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2085.1">1251</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2086.1">1252</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2087.1">1253</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2088.1">1254</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2089.1">1255</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2090.1">1256</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2091.1">1257</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2092.1">1258</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2093.1">ŕ</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2094.1">а</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2095.1">à</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2096.1">ΰ</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2097.1">à</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2098.1"><img alt="" src="../Images/1.png"/></span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2099.1">à</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2100.1">ą</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2101.1">à</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2102.1">Table 2.11: The character corresponding to index 224 in the several Windows code pages</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2103.1">In encoding terminology, the numerical value to which a character is mapped is called a </span><em class="italic"><span class="koboSpan" id="kobo.2104.1">code point</span></em><span class="koboSpan" id="kobo.2105.1"> (or </span><em class="italic"><span class="koboSpan" id="kobo.2106.1">codepoint</span></em><span class="koboSpan" id="kobo.2107.1">). </span><span class="koboSpan" id="kobo.2107.2">In our example, 224 is a code point, and </span><em class="italic"><span class="koboSpan" id="kobo.2108.1">a</span></em><span class="koboSpan" id="kobo.2109.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2110.1">à</span></em><span class="koboSpan" id="kobo.2111.1">, or </span><em class="italic"><span class="koboSpan" id="kobo.2112.1">ą</span></em><span class="koboSpan" id="kobo.2113.1"> are specific characters mapped to this code point in different code pages.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2114.1">In Windows, you</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.2115.1"> can activate one code page for </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.2116.1">the console associated with the running process by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2117.1">SetConsoleOutputCP()</span></code><span class="koboSpan" id="kobo.2118.1"> API. </span><span class="koboSpan" id="kobo.2118.2">An example is shown in the following snippet, where we print the character mapped to the 224 code point for all the code pages from 1250 to 1258 (the ones listed earlier):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2119.1">char</span></span><span class="koboSpan" id="kobo.2120.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2121.1">224</span></span><span class="koboSpan" id="kobo.2122.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2123.1">for</span></span><span class="koboSpan" id="kobo.2124.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2125.1">int</span></span><span class="koboSpan" id="kobo.2126.1"> codepage = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2127.1">1250</span></span><span class="koboSpan" id="kobo.2128.1">; codepage &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2129.1">1258</span></span><span class="koboSpan" id="kobo.2130.1">; codepage++)
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2131.1">SetConsoleOutputCP</span></span><span class="koboSpan" id="kobo.2132.1">(codepage);
   std::cout &lt;&lt; c &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2133.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2134.1"> '</span></span><span class="koboSpan" id="kobo.2135.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2136.1">The output from running this program is shown in the next image. </span><span class="koboSpan" id="kobo.2136.2">You can see here that the printed characters are the ones expected according to </span><em class="italic"><span class="koboSpan" id="kobo.2137.1">Table 2.9</span></em><span class="koboSpan" id="kobo.2138.1">.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2139.1"><img alt="" src="../Images/B21549_02_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2140.1">Figure 2.5: Printing of code point 224 with different code pages</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2141.1">Although </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.2142.1">code pages provide a simple approach to switching between different scripts, it is not a solution that can support languages or writing systems that include hundreds or thousands of characters or pictograms, such as Chinese or Egyptian hieroglyphs. </span><span class="koboSpan" id="kobo.2142.2">For this purpose, another standard was developed, called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2143.1">Unicode</span></strong><span class="koboSpan" id="kobo.2144.1">. </span><span class="koboSpan" id="kobo.2144.2">This encoding standard is meant to represent most of the world’s writing scripts, both present and from the past, as well as other symbols, such as emojis, which have become extremely popular for texting in recent times. </span><span class="koboSpan" id="kobo.2144.3">Currently, the Unicode standard defines almost 150,000 characters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2145.1">Unicode characters </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.2146.1">can be stored in several encodings, the most popular being UTF-8 and UTF-16. </span><span class="koboSpan" id="kobo.2146.2">There is also UTF-32 and GB18030; the latter one is not part of the Unicode specification but it’s used in China and fully implements Unicode.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2147.1">UTF-8 is a </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.2148.1">variable-length character encoding standard, compatible with ASCII. </span><span class="koboSpan" id="kobo.2148.2">UTF-8 uses 1, 2, 3, or 4 bytes to encode all the representable code points. </span><span class="koboSpan" id="kobo.2148.3">The more used a code point is, the fewer bytes are used for its encoding. </span><span class="koboSpan" id="kobo.2148.4">The 128 code points of the ASCII encoding are represented by a single byte. </span><span class="koboSpan" id="kobo.2148.5">As a result, UTF-8 is fully “backward” compatible with ASCII. </span><span class="koboSpan" id="kobo.2148.6">All the other Unicode code points are encoded using multiple bytes: code points in the range 128–2047 using 2 bytes, code points in the range 2048–65535 using 3 bytes, and code points in the range 65536–1114111 using 4 bytes. </span><span class="koboSpan" id="kobo.2148.7">The first byte in the encoding is</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.2149.1"> called a </span><em class="italic"><span class="koboSpan" id="kobo.2150.1">lead byte</span></em><span class="koboSpan" id="kobo.2151.1"> and provides information about how many bytes are used to encode the code point. </span><span class="koboSpan" id="kobo.2151.2">Because of this, UTF-8 is a very efficient encoding system and is the preferred choice for the World Wide Web, where virtually almost all web pages use this encoding.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2152.1">UTF-16 is also</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.2153.1"> a variable-length character encoding that can encode all the Unicode code points. </span><span class="koboSpan" id="kobo.2153.2">For this, it uses either one or two 16-bit code units, which makes it incompatible with ASCII. </span><span class="koboSpan" id="kobo.2153.3">UTF-16 is the encoding used by the Windows operating system, as well as by the Java and JavaScript programming languages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2154.1">UTF-32 is a less </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.2155.1">common</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.2156.1"> encoding system. </span><span class="koboSpan" id="kobo.2156.2">It’s a fixed-length encoding that uses 32 bits for each code point. </span><span class="koboSpan" id="kobo.2156.3">Since all the Unicode code points require at most 21 bits, the leading 11 bits are always 0. </span><span class="koboSpan" id="kobo.2156.4">This makes it space-inefficient, which is its main disadvantage. </span><span class="koboSpan" id="kobo.2156.5">Its primary advantage is that it takes constant time to find the Nth code point in a sequence, as opposed to a linear time for variable-length encodings such as UTF-8 and UTF-16.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2157.1">Compilers </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.2158.1">typically assume UTF-8 encoding for source files. </span><span class="koboSpan" id="kobo.2158.2">This is the case for GCC, Clang, and MSVC.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2159.1">Linux distributions have native support for UTF-8. </span><span class="koboSpan" id="kobo.2159.2">This means that writing string literals to the output console such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2160.1">"Στέφανος Τσιτσιπάς"</span></code><span class="koboSpan" id="kobo.2161.1"> will produce the expected result since the terminal supports UTF-8:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2162.1">std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2163.1">"Στέφανος Τσιτσιπάς"</span></span><span class="koboSpan" id="kobo.2164.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2165.1">On the other hand, writing wide strings such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2166.1">L"Στέφανος Τσιτσιπάς"</span></code><span class="koboSpan" id="kobo.2167.1"> does not work out of the box. </span><span class="koboSpan" id="kobo.2167.2">To get the expected result, you need to set up a locale object. </span><span class="koboSpan" id="kobo.2167.3">The default C locale does not know how to convert from wide characters to UTF-8. </span><span class="koboSpan" id="kobo.2167.4">For this to happen, you need to use a locale that is able to do that. </span><span class="koboSpan" id="kobo.2167.5">You have two options:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2168.1">Initialize a locale object to match the environment’s configuration, which should typically be a locale that supports UTF-8:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2169.1">std::locale </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2170.1">utf8</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2171.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2172.1">""</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2173.1">)</span></span><span class="koboSpan" id="kobo.2174.1">;
std::wcout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2175.1">imbue</span></span><span class="koboSpan" id="kobo.2176.1">(utf8);
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2177.1">L"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.2178.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2179.1">Initialize a locale object with a specific locale, such as English (United States):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2180.1">std::locale </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2181.1">utf8</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2182.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2183.1">"en_US.UTF-8"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2184.1">)</span></span><span class="koboSpan" id="kobo.2185.1">;
std::wcout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2186.1">imbue</span></span><span class="koboSpan" id="kobo.2187.1">(utf8);
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2188.1">L"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.2189.1">;
</span></code></pre>
</li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2190.1">Locales are discussed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2191.1">Chapter 7</span></em><span class="koboSpan" id="kobo.2192.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2193.1">Using localized settings for streams</span></em><span class="koboSpan" id="kobo.2194.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2195.1">On a Windows system, things are different. </span><span class="koboSpan" id="kobo.2195.2">The Windows Command Prompt (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2196.1">cmd.exe</span></code><span class="koboSpan" id="kobo.2197.1">) does not have support for UTF-8. </span><span class="koboSpan" id="kobo.2197.2">Although Windows 10 added support for a beta feature called “</span><em class="italic"><span class="koboSpan" id="kobo.2198.1">Use Unicode UTF-8 for worldwide language support</span></em><span class="koboSpan" id="kobo.2199.1">,” this is deeply hidden in the </span><em class="italic"><span class="koboSpan" id="kobo.2200.1">Regional Settings</span></em><span class="koboSpan" id="kobo.2201.1"> and is currently reported to prevent some applications from working correctly. </span><span class="koboSpan" id="kobo.2201.2">To write UTF-8 content to the Command Prompt, you must first set the correct code page by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.2202.1">SetConsoleOutputCP()</span></code><span class="koboSpan" id="kobo.2203.1"> and passing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2204.1">CP_UTF8</span></code><span class="koboSpan" id="kobo.2205.1"> as an argument (or 65001, its numerical value):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2206.1">SetConsoleOutputCP</span></span><span class="koboSpan" id="kobo.2207.1">(CP_UTF8);
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2208.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2209.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2210.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2211.1">char</span></span><span class="koboSpan" id="kobo.2212.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2213.1">u8"Erling Håland\n"</span></span><span class="koboSpan" id="kobo.2214.1">);
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2215.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2216.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2217.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2218.1">char</span></span><span class="koboSpan" id="kobo.2219.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2220.1">u8"Thomas Müller\n"</span></span><span class="koboSpan" id="kobo.2221.1">);
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2222.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2223.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2224.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2225.1">char</span></span><span class="koboSpan" id="kobo.2226.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2227.1">u8"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.2228.1">);
std::u8string monkeys = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2229.1">u8"</span><span class="koboSpan" id="kobo.2230.1"><img alt="" src="../Images/3rd_GLYPS.png"/></span><span class="koboSpan" id="kobo.2231.1">\n"</span></span><span class="koboSpan" id="kobo.2232.1">;
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2233.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2234.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2235.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2236.1">char</span></span><span class="koboSpan" id="kobo.2237.1">*&gt;(monkeys.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2238.1">c_str</span></span><span class="koboSpan" id="kobo.2239.1">());
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2240.1">To </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.2241.1">write UTF-16, you need to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.2242.1">_setmode()</span></code><span class="koboSpan" id="kobo.2243.1"> (from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2244.1">&lt;io.h&gt;</span></code><span class="koboSpan" id="kobo.2245.1">) to set the translation mode for a file (in this case, the standard output console) to UTF-16. </span><span class="koboSpan" id="kobo.2245.2">For this, you have to pass the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2246.1">_O_U16TEXT</span></code><span class="koboSpan" id="kobo.2247.1"> argument. </span><span class="koboSpan" id="kobo.2247.2">The</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.2248.1"> function returns the previous translation mode that you can use to restore the translation mode after writing the desired content. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2249.1">Passing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2250.1">_O_TEXT</span></code><span class="koboSpan" id="kobo.2251.1"> sets the text mode (in which CR-LF combinations are translated into a single LF on input, and LF characters are translated into CR-LF on output):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2252.1">auto</span></span><span class="koboSpan" id="kobo.2253.1"> mode = _setmode(_fileno(stdout), _O_U16TEXT);
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2254.1">L"Erling Håland\n"</span></span><span class="koboSpan" id="kobo.2255.1">;
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2256.1">L"Thomas Müller\n"</span></span><span class="koboSpan" id="kobo.2257.1">;
std::wcout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2258.1">L"Στέφανος Τσιτσιπάς\n"</span></span><span class="koboSpan" id="kobo.2259.1">;
_setmode(_fileno(stdout), mode);
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2260.1">For this to work, however, it is also important that the Command Prompt application uses a True Type font, such as Lucinda Console or Consolas, and not a Raster font that only supports ASCII.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2261.1">Starting with Windows 10, a new terminal application is available for Windows. </span><span class="koboSpan" id="kobo.2261.2">This is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2262.1">Windows Terminal,</span></strong><span class="koboSpan" id="kobo.2263.1"> and</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.2264.1"> it has built-in support for UTF-8. </span><span class="koboSpan" id="kobo.2264.2">This means that the following code prints the expected result without having to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.2265.1">SetConsoleOutputCP()</span></code><span class="koboSpan" id="kobo.2266.1"> first:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2267.1">std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2268.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2269.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2270.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2271.1">char</span></span><span class="koboSpan" id="kobo.2272.1">*&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2273.1">u8"Erling Håland\n"</span></span><span class="koboSpan" id="kobo.2274.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2275.1">Unlike other </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.2276.1">programming languages, support for Unicode has not been a strong point of C++. </span><span class="koboSpan" id="kobo.2276.2">This recipe provides the basics for working with Unicode in console applications. </span><span class="koboSpan" id="kobo.2276.3">However, in practice, matters can get more complex and require additional support. </span><span class="koboSpan" id="kobo.2276.4">To further your</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.2277.1"> understanding of this topic, it is recommended that you consult additional sources, with many being available online.</span></p>
<h2 class="heading-2" id="_idParaDest-109"><span class="koboSpan" id="kobo.2278.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2279.1">Understanding the various character and string types</span></em><span class="koboSpan" id="kobo.2280.1"> to learn about the available character and string types in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2281.1">Formatting and printing text with std::format and std::print</span></em><span class="koboSpan" id="kobo.2282.1"> to learn about how to format and print text using modern utilities</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2283.1">Chapter 7</span></em><span class="koboSpan" id="kobo.2284.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2285.1">Using localized settings for streams</span></em><span class="koboSpan" id="kobo.2286.1">, to learn about locales and how to control the behavior of input/output streams</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-110"><span class="koboSpan" id="kobo.2287.1">Generating pseudo-random numbers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2288.1">Generating random numbers </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.2289.1">is necessary for a large variety of applications, from games to cryptography, from sampling to forecasting. </span><span class="koboSpan" id="kobo.2289.2">However, the</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.2290.1"> term </span><em class="italic"><span class="koboSpan" id="kobo.2291.1">random numbers</span></em><span class="koboSpan" id="kobo.2292.1"> is not actually correct, as the generation of numbers through mathematical formulas is deterministic and does not produce true random numbers, but rather, numbers that look random and are called </span><em class="italic"><span class="koboSpan" id="kobo.2293.1">pseudo-random</span></em><span class="koboSpan" id="kobo.2294.1">. </span><span class="koboSpan" id="kobo.2294.2">True</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.2295.1"> randomness can only be achieved through hardware </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.2296.1">devices, based on physical processes, and even that can be challenged as we may consider even the universe to be actually deterministic. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2297.1">Modern C++ provides support for generating pseudo-random numbers through a pseudo-random number library containing number generators and distributions. </span><span class="koboSpan" id="kobo.2297.2">Theoretically, it can also produce true random numbers but, in practice, those could actually be only pseudo-random.</span></p>
<h2 class="heading-2" id="_idParaDest-111"><span class="koboSpan" id="kobo.2298.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2299.1">In this recipe, we’ll discuss the standard support for generating pseudo-random numbers. </span><span class="koboSpan" id="kobo.2299.2">Understanding the difference between random and pseudo-random numbers is key. </span><span class="koboSpan" id="kobo.2299.3">True random numbers are numbers that cannot be predicted better than by random chance and are produced with the help of hardware-based random number generators. </span><span class="koboSpan" id="kobo.2299.4">Pseudo-random numbers are numbers produced with the help of algorithms that generate sequences with properties that approximate the ones of true random numbers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2300.1">Furthermore, being familiar with various statistical distributions is a plus. </span><span class="koboSpan" id="kobo.2300.2">It is mandatory, though, that you know what a uniform distribution is because all engines in the library produce numbers that are uniformly distributed. </span><span class="koboSpan" id="kobo.2300.3">Without going into any details, we will just mention that uniform distribution is a probability distribution that is concerned with events that are equally likely to occur (within certain bounds).</span></p>
<h2 class="heading-2" id="_idParaDest-112"><span class="koboSpan" id="kobo.2301.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2302.1">To generate </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.2303.1">pseudo-random numbers in your application, you should perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2304.1">Include the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.2305.1">&lt;random&gt;</span></code><span class="koboSpan" id="kobo.2306.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.2307.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2308.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2309.1">&lt;random&gt;</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2310.1">Use an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2311.1">std::random_device</span></code><span class="koboSpan" id="kobo.2312.1"> generator to seed a pseudo-random engine:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2313.1">std::random_device rd{};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2314.1">Use one of the available engines to generate numbers and initialize it with a random seed:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2315.1">auto</span></span><span class="koboSpan" id="kobo.2316.1"> mtgen = std::mt19937{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2317.1">rd</span></span><span class="koboSpan" id="kobo.2318.1">() };
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2319.1">Use one of the available distributions to convert the output of the engine to one of the desired statistical distributions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2320.1">auto</span></span><span class="koboSpan" id="kobo.2321.1"> ud = std::uniform_int_distribution&lt;&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2322.1">1</span></span><span class="koboSpan" id="kobo.2323.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2324.1">6</span></span><span class="koboSpan" id="kobo.2325.1"> };
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2326.1">Generate the pseudo-random numbers:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2327.1">for</span></span><span class="koboSpan" id="kobo.2328.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2329.1">auto</span></span><span class="koboSpan" id="kobo.2330.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2331.1">0</span></span><span class="koboSpan" id="kobo.2332.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2333.1">20</span></span><span class="koboSpan" id="kobo.2334.1">; ++i)
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2335.1">auto</span></span><span class="koboSpan" id="kobo.2336.1"> number = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2337.1">ud</span></span><span class="koboSpan" id="kobo.2338.1">(mtgen);
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-113"><span class="koboSpan" id="kobo.2339.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2340.1">The pseudo-random number</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.2341.1"> library contains two types of components:</span></p>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2342.1">Engines</span></em><span class="koboSpan" id="kobo.2343.1">, which are generators of random numbers; these can produce either pseudo-random numbers with a uniform distribution or, if available, actual random numbers.</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2344.1">Distributions</span></em><span class="koboSpan" id="kobo.2345.1"> that convert the output of an engine to a statistical distribution.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2346.1">All engines (except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2347.1">random_device</span></code><span class="koboSpan" id="kobo.2348.1">) produce integer numbers in a uniform distribution, and all engines implement the following methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2349.1">min()</span></code><span class="koboSpan" id="kobo.2350.1">: This is a static method that returns the minimum value that can be produced by the generator.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2351.1">max()</span></code><span class="koboSpan" id="kobo.2352.1">: This is a static method that returns the maximum value that can be produced by the generator.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2353.1">seed()</span></code><span class="koboSpan" id="kobo.2354.1">: This initializes the algorithm with a start value (except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2355.1">random_device</span></code><span class="koboSpan" id="kobo.2356.1">, which cannot be seeded).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2357.1">operator()</span></code><span class="koboSpan" id="kobo.2358.1">: This generates a new number uniformly distributed between </span><code class="inlineCode"><span class="koboSpan" id="kobo.2359.1">min()</span></code><span class="koboSpan" id="kobo.2360.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2361.1">max()</span></code><span class="koboSpan" id="kobo.2362.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2363.1">discard()</span></code><span class="koboSpan" id="kobo.2364.1">: This generates and discards a given number of pseudo-random numbers.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2365.1">The following engines are available:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2366.1">linear_congruential_engine</span></code><span class="koboSpan" id="kobo.2367.1">: This is a linear congruential generator that produces numbers using the following formula:
    </span><p class="normal"><em class="italic"><span class="koboSpan" id="kobo.2368.1">x</span></em><span class="koboSpan" id="kobo.2369.1">(</span><em class="italic"><span class="koboSpan" id="kobo.2370.1">i</span></em><span class="koboSpan" id="kobo.2371.1">) = (</span><em class="italic"><span class="koboSpan" id="kobo.2372.1">A</span></em><span class="koboSpan" id="kobo.2373.1"> * </span><em class="italic"><span class="koboSpan" id="kobo.2374.1">x</span></em><span class="koboSpan" id="kobo.2375.1">(i – </span><em class="italic"><span class="koboSpan" id="kobo.2376.1">1</span></em><span class="koboSpan" id="kobo.2377.1">) + </span><em class="italic"><span class="koboSpan" id="kobo.2378.1">C</span></em><span class="koboSpan" id="kobo.2379.1">) mod </span><em class="italic"><span class="koboSpan" id="kobo.2380.1">M</span></em></p></li>
</ul>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2381.1">mersenne_twister_engine</span></code><span class="koboSpan" id="kobo.2382.1">: This is a Mersenne Twister generator that keeps a value on </span><em class="italic"><span class="koboSpan" id="kobo.2383.1">W</span></em><span class="koboSpan" id="kobo.2384.1"> * (</span><em class="italic"><span class="koboSpan" id="kobo.2385.1">N</span></em><span class="koboSpan" id="kobo.2386.1"> – 1) * </span><em class="italic"><span class="koboSpan" id="kobo.2387.1">R</span></em><span class="koboSpan" id="kobo.2388.1"> bits. </span><span class="koboSpan" id="kobo.2388.2">Each time a number needs to be generated, it extracts </span><em class="italic"><span class="koboSpan" id="kobo.2389.1">W</span></em><span class="koboSpan" id="kobo.2390.1"> bits. </span><span class="koboSpan" id="kobo.2390.2">When all the bits have been used, it twists the large value by shifting and mixing the bits so that it has a new set of bits to extract from.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2391.1">subtract_with_carry_engine</span></code><span class="koboSpan" id="kobo.2392.1">: This is a generator that implements a </span><em class="italic"><span class="koboSpan" id="kobo.2393.1">subtract with carry</span></em><span class="koboSpan" id="kobo.2394.1"> algorithm based on the following formula:
    </span><p class="normal"><em class="italic"><span class="koboSpan" id="kobo.2395.1">x</span></em><span class="koboSpan" id="kobo.2396.1">(</span><em class="italic"><span class="koboSpan" id="kobo.2397.1">i</span></em><span class="koboSpan" id="kobo.2398.1">) = (</span><em class="italic"><span class="koboSpan" id="kobo.2399.1">x</span></em><span class="koboSpan" id="kobo.2400.1">(</span><em class="italic"><span class="koboSpan" id="kobo.2401.1">i</span></em><span class="koboSpan" id="kobo.2402.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.2403.1">R</span></em><span class="koboSpan" id="kobo.2404.1">) – </span><em class="italic"><span class="koboSpan" id="kobo.2405.1">x</span></em><span class="koboSpan" id="kobo.2406.1">(</span><em class="italic"><span class="koboSpan" id="kobo.2407.1">i</span></em><span class="koboSpan" id="kobo.2408.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.2409.1">S</span></em><span class="koboSpan" id="kobo.2410.1">) – </span><em class="italic"><span class="koboSpan" id="kobo.2411.1">cy</span></em><span class="koboSpan" id="kobo.2412.1">(</span><em class="italic"><span class="koboSpan" id="kobo.2413.1">i</span></em><span class="koboSpan" id="kobo.2414.1"> – 1)) mod </span><em class="italic"><span class="koboSpan" id="kobo.2415.1">M</span></em></p>
<p class="normal"><span class="koboSpan" id="kobo.2416.1">In the preceding formula, </span><em class="italic"><span class="koboSpan" id="kobo.2417.1">cy</span></em><span class="koboSpan" id="kobo.2418.1"> is defined as:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2419.1"><img alt="" src="../Images/B21549_02_001.png"/></span></figure></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2420.1">In addition, the</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.2421.1"> library provides engine adapters that are also engines wrapping another engine and producing numbers based on the output of the base engine. </span><span class="koboSpan" id="kobo.2421.2">Engine adapters implement the same methods mentioned earlier for the base engines. </span><span class="koboSpan" id="kobo.2421.3">The following engine adapters are available:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2422.1">discard_block_engine</span></code><span class="koboSpan" id="kobo.2423.1">: A generator that, from every block of </span><em class="italic"><span class="koboSpan" id="kobo.2424.1">P</span></em><span class="koboSpan" id="kobo.2425.1"> numbers generated by the base engine, keeps only </span><em class="italic"><span class="koboSpan" id="kobo.2426.1">R</span></em><span class="koboSpan" id="kobo.2427.1"> numbers, discarding the rest.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2428.1">independent_bits_engine</span></code><span class="koboSpan" id="kobo.2429.1">: A generator that produces numbers with a different number of bits than the base engine.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2430.1">shuffle_order_engine</span></code><span class="koboSpan" id="kobo.2431.1">: A generator that keeps a shuffled table of </span><em class="italic"><span class="koboSpan" id="kobo.2432.1">K</span></em><span class="koboSpan" id="kobo.2433.1"> numbers produced by the base engine and returns numbers from this table, replacing them with numbers generated by the base engine.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2434.1">Choosing a pseudo-random number generator should be done based on the specific requirements of your application. </span><span class="koboSpan" id="kobo.2434.2">The linear congruential engine is medium-fast but has very small storage requirements for its internal state. </span><span class="koboSpan" id="kobo.2434.3">The subtract with carry engine is very fast, including on machines that don’t have a processor with advanced arithmetic instruction sets. </span><span class="koboSpan" id="kobo.2434.4">However, it requires larger storage for its internal state and the sequence of generated numbers has fewer desirable characteristics. </span><span class="koboSpan" id="kobo.2434.5">The Mersenne Twister is the slowest of these engines and has the greatest storage durations but produces the longest non-repeating sequences of pseudo-numbers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2435.1">All these engines and engine adaptors produce pseudo-random numbers. </span><span class="koboSpan" id="kobo.2435.2">The library, however, provides another engine called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2436.1">random_device</span></code><span class="koboSpan" id="kobo.2437.1"> that is supposed to produce non-deterministic numbers, but this is not an actual constraint as physical sources of random entropy might not be available. </span><span class="koboSpan" id="kobo.2437.2">Therefore, implementations of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2438.1">random_device</span></code><span class="koboSpan" id="kobo.2439.1"> could actually be based on a pseudo-random engine. </span><span class="koboSpan" id="kobo.2439.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2440.1">random_device</span></code><span class="koboSpan" id="kobo.2441.1"> class cannot be seeded like the other engines and has an additional method called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2442.1">entropy()</span></code><span class="koboSpan" id="kobo.2443.1"> that returns the random device entropy, which is 0 for a deterministic generator and nonzero for a non-deterministic generator.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2444.1">However, this is not a reliable method for determining whether the device is actually deterministic or non-deterministic. </span><span class="koboSpan" id="kobo.2444.2">For instance, both GNU </span><code class="inlineCode"><span class="koboSpan" id="kobo.2445.1">libstdc++</span></code><span class="koboSpan" id="kobo.2446.1"> and LLVM </span><code class="inlineCode"><span class="koboSpan" id="kobo.2447.1">libc++</span></code><span class="koboSpan" id="kobo.2448.1"> implement a non-deterministic device but return </span><code class="inlineCode"><span class="koboSpan" id="kobo.2449.1">0</span></code><span class="koboSpan" id="kobo.2450.1"> for entropy. </span><span class="koboSpan" id="kobo.2450.2">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2451.1">VC++</span></code><span class="koboSpan" id="kobo.2452.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2453.1">boost.random</span></code><span class="koboSpan" id="kobo.2454.1"> return </span><code class="inlineCode"><span class="koboSpan" id="kobo.2455.1">32</span></code><span class="koboSpan" id="kobo.2456.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2457.1">10</span></code><span class="koboSpan" id="kobo.2458.1">, respectively, for entropy.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2459.1">All these</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.2460.1"> generators produce integers in a uniform distribution. </span><span class="koboSpan" id="kobo.2460.2">This is, however, only one of the many possible statistical distributions where random numbers are needed in most applications. </span><span class="koboSpan" id="kobo.2460.3">To be able to produce numbers (either integer or real) in other distributions, the library provides several classes called </span><em class="italic"><span class="koboSpan" id="kobo.2461.1">distributions</span></em><span class="koboSpan" id="kobo.2462.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2463.1">These convert the output of an engine according to the statistical distribution it implements. </span><span class="koboSpan" id="kobo.2463.2">The following distributions are available:</span></p>
<table class="table-container" id="table012">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2464.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2465.1">Class name</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2466.1">Numbers</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2467.1">Statistical distribution</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal"><span class="koboSpan" id="kobo.2468.1">Uniform</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2469.1">uniform_int_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2470.1">Integer</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2471.1">Uniform</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2472.1">uniform_real_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2473.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2474.1">Uniform</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="4">
<p class="normal"><span class="koboSpan" id="kobo.2475.1">Bernoulli</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2476.1">bernoulli_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2477.1">Boolean</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2478.1">Bernoulli</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2479.1">binomial_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2480.1">Integer</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2481.1">Binomial</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2482.1">negative_binomial_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2483.1">Integer</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2484.1">Negative binomial</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2485.1">geometric_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2486.1">Integer</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2487.1">Geometric</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="5">
<p class="normal"><span class="koboSpan" id="kobo.2488.1">Poisson</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2489.1">poisson_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2490.1">Integer</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2491.1">Poisson</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2492.1">exponential_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2493.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2494.1">Exponential</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2495.1">gamma_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2496.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2497.1">Gamma</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2498.1">weibull_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2499.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2500.1">Weibull</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2501.1">extreme_value_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2502.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2503.1">Extreme value</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="6">
<p class="normal"><span class="koboSpan" id="kobo.2504.1">Normal</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2505.1">normal_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2506.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2507.1">Standard normal (Gaussian)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2508.1">lognormal_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2509.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2510.1">Lognormal</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2511.1">chi_squared_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2512.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2513.1">Chi-squared</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2514.1">cauchy_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2515.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2516.1">Cauchy</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2517.1">fisher_f_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2518.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2519.1">Fisher’s F-distribution</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2520.1">student_t_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2521.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2522.1">Student’s t-distribution</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="3">
<p class="normal"><span class="koboSpan" id="kobo.2523.1">Sampling</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2524.1">discrete_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2525.1">Integer</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2526.1">Discrete</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2527.1">piecewise_constant_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2528.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2529.1">Values distributed on constant subintervals</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2530.1">piecewise_linear_distribution</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2531.1">Real</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2532.1">Values distributed on defined subintervals</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2533.1">Table 2.12: The list of standard distributions from the &lt;random&gt; header</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2534.1">Each of the </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.2535.1">engines provided by the library has advantages and disadvantages, as mentioned earlier. </span><span class="koboSpan" id="kobo.2535.2">When initialized appropriately, the Mersenne Twister, although the slowest and one that has the largest internal state, can produce the longest non-repeating sequence of numbers. </span><span class="koboSpan" id="kobo.2535.3">In the following examples, we will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2536.1">std::mt19937</span></code><span class="koboSpan" id="kobo.2537.1">, a 32-bit Mersenne Twister with 19,937 bits of internal state. </span><span class="koboSpan" id="kobo.2537.2">There is also a 64-bit Mersenne Twister, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2538.1">std::mt19937_64</span></code><span class="koboSpan" id="kobo.2539.1">. </span><span class="koboSpan" id="kobo.2539.2">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2540.1">std::mt19937</span></code><span class="koboSpan" id="kobo.2541.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2542.1">std::mt19937_64</span></code><span class="koboSpan" id="kobo.2543.1"> are aliases for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2544.1">std::mersenne_twister_engine</span></code><span class="koboSpan" id="kobo.2545.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2546.1">The simplest way to generate random numbers looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2547.1">auto</span></span><span class="koboSpan" id="kobo.2548.1"> mtgen = std::mt19937 {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2549.1">for</span></span><span class="koboSpan" id="kobo.2550.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2551.1">auto</span></span><span class="koboSpan" id="kobo.2552.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2553.1">0</span></span><span class="koboSpan" id="kobo.2554.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2555.1">10</span></span><span class="koboSpan" id="kobo.2556.1">; ++i)
  std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2557.1">mtgen</span></span><span class="koboSpan" id="kobo.2558.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2559.1">'\n'</span></span><span class="koboSpan" id="kobo.2560.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2561.1">In this </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.2562.1">example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2563.1">mtgen</span></code><span class="koboSpan" id="kobo.2564.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2565.1">std::mt19937</span></code><span class="koboSpan" id="kobo.2566.1"> for the Mersenne Twister. </span><span class="koboSpan" id="kobo.2566.2">To generate numbers, you only need to use the call operator that advances the internal state and returns the next pseudo-random number. </span><span class="koboSpan" id="kobo.2566.3">However, this code is flawed, as the engine is not seeded. </span><span class="koboSpan" id="kobo.2566.4">As a result, it always produces the same sequence of numbers, which is probably not what you want in most cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2567.1">There are different approaches to initializing the engine. </span><span class="koboSpan" id="kobo.2567.2">One approach, common with the C </span><code class="inlineCode"><span class="koboSpan" id="kobo.2568.1">random</span></code><span class="koboSpan" id="kobo.2569.1"> library, is to use the current time. </span><span class="koboSpan" id="kobo.2569.2">In modern C++, it should look like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2570.1">auto</span></span><span class="koboSpan" id="kobo.2571.1"> seed = std::chrono::high_resolution_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2572.1">now</span></span><span class="koboSpan" id="kobo.2573.1">()
            .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2574.1">time_since_epoch</span></span><span class="koboSpan" id="kobo.2575.1">()
            .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2576.1">count</span></span><span class="koboSpan" id="kobo.2577.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2578.1">auto</span></span><span class="koboSpan" id="kobo.2579.1"> mtgen = std::mt19937{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2580.1">static_cast</span></span><span class="koboSpan" id="kobo.2581.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2582.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2583.1">int</span></span><span class="koboSpan" id="kobo.2584.1">&gt;(seed) };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2585.1">In this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2586.1">seed</span></code><span class="koboSpan" id="kobo.2587.1"> is a number representing the number of ticks from the clock’s epoch until the present moment. </span><span class="koboSpan" id="kobo.2587.2">This number is then used to seed the engine. </span><span class="koboSpan" id="kobo.2587.3">The problem with this approach is that the value of that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2588.1">seed</span></code><span class="koboSpan" id="kobo.2589.1"> is actually deterministic, and in some classes of applications, it could be prone to attacks. </span><span class="koboSpan" id="kobo.2589.2">A more reliable approach is to seed the generator with actual random numbers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2590.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2591.1">std::random_device</span></code><span class="koboSpan" id="kobo.2592.1"> class is an engine that is supposed to return true random numbers, though implementations could actually be based on a pseudo-random generator:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2593.1">std::random_device rd;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2594.1">auto</span></span><span class="koboSpan" id="kobo.2595.1"> mtgen = std::mt19937 {</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2596.1">rd</span></span><span class="koboSpan" id="kobo.2597.1">()};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2598.1">Numbers produced by all engines follow a uniform distribution. </span><span class="koboSpan" id="kobo.2598.2">To convert the result to another statistical distribution, we have to use a distribution class. </span><span class="koboSpan" id="kobo.2598.3">To show how generated numbers are distributed according to the selected distribution, we will use the following function. </span><span class="koboSpan" id="kobo.2598.4">This function generates a specified number of pseudo-random numbers and counts their repetition in a map. </span><span class="koboSpan" id="kobo.2598.5">The values from the map are then used to produce a bar-like diagram showing how often each number occurred:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2599.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2600.1">generate_and_print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2601.1">(std::function&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2602.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2603.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2604.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2605.1">)&gt; gen,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2606.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2607.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2608.1"> iterations = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.2609.1">10000</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2610.1">)</span></span><span class="koboSpan" id="kobo.2611.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2612.1">// map to store the numbers and their repetition</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2613.1">auto</span></span><span class="koboSpan" id="kobo.2614.1"> data = std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2615.1">int</span></span><span class="koboSpan" id="kobo.2616.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2617.1">int</span></span><span class="koboSpan" id="kobo.2618.1">&gt;{};
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2619.1">// generate random numbers</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2620.1">for</span></span><span class="koboSpan" id="kobo.2621.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2622.1">auto</span></span><span class="koboSpan" id="kobo.2623.1"> n = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2624.1">0</span></span><span class="koboSpan" id="kobo.2625.1">; n &lt; iterations; ++n)
    ++data[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2626.1">gen</span></span><span class="koboSpan" id="kobo.2627.1">()];
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2628.1">// find the element with the most repetitions</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2629.1">auto</span></span><span class="koboSpan" id="kobo.2630.1"> max = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2631.1">max_element</span></span><span class="koboSpan" id="kobo.2632.1">(
             std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2633.1">begin</span></span><span class="koboSpan" id="kobo.2634.1">(data), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2635.1">end</span></span><span class="koboSpan" id="kobo.2636.1">(data),
             [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2637.1">auto</span></span><span class="koboSpan" id="kobo.2638.1"> kvp1, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2639.1">auto</span></span><span class="koboSpan" id="kobo.2640.1"> kvp2) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2641.1">return</span></span><span class="koboSpan" id="kobo.2642.1"> kvp1.second &lt; kvp2.second; });
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2643.1">// print the bars</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2644.1">for</span></span><span class="koboSpan" id="kobo.2645.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2646.1">auto</span></span><span class="koboSpan" id="kobo.2647.1"> i = max-&gt;second / </span><span class="hljs-number"><span class="koboSpan" id="kobo.2648.1">200</span></span><span class="koboSpan" id="kobo.2649.1">; i &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2650.1">0</span></span><span class="koboSpan" id="kobo.2651.1">; --i)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2652.1">for</span></span><span class="koboSpan" id="kobo.2653.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2654.1">auto</span></span><span class="koboSpan" id="kobo.2655.1"> kvp : data)
    {
      std::cout
        &lt;&lt; std::fixed &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2656.1">setprecision</span></span><span class="koboSpan" id="kobo.2657.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2658.1">1</span></span><span class="koboSpan" id="kobo.2659.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2660.1">setw</span></span><span class="koboSpan" id="kobo.2661.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2662.1">3</span></span><span class="koboSpan" id="kobo.2663.1">)
        &lt;&lt; (kvp.second / </span><span class="hljs-number"><span class="koboSpan" id="kobo.2664.1">200</span></span><span class="koboSpan" id="kobo.2665.1"> &gt;= i ? </span><span class="koboSpan" id="kobo.2665.2">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2666.1">char</span></span><span class="koboSpan" id="kobo.2667.1">)</span><span class="hljs-number"><span class="koboSpan" id="kobo.2668.1">219</span></span><span class="koboSpan" id="kobo.2669.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.2670.1">' '</span></span><span class="koboSpan" id="kobo.2671.1">);
    }
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2672.1">'\n'</span></span><span class="koboSpan" id="kobo.2673.1">;
  }
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2674.1">// print the numbers</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2675.1">for</span></span><span class="koboSpan" id="kobo.2676.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2677.1">auto</span></span><span class="koboSpan" id="kobo.2678.1"> kvp : data)
  {
    std::cout
      &lt;&lt; std::fixed &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2679.1">setprecision</span></span><span class="koboSpan" id="kobo.2680.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2681.1">1</span></span><span class="koboSpan" id="kobo.2682.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2683.1">setw</span></span><span class="koboSpan" id="kobo.2684.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2685.1">3</span></span><span class="koboSpan" id="kobo.2686.1">)
      &lt;&lt; kvp.first;
  }
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2687.1">'\n'</span></span><span class="koboSpan" id="kobo.2688.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2689.1">The </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.2690.1">following code generates random numbers using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2691.1">std::mt19937</span></code><span class="koboSpan" id="kobo.2692.1"> engine with a uniform distribution in the range </span><code class="inlineCode"><span class="koboSpan" id="kobo.2693.1">[1, 6]</span></code><span class="koboSpan" id="kobo.2694.1">; this is basically what you get when you throw a die:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2695.1">std::random_device rd{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2696.1">auto</span></span><span class="koboSpan" id="kobo.2697.1"> mtgen = std::mt19937{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2698.1">rd</span></span><span class="koboSpan" id="kobo.2699.1">() };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2700.1">auto</span></span><span class="koboSpan" id="kobo.2701.1"> ud = std::uniform_int_distribution&lt;&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2702.1">1</span></span><span class="koboSpan" id="kobo.2703.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2704.1">6</span></span><span class="koboSpan" id="kobo.2705.1"> };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2706.1">generate_and_print</span></span><span class="koboSpan" id="kobo.2707.1">([&amp;mtgen, &amp;ud]() {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2708.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2709.1">ud</span></span><span class="koboSpan" id="kobo.2710.1">(mtgen); });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2711.1">The output of the program looks like this:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2712.1"><img alt="A screenshot of a computer screen  Description automatically generated" src="../Images/B21549_02_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2713.1">Figure 2.6: Uniform distribution of the range [1,6]</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2714.1">In the next </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.2715.1">and final example, we’re changing the distribution to a normal distribution with a mean of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2716.1">5</span></code><span class="koboSpan" id="kobo.2717.1"> and a standard deviation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2718.1">2</span></code><span class="koboSpan" id="kobo.2719.1">. </span><span class="koboSpan" id="kobo.2719.2">This distribution produces real numbers; therefore, in order to use the previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.2720.1">generate_and_print()</span></code><span class="koboSpan" id="kobo.2721.1"> function, the numbers must be rounded to integers:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2722.1">std::random_device rd{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2723.1">auto</span></span><span class="koboSpan" id="kobo.2724.1"> mtgen = std::mt19937{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2725.1">rd</span></span><span class="koboSpan" id="kobo.2726.1">() };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2727.1">auto</span></span><span class="koboSpan" id="kobo.2728.1"> nd = std::normal_distribution&lt;&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2729.1">5</span></span><span class="koboSpan" id="kobo.2730.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2731.1">2</span></span><span class="koboSpan" id="kobo.2732.1"> };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2733.1">generate_and_print</span></span><span class="koboSpan" id="kobo.2734.1">(
  [&amp;mtgen, &amp;nd]() {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2735.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2736.1">static_cast</span></span><span class="koboSpan" id="kobo.2737.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2738.1">int</span></span><span class="koboSpan" id="kobo.2739.1">&gt;(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2740.1">round</span></span><span class="koboSpan" id="kobo.2741.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2742.1">nd</span></span><span class="koboSpan" id="kobo.2743.1">(mtgen))); });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2744.1">The following will be the output of the preceding code:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2745.1"><img alt="" src="../Images/B21549_02_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2746.1">Figure 2.7: Normal distribution with mean 5 and standard variance 2</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2747.1">Here, we can</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.2748.1"> see that, based on the graphical representation, the distribution has changed from a uniform one to a normal one with the mean at value 5.</span></p>
<h2 class="heading-2" id="_idParaDest-114"><span class="koboSpan" id="kobo.2749.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2750.1">Properly initializing a pseudo-random number generator</span></em><span class="koboSpan" id="kobo.2751.1">, to learn how to properly initialize random number engines</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-115"><span class="koboSpan" id="kobo.2752.1">Properly initializing a pseudo-random number generator</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2753.1">In the</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.2754.1"> previous recipe, we looked at the pseudo-random number library, along with its components, and how it can be used to produce numbers in different statistical distributions. </span><span class="koboSpan" id="kobo.2754.2">One important factor that was overlooked in that recipe is the proper initialization of the pseudo-random number generators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2755.1">With careful analysis (which is beyond the purpose of this recipe or this book), it can be shown that the Mersenne Twister engine has a bias toward producing some values repeatedly and omitting others, thus generating numbers not in a uniform distribution, but rather in a binomial or Poisson distribution. </span><span class="koboSpan" id="kobo.2755.2">In this recipe, you will learn how to initialize a generator in order to produce pseudo-random numbers with a true uniform distribution.</span></p>
<h2 class="heading-2" id="_idParaDest-116"><span class="koboSpan" id="kobo.2756.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2757.1">You should read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.2758.1">Generating pseudo-random numbers</span></em><span class="koboSpan" id="kobo.2759.1">, to get an overview of what the pseudo-random number library offers.</span></p>
<h2 class="heading-2" id="_idParaDest-117"><span class="koboSpan" id="kobo.2760.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2761.1">To properly </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.2762.1">initialize a pseudo-random number generator to produce a uniformly distributed sequence of pseudo-random numbers, perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2763.1">Use an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2764.1">std::random_device</span></code><span class="koboSpan" id="kobo.2765.1"> to produce random numbers to be used as seeding values:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2766.1">std::random_device rd;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2767.1">Generate random data for all internal bits of the engine:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2768.1">std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2769.1">int</span></span><span class="koboSpan" id="kobo.2770.1">, std::mt19937::state_size&gt; seed_data {};
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2771.1">generate</span></span><span class="koboSpan" id="kobo.2772.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2773.1">begin</span></span><span class="koboSpan" id="kobo.2774.1">(seed_data), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2775.1">end</span></span><span class="koboSpan" id="kobo.2776.1">(seed_data),
              std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2777.1">ref</span></span><span class="koboSpan" id="kobo.2778.1">(rd));
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2779.1">Create an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2780.1">std::seed_seq</span></code><span class="koboSpan" id="kobo.2781.1"> object from the previously generated pseudo-random data:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2782.1">std::seed_seq </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2783.1">seq</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2784.1">(std::begin(seed_data), std::end(seed_data))</span></span><span class="koboSpan" id="kobo.2785.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2786.1">Create an engine object and initialize all the bits representing the internal state of the engine; for example, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2787.1">mt19937</span></code><span class="koboSpan" id="kobo.2788.1"> has 19,937 bits of internal state:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2789.1">auto</span></span><span class="koboSpan" id="kobo.2790.1"> eng = std::mt19937{ seq };
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2791.1">Use the appropriate distribution based on the requirements of the application:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2792.1">auto</span></span><span class="koboSpan" id="kobo.2793.1"> dist = std::uniform_real_distribution&lt;&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2794.1">0</span></span><span class="koboSpan" id="kobo.2795.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2796.1">1</span></span><span class="koboSpan" id="kobo.2797.1"> };
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-118"><span class="koboSpan" id="kobo.2798.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2799.1">In all the examples shown in the previous recipe, we used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2800.1">std::mt19937</span></code><span class="koboSpan" id="kobo.2801.1"> engine to produce pseudo-random numbers. </span><span class="koboSpan" id="kobo.2801.2">Though the Mersenne Twister is slower than the other engines, it can produce the longest sequences of non-repeating numbers with the best spectral characteristics. </span><span class="koboSpan" id="kobo.2801.3">However, initializing the engine in the manner shown in the previous recipe will not have this effect. </span><span class="koboSpan" id="kobo.2801.4">The problem is that the internal state of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2802.1">mt19937</span></code><span class="koboSpan" id="kobo.2803.1"> has 624 32-bit integers, and in the examples from the previous recipe, we have only initialized one of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2804.1">When</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.2805.1"> working with the pseudo-random number library, remember the following rule of thumb (shown in the information box).</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2806.1">In order to produce the best results, engines must have their entire internal state properly initialized before generating numbers.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2807.1">The pseudo-random number library provides a class for this particular purpose, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2808.1">std::seed_seq</span></code><span class="koboSpan" id="kobo.2809.1">. </span><span class="koboSpan" id="kobo.2809.2">This is a generator that can be seeded with any number of 32-bit integers and produces the requested number of integers evenly distributed in the 32-bit space.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2810.1">In the preceding code from the </span><em class="italic"><span class="koboSpan" id="kobo.2811.1">How to do it...</span></em><span class="koboSpan" id="kobo.2812.1"> section, we defined an array called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2813.1">seed_data</span></code><span class="koboSpan" id="kobo.2814.1"> with a number of 32-bit integers equal to the internal state of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2815.1">mt19937</span></code><span class="koboSpan" id="kobo.2816.1"> generator – that is, 624 integers. </span><span class="koboSpan" id="kobo.2816.2">Then, we initialized the array with random numbers produced by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2817.1">std::random_device</span></code><span class="koboSpan" id="kobo.2818.1">. </span><span class="koboSpan" id="kobo.2818.2">The array was later used to seed </span><code class="inlineCode"><span class="koboSpan" id="kobo.2819.1">std::seed_seq</span></code><span class="koboSpan" id="kobo.2820.1">, which, in turn, was used to seed the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2821.1">mt19937</span></code><span class="koboSpan" id="kobo.2822.1"> generator.</span></p>
<h2 class="heading-2" id="_idParaDest-119"><span class="koboSpan" id="kobo.2823.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2824.1">Generating pseudo-random numbers</span></em><span class="koboSpan" id="kobo.2825.1">, to familiarize yourself with the capabilities of the standard numeric library for generating pseudo-random numbers</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-120"><span class="koboSpan" id="kobo.2826.1">Creating cooked user-defined literals</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2827.1">Literals are</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.2828.1"> constants of built-in types (numerical, Boolean, character, character string, and pointer) that cannot </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.2829.1">be altered in a program. </span><span class="koboSpan" id="kobo.2829.2">The language defines a series of prefixes and suffixes to specify literals (and the prefix/suffix is actually part of the literal). </span><span class="koboSpan" id="kobo.2829.3">C++11 allows us to create user-defined literals by defining functions called </span><em class="italic"><span class="koboSpan" id="kobo.2830.1">literal operators</span></em><span class="koboSpan" id="kobo.2831.1">, which introduce suffixes for specifying literals. </span><span class="koboSpan" id="kobo.2831.2">These work only with numerical character and character string types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2832.1">This opens the possibility of defining both standard literals in future versions and allows developers to create their own literals. </span><span class="koboSpan" id="kobo.2832.2">In this recipe, we will learn how to create our own cooked literals.</span></p>
<h2 class="heading-2" id="_idParaDest-121"><span class="koboSpan" id="kobo.2833.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2834.1">User-defined literals</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.2835.1"> can have two forms: </span><em class="italic"><span class="koboSpan" id="kobo.2836.1">raw</span></em><span class="koboSpan" id="kobo.2837.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.2838.1">cooked</span></em><span class="koboSpan" id="kobo.2839.1">. </span><span class="koboSpan" id="kobo.2839.2">Raw literals </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.2840.1">are not processed by the compiler, whereas</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.2841.1"> cooked literals are values processed by the compiler (examples include </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.2842.1">handling escape sequences in a character string or identifying numerical values such as integer 2898 from literal 0xBAD). </span><span class="koboSpan" id="kobo.2842.2">Raw literals are only available for integral and floating-point types, whereas cooked literals are also available for character and character string literals.</span></p>
<h2 class="heading-2" id="_idParaDest-122"><span class="koboSpan" id="kobo.2843.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2844.1">To create cooked user-defined literals, you should follow these steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2845.1">Define your literals in a separate namespace to avoid name clashes.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2846.1">Always prefix the user-defined suffix with an underscore (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2847.1">_</span></code><span class="koboSpan" id="kobo.2848.1">).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2849.1">Define a literal operator of one of the following forms for cooked literals (the forms using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2850.1">char8_t</span></code><span class="koboSpan" id="kobo.2851.1"> are only available since C++20). </span><span class="koboSpan" id="kobo.2851.2">Notice that in the following listing, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2852.1">T</span></code><span class="koboSpan" id="kobo.2853.1"> is not a type template parameter, but only a placeholder for the return type of the operator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2854.1">T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2855.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2856.1">""</span></span><span class="koboSpan" id="kobo.2857.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2858.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2859.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2860.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2861.1">int</span></span><span class="koboSpan" id="kobo.2862.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2863.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2864.1">""</span></span><span class="koboSpan" id="kobo.2865.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2866.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2867.1">double</span></span><span class="koboSpan" id="kobo.2868.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2869.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2870.1">""</span></span><span class="koboSpan" id="kobo.2871.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2872.1">char</span></span><span class="koboSpan" id="kobo.2873.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2874.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2875.1">""</span></span><span class="koboSpan" id="kobo.2876.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2877.1">wchar_t</span></span><span class="koboSpan" id="kobo.2878.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2879.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2880.1">""</span></span><span class="koboSpan" id="kobo.2881.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2882.1">char8_t</span></span><span class="koboSpan" id="kobo.2883.1">); // since C++20
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2884.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2885.1">""</span></span><span class="koboSpan" id="kobo.2886.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2887.1">char16_t</span></span><span class="koboSpan" id="kobo.2888.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2889.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2890.1">""</span></span><span class="koboSpan" id="kobo.2891.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2892.1">char32_t</span></span><span class="koboSpan" id="kobo.2893.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2894.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2895.1">""</span></span><span class="koboSpan" id="kobo.2896.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2897.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2898.1">const</span></span><span class="koboSpan" id="kobo.2899.1"> *, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.2900.1">size_t</span></span><span class="koboSpan" id="kobo.2901.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2902.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2903.1">""</span></span><span class="koboSpan" id="kobo.2904.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2905.1">wchar_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2906.1">const</span></span><span class="koboSpan" id="kobo.2907.1"> *, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.2908.1">size_t</span></span><span class="koboSpan" id="kobo.2909.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2910.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2911.1">""</span></span><span class="koboSpan" id="kobo.2912.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2913.1">char8_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2914.1">const</span></span><span class="koboSpan" id="kobo.2915.1"> *, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.2916.1">size_t</span></span><span class="koboSpan" id="kobo.2917.1">); // C++20
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2918.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2919.1">""</span></span><span class="koboSpan" id="kobo.2920.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2921.1">char16_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2922.1">const</span></span><span class="koboSpan" id="kobo.2923.1"> *, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.2924.1">size_t</span></span><span class="koboSpan" id="kobo.2925.1">);
T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2926.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2927.1">""</span></span><span class="koboSpan" id="kobo.2928.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2929.1">char32_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2930.1">const</span></span><span class="koboSpan" id="kobo.2931.1"> *, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.2932.1">size_t</span></span><span class="koboSpan" id="kobo.2933.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2934.1">The following example creates a user-defined literal for specifying kilobytes:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2935.1">namespace</span></span><span class="koboSpan" id="kobo.2936.1"> compunits
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2937.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2938.1">size_t</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2939.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2940.1">""</span></span><span class="koboSpan" id="kobo.2941.1"> _KB(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2942.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2943.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2944.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2945.1">const</span></span><span class="koboSpan" id="kobo.2946.1"> size)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2947.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2948.1">static_cast</span></span><span class="koboSpan" id="kobo.2949.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2950.1">size_t</span></span><span class="koboSpan" id="kobo.2951.1">&gt;(size * </span><span class="hljs-number"><span class="koboSpan" id="kobo.2952.1">1024</span></span><span class="koboSpan" id="kobo.2953.1">);
  }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2954.1">auto</span></span><span class="koboSpan" id="kobo.2955.1"> size{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2956.1">4</span></span><span class="koboSpan" id="kobo.2957.1">_KB };         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2958.1">// size_t size = 4096;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2959.1">using</span></span><span class="koboSpan" id="kobo.2960.1"> byte = </span><span class="hljs-type"><span class="koboSpan" id="kobo.2961.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2962.1">char</span></span><span class="koboSpan" id="kobo.2963.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2964.1">auto</span></span><span class="koboSpan" id="kobo.2965.1"> buffer = std::array&lt;byte, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2966.1">1</span></span><span class="koboSpan" id="kobo.2967.1">_KB&gt;{};
</span></code></pre> </li>
</ol>
<h2 class="heading-2" id="_idParaDest-123"><span class="koboSpan" id="kobo.2968.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2969.1">When the </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.2970.1">compiler encounters a user-defined literal with a user-defined suffix, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2971.1">_X</span></code><span class="koboSpan" id="kobo.2972.1"> (it always has a leading underscore for third-party suffixes, as suffixes without a leading underscore are reserved for the standard library), it does an unqualified name lookup in order to identify a function with the name </span><code class="inlineCode"><span class="koboSpan" id="kobo.2973.1">operator "" _X</span></code><span class="koboSpan" id="kobo.2974.1">. </span><span class="koboSpan" id="kobo.2974.2">If it finds one, then it calls it according to the type of the literal and the type of the literal operator. </span><span class="koboSpan" id="kobo.2974.3">Otherwise, the compiler will yield an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2975.1">In the example shown in the </span><em class="italic"><span class="koboSpan" id="kobo.2976.1">How to do it...</span></em><span class="koboSpan" id="kobo.2977.1"> section, the literal operator is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2978.1">operator "" _KB</span></code><span class="koboSpan" id="kobo.2979.1"> and has an argument of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2980.1">unsigned long long int</span></code><span class="koboSpan" id="kobo.2981.1">. </span><span class="koboSpan" id="kobo.2981.2">This is the only integral type possible for literal operators to handle integral types. </span><span class="koboSpan" id="kobo.2981.3">Similarly, for floating-point user-defined literals, the parameter type must be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2982.1">long double</span></code><span class="koboSpan" id="kobo.2983.1"> since, for numeric types, the literal operators must be able to handle the largest possible values. </span><span class="koboSpan" id="kobo.2983.2">This literal operator returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2984.1">constexpr</span></code><span class="koboSpan" id="kobo.2985.1"> value so that it can be used where compile-time values are expected, such as specifying the size of an array, as shown in the preceding example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2986.1">When the compiler identifies a user-defined literal and has to call the appropriate user-defined literal operator, it will pick the overload from the overload set according to the following rules:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.2987.1">For integral literals</span></strong><span class="koboSpan" id="kobo.2988.1">: It </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.2989.1">calls in the following order: the operator that takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2990.1">unsigned long long</span></code><span class="koboSpan" id="kobo.2991.1">, the raw literal operator that takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2992.1">const char*</span></code><span class="koboSpan" id="kobo.2993.1">, or the literal operator template.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.2994.1">For floating-point literals</span></strong><span class="koboSpan" id="kobo.2995.1">: It</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.2996.1"> calls in the following order: the operator that takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2997.1">long double</span></code><span class="koboSpan" id="kobo.2998.1">, the raw literal operator that takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2999.1">const char*</span></code><span class="koboSpan" id="kobo.3000.1">, or the literal operator template.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.3001.1">For character literals</span></strong><span class="koboSpan" id="kobo.3002.1">: It calls </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.3003.1">the appropriate operator, depending on the character type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3004.1">char</span></code><span class="koboSpan" id="kobo.3005.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3006.1">wchar_t</span></code><span class="koboSpan" id="kobo.3007.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3008.1">char16_t</span></code><span class="koboSpan" id="kobo.3009.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3010.1">char32_t</span></code><span class="koboSpan" id="kobo.3011.1">).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.3012.1">For string literals</span></strong><span class="koboSpan" id="kobo.3013.1">: It </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.3014.1">calls the appropriate operator, depending on the string type, that takes a pointer to the string of characters and the size.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3015.1">In the following example, we’re defining a system of units and quantities. </span><span class="koboSpan" id="kobo.3015.2">We want to operate with kilograms, pieces, liters, and other types of units. </span><span class="koboSpan" id="kobo.3015.3">This could be useful in a system that can process orders and you need to specify the amount and unit for each article.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3016.1">The following are </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.3017.1">defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3018.1">units</span></code><span class="koboSpan" id="kobo.3019.1"> namespace:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3020.1">A scoped enumeration for the possible types of units (kilogram, meter, liter, and pieces):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3021.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3022.1">unit</span></span><span class="koboSpan" id="kobo.3023.1"> { kilogram, liter, meter, piece, };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3024.1">A class template to specify quantities of a particular unit (such as 3.5 kilograms or 42 pieces):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3025.1">template</span></span><span class="koboSpan" id="kobo.3026.1"> &lt;unit U&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3027.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3028.1">quantity</span></span><span class="koboSpan" id="kobo.3029.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3030.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3031.1">double</span></span><span class="koboSpan" id="kobo.3032.1"> amount;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3033.1">public</span></span><span class="koboSpan" id="kobo.3034.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3035.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3036.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3037.1">quantity</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3038.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3039.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3040.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3041.1"> a)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3042.1"> : amount(a)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3043.1">  {</span></span><span class="koboSpan" id="kobo.3044.1">}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3045.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3046.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3047.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3048.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3049.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3050.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3051.1">return</span></span><span class="koboSpan" id="kobo.3052.1"> amount; }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3053.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3054.1">operator+</span></code><span class="koboSpan" id="kobo.3055.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3056.1">operator-</span></code><span class="koboSpan" id="kobo.3057.1"> functions for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3058.1">quantity</span></code><span class="koboSpan" id="kobo.3059.1"> class template in order to be able to add and subtract quantities:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3060.1">template</span></span><span class="koboSpan" id="kobo.3061.1"> &lt;unit U&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3062.1">constexpr</span></span><span class="koboSpan" id="kobo.3063.1"> quantity&lt;U&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3064.1">operator</span></span><span class="koboSpan" id="kobo.3065.1">+(quantity&lt;U&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3066.1">const</span></span><span class="koboSpan" id="kobo.3067.1"> &amp;q1,
                                quantity&lt;U&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3068.1">const</span></span><span class="koboSpan" id="kobo.3069.1"> &amp;q2)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3070.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3071.1">quantity</span></span><span class="koboSpan" id="kobo.3072.1">&lt;U&gt;(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3073.1">static_cast</span></span><span class="koboSpan" id="kobo.3074.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3075.1">double</span></span><span class="koboSpan" id="kobo.3076.1">&gt;(q1) +
                     </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3077.1">static_cast</span></span><span class="koboSpan" id="kobo.3078.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3079.1">double</span></span><span class="koboSpan" id="kobo.3080.1">&gt;(q2));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3081.1">template</span></span><span class="koboSpan" id="kobo.3082.1"> &lt;unit U&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3083.1">constexpr</span></span><span class="koboSpan" id="kobo.3084.1"> quantity&lt;U&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3085.1">operator</span></span><span class="koboSpan" id="kobo.3086.1">-(quantity&lt;U&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3087.1">const</span></span><span class="koboSpan" id="kobo.3088.1"> &amp;q1,
                                quantity&lt;U&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3089.1">const</span></span><span class="koboSpan" id="kobo.3090.1"> &amp;q2)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3091.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3092.1">quantity</span></span><span class="koboSpan" id="kobo.3093.1">&lt;U&gt;(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3094.1">static_cast</span></span><span class="koboSpan" id="kobo.3095.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3096.1">double</span></span><span class="koboSpan" id="kobo.3097.1">&gt;(q1) –
                     </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3098.1">static_cast</span></span><span class="koboSpan" id="kobo.3099.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3100.1">double</span></span><span class="koboSpan" id="kobo.3101.1">&gt;(q2));
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3102.1">Literal </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.3103.1">operators to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.3104.1">quantity</span></code><span class="koboSpan" id="kobo.3105.1"> literals, defined in an inner namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3106.1">unit_literals</span></code><span class="koboSpan" id="kobo.3107.1">. </span><span class="koboSpan" id="kobo.3107.2">The purpose of this is to avoid possible name clashes with literals from other namespaces.
    </span><p class="normal"><span class="koboSpan" id="kobo.3108.1">If such collisions do happen, developers could select the ones that they should use using the appropriate namespace in the scope where the literals need to be defined:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3109.1">namespace</span></span><span class="koboSpan" id="kobo.3110.1"> unit_literals
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3111.1">constexpr</span></span><span class="koboSpan" id="kobo.3112.1"> quantity&lt;unit::kilogram&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3113.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3114.1">""</span></span><span class="koboSpan" id="kobo.3115.1"> _kg(
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.3116.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3117.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3118.1">const</span></span><span class="koboSpan" id="kobo.3119.1"> amount)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3120.1">return</span></span><span class="koboSpan" id="kobo.3121.1"> quantity&lt;unit::kilogram&gt; { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3122.1">static_cast</span></span><span class="koboSpan" id="kobo.3123.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3124.1">double</span></span><span class="koboSpan" id="kobo.3125.1">&gt;(amount) };
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3126.1">constexpr</span></span><span class="koboSpan" id="kobo.3127.1"> quantity&lt;unit::kilogram&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3128.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3129.1">""</span></span><span class="koboSpan" id="kobo.3130.1"> _kg(
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.3131.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3132.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3133.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3134.1">const</span></span><span class="koboSpan" id="kobo.3135.1"> amount)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3136.1">return</span></span><span class="koboSpan" id="kobo.3137.1"> quantity&lt;unit::kilogram&gt; { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3138.1">static_cast</span></span><span class="koboSpan" id="kobo.3139.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3140.1">double</span></span><span class="koboSpan" id="kobo.3141.1">&gt;(amount) };
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3142.1">constexpr</span></span><span class="koboSpan" id="kobo.3143.1"> quantity&lt;unit::liter&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3144.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3145.1">""</span></span><span class="koboSpan" id="kobo.3146.1"> _l(
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.3147.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3148.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3149.1">const</span></span><span class="koboSpan" id="kobo.3150.1"> amount)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3151.1">return</span></span><span class="koboSpan" id="kobo.3152.1"> quantity&lt;unit::liter&gt; { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3153.1">static_cast</span></span><span class="koboSpan" id="kobo.3154.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3155.1">double</span></span><span class="koboSpan" id="kobo.3156.1">&gt;(amount) };
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3157.1">constexpr</span></span><span class="koboSpan" id="kobo.3158.1"> quantity&lt;unit::meter&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3159.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3160.1">""</span></span><span class="koboSpan" id="kobo.3161.1"> _m(
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.3162.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3163.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3164.1">const</span></span><span class="koboSpan" id="kobo.3165.1"> amount)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3166.1">return</span></span><span class="koboSpan" id="kobo.3167.1"> quantity&lt;unit::meter&gt; { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3168.1">static_cast</span></span><span class="koboSpan" id="kobo.3169.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3170.1">double</span></span><span class="koboSpan" id="kobo.3171.1">&gt;(amount) };
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3172.1">constexpr</span></span><span class="koboSpan" id="kobo.3173.1"> quantity&lt;unit::piece&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3174.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3175.1">""</span></span><span class="koboSpan" id="kobo.3176.1"> _pcs(
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.3177.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3178.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3179.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3180.1">const</span></span><span class="koboSpan" id="kobo.3181.1"> amount)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3182.1">return</span></span><span class="koboSpan" id="kobo.3183.1"> quantity&lt;unit::piece&gt; { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3184.1">static_cast</span></span><span class="koboSpan" id="kobo.3185.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3186.1">double</span></span><span class="koboSpan" id="kobo.3187.1">&gt;(amount) };
  }
}
</span></code></pre></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3188.1">By looking carefully, you </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.3189.1">can note that the literal operators defined earlier are not the same:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3190.1">_kg</span></code><span class="koboSpan" id="kobo.3191.1"> is defined for both integral and floating-point literals; that enables us to create both integral and floating-point values such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3192.1">1_kg</span></code><span class="koboSpan" id="kobo.3193.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3194.1">1.0_kg</span></code><span class="koboSpan" id="kobo.3195.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3196.1">_l</span></code><span class="koboSpan" id="kobo.3197.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3198.1">_m</span></code><span class="koboSpan" id="kobo.3199.1"> are defined only for floating-point literals; this means we can only define quantity literals for these units with floating points, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3200.1">4.5_l</span></code><span class="koboSpan" id="kobo.3201.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3202.1">10.0_m</span></code><span class="koboSpan" id="kobo.3203.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3204.1">_pcs</span></code><span class="koboSpan" id="kobo.3205.1"> is only defined for integral literals; this means we can only define quantities of an integer number of pieces, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3206.1">42_pcs</span></code><span class="koboSpan" id="kobo.3207.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3208.1">Having these literal operators available, we can operate with various quantities. </span><span class="koboSpan" id="kobo.3208.2">The following examples show both valid and invalid operations:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3209.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3210.1">namespace</span></span><span class="koboSpan" id="kobo.3211.1"> units;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3212.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3213.1">namespace</span></span><span class="koboSpan" id="kobo.3214.1"> unit_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3215.1">auto</span></span><span class="koboSpan" id="kobo.3216.1"> q1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3217.1">1</span></span><span class="koboSpan" id="kobo.3218.1">_kg };    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3219.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3220.1">auto</span></span><span class="koboSpan" id="kobo.3221.1"> q2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3222.1">4.5</span></span><span class="koboSpan" id="kobo.3223.1">_kg };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3224.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3225.1">auto</span></span><span class="koboSpan" id="kobo.3226.1"> q3{ q1 + q2 }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3227.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3228.1">auto</span></span><span class="koboSpan" id="kobo.3229.1"> q4{ q2 - q1 }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3230.1">// OK</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3231.1">// error, cannot add meters and pieces</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3232.1">auto</span></span><span class="koboSpan" id="kobo.3233.1"> q5{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3234.1">1.0</span></span><span class="koboSpan" id="kobo.3235.1">_m + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3236.1">1</span></span><span class="koboSpan" id="kobo.3237.1">_pcs };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3238.1">// error, cannot have an integer number of liters</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3239.1">auto</span></span><span class="koboSpan" id="kobo.3240.1"> q6{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3241.1">1</span></span><span class="koboSpan" id="kobo.3242.1">_l };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3243.1">// error, can only have an integer number of pieces</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3244.1">auto</span></span><span class="koboSpan" id="kobo.3245.1"> q7{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3246.1">2.0</span></span><span class="koboSpan" id="kobo.3247.1">_pcs}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3248.1">q1</span></code><span class="koboSpan" id="kobo.3249.1"> is a quantity of 1 kg; this </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.3250.1">is an integer value. </span><span class="koboSpan" id="kobo.3250.2">Since an overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.3251.1">operator "" _kg(unsigned long long const)</span></code><span class="koboSpan" id="kobo.3252.1"> exists, the literal can be correctly created from the integer 1. </span><span class="koboSpan" id="kobo.3252.2">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3253.1">q2</span></code><span class="koboSpan" id="kobo.3254.1"> is a quantity of 4.5 kilograms; this is a real value. </span><span class="koboSpan" id="kobo.3254.2">Since an overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.3255.1">operator "" _kg(long double)</span></code><span class="koboSpan" id="kobo.3256.1"> exists, the literal can be created from the double floating-point value 4.5.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3257.1">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3258.1">q6</span></code><span class="koboSpan" id="kobo.3259.1"> is a quantity of 1 liter. </span><span class="koboSpan" id="kobo.3259.2">Since there is no overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.3260.1">operator "" _l(unsigned long long)</span></code><span class="koboSpan" id="kobo.3261.1">, the literal cannot be created. </span><span class="koboSpan" id="kobo.3261.2">It would require an overload that takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3262.1">unsigned long long</span></code><span class="koboSpan" id="kobo.3263.1">, but such an overload does not exist. </span><span class="koboSpan" id="kobo.3263.2">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3264.1">q7</span></code><span class="koboSpan" id="kobo.3265.1"> is a quantity of 2.0 pieces, but piece literals can only be created from integer values and, therefore, this generates another compiler error.</span></p>
<h2 class="heading-2" id="_idParaDest-124"><span class="koboSpan" id="kobo.3266.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3267.1">Though user-defined literals are available from C++11, standard literal operators have been available only from C++14. </span><span class="koboSpan" id="kobo.3267.2">Further standard user-defined literals have been added to the next versions of the standard. </span><span class="koboSpan" id="kobo.3267.3">The following is a list of these standard literal operators:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3268.1">operator""s</span></code><span class="koboSpan" id="kobo.3269.1"> for defining </span><code class="inlineCode"><span class="koboSpan" id="kobo.3270.1">std::basic_string</span></code><span class="koboSpan" id="kobo.3271.1"> literals and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3272.1">operator""sv</span></code><span class="koboSpan" id="kobo.3273.1"> (in C++17) for defining </span><code class="inlineCode"><span class="koboSpan" id="kobo.3274.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.3275.1"> literals:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3276.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3277.1">namespace</span></span><span class="koboSpan" id="kobo.3278.1"> std::string_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3279.1">auto</span></span><span class="koboSpan" id="kobo.3280.1"> s1{  </span><span class="hljs-string"><span class="koboSpan" id="kobo.3281.1">"text"</span></span><span class="koboSpan" id="kobo.3282.1">s }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3283.1">// std::string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3284.1">auto</span></span><span class="koboSpan" id="kobo.3285.1"> s2{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3286.1">L"text"</span></span><span class="koboSpan" id="kobo.3287.1">s }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3288.1">// std::wstring</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3289.1">auto</span></span><span class="koboSpan" id="kobo.3290.1"> s3{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3291.1">u"text"</span></span><span class="koboSpan" id="kobo.3292.1">s }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3293.1">// std::u16string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3294.1">auto</span></span><span class="koboSpan" id="kobo.3295.1"> s4{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3296.1">U"text"</span></span><span class="koboSpan" id="kobo.3297.1">s }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3298.1">// std::u32string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3299.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3300.1">namespace</span></span><span class="koboSpan" id="kobo.3301.1"> std::string_view_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3302.1">auto</span></span><span class="koboSpan" id="kobo.3303.1"> s5{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3304.1">"text"</span></span><span class="koboSpan" id="kobo.3305.1">sv }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3306.1">// std::string_view</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3307.1">operator""h</span></code><span class="koboSpan" id="kobo.3308.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3309.1">operator""min</span></code><span class="koboSpan" id="kobo.3310.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3311.1">operator""s</span></code><span class="koboSpan" id="kobo.3312.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3313.1">operator""ms</span></code><span class="koboSpan" id="kobo.3314.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3315.1">operator""us</span></code><span class="koboSpan" id="kobo.3316.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3317.1">operator""ns</span></code><span class="koboSpan" id="kobo.3318.1"> for creating an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3319.1">std::chrono::duration</span></code><span class="koboSpan" id="kobo.3320.1"> value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3321.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3322.1">namespace</span></span><span class="koboSpan" id="kobo.3323.1"> std::chrono_literals;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3324.1">// std::chrono::duration&lt;long long&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3325.1">auto</span></span><span class="koboSpan" id="kobo.3326.1"> timer {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3327.1">2</span></span><span class="koboSpan" id="kobo.3328.1">h + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3329.1">42</span></span><span class="koboSpan" id="kobo.3330.1">min + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3331.1">15</span></span><span class="koboSpan" id="kobo.3332.1">s};
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3333.1">operator""y</span></code><span class="koboSpan" id="kobo.3334.1"> for creating an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3335.1">std::chrono::year</span></code><span class="koboSpan" id="kobo.3336.1"> literal and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3337.1">operator""d</span></code><span class="koboSpan" id="kobo.3338.1"> for creating an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3339.1">std::chrono::day</span></code><span class="koboSpan" id="kobo.3340.1"> literal that represents a day of a month, both added to C++20:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3341.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3342.1">namespace</span></span><span class="koboSpan" id="kobo.3343.1"> std::chrono_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3344.1">auto</span></span><span class="koboSpan" id="kobo.3345.1"> year { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3346.1">2020</span></span><span class="koboSpan" id="kobo.3347.1">y }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3348.1">// std::chrono::year</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3349.1">auto</span></span><span class="koboSpan" id="kobo.3350.1"> day { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3351.1">15</span></span><span class="koboSpan" id="kobo.3352.1">d };    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3353.1">// std::chrono::day</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3354.1">operator""if</span></code><span class="koboSpan" id="kobo.3355.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3356.1">operator""i</span></code><span class="koboSpan" id="kobo.3357.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3358.1">operator""il</span></code><span class="koboSpan" id="kobo.3359.1"> for creating an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3360.1">std::complex&lt;float&gt;</span></code><span class="koboSpan" id="kobo.3361.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3362.1">std::complex&lt;double&gt;</span></code><span class="koboSpan" id="kobo.3363.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3364.1">std::complex&lt;long double&gt;</span></code><span class="koboSpan" id="kobo.3365.1"> value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3366.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3367.1">namespace</span></span><span class="koboSpan" id="kobo.3368.1"> std::complex_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3369.1">auto</span></span><span class="koboSpan" id="kobo.3370.1"> c{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3371.1">12.0</span></span><span class="koboSpan" id="kobo.3372.1"> + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3373.1">4.5</span></span><span class="koboSpan" id="kobo.3374.1">i }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3375.1">// std::complex&lt;double&gt;</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3376.1">The standard </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.3377.1">user-defined literals are available in multiple namespaces. </span><span class="koboSpan" id="kobo.3377.2">For instance, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3378.1">""s</span></code><span class="koboSpan" id="kobo.3379.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3380.1">""sv</span></code><span class="koboSpan" id="kobo.3381.1"> literals for strings are defined in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.3382.1">std::literals::string_literals</span></code><span class="koboSpan" id="kobo.3383.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3384.1">However, both </span><code class="inlineCode"><span class="koboSpan" id="kobo.3385.1">literals</span></code><span class="koboSpan" id="kobo.3386.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3387.1">string_literals</span></code><span class="koboSpan" id="kobo.3388.1"> are inlined namespaces. </span><span class="koboSpan" id="kobo.3388.2">Therefore, you can access the literals with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3389.1">using namespace std::literals</span></code><span class="koboSpan" id="kobo.3390.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3391.1">using namespace std::string_literals</span></code><span class="koboSpan" id="kobo.3392.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3393.1">using namespace std::literals::string_literals</span></code><span class="koboSpan" id="kobo.3394.1">. </span><span class="koboSpan" id="kobo.3394.2">In the previous examples, the second form was preferred.</span></p>
<h2 class="heading-2" id="_idParaDest-125"><span class="koboSpan" id="kobo.3395.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3396.1">Using raw string literals to avoid escaping characters</span></em><span class="koboSpan" id="kobo.3397.1">, to learn how to define string literals without the need to escape special characters</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3398.1">Creating raw user-defined literals</span></em><span class="koboSpan" id="kobo.3399.1">, to understand how to provide a custom interpretation of an input sequence so that it changes the normal behavior of the compiler</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3400.1">Chapter 1</span></em><span class="koboSpan" id="kobo.3401.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3402.1">Using inline namespaces for symbol versioning,</span></em><span class="koboSpan" id="kobo.3403.1"> to learn how to version your source code using inline namespaces and conditional compilation</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-126"><span class="koboSpan" id="kobo.3404.1">Creating raw user-defined literals</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3405.1">In the previous</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.3406.1"> recipe, we looked at the way C++11 allows library implementers and developers to create user-defined literals and the user-defined literals available in the C++14 standard. </span><span class="koboSpan" id="kobo.3406.2">However, user-defined literals have two forms: a cooked form, where the literal value is processed by the compiler before being supplied to the literal operator, and a raw form, in which the literal is not processed by the compiler before being supplied to the literal operator. </span><span class="koboSpan" id="kobo.3406.3">The latter is only available for integral and floating-point types. </span><span class="koboSpan" id="kobo.3406.4">Raw literals are useful for altering the compiler’s normal behavior. </span><span class="koboSpan" id="kobo.3406.5">For instance, a sequence such as 3.1415926 is interpreted by the compiler as a floating-point value, but with the use of a raw user-defined literal, it could be interpreted as a user-defined decimal value. </span><span class="koboSpan" id="kobo.3406.6">In this recipe, we will look at creating raw user-defined literals.</span></p>
<h2 class="heading-2" id="_idParaDest-127"><span class="koboSpan" id="kobo.3407.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3408.1">Before continuing with this recipe, it is strongly recommended that you go through the previous one, </span><em class="italic"><span class="koboSpan" id="kobo.3409.1">Creating cooked user-defined literals</span></em><span class="koboSpan" id="kobo.3410.1">, as general details about user-defined literals will not be reiterated here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3411.1">To exemplify the way raw user-defined literals can be created, we will define binary literals. </span><span class="koboSpan" id="kobo.3411.2">These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned) types. </span><span class="koboSpan" id="kobo.3411.3">These types will be called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3412.1">byte8</span></code><span class="koboSpan" id="kobo.3413.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3414.1">byte16</span></code><span class="koboSpan" id="kobo.3415.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3416.1">byte32</span></code><span class="koboSpan" id="kobo.3417.1">, and the literals we will create will be called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3418.1">_b8</span></code><span class="koboSpan" id="kobo.3419.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3420.1">_b16</span></code><span class="koboSpan" id="kobo.3421.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3422.1">_b32</span></code><span class="koboSpan" id="kobo.3423.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-128"><span class="koboSpan" id="kobo.3424.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3425.1">To create raw user-defined literals, you should follow these steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3426.1">Define your literals in a separate namespace to avoid name clashes.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.3427.1">Always prefix the used-defined suffix with an underscore (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3428.1">_</span></code><span class="koboSpan" id="kobo.3429.1">).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.3430.1">Define a literal operator or literal operator template of the following form:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3431.1">T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3432.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3433.1">""</span></span><span class="koboSpan" id="kobo.3434.1"> _suffix(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3435.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3436.1">char</span></span><span class="koboSpan" id="kobo.3437.1">*);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3438.1">template</span></span><span class="koboSpan" id="kobo.3439.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3440.1">char</span></span><span class="koboSpan" id="kobo.3441.1">...&gt; T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3442.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3443.1">""</span></span><span class="koboSpan" id="kobo.3444.1"> _suffix();
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3445.1">The following </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.3446.1">example shows a possible implementation of 8-bit, 16-bit, and 32-bit binary literals:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3447.1">namespace</span></span><span class="koboSpan" id="kobo.3448.1"> binary
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3449.1">using</span></span><span class="koboSpan" id="kobo.3450.1"> byte8  = </span><span class="hljs-type"><span class="koboSpan" id="kobo.3451.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3452.1">char</span></span><span class="koboSpan" id="kobo.3453.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3454.1">using</span></span><span class="koboSpan" id="kobo.3455.1"> byte16 = </span><span class="hljs-type"><span class="koboSpan" id="kobo.3456.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3457.1">short</span></span><span class="koboSpan" id="kobo.3458.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3459.1">using</span></span><span class="koboSpan" id="kobo.3460.1"> byte32 = </span><span class="hljs-type"><span class="koboSpan" id="kobo.3461.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3462.1">int</span></span><span class="koboSpan" id="kobo.3463.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3464.1">namespace</span></span><span class="koboSpan" id="kobo.3465.1"> binary_literals
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3466.1">namespace</span></span><span class="koboSpan" id="kobo.3467.1"> binary_literals_internals
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3468.1">template</span></span><span class="koboSpan" id="kobo.3469.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3470.1">typename</span></span><span class="koboSpan" id="kobo.3471.1"> CharT, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3472.1">char</span></span><span class="koboSpan" id="kobo.3473.1">... </span><span class="koboSpan" id="kobo.3473.2">bits&gt;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3474.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3475.1">binary_struct</span></span><span class="koboSpan" id="kobo.3476.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3477.1">template</span></span><span class="koboSpan" id="kobo.3478.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3479.1">typename</span></span><span class="koboSpan" id="kobo.3480.1"> CharT, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3481.1">char</span></span><span class="koboSpan" id="kobo.3482.1">... </span><span class="koboSpan" id="kobo.3482.2">bits&gt;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3483.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3484.1">binary_struct</span></span><span class="koboSpan" id="kobo.3485.1">&lt;CharT, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3486.1">'0'</span></span><span class="koboSpan" id="kobo.3487.1">, bits...&gt;
      {
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.3488.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3489.1">constexpr</span></span><span class="koboSpan" id="kobo.3490.1"> CharT value{
          binary_struct&lt;CharT, bits...&gt;::value };
      };
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3491.1">template</span></span><span class="koboSpan" id="kobo.3492.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3493.1">typename</span></span><span class="koboSpan" id="kobo.3494.1"> CharT, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3495.1">char</span></span><span class="koboSpan" id="kobo.3496.1">... </span><span class="koboSpan" id="kobo.3496.2">bits&gt;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3497.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3498.1">binary_struct</span></span><span class="koboSpan" id="kobo.3499.1">&lt;CharT, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3500.1">'1'</span></span><span class="koboSpan" id="kobo.3501.1">, bits...&gt;
      {
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.3502.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3503.1">constexpr</span></span><span class="koboSpan" id="kobo.3504.1"> CharT value{
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3505.1">static_cast</span></span><span class="koboSpan" id="kobo.3506.1">&lt;CharT&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3507.1">1</span></span><span class="koboSpan" id="kobo.3508.1"> &lt;&lt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3509.1">sizeof</span></span><span class="koboSpan" id="kobo.3510.1">...(bits)) |
          binary_struct&lt;CharT, bits...&gt;::value };
      };
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3511.1">template</span></span><span class="koboSpan" id="kobo.3512.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3513.1">typename</span></span><span class="koboSpan" id="kobo.3514.1"> CharT&gt;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3515.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3516.1">binary_struct</span></span><span class="koboSpan" id="kobo.3517.1">&lt;CharT&gt;
      {
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.3518.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3519.1">constexpr</span></span><span class="koboSpan" id="kobo.3520.1"> CharT value{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3521.1">0</span></span><span class="koboSpan" id="kobo.3522.1"> };
      };
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3523.1">template</span></span><span class="koboSpan" id="kobo.3524.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3525.1">char</span></span><span class="koboSpan" id="kobo.3526.1">... </span><span class="koboSpan" id="kobo.3526.2">bits&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3527.1">constexpr</span></span><span class="koboSpan" id="kobo.3528.1"> byte8 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3529.1">operator</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3530.1">""</span></span><span class="koboSpan" id="kobo.3531.1">_b8()
    {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3532.1">static_assert</span></span><span class="koboSpan" id="kobo.3533.1">(
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3534.1">sizeof</span></span><span class="koboSpan" id="kobo.3535.1">...(bits) &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3536.1">8</span></span><span class="koboSpan" id="kobo.3537.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.3538.1">"binary literal b8 must be up to 8 digits long"</span></span><span class="koboSpan" id="kobo.3539.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3540.1">return</span></span><span class="koboSpan" id="kobo.3541.1"> binary_literals_internals::
                binary_struct&lt;byte8, bits...&gt;::value;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3542.1">template</span></span><span class="koboSpan" id="kobo.3543.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3544.1">char</span></span><span class="koboSpan" id="kobo.3545.1">... </span><span class="koboSpan" id="kobo.3545.2">bits&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3546.1">constexpr</span></span><span class="koboSpan" id="kobo.3547.1"> byte16 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3548.1">operator</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3549.1">""</span></span><span class="koboSpan" id="kobo.3550.1">_b16()
    {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3551.1">static_assert</span></span><span class="koboSpan" id="kobo.3552.1">(
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3553.1">sizeof</span></span><span class="koboSpan" id="kobo.3554.1">...(bits) &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3555.1">16</span></span><span class="koboSpan" id="kobo.3556.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.3557.1">"binary literal b16 must be up to 16 digits long"</span></span><span class="koboSpan" id="kobo.3558.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3559.1">return</span></span><span class="koboSpan" id="kobo.3560.1"> binary_literals_internals::
                binary_struct&lt;byte16, bits...&gt;::value;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3561.1">template</span></span><span class="koboSpan" id="kobo.3562.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3563.1">char</span></span><span class="koboSpan" id="kobo.3564.1">... </span><span class="koboSpan" id="kobo.3564.2">bits&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3565.1">constexpr</span></span><span class="koboSpan" id="kobo.3566.1"> byte32 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3567.1">operator</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3568.1">""</span></span><span class="koboSpan" id="kobo.3569.1">_b32()
    {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3570.1">static_assert</span></span><span class="koboSpan" id="kobo.3571.1">(
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3572.1">sizeof</span></span><span class="koboSpan" id="kobo.3573.1">...(bits) &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3574.1">32</span></span><span class="koboSpan" id="kobo.3575.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.3576.1">"binary literal b32 must be up to 32 digits long"</span></span><span class="koboSpan" id="kobo.3577.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3578.1">return</span></span><span class="koboSpan" id="kobo.3579.1"> binary_literals_internals::
                binary_struct&lt;byte32, bits...&gt;::value;
    }
  }
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-129"><span class="koboSpan" id="kobo.3580.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3581.1">First of all, we</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.3582.1"> define everything inside a namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3583.1">binary</span></code><span class="koboSpan" id="kobo.3584.1"> and start by introducing several type aliases: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3585.1">byte8</span></code><span class="koboSpan" id="kobo.3586.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3587.1">byte16</span></code><span class="koboSpan" id="kobo.3588.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3589.1">byte32</span></code><span class="koboSpan" id="kobo.3590.1">. </span><span class="koboSpan" id="kobo.3590.2">These represent integral types of 8 bits, 16 bits, and 32 bits, as the names imply.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3591.1">The implementation in the previous section enables us to define binary literals of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.3592.1">1010_b8</span></code><span class="koboSpan" id="kobo.3593.1"> (a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3594.1">byte8</span></code><span class="koboSpan" id="kobo.3595.1"> value of decimal 10) or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3596.1">000010101100_b16</span></code><span class="koboSpan" id="kobo.3597.1"> (a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3598.1">byte16</span></code><span class="koboSpan" id="kobo.3599.1"> value of decimal 2130496). </span><span class="koboSpan" id="kobo.3599.2">However, we want to make sure that we do not exceed the number of digits for each type. </span><span class="koboSpan" id="kobo.3599.3">In other words, values such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3600.1">111100001_b8</span></code><span class="koboSpan" id="kobo.3601.1"> should be illegal and the compiler should yield an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3602.1">The literal operator templates are defined in a nested namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3603.1">binary_literal_internals</span></code><span class="koboSpan" id="kobo.3604.1">. </span><span class="koboSpan" id="kobo.3604.2">This is a good practice in order to avoid name collisions with other literal operators from other namespaces. </span><span class="koboSpan" id="kobo.3604.3">Should something like that happen, you can choose to use the appropriate namespace in the right scope (such as one namespace in a function or block and another namespace in another function or block).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3605.1">The </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.3606.1">three literal operator templates are very similar. </span><span class="koboSpan" id="kobo.3606.2">The only things that are different are their names (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3607.1">_b8</span></code><span class="koboSpan" id="kobo.3608.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3609.1">_16</span></code><span class="koboSpan" id="kobo.3610.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3611.1">_b32</span></code><span class="koboSpan" id="kobo.3612.1">), return type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3613.1">byte8</span></code><span class="koboSpan" id="kobo.3614.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3615.1">byte16</span></code><span class="koboSpan" id="kobo.3616.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3617.1">byte32</span></code><span class="koboSpan" id="kobo.3618.1">), and the condition in the static assert that checks the number of digits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3619.1">We will explore the details of variadic templates and template recursion in a later recipe; however, for a better understanding, this is how this particular implementation works: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3620.1">bits</span></code><span class="koboSpan" id="kobo.3621.1"> is a template parameter pack that is not a single value, but all the values the template could be instantiated with. </span><span class="koboSpan" id="kobo.3621.2">For example, if we consider the literal </span><code class="inlineCode"><span class="koboSpan" id="kobo.3622.1">1010_b8</span></code><span class="koboSpan" id="kobo.3623.1">, then the literal operator template would be instantiated as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3624.1">operator"" _b8&lt;'1', '0', '1', '0'&gt;()</span></code><span class="koboSpan" id="kobo.3625.1">. </span><span class="koboSpan" id="kobo.3625.2">Before proceeding with computing the binary value, we check the number of digits in the literal. </span><span class="koboSpan" id="kobo.3625.3">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.3626.1">_b8</span></code><span class="koboSpan" id="kobo.3627.1">, this must not exceed eight (including any trailing zeros). </span><span class="koboSpan" id="kobo.3627.2">Similarly, it should be up to 16 digits for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3628.1">_b16</span></code><span class="koboSpan" id="kobo.3629.1"> and 32 for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3630.1">_b32</span></code><span class="koboSpan" id="kobo.3631.1">. </span><span class="koboSpan" id="kobo.3631.2">For this, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3632.1">sizeof...</span></code><span class="koboSpan" id="kobo.3633.1"> operator, which returns the number of elements in a parameter pack (in this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3634.1">bits</span></code><span class="koboSpan" id="kobo.3635.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3636.1">If the number of digits is correct, we can proceed to expand the parameter pack and recursively compute the decimal value represented by the binary literal. </span><span class="koboSpan" id="kobo.3636.2">This is done with the help of an additional class template and its specializations. </span><span class="koboSpan" id="kobo.3636.3">These templates are defined in yet another nested namespace, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3637.1">binary_literals_internals</span></code><span class="koboSpan" id="kobo.3638.1">. </span><span class="koboSpan" id="kobo.3638.2">This is also a good practice because it hides (without proper qualification) the implementation details from the client (unless an explicit </span><code class="inlineCode"><span class="koboSpan" id="kobo.3639.1">using namespace</span></code><span class="koboSpan" id="kobo.3640.1"> directive makes them available to the current namespace).</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3641.1">Even though this looks like recursion, it is not a true runtime recursion. </span><span class="koboSpan" id="kobo.3641.2">This is because, after the compiler expands and generates the code from templates, what we end up with is basically calls to overloaded functions with a different number of parameters. </span><span class="koboSpan" id="kobo.3641.3">This is explained in </span><em class="italic"><span class="koboSpan" id="kobo.3642.1">Chapter 3</span></em><span class="koboSpan" id="kobo.3643.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.3644.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.3645.1"> recipe.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3646.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3647.1">binary_struct</span></code><span class="koboSpan" id="kobo.3648.1"> class template has a template type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3649.1">CharT</span></code><span class="koboSpan" id="kobo.3650.1"> for the return type of the function (we need this because our literal operator templates should return either </span><code class="inlineCode"><span class="koboSpan" id="kobo.3651.1">byte8</span></code><span class="koboSpan" id="kobo.3652.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3653.1">byte16</span></code><span class="koboSpan" id="kobo.3654.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3655.1">byte32</span></code><span class="koboSpan" id="kobo.3656.1">) and a parameter pack:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3657.1">template</span></span><span class="koboSpan" id="kobo.3658.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3659.1">typename</span></span><span class="koboSpan" id="kobo.3660.1"> CharT, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3661.1">char</span></span><span class="koboSpan" id="kobo.3662.1">... </span><span class="koboSpan" id="kobo.3662.2">bits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3663.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3664.1">binary_struct</span></span><span class="koboSpan" id="kobo.3665.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3666.1">Several specializations</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.3667.1"> of this class template are available with parameter pack decomposition (of which you can read more in </span><em class="chapterRef"><span class="koboSpan" id="kobo.3668.1">Chapter 3</span></em><span class="koboSpan" id="kobo.3669.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.3670.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.3671.1">) recipe. </span><span class="koboSpan" id="kobo.3671.2">When the first digit of the pack is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3672.1">'0'</span></code><span class="koboSpan" id="kobo.3673.1">, the computed value remains the same, and we continue expanding the rest of the pack. </span><span class="koboSpan" id="kobo.3673.2">If the first digit of the pack is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3674.1">'1'</span></code><span class="koboSpan" id="kobo.3675.1">, then the new value is 1, shifted to the left with the number of digits in the remainder of the pack bit, or the value of the rest of the pack:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3676.1">template</span></span><span class="koboSpan" id="kobo.3677.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3678.1">typename</span></span><span class="koboSpan" id="kobo.3679.1"> CharT, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3680.1">char</span></span><span class="koboSpan" id="kobo.3681.1">... </span><span class="koboSpan" id="kobo.3681.2">bits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3682.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3683.1">binary_struct</span></span><span class="koboSpan" id="kobo.3684.1">&lt;CharT, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3685.1">'0'</span></span><span class="koboSpan" id="kobo.3686.1">, bits...&gt;
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3687.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3688.1">constexpr</span></span><span class="koboSpan" id="kobo.3689.1"> CharT value{ binary_struct&lt;CharT, bits...&gt;::value };
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3690.1">template</span></span><span class="koboSpan" id="kobo.3691.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3692.1">typename</span></span><span class="koboSpan" id="kobo.3693.1"> CharT, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3694.1">char</span></span><span class="koboSpan" id="kobo.3695.1">... </span><span class="koboSpan" id="kobo.3695.2">bits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3696.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3697.1">binary_struct</span></span><span class="koboSpan" id="kobo.3698.1">&lt;CharT, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3699.1">'1'</span></span><span class="koboSpan" id="kobo.3700.1">, bits...&gt;
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3701.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3702.1">constexpr</span></span><span class="koboSpan" id="kobo.3703.1"> CharT value{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3704.1">static_cast</span></span><span class="koboSpan" id="kobo.3705.1">&lt;CharT&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3706.1">1</span></span><span class="koboSpan" id="kobo.3707.1"> &lt;&lt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3708.1">sizeof</span></span><span class="koboSpan" id="kobo.3709.1">...(bits)) |
    binary_struct&lt;CharT, bits...&gt;::value };
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3710.1">The last specialization covers the case where the pack is empty; in this case, we return 0:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3711.1">template</span></span><span class="koboSpan" id="kobo.3712.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3713.1">typename</span></span><span class="koboSpan" id="kobo.3714.1"> CharT&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3715.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3716.1">binary_struct</span></span><span class="koboSpan" id="kobo.3717.1">&lt;CharT&gt;
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3718.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3719.1">constexpr</span></span><span class="koboSpan" id="kobo.3720.1"> CharT value{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3721.1">0</span></span><span class="koboSpan" id="kobo.3722.1"> };
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3723.1">After defining these helper classes, we could implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3724.1">byte8</span></code><span class="koboSpan" id="kobo.3725.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3726.1">byte16</span></code><span class="koboSpan" id="kobo.3727.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3728.1">byte32</span></code><span class="koboSpan" id="kobo.3729.1"> binary literals as intended. </span><span class="koboSpan" id="kobo.3729.2">Note that we need to bring the content of the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.3730.1">binary_literals</span></code><span class="koboSpan" id="kobo.3731.1"> into the current namespace in order to use the literal operator templates:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3732.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3733.1">namespace</span></span><span class="koboSpan" id="kobo.3734.1"> binary;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3735.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3736.1">namespace</span></span><span class="koboSpan" id="kobo.3737.1"> binary_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3738.1">auto</span></span><span class="koboSpan" id="kobo.3739.1"> b1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3740.1">1010</span></span><span class="koboSpan" id="kobo.3741.1">_b8;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3742.1">auto</span></span><span class="koboSpan" id="kobo.3743.1"> b2 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3744.1">101010101010</span></span><span class="koboSpan" id="kobo.3745.1">_b16;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3746.1">auto</span></span><span class="koboSpan" id="kobo.3747.1"> b3 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3748.1">101010101010101010101010</span></span><span class="koboSpan" id="kobo.3749.1">_b32;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3750.1">The following definitions trigger compiler errors:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.3751.1">// binary literal b8 must be up to 8 digits long</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3752.1">auto</span></span><span class="koboSpan" id="kobo.3753.1"> b4 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3754.1">0011111111</span></span><span class="koboSpan" id="kobo.3755.1">_b8;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3756.1">// binary literal b16 must be up to 16 digits long</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3757.1">auto</span></span><span class="koboSpan" id="kobo.3758.1"> b5 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3759.1">001111111111111111</span></span><span class="koboSpan" id="kobo.3760.1">_b16;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3761.1">// binary literal b32 must be up to 32 digits long</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3762.1">auto</span></span><span class="koboSpan" id="kobo.3763.1"> b6 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3764.1">0011111111111111111111111111111111</span></span><span class="koboSpan" id="kobo.3765.1">_b32;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3766.1">The reason</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.3767.1"> for this is that the condition in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3768.1">static_assert</span></code><span class="koboSpan" id="kobo.3769.1"> is not met. </span><span class="koboSpan" id="kobo.3769.2">The length of the sequence of characters preceding the literal operator is greater than expected, in all cases.</span></p>
<h2 class="heading-2" id="_idParaDest-130"><span class="koboSpan" id="kobo.3770.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3771.1">Using raw string literals to avoid escaping characters</span></em><span class="koboSpan" id="kobo.3772.1">, to learn how to define string literals without the need to escape special characters</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3773.1">Creating cooked user-defined literals</span></em><span class="koboSpan" id="kobo.3774.1">, to learn how to create literals of user-defined types</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3775.1">Chapter 3</span></em><span class="koboSpan" id="kobo.3776.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3777.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.3778.1">, to see how variadic templates enable us to write functions that can take any number of arguments</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3779.1">Chapter 1</span></em><span class="koboSpan" id="kobo.3780.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3781.1">Creating type aliases and alias templates</span></em><span class="koboSpan" id="kobo.3782.1">, to learn about aliases for types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-131"><span class="koboSpan" id="kobo.3783.1">Using raw string literals to avoid escaping characters</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3784.1">Strings </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.3785.1">may contain special characters, such as </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.3786.1">non-printable characters (newline, horizontal and vertical tab, and so on), string and character delimiters (double and single quotes), or arbitrary octal, hexadecimal, or Unicode values. </span><span class="koboSpan" id="kobo.3786.2">These special characters are introduced with an escape sequence that starts with a backslash, followed by either the character (examples include </span><code class="inlineCode"><span class="koboSpan" id="kobo.3787.1">'</span></code><span class="koboSpan" id="kobo.3788.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3789.1">"</span></code><span class="koboSpan" id="kobo.3790.1">), its designated letter (examples include </span><code class="inlineCode"><span class="koboSpan" id="kobo.3791.1">n</span></code><span class="koboSpan" id="kobo.3792.1"> for a new line, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3793.1">t</span></code><span class="koboSpan" id="kobo.3794.1"> for a horizontal tab), or its value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). </span><span class="koboSpan" id="kobo.3794.2">As a result, the backslash character itself has to be escaped with another backslash character. </span><span class="koboSpan" id="kobo.3794.3">This leads to more complicated literal strings that can be hard to read.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3795.1">To avoid </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.3796.1">escaping characters, C++11 introduced raw string literals that do not process escape sequences. </span><span class="koboSpan" id="kobo.3796.2">In this recipe, you will learn how to use the various forms of raw string literals.</span></p>
<h2 class="heading-2" id="_idParaDest-132"><span class="koboSpan" id="kobo.3797.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3798.1">In this recipe, and throughout the rest of this book, I will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3799.1">s</span></code><span class="koboSpan" id="kobo.3800.1"> suffix to define </span><code class="inlineCode"><span class="koboSpan" id="kobo.3801.1">basic_string</span></code><span class="koboSpan" id="kobo.3802.1"> literals. </span><span class="koboSpan" id="kobo.3802.2">This was covered earlier in this chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.3803.1">Creating cooked user-defined literals</span></em><span class="koboSpan" id="kobo.3804.1"> recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-133"><span class="koboSpan" id="kobo.3805.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3806.1">To </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.3807.1">avoid escaping characters, define the string literals with one of the following forms:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3808.1">R"( literal )"</span></code><span class="koboSpan" id="kobo.3809.1"> as the default form:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3810.1">auto</span></span><span class="koboSpan" id="kobo.3811.1"> filename {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3812.1">R"(C:\Users\Marius\Documents\)"</span></span><span class="koboSpan" id="kobo.3813.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3814.1">auto</span></span><span class="koboSpan" id="kobo.3815.1"> pattern {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3816.1">R"((\w+)=(\d+)$)"</span></span><span class="koboSpan" id="kobo.3817.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3818.1">auto</span></span><span class="koboSpan" id="kobo.3819.1"> sqlselect {
  </span><span class="hljs-string"><span class="koboSpan" id="kobo.3820.1">R"(SELECT *</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3821.1">  FROM Books</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3822.1">  WHERE Publisher='Packtpub'</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3823.1">  ORDER BY PubDate DESC)"</span></span><span class="koboSpan" id="kobo.3824.1">s};
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3825.1">R"delimiter( literal )delimiter"</span></code><span class="koboSpan" id="kobo.3826.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.3827.1">delimiter</span></code><span class="koboSpan" id="kobo.3828.1"> is any sequence of characters excluding parentheses, backslash, and spaces, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3829.1">literal</span></code><span class="koboSpan" id="kobo.3830.1"> is any sequence of characters with the limitation that it cannot include the closing sequence </span><code class="inlineCode"><span class="koboSpan" id="kobo.3831.1">)delimiter"</span></code><span class="koboSpan" id="kobo.3832.1">. </span><span class="koboSpan" id="kobo.3832.2">Here is an example with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3833.1">!!</span></code><span class="koboSpan" id="kobo.3834.1"> as a delimiter:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3835.1">auto</span></span><span class="koboSpan" id="kobo.3836.1"> text{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3837.1">R"!!(This text contains both "( and )".)!!"</span></span><span class="koboSpan" id="kobo.3838.1">s };
std::cout &lt;&lt; text &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3839.1">'\n'</span></span><span class="koboSpan" id="kobo.3840.1">;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-134"><span class="koboSpan" id="kobo.3841.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3842.1">When </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.3843.1">string literals are used, escapes are not processed, and the actual content of the string is written between the delimiter (in other words, what you see is what you get). </span><span class="koboSpan" id="kobo.3843.2">The following example shows what appears as the same raw literal string; however, the second one still contains escaped characters. </span><span class="koboSpan" id="kobo.3843.3">Since these are not processed in the case of string literals, they will be printed as they are in the output:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3844.1">auto</span></span><span class="koboSpan" id="kobo.3845.1"> filename1 {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3846.1">R"(C:\Users\Marius\Documents\)"</span></span><span class="koboSpan" id="kobo.3847.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3848.1">auto</span></span><span class="koboSpan" id="kobo.3849.1"> filename2 {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3850.1">R"(C:\\Users\\Marius\\Documents\\)"</span></span><span class="koboSpan" id="kobo.3851.1">s};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3852.1">// prints C:\Users\Marius\Documents\</span></span><span class="koboSpan" id="kobo.3853.1">
std::cout &lt;&lt; filename1 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3854.1">'\n'</span></span><span class="koboSpan" id="kobo.3855.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3856.1">// prints C:\\Users\\Marius\\Documents\\</span></span><span class="koboSpan" id="kobo.3857.1">
std::cout &lt;&lt; filename2 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3858.1">'\n'</span></span><span class="koboSpan" id="kobo.3859.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3860.1">If the text</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.3861.1"> has to contain the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3862.1">)"</span></code><span class="koboSpan" id="kobo.3863.1"> sequence, then a different delimiter must be used, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3864.1">R"delimiter( literal )delimiter"</span></code><span class="koboSpan" id="kobo.3865.1"> form. </span><span class="koboSpan" id="kobo.3865.2">According to the standard, the possible characters in a delimiter can be as follows:</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.3866.1">Any member of the basic source character set except: space, the left parenthesis (the right parenthesis ), the backslash \, and the control characters representing horizontal tab, vertical tab, form feed, and newline.</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.3867.1">Raw string literals can be prefixed by one of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3868.1">L</span></code><span class="koboSpan" id="kobo.3869.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3870.1">u8</span></code><span class="koboSpan" id="kobo.3871.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3872.1">u</span></code><span class="koboSpan" id="kobo.3873.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3874.1">U</span></code><span class="koboSpan" id="kobo.3875.1"> to indicate a wide, UTF-8, UTF-16, or UTF-32 string literal, respectively. </span><span class="koboSpan" id="kobo.3875.2">The following are examples of such string literals:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3876.1">auto</span></span><span class="koboSpan" id="kobo.3877.1"> t1{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3878.1">LR"(text)"</span></span><span class="koboSpan" id="kobo.3879.1">  };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3880.1">// const wchar_t*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3881.1">auto</span></span><span class="koboSpan" id="kobo.3882.1"> t2{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3883.1">u8R"(text)"</span></span><span class="koboSpan" id="kobo.3884.1"> };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3885.1">// const char* until C++20</span></span>
<span class="hljs-keyword"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3886.1">// const char8_t* in C++20</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3887.1">auto</span></span><span class="koboSpan" id="kobo.3888.1"> t3{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3889.1">uR"(text)"</span></span><span class="koboSpan" id="kobo.3890.1">  };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3891.1">// const char16_t*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3892.1">auto</span></span><span class="koboSpan" id="kobo.3893.1"> t4{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3894.1">UR"(text)"</span></span><span class="koboSpan" id="kobo.3895.1">  };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3896.1">// const char32_t*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3897.1">auto</span></span><span class="koboSpan" id="kobo.3898.1"> t5{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3899.1">LR"(text)"</span></span><span class="koboSpan" id="kobo.3900.1">s  }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3901.1">// std::wstring</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3902.1">auto</span></span><span class="koboSpan" id="kobo.3903.1"> t6{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3904.1">u8R"(text)"</span></span><span class="koboSpan" id="kobo.3905.1">s }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3906.1">// std::string until C++20</span></span>
<span class="hljs-keyword"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3907.1">// std::u8string in C++20</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3908.1">auto</span></span><span class="koboSpan" id="kobo.3909.1"> t7{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3910.1">uR"(text)"</span></span><span class="koboSpan" id="kobo.3911.1">s  }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3912.1">// std::u16string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3913.1">auto</span></span><span class="koboSpan" id="kobo.3914.1"> t8{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3915.1">UR"(text)"</span></span><span class="koboSpan" id="kobo.3916.1">s  }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3917.1">// std::u32string</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3918.1">Note that the presence of the suffix </span><code class="inlineCode"><span class="koboSpan" id="kobo.3919.1">""s</span></code><span class="koboSpan" id="kobo.3920.1"> at the end of the string makes the compiler deduce the type </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.3921.1">as various string </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.3922.1">classes and not character arrays.</span></p>
<h2 class="heading-2" id="_idParaDest-135"><span class="koboSpan" id="kobo.3923.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3924.1">Creating cooked user-defined literals</span></em><span class="koboSpan" id="kobo.3925.1">, to learn how to create literals of user-defined types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3926.1">Understanding the various character and string types</span></em><span class="koboSpan" id="kobo.3927.1">, to learn more about character and string types, literal prefixes, and the changes in C++20 concerning the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3928.1">u8</span></code><span class="koboSpan" id="kobo.3929.1"> prefix</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-136"><span class="koboSpan" id="kobo.3930.1">Creating a library of string helpers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3931.1">The</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.3932.1"> string types from the standard library are a general-purpose implementation that lacks many helpful methods, such as changing the case, trimming, splitting, and others that may address different developer needs. </span><span class="koboSpan" id="kobo.3932.2">Third-party libraries that provide rich sets of string functionalities exist. </span><span class="koboSpan" id="kobo.3932.3">However, in this recipe, we will look at implementing several simple, yet helpful, methods you may often need in practice. </span><span class="koboSpan" id="kobo.3932.4">The purpose is to see how string methods and standard general algorithms can be used for manipulating strings but also to have a reference to reusable code that can be used in your applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3933.1">In this recipe, we will implement a small library of string utilities that will provide functions for the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3934.1">Changing a string into lowercase or uppercase</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3935.1">Reversing a string</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3936.1">Trimming white spaces from the beginning and/or the end of the string</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3937.1">Trimming a specific set of characters from the beginning and/or the end of the string</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3938.1">Removing occurrences of a character anywhere in the string</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3939.1">Tokenizing a string using a specific delimiter</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3940.1">Before we start with the implementation, let’s look at some prerequisites.</span></p>
<h2 class="heading-2" id="_idParaDest-137"><span class="koboSpan" id="kobo.3941.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3942.1">The string library we will be implementing should work with all the standard string types – that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3943.1">std::string</span></code><span class="koboSpan" id="kobo.3944.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3945.1">std::wstring</span></code><span class="koboSpan" id="kobo.3946.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3947.1">std::u16string</span></code><span class="koboSpan" id="kobo.3948.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3949.1">std::u32string</span></code><span class="koboSpan" id="kobo.3950.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3951.1">To avoid specifying long names such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3952.1">std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;, std::allocator&lt;CharT&gt;&gt;</span></code><span class="koboSpan" id="kobo.3953.1">, we will use the following alias templates for</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.3954.1"> strings and string streams:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3955.1">template</span></span><span class="koboSpan" id="kobo.3956.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3957.1">typename</span></span><span class="koboSpan" id="kobo.3958.1"> CharT&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3959.1">using</span></span><span class="koboSpan" id="kobo.3960.1"> tstring =
  std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;,
                    std::allocator&lt;CharT&gt;&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3961.1">template</span></span><span class="koboSpan" id="kobo.3962.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3963.1">typename</span></span><span class="koboSpan" id="kobo.3964.1"> CharT&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3965.1">using</span></span><span class="koboSpan" id="kobo.3966.1"> tstringstream =
  std::basic_stringstream&lt;CharT, std::char_traits&lt;CharT&gt;,
                          std::allocator&lt;CharT&gt;&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3967.1">To implement these string helper functions, we need to include the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.3968.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.3969.1"> for strings and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3970.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.3971.1"> for the general standard algorithms we will use.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3972.1">In all the examples in this recipe, we will use the standard user-defined literal operators for strings from C++14, for which we need to explicitly use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3973.1">std::string_literals</span></code><span class="koboSpan" id="kobo.3974.1"> namespace.</span></p>
<h2 class="heading-2" id="_idParaDest-138"><span class="koboSpan" id="kobo.3975.1">How to do it...</span></h2>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3976.1">To convert a string to lowercase or uppercase, apply the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3977.1">tolower()</span></code><span class="koboSpan" id="kobo.3978.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3979.1">toupper()</span></code><span class="koboSpan" id="kobo.3980.1"> functions to the characters of a string using the general-purpose algorithm </span><code class="inlineCode"><span class="koboSpan" id="kobo.3981.1">std::transform()</span></code><span class="koboSpan" id="kobo.3982.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3983.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3984.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3985.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3986.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3987.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3988.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3989.1">to_upper</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3990.1">(tstring&lt;CharT&gt; text)</span></span><span class="koboSpan" id="kobo.3991.1">
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3992.1">transform</span></span><span class="koboSpan" id="kobo.3993.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3994.1">begin</span></span><span class="koboSpan" id="kobo.3995.1">(text), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3996.1">end</span></span><span class="koboSpan" id="kobo.3997.1">(text),
                 std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3998.1">begin</span></span><span class="koboSpan" id="kobo.3999.1">(text), toupper);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4000.1">return</span></span><span class="koboSpan" id="kobo.4001.1"> text;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4002.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4003.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4004.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4005.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4006.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4007.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4008.1">to_lower</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4009.1">(tstring&lt;CharT&gt; text)</span></span><span class="koboSpan" id="kobo.4010.1">
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4011.1">transform</span></span><span class="koboSpan" id="kobo.4012.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4013.1">begin</span></span><span class="koboSpan" id="kobo.4014.1">(text), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4015.1">end</span></span><span class="koboSpan" id="kobo.4016.1">(text),
                 std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4017.1">begin</span></span><span class="koboSpan" id="kobo.4018.1">(text), tolower);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4019.1">return</span></span><span class="koboSpan" id="kobo.4020.1"> text;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4021.1">To reverse a string, use the general-purpose algorithm </span><code class="inlineCode"><span class="koboSpan" id="kobo.4022.1">std::reverse()</span></code><span class="koboSpan" id="kobo.4023.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4024.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4025.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4026.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4027.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4028.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4029.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4030.1">reverse</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4031.1">(tstring&lt;CharT&gt; text)</span></span><span class="koboSpan" id="kobo.4032.1">
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4033.1">reverse</span></span><span class="koboSpan" id="kobo.4034.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4035.1">begin</span></span><span class="koboSpan" id="kobo.4036.1">(text), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4037.1">end</span></span><span class="koboSpan" id="kobo.4038.1">(text));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4039.1">return</span></span><span class="koboSpan" id="kobo.4040.1"> text;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4041.1">To trim</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.4042.1"> a string at the beginning, end, or both, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4043.1">std::basic_string</span></code><span class="koboSpan" id="kobo.4044.1"> methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.4045.1">find_first_not_of()</span></code><span class="koboSpan" id="kobo.4046.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4047.1">find_last_not_of()</span></code><span class="koboSpan" id="kobo.4048.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4049.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4050.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4051.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4052.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4053.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4054.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4055.1">trim</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4056.1">(tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4057.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4058.1"> &amp; text)</span></span><span class="koboSpan" id="kobo.4059.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4060.1">auto</span></span><span class="koboSpan" id="kobo.4061.1"> first{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4062.1">find_first_not_of</span></span><span class="koboSpan" id="kobo.4063.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4064.1">' '</span></span><span class="koboSpan" id="kobo.4065.1">) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4066.1">auto</span></span><span class="koboSpan" id="kobo.4067.1"> last{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4068.1">find_last_not_of</span></span><span class="koboSpan" id="kobo.4069.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4070.1">' '</span></span><span class="koboSpan" id="kobo.4071.1">) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4072.1">return</span></span><span class="koboSpan" id="kobo.4073.1"> text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4074.1">substr</span></span><span class="koboSpan" id="kobo.4075.1">(first, (last - first + </span><span class="hljs-number"><span class="koboSpan" id="kobo.4076.1">1</span></span><span class="koboSpan" id="kobo.4077.1">));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4078.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4079.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4080.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4081.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4082.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4083.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4084.1">trimleft</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4085.1">(tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4086.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4087.1"> &amp; text)</span></span><span class="koboSpan" id="kobo.4088.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4089.1">auto</span></span><span class="koboSpan" id="kobo.4090.1"> first{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4091.1">find_first_not_of</span></span><span class="koboSpan" id="kobo.4092.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4093.1">' '</span></span><span class="koboSpan" id="kobo.4094.1">) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4095.1">return</span></span><span class="koboSpan" id="kobo.4096.1"> text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4097.1">substr</span></span><span class="koboSpan" id="kobo.4098.1">(first, text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4099.1">size</span></span><span class="koboSpan" id="kobo.4100.1">() - first);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4101.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4102.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4103.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4104.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4105.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4106.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4107.1">trimright</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4108.1">(tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4109.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4110.1"> &amp; text)</span></span><span class="koboSpan" id="kobo.4111.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4112.1">auto</span></span><span class="koboSpan" id="kobo.4113.1"> last{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4114.1">find_last_not_of</span></span><span class="koboSpan" id="kobo.4115.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4116.1">' '</span></span><span class="koboSpan" id="kobo.4117.1">) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4118.1">return</span></span><span class="koboSpan" id="kobo.4119.1"> text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4120.1">substr</span></span><span class="koboSpan" id="kobo.4121.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4122.1">0</span></span><span class="koboSpan" id="kobo.4123.1">, last + </span><span class="hljs-number"><span class="koboSpan" id="kobo.4124.1">1</span></span><span class="koboSpan" id="kobo.4125.1">);
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4126.1">To trim characters in a given set from a string, use overloads of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4127.1">std::basic_string</span></code><span class="koboSpan" id="kobo.4128.1"> methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.4129.1">find_first_not_of()</span></code><span class="koboSpan" id="kobo.4130.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4131.1">find_last_not_of()</span></code><span class="koboSpan" id="kobo.4132.1">, which take a string parameter that defines the set of characters to look for:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4133.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4134.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4135.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4136.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4137.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4138.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4139.1">trim</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4140.1">(tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4141.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4142.1"> &amp; text,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4143.1">                           tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4144.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4145.1"> &amp; chars)</span></span><span class="koboSpan" id="kobo.4146.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4147.1">auto</span></span><span class="koboSpan" id="kobo.4148.1"> first{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4149.1">find_first_not_of</span></span><span class="koboSpan" id="kobo.4150.1">(chars) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4151.1">auto</span></span><span class="koboSpan" id="kobo.4152.1"> last{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4153.1">find_last_not_of</span></span><span class="koboSpan" id="kobo.4154.1">(chars) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4155.1">return</span></span><span class="koboSpan" id="kobo.4156.1"> text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4157.1">substr</span></span><span class="koboSpan" id="kobo.4158.1">(first, (last - first + </span><span class="hljs-number"><span class="koboSpan" id="kobo.4159.1">1</span></span><span class="koboSpan" id="kobo.4160.1">));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4161.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4162.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4163.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4164.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4165.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4166.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4167.1">trimleft</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4168.1">(tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4169.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4170.1"> &amp; text,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4171.1">                               tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4172.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4173.1"> &amp; chars)</span></span><span class="koboSpan" id="kobo.4174.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4175.1">auto</span></span><span class="koboSpan" id="kobo.4176.1"> first{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4177.1">find_first_not_of</span></span><span class="koboSpan" id="kobo.4178.1">(chars) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4179.1">return</span></span><span class="koboSpan" id="kobo.4180.1"> text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4181.1">substr</span></span><span class="koboSpan" id="kobo.4182.1">(first, text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4183.1">size</span></span><span class="koboSpan" id="kobo.4184.1">() - first);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4185.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4186.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4187.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4188.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4189.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4190.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4191.1">trimright</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4192.1">(tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4193.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4194.1"> &amp;text,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4195.1">                                tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4196.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4197.1"> &amp;chars)</span></span><span class="koboSpan" id="kobo.4198.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4199.1">auto</span></span><span class="koboSpan" id="kobo.4200.1"> last{ text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4201.1">find_last_not_of</span></span><span class="koboSpan" id="kobo.4202.1">(chars) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4203.1">return</span></span><span class="koboSpan" id="kobo.4204.1"> text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4205.1">substr</span></span><span class="koboSpan" id="kobo.4206.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4207.1">0</span></span><span class="koboSpan" id="kobo.4208.1">, last + </span><span class="hljs-number"><span class="koboSpan" id="kobo.4209.1">1</span></span><span class="koboSpan" id="kobo.4210.1">);
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4211.1">To remove</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.4212.1"> characters from a string, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4213.1">std::remove_if()</span></code><span class="koboSpan" id="kobo.4214.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4215.1">std::basic_string::erase()</span></code><span class="koboSpan" id="kobo.4216.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4217.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4218.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4219.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4220.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4221.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4222.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4223.1">remove</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4224.1">(tstring&lt;CharT&gt; text,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4225.1">                             CharT </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4226.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4227.1"> ch)</span></span><span class="koboSpan" id="kobo.4228.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4229.1">auto</span></span><span class="koboSpan" id="kobo.4230.1"> start = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4231.1">remove_if</span></span><span class="koboSpan" id="kobo.4232.1">(
                  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4233.1">begin</span></span><span class="koboSpan" id="kobo.4234.1">(text), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4235.1">end</span></span><span class="koboSpan" id="kobo.4236.1">(text),
                  [=](CharT </span><span class="hljs-type"><span class="koboSpan" id="kobo.4237.1">const</span></span><span class="koboSpan" id="kobo.4238.1"> c) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4239.1">return</span></span><span class="koboSpan" id="kobo.4240.1"> c == ch; });
  text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4241.1">erase</span></span><span class="koboSpan" id="kobo.4242.1">(start, std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4243.1">end</span></span><span class="koboSpan" id="kobo.4244.1">(text));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4245.1">return</span></span><span class="koboSpan" id="kobo.4246.1"> text;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4247.1">To split a string based on a specified delimiter, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4248.1">std::getline()</span></code><span class="koboSpan" id="kobo.4249.1"> to read from an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4250.1">std::basic_stringstream</span></code><span class="koboSpan" id="kobo.4251.1"> initialized with the content of the string. </span><span class="koboSpan" id="kobo.4251.2">The tokens extracted from the stream are pushed into a vector of strings:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4252.1">template</span></span><span class="koboSpan" id="kobo.4253.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4254.1">typename</span></span><span class="koboSpan" id="kobo.4255.1"> CharT&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4256.1">inline</span></span><span class="koboSpan" id="kobo.4257.1"> std::vector&lt;tstring&lt;CharT&gt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4258.1">split</span></span><span class="koboSpan" id="kobo.4259.1">
  (tstring&lt;CharT&gt; text, CharT </span><span class="hljs-type"><span class="koboSpan" id="kobo.4260.1">const</span></span><span class="koboSpan" id="kobo.4261.1"> delimiter)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4262.1">auto</span></span><span class="koboSpan" id="kobo.4263.1"> sstr = tstringstream&lt;CharT&gt;{ text };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4264.1">auto</span></span><span class="koboSpan" id="kobo.4265.1"> tokens = std::vector&lt;tstring&lt;CharT&gt;&gt;{};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4266.1">auto</span></span><span class="koboSpan" id="kobo.4267.1"> token = tstring&lt;CharT&gt;{};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4268.1">while</span></span><span class="koboSpan" id="kobo.4269.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4270.1">getline</span></span><span class="koboSpan" id="kobo.4271.1">(sstr, token, delimiter))
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4272.1">if</span></span><span class="koboSpan" id="kobo.4273.1"> (!token.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4274.1">empty</span></span><span class="koboSpan" id="kobo.4275.1">()) tokens.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4276.1">push_back</span></span><span class="koboSpan" id="kobo.4277.1">(token);
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4278.1">return</span></span><span class="koboSpan" id="kobo.4279.1"> tokens;
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-139"><span class="koboSpan" id="kobo.4280.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4281.1">To implement</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.4282.1"> the utility functions from the library, we have two options:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4283.1">Functions will modify a string passed by a reference</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4284.1">Functions will not alter the original string but, instead, return a new string</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4285.1">The second option has the advantage that it preserves the original string, which may be helpful in many cases. </span><span class="koboSpan" id="kobo.4285.2">Otherwise, in those cases, you would first have to make a copy of the string and alter the copy. </span><span class="koboSpan" id="kobo.4285.3">The implementation provided in this recipe takes the second approach.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4286.1">The first functions we implemented in the </span><em class="italic"><span class="koboSpan" id="kobo.4287.1">How to do it...</span></em><span class="koboSpan" id="kobo.4288.1"> section were </span><code class="inlineCode"><span class="koboSpan" id="kobo.4289.1">to_upper()</span></code><span class="koboSpan" id="kobo.4290.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4291.1">to_lower()</span></code><span class="koboSpan" id="kobo.4292.1">. </span><span class="koboSpan" id="kobo.4292.2">These functions change the content of a string either to uppercase or lowercase. </span><span class="koboSpan" id="kobo.4292.3">The simplest way to implement this is by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4293.1">std::transform()</span></code><span class="koboSpan" id="kobo.4294.1"> standard algorithm. </span><span class="koboSpan" id="kobo.4294.2">This is a general-purpose algorithm that applies a function to every element of a range (defined by a begin and end iterator) and stores the result in another range for which only the begin iterator needs to be specified. </span><span class="koboSpan" id="kobo.4294.3">The output range can be the same as the input range, which is exactly what we did to transform the string. </span><span class="koboSpan" id="kobo.4294.4">The applied function is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4295.1">toupper()</span></code><span class="koboSpan" id="kobo.4296.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4297.1">tolower()</span></code><span class="koboSpan" id="kobo.4298.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4299.1">auto</span></span><span class="koboSpan" id="kobo.4300.1"> ut{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4301.1">to_upper</span></span><span class="koboSpan" id="kobo.4302.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4303.1">"this is not UPPERCASE"</span></span><span class="koboSpan" id="kobo.4304.1">s) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4305.1">// ut = "THIS IS NOT UPPERCASE"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4306.1">auto</span></span><span class="koboSpan" id="kobo.4307.1"> lt{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4308.1">to_lower</span></span><span class="koboSpan" id="kobo.4309.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4310.1">"THIS IS NOT lowercase"</span></span><span class="koboSpan" id="kobo.4311.1">s) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4312.1">// lt = "this is not lowercase"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4313.1">The </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.4314.1">next function we considered was </span><code class="inlineCode"><span class="koboSpan" id="kobo.4315.1">reverse()</span></code><span class="koboSpan" id="kobo.4316.1">, which, as the name implies, reverses the content of a string. </span><span class="koboSpan" id="kobo.4316.2">For this, we used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4317.1">std::reverse()</span></code><span class="koboSpan" id="kobo.4318.1"> standard algorithm. </span><span class="koboSpan" id="kobo.4318.2">This general-purpose algorithm reverses the elements of a range defined by a begin and end iterator:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4319.1">auto</span></span><span class="koboSpan" id="kobo.4320.1"> rt{string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4321.1">reverse</span></span><span class="koboSpan" id="kobo.4322.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4323.1">"cookbook"</span></span><span class="koboSpan" id="kobo.4324.1">s)}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4325.1">// rt = "koobkooc"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4326.1">When it comes to trimming, a string can be trimmed at the beginning, end, or both sides. </span><span class="koboSpan" id="kobo.4326.2">For that reason, we implemented three different functions: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4327.1">trim()</span></code><span class="koboSpan" id="kobo.4328.1"> for trimming at both ends, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4329.1">trimleft()</span></code><span class="koboSpan" id="kobo.4330.1"> for trimming at the beginning of a string, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4331.1">trimright()</span></code><span class="koboSpan" id="kobo.4332.1"> for trimming at the end of a string. </span><span class="koboSpan" id="kobo.4332.2">The first version of the function trims only spaces. </span><span class="koboSpan" id="kobo.4332.3">In order to find the right part to trim, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4333.1">find_first_not_of()</span></code><span class="koboSpan" id="kobo.4334.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4335.1">find_last_not_of()</span></code><span class="koboSpan" id="kobo.4336.1"> methods of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4337.1">std::basic_string</span></code><span class="koboSpan" id="kobo.4338.1">. </span><span class="koboSpan" id="kobo.4338.2">These return the first and last characters in the string that are not of the specified character. </span><span class="koboSpan" id="kobo.4338.3">Subsequently, a call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4339.1">substr()</span></code><span class="koboSpan" id="kobo.4340.1"> method of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4341.1">std::basic_string</span></code><span class="koboSpan" id="kobo.4342.1"> returns a new string. </span><span class="koboSpan" id="kobo.4342.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4343.1">substr()</span></code><span class="koboSpan" id="kobo.4344.1"> method takes an index in the string and a number of elements to copy to the new string:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4345.1">auto</span></span><span class="koboSpan" id="kobo.4346.1"> text1{</span><span class="hljs-string"><span class="koboSpan" id="kobo.4347.1">"   this is an example   "</span></span><span class="koboSpan" id="kobo.4348.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4349.1">auto</span></span><span class="koboSpan" id="kobo.4350.1"> t1{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4351.1">trim</span></span><span class="koboSpan" id="kobo.4352.1">(text1) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4353.1">// t1 = "this is an example"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4354.1">auto</span></span><span class="koboSpan" id="kobo.4355.1"> t2{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4356.1">trimleft</span></span><span class="koboSpan" id="kobo.4357.1">(text1) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4358.1">// t2 = "this is an example   "</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4359.1">auto</span></span><span class="koboSpan" id="kobo.4360.1"> t3{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4361.1">trimright</span></span><span class="koboSpan" id="kobo.4362.1">(text1) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4363.1">// t3 = "   this is an example"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4364.1">Sometimes, it can be useful to trim other characters and then spaces from a string. </span><span class="koboSpan" id="kobo.4364.2">In order to do that, we provided overloads for the trimming functions that specify a set of characters to be removed. </span><span class="koboSpan" id="kobo.4364.3">That set is also specified as a string. </span><span class="koboSpan" id="kobo.4364.4">The implementation is very similar to the previous one because both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4365.1">find_first_not_of()</span></code><span class="koboSpan" id="kobo.4366.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4367.1">find_last_not_of()</span></code><span class="koboSpan" id="kobo.4368.1"> have overloads that take a string containing the characters to be excluded from the search:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4369.1">auto</span></span><span class="koboSpan" id="kobo.4370.1"> chars1{</span><span class="hljs-string"><span class="koboSpan" id="kobo.4371.1">" !%\n\r"</span></span><span class="koboSpan" id="kobo.4372.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4373.1">auto</span></span><span class="koboSpan" id="kobo.4374.1"> text3{</span><span class="hljs-string"><span class="koboSpan" id="kobo.4375.1">"!!  </span><span class="koboSpan" id="kobo.4375.2">this % needs a lot\rof trimming  !\n"</span></span><span class="koboSpan" id="kobo.4376.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4377.1">auto</span></span><span class="koboSpan" id="kobo.4378.1"> t7{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4379.1">trim</span></span><span class="koboSpan" id="kobo.4380.1">(text3, chars1) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4381.1">// t7 = "this % needs a lot\rof trimming"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4382.1">auto</span></span><span class="koboSpan" id="kobo.4383.1"> t8{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4384.1">trimleft</span></span><span class="koboSpan" id="kobo.4385.1">(text3, chars1) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4386.1">// t8 = "this % needs a lot\rof trimming  !\n"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4387.1">auto</span></span><span class="koboSpan" id="kobo.4388.1"> t9{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4389.1">trimright</span></span><span class="koboSpan" id="kobo.4390.1">(text3, chars1) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4391.1">// t9 = "!!  </span><span class="koboSpan" id="kobo.4391.2">this % needs a lot\rof trimming"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4392.1">If </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.4393.1">removing characters from any part of the string is necessary, the trimming methods are not helpful because they only treat a contiguous sequence of characters at the start and end of a string. </span><span class="koboSpan" id="kobo.4393.2">For that, however, we implemented a simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.4394.1">remove()</span></code><span class="koboSpan" id="kobo.4395.1"> method. </span><span class="koboSpan" id="kobo.4395.2">This uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4396.1">std:remove_if()</span></code><span class="koboSpan" id="kobo.4397.1"> standard algorithm.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4398.1">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4399.1">std::remove()</span></code><span class="koboSpan" id="kobo.4400.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4401.1">std::remove_if()</span></code><span class="koboSpan" id="kobo.4402.1"> work in a way that may not be very intuitive at first. </span><span class="koboSpan" id="kobo.4402.2">They remove elements that satisfy the criteria from a range defined by a first and last iterator by rearranging the content of the range (using move assignment). </span><span class="koboSpan" id="kobo.4402.3">The elements that need to be removed are placed at the end of the range, and the function returns an iterator to the first element in the range that represents the removed elements. </span><span class="koboSpan" id="kobo.4402.4">This iterator basically defines the new end of the range that was modified. </span><span class="koboSpan" id="kobo.4402.5">If no element was removed, the returned iterator is the end iterator of the original range. </span><span class="koboSpan" id="kobo.4402.6">The value of this returned iterator is then used to call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4403.1">std::basic_string::erase()</span></code><span class="koboSpan" id="kobo.4404.1"> method, which actually erases the content of the string defined by two iterators. </span><span class="koboSpan" id="kobo.4404.2">The two iterators in our case are the iterator returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.4405.1">std::remove_if()</span></code><span class="koboSpan" id="kobo.4406.1"> and the end of the string:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4407.1">auto</span></span><span class="koboSpan" id="kobo.4408.1"> text4{</span><span class="hljs-string"><span class="koboSpan" id="kobo.4409.1">"must remove all * from text**"</span></span><span class="koboSpan" id="kobo.4410.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4411.1">auto</span></span><span class="koboSpan" id="kobo.4412.1"> t10{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4413.1">remove</span></span><span class="koboSpan" id="kobo.4414.1">(text4, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4415.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4416.1">*'</span></span><span class="koboSpan" id="kobo.4417.1">) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4418.1">// t10 = "must remove all  from text"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4419.1">auto</span></span><span class="koboSpan" id="kobo.4420.1"> t11{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4421.1">remove</span></span><span class="koboSpan" id="kobo.4422.1">(text4, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4423.1">'!'</span></span><span class="koboSpan" id="kobo.4424.1">) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4425.1">// t11 = "must remove all * from text**"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4426.1">The last method we implemented, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4427.1">split()</span></code><span class="koboSpan" id="kobo.4428.1">, splits the content of a string based on a specified delimiter. </span><span class="koboSpan" id="kobo.4428.2">There are various ways to implement this. </span><span class="koboSpan" id="kobo.4428.3">In this implementation, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.4429.1">std::getline()</span></code><span class="koboSpan" id="kobo.4430.1">. </span><span class="koboSpan" id="kobo.4430.2">This function reads characters from an input stream until a specified delimiter is found and places the characters in a string. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4431.1">Before starting to read from the input buffer, it calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.4432.1">erase()</span></code><span class="koboSpan" id="kobo.4433.1"> on the output string to clear its content. </span><span class="koboSpan" id="kobo.4433.2">Calling this method in a loop produces tokens that are placed in a vector. </span><span class="koboSpan" id="kobo.4433.3">In our implementation, empty tokens were skipped from the result set:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4434.1">auto</span></span><span class="koboSpan" id="kobo.4435.1"> text5{</span><span class="hljs-string"><span class="koboSpan" id="kobo.4436.1">"this text will be split   "</span></span><span class="koboSpan" id="kobo.4437.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4438.1">auto</span></span><span class="koboSpan" id="kobo.4439.1"> tokens1{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4440.1">split</span></span><span class="koboSpan" id="kobo.4441.1">(text5, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4442.1">' '</span></span><span class="koboSpan" id="kobo.4443.1">) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4444.1">// tokens1 = {"this", "text", "will", "be", "split"}</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4445.1">auto</span></span><span class="koboSpan" id="kobo.4446.1"> tokens2{ string_library::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4447.1">split</span></span><span class="koboSpan" id="kobo.4448.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4449.1">""</span></span><span class="koboSpan" id="kobo.4450.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4451.1">' '</span></span><span class="koboSpan" id="kobo.4452.1">) };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4453.1">// tokens2 = {}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4454.1">Two examples</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.4455.1"> of text splitting are shown here. </span><span class="koboSpan" id="kobo.4455.2">In the first example, the text from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4456.1">text5</span></code><span class="koboSpan" id="kobo.4457.1"> variable is split into words and, as mentioned earlier, empty tokens are ignored. </span><span class="koboSpan" id="kobo.4457.2">In the second example, splitting an empty string produces an empty vector of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4458.1">token</span></code><span class="koboSpan" id="kobo.4459.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-140"><span class="koboSpan" id="kobo.4460.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4461.1">Several helper methods have been added to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4462.1">std::basic_string</span></code><span class="koboSpan" id="kobo.4463.1"> class template in recent versions of the standard to help users avoid defining some widely used functions. </span><span class="koboSpan" id="kobo.4463.2">These are listed in the following table:</span></p>
<table class="table-container" id="table013">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4464.1">Function</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4465.1">C++ version</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4466.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4467.1">starts_with</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4468.1">C++20</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4469.1">Checks whether the string starts with the specified prefix </span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4470.1">ends_with</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4471.1">C++20</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4472.1">Checks whether the string ends with the specified suffix</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4473.1">contains</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4474.1">C++23</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4475.1">Checks whether the string contains the specified substring</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4476.1">Table 2.13: Newer basic_string member functions for widely-used string operations</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4477.1">The use of these member functions is exemplified in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4478.1">std::string text = "The Lord of the Rings";
if(text.starts_with("The")) {}
if(text.ends_with("Rings")) {}
if(text.contains("Lord")) {}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-141"><span class="koboSpan" id="kobo.4479.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4480.1">Creating cooked user-defined literals</span></em><span class="koboSpan" id="kobo.4481.1">, to learn how to create literals of user-defined types</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.4482.1">Chapter 1</span></em><span class="koboSpan" id="kobo.4483.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4484.1">Creating type aliases and alias templates</span></em><span class="koboSpan" id="kobo.4485.1">, to learn about aliases for types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-142"><span class="koboSpan" id="kobo.4486.1">Verifying the format of a string using regular expressions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4487.1">Regular expressions </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.4488.1">are a language intended for performing pattern matching and replacements in texts. </span><span class="koboSpan" id="kobo.4488.2">C++11 provides support for regular expressions </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.4489.1">within the standard library through a set of classes, algorithms, and iterators available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4490.1">&lt;regex&gt;</span></code><span class="koboSpan" id="kobo.4491.1"> header. </span><span class="koboSpan" id="kobo.4491.2">In this recipe, we will learn how regular expressions can be used to verify that a string matches a pattern (examples include verifying an email or IP address format).</span></p>
<h2 class="heading-2" id="_idParaDest-143"><span class="koboSpan" id="kobo.4492.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4493.1">Throughout</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.4494.1"> this recipe, we will explain, whenever necessary, the details of the regular expressions that we use. </span><span class="koboSpan" id="kobo.4494.2">However, you should have at least some basic knowledge of regular expressions in order to use the C++ standard library for regular expressions. </span><span class="koboSpan" id="kobo.4494.3">A description of regular expression syntax and standards is beyond the purpose of this book; if you are not familiar with regular expressions, it is recommended that you read more about them before continuing with this, and the other recipes that focus on regular expressions. </span><span class="koboSpan" id="kobo.4494.4">Good online resources for learning, building, and debugging regular expressions can be found at </span><a href="https://regexr.com"><span class="url"><span class="koboSpan" id="kobo.4495.1">https://regexr.com</span></span></a><span class="koboSpan" id="kobo.4496.1"> and </span><a href="https://regex101.com"><span class="url"><span class="koboSpan" id="kobo.4497.1">https://regex101.com</span></span></a><span class="koboSpan" id="kobo.4498.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-144"><span class="koboSpan" id="kobo.4499.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4500.1">In order to verify that a string matches a regular expression, perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.4501.1">Include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4502.1">&lt;regex&gt;</span></code><span class="koboSpan" id="kobo.4503.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4504.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.4505.1"> headers and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4506.1">std::string_literals</span></code><span class="koboSpan" id="kobo.4507.1"> namespace for standard user-defined literals for strings (added in C++14):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.4508.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4509.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.4510.1">&lt;regex&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.4511.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4512.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.4513.1">&lt;string&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4514.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4515.1">namespace</span></span><span class="koboSpan" id="kobo.4516.1"> std::string_literals;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4517.1">Use</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.4518.1"> raw string literals to specify the regular expression to avoid escaping backslashes (which can occur frequently). </span><span class="koboSpan" id="kobo.4518.2">The following regular expression validates most email formats:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4519.1">auto</span></span><span class="koboSpan" id="kobo.4520.1"> pattern {</span><span class="hljs-string"><span class="koboSpan" id="kobo.4521.1">R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"</span></span><span class="koboSpan" id="kobo.4522.1">s};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4523.1">Create </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.4524.1">an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4525.1">std::regex</span></code><span class="koboSpan" id="kobo.4526.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.4527.1">std::wregex</span></code><span class="koboSpan" id="kobo.4528.1"> object (depending on the character set that is used) to encapsulate the regular expression:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4529.1">auto</span></span><span class="koboSpan" id="kobo.4530.1"> rx = std::regex{pattern};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4531.1">To ignore casing or specify other parsing options, use an overloaded constructor that has an extra parameter for regular expression flags:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4532.1">auto</span></span><span class="koboSpan" id="kobo.4533.1"> rx = std::regex{pattern, std::regex_constants::icase};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4534.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4535.1">std::regex_match()</span></code><span class="koboSpan" id="kobo.4536.1"> to match the regular expression with an entire string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4537.1">auto</span></span><span class="koboSpan" id="kobo.4538.1"> valid = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4539.1">regex_match</span></span><span class="koboSpan" id="kobo.4540.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4541.1">"marius@domain.com"</span></span><span class="koboSpan" id="kobo.4542.1">s, rx);
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-145"><span class="koboSpan" id="kobo.4543.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4544.1">Considering the problem of verifying the format of email addresses, even though this may look like a trivial problem, in practice, it is hard to find a simple regular expression that covers all the possible cases for valid email formats. </span><span class="koboSpan" id="kobo.4544.2">In this recipe, we will not try to find that ultimate regular expression but, rather, apply a regular expression that is good enough for most cases. </span><span class="koboSpan" id="kobo.4544.3">The regular expression we will use for this purpose is this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4545.1">^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4546.1">The following table explains the structure of the regular expression:</span></p>
<table class="table-container" id="table014">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4547.1">Part</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4548.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4549.1">^</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4550.1">Start of string</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4551.1">[A-Z0-9._%+-]+</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4552.1">At least one character that is an uppercase letter, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4553.1">A-Z</span></code><span class="koboSpan" id="kobo.4554.1">, a digit </span><code class="inlineCode"><span class="koboSpan" id="kobo.4555.1">0-9</span></code><span class="koboSpan" id="kobo.4556.1">, or one of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4557.1">.</span></code><span class="koboSpan" id="kobo.4558.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4559.1">%</span></code><span class="koboSpan" id="kobo.4560.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4561.1">+</span></code><span class="koboSpan" id="kobo.4562.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4563.1">-</span></code><span class="koboSpan" id="kobo.4564.1">, which represents the local part of the email address</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4565.1">@</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4566.1">The character </span><code class="inlineCode"><span class="koboSpan" id="kobo.4567.1">@</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4568.1">[A-Z0-9.-]+</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4569.1">At least one character that is an uppercase letter </span><code class="inlineCode"><span class="koboSpan" id="kobo.4570.1">A-Z</span></code><span class="koboSpan" id="kobo.4571.1">, a digit </span><code class="inlineCode"><span class="koboSpan" id="kobo.4572.1">0-9</span></code><span class="koboSpan" id="kobo.4573.1">, or one of the symbols </span><code class="inlineCode"><span class="koboSpan" id="kobo.4574.1">.</span></code><span class="koboSpan" id="kobo.4575.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4576.1">-</span></code><span class="koboSpan" id="kobo.4577.1">, which represents the hostname of the domain part</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4578.1">\.</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4579.1">A dot that separates the domain hostname and label</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4580.1">[A-Z]{2,}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4581.1">The DNS label of a domain, which can have between 2 and 63 characters</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4582.1">$</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4583.1">End of the string</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4584.1">Table 2.14: The structure of the previously defined regular expression</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4585.1">Bear in </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.4586.1">mind that, in practice, a domain</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.4587.1"> name is composed of a hostname followed by a dot-separated list of DNS labels. </span><span class="koboSpan" id="kobo.4587.2">Examples include </span><code class="inlineCode"><span class="koboSpan" id="kobo.4588.1">localhost</span></code><span class="koboSpan" id="kobo.4589.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4590.1">gmail.com</span></code><span class="koboSpan" id="kobo.4591.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4592.1">yahoo.co.uk</span></code><span class="koboSpan" id="kobo.4593.1">. </span><span class="koboSpan" id="kobo.4593.2">This regular expression we are using does not match domains without DNS labels, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4594.1">localhost</span></code><span class="koboSpan" id="kobo.4595.1"> (an email address such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4596.1">root@localhost</span></code><span class="koboSpan" id="kobo.4597.1"> is a valid email address). </span><span class="koboSpan" id="kobo.4597.2">The domain name can also be an IP address specified in brackets, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4598.1">[192.168.100.11]</span></code><span class="koboSpan" id="kobo.4599.1"> (as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.4600.1">john.doe@[192.168.100.11]</span></code><span class="koboSpan" id="kobo.4601.1">). </span><span class="koboSpan" id="kobo.4601.2">Email addresses containing such domains will not match the regular expression defined previously. </span><span class="koboSpan" id="kobo.4601.3">Even though these rather rare formats will not be matched, the regular expression can cover most email formats.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.4602.1">The regular expression for the example in this chapter is provided for didactical purposes only and is not intended to be used as it is in production code. </span><span class="koboSpan" id="kobo.4602.2">As explained earlier, this sample does not cover all possible email formats.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.4603.1">We began by including the necessary headers – that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4604.1">&lt;regex&gt;</span></code><span class="koboSpan" id="kobo.4605.1"> for regular expressions and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4606.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.4607.1"> for strings. </span><span class="koboSpan" id="kobo.4607.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4608.1">is_valid_email()</span></code><span class="koboSpan" id="kobo.4609.1"> function, shown in the following code (which basically contains the samples from the </span><em class="italic"><span class="koboSpan" id="kobo.4610.1">How to do it...</span></em><span class="koboSpan" id="kobo.4611.1"> section), takes a string representing an email address and returns a Boolean indicating whether the email has a valid format or not.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4612.1">We first </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.4613.1">construct an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4614.1">std::regex</span></code><span class="koboSpan" id="kobo.4615.1"> object to encapsulate the regular expression indicated with the raw string literal. </span><span class="koboSpan" id="kobo.4615.2">Using</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.4616.1"> raw string literals is helpful because it avoids escaping backslashes, which are used for escape characters in regular expressions too. </span><span class="koboSpan" id="kobo.4616.2">The function then calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.4617.1">std::regex_match()</span></code><span class="koboSpan" id="kobo.4618.1">, passing the input text and the regular expression:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4619.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4620.1">is_valid_email_format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4621.1">(std::string </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4622.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4623.1"> &amp; email)</span></span><span class="koboSpan" id="kobo.4624.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4625.1">auto</span></span><span class="koboSpan" id="kobo.4626.1"> pattern {</span><span class="hljs-string"><span class="koboSpan" id="kobo.4627.1">R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"</span></span><span class="koboSpan" id="kobo.4628.1">s};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4629.1">auto</span></span><span class="koboSpan" id="kobo.4630.1"> rx = std::regex{ pattern };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4631.1">return</span></span><span class="koboSpan" id="kobo.4632.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4633.1">regex_match</span></span><span class="koboSpan" id="kobo.4634.1">(email, rx);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4635.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4636.1">std::regex_match()</span></code><span class="koboSpan" id="kobo.4637.1"> method tries to match the regular expression against the entire string. </span><span class="koboSpan" id="kobo.4637.2">If successful, it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.4638.1">true</span></code><span class="koboSpan" id="kobo.4639.1">; otherwise, it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.4640.1">false</span></code><span class="koboSpan" id="kobo.4641.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4642.1">auto</span></span><span class="koboSpan" id="kobo.4643.1"> ltest = [](std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.4644.1">const</span></span><span class="koboSpan" id="kobo.4645.1"> &amp; email)
{
  std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4646.1">setw</span></span><span class="koboSpan" id="kobo.4647.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4648.1">30</span></span><span class="koboSpan" id="kobo.4649.1">) &lt;&lt; std::left
            &lt;&lt; email &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4650.1">" : "</span></span><span class="koboSpan" id="kobo.4651.1">
            &lt;&lt; (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4652.1">is_valid_email_format</span></span><span class="koboSpan" id="kobo.4653.1">(email) ?
                </span><span class="hljs-string"><span class="koboSpan" id="kobo.4654.1">"valid format"</span></span><span class="koboSpan" id="kobo.4655.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4656.1">"invalid format"</span></span><span class="koboSpan" id="kobo.4657.1">)
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4658.1">'\n'</span></span><span class="koboSpan" id="kobo.4659.1">;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4660.1">ltest</span></span><span class="koboSpan" id="kobo.4661.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4662.1">"JOHN.DOE@DOMAIN.COM"</span></span><span class="koboSpan" id="kobo.4663.1">s);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4664.1">// valid format</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4665.1">ltest</span></span><span class="koboSpan" id="kobo.4666.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4667.1">"JOHNDOE@DOMAIL.CO.UK"</span></span><span class="koboSpan" id="kobo.4668.1">s);        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4669.1">// valid format</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4670.1">ltest</span></span><span class="koboSpan" id="kobo.4671.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4672.1">"JOHNDOE@DOMAIL.INFO"</span></span><span class="koboSpan" id="kobo.4673.1">s);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4674.1">// valid format</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4675.1">ltest</span></span><span class="koboSpan" id="kobo.4676.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4677.1">"J.O.H.N_D.O.E@DOMAIN.INFO"</span></span><span class="koboSpan" id="kobo.4678.1">s);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4679.1">// valid format</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4680.1">ltest</span></span><span class="koboSpan" id="kobo.4681.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4682.1">"ROOT@LOCALHOST"</span></span><span class="koboSpan" id="kobo.4683.1">s);              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4684.1">// invalid format</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4685.1">ltest</span></span><span class="koboSpan" id="kobo.4686.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4687.1">"john.doe@domain.com"</span></span><span class="koboSpan" id="kobo.4688.1">s);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4689.1">// invalid format</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4690.1">In this simple test, the only emails that do not match the regular expression are </span><code class="inlineCode"><span class="koboSpan" id="kobo.4691.1">ROOT@LOCALHOST</span></code><span class="koboSpan" id="kobo.4692.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4693.1">john.doe@domain.com</span></code><span class="koboSpan" id="kobo.4694.1">. </span><span class="koboSpan" id="kobo.4694.2">The first contains a domain name without a dot-prefixed DNS label, and that case is not covered in the regular expression. </span><span class="koboSpan" id="kobo.4694.3">The second contains only lowercase letters, and in the regular expression, the valid set of characters for both the local part and the domain name was uppercase letters, A to Z.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4695.1">Instead of</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.4696.1"> complicating the regular expression with additional valid characters (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4697.1">[A-Za-z0-9._%+-]</span></code><span class="koboSpan" id="kobo.4698.1">), we can specify that the match can ignore this case. </span><span class="koboSpan" id="kobo.4698.2">This can be done with an additional parameter to the constructor of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4699.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.4700.1"> class. </span><span class="koboSpan" id="kobo.4700.2">The available constants for this purpose are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4701.1">regex_constants</span></code><span class="koboSpan" id="kobo.4702.1"> namespace. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4703.1">The </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.4704.1">following slight change to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4705.1">is_valid_email_format()</span></code><span class="koboSpan" id="kobo.4706.1"> will make it ignore the case and allow email addresses with both lowercase and uppercase letters to correctly match the regular expression:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4707.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4708.1">is_valid_email_format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4709.1">(std::string </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4710.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4711.1"> &amp; email)</span></span><span class="koboSpan" id="kobo.4712.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4713.1">auto</span></span><span class="koboSpan" id="kobo.4714.1"> rx = std::regex{
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.4715.1">R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"</span></span><span class="koboSpan" id="kobo.4716.1">s,
    std::regex_constants::icase};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4717.1">return</span></span><span class="koboSpan" id="kobo.4718.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4719.1">regex_match</span></span><span class="koboSpan" id="kobo.4720.1">(email, rx);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4721.1">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.4722.1">is_valid_email_format()</span></code><span class="koboSpan" id="kobo.4723.1"> function is pretty simple, and if the regular expression was provided as a parameter, along with the text to match, it could be used for matching anything. </span><span class="koboSpan" id="kobo.4723.2">However, it would be nice to be able to handle not only multi-byte strings (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4724.1">std::string</span></code><span class="koboSpan" id="kobo.4725.1">) but also wide strings (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4726.1">std::wstring</span></code><span class="koboSpan" id="kobo.4727.1">), with a single function. </span><span class="koboSpan" id="kobo.4727.2">This can be achieved by creating a function template where the character type is provided as a template parameter:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4728.1">template</span></span><span class="koboSpan" id="kobo.4729.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4730.1">typename</span></span><span class="koboSpan" id="kobo.4731.1"> CharT&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4732.1">using</span></span><span class="koboSpan" id="kobo.4733.1"> tstring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;,
                                  std::allocator&lt;CharT&gt;&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4734.1">template</span></span><span class="koboSpan" id="kobo.4735.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4736.1">typename</span></span><span class="koboSpan" id="kobo.4737.1"> CharT&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4738.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4739.1">is_valid_format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4740.1">(tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4741.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4742.1"> &amp; pattern,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4743.1">                     tstring&lt;CharT&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4744.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4745.1"> &amp; text)</span></span><span class="koboSpan" id="kobo.4746.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4747.1">auto</span></span><span class="koboSpan" id="kobo.4748.1"> rx = std::basic_regex&lt;CharT&gt;{ pattern, std::regex_constants::icase };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4749.1">return</span></span><span class="koboSpan" id="kobo.4750.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4751.1">regex_match</span></span><span class="koboSpan" id="kobo.4752.1">(text, rx);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4753.1">We start by creating an alias template for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4754.1">std::basic_string</span></code><span class="koboSpan" id="kobo.4755.1"> in order to simplify its use. </span><span class="koboSpan" id="kobo.4755.2">The new </span><code class="inlineCode"><span class="koboSpan" id="kobo.4756.1">is_valid_format()</span></code><span class="koboSpan" id="kobo.4757.1"> function is a function template very similar to our implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4758.1">is_valid_email()</span></code><span class="koboSpan" id="kobo.4759.1">. </span><span class="koboSpan" id="kobo.4759.2">However, we now use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4760.1">std::basic_regex&lt;CharT&gt;</span></code><span class="koboSpan" id="kobo.4761.1"> instead of the typedef </span><code class="inlineCode"><span class="koboSpan" id="kobo.4762.1">std::regex</span></code><span class="koboSpan" id="kobo.4763.1">, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4764.1">std::basic_regex&lt;char&gt;</span></code><span class="koboSpan" id="kobo.4765.1">, and the pattern is provided as the first argument. </span><span class="koboSpan" id="kobo.4765.2">We now implement a new function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4766.1">is_valid_email_format_w()</span></code><span class="koboSpan" id="kobo.4767.1"> for wide strings that relies on</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.4768.1"> this function template. </span><span class="koboSpan" id="kobo.4768.2">The </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.4769.1">function template, however, can be reused for implementing other validations, such as whether a license plate has a particular format:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4770.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4771.1">is_valid_email_format_w</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4772.1">(std::wstring </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4773.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4774.1"> &amp; text)</span></span><span class="koboSpan" id="kobo.4775.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4776.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4777.1">is_valid_format</span></span><span class="koboSpan" id="kobo.4778.1">(
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.4779.1">LR"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"</span></span><span class="koboSpan" id="kobo.4780.1">s,
    text);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4781.1">auto</span></span><span class="koboSpan" id="kobo.4782.1"> ltest2 = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4783.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4784.1">const</span></span><span class="koboSpan" id="kobo.4785.1"> &amp; email)
{
  std::wcout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4786.1">setw</span></span><span class="koboSpan" id="kobo.4787.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4788.1">30</span></span><span class="koboSpan" id="kobo.4789.1">) &lt;&lt; std::left
     &lt;&lt; email &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4790.1">L" : "</span></span><span class="koboSpan" id="kobo.4791.1">
     &lt;&lt; (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4792.1">is_valid_email_format_w</span></span><span class="koboSpan" id="kobo.4793.1">(email) ? </span><span class="hljs-string"><span class="koboSpan" id="kobo.4794.1">L"valid"</span></span><span class="koboSpan" id="kobo.4795.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4796.1">L"invalid"</span></span><span class="koboSpan" id="kobo.4797.1">)
     &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4798.1">'\n'</span></span><span class="koboSpan" id="kobo.4799.1">;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4800.1">ltest2</span></span><span class="koboSpan" id="kobo.4801.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4802.1">L"JOHN.DOE@DOMAIN.COM"</span></span><span class="koboSpan" id="kobo.4803.1">s);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4804.1">// valid</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4805.1">ltest2</span></span><span class="koboSpan" id="kobo.4806.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4807.1">L"JOHNDOE@DOMAIL.CO.UK"</span></span><span class="koboSpan" id="kobo.4808.1">s);      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4809.1">// valid</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4810.1">ltest2</span></span><span class="koboSpan" id="kobo.4811.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4812.1">L"JOHNDOE@DOMAIL.INFO"</span></span><span class="koboSpan" id="kobo.4813.1">s);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4814.1">// valid</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4815.1">ltest2</span></span><span class="koboSpan" id="kobo.4816.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4817.1">L"J.O.H.N_D.O.E@DOMAIN.INFO"</span></span><span class="koboSpan" id="kobo.4818.1">s); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4819.1">// valid</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4820.1">ltest2</span></span><span class="koboSpan" id="kobo.4821.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4822.1">L"ROOT@LOCALHOST"</span></span><span class="koboSpan" id="kobo.4823.1">s);            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4824.1">// invalid</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4825.1">ltest2</span></span><span class="koboSpan" id="kobo.4826.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4827.1">L"john.doe@domain.com"</span></span><span class="koboSpan" id="kobo.4828.1">s);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4829.1">// valid</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4830.1">Of all the examples shown here, the only one that does not match is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4831.1">ROOT@LOCALHOST</span></code><span class="koboSpan" id="kobo.4832.1">, as expected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4833.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4834.1">std::regex_match()</span></code><span class="koboSpan" id="kobo.4835.1"> method has, in fact, several overloads, and some of them have a parameter that is a reference to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4836.1">std::match_results</span></code><span class="koboSpan" id="kobo.4837.1"> object to store the result of the match. </span><span class="koboSpan" id="kobo.4837.2">If there is no match, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.4838.1">std::match_results</span></code><span class="koboSpan" id="kobo.4839.1"> is empty and its size is 0. </span><span class="koboSpan" id="kobo.4839.2">Otherwise, if there is a match, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4840.1">std::match_results</span></code><span class="koboSpan" id="kobo.4841.1"> object is not empty and its size is 1, plus the number of matched subexpressions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4842.1">The </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.4843.1">following version of the function uses the mentioned overloads and returns the matched subexpressions in an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4844.1">std::smatch</span></code><span class="koboSpan" id="kobo.4845.1"> object. </span><span class="koboSpan" id="kobo.4845.2">Note that the regular expression is changed as three caption groups are defined – one for the local part, one for the hostname part of the domain, and one for the DNS label. </span><span class="koboSpan" id="kobo.4845.3">If the match is successful, then the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4846.1">std::smatch</span></code><span class="koboSpan" id="kobo.4847.1"> object will contain four submatch objects: the first (index 0) to match the entire string, the second (index 1) for the first capture group (the local part), the third (index 2) for the second capture group (the hostname), and the fourth (index 3) for the third and last capture group (the DNS label). </span><span class="koboSpan" id="kobo.4847.2">The result is returned in a tuple, where the first item</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.4848.1"> actually indicates success or failure:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4849.1">std::tuple&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4850.1">bool</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4851.1">, std::string, std::string, std::string&gt;</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.4852.1">is_valid_email_format_with_result</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4853.1">(std::string </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4854.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4855.1"> &amp; email)</span></span><span class="koboSpan" id="kobo.4856.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4857.1">auto</span></span><span class="koboSpan" id="kobo.4858.1"> rx = std::regex{
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.4859.1">R"(^([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,})$)"</span></span><span class="koboSpan" id="kobo.4860.1">s,
    std::regex_constants::icase };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4861.1">auto</span></span><span class="koboSpan" id="kobo.4862.1"> result = std::smatch{};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4863.1">auto</span></span><span class="koboSpan" id="kobo.4864.1"> success = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4865.1">regex_match</span></span><span class="koboSpan" id="kobo.4866.1">(email, result, rx);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4867.1">return</span></span><span class="koboSpan" id="kobo.4868.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4869.1">make_tuple</span></span><span class="koboSpan" id="kobo.4870.1">(
    success,
    success ? </span><span class="koboSpan" id="kobo.4870.2">result[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4871.1">1</span></span><span class="koboSpan" id="kobo.4872.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4873.1">str</span></span><span class="koboSpan" id="kobo.4874.1">() : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4875.1">""</span></span><span class="koboSpan" id="kobo.4876.1">s,
    success ? </span><span class="koboSpan" id="kobo.4876.2">result[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4877.1">2</span></span><span class="koboSpan" id="kobo.4878.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4879.1">str</span></span><span class="koboSpan" id="kobo.4880.1">() : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4881.1">""</span></span><span class="koboSpan" id="kobo.4882.1">s,
    success ? </span><span class="koboSpan" id="kobo.4882.2">result[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4883.1">3</span></span><span class="koboSpan" id="kobo.4884.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4885.1">str</span></span><span class="koboSpan" id="kobo.4886.1">() : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4887.1">""</span></span><span class="koboSpan" id="kobo.4888.1">s);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4889.1">Following the preceding code, we use C++17 structured bindings to unpack the content of the tuple into named variables:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4890.1">auto</span></span><span class="koboSpan" id="kobo.4891.1"> ltest3 = [](std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.4892.1">const</span></span><span class="koboSpan" id="kobo.4893.1"> &amp; email)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4894.1">auto</span></span><span class="koboSpan" id="kobo.4895.1"> [valid, localpart, hostname, dnslabel] =
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4896.1">is_valid_email_format_with_result</span></span><span class="koboSpan" id="kobo.4897.1">(email);
  std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4898.1">setw</span></span><span class="koboSpan" id="kobo.4899.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4900.1">30</span></span><span class="koboSpan" id="kobo.4901.1">) &lt;&lt; std::left
     &lt;&lt; email &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4902.1">" : "</span></span><span class="koboSpan" id="kobo.4903.1">
     &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4904.1">setw</span></span><span class="koboSpan" id="kobo.4905.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4906.1">10</span></span><span class="koboSpan" id="kobo.4907.1">) &lt;&lt; (valid ? </span><span class="hljs-string"><span class="koboSpan" id="kobo.4908.1">"valid"</span></span><span class="koboSpan" id="kobo.4909.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4910.1">"invalid"</span></span><span class="koboSpan" id="kobo.4911.1">)
     &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4912.1">"local="</span></span><span class="koboSpan" id="kobo.4913.1"> &lt;&lt; localpart
     &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4914.1">";domain="</span></span><span class="koboSpan" id="kobo.4915.1"> &lt;&lt; hostname
     &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4916.1">";dns="</span></span><span class="koboSpan" id="kobo.4917.1"> &lt;&lt; dnslabel
     &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4918.1">'\n'</span></span><span class="koboSpan" id="kobo.4919.1">;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4920.1">ltest3</span></span><span class="koboSpan" id="kobo.4921.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4922.1">"JOHN.DOE@DOMAIN.COM"</span></span><span class="koboSpan" id="kobo.4923.1">s);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4924.1">ltest3</span></span><span class="koboSpan" id="kobo.4925.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4926.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4927.1">JOHNDOE@DOMAIL.CO.UK"</span></span><span class="koboSpan" id="kobo.4928.1">s);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4929.1">ltest3</span></span><span class="koboSpan" id="kobo.4930.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4931.1">"JOHNDOE@DOMAIL.INFO"</span></span><span class="koboSpan" id="kobo.4932.1">s);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4933.1">ltest3</span></span><span class="koboSpan" id="kobo.4934.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4935.1">"J.O.H.N_D.O.E@DOMAIN.INFO"</span></span><span class="koboSpan" id="kobo.4936.1">s);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4937.1">ltest3</span></span><span class="koboSpan" id="kobo.4938.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4939.1">"ROOT@LOCALHOST"</span></span><span class="koboSpan" id="kobo.4940.1">s);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4941.1">ltest3</span></span><span class="koboSpan" id="kobo.4942.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4943.1">"john.doe@domain.com"</span></span><span class="koboSpan" id="kobo.4944.1">s);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4945.1">The</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.4946.1"> output of the program will be as follows:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.4947.1"><img alt="" src="../Images/B21549_02_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.4948.1">Figure 2.8: Output of tests</span></p>
<h2 class="heading-2" id="_idParaDest-146"><span class="koboSpan" id="kobo.4949.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4950.1">There are </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.4951.1">multiple versions of regular expressions, and the C++ standard library supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and egrep (grep with the option </span><code class="inlineCode"><span class="koboSpan" id="kobo.4952.1">-E</span></code><span class="koboSpan" id="kobo.4953.1">). </span><span class="koboSpan" id="kobo.4953.2">The default grammar used is ECMAScript, and in order to use another, you have to explicitly specify the grammar when defining the regular expression. </span><span class="koboSpan" id="kobo.4953.3">You can learn more about the supported grammar options at </span><a href="https://en.cppreference.com/w/cpp/regex/syntax_option_type"><span class="url"><span class="koboSpan" id="kobo.4954.1">https://en.cppreference.com/w/cpp/regex/syntax_option_type</span></span></a><span class="koboSpan" id="kobo.4955.1">. </span><span class="koboSpan" id="kobo.4955.2">In addition to specifying the grammar, you can also specify parsing options, such as matching by ignoring the case.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4956.1">The standard library </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.4957.1">provides more classes and algorithms than we have seen so far. </span><span class="koboSpan" id="kobo.4957.2">The main classes available in the library are as follows (all of them are class templates and, for convenience, typedefs are provided for different character types):</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4958.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.4959.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.4960.1"> defines the regular expression object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4961.1">typedef</span></span><span class="koboSpan" id="kobo.4962.1"> basic_regex&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4963.1">char</span></span><span class="koboSpan" id="kobo.4964.1">&gt;    regex;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4965.1">typedef</span></span><span class="koboSpan" id="kobo.4966.1"> basic_regex&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4967.1">wchar_t</span></span><span class="koboSpan" id="kobo.4968.1">&gt; wregex;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4969.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.4970.1">std::sub_match</span></code><span class="koboSpan" id="kobo.4971.1"> represents a sequence of characters that matches a capture group; this class is actually derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4972.1">std::pair</span></code><span class="koboSpan" id="kobo.4973.1">, and its </span><code class="inlineCode"><span class="koboSpan" id="kobo.4974.1">first</span></code><span class="koboSpan" id="kobo.4975.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4976.1">second</span></code><span class="koboSpan" id="kobo.4977.1"> members represent iterators to the first and the one-past-the-end characters in the match sequence. </span><span class="koboSpan" id="kobo.4977.2">If there is no match sequence, the two iterators are equal:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4978.1">typedef</span></span><span class="koboSpan" id="kobo.4979.1"> sub_match&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4980.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4981.1">char</span></span><span class="koboSpan" id="kobo.4982.1"> *&gt;            csub_match;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4983.1">typedef</span></span><span class="koboSpan" id="kobo.4984.1"> sub_match&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4985.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4986.1">wchar_t</span></span><span class="koboSpan" id="kobo.4987.1"> *&gt;         wcsub_match;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4988.1">typedef</span></span><span class="koboSpan" id="kobo.4989.1"> sub_match&lt;string::const_iterator&gt;  ssub_match;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4990.1">typedef</span></span><span class="koboSpan" id="kobo.4991.1"> sub_match&lt;wstring::const_iterator&gt; wssub_match;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4992.1">The </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.4993.1">class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.4994.1">std::match_results</span></code><span class="koboSpan" id="kobo.4995.1"> is a collection of matches; the first element is always a full match in the target, while the other elements are matches of subexpressions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4996.1">typedef</span></span><span class="koboSpan" id="kobo.4997.1"> match_results&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4998.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4999.1">char</span></span><span class="koboSpan" id="kobo.5000.1"> *&gt;            cmatch;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5001.1">typedef</span></span><span class="koboSpan" id="kobo.5002.1"> match_results&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5003.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5004.1">wchar_t</span></span><span class="koboSpan" id="kobo.5005.1"> *&gt;         wcmatch;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5006.1">typedef</span></span><span class="koboSpan" id="kobo.5007.1"> match_results&lt;string::const_iterator&gt;  smatch;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5008.1">typedef</span></span><span class="koboSpan" id="kobo.5009.1"> match_results&lt;wstring::const_iterator&gt; wsmatch;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5010.1">The algorithms available in the regular expressions standard library are as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5011.1">std::regex_match()</span></code><span class="koboSpan" id="kobo.5012.1">: This tries to match a regular expression (represented by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5013.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.5014.1"> instance) to an entire string.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5015.1">std::regex_search()</span></code><span class="koboSpan" id="kobo.5016.1">: This tries to match a regular expression (represented by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5017.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.5018.1"> instance) to a part of a string (including the entire string).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5019.1">std::regex_replace()</span></code><span class="koboSpan" id="kobo.5020.1">: This replaces matches from a regular expression according to a specified format.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5021.1">The iterators available in the regular expressions standard library are as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5022.1">std::regex_interator</span></code><span class="koboSpan" id="kobo.5023.1">: A constant forward iterator used to iterate through the occurrences of a pattern in a string. </span><span class="koboSpan" id="kobo.5023.2">It has a pointer to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5024.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.5025.1"> that must live until the iterator is destroyed. </span><span class="koboSpan" id="kobo.5025.2">Upon creation and when incremented, the iterator calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.5026.1">std::regex_search()</span></code><span class="koboSpan" id="kobo.5027.1"> and stores a copy of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5028.1">std::match_results</span></code><span class="koboSpan" id="kobo.5029.1"> object returned by the algorithm.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5030.1">std::regex_token_iterator</span></code><span class="koboSpan" id="kobo.5031.1">: A constant forward iterator used to iterate through the submatches of every match of a regular expression in a string. </span><span class="koboSpan" id="kobo.5031.2">Internally, it uses a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5032.1">std::regex_iterator</span></code><span class="koboSpan" id="kobo.5033.1"> to step through the submatches. </span><span class="koboSpan" id="kobo.5033.2">Since it stores a pointer to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5034.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.5035.1"> instance, the regular expression object must live until the iterator is destroyed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5036.1">It should be </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.5037.1">mentioned that the standard regex library</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.5038.1"> has poorer performance compared to other implementations (such as Boost.Regex) and does not support Unicode. </span><span class="koboSpan" id="kobo.5038.2">Moreover, it could be argued that the API itself is cumbersome to use. </span><span class="koboSpan" id="kobo.5038.3">However, using the standard library has the benefit of avoiding additional dependencies.</span></p>
<h2 class="heading-2" id="_idParaDest-147"><span class="koboSpan" id="kobo.5039.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5040.1">Parsing the content of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5041.1">, to learn how to perform multiple matches of a pattern in a text</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5042.1">Replacing the content of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5043.1">, to see how to perform text replacements with the help of regular expressions</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5044.1">Chapter 1</span></em><span class="koboSpan" id="kobo.5045.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5046.1">Using structured bindings to handle multi-return values</span></em><span class="koboSpan" id="kobo.5047.1">, to learn how to bind variables to subobjects or elements from the initializing expressions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-148"><span class="koboSpan" id="kobo.5048.1">Parsing the content of a string using regular expressions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5049.1">In the</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.5050.1"> previous recipe, we looked at how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5051.1">std::regex_match()</span></code><span class="koboSpan" id="kobo.5052.1"> to verify that the content of a string matches a particular format. </span><span class="koboSpan" id="kobo.5052.2">The </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.5053.1">library provides another algorithm called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5054.1">std::regex_search()</span></code><span class="koboSpan" id="kobo.5055.1"> that matches a regular expression against any part of a string, and not the entire string, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5056.1">regex_match()</span></code><span class="koboSpan" id="kobo.5057.1"> does. </span><span class="koboSpan" id="kobo.5057.2">This function, however, does not allow us to search through all the occurrences of a regular expression in an input string. </span><span class="koboSpan" id="kobo.5057.3">For this purpose, we need to use one of the iterator classes available in the library.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5058.1">In this recipe, you will learn how to parse the content of a string using regular expressions. </span><span class="koboSpan" id="kobo.5058.2">For this purpose, we will consider the problem of parsing a text file containing name-value pairs. </span><span class="koboSpan" id="kobo.5058.3">Each such pair is defined on a different line and has the format </span><code class="inlineCode"><span class="koboSpan" id="kobo.5059.1">name = value</span></code><span class="koboSpan" id="kobo.5060.1">, but lines starting with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5061.1">#</span></code><span class="koboSpan" id="kobo.5062.1"> represent comments and must be ignored. </span><span class="koboSpan" id="kobo.5062.2">The following is an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.5063.1">#remove # to uncomment a </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5064.1">line</span></span><span class="koboSpan" id="kobo.5065.1">
timeout=</span><span class="hljs-number"><span class="koboSpan" id="kobo.5066.1">120</span></span><span class="koboSpan" id="kobo.5067.1">
server = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5068.1">127.0.0.1</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.5069.1">#retrycount=3</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5070.1">Before looking at the implementation details, let’s consider some prerequisites.</span></p>
<h2 class="heading-2" id="_idParaDest-149"><span class="koboSpan" id="kobo.5071.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5072.1">For general information about regular expression support in C++11, refer to the </span><em class="italic"><span class="koboSpan" id="kobo.5073.1">Verifying the format of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5074.1"> recipe earlier in this chapter. </span><span class="koboSpan" id="kobo.5074.2">Basic knowledge of regular expressions is required to proceed with this recipe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5075.1">In the following examples, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5076.1">text</span></code><span class="koboSpan" id="kobo.5077.1"> is a variable that’s defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5078.1">auto</span></span><span class="koboSpan" id="kobo.5079.1"> text {
  </span><span class="hljs-string"><span class="koboSpan" id="kobo.5080.1">R"(</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.5081.1">    #remove # to uncomment a line</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.5082.1">    timeout=120</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.5083.1">    server = 127.0.0.1</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.5084.1">    #retrycount=3</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.5085.1">  )"</span></span><span class="koboSpan" id="kobo.5086.1">s};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5087.1">The sole purpose of this is to simplify our snippets, although, in a real-world example, you will probably be reading the text from a file or other source.</span></p>
<h2 class="heading-2" id="_idParaDest-150"><span class="koboSpan" id="kobo.5088.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5089.1">In order to </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.5090.1">search for occurrences </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.5091.1">of a regular expression through a string, you should do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.5092.1">Include the headers </span><code class="inlineCode"><span class="koboSpan" id="kobo.5093.1">&lt;regex&gt;</span></code><span class="koboSpan" id="kobo.5094.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5095.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.5096.1"> and the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.5097.1">std::string_literals</span></code><span class="koboSpan" id="kobo.5098.1"> for standard user-defined literals for strings (added in C++14):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.5099.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5100.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.5101.1">&lt;regex&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.5102.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5103.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.5104.1">&lt;string&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5105.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5106.1">namespace</span></span><span class="koboSpan" id="kobo.5107.1"> std::string_literals;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.5108.1">Use raw string literals (or raw wide string literals for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5109.1">std::wregex</span></code><span class="koboSpan" id="kobo.5110.1">) to specify a regular expression in order to avoid escaping backslashes (which can occur frequently). </span><span class="koboSpan" id="kobo.5110.2">The following regular expression validates the file format proposed earlier:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5111.1">auto</span></span><span class="koboSpan" id="kobo.5112.1"> pattern {</span><span class="hljs-string"><span class="koboSpan" id="kobo.5113.1">R"(^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,\-:]*)$)"</span></span><span class="koboSpan" id="kobo.5114.1">s};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.5115.1">Create an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5116.1">std::regex</span></code><span class="koboSpan" id="kobo.5117.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5118.1">std::wregex</span></code><span class="koboSpan" id="kobo.5119.1"> object (depending on the character set that is used) to encapsulate the regular expression:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5120.1">auto</span></span><span class="koboSpan" id="kobo.5121.1"> rx = std::regex{pattern};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.5122.1">To search for the first occurrence of a regular expression in a given text, use the general-purpose algorithm </span><code class="inlineCode"><span class="koboSpan" id="kobo.5123.1">std::regex_search()</span></code><span class="koboSpan" id="kobo.5124.1"> (example 1):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5125.1">auto</span></span><span class="koboSpan" id="kobo.5126.1"> match = std::smatch{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5127.1">if</span></span><span class="koboSpan" id="kobo.5128.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5129.1">regex_search</span></span><span class="koboSpan" id="kobo.5130.1">(text, match, rx))
{
  std::cout &lt;&lt; match[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5131.1">1</span></span><span class="koboSpan" id="kobo.5132.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5133.1">'='</span></span><span class="koboSpan" id="kobo.5134.1"> &lt;&lt; match[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5135.1">2</span></span><span class="koboSpan" id="kobo.5136.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5137.1">'\n'</span></span><span class="koboSpan" id="kobo.5138.1">;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.5139.1">To find all the occurrences of a regular expression in a given text, use the iterator </span><code class="inlineCode"><span class="koboSpan" id="kobo.5140.1">std::regex_iterator</span></code><span class="koboSpan" id="kobo.5141.1"> (example 2):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5142.1">auto</span></span><span class="koboSpan" id="kobo.5143.1"> end = std::sregex_iterator{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5144.1">for</span></span><span class="koboSpan" id="kobo.5145.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5146.1">auto</span></span><span class="koboSpan" id="kobo.5147.1"> it=std::sregex_iterator{ std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5148.1">begin</span></span><span class="koboSpan" id="kobo.5149.1">(text),
                                   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5150.1">end</span></span><span class="koboSpan" id="kobo.5151.1">(text), rx };
     it != end; ++it)
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5152.1">'\''</span></span><span class="koboSpan" id="kobo.5153.1"> &lt;&lt; (*it)[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5154.1">1</span></span><span class="koboSpan" id="kobo.5155.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5156.1">"'='"</span></span><span class="koboSpan" id="kobo.5157.1">
            &lt;&lt; (*it)[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5158.1">2</span></span><span class="koboSpan" id="kobo.5159.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5160.1">'\''</span></span><span class="koboSpan" id="kobo.5161.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5162.1">'\n'</span></span><span class="koboSpan" id="kobo.5163.1">;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.5164.1">To </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.5165.1">iterate through all the subexpressions of a match, use the iterator </span><code class="inlineCode"><span class="koboSpan" id="kobo.5166.1">std::regex_token_iterator</span></code><span class="koboSpan" id="kobo.5167.1"> (example 3):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5168.1">auto</span></span><span class="koboSpan" id="kobo.5169.1"> end = std::sregex_token_iterator{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5170.1">for</span></span><span class="koboSpan" id="kobo.5171.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5172.1">auto</span></span><span class="koboSpan" id="kobo.5173.1"> it = std::sregex_token_iterator{
                  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5174.1">begin</span></span><span class="koboSpan" id="kobo.5175.1">(text), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5176.1">end</span></span><span class="koboSpan" id="kobo.5177.1">(text), rx };
     it != end; ++it)
{
  std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5178.1">'\n'</span></span><span class="koboSpan" id="kobo.5179.1">;
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-151"><span class="koboSpan" id="kobo.5180.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5181.1">A </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.5182.1">simple regular expression that can parse the input file shown earlier may look like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5183.1">^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,\-:]*)$
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5184.1">This regular expression is supposed to ignore all lines that start with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5185.1">#</span></code><span class="koboSpan" id="kobo.5186.1">; for those that do not start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.5187.1">#</span></code><span class="koboSpan" id="kobo.5188.1">, match a name followed by the equals sign and then a value, which can be composed of alphanumeric characters and several other characters (underscore, dot, comma, and so on). </span><span class="koboSpan" id="kobo.5188.2">The exact meaning of this regular expression is explained as follows:</span></p>
<table class="table-container" id="table015">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.5189.1">Part</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.5190.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5191.1">^</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5192.1">Start of line</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5193.1">(?!#)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5194.1">A negative lookahead that makes sure that it is not possible to match the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5195.1">#</span></code><span class="koboSpan" id="kobo.5196.1"> character</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5197.1">(\w)+</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5198.1">A capturing group representing an identifier of at least a one-word character</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5199.1">\s*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5200.1">Any white spaces</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5201.1">=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5202.1">Equals sign</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5203.1">\s*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5204.1">Any white spaces</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5205.1">([\w\d]+[\w\d._,\-:]*)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5206.1">A capturing group representing a value that starts with an alphanumeric character, but can also contain a dot, comma, backslash, hyphen, colon, or underscore</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5207.1">$</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5208.1">End of line</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5209.1">Table 2.15: Breaking down the regular expression</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5210.1">We can </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.5211.1">use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5212.1">std::regex_search()</span></code><span class="koboSpan" id="kobo.5213.1"> to search for a match anywhere in the input text. </span><span class="koboSpan" id="kobo.5213.2">This algorithm has several overloads, but in general, they work in the same way. </span><span class="koboSpan" id="kobo.5213.3">You must specify the range of characters to work through, an output </span><code class="inlineCode"><span class="koboSpan" id="kobo.5214.1">std::match_results</span></code><span class="koboSpan" id="kobo.5215.1"> object that will contain the result of the match, and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5216.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.5217.1"> object representing the regular expression and matching flags (which define the way the search is done). </span><span class="koboSpan" id="kobo.5217.2">The function returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5218.1">true</span></code><span class="koboSpan" id="kobo.5219.1"> if a match was found or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5220.1">false</span></code><span class="koboSpan" id="kobo.5221.1"> otherwise.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5222.1">In the</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.5223.1"> first example from the previous section (see the fourth list item), </span><code class="inlineCode"><span class="koboSpan" id="kobo.5224.1">match</span></code><span class="koboSpan" id="kobo.5225.1"> is an instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5226.1">std::smatch</span></code><span class="koboSpan" id="kobo.5227.1"> that is a typedef of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5228.1">std::match_results</span></code><span class="koboSpan" id="kobo.5229.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.5230.1">string::const_iterator</span></code><span class="koboSpan" id="kobo.5231.1"> as the template type. </span><span class="koboSpan" id="kobo.5231.2">If a match is found, this object will contain the matching information in a sequence of values for all matched subexpressions. </span><span class="koboSpan" id="kobo.5231.3">The submatch at index 0 is always the entire match. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.5232.1">The submatch at index 1 is the first subexpression that was matched, the submatch at index 2 is the second subexpression that was matched, and so on. </span><span class="koboSpan" id="kobo.5232.2">Since we have two capturing groups (which are subexpressions) in our regular expression, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5233.1">std::match_results</span></code><span class="koboSpan" id="kobo.5234.1"> will have three submatches in the event of success. </span><span class="koboSpan" id="kobo.5234.2">The identifier representing the name is at index 1, and the value after the equals sign is at index 2. </span><span class="koboSpan" id="kobo.5234.3">Therefore, this code only prints the following:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.5235.1"><img alt="" src="../Images/B21549_02_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.5236.1">Figure 2.9: Output of the first example</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5237.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5238.1">std::regex_search()</span></code><span class="koboSpan" id="kobo.5239.1"> algorithm is not able to iterate through all the possible matches</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.5240.1"> in a piece of text. </span><span class="koboSpan" id="kobo.5240.2">To do that, we need to use an iterator. </span><code class="inlineCode"><span class="koboSpan" id="kobo.5241.1">std::regex_iterator</span></code><span class="koboSpan" id="kobo.5242.1"> is intended for this purpose. </span><span class="koboSpan" id="kobo.5242.2">It allows not only iterating through all the matches but also accessing all the submatches of a match.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5243.1">The</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.5244.1"> iterator actually calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.5245.1">std::regex_search()</span></code><span class="koboSpan" id="kobo.5246.1"> upon construction and on each increment, and it remembers the resulting </span><code class="inlineCode"><span class="koboSpan" id="kobo.5247.1">std::match_results</span></code><span class="koboSpan" id="kobo.5248.1"> from the call. </span><span class="koboSpan" id="kobo.5248.2">The default constructor creates an iterator that represents the end of the sequence and can be used to test when the loop through the matches should stop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5249.1">In the second example from the previous section (see the fifth list item), we first create an end-of-sequence iterator, and then we start iterating through all the possible matches. </span><span class="koboSpan" id="kobo.5249.2">When constructed, it will call </span><code class="inlineCode"><span class="koboSpan" id="kobo.5250.1">std::regex_match()</span></code><span class="koboSpan" id="kobo.5251.1">, and if a match is found, we can access its results through the current iterator. </span><span class="koboSpan" id="kobo.5251.2">This will continue until no match is found (the end of the sequence). </span><span class="koboSpan" id="kobo.5251.3">This code will print the following output:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.5252.1"><img alt="" src="../Images/B21549_02_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.5253.1">Figure 2.10: Output of the second example</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5254.1">An alternative to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5255.1">std::regex_iterator</span></code><span class="koboSpan" id="kobo.5256.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5257.1">std::regex_token_iterator</span></code><span class="koboSpan" id="kobo.5258.1">. </span><span class="koboSpan" id="kobo.5258.2">This works similarly to the way </span><code class="inlineCode"><span class="koboSpan" id="kobo.5259.1">std::regex_iterator</span></code><span class="koboSpan" id="kobo.5260.1"> works and, in fact, it contains such an iterator internally, except that it enables us to access a particular subexpression from a match. </span><span class="koboSpan" id="kobo.5260.2">This is shown in the third example in the </span><em class="italic"><span class="koboSpan" id="kobo.5261.1">How to do it...</span></em><span class="koboSpan" id="kobo.5262.1"> section (see the sixth list item). </span><span class="koboSpan" id="kobo.5262.2">We start by creating an end-of-sequence iterator and then loop through the matches until the end-of-sequence is reached. </span><span class="koboSpan" id="kobo.5262.3">In the constructor we used, we did not specify the index of the subexpression to access through the iterator; therefore, the default value of 0 is used. </span><span class="koboSpan" id="kobo.5262.4">This means this program will print all the matches:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.5263.1"><img alt="" src="../Images/B21549_02_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.5264.1">Figure 2.11: Output of the third example</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5265.1">If we</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.5266.1"> wanted to access only the first subexpression (this means the names in our case), all we had to do was specify the index of </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.5267.1">the subexpression in the constructor of the token iterator, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5268.1">auto</span></span><span class="koboSpan" id="kobo.5269.1"> end = std::sregex_token_iterator{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5270.1">for</span></span><span class="koboSpan" id="kobo.5271.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5272.1">auto</span></span><span class="koboSpan" id="kobo.5273.1"> it = std::sregex_token_iterator{ std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5274.1">begin</span></span><span class="koboSpan" id="kobo.5275.1">(text),
               std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5276.1">end</span></span><span class="koboSpan" id="kobo.5277.1">(text), rx, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5278.1">1</span></span><span class="koboSpan" id="kobo.5279.1"> };
     it != end; ++it)
{
  std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5280.1">'\n'</span></span><span class="koboSpan" id="kobo.5281.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5282.1">This time, the output that we get contains only the names. </span><span class="koboSpan" id="kobo.5282.2">This is shown in the following image:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.5283.1"><img alt="" src="../Images/B21549_02_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.5284.1">Figure 2.12: Output containing only the names</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5285.1">An interesting thing about the token iterator is that it can return the unmatched parts of the string if the index of the subexpressions is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5286.1">-1</span></code><span class="koboSpan" id="kobo.5287.1">, in which case it returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5288.1">std::match_results</span></code><span class="koboSpan" id="kobo.5289.1"> object that corresponds to the sequence of characters between the last match and the end of the sequence:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5290.1">auto</span></span><span class="koboSpan" id="kobo.5291.1"> end = std::sregex_token_iterator{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5292.1">for</span></span><span class="koboSpan" id="kobo.5293.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5294.1">auto</span></span><span class="koboSpan" id="kobo.5295.1"> it = std::sregex_token_iterator{ std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5296.1">begin</span></span><span class="koboSpan" id="kobo.5297.1">(text),
               std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5298.1">end</span></span><span class="koboSpan" id="kobo.5299.1">(text), rx, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5300.1">-1</span></span><span class="koboSpan" id="kobo.5301.1"> };
     it != end; ++it)
{
  std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5302.1">'\n'</span></span><span class="koboSpan" id="kobo.5303.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5304.1">This program </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.5305.1">will output the following:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.5306.1"><img alt="" src="../Images/B21549_02_13.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.5307.1">Figure 2.13: Output including empty lines</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5308.1">Please </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.5309.1">note that the empty lines in the output correspond to empty tokens.</span></p>
<h2 class="heading-2" id="_idParaDest-152"><span class="koboSpan" id="kobo.5310.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5311.1">Verifying the format of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5312.1">, to familiarize yourself with the C++ library support for working with regular expressions</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5313.1">Replacing the content of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5314.1">, to learn how to perform multiple matches of a pattern in a text</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-153"><span class="koboSpan" id="kobo.5315.1">Replacing the content of a string using regular expressions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5316.1">In the </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.5317.1">previous two recipes, we looked at how to match a regular expression on a string or a part of a string and iterate </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.5318.1">through matches and submatches. </span><span class="koboSpan" id="kobo.5318.2">The regular expression library also supports text replacement based on regular expressions. </span><span class="koboSpan" id="kobo.5318.3">In this recipe, we will learn how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5319.1">std::regex_replace()</span></code><span class="koboSpan" id="kobo.5320.1"> to perform such text transformations.</span></p>
<h2 class="heading-2" id="_idParaDest-154"><span class="koboSpan" id="kobo.5321.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5322.1">For general information about regular expression support in C++11, refer to the </span><em class="italic"><span class="koboSpan" id="kobo.5323.1">Verifying the format of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5324.1"> recipe earlier in this chapter.</span></p>
<h2 class="heading-2" id="_idParaDest-155"><span class="koboSpan" id="kobo.5325.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5326.1">In order to </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.5327.1">perform text transformations </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.5328.1">using regular expressions, you should perform the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5329.1">Include </span><code class="inlineCode"><span class="koboSpan" id="kobo.5330.1">&lt;regex&gt;</span></code><span class="koboSpan" id="kobo.5331.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5332.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.5333.1"> and the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.5334.1">std::string_literals</span></code><span class="koboSpan" id="kobo.5335.1"> for C++14 standard user-defined literals for strings:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.5336.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5337.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.5338.1">&lt;regex&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.5339.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5340.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.5341.1">&lt;string&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5342.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5343.1">namespace</span></span><span class="koboSpan" id="kobo.5344.1"> std::string_literals;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5345.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5346.1">std::regex_replace()</span></code><span class="koboSpan" id="kobo.5347.1"> algorithm with a replacement string as the third argument. </span><span class="koboSpan" id="kobo.5347.2">Consider the following example. </span><span class="koboSpan" id="kobo.5347.3">Replace all words composed of exactly three characters that are either </span><code class="inlineCode"><span class="koboSpan" id="kobo.5348.1">a</span></code><span class="koboSpan" id="kobo.5349.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5350.1">b</span></code><span class="koboSpan" id="kobo.5351.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5352.1">c</span></code><span class="koboSpan" id="kobo.5353.1"> with three hyphens:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5354.1">auto</span></span><span class="koboSpan" id="kobo.5355.1"> text{</span><span class="hljs-string"><span class="koboSpan" id="kobo.5356.1">"abc aa bca ca bbbb"</span></span><span class="koboSpan" id="kobo.5357.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5358.1">auto</span></span><span class="koboSpan" id="kobo.5359.1"> rx = std::regex{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5360.1">R"(\b[a|b|c]{3}\b)"</span></span><span class="koboSpan" id="kobo.5361.1">s };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5362.1">auto</span></span><span class="koboSpan" id="kobo.5363.1"> newtext = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5364.1">regex_replace</span></span><span class="koboSpan" id="kobo.5365.1">(text, rx, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5366.1">"---"</span></span><span class="koboSpan" id="kobo.5367.1">s);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5368.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5369.1">std::regex_replace()</span></code><span class="koboSpan" id="kobo.5370.1"> algorithm with match identifiers prefixed with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5371.1">$</span></code><span class="koboSpan" id="kobo.5372.1"> for the third argument. </span><span class="koboSpan" id="kobo.5372.2">For example, replace names in the format “lastname, firstname” with names in the format “firstname lastname”, as follows:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5373.1">auto</span></span><span class="koboSpan" id="kobo.5374.1"> text{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5375.1">"bancila, marius"</span></span><span class="koboSpan" id="kobo.5376.1">s };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5377.1">auto</span></span><span class="koboSpan" id="kobo.5378.1"> rx = std::regex{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5379.1">R"((\w+),\s*(\w+))"</span></span><span class="koboSpan" id="kobo.5380.1">s };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5381.1">auto</span></span><span class="koboSpan" id="kobo.5382.1"> newtext = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5383.1">regex_replace</span></span><span class="koboSpan" id="kobo.5384.1">(text, rx, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5385.1">"$2 $1"</span></span><span class="koboSpan" id="kobo.5386.1">s);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-156"><span class="koboSpan" id="kobo.5387.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5388.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5389.1">std::regex_replace()</span></code><span class="koboSpan" id="kobo.5390.1"> algorithm has several overloads with different types of parameters, but the meaning of the parameters is as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5391.1">The input string on which the replacement is performed</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5392.1">An </span><code class="inlineCode"><span class="koboSpan" id="kobo.5393.1">std::basic_regex</span></code><span class="koboSpan" id="kobo.5394.1"> object that encapsulates the regular expression used to identify the parts of the strings to be replaced</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5395.1">The string format used for replacement</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5396.1">Optional matching flags</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5397.1">The</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.5398.1"> return value is, depending on the overload used, either a string or a copy of the output iterator provided as </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.5399.1">an argument. </span><span class="koboSpan" id="kobo.5399.2">The string format used for replacement can either be a simple string or a match identifier, indicated with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5400.1">$</span></code><span class="koboSpan" id="kobo.5401.1"> prefix:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5402.1">$&amp;</span></code><span class="koboSpan" id="kobo.5403.1"> indicates the entire match.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5404.1">$1</span></code><span class="koboSpan" id="kobo.5405.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5406.1">$2</span></code><span class="koboSpan" id="kobo.5407.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5408.1">$3</span></code><span class="koboSpan" id="kobo.5409.1">, and so on indicate the first, second, and third submatches, and so on.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5410.1">$`</span></code><span class="koboSpan" id="kobo.5411.1"> indicates the part of the string before the first match.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5412.1">$'</span></code><span class="koboSpan" id="kobo.5413.1"> indicates the part of the string after the last match.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5414.1">In the first example shown in the </span><em class="italic"><span class="koboSpan" id="kobo.5415.1">How to do it...</span></em><span class="koboSpan" id="kobo.5416.1"> section, the initial text contains two words made of exactly three </span><code class="inlineCode"><span class="koboSpan" id="kobo.5417.1">a</span></code><span class="koboSpan" id="kobo.5418.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5419.1">b</span></code><span class="koboSpan" id="kobo.5420.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5421.1">c</span></code><span class="koboSpan" id="kobo.5422.1"> characters: </span><code class="inlineCode"><span class="koboSpan" id="kobo.5423.1">abc</span></code><span class="koboSpan" id="kobo.5424.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5425.1">bca</span></code><span class="koboSpan" id="kobo.5426.1">. </span><span class="koboSpan" id="kobo.5426.2">The regular expression indicates an expression of exactly three characters between word boundaries. </span><span class="koboSpan" id="kobo.5426.3">This means a subtext, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5427.1">bbbb</span></code><span class="koboSpan" id="kobo.5428.1">, will not match the expression. </span><span class="koboSpan" id="kobo.5428.2">The result of the replacement is that the string text will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.5429.1">--- aa --- ca bbbb</span></code><span class="koboSpan" id="kobo.5430.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5431.1">Additional flags for the match can be specified for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5432.1">std::regex_replace()</span></code><span class="koboSpan" id="kobo.5433.1"> algorithm. </span><span class="koboSpan" id="kobo.5433.2">By default, the matching flag is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5434.1">std::regex_constants::match_default</span></code><span class="koboSpan" id="kobo.5435.1">, which basically specifies ECMAScript as the grammar used for constructing the regular expression. </span><span class="koboSpan" id="kobo.5435.2">If we want, for instance, to replace only the first occurrence, then we can specify </span><code class="inlineCode"><span class="koboSpan" id="kobo.5436.1">std::regex_constants::format_first_only</span></code><span class="koboSpan" id="kobo.5437.1">. </span><span class="koboSpan" id="kobo.5437.2">In the following example, the result is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5438.1">--- aa bca ca bbbb</span></code><span class="koboSpan" id="kobo.5439.1"> as the replacement stops after the first match is found:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5440.1">auto</span></span><span class="koboSpan" id="kobo.5441.1"> text{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5442.1">"abc aa bca ca bbbb"</span></span><span class="koboSpan" id="kobo.5443.1">s };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5444.1">auto</span></span><span class="koboSpan" id="kobo.5445.1"> rx = std::regex{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5446.1">R"(\b[a|b|c]{3}\b)"</span></span><span class="koboSpan" id="kobo.5447.1">s };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5448.1">auto</span></span><span class="koboSpan" id="kobo.5449.1"> newtext = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5450.1">regex_replace</span></span><span class="koboSpan" id="kobo.5451.1">(text, rx, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5452.1">"---"</span></span><span class="koboSpan" id="kobo.5453.1">s,
                 std::regex_constants::format_first_only);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5454.1">The replacement string, however, can contain special indicators for the whole match, a particular submatch, or the parts that were not matched, as explained earlier. </span><span class="koboSpan" id="kobo.5454.2">In the second example shown in the </span><em class="italic"><span class="koboSpan" id="kobo.5455.1">How to do it...</span></em><span class="koboSpan" id="kobo.5456.1"> section, the regular expression identifies a word of at least one character, followed by a comma and possible white spaces, and then another word of at least one character. </span><span class="koboSpan" id="kobo.5456.2">The first word is supposed to be the last name, while the second word is supposed to be the first name. </span><span class="koboSpan" id="kobo.5456.3">The replacement string is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5457.1">$2 $1</span></code><span class="koboSpan" id="kobo.5458.1"> format. </span><span class="koboSpan" id="kobo.5458.2">This is an instruction that’s used to replace the matched expression (in this example, the entire original string) with another string formed of the second submatch, followed by a space, and then the first submatch.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5459.1">In this case, the </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.5460.1">entire string was a</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.5461.1"> match. </span><span class="koboSpan" id="kobo.5461.2">In the following example, there will be multiple matches inside the string, and they will all be replaced with the indicated string. </span><span class="koboSpan" id="kobo.5461.3">In this example, we are replacing the indefinite article </span><em class="italic"><span class="koboSpan" id="kobo.5462.1">a</span></em><span class="koboSpan" id="kobo.5463.1"> when preceding a word that starts with a vowel (this, of course, does not cover words that start with a vowel sound) with the indefinite article </span><em class="italic"><span class="koboSpan" id="kobo.5464.1">an</span></em><span class="koboSpan" id="kobo.5465.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5466.1">auto</span></span><span class="koboSpan" id="kobo.5467.1"> text{</span><span class="hljs-string"><span class="koboSpan" id="kobo.5468.1">"this is a example with a error"</span></span><span class="koboSpan" id="kobo.5469.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5470.1">auto</span></span><span class="koboSpan" id="kobo.5471.1"> rx = std::regex{</span><span class="hljs-string"><span class="koboSpan" id="kobo.5472.1">R"(\ba ((a|e|i|u|o)\w+))"</span></span><span class="koboSpan" id="kobo.5473.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5474.1">auto</span></span><span class="koboSpan" id="kobo.5475.1"> newtext = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5476.1">regex_replace</span></span><span class="koboSpan" id="kobo.5477.1">(text, rx, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5478.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5479.1">an $1"</span></span><span class="koboSpan" id="kobo.5480.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5481.1">The regular expression identifies the letter </span><em class="italic"><span class="koboSpan" id="kobo.5482.1">a</span></em><span class="koboSpan" id="kobo.5483.1"> as a single word (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5484.1">\b</span></code><span class="koboSpan" id="kobo.5485.1"> indicates a word boundary, so </span><code class="inlineCode"><span class="koboSpan" id="kobo.5486.1">\ba</span></code><span class="koboSpan" id="kobo.5487.1"> means a word with a single letter, </span><em class="italic"><span class="koboSpan" id="kobo.5488.1">a</span></em><span class="koboSpan" id="kobo.5489.1">), followed by a space and a word of at least two characters starting with a vowel. </span><span class="koboSpan" id="kobo.5489.2">When such a match is identified, it is replaced with a string formed of the fixed string </span><em class="italic"><span class="koboSpan" id="kobo.5490.1">an</span></em><span class="koboSpan" id="kobo.5491.1">, followed by a space and the first subexpression of the match, which is the word itself. </span><span class="koboSpan" id="kobo.5491.2">In this example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5492.1">newtext</span></code><span class="koboSpan" id="kobo.5493.1"> string will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.5494.1">this is an example with an error</span></code><span class="koboSpan" id="kobo.5495.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5496.1">Apart from the identifiers of the subexpressions (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5497.1">$1</span></code><span class="koboSpan" id="kobo.5498.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5499.1">$2</span></code><span class="koboSpan" id="kobo.5500.1">, and so on), there are other identifiers for the entire match (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5501.1">$&amp;</span></code><span class="koboSpan" id="kobo.5502.1">), the part of the string before the first match (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5503.1">$`</span></code><span class="koboSpan" id="kobo.5504.1">), and the part of the string after the last match (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5505.1">$'</span></code><span class="koboSpan" id="kobo.5506.1">). </span><span class="koboSpan" id="kobo.5506.2">In the last example, we change the format of a date from </span><code class="inlineCode"><span class="koboSpan" id="kobo.5507.1">dd.mm.yyyy</span></code><span class="koboSpan" id="kobo.5508.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5509.1">yyyy.mm.dd</span></code><span class="koboSpan" id="kobo.5510.1">, but also show the matched parts:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5511.1">auto</span></span><span class="koboSpan" id="kobo.5512.1"> text{</span><span class="hljs-string"><span class="koboSpan" id="kobo.5513.1">"today is 1.06.2023!!"</span></span><span class="koboSpan" id="kobo.5514.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5515.1">auto</span></span><span class="koboSpan" id="kobo.5516.1"> rx = std::regex{</span><span class="hljs-string"><span class="koboSpan" id="kobo.5517.1">R"((\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4}))"</span></span><span class="koboSpan" id="kobo.5518.1">s};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.5519.1">// today is 2023.06.1!!</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5520.1">auto</span></span><span class="koboSpan" id="kobo.5521.1"> newtext1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5522.1">regex_replace</span></span><span class="koboSpan" id="kobo.5523.1">(text, rx, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5524.1">R"($5$4$3$2$1)"</span></span><span class="koboSpan" id="kobo.5525.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.5526.1">// today is [today is ][1.06.2023][!!]!!</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5527.1">auto</span></span><span class="koboSpan" id="kobo.5528.1"> newtext2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5529.1">regex_replace</span></span><span class="koboSpan" id="kobo.5530.1">(text, rx, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5531.1">R"([$`][$&amp;][$'])"</span></span><span class="koboSpan" id="kobo.5532.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5533.1">The regular expression matches a one- or two-digit number followed by a dot, hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen, or slash; and lastly, a four-digit number. </span><span class="koboSpan" id="kobo.5533.2">Keep in mind this is only an example, and there are better expressions for parsing a date.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5534.1">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.5535.1">newtext1</span></code><span class="koboSpan" id="kobo.5536.1">, the replacement string is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5537.1">$5$4$3$2$1</span></code><span class="koboSpan" id="kobo.5538.1">; this means year, followed by the second separator, then month, the first separator, and finally, day. </span><span class="koboSpan" id="kobo.5538.2">Therefore, for the input string </span><code class="inlineCode"><span class="koboSpan" id="kobo.5539.1">today is 1.06.2023!</span></code><span class="koboSpan" id="kobo.5540.1">, the result is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5541.1">today is 2023.06.1!!</span></code><span class="koboSpan" id="kobo.5542.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5543.1">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.5544.1">newtext2</span></code><span class="koboSpan" id="kobo.5545.1">, the </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.5546.1">replacement string is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5547.1">[$`][$&amp;][$']</span></code><span class="koboSpan" id="kobo.5548.1">; this means the part before the first match, followed by the </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.5549.1">entire match, and finally, the part after the last match are in square brackets. </span><span class="koboSpan" id="kobo.5549.2">However, the result is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.5550.1">[!!][1.06.2023][today is ]</span></code><span class="koboSpan" id="kobo.5551.1"> as you perhaps might expect at first glance, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.5552.1">today is [today is ][1.06.2023][!!]!!</span></code><span class="koboSpan" id="kobo.5553.1">. </span><span class="koboSpan" id="kobo.5553.2">The reason for this is that what is replaced is the matched expression, and, in this case, that is only the date (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5554.1">1.06.2023</span></code><span class="koboSpan" id="kobo.5555.1">). </span><span class="koboSpan" id="kobo.5555.2">This substring is replaced with another string formed of all the parts of the initial string.</span></p>
<h2 class="heading-2" id="_idParaDest-157"><span class="koboSpan" id="kobo.5556.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5557.1">Verifying the format of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5558.1">, to familiarize yourself with the C++ library support for working with regular expressions</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5559.1">Parsing the content of a string using regular expressions</span></em><span class="koboSpan" id="kobo.5560.1">, to learn how to perform multiple matches of a pattern in a text</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-158"><span class="koboSpan" id="kobo.5561.1">Using std::string_view instead of constant string references</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5562.1">When </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.5563.1">working with strings, temporary objects are created all the time, even if you might not be really aware of it. </span><span class="koboSpan" id="kobo.5563.2">Many times, these temporary objects are irrelevant and only serve the purpose of copying data from one place to another (for example, from a function to its caller). </span><span class="koboSpan" id="kobo.5563.3">This represents a performance issue because they require memory allocation and data copying, which should be avoided. </span><span class="koboSpan" id="kobo.5563.4">For this purpose, the C++17 standard provides a new string class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5564.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5565.1">, which represents a non-owning constant reference to a string (that is, a sequence of characters). </span><span class="koboSpan" id="kobo.5565.2">In this recipe, you will learn when and how you should use this class.</span></p>
<h2 class="heading-2" id="_idParaDest-159"><span class="koboSpan" id="kobo.5566.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5567.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5568.1">string_view</span></code><span class="koboSpan" id="kobo.5569.1"> class is available in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.5570.1">std</span></code><span class="koboSpan" id="kobo.5571.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5572.1">string_view</span></code><span class="koboSpan" id="kobo.5573.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-160"><span class="koboSpan" id="kobo.5574.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5575.1">You should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5576.1">std::string_view</span></code><span class="koboSpan" id="kobo.5577.1"> to pass a parameter to a function (or return a value from a function), instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5578.1">std::string const &amp;</span></code><span class="koboSpan" id="kobo.5579.1">, unless your code needs to call other functions</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.5580.1"> that take </span><code class="inlineCode"><span class="koboSpan" id="kobo.5581.1">std::string</span></code><span class="koboSpan" id="kobo.5582.1"> parameters (in which case, conversions would be necessary):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5583.1">std::string_view </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5584.1">get_filename</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5585.1">(std::string_view str)</span></span><span class="koboSpan" id="kobo.5586.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5587.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5588.1">const</span></span><span class="koboSpan" id="kobo.5589.1"> pos1 {str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5590.1">find_last_of</span></span><span class="koboSpan" id="kobo.5591.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5592.1">'')};</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.5593.1">  auto const pos2 {str.find_last_of('</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5594.1">.'</span></span><span class="koboSpan" id="kobo.5595.1">)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5596.1">return</span></span><span class="koboSpan" id="kobo.5597.1"> str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5598.1">substr</span></span><span class="koboSpan" id="kobo.5599.1">(pos1 + </span><span class="hljs-number"><span class="koboSpan" id="kobo.5600.1">1</span></span><span class="koboSpan" id="kobo.5601.1">, pos2 - pos1 - </span><span class="hljs-number"><span class="koboSpan" id="kobo.5602.1">1</span></span><span class="koboSpan" id="kobo.5603.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5604.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5605.1">const</span></span><span class="koboSpan" id="kobo.5606.1"> file1[] {</span><span class="hljs-string"><span class="koboSpan" id="kobo.5607.1">R"(c:\test\example1.doc)"</span></span><span class="koboSpan" id="kobo.5608.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5609.1">auto</span></span><span class="koboSpan" id="kobo.5610.1"> name1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5611.1">get_filename</span></span><span class="koboSpan" id="kobo.5612.1">(file1);
std::string file2 {</span><span class="hljs-string"><span class="koboSpan" id="kobo.5613.1">R"(c:\test\example2)"</span></span><span class="koboSpan" id="kobo.5614.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5615.1">auto</span></span><span class="koboSpan" id="kobo.5616.1"> name2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5617.1">get_filename</span></span><span class="koboSpan" id="kobo.5618.1">(file2);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5619.1">auto</span></span><span class="koboSpan" id="kobo.5620.1"> name3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5621.1">get_filename</span></span><span class="koboSpan" id="kobo.5622.1">(std::string_view{file1, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5623.1">16</span></span><span class="koboSpan" id="kobo.5624.1">});
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-161"><span class="koboSpan" id="kobo.5625.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5626.1">Before we look at how the new string type works, let’s consider the following example of a function that is supposed to extract the name of a file without its extension. </span><span class="koboSpan" id="kobo.5626.2">This is basically how you would write the function from the previous section before C++17:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5627.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5628.1">get_filename</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5629.1">(std::string </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5630.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5631.1"> &amp; str)</span></span><span class="koboSpan" id="kobo.5632.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5633.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5634.1">const</span></span><span class="koboSpan" id="kobo.5635.1"> pos1 {str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5636.1">find_last_of</span></span><span class="koboSpan" id="kobo.5637.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5638.1">'\\'</span></span><span class="koboSpan" id="kobo.5639.1">)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5640.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5641.1">const</span></span><span class="koboSpan" id="kobo.5642.1"> pos2 {str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5643.1">find_last_of</span></span><span class="koboSpan" id="kobo.5644.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5645.1">'.'</span></span><span class="koboSpan" id="kobo.5646.1">)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5647.1">return</span></span><span class="koboSpan" id="kobo.5648.1"> str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5649.1">substr</span></span><span class="koboSpan" id="kobo.5650.1">(pos1 + </span><span class="hljs-number"><span class="koboSpan" id="kobo.5651.1">1</span></span><span class="koboSpan" id="kobo.5652.1">, pos2 - pos1 - </span><span class="hljs-number"><span class="koboSpan" id="kobo.5653.1">1</span></span><span class="koboSpan" id="kobo.5654.1">);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5655.1">auto</span></span><span class="koboSpan" id="kobo.5656.1"> name1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5657.1">get_filename</span></span><span class="koboSpan" id="kobo.5658.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5659.1">R"(c:\test\example1.doc)"</span></span><span class="koboSpan" id="kobo.5660.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5661.1">// example1</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5662.1">auto</span></span><span class="koboSpan" id="kobo.5663.1"> name2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5664.1">get_filename</span></span><span class="koboSpan" id="kobo.5665.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5666.1">R"(c:\test\example2)"</span></span><span class="koboSpan" id="kobo.5667.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5668.1">// example2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5669.1">if</span></span><span class="koboSpan" id="kobo.5670.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5671.1">get_filename</span></span><span class="koboSpan" id="kobo.5672.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5673.1">R"(c:\test\_sample_.tmp)"</span></span><span class="koboSpan" id="kobo.5674.1">).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5675.1">front</span></span><span class="koboSpan" id="kobo.5676.1">() == </span><span class="hljs-string"><span class="koboSpan" id="kobo.5677.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5678.1">_'</span></span><span class="koboSpan" id="kobo.5679.1">) {}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.5680.1">Note that, in this example, the file separator is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5681.1">\</span></code><span class="koboSpan" id="kobo.5682.1"> (backslash), as in Windows. </span><span class="koboSpan" id="kobo.5682.2">For Linux-based systems, it has to be changed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5683.1">/</span></code><span class="koboSpan" id="kobo.5684.1"> (slash).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.5685.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5686.1">get_filename()</span></code><span class="koboSpan" id="kobo.5687.1"> function is relatively simple. </span><span class="koboSpan" id="kobo.5687.2">It takes a constant reference to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5688.1">std::string</span></code><span class="koboSpan" id="kobo.5689.1"> and identifies a substring bounded by the last file separator and the last dot, which basically represents a filename without an extension (and without folder names).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5690.1">The</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.5691.1"> problem with this code, however, is that it creates one, two, or possibly even more temporaries, depending on the compiler optimizations. </span><span class="koboSpan" id="kobo.5691.2">The function parameter is a constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.5692.1">std::string</span></code><span class="koboSpan" id="kobo.5693.1"> reference, but the function is called with a string literal, which means </span><code class="inlineCode"><span class="koboSpan" id="kobo.5694.1">std::string</span></code><span class="koboSpan" id="kobo.5695.1"> needs to be constructed from the literal. </span><span class="koboSpan" id="kobo.5695.2">These temporaries need to allocate and copy data, which is both time- and resource-consuming. </span><span class="koboSpan" id="kobo.5695.3">In the last example, all we want to do is check whether the first character of the filename is an underscore, but we create at least two temporary string objects for that purpose.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5696.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5697.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5698.1"> class template is intended to solve this problem. </span><span class="koboSpan" id="kobo.5698.2">This class template is very similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5699.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5700.1">, with the two having almost the same interface. </span><span class="koboSpan" id="kobo.5700.2">The reason for this is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.5701.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5702.1"> is intended to be used instead of a constant reference to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5703.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5704.1"> without further code changes. </span><span class="koboSpan" id="kobo.5704.2">Just like with </span><code class="inlineCode"><span class="koboSpan" id="kobo.5705.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5706.1">, there are specializations for all types of standard characters:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5707.1">typedef</span></span><span class="koboSpan" id="kobo.5708.1"> basic_string_view&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5709.1">char</span></span><span class="koboSpan" id="kobo.5710.1">&gt;     string_view;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5711.1">typedef</span></span><span class="koboSpan" id="kobo.5712.1"> basic_string_view&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5713.1">wchar_t</span></span><span class="koboSpan" id="kobo.5714.1">&gt;  wstring_view;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5715.1">typedef</span></span><span class="koboSpan" id="kobo.5716.1"> basic_string_view&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5717.1">char16_t</span></span><span class="koboSpan" id="kobo.5718.1">&gt; u16string_view;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5719.1">typedef</span></span><span class="koboSpan" id="kobo.5720.1"> basic_string_view&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5721.1">char32_t</span></span><span class="koboSpan" id="kobo.5722.1">&gt; u32string_view;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5723.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5724.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5725.1"> class template defines a reference to a constant contiguous sequence of characters. </span><span class="koboSpan" id="kobo.5725.2">As the name implies, it represents a view and cannot be used to modify the reference sequence of characters. </span><span class="koboSpan" id="kobo.5725.3">An </span><code class="inlineCode"><span class="koboSpan" id="kobo.5726.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5727.1"> object has a relatively small size because all it needs is a pointer to the first character in the sequence and the length. </span><span class="koboSpan" id="kobo.5727.2">It can be constructed not only from an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5728.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5729.1"> object but also from a pointer and a length, or from a null-terminated sequence of characters (in which case, it will require an initial traversal of the string in order to find the length). </span><span class="koboSpan" id="kobo.5729.2">Therefore, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5730.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5731.1"> class template can also be used as a common interface for multiple types of strings (as long as data only needs to be read). </span><span class="koboSpan" id="kobo.5731.2">On the other hand, converting from an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5732.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5733.1"> to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5734.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5735.1"> is not possible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5736.1">You must explicitly construct an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5737.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5738.1"> object from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5739.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5740.1">, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5741.1">std::string_view sv{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5742.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5743.1">demo"</span></span><span class="koboSpan" id="kobo.5744.1"> };
std::string s{ sv };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5745.1">Passing </span><code class="inlineCode"><span class="koboSpan" id="kobo.5746.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5747.1"> to functions and returning </span><code class="inlineCode"><span class="koboSpan" id="kobo.5748.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5749.1"> still creates temporaries of this type, but these are small-sized objects on the stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore, they should incur fewer performance costs than allocating heap space and copying data.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.5750.1">Note that all major compilers provide an implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5751.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5752.1">, which includes a small string optimization. </span><span class="koboSpan" id="kobo.5752.2">Although the implementation details are different, they typically rely on having a statically allocated buffer of a number of characters (16 for VC++ and GCC 5 or newer) that does not involve heap operations, which are only required when the size of the string exceeds that number of characters.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.5753.1">In</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.5754.1"> addition to the methods that are identical to those available in </span><code class="inlineCode"><span class="koboSpan" id="kobo.5755.1">std::basic_string</span></code><span class="koboSpan" id="kobo.5756.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5757.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5758.1"> has two more:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5759.1">remove_prefix()</span></code><span class="koboSpan" id="kobo.5760.1">: Shrinks the view by incrementing the start with </span><em class="italic"><span class="koboSpan" id="kobo.5761.1">N</span></em><span class="koboSpan" id="kobo.5762.1"> characters and decrementing the length with </span><em class="italic"><span class="koboSpan" id="kobo.5763.1">N</span></em><span class="koboSpan" id="kobo.5764.1"> characters</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5765.1">remove_suffix()</span></code><span class="koboSpan" id="kobo.5766.1">: Shrinks the view by decrementing the length with </span><em class="italic"><span class="koboSpan" id="kobo.5767.1">N</span></em><span class="koboSpan" id="kobo.5768.1"> characters</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5769.1">The two member functions are used in the following example to trim spaces from an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5770.1">std::string_view</span></code><span class="koboSpan" id="kobo.5771.1">, both at the beginning and the end. </span><span class="koboSpan" id="kobo.5771.2">The implementation of the function first looks for the first element that is not a space and then for the last element that is not a space. </span><span class="koboSpan" id="kobo.5771.3">Then, it removes from the end everything after the last non-space character, and from the beginning, everything until the first non-space character. </span><span class="koboSpan" id="kobo.5771.4">The function returns the new view, trimmed at both ends:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5772.1">std::string_view </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5773.1">trim_view</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5774.1">(std::string_view str)</span></span><span class="koboSpan" id="kobo.5775.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5776.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5777.1">const</span></span><span class="koboSpan" id="kobo.5778.1"> pos1{ str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5779.1">find_first_not_of</span></span><span class="koboSpan" id="kobo.5780.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5781.1">" "</span></span><span class="koboSpan" id="kobo.5782.1">) };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5783.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5784.1">const</span></span><span class="koboSpan" id="kobo.5785.1"> pos2{ str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5786.1">find_last_not_of</span></span><span class="koboSpan" id="kobo.5787.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5788.1">" "</span></span><span class="koboSpan" id="kobo.5789.1">) };
  str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5790.1">remove_suffix</span></span><span class="koboSpan" id="kobo.5791.1">(str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5792.1">length</span></span><span class="koboSpan" id="kobo.5793.1">() - pos2 - </span><span class="hljs-number"><span class="koboSpan" id="kobo.5794.1">1</span></span><span class="koboSpan" id="kobo.5795.1">);
  str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5796.1">remove_prefix</span></span><span class="koboSpan" id="kobo.5797.1">(pos1);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5798.1">return</span></span><span class="koboSpan" id="kobo.5799.1"> str;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5800.1">auto</span></span><span class="koboSpan" id="kobo.5801.1"> sv1{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5802.1">trim_view</span></span><span class="koboSpan" id="kobo.5803.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5804.1">"sample"</span></span><span class="koboSpan" id="kobo.5805.1">) };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5806.1">auto</span></span><span class="koboSpan" id="kobo.5807.1"> sv2{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5808.1">trim_view</span></span><span class="koboSpan" id="kobo.5809.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5810.1">"  sample"</span></span><span class="koboSpan" id="kobo.5811.1">) };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5812.1">auto</span></span><span class="koboSpan" id="kobo.5813.1"> sv3{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5814.1">trim_view</span></span><span class="koboSpan" id="kobo.5815.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5816.1">"sample  "</span></span><span class="koboSpan" id="kobo.5817.1">) };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5818.1">auto</span></span><span class="koboSpan" id="kobo.5819.1"> sv4{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5820.1">trim_view</span></span><span class="koboSpan" id="kobo.5821.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5822.1">"  sample  "</span></span><span class="koboSpan" id="kobo.5823.1">) };
std::string s1{ sv1 };
std::string s2{ sv2 };
std::string s3{ sv3 };
std::string s4{ sv4 };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5824.1">When </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.5825.1">using </span><code class="inlineCode"><span class="koboSpan" id="kobo.5826.1">std::basic_string_view</span></code><span class="koboSpan" id="kobo.5827.1">, you must be aware of two things: you cannot change the underlying data referred to by a view and you must manage the lifetime of the data, as the view is a non-owning reference.</span></p>
<h2 class="heading-2" id="_idParaDest-162"><span class="koboSpan" id="kobo.5828.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5829.1">Creating a library of string helpers</span></em><span class="koboSpan" id="kobo.5830.1">, to see how to create useful text utilities that are not directly available in the standard library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-163"><span class="koboSpan" id="kobo.5831.1">Formatting and printing text with std::format and std::print</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5832.1">The C++ language has two ways of formatting text: the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5833.1">printf</span></code><span class="koboSpan" id="kobo.5834.1"> family of functions and the I/O streams library. </span><span class="koboSpan" id="kobo.5834.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5835.1">printf</span></code><span class="koboSpan" id="kobo.5836.1"> functions are inherited from C and provide a separation of the formatting text and the arguments. </span><span class="koboSpan" id="kobo.5836.2">The streams library provides safety and extensibility and is usually recommended over </span><code class="inlineCode"><span class="koboSpan" id="kobo.5837.1">printf</span></code><span class="koboSpan" id="kobo.5838.1"> functions, but is, in general, slower. </span><span class="koboSpan" id="kobo.5838.2">The C++20 standard proposes a new formatting library alternative for output formatting, which </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.5839.1">is similar in form to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5840.1">printf</span></code><span class="koboSpan" id="kobo.5841.1"> but safe and extensible and is intended to complement the existing streams library. </span><span class="koboSpan" id="kobo.5841.2">In this recipe, we will learn how to use the new functionalities instead of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5842.1">printf</span></code><span class="koboSpan" id="kobo.5843.1"> functions or the streams library.</span></p>
<h2 class="heading-2" id="_idParaDest-164"><span class="koboSpan" id="kobo.5844.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5845.1">The new formatting</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.5846.1"> library is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5847.1">&lt;format&gt;</span></code><span class="koboSpan" id="kobo.5848.1"> header. </span><span class="koboSpan" id="kobo.5848.2">You must include this header for the following samples to work.</span></p>
<h2 class="heading-2" id="_idParaDest-165"><span class="koboSpan" id="kobo.5849.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5850.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5851.1">std::format()</span></code><span class="koboSpan" id="kobo.5852.1"> function formats its arguments according to the provided formatting</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.5853.1"> string. </span><span class="koboSpan" id="kobo.5853.2">You </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.5854.1">can use it as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5855.1">Provide empty replacement fields, represented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.5856.1">{}</span></code><span class="koboSpan" id="kobo.5857.1">, in the format string for each argument:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5858.1">auto</span></span><span class="koboSpan" id="kobo.5859.1"> text = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5860.1">"{} is {}"</span></span><span class="koboSpan" id="kobo.5861.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5862.1">"John"</span></span><span class="koboSpan" id="kobo.5863.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5864.1">42</span></span><span class="koboSpan" id="kobo.5865.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5866.1">Specify the 0-based index of each argument in the argument list inside the replacement field, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5867.1">{0}</span></code><span class="koboSpan" id="kobo.5868.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5869.1">{1}</span></code><span class="koboSpan" id="kobo.5870.1">, and so on. </span><span class="koboSpan" id="kobo.5870.2">The order of the arguments is not important, but the index must be valid:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5871.1">auto</span></span><span class="koboSpan" id="kobo.5872.1"> text = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5873.1">"{0} is {1}"</span></span><span class="koboSpan" id="kobo.5874.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5875.1">"John"</span></span><span class="koboSpan" id="kobo.5876.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5877.1">42</span></span><span class="koboSpan" id="kobo.5878.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5879.1">Control the output text with format specifiers provided in the replacement field after a colon (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5880.1">:</span></code><span class="koboSpan" id="kobo.5881.1">). </span><span class="koboSpan" id="kobo.5881.2">For basic and string types, this is a standard format specification. </span><span class="koboSpan" id="kobo.5881.3">For chrono types, this is a chrono format specification:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5882.1">auto</span></span><span class="koboSpan" id="kobo.5883.1"> text = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5884.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5885.1">{0} hex is {0:08X}"</span></span><span class="koboSpan" id="kobo.5886.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5887.1">42</span></span><span class="koboSpan" id="kobo.5888.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5889.1">auto</span></span><span class="koboSpan" id="kobo.5890.1"> now = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5891.1">now</span></span><span class="koboSpan" id="kobo.5892.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5893.1">auto</span></span><span class="koboSpan" id="kobo.5894.1"> date = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5895.1">"Today is {:%Y-%m-%d}"</span></span><span class="koboSpan" id="kobo.5896.1">, now);
std::cout &lt;&lt; date &lt;&lt; '\n';
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5897.1">You can also write the arguments in an out format using an iterator with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.5898.1">std::format_to()</span></code><span class="koboSpan" id="kobo.5899.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5900.1">std::format_to_n()</span></code><span class="koboSpan" id="kobo.5901.1">, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5902.1">Write to a buffer, such as an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5903.1">std::string</span></code><span class="koboSpan" id="kobo.5904.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5905.1">std::vector&lt;char&gt;</span></code><span class="koboSpan" id="kobo.5906.1">, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.5907.1">std::format_n()</span></code><span class="koboSpan" id="kobo.5908.1"> and using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5909.1">std::back_inserter()</span></code><span class="koboSpan" id="kobo.5910.1"> helper function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5911.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5912.1">char</span></span><span class="koboSpan" id="kobo.5913.1">&gt; buf;
std::format_to(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5914.1">back_inserter</span></span><span class="koboSpan" id="kobo.5915.1">(buf), </span><span class="hljs-string"><span class="koboSpan" id="kobo.5916.1">"{} is {}"</span></span><span class="koboSpan" id="kobo.5917.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5918.1">"John"</span></span><span class="koboSpan" id="kobo.5919.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5920.1">42</span></span><span class="koboSpan" id="kobo.5921.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5922.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5923.1">std::formatted_size()</span></code><span class="koboSpan" id="kobo.5924.1"> to retrieve the number of characters necessary to store the formatted representation of the arguments:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5925.1">auto</span></span><span class="koboSpan" id="kobo.5926.1"> size = std::formatted_size(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5927.1">"{} is {}"</span></span><span class="koboSpan" id="kobo.5928.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5929.1">"John"</span></span><span class="koboSpan" id="kobo.5930.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5931.1">42</span></span><span class="koboSpan" id="kobo.5932.1">);
</span><span class="hljs-function"><span class="koboSpan" id="kobo.5933.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5934.1">char</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5935.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5936.1">buf</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5937.1">(size)</span></span><span class="koboSpan" id="kobo.5938.1">;
std::format_to(buf.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5939.1">data</span></span><span class="koboSpan" id="kobo.5940.1">(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.5941.1">"{} is {}"</span></span><span class="koboSpan" id="kobo.5942.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5943.1">"John"</span></span><span class="koboSpan" id="kobo.5944.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5945.1">42</span></span><span class="koboSpan" id="kobo.5946.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5947.1">To limit the number of characters written to the output buffer, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5948.1">std::format_to_n()</span></code><span class="koboSpan" id="kobo.5949.1">, which</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.5950.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5951.1">std::format_to()</span></code><span class="koboSpan" id="kobo.5952.1"> but</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.5953.1"> writes, at most, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5954.1">n</span></code><span class="koboSpan" id="kobo.5955.1"> characters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5956.1">char</span></span><span class="koboSpan" id="kobo.5957.1"> buf[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5958.1">100</span></span><span class="koboSpan" id="kobo.5959.1">];
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5960.1">auto</span></span><span class="koboSpan" id="kobo.5961.1"> result = std::format_to_n(buf, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5962.1">sizeof</span></span><span class="koboSpan" id="kobo.5963.1">(buf), </span><span class="hljs-string"><span class="koboSpan" id="kobo.5964.1">"{} is {}"</span></span><span class="koboSpan" id="kobo.5965.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5966.1">"John"</span></span><span class="koboSpan" id="kobo.5967.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5968.1">42</span></span><span class="koboSpan" id="kobo.5969.1">);
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5970.1">In C++23, you </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.5971.1">can write formatted text directly to a file stream, such </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.5972.1">as the standard output console, using the following functions from the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.5973.1">&lt;print&gt;</span></code><span class="koboSpan" id="kobo.5974.1"> header:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5975.1">std::print</span></code><span class="koboSpan" id="kobo.5976.1">, to write the arguments according to the format string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5977.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5978.1">print</span></span><span class="koboSpan" id="kobo.5979.1">("The answer is {}", </span><span class="hljs-number"><span class="koboSpan" id="kobo.5980.1">42</span></span><span class="koboSpan" id="kobo.5981.1">);
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5982.1">std::println</span></code><span class="koboSpan" id="kobo.5983.1">, to write the arguments according to the format string followed by a new line character (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5984.1">'\n'</span></code><span class="koboSpan" id="kobo.5985.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5986.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5987.1">println</span></span><span class="koboSpan" id="kobo.5988.1">("The answer is {}", </span><span class="hljs-number"><span class="koboSpan" id="kobo.5989.1">42</span></span><span class="koboSpan" id="kobo.5990.1">);
std::FILE* stream = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5991.1">fopen</span></span><span class="koboSpan" id="kobo.5992.1">("demo.txt", "w");
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5993.1">if</span></span><span class="koboSpan" id="kobo.5994.1"> (stream)
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5995.1">println</span></span><span class="koboSpan" id="kobo.5996.1">(stream, "The answer is {}", </span><span class="hljs-number"><span class="koboSpan" id="kobo.5997.1">42</span></span><span class="koboSpan" id="kobo.5998.1">);
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5999.1">fclose</span></span><span class="koboSpan" id="kobo.6000.1">(stream);
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-166"><span class="koboSpan" id="kobo.6001.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6002.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6003.1">std::format()</span></code><span class="koboSpan" id="kobo.6004.1"> function </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.6005.1">has multiple overloads. </span><span class="koboSpan" id="kobo.6005.2">You can specify the format string either as a string view or a wide string view, with the function returning either an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6006.1">std::string</span></code><span class="koboSpan" id="kobo.6007.1"> or an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6008.1">std::wstring</span></code><span class="koboSpan" id="kobo.6009.1">. </span><span class="koboSpan" id="kobo.6009.2">You can also specify, as the first argument, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6010.1">std::locale</span></code><span class="koboSpan" id="kobo.6011.1">, which is used for locale-specific formatting. </span><span class="koboSpan" id="kobo.6011.2">The function overloads are all variadic function templates, which means you can specify any number of arguments after the format.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6012.1">The format string consists of ordinary characters, replacement fields, and escape sequences. </span><span class="koboSpan" id="kobo.6012.2">The escape sequences are </span><code class="inlineCode"><span class="koboSpan" id="kobo.6013.1">{{</span></code><span class="koboSpan" id="kobo.6014.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6015.1">}}</span></code><span class="koboSpan" id="kobo.6016.1"> and are replaced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6017.1">{</span></code><span class="koboSpan" id="kobo.6018.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6019.1">}</span></code><span class="koboSpan" id="kobo.6020.1"> in the output. </span><span class="koboSpan" id="kobo.6020.2">A replacement field is provided within curly brackets </span><code class="inlineCode"><span class="koboSpan" id="kobo.6021.1">{}</span></code><span class="koboSpan" id="kobo.6022.1">. </span><span class="koboSpan" id="kobo.6022.2">It can optionally contain a non-negative number, representing the 0-based index of the argument to be formatted, and a colon (</span><code class="inlineCode"><span class="koboSpan" id="kobo.6023.1">:</span></code><span class="koboSpan" id="kobo.6024.1">), followed by a format specifier. </span><span class="koboSpan" id="kobo.6024.2">If the format specifier is invalid, an exception of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6025.1">std::format_error</span></code><span class="koboSpan" id="kobo.6026.1"> is thrown.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6027.1">In a similar </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.6028.1">manner, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6029.1">std::format_to()</span></code><span class="koboSpan" id="kobo.6030.1"> has multiple overloads, just like </span><code class="inlineCode"><span class="koboSpan" id="kobo.6031.1">std::format()</span></code><span class="koboSpan" id="kobo.6032.1">. </span><span class="koboSpan" id="kobo.6032.2">The difference between these two is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.6033.1">std::format_to()</span></code><span class="koboSpan" id="kobo.6034.1"> always takes an iterator to the output buffer as the first argument and returns an iterator past the end of the output range (and not a string as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6035.1">std::format()</span></code><span class="koboSpan" id="kobo.6036.1"> does). </span><span class="koboSpan" id="kobo.6036.2">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6037.1">std::format_to_n()</span></code><span class="koboSpan" id="kobo.6038.1"> has one more parameter than </span><code class="inlineCode"><span class="koboSpan" id="kobo.6039.1">std::format_to()</span></code><span class="koboSpan" id="kobo.6040.1">. </span><span class="koboSpan" id="kobo.6040.2">Its second parameter is a number representing the maximum number of characters to be written to the buffer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6041.1">The following</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.6042.1"> listing shows the signature of the simplest overload of each of these three function templates:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6043.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6044.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6045.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6046.1">... </span><span class="koboSpan" id="kobo.6046.2">Args&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.6047.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6048.1">format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6049.1">(std::string_view fmt, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6050.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6051.1"> Args&amp;... </span><span class="koboSpan" id="kobo.6051.2">args)</span></span><span class="koboSpan" id="kobo.6052.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6053.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6054.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6055.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6056.1"> OutputIt, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6057.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6058.1">... </span><span class="koboSpan" id="kobo.6058.2">Args&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.6059.1">OutputIt </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6060.1">format_to</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6061.1">(OutputIt out,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.6062.1">                   std::string_view fmt, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6063.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6064.1"> Args&amp;... </span><span class="koboSpan" id="kobo.6064.2">args)</span></span><span class="koboSpan" id="kobo.6065.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6066.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6067.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6068.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6069.1"> OutputIt, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6070.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6071.1">... </span><span class="koboSpan" id="kobo.6071.2">Args&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.6072.1">std::format_to_n_result&lt;OutputIt&gt;</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.6073.1">format_to_n</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6074.1">(OutputIt out, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6075.1">iter_difference_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6076.1">&lt;OutputIt&gt; n,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.6077.1">            std::string_view fmt, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6078.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6079.1"> Args&amp;... </span><span class="koboSpan" id="kobo.6079.2">args)</span></span><span class="koboSpan" id="kobo.6080.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6081.1">When you provide the format string, you can supply argument identifiers (their 0-based index) or omit them. </span><span class="koboSpan" id="kobo.6081.2">However, it is illegal to use both. </span><span class="koboSpan" id="kobo.6081.3">If the indexes are omitted in the replacement fields, the arguments are processed in the provided order, and the number of replacement fields must not be greater than the number of supplied arguments. </span><span class="koboSpan" id="kobo.6081.4">If indexes are provided, they must be valid for the format string to be valid.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6082.1">When a format specification is used, then:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6083.1">For basic types and string types, it is considered to be a standard format specification.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6084.1">For chrono types, it is considered to be a chrono format specification.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6085.1">For user-defined types, it is defined by a user-defined specialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6086.1">std::formatter</span></code><span class="koboSpan" id="kobo.6087.1"> class for the desired type.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6088.1">The standard format specification is based on the format specification in Python and has the following syntax:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6089.1">fill-</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6090.1">and</span></span><span class="koboSpan" id="kobo.6091.1">-</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6092.1">align</span></span><span class="koboSpan" id="kobo.6093.1">(optional) </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6094.1">sign</span></span><span class="koboSpan" id="kobo.6095.1">(optional) #(optional) </span><span class="hljs-number"><span class="koboSpan" id="kobo.6096.1">0</span></span><span class="koboSpan" id="kobo.6097.1">(optional) </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6098.1">width</span></span><span class="koboSpan" id="kobo.6099.1">(optional) </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6100.1">precision</span></span><span class="koboSpan" id="kobo.6101.1">(optional) </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6102.1">L</span></span><span class="koboSpan" id="kobo.6103.1">(optional) </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6104.1">type</span></span><span class="koboSpan" id="kobo.6105.1">(optional)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6106.1">These syntax parts</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.6107.1"> are briefly described here.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6108.1">fill-and-align</span></code><span class="koboSpan" id="kobo.6109.1"> is an optional fill character, followed by one of the align options:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6110.1">&lt;</span></code><span class="koboSpan" id="kobo.6111.1">: Forces the field to be left-aligned with the available space.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6112.1">&gt;</span></code><span class="koboSpan" id="kobo.6113.1">: Forces the field to be right-aligned with the available space.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6114.1">^</span></code><span class="koboSpan" id="kobo.6115.1">: Forces the field to be centered with the available space. </span><span class="koboSpan" id="kobo.6115.2">To do so, it will insert n/2 characters to the left and n/2 characters to the right:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6116.1">auto</span></span><span class="koboSpan" id="kobo.6117.1"> t1 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6118.1">"{:5}"</span></span><span class="koboSpan" id="kobo.6119.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6120.1">42</span></span><span class="koboSpan" id="kobo.6121.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6122.1">// "   42"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6123.1">auto</span></span><span class="koboSpan" id="kobo.6124.1"> t2 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6125.1">"{:5}"</span></span><span class="koboSpan" id="kobo.6126.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.6127.1">'x'</span></span><span class="koboSpan" id="kobo.6128.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6129.1">// "x    "</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6130.1">auto</span></span><span class="koboSpan" id="kobo.6131.1"> t3 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6132.1">"{:*&lt;5}"</span></span><span class="koboSpan" id="kobo.6133.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.6134.1">'x'</span></span><span class="koboSpan" id="kobo.6135.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6136.1">// "x****"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6137.1">auto</span></span><span class="koboSpan" id="kobo.6138.1"> t4 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6139.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.6140.1">{:*&gt;5}"</span></span><span class="koboSpan" id="kobo.6141.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.6142.1">'x'</span></span><span class="koboSpan" id="kobo.6143.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6144.1">// "****x"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6145.1">auto</span></span><span class="koboSpan" id="kobo.6146.1"> t5 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6147.1">"{:*^5}"</span></span><span class="koboSpan" id="kobo.6148.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.6149.1">'x'</span></span><span class="koboSpan" id="kobo.6150.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6151.1">// "**x**"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6152.1">auto</span></span><span class="koboSpan" id="kobo.6153.1"> t6 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6154.1">"{:5}"</span></span><span class="koboSpan" id="kobo.6155.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6156.1">true</span></span><span class="koboSpan" id="kobo.6157.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6158.1">// "true "</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6159.1">sign</span></code><span class="koboSpan" id="kobo.6160.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6161.1">#</span></code><span class="koboSpan" id="kobo.6162.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6163.1">0</span></code><span class="koboSpan" id="kobo.6164.1"> are only</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.6165.1"> valid when a number (either an integer or a floating-point) is used. </span><span class="koboSpan" id="kobo.6165.2">The sign can be one of:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6166.1">+</span></code><span class="koboSpan" id="kobo.6167.1">: Specifies that the sign must be used for both negative and positive numbers</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6168.1">-</span></code><span class="koboSpan" id="kobo.6169.1">: Specifies that the sign must be used only for negative numbers (which is the implicit behavior)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6170.1">A space: Specifies that the sign must be used for negative numbers and that a leading space must be used for non-negative numbers:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6171.1">auto</span></span><span class="koboSpan" id="kobo.6172.1"> t7 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6173.1">"{0:},{0:+},{0:-},{0: }"</span></span><span class="koboSpan" id="kobo.6174.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6175.1">42</span></span><span class="koboSpan" id="kobo.6176.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.6177.1">// "42,+42,42, 42"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6178.1">auto</span></span><span class="koboSpan" id="kobo.6179.1"> t8 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6180.1">"{0:},{0:+},{0:-},{0: }"</span></span><span class="koboSpan" id="kobo.6181.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6182.1">-42</span></span><span class="koboSpan" id="kobo.6183.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.6184.1">// "-42,-42,-42,-42"</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6185.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6186.1">#</span></code><span class="koboSpan" id="kobo.6187.1"> symbol causes the alternate form to be used. </span><span class="koboSpan" id="kobo.6187.2">This can be one of the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6188.1">For integral types, when binary, octal, or hexadecimal representation is specified, the alternate form adds the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.6189.1">0b</span></code><span class="koboSpan" id="kobo.6190.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6191.1">0</span></code><span class="koboSpan" id="kobo.6192.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6193.1">0x</span></code><span class="koboSpan" id="kobo.6194.1"> to the output.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6195.1">For floating-point types, the alternate form causes a decimal-point character to always be present in the formatted value, even if no digits follow it. </span><span class="koboSpan" id="kobo.6195.2">In addition, when </span><code class="inlineCode"><span class="koboSpan" id="kobo.6196.1">g</span></code><span class="koboSpan" id="kobo.6197.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6198.1">G</span></code><span class="koboSpan" id="kobo.6199.1"> are used, the trailing zeros are not removed from the output.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6200.1">The digit </span><code class="inlineCode"><span class="koboSpan" id="kobo.6201.1">0</span></code><span class="koboSpan" id="kobo.6202.1"> specifies that leading zeros should be outputted to the field width, except when the value of a floating-point type is infinity or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6203.1">NaN</span></code><span class="koboSpan" id="kobo.6204.1">. </span><span class="koboSpan" id="kobo.6204.2">When present alongside an align option, the specifier </span><code class="inlineCode"><span class="koboSpan" id="kobo.6205.1">0</span></code><span class="koboSpan" id="kobo.6206.1"> is ignored:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6207.1">auto</span></span><span class="koboSpan" id="kobo.6208.1"> t9  = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6209.1">"{:+05d}"</span></span><span class="koboSpan" id="kobo.6210.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6211.1">42</span></span><span class="koboSpan" id="kobo.6212.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6213.1">// "+0042"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6214.1">auto</span></span><span class="koboSpan" id="kobo.6215.1"> t10 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6216.1">"{:#05x}"</span></span><span class="koboSpan" id="kobo.6217.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6218.1">42</span></span><span class="koboSpan" id="kobo.6219.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6220.1">// "0x02a"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6221.1">auto</span></span><span class="koboSpan" id="kobo.6222.1"> t11 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6223.1">"{:&lt;05}"</span></span><span class="koboSpan" id="kobo.6224.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6225.1">-42</span></span><span class="koboSpan" id="kobo.6226.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6227.1">// "-42  "</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6228.1">width</span></code><span class="koboSpan" id="kobo.6229.1"> specifies </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.6230.1">the minimum field width and can be either a positive decimal number or a nested replacement field. </span><span class="koboSpan" id="kobo.6230.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6231.1">precision</span></code><span class="koboSpan" id="kobo.6232.1"> field indicates the precision for</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.6233.1"> floating-point types or, for string types, how many characters will be used from the string. </span><span class="koboSpan" id="kobo.6233.2">It is specified with a dot (</span><code class="inlineCode"><span class="koboSpan" id="kobo.6234.1">.</span></code><span class="koboSpan" id="kobo.6235.1">), followed by a non-negative decimal number or a nested replacement field.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6236.1">Locale-specific formatting is specified with the uppercase </span><code class="inlineCode"><span class="koboSpan" id="kobo.6237.1">L</span></code><span class="koboSpan" id="kobo.6238.1"> and causes the locale-specific form to be used. </span><span class="koboSpan" id="kobo.6238.2">This option is only available for arithmetic types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6239.1">The optional </span><code class="inlineCode"><span class="koboSpan" id="kobo.6240.1">type</span></code><span class="koboSpan" id="kobo.6241.1"> determines how the data will be presented in the output. </span><span class="koboSpan" id="kobo.6241.2">The available string presentation types are shown in the following table:</span></p>
<table class="table-container" id="table016">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6242.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6243.1">Presentation type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6244.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6245.1">Strings</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6246.1">none, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6247.1">s</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6248.1">Copies the string to the output.</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="7">
<p class="normal"><span class="koboSpan" id="kobo.6249.1">Integral types</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6250.1">b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6251.1">Binary format with 0b as a prefix.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6252.1">B</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6253.1">Binary format with 0B as a prefix.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6254.1">C</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6255.1">Character format. </span><span class="koboSpan" id="kobo.6255.2">Copies the value to the output as it was a character type.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6256.1">none or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6257.1">d</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6258.1">Decimal format.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6259.1">O</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6260.1">Octal format with 0 as a prefix (unless the value is 0).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6261.1">x</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6262.1">Hexadecimal format with 0x as a prefix.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6263.1">X</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6264.1">Hexadecimal format with 0X as a prefix.</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6265.1">char</span></code><span class="koboSpan" id="kobo.6266.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6267.1">wchar_t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6268.1">none or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6269.1">c</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6270.1">Copies the character to the output.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6271.1">b</span></code><span class="koboSpan" id="kobo.6272.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6273.1">B</span></code><span class="koboSpan" id="kobo.6274.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6275.1">c</span></code><span class="koboSpan" id="kobo.6276.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6277.1">d</span></code><span class="koboSpan" id="kobo.6278.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6279.1">o</span></code><span class="koboSpan" id="kobo.6280.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6281.1">x</span></code><span class="koboSpan" id="kobo.6282.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6283.1">X</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6284.1">Integer presentation types.</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6285.1">bool</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6286.1">none or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6287.1">s</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6288.1">Copies true or false as a textual representation (or their local-specific form) to the output.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6289.1">b</span></code><span class="koboSpan" id="kobo.6290.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6291.1">B</span></code><span class="koboSpan" id="kobo.6292.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6293.1">c</span></code><span class="koboSpan" id="kobo.6294.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6295.1">d</span></code><span class="koboSpan" id="kobo.6296.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6297.1">o</span></code><span class="koboSpan" id="kobo.6298.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6299.1">x</span></code><span class="koboSpan" id="kobo.6300.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6301.1">X</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6302.1">Integer presentation types.</span></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="7">
<p class="normal"><span class="koboSpan" id="kobo.6303.1">Floating-point</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6304.1">a</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6305.1">Hexadecimal representation. </span><span class="koboSpan" id="kobo.6305.2">Same as if calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.6306.1">std::to_chars(first, last, value, std::chars_format::hex, precision)</span></code><span class="koboSpan" id="kobo.6307.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6308.1">std::to_chars(first, last, value, std::chars_format::hex)</span></code><span class="koboSpan" id="kobo.6309.1">, depending on whether precision is specified or not.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6310.1">A</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6311.1">Same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6312.1">a</span></code><span class="koboSpan" id="kobo.6313.1"> except that it uses uppercase letters for digits above 9 and uses P to indicate the exponent.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6314.1">e</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6315.1">Scientific representation. </span><span class="koboSpan" id="kobo.6315.2">Produces the output as if calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.6316.1">std::to_chars(first, last, value, std::chars_format::scientific, precision)</span></code><span class="koboSpan" id="kobo.6317.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6318.1">E</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6319.1">Similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6320.1">e</span></code><span class="koboSpan" id="kobo.6321.1"> except that it uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.6322.1">E</span></code><span class="koboSpan" id="kobo.6323.1"> to indicate the exponent.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6324.1">f</span></code><span class="koboSpan" id="kobo.6325.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6326.1">F</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6327.1">Fixed representation. </span><span class="koboSpan" id="kobo.6327.2">Produces the output as if by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.6328.1">std::to_chars(first, last, value, std::chars_format::fixed, precision)</span></code><span class="koboSpan" id="kobo.6329.1">. </span><span class="koboSpan" id="kobo.6329.2">When no precision is specified, the default is 6.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6330.1">g</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6331.1">General floating-point representation. </span><span class="koboSpan" id="kobo.6331.2">Produces the output as if by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.6332.1">std::to_chars(first, last, value, std::chars_format::general, precision)</span></code><span class="koboSpan" id="kobo.6333.1">. </span><span class="koboSpan" id="kobo.6333.2">When no precision is specified, the default is 6.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6334.1">G</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6335.1">Same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6336.1">g</span></code><span class="koboSpan" id="kobo.6337.1"> except that it uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.6338.1">E</span></code><span class="koboSpan" id="kobo.6339.1"> to indicate the exponent.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6340.1">Pointer</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6341.1">none or </span><code class="inlineCode"><span class="koboSpan" id="kobo.6342.1">p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6343.1">Pointer representation. </span><span class="koboSpan" id="kobo.6343.2">Produces the output as if by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.6344.1">std::to_chars(first, last, reinterpret_cast&lt;std::uintptr_t&gt;(value), 16)</span></code><span class="koboSpan" id="kobo.6345.1"> with the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.6346.1">0x</span></code><span class="koboSpan" id="kobo.6347.1"> added to the output. </span><span class="koboSpan" id="kobo.6347.2">This is available only when </span><code class="inlineCode"><span class="koboSpan" id="kobo.6348.1">std::uintptr_t</span></code><span class="koboSpan" id="kobo.6349.1"> is defined; otherwise, the output is implementation-defined.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.6350.1">Table 2.16: The list of available presentation types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6351.1">The chrono format </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.6352.1">specification has the following form:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6353.1">fill-</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6354.1">and</span></span><span class="koboSpan" id="kobo.6355.1">-</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6356.1">align</span></span><span class="koboSpan" id="kobo.6357.1">(optional) </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6358.1">width</span></span><span class="koboSpan" id="kobo.6359.1">(optional) </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6360.1">precision</span></span><span class="koboSpan" id="kobo.6361.1">(optional) chrono-</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6362.1">spec</span></span><span class="koboSpan" id="kobo.6363.1">(optional)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6364.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6365.1">fill-and-align</span></code><span class="koboSpan" id="kobo.6366.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6367.1">width</span></code><span class="koboSpan" id="kobo.6368.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6369.1">precision</span></code><span class="koboSpan" id="kobo.6370.1"> fields have the same meaning as in the standard format </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.6371.1">specification, described previously. </span><span class="koboSpan" id="kobo.6371.2">The precision is only valid for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6372.1">std::chrono::duration</span></code><span class="koboSpan" id="kobo.6373.1"> types when the representation type is a floating-point type. </span><span class="koboSpan" id="kobo.6373.2">Using it in other cases throws an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6374.1">std::format_error</span></code><span class="koboSpan" id="kobo.6375.1"> exception.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6376.1">The chrono specification can be empty, in which case the argument is formatted as if by streaming it to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6377.1">std::stringstream</span></code><span class="koboSpan" id="kobo.6378.1"> and copying the result string. </span><span class="koboSpan" id="kobo.6378.2">Alternatively, it can consist of a series of conversion specifiers and ordinary characters. </span><span class="koboSpan" id="kobo.6378.3">Some of these format specifiers are presented in the following table:</span></p>
<table class="table-container" id="table017">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6379.1">Conversion specifier</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6380.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6381.1">%%</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6382.1">Writes a literal </span><code class="inlineCode"><span class="koboSpan" id="kobo.6383.1">%</span></code><span class="koboSpan" id="kobo.6384.1"> character.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6385.1">%n</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6386.1">Writes a newline character.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6387.1">%t</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6388.1">Writes a horizontal tab character.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6389.1">%Y</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6390.1">Writes the year as a decimal number. </span><span class="koboSpan" id="kobo.6390.2">If the result is less than four digits, it is left-padded with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6391.1">0</span></code><span class="koboSpan" id="kobo.6392.1"> to four digits.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6393.1">%m</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6394.1">Writes the month as a decimal number (January is </span><code class="inlineCode"><span class="koboSpan" id="kobo.6395.1">01</span></code><span class="koboSpan" id="kobo.6396.1">). </span><span class="koboSpan" id="kobo.6396.2">If the result is a single digit, it is prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6397.1">0</span></code><span class="koboSpan" id="kobo.6398.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6399.1">%d</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6400.1">Writes the day of the month as a decimal number. </span><span class="koboSpan" id="kobo.6400.2">If the result is a single decimal digit, it is prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6401.1">0</span></code><span class="koboSpan" id="kobo.6402.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6403.1">%w</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6404.1">Writes the weekday as a decimal number (</span><code class="inlineCode"><span class="koboSpan" id="kobo.6405.1">0</span></code><span class="koboSpan" id="kobo.6406.1">-</span><code class="inlineCode"><span class="koboSpan" id="kobo.6407.1">6</span></code><span class="koboSpan" id="kobo.6408.1">), where Sunday is </span><code class="inlineCode"><span class="koboSpan" id="kobo.6409.1">0</span></code><span class="koboSpan" id="kobo.6410.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6411.1">%D</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6412.1">Equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6413.1">%m/%d/%y</span></code><span class="koboSpan" id="kobo.6414.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6415.1">%F</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6416.1">Equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6417.1">%Y-%m-%d</span></code><span class="koboSpan" id="kobo.6418.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6419.1">%H</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6420.1">Writes the hour (24-hour clock) as a decimal number. </span><span class="koboSpan" id="kobo.6420.2">If the result is a single digit, it is prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6421.1">0</span></code><span class="koboSpan" id="kobo.6422.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6423.1">%I</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6424.1">Writes the hour (12-hour clock) as a decimal number. </span><span class="koboSpan" id="kobo.6424.2">If the result is a single digit, it is prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6425.1">0</span></code><span class="koboSpan" id="kobo.6426.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6427.1">%M</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6428.1">Writes the minute as a decimal number. </span><span class="koboSpan" id="kobo.6428.2">If the result is a single digit, it is prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6429.1">0</span></code><span class="koboSpan" id="kobo.6430.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6431.1">%S</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6432.1">Writes the second as a decimal number. </span><span class="koboSpan" id="kobo.6432.2">If the number of seconds is less than 10, the result is prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6433.1">0</span></code><span class="koboSpan" id="kobo.6434.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6435.1">%R</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6436.1">Equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6437.1">%H:%M</span></code><span class="koboSpan" id="kobo.6438.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6439.1">%T</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6440.1">Equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6441.1">%H:%M:%S</span></code><span class="koboSpan" id="kobo.6442.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6443.1">%X</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6444.1">Writes the locale’s time representation.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.6445.1">Table 2.17: A list of the most commonly used chrono specifiers</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6446.1">The complete list of format specifiers for the chrono library can be consulted at </span><a href="https://en.cppreference.com/w/cpp/chrono/system_clock/formatter"><span class="url"><span class="koboSpan" id="kobo.6447.1">https://en.cppreference.com/w/cpp/chrono/system_clock/formatter</span></span></a><span class="koboSpan" id="kobo.6448.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6449.1">Because writing </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.6450.1">formatted text to the console or a file stream requires two</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.6451.1"> operations (formatting text into a string or a vector of characters and then writing that buffer to the output stream), the C++23 standard introduced a couple of new functions to simplify this process. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.6452.1">The new </span><code class="inlineCode"><span class="koboSpan" id="kobo.6453.1">std::print</span></code><span class="koboSpan" id="kobo.6454.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6455.1">std::println</span></code><span class="koboSpan" id="kobo.6456.1"> functions are very similar. </span><span class="koboSpan" id="kobo.6456.2">The only difference is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.6457.1">std::println</span></code><span class="koboSpan" id="kobo.6458.1"> appends a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6459.1">\n</span></code><span class="koboSpan" id="kobo.6460.1"> character (new line) after the formatted text. </span><span class="koboSpan" id="kobo.6460.2">These two functions have two overloads each:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6461.1">One that takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6462.1">std::FILE*</span></code><span class="koboSpan" id="kobo.6463.1"> as the first argument, representing the output file stream</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6464.1">One that does not have such an argument, and uses the C output stream stdout implicitly</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6465.1">Because of this, the following two calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6466.1">std::println</span></code><span class="koboSpan" id="kobo.6467.1"> are equivalent:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6468.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6469.1">println</span></span><span class="koboSpan" id="kobo.6470.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6471.1">"The answer is {}"</span></span><span class="koboSpan" id="kobo.6472.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6473.1">42</span></span><span class="koboSpan" id="kobo.6474.1">);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6475.1">println</span></span><span class="koboSpan" id="kobo.6476.1">(stdout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.6477.1">"The answer is {}"</span></span><span class="koboSpan" id="kobo.6478.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6479.1">42</span></span><span class="koboSpan" id="kobo.6480.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6481.1">Also, the following two calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6482.1">std::print</span></code><span class="koboSpan" id="kobo.6483.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6484.1">std::println</span></code><span class="koboSpan" id="kobo.6485.1"> have the same result on the standard output stream:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6486.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6487.1">println</span></span><span class="koboSpan" id="kobo.6488.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6489.1">"The answer is {}"</span></span><span class="koboSpan" id="kobo.6490.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6491.1">42</span></span><span class="koboSpan" id="kobo.6492.1">);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6493.1">print</span></span><span class="koboSpan" id="kobo.6494.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6495.1">"The answer is {}\n"</span></span><span class="koboSpan" id="kobo.6496.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6497.1">42</span></span><span class="koboSpan" id="kobo.6498.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6499.1">The format string specification is the same as for </span><code class="inlineCode"><span class="koboSpan" id="kobo.6500.1">std::format</span></code><span class="koboSpan" id="kobo.6501.1"> and was presented previously.</span></p>
<h2 class="heading-2" id="_idParaDest-167"><span class="koboSpan" id="kobo.6502.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6503.1">Using std::format with user-defined types</span></em><span class="koboSpan" id="kobo.6504.1">, to learn how to create custom formatting specialization for user-defined types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6505.1">Converting between numeric and string types</span></em><span class="koboSpan" id="kobo.6506.1">, to learn how to convert between numbers and strings</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-168"><span class="koboSpan" id="kobo.6507.1">Using std::format with user-defined types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6508.1">The</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.6509.1"> C++20 formatting library is </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.6510.1">a modern alternative to using </span><code class="inlineCode"><span class="koboSpan" id="kobo.6511.1">printf</span></code><span class="koboSpan" id="kobo.6512.1">-like functions or the I/O streams library, which it actually complements. </span><span class="koboSpan" id="kobo.6512.2">Although the standard provides default</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.6513.1"> formatting for basic types, such as integral and floating-point types, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6514.1">bool</span></code><span class="koboSpan" id="kobo.6515.1">, character types, strings, and chrono types, the user can create custom specializations for user-defined types. </span><span class="koboSpan" id="kobo.6515.2">In this recipe, we will learn how to do that.</span></p>
<h2 class="heading-2" id="_idParaDest-169"><span class="koboSpan" id="kobo.6516.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6517.1">You should read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.6518.1">Formatting and printing text with std::format and std::print</span></em><span class="koboSpan" id="kobo.6519.1">, to familiarize yourself with the formatting library.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6520.1">In the examples that we’ll be showing here, we will use the following class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6521.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6522.1">employee</span></span><span class="koboSpan" id="kobo.6523.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.6524.1">int</span></span><span class="koboSpan" id="kobo.6525.1">         id;
   std::string firstName;
   std::string lastName;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6526.1">In the next section, we’ll introduce the necessary steps to implement to enable text formatting using </span><code class="inlineCode"><span class="koboSpan" id="kobo.6527.1">std::format()</span></code><span class="koboSpan" id="kobo.6528.1"> for user-defined types.</span></p>
<h2 class="heading-2" id="_idParaDest-170"><span class="koboSpan" id="kobo.6529.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6530.1">To enable formatting using the new formatting library for user-defined types, you must do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6531.1">Define a specialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6532.1">std::formatter&lt;T, CharT&gt;</span></code><span class="koboSpan" id="kobo.6533.1"> class in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6534.1">std</span></code><span class="koboSpan" id="kobo.6535.1"> namespace.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6536.1">Implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6537.1">parse()</span></code><span class="koboSpan" id="kobo.6538.1"> method to parse the portion of the format string corresponding to the current argument. </span><span class="koboSpan" id="kobo.6538.2">If the class inherits from another formatter, then this method can be omitted.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6539.1">Implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6540.1">format()</span></code><span class="koboSpan" id="kobo.6541.1"> method to format the argument and write the output via </span><code class="inlineCode"><span class="koboSpan" id="kobo.6542.1">format_context</span></code><span class="koboSpan" id="kobo.6543.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6544.1">For the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6545.1">employee</span></code><span class="koboSpan" id="kobo.6546.1"> class</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.6547.1"> listed here, a formatter that formats </span><code class="inlineCode"><span class="koboSpan" id="kobo.6548.1">employee</span></code><span class="koboSpan" id="kobo.6549.1"> to the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.6550.1">[42]</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.6551.1">John Doe</span></code><span class="koboSpan" id="kobo.6552.1"> (that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6553.1">[id] firstName lastName</span></code><span class="koboSpan" id="kobo.6554.1">) can be implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6555.1">template</span></span><span class="koboSpan" id="kobo.6556.1"> &lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6557.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6558.1">std</span></span><span class="koboSpan" id="kobo.6559.1">::formatter&lt;employee&gt;
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6560.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6561.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6562.1">parse</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6563.1">(format_parse_context&amp; ctx)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6564.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6565.1">return</span></span><span class="koboSpan" id="kobo.6566.1"> ctx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6567.1">begin</span></span><span class="koboSpan" id="kobo.6568.1">();
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6569.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6570.1">format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6571.1">(employee </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6572.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6573.1"> &amp; e, format_context&amp; ctx)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6574.1"> const </span></span>
<span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.6575.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6576.1">return</span></span><span class="koboSpan" id="kobo.6577.1"> std::format_to(ctx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6578.1">out</span></span><span class="koboSpan" id="kobo.6579.1">(),
                            </span><span class="hljs-string"><span class="koboSpan" id="kobo.6580.1">"[{}] {} {}"</span></span><span class="koboSpan" id="kobo.6581.1">,
                            e.id, e.firstName, e.lastName);
   }
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-171"><span class="koboSpan" id="kobo.6582.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6583.1">The formatting </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.6584.1">library uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6585.1">std::formatter&lt;T, CharT&gt;</span></code><span class="koboSpan" id="kobo.6586.1"> class template to define formatting rules for a given type. </span><span class="koboSpan" id="kobo.6586.2">Built-in types, string types, and chrono types have formatters provided by the library. </span><span class="koboSpan" id="kobo.6586.3">These are implemented as specializations of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6587.1">std::formatter&lt;T, CharT&gt;</span></code><span class="koboSpan" id="kobo.6588.1"> class template.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6589.1">This class has two methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6590.1">parse()</span></code><span class="koboSpan" id="kobo.6591.1">, which takes a single argument of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6592.1">std::basic_format_parse_context&lt;CharT&gt;</span></code><span class="koboSpan" id="kobo.6593.1"> and parses the format’s specification for the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6594.1">T</span></code><span class="koboSpan" id="kobo.6595.1">, provided by the parse context. </span><span class="koboSpan" id="kobo.6595.2">The result of the parsing is supposed to be stored in member fields of the class. </span><span class="koboSpan" id="kobo.6595.3">If the parsing succeeds, this function should return a value of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6596.1">std::basic_format_parse_context&lt;CharT&gt;::iterator</span></code><span class="koboSpan" id="kobo.6597.1">, which represents the end of the format specification. </span><span class="koboSpan" id="kobo.6597.2">If the parsing fails, the function should throw an exception of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6598.1">std::format_error</span></code><span class="koboSpan" id="kobo.6599.1"> to provide details about the error.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6600.1">format()</span></code><span class="koboSpan" id="kobo.6601.1">, which takes two arguments, with the first being the object of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6602.1">T</span></code><span class="koboSpan" id="kobo.6603.1"> to format and the second being a formatting context object of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6604.1">std::basic_format_context&lt;OutputIt, CharT&gt;</span></code><span class="koboSpan" id="kobo.6605.1">. </span><span class="koboSpan" id="kobo.6605.2">This function should write the output to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6606.1">ctx.out()</span></code><span class="koboSpan" id="kobo.6607.1"> according to the desired specifiers (which could be something implicit or the result of parsing the format specification). </span><span class="koboSpan" id="kobo.6607.2">The function must return a value of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6608.1">std::basic_format_context&lt;OutputIt, CharT&gt;::iterator</span></code><span class="koboSpan" id="kobo.6609.1">, representing the end of the output.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6610.1">In the</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.6611.1"> implementation shown in the previous section, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6612.1">parse()</span></code><span class="koboSpan" id="kobo.6613.1"> function does not do anything other than return an iterator </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.6614.1">representing the beginning of the format specification. </span><span class="koboSpan" id="kobo.6614.2">The formatting is always done by printing the employee identifier between square brackets, followed by the first name and the last name, such as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.6615.1">[42] John Doe</span></code><span class="koboSpan" id="kobo.6616.1">. </span><span class="koboSpan" id="kobo.6616.2">An attempt to use a format specifier would result in a compile-time error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6617.1">employee e{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.6618.1">42</span></span><span class="koboSpan" id="kobo.6619.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.6620.1">"John"</span></span><span class="koboSpan" id="kobo.6621.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.6622.1">"Doe"</span></span><span class="koboSpan" id="kobo.6623.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6624.1">auto</span></span><span class="koboSpan" id="kobo.6625.1"> s1 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6626.1">"{}"</span></span><span class="koboSpan" id="kobo.6627.1">, e);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6628.1">// [42] John Doe</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6629.1">auto</span></span><span class="koboSpan" id="kobo.6630.1"> s2 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6631.1">"{:L}"</span></span><span class="koboSpan" id="kobo.6632.1">, e); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6633.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6634.1">If you want your user-defined types to support format specifiers, then you must properly implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6635.1">parse()</span></code><span class="koboSpan" id="kobo.6636.1"> method. </span><span class="koboSpan" id="kobo.6636.2">To show how this can be done, we will support the several specifiers for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6637.1">employee</span></code><span class="koboSpan" id="kobo.6638.1"> class, as defined in the following table:</span></p>
<table class="table-container" id="table018">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6639.1">Specifier</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6640.1">Description</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6641.1">Example</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6642.1">L</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6643.1">Lexicographic order</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6644.1">[42] Doe, John</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6645.1">l</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6646.1">Lowercase</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6647.1">[42] john doe</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6648.1">u</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6649.1">Uppercase</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6650.1">[42] JOHN DOE</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.6651.1">Table 2.18: Specifiers supported for the user-defined employee class</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6652.1">When the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6653.1">L</span></code><span class="koboSpan" id="kobo.6654.1"> specifier is used, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6655.1">employee</span></code><span class="koboSpan" id="kobo.6656.1"> is formatted with the identifier in square brackets, followed by the last name, a comma, and then the first name, such as in </span><em class="italic"><span class="koboSpan" id="kobo.6657.1">[42] Doe, John</span></em><span class="koboSpan" id="kobo.6658.1">. </span><span class="koboSpan" id="kobo.6658.2">A combination of these specifiers is also possible. </span><span class="koboSpan" id="kobo.6658.3">For instance </span><code class="inlineCode"><span class="koboSpan" id="kobo.6659.1">{:Ll}</span></code><span class="koboSpan" id="kobo.6660.1"> would produce </span><em class="italic"><span class="koboSpan" id="kobo.6661.1">[42] doe, john</span></em><span class="koboSpan" id="kobo.6662.1">, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.6663.1">{:uL}</span></code><span class="koboSpan" id="kobo.6664.1"> would produce </span><em class="italic"><span class="koboSpan" id="kobo.6665.1">[42] DOE, JOHN</span></em><span class="koboSpan" id="kobo.6666.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6667.1">The specialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6668.1">std::formatter</span></code><span class="koboSpan" id="kobo.6669.1"> class for the employee class that implements the defined </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.6670.1">requirements may look as</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.6671.1"> follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6672.1">template</span></span><span class="koboSpan" id="kobo.6673.1">&lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6674.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6675.1">std</span></span><span class="koboSpan" id="kobo.6676.1">::formatter&lt;employee&gt;
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6677.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6678.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6679.1">parse</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6680.1">(std::format_parse_context&amp; ctx)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6681.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6682.1">auto</span></span><span class="koboSpan" id="kobo.6683.1"> iter = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6684.1">begin</span></span><span class="koboSpan" id="kobo.6685.1">(ctx);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6686.1">while</span></span><span class="koboSpan" id="kobo.6687.1">(iter != ctx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6688.1">end</span></span><span class="koboSpan" id="kobo.6689.1">() &amp;&amp; *iter != '}')
      {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6690.1">switch</span></span><span class="koboSpan" id="kobo.6691.1"> (*iter)
         {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6692.1">case</span></span><span class="koboSpan" id="kobo.6693.1"> 'L': lexicographic_order = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6694.1">true</span></span><span class="koboSpan" id="kobo.6695.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6696.1">break</span></span><span class="koboSpan" id="kobo.6697.1">;
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6698.1">case</span></span><span class="koboSpan" id="kobo.6699.1"> 'u': uppercase = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6700.1">true</span></span><span class="koboSpan" id="kobo.6701.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6702.1">break</span></span><span class="koboSpan" id="kobo.6703.1">;
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6704.1">case</span></span><span class="koboSpan" id="kobo.6705.1"> 'l': lowercase = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6706.1">true</span></span><span class="koboSpan" id="kobo.6707.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6708.1">break</span></span><span class="koboSpan" id="kobo.6709.1">;
         }
         ++iter;
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6710.1">return</span></span><span class="koboSpan" id="kobo.6711.1"> iter;
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6712.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6713.1">format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6714.1">(employee </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6715.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6716.1">&amp; e, std::format_context&amp; ctx)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.6717.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6718.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6719.1">if</span></span><span class="koboSpan" id="kobo.6720.1"> (lexicographic_order)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6721.1">return</span></span><span class="koboSpan" id="kobo.6722.1"> std::format_to(ctx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6723.1">out</span></span><span class="koboSpan" id="kobo.6724.1">(), 
                               "[{}] {}, {}", 
                               e.id, 
                               </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6725.1">text_format</span></span><span class="koboSpan" id="kobo.6726.1">(e.lastName), 
                               </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6727.1">text_format</span></span><span class="koboSpan" id="kobo.6728.1">(e.firstName));
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6729.1">return</span></span><span class="koboSpan" id="kobo.6730.1"> std::format_to(ctx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6731.1">out</span></span><span class="koboSpan" id="kobo.6732.1">(), 
                            "[{}] {} {}", 
                            e.id, 
                            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6733.1">text_format</span></span><span class="koboSpan" id="kobo.6734.1">(e.firstName),
                            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6735.1">text_format</span></span><span class="koboSpan" id="kobo.6736.1">(e.lastName));
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6737.1">private</span></span><span class="koboSpan" id="kobo.6738.1">:
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.6739.1">bool</span></span><span class="koboSpan" id="kobo.6740.1"> lexicographic_order = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6741.1">false</span></span><span class="koboSpan" id="kobo.6742.1">;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.6743.1">bool</span></span><span class="koboSpan" id="kobo.6744.1"> uppercase = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6745.1">false</span></span><span class="koboSpan" id="kobo.6746.1">;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.6747.1">bool</span></span><span class="koboSpan" id="kobo.6748.1"> lowercase = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6749.1">false</span></span><span class="koboSpan" id="kobo.6750.1">;
   
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6751.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6752.1"> std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6753.1">text_format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6754.1">(std::string text)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.6755.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6756.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6757.1">if</span></span><span class="koboSpan" id="kobo.6758.1">(lowercase)
         std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6759.1">transform</span></span><span class="koboSpan" id="kobo.6760.1">(text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6761.1">begin</span></span><span class="koboSpan" id="kobo.6762.1">(), text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6763.1">end</span></span><span class="koboSpan" id="kobo.6764.1">(), text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6765.1">begin</span></span><span class="koboSpan" id="kobo.6766.1">(),                         ::tolower);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6767.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.6768.1">if</span></span><span class="koboSpan" id="kobo.6769.1">(uppercase)
         std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6770.1">transform</span></span><span class="koboSpan" id="kobo.6771.1">(text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6772.1">begin</span></span><span class="koboSpan" id="kobo.6773.1">(), text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6774.1">end</span></span><span class="koboSpan" id="kobo.6775.1">(), text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6776.1">begin</span></span><span class="koboSpan" id="kobo.6777.1">(),                         ::toupper);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6778.1">return</span></span><span class="koboSpan" id="kobo.6779.1"> text;
   }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6780.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6781.1">parse()</span></code><span class="koboSpan" id="kobo.6782.1"> function </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.6783.1">receives the parsing context that</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.6784.1"> includes the format string. </span><span class="koboSpan" id="kobo.6784.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6785.1">begin()</span></code><span class="koboSpan" id="kobo.6786.1"> iterator points to the first element of the format string after the format delimiter (</span><code class="inlineCode"><span class="koboSpan" id="kobo.6787.1">:</span></code><span class="koboSpan" id="kobo.6788.1">). </span><span class="koboSpan" id="kobo.6788.2">An example is provided in the next table:</span></p>
<table class="table-container" id="table019">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6789.1">Format</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6790.1">begin() iterator</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.6791.1">Range</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6792.1">"{}"</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6793.1">Equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6794.1">end()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6795.1">Empty</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6796.1">"{0}"</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6797.1">Equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6798.1">end()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6799.1">Empty</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6800.1">"{0:L}"</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6801.1">Points to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6802.1">'L'</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6803.1">L}</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6804.1">"{:L}"</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6805.1">Points to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6806.1">'L'</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6807.1">L}</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6808.1">"{:Lul}"</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.6809.1">Points to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6810.1">'L'</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6811.1">Lul}</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.6812.1">Table 2.19: Examples of the content of the parsing context</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6813.1">With this defined, the preceding sample code (using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6814.1">{:L}</span></code><span class="koboSpan" id="kobo.6815.1"> format argument) would work. </span><span class="koboSpan" id="kobo.6815.2">Moreover, various combinations of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6816.1">L</span></code><span class="koboSpan" id="kobo.6817.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6818.1">u</span></code><span class="koboSpan" id="kobo.6819.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6820.1">l</span></code><span class="koboSpan" id="kobo.6821.1"> specifiers can be used, as exemplified next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6822.1">auto</span></span><span class="koboSpan" id="kobo.6823.1"> s1 = std::format("{}", e);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6824.1">// [42] John Doe</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6825.1">auto</span></span><span class="koboSpan" id="kobo.6826.1"> s2 = std::format("{:L}", e);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6827.1">// [42] Doe, John</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6828.1">auto</span></span><span class="koboSpan" id="kobo.6829.1"> s3 = std::format("{:u}", e);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6830.1">// [42] JOHN DOE</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6831.1">auto</span></span><span class="koboSpan" id="kobo.6832.1"> s4 = std::format("{:lL}", e);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6833.1">// [42] doe, john</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.6834.1">// uppercase ignored when lowercase also specified</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6835.1">auto</span></span><span class="koboSpan" id="kobo.6836.1"> s5 = std::format("{:ulL}", e); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6837.1">// [42] doe, john</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6838.1">Multiple usage of the same argument is also possible, as in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6839.1">auto</span></span><span class="koboSpan" id="kobo.6840.1"> s6 = std::format("{</span><span class="hljs-number"><span class="koboSpan" id="kobo.6841.1">0</span></span><span class="koboSpan" id="kobo.6842.1">} = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.6843.1">0</span></span><span class="koboSpan" id="kobo.6844.1">:L}", e);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.6845.1">// [42] John Doe = [42] Doe, John</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6846.1">However, using other format specifiers (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6847.1">A</span></code><span class="koboSpan" id="kobo.6848.1">, for example) would not work; the specifier is simply ignored and the default formatting is used:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6849.1">auto</span></span><span class="koboSpan" id="kobo.6850.1"> s7 = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6851.1">"{:A}"</span></span><span class="koboSpan" id="kobo.6852.1">, e);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6853.1">// [42] John Doe</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6854.1">If you </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.6855.1">do not need to parse the format </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.6856.1">specifier in order to support various options, you could entirely omit the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6857.1">parse()</span></code><span class="koboSpan" id="kobo.6858.1"> method. </span><span class="koboSpan" id="kobo.6858.2">However, in order to do so, your </span><code class="inlineCode"><span class="koboSpan" id="kobo.6859.1">std::formatter</span></code><span class="koboSpan" id="kobo.6860.1"> specialization must derive from another </span><code class="inlineCode"><span class="koboSpan" id="kobo.6861.1">std::formatter</span></code><span class="koboSpan" id="kobo.6862.1"> class. </span><span class="koboSpan" id="kobo.6862.2">An implementation is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6863.1">template</span></span><span class="koboSpan" id="kobo.6864.1">&lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6865.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6866.1">std</span></span><span class="koboSpan" id="kobo.6867.1">::formatter&lt;employee&gt; : std::formatter&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6868.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.6869.1">const</span></span><span class="koboSpan" id="kobo.6870.1">*&gt;
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6871.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6872.1">format</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6873.1">(employee </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6874.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6875.1">&amp; e, </span></span><span class="koboSpan" id="kobo.6876.1">std::format_context</span><span class="hljs-params"><span class="koboSpan" id="kobo.6877.1">&amp; ctx) const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6878.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6879.1">return</span></span><span class="koboSpan" id="kobo.6880.1"> std::format_to(ctx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6881.1">out</span></span><span class="koboSpan" id="kobo.6882.1">(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.6883.1">"[{}] {} {}"</span></span><span class="koboSpan" id="kobo.6884.1">,
                            e.id, e.firstName, e.lastName);
   }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6885.1">This specialization for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6886.1">employee</span></code><span class="koboSpan" id="kobo.6887.1"> class is equivalent to the first implementation shown earlier in the </span><em class="italic"><span class="koboSpan" id="kobo.6888.1">How to do it...</span></em><span class="koboSpan" id="kobo.6889.1"> section.</span></p>
<h2 class="heading-2" id="_idParaDest-172"><span class="koboSpan" id="kobo.6890.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6891.1">The C++23 standard introduces a new concept called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6892.1">std::formattable</span></code><span class="koboSpan" id="kobo.6893.1"> (also in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6894.1">&lt;format&gt;</span></code><span class="koboSpan" id="kobo.6895.1"> header), which specifies that a type is formattable. </span><span class="koboSpan" id="kobo.6895.2">That means that a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.6896.1">std::format</span></code><span class="koboSpan" id="kobo.6897.1"> is available for a type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6898.1">T</span></code><span class="koboSpan" id="kobo.6899.1"> and that it defines the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6900.1">parse()</span></code><span class="koboSpan" id="kobo.6901.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6902.1">format()</span></code><span class="koboSpan" id="kobo.6903.1"> member functions, as described in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-173"><span class="koboSpan" id="kobo.6904.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6905.1">Formatting text with std::format</span></em><span class="koboSpan" id="kobo.6906.1">, to get a good introduction to the new C++20 text formatting library</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.6907.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6908.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_02.xhtml"><span class="url"><span class="koboSpan" id="kobo.6909.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.6910.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>