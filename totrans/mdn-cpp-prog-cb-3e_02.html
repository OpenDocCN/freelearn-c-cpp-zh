<html><head></head><body>
<div><h1 class="chapterNumber">2</h1>
<h1 class="chapterTitle" id="_idParaDest-87">Working with Numbers and Strings</h1>
<p class="normal">Numbers <a id="_idIndexMarker136"/>and strings are <a id="_idIndexMarker137"/>the fundamental types of any programming language; all other types are based on or composed of these. Developers are confronted all the time with tasks such as converting between numbers and strings, parsing and formatting strings, and generating random numbers. This chapter is focused on providing useful recipes for these common tasks using modern C++ language and library features.</p>
<p class="normal">The recipes included in this chapter are as follows:</p>
<ul>
<li class="bulletList">Understanding the various numeric types</li>
<li class="bulletList">Limits and other properties of numeric types</li>
<li class="bulletList">Converting between numeric and string types</li>
<li class="bulletList">Understanding the various character and string types</li>
<li class="bulletList">Printing Unicode characters to the output console</li>
<li class="bulletList">Generating pseudo-random numbers</li>
<li class="bulletList">Properly initializing a pseudo-random number generator</li>
<li class="bulletList">Creating cooked user-defined literals</li>
<li class="bulletList">Creating raw user-defined literals</li>
<li class="bulletList">Using raw string literals to avoid escaping characters</li>
<li class="bulletList">Creating a library of string helpers</li>
<li class="bulletList">Verifying the format of a string using regular expressions</li>
<li class="bulletList">Parsing the content of a string using regular expressions</li>
<li class="bulletList">Replacing the content of a string using regular expressions</li>
<li class="bulletList">Using <code class="inlineCode">std::string_view</code> instead of constant string references</li>
<li class="bulletList">Formatting and printing text with <code class="inlineCode">std::format</code> and <code class="inlineCode">std::print</code></li>
<li class="bulletList">Using <code class="inlineCode">std::format</code> with user-defined types</li>
</ul>
<p class="normal">Let’s start this chapter by looking at the different numeric types that exist in the C++ programming language.</p>
<h1 class="heading-1" id="_idParaDest-88">Understanding the various numeric types</h1>
<p class="normal">The C++ programming language <a id="_idIndexMarker138"/>defines a multitude of arithmetic types; these are types on which arithmetic operations (addition, subtraction, multiplication, division, modulo) can be performed. This category includes character, integral, and floating-point types. Many of these types are inherited from the C programming languages, while some have been added to C++ in recent versions of the standard. A typical problem with the arithmetic types is that, unlike many other programming languages, most of them don’t have a fixed size. The size varies with the target platform and the standard only guarantees a minimum one. In this recipe, we will learn about the various integral and floating-point types.</p>
<h2 class="heading-2" id="_idParaDest-89">How to do it…</h2>
<p class="normal">Use one of the<a id="_idIndexMarker139"/> available numeric types depending on the kind of value you need to represent:</p>
<ul>
<li class="bulletList">To represent an integral value (when the range doesn’t really matter), use the <code class="inlineCode">int</code> type. This is the default basic (signed) integer type, typically with a size of 32 bits, but not guaranteed. You can use it for values such as the age of a person, the day, month, and year in a date, the rating of a movie or book, the number of items in a collection, and countless other things:
        <pre class="programlisting code"><code class="hljs-code">int age = 42;
int attendance = 96321;
</code></pre>
</li>
<li class="bulletList">Use signedness (<code class="inlineCode">signed</code>/<code class="inlineCode">unsigned</code>) and size (<code class="inlineCode">short</code>/<code class="inlineCode">long</code>/<code class="inlineCode">long long</code>) modifiers when you need to impose restrictions on the range of possible values or the memory representation. For instance, you may want to use unsigned integers to represent values that cannot have negative values. Mixing signed and unsigned integers should be avoided. On the other hand, you may want to optimize the memory used for storing some values, such as those representing a date, in which case you could use a <code class="inlineCode">short int</code>, guaranteed to be at least 16 bits. If you need to represent large values, such as the size of a file, you can use <code class="inlineCode">unsigned long long int</code>, which is guaranteed to be at least 64 bits:
        <pre class="programlisting code"><code class="hljs-code">unsigned int length = 32;
short year = 2023; // same as short int
unsigned long long filesize = 3'758'096'384;
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker140"/>represent <code class="inlineCode">std::array</code> indexes (which cannot be negative), the number of elements in a collection (such as standard containers), or the result of the <code class="inlineCode">sizeof</code> operator, use <code class="inlineCode">std::size_t</code>. This is an unsigned integer type of at least 16 bits. The standard containers defined a member type alias called <code class="inlineCode">size_type</code> for size and indexing the container, and this type is typically a synonym for <code class="inlineCode">std::size_t</code>:
        <pre class="programlisting code"><code class="hljs-code">std::size_t items = arr.size();
</code></pre>
</li>
<li class="bulletList">To store the result of a pointer arithmetic operation, or present a C-like array index (which can be negative), use <code class="inlineCode">std::ptrdiff_t</code>. The C++ standard containers define a member type alias called <code class="inlineCode">difference_type</code> to store differences between iterators, and this is typically defined as a synonym for <code class="inlineCode">std::ptrdiff_t</code>.</li>
<li class="bulletList">When you need to store a value that needs a guaranteed range, use one of the <code class="inlineCode">std::int8_t</code>, <code class="inlineCode">std::int16_t</code>, <code class="inlineCode">std::int32_t</code>, or <code class="inlineCode">std::int64_t</code> types. Although these are optional, they are defined for all modern architectures.</li>
<li class="bulletList">When you need to store non-negative values or perform bit manipulations on values of a guaranteed range, use one of the <code class="inlineCode">std::uint8_t</code>, <code class="inlineCode">std::uint16_t</code>, <code class="inlineCode">std::uint32_t</code>, or <code class="inlineCode">std::uint64_t</code> types.</li>
<li class="bulletList">When you need to store a value that needs a guaranteed range and, at the same time, you want to optimize for fastest access, use one of the <code class="inlineCode">std::int_fast8_t</code>, <code class="inlineCode">std::int_fast16_t</code>, <code class="inlineCode">std::int_fast32_t</code>, or <code class="inlineCode">std::int_fast64_t</code> types (or their unsigned counterparts). These are guaranteed to be available on all target architectures.</li>
<li class="bulletList">When you need to store a value that needs a guaranteed range and, at the same time, you want to optimize the memory usage, use one of <code class="inlineCode">std::int_least8_t</code>, <code class="inlineCode">std::int_last16_t</code>, <code class="inlineCode">std::int_least32_t</code>, or <code class="inlineCode">std::int_least64_t</code> (or their unsigned counterparts). These are also guaranteed to be available on all target architectures.</li>
<li class="bulletList">To represent a real number, use the type <code class="inlineCode">double</code>. This is the default floating-point type, with a size of 64 bits. The name indicates a double precision type, as <a id="_idIndexMarker141"/>opposed to a single precision type (using 32 bits), implemented with the <code class="inlineCode">float</code> type. An extended precision type, called <code class="inlineCode">long double</code>, is also available. The standard does not specify its actual precision but requires that it’s at least the same as the <code class="inlineCode">double</code> type. On some compilers, this can be a quadruple precision (using 128 bits), although some, such as VC++, treat it as equal to <code class="inlineCode">double</code>:
        <pre class="programlisting code"><code class="hljs-code">double price = 4.99;
float temperature = 36.5;
long double pi = 3.14159265358979323846264338327950288419716939937510L;
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-90">How it works…</h2>
<p class="normal">The C++ language <a id="_idIndexMarker142"/>has one basic integral type, <code class="inlineCode">int</code>, and several modifiers that can be applied to it, for signedness and size. The type <code class="inlineCode">int</code> is a signed one, so <code class="inlineCode">int</code> and <code class="inlineCode">signed int</code> are the same type. The use of <code class="inlineCode">int</code> is actually optional when using a modifier. Therefore, the following types are equivalent:</p>
<table class="table-container" id="table001-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Equivalent to</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">signed</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">short</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">short int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">signed short</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">short int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">signed short int</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">short int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long long</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long long int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned short</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned short int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned long </code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned long int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned long long</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned long long int</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.1: Integral type equivalence</p>
<p class="normal">This table<a id="_idIndexMarker143"/> does <a id="_idIndexMarker144"/>not list all the possible combinations, only several examples. The order of the type modifiers is not specified; therefore, any order is permitted. The following table lists several types that represent the same type:</p>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Equivalent type</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long long unsigned int</code></p>
</td>
<td class="table-cell" rowspan="5">
<p class="normal"><code class="inlineCode">unsigned long long int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long unsigned long int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">int long long unsigned</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unsigned long long int</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">int long unsigned long</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.2: Integral type equivalence with modifiers</p>
<p class="normal">Even though the<a id="_idIndexMarker145"/> order is undefined, it is a common practice to start with the signedness modifier, then the size modifier, and finally the <code class="inlineCode">int</code> type. Therefore, the canonical form for the types on the left column in the previous table is <code class="inlineCode">unsigned long long int</code>.</p>
<p class="normal">Regardless of the signedness or size of an integral type, a<a id="_idIndexMarker146"/> process called <em class="italic">overflow</em> or <em class="italic">underflow</em> can <a id="_idIndexMarker147"/>occur. Overflow occurs when an attempt to store a value greater than the maximum value of the data type happens. Underflow occurs in the opposite case, when an attempt to store a value smaller than the minimum value of the data type happens.</p>
<p class="normal">Let’s consider the case of the <code class="inlineCode">short</code> type. This is a signed integer type that can store values in the range of -32,768 to 32,767. What happens if we want to store 32,768? Since this is greater than the maximum, an overflow occurs. The decimal 32,767 is 01111111 11111111 in binary and the next value is 10000000 00000000, which, on a 16-bit representation, is -32,768 in decimal. The following table shows overflows and underflows:</p>
<table class="table-container" id="table003">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Value to store</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Stored value</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-32771</p>
</td>
<td class="table-cell">
<p class="normal">32765</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-32770</p>
</td>
<td class="table-cell">
<p class="normal">32766</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-32769</p>
</td>
<td class="table-cell">
<p class="normal">32767</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-32768</p>
</td>
<td class="table-cell">
<p class="normal">-32768</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">…</p>
</td>
<td class="table-cell">
<p class="normal">…</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">32767</p>
</td>
<td class="table-cell">
<p class="normal">32767</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">32768</p>
</td>
<td class="table-cell">
<p class="normal">-32768</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">32769</p>
</td>
<td class="table-cell">
<p class="normal">-32767</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">32770</p>
</td>
<td class="table-cell">
<p class="normal">-32765</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.3: Examples of short int values with overflow and underflow</p>
<p class="normal">The same<a id="_idIndexMarker148"/> examples are shown in a different form in the following image, which you might find simpler to understand:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_01.png"/></figure>
<p class="packt_figref">Figure 2.1: Example of short int values with overflow and underflow</p>
<p class="normal">If, instead <a id="_idIndexMarker149"/>of <code class="inlineCode">short</code>, we consider the <code class="inlineCode">unsigned short</code> type, the same problems occur, although they might be easier to understand. The range for <code class="inlineCode">unsigned short</code> is 0 to 65,535. Attempting to store 65,536 will result in the value 0 being stored. Similarly, attempting to store 65,537 will result in the value 1 being stored instead. This is the result of the modulo operation between the value to be stored and the number of values that can be stored by the data type. In the case of <code class="inlineCode">unsigned short</code>, this is 2^16 or 62,536. For underflow, the result happens in a similar way. The value -1 becomes 65,535, -2 becomes 65,534, and so forth. This is the same as adding the negative value to 65,536 and then performing the modulo 65,536 operation. The overflows and underflows are shown in the following table:</p>
<table class="table-container" id="table004">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Value to store</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Stored value</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-2</p>
</td>
<td class="table-cell">
<p class="normal">65534</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-1</p>
</td>
<td class="table-cell">
<p class="normal">65535</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">0</p>
</td>
<td class="table-cell">
<p class="normal">0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">…</p>
</td>
<td class="table-cell">
<p class="normal">…</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">65535</p>
</td>
<td class="table-cell">
<p class="normal">65535</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">65536</p>
</td>
<td class="table-cell">
<p class="normal">0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">65537</p>
</td>
<td class="table-cell">
<p class="normal">1</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.4: Examples of unsigned short int with overflow and underflow</p>
<p class="normal">Similarly, the<a id="_idIndexMarker150"/> same<a id="_idIndexMarker151"/> values are exemplified in the next image:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_02.png"/></figure>
<p class="packt_figref">Figure 2.2: Examples of unsigned short int with overflow and underflow</p>
<p class="normal">A significant problem with integral types in C++ is the lack of specification for their size. The only well-defined size is for the <code class="inlineCode">char</code> type (and its <code class="inlineCode">signed</code> and <code class="inlineCode">unsigned</code> modifiers), which must be 1. For the rest, the following relation applies:</p>
<pre class="programlisting code"><code class="hljs-code">1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)
</code></pre>
<p class="normal">In practice, on most platforms, <code class="inlineCode">short</code> is 16-bit, <code class="inlineCode">int</code> and <code class="inlineCode">long</code> are both 32-bit, and <code class="inlineCode">long long</code> is 64-bit. However, there are platforms where <code class="inlineCode">long</code> and <code class="inlineCode">long long</code> are both 64-bit or where <code class="inlineCode">int</code> is 16-bit. To overcome this heterogeneity, the C++11 standard introduced a series of fixed-width integer types. These are defined in the <code class="inlineCode">&lt;cstdint&gt;</code> header and are grouped into<a id="_idIndexMarker152"/> two categories:</p>
<ul>
<li class="bulletList">A category of types that are optional and might not be available on some platforms. These types have an exact number of bits, as specified by their name:<ul>
<li class="bulletList"><code class="inlineCode">int8_t</code> and <code class="inlineCode">uint8_t</code> are 8-bit</li>
<li class="bulletList"><code class="inlineCode">int16_t</code> and <code class="inlineCode">uint16_t</code> are 16-bit</li>
<li class="bulletList"><code class="inlineCode">int32_t</code> and <code class="inlineCode">uint32_t</code> are 32-bit</li>
<li class="bulletList"><code class="inlineCode">int64_t</code> and <code class="inlineCode">uint64_t</code> are 64-bit</li>
<li class="bulletList">There are also <code class="inlineCode">intptr_t</code> and <code class="inlineCode">uintptr_t</code> that have a size large enough to store a pointer to void</li>
</ul>
</li>
<li class="bulletList">A category of types that are mandatory and, therefore, available on all platforms. These, in turn, are grouped into two categories:<ul>
<li class="bulletList">One that is optimized for fast access; these are called <code class="inlineCode">int_fastX_t</code> and <code class="inlineCode">uint_fastX_t</code>, where <code class="inlineCode">X</code> is 8, 16, 32, or 64, representing the number of bits. These types provide the integral type that is fastest to access on a particular architecture that also has a width at least the size <code class="inlineCode">X</code>.</li>
<li class="bulletList">One that is optimized for memory consumption; these are called <code class="inlineCode">int_leastX_t</code> and <code class="inlineCode">uint_leastX_t</code>, where <code class="inlineCode">X</code> is 8, 16, 32, or 64, representing the number of bits. These types provide the integral type that is the smallest to represent on a particular architecture but that also has a width of at least the size <code class="inlineCode">X</code>.</li>
</ul>
</li>
</ul>
<p class="normal">In practice, most compilers treat the 8-bit types (<code class="inlineCode">int8_t</code>, <code class="inlineCode">uint8_t</code>, <code class="inlineCode">int_least8_t</code>, <code class="inlineCode">uint_least8_t</code>, <code class="inlineCode">int_fast8_t</code>, and <code class="inlineCode">uint_fast8_t</code>) as identical to <code class="inlineCode">signed char</code> and <code class="inlineCode">unsigned char</code>. This means that on different systems, a program using them may behave differently from a program using the other fixed-width integer types. Here is an example to demonstrate this:</p>
<pre class="programlisting code"><code class="hljs-code">std::int8_t x = 42;
std::cout &lt;&lt; x &lt;&lt; '\n'; // [1] prints *
std::int16_t y = 42;
std::cout &lt;&lt; y &lt;&lt; '\n'; // [2] prints 42
</code></pre>
<p class="normal">Both <code class="inlineCode">x</code> and <code class="inlineCode">y</code> are of fixed-width integer types and both are assigned the value 42. However, when <a id="_idIndexMarker153"/>printing their value to the console, <code class="inlineCode">x</code> will be printed as <code class="inlineCode">*</code> instead of 42. Keep in mind, though, that this is not a guarantee as the behavior is system-dependent.</p>
<p class="normal">Therefore, you might want to avoid using the 8-bit fixed-width integer types and prefer <code class="inlineCode">int16_t</code>/<code class="inlineCode">uint16_t</code> or one of the fast/least variants.</p>
<div><p class="normal">When writing numerical literals, you can use the single quotation mark (<code class="inlineCode">'</code>) as a digit separator. This makes it easier to read large numbers, and perhaps compare them visually. It can be used for decimal, hexadecimal, octal, and binary numbers, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">auto a = 4'234'871'523ll;        // 4234871523
auto b = 0xBAAD'F00D;            // 3131961357
auto c = 00'12'34;               // 668
auto d = 0b1011'01011'0001'1001; // 46361
</code></pre>
<p class="normal">The digit separators are ignored when determining the numerical value, so their position is irrelevant. This means you can write numbers in formats that have no practical meaning without producing an error:</p>
<pre class="programlisting code"><code class="hljs-code">auto e = 1'2'3'4'5;
</code></pre>
</div>
<h2 class="heading-2" id="_idParaDest-91">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Understanding the various character and string types</em>, to learn about the different character and string types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-92">Limits and other properties of numeric types</h1>
<p class="normal">Sometimes, it is <a id="_idIndexMarker154"/>necessary to know and use the minimum and maximum values <a id="_idIndexMarker155"/>that can be represented with a numeric type, such as <code class="inlineCode">char</code>, <code class="inlineCode">int</code>, or <code class="inlineCode">double</code>. Many developers use standard C macros for this, such as <code class="inlineCode">CHAR_MIN</code>/<code class="inlineCode">CHAR_MAX</code>, <code class="inlineCode">INT_MIN</code>/<code class="inlineCode">INT_MAX</code>, and <code class="inlineCode">DBL_MIN</code>/<code class="inlineCode">DBL_MAX</code>. C++ provides a class template called <code class="inlineCode">numeric_limits</code> with specializations for every numeric type, which enables you to query the minimum and maximum value of a type. However, <code class="inlineCode">numeric_limits</code> is not limited to that functionality and offers additional constants for type property querying, such as whether a type is signed or not, how many bits it needs for representing<a id="_idIndexMarker156"/> its values, whether it can represent infinity for floating-point types, and many others. Prior to C++11, the use of <code class="inlineCode">numeric_limits&lt;T&gt;</code> was limited because it could not be used in places where constants were needed (examples include the size of arrays and switch cases). Due to that, developers preferred to use C macros throughout their code. In C++11, that is no longer the case, as all the static members of <code class="inlineCode">numeric_limits&lt;T&gt;</code> are now <code class="inlineCode">constexpr</code>, which means they can be used everywhere a constant expression is expected.</p>
<h2 class="heading-2" id="_idParaDest-93">Getting ready</h2>
<p class="normal">The <code class="inlineCode">numeric_limits&lt;T&gt;</code> class template is available in the namespace <code class="inlineCode">std</code> in the <code class="inlineCode">&lt;limits&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-94">How to do it...</h2>
<p class="normal">Use <code class="inlineCode">std::numeric_limits&lt;T&gt;</code> to query various properties of a numeric type <code class="inlineCode">T</code>:</p>
<ul>
<li class="bulletList">Use the <code class="inlineCode">min()</code> and <code class="inlineCode">max()</code> static methods to get the smallest and largest finite numbers of a type. The following are examples of how these could be used:
        <pre class="programlisting code"><code class="hljs-code">// example 1
template&lt;typename T, typename Iter&gt;
T minimum(Iter const start, Iter const end) // finds the
 // minimum value
 // in a range
{
  T minval = std::numeric_limits&lt;T&gt;::max();
  for (auto i = start; i &lt; end; ++i)
  {
    if (*i &lt; minval)
      minval = *i;
  }
  return minval;
}
// example 2
int range[std::numeric_limits&lt;char&gt;::max() + 1] = { 0 };
// example 3
switch(get_value())
{
  case std::numeric_limits&lt;int&gt;::min():
  // do something
break;
}
</code></pre>
</li>
<li class="bulletList">Use <a id="_idIndexMarker157"/>other static methods and static constants to retrieve other properties of a numeric type. In the following example, the <code class="inlineCode">bits</code> variable is an <code class="inlineCode">std::bitset</code> object that contains a sequence of bits that are necessary to represent the numerical value represented by the variable <code class="inlineCode">n</code> (which is an integer):
        <pre class="programlisting code"><code class="hljs-code">auto n = 42;
std::bitset&lt;std::numeric_limits&lt;decltype(n)&gt;::digits&gt;
   bits { static_cast&lt;unsigned long long&gt;(n) };
</code></pre>
</li>
</ul>
<div><p class="normal">In C++11, there is no limitation to where <code class="inlineCode">std::numeric_limits&lt;T&gt;</code> can be used; therefore, preferably, use it over C macros in your modern C++ code.</p>
</div>
<h2 class="heading-2" id="_idParaDest-95">How it works...</h2>
<p class="normal">The <code class="inlineCode">std::numeric_limits&lt;T&gt;</code> class template enables developers to query properties of numeric types. Actual values are available through specializations, and the standard library provides specializations for all the built-in numeric types (<code class="inlineCode">char</code>, <code class="inlineCode">short</code>, <code class="inlineCode">int</code>, <code class="inlineCode">long</code>, <code class="inlineCode">float</code>, <code class="inlineCode">double</code>, and so on). In addition, third parties may provide additional implementations for other types. An example could be a numeric library that implements a <code class="inlineCode">bigint</code> type and a <code class="inlineCode">decimal</code> type and provides specializations of <code class="inlineCode">numeric_limits</code> for these types (such as <code class="inlineCode">numeric_limits&lt;bigint&gt;</code> and <code class="inlineCode">numeric_limits&lt;decimal&gt;</code>).</p>
<p class="normal">The following specializations of numeric types are available in the <code class="inlineCode">&lt;limits&gt;</code> header. Note that specializations for <code class="inlineCode">char16_t</code> and <code class="inlineCode">char32_t</code> are new in C++11; the others were available previously. Apart from the specializations listed ahead, the library also includes specializations for every <code class="inlineCode">cv-qualified</code> version of these numeric types, and they are identical to the unqualified specialization. For example, consider the type <code class="inlineCode">int</code>; there are four actual specializations (and they are identical): <code class="inlineCode">numeric_limits&lt;int&gt;</code>, <code class="inlineCode">numeric_limits&lt;const int&gt;</code>, <code class="inlineCode">numeric_limits&lt;volatile int&gt;</code>, and <code class="inlineCode">numeric_limits&lt;const volatile int&gt;</code>. You can find the entire list of specializations at <a href="https://en.cppreference.com/w/cpp/types/numeric_limits">https://en.cppreference.com/w/cpp/types/numeric_limits</a>.</p>
<p class="normal">As mentioned <a id="_idIndexMarker158"/>earlier, in C++11, all static members of <code class="inlineCode">std::numeric_limits</code> are <code class="inlineCode">constexpr</code>, which means they can be used in all the places where constant expressions are needed. These have several major advantages over C++ macros:</p>
<ul>
<li class="bulletList">They are easier to remember, as the only thing you need to know is the name of the type, which you should know anyway, and not countless names of macros.</li>
<li class="bulletList">They support types that are not available in C, such as <code class="inlineCode">char16_t</code> and <code class="inlineCode">char32_t</code>.</li>
<li class="bulletList">They are the only possible solutions for templates where you don’t know the type.</li>
<li class="bulletList"><code class="inlineCode">min</code> and <code class="inlineCode">max</code> are only two of the various properties of types it provides; therefore, its actual use is beyond the numeric limits shown. As a side note, for this reason, the class should have been perhaps called <em class="italic">numeric_properties</em>, instead of <code class="inlineCode">numeric_limits</code>.</li>
</ul>
<p class="normal">The following function template, <code class="inlineCode">print_type_properties()</code>, prints the minimum and maximum finite values of the type, as well as other information:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
void print_type_properties()
{
  std::cout
    &lt;&lt; "min="
    &lt;&lt; std::numeric_limits&lt;T&gt;::min()        &lt;&lt; '\n'
    &lt;&lt; "max="
    &lt;&lt; std::numeric_limits&lt;T&gt;::max()        &lt;&lt; '\n'
    &lt;&lt; "bits="
    &lt;&lt; std::numeric_limits&lt;T&gt;::digits       &lt;&lt; '\n'
    &lt;&lt; "decdigits="
    &lt;&lt; std::numeric_limits&lt;T&gt;::digits10     &lt;&lt; '\n'
    &lt;&lt; "integral="
    &lt;&lt; std::numeric_limits&lt;T&gt;::is_integer   &lt;&lt; '\n'
    &lt;&lt; "signed="
    &lt;&lt; std::numeric_limits&lt;T&gt;::is_signed    &lt;&lt; '\n'
    &lt;&lt; "exact="
    &lt;&lt; std::numeric_limits&lt;T&gt;::is_exact     &lt;&lt; '\n'
    &lt;&lt; "infinity="
    &lt;&lt; std::numeric_limits&lt;T&gt;::has_infinity &lt;&lt; '\n';
}
</code></pre>
<p class="normal">If we call<a id="_idIndexMarker159"/> the <code class="inlineCode">print_type_properties()</code> function for <code class="inlineCode">unsigned</code> <code class="inlineCode">short</code>, <code class="inlineCode">int</code>, and <code class="inlineCode">double</code>, we will get the following output:</p>
<table class="table-container" id="table005">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">unsigned short</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">int</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">double</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con">min=0
max=65535
bits=16
decdigits=4
integral=1
signed=0
exact=1
infinity=0
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con">min=-2147483648
max=2147483647
bits=31
decdigits=9
integral=1
signed=1
exact=1
infinity=0
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con">min=2.22507e-308
max=1.79769e+308
bits=53
decdigits=15
integral=0
signed=1
exact=0
infinity=1
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.5: The output of print_type_properties() for unsigned short, int, and double</p>
<p class="normal">Please note that there is a difference between the <code class="inlineCode">digits</code> and <code class="inlineCode">digits10</code> constants:</p>
<ul>
<li class="bulletList"><code class="inlineCode">digits</code> represents the number of bits (excluding the sign bit if present) and padding bits (if any) for integral types and the number of bits of the mantissa for floating-point types.</li>
<li class="bulletList"><code class="inlineCode">digits10</code> is the number of decimal digits that can be represented by a type without a change. To understand this better, let’s consider the case of <code class="inlineCode">unsigned short</code>. This is a 16-bit integral type. It can represent numbers between 0 and 65,536. It can represent numbers up to five decimal digits, 10,000 to 65,536, but it cannot represent all five decimal digit numbers, as numbers from 65,537 to 99,999 require more bits. Therefore, the largest numbers that it can represent without requiring more bits have four decimal digits (numbers from 1,000 to 9,999). This is the value indicated by <code class="inlineCode">digits10</code>. For integral types, it has a direct relationship to constant <code class="inlineCode">digits</code>; for an integral type, <code class="inlineCode">T</code>, the value of <code class="inlineCode">digits10</code> is <code class="inlineCode">std::numeric_limits&lt;T&gt;::digits * std::log10(2)</code>.</li>
</ul>
<p class="normal">It’s worth <a id="_idIndexMarker160"/>mentioning that the standard library types that are aliases of arithmetic types (such as <code class="inlineCode">std::size_t</code>) may also be inspected with <code class="inlineCode">std::numeric_limits</code>. On the other hand, other standard types that are not arithmetic types, such as <code class="inlineCode">std::complex&lt;T&gt;</code> or <code class="inlineCode">std::nullptr_t</code>, do not have <code class="inlineCode">std::numeric_limits</code> specializations.</p>
<h2 class="heading-2" id="_idParaDest-96">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Converting between numeric and string types</em>, to learn how to convert between numbers and strings</li>
</ul>
<h1 class="heading-1" id="_idParaDest-97">Converting between numeric and string types</h1>
<p class="normal">Converting between number and string types is a ubiquitous operation. Prior to C++11, there was little support for converting numbers to strings and back, so developers had to resort<a id="_idIndexMarker161"/> mostly to type-unsafe functions, and they usually wrote their own utility functions in order to avoid writing the same code over <a id="_idIndexMarker162"/>and over again. With C++11, the standard library provides utility functions for converting between numbers and strings. In this recipe, you will learn how to convert between numbers and strings and the other way around using modern C++ standard functions.</p>
<h2 class="heading-2" id="_idParaDest-98">Getting ready</h2>
<p class="normal">All the utility functions mentioned in this recipe are available in the <code class="inlineCode">&lt;string&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-99">How to do it...</h2>
<p class="normal">Use the <a id="_idIndexMarker163"/>following standard conversion functions when you need to convert between numbers and strings:</p>
<ul>
<li class="bulletList">To convert<a id="_idIndexMarker164"/> from an integer or floating-point type to a string type, use <code class="inlineCode">std::to_string()</code> or <code class="inlineCode">std::to_wstring()</code>, as shown in the following code snippet:
        <pre class="programlisting code"><code class="hljs-code">auto si = std::to_string(42);      // si="42"
auto sl = std::to_string(42L);     // sl="42"
auto su = std::to_string(42u);     // su="42"
auto sd = std::to_wstring(42.0);   // sd=L"42.000000"
auto sld = std::to_wstring(42.0L); // sld=L"42.000000"
</code></pre>
</li>
<li class="bulletList">To convert from a string type to an integer type, use <code class="inlineCode">std::stoi()</code>, <code class="inlineCode">std::stol()</code>, <code class="inlineCode">std::stoll()</code>, <code class="inlineCode">std::stoul()</code>, or <code class="inlineCode">std::stoull()</code>, as shown in the following code snippet:
        <pre class="programlisting code"><code class="hljs-code">auto i1 = std::stoi("42");                  // i1 = 42
auto i2 = std::stoi("101010"L, nullptr, 2); // i2 = 42
auto i3 = std::stoi("052", nullptr, 8);     // i3 = 42
auto i4 = std::stoi("0x2A"L, nullptr, 16);  // i4 = 42
</code></pre>
</li>
<li class="bulletList">To convert from a string type to a floating-point type, use <code class="inlineCode">std::stof()</code>, <code class="inlineCode">std::stod()</code>, or <code class="inlineCode">std::stold()</code>, as shown in the following code snippet:
        <pre class="programlisting code"><code class="hljs-code">// d1 = 123.45000000000000
auto d1 = std::stod("123.45");
// d2 = 123.45000000000000
auto d2 = std::stod("1.2345e+2");
// d3 = 123.44999980926514
auto d3 = std::stod("0xF.6E6666p3");
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-100">How it works...</h2>
<pre>int</code> of these two functions:</pre>
<pre class="programlisting code"><code class="hljs-code">std::string to_string(int value);
std::wstring to_wstring(int value);
</code></pre>
<p class="normal">In addition <a id="_idIndexMarker167"/>to <code class="inlineCode">int</code>, these two functions have overloads for <code class="inlineCode">long</code>, <code class="inlineCode">long long</code>, <code class="inlineCode">unsigned int</code>, <code class="inlineCode">unsigned long</code>, <code class="inlineCode">unsigned long long</code>, <code class="inlineCode">float</code>, <code class="inlineCode">double</code>, and <code class="inlineCode">long double</code>.</p>
<p class="normal">When it comes<a id="_idIndexMarker168"/> to the opposite conversion, there is an entire set of functions that have a name with the format <strong class="keyWord">sto</strong><em class="italic">n</em> (<strong class="keyWord">string to number</strong>), where <em class="italic">n</em> stands for <strong class="keyWord">i</strong> (<code class="inlineCode">integer</code>), <strong class="keyWord">l</strong> (<code class="inlineCode">long</code>), <strong class="keyWord">ll</strong> (<code class="inlineCode">long long</code>), <strong class="keyWord">ul</strong> (<code class="inlineCode">unsigned long</code>), or <strong class="keyWord">ull</strong> (<code class="inlineCode">unsigned long long</code>). The following list shows the <code class="inlineCode">stoi</code> function with its two overloads—one that takes an <code class="inlineCode">std::string</code> and one that takes an <code class="inlineCode">std::wstring</code> as the first parameter. In addition, there are similar functions called <code class="inlineCode">stol</code>, <code class="inlineCode">stoll</code>, <code class="inlineCode">stoul</code>, <code class="inlineCode">stoull</code>, <code class="inlineCode">stof</code>, <code class="inlineCode">stod</code>, and <code class="inlineCode">stold</code>:</p>
<pre class="programlisting code"><code class="hljs-code">int stoi(const std::string&amp; str, std::size_t* pos = 0, int base = 10);
int stoi(const std::wstring&amp; str, std::size_t* pos = 0, int base = 10);
</code></pre>
<p class="normal">The way the string to integral type functions work is by discarding all white spaces before a non-whitespace character, then taking as many characters as possible to form a signed or unsigned number (depending on the case), and then converting that to the requested integral type (<code class="inlineCode">stoi()</code> will return an <code class="inlineCode">integer</code>, <code class="inlineCode">stoul()</code> will return an <code class="inlineCode">unsigned long</code>, and so on). In all the following examples, the result is the integer <code class="inlineCode">42</code>, except for the last example, where the result is <code class="inlineCode">-42</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto i1 = std::stoi("42");             // i1 = 42
auto i2 = std::stoi("   42");          // i2 = 42
auto i3 = std::stoi("   42fortytwo");  // i3 = 42
auto i4 = std::stoi("+42");            // i4 = 42
auto i5 = std::stoi("-42");            // i5 = -42
</code></pre>
<p class="normal">A valid integral number may consist of the following parts:</p>
<ul>
<li class="bulletList">A sign, plus (<code class="inlineCode">+</code>) or minus (<code class="inlineCode">-</code>) (optional)</li>
<li class="bulletList">The prefix <code class="inlineCode">0</code> to indicate an octal base (optional)</li>
<li class="bulletList">The prefix <code class="inlineCode">0x</code> or <code class="inlineCode">0X</code> to indicate a hexadecimal base (optional)</li>
<li class="bulletList">A sequence of digits</li>
</ul>
<p class="normal">The optional prefix <code class="inlineCode">0</code> (for octal) is applied only when the specified base is <code class="inlineCode">8</code> or <code class="inlineCode">0</code>. Similarly, the optional prefix <code class="inlineCode">0x</code> or <code class="inlineCode">0X</code> (for hexadecimal) is applied only when the specified base is <code class="inlineCode">16</code> or <code class="inlineCode">0</code>.</p>
<p class="normal">The functions that convert a string to an integer have three parameters:</p>
<ul>
<li class="bulletList">The input string.</li>
<li class="bulletList">A pointer that, when not null, will receive the number of characters that were processed. This can include any leading white spaces that were discarded, the sign, and the base prefix, so it should not be confused with the number of digits the integral value has.</li>
<li class="bulletList">A number indicating the base; by default, this is <code class="inlineCode">10</code>.</li>
</ul>
<p class="normal">The<a id="_idIndexMarker169"/> valid<a id="_idIndexMarker170"/> digits in the input string depend on the base. For base <code class="inlineCode">2</code>, the only valid digits are <code class="inlineCode">0</code> and <code class="inlineCode">1</code>; for base <code class="inlineCode">5</code>, they are <code class="inlineCode">01234</code>. For base <code class="inlineCode">11</code>, the valid digits are <code class="inlineCode">0</code>-<code class="inlineCode">9</code> and the characters <code class="inlineCode">A</code> and <code class="inlineCode">a</code>. This continues until we reach base <code class="inlineCode">36</code>, which has the valid characters <code class="inlineCode">0</code>-<code class="inlineCode">9</code>, <code class="inlineCode">A</code>-<code class="inlineCode">Z</code>, and <code class="inlineCode">a</code>-<code class="inlineCode">z</code>.</p>
<p class="normal">The following are additional examples of strings with numbers in various bases converted to decimal integers. Again, in all cases, the result is either <code class="inlineCode">42</code> or <code class="inlineCode">-42</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto i6 = std::stoi("052", nullptr, 8);      // i6 = 42
auto i7 = std::stoi("052", nullptr, 0);      // i7 = 42
auto i8 = std::stoi("0x2A", nullptr, 16);    // i8 = 42
auto i9 = std::stoi("0x2A", nullptr, 0);     // i9 = 42
auto i10 = std::stoi("101010", nullptr, 2); // i10 = 42
auto i11 = std::stoi("22", nullptr, 20);    // i11 = 42
auto i12 = std::stoi("-22", nullptr, 20);  // i12 = -42
auto pos = size_t{ 0 };
auto i13 = std::stoi("42", &amp;pos);      // i13 = 42,  pos = 2
auto i14 = std::stoi("-42", &amp;pos);     // i14 = -42, pos = 3
auto i15 = std::stoi("  +42dec", &amp;pos);// i15 = 42,  pos = 5
</code></pre>
<p class="normal">An important thing to note is that these conversion functions throw an exception if the conversion fails. There are two exceptions that can be thrown:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::invalid_argument</code> if the conversion cannot be performed:
        <pre class="programlisting code"><code class="hljs-code">try
{
  auto i16 = std::stoi("");
}
catch (std::exception const &amp; e)
{
  // prints "invalid stoi argument"
  std::cout &lt;&lt; e.what() &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::out_of_range</code> if the converted value is outside the range of the result type (or if the underlying function sets <code class="inlineCode">errno</code> to <code class="inlineCode">ERANGE</code>):
        <pre class="programlisting code"><code class="hljs-code">try
{
  // OK
auto i17 = std::stoll("12345678901234");
  // throws std::out_of_range
auto i18 = std::stoi("12345678901234");
}
catch (std::exception const &amp; e)
{
  // prints "stoi argument out of range"
  std::cout &lt;&lt; e.what() &lt;&lt; '\n';
}
</code></pre>
</li>
</ul>
<p class="normal">The <a id="_idIndexMarker171"/>other<a id="_idIndexMarker172"/> set of functions that convert a string to a floating-point type are very similar, except that they don’t have a parameter for the numeric base. A valid floating-point value can have different representations in the input string:</p>
<ul>
<li class="bulletList">Decimal floating-point expression (optional sign, sequence of decimal digits with optional point, optional <code class="inlineCode">e</code> or <code class="inlineCode">E</code>, followed by exponent with optional sign)</li>
<li class="bulletList">Binary floating-point expression (optional sign, <code class="inlineCode">0x</code> or <code class="inlineCode">0X</code> prefix, sequence of hexadecimal digits with optional point, optional <code class="inlineCode">p</code> or <code class="inlineCode">P</code>, followed by exponent with optional sign)</li>
<li class="bulletList">Infinity expression (optional sign followed by case-insensitive <code class="inlineCode">INF</code> or <code class="inlineCode">INFINITY</code>)</li>
<li class="bulletList">A non-number expression (optional sign followed by case-insensitive <code class="inlineCode">NAN</code> and possibly other alphanumeric characters)</li>
</ul>
<p class="normal">Apart from these formats, additional ones supported by the currently installed C locale may also be supported.</p>
<p class="normal">The following are various examples of converting strings to doubles:</p>
<pre class="programlisting code"><code class="hljs-code">auto d1 = std::stod("123.45");         // d1 =  123.45000000000000
auto d2 = std::stod("+123.45");        // d2 =  123.45000000000000
auto d3 = std::stod("-123.45");        // d3 = -123.45000000000000
auto d4 = std::stod("  123.45");       // d4 =  123.45000000000000
auto d5 = std::stod("  -123.45abc");   // d5 = -123.45000000000000
auto d6 = std::stod("1.2345e+2");      // d6 =  123.45000000000000
auto d7 = std::stod("0xF.6E6666p3");   // d7 =  123.44999980926514
auto d8 = std::stod("INF");            // d8 = inf
auto d9 = std::stod("-infinity");      // d9 = -inf
auto d10 = std::stod("NAN");           // d10 = nan
auto d11 = std::stod("-nanabc");       // d11 = -nan
</code></pre>
<p class="normal">The <a id="_idIndexMarker173"/>floating-point base 2 scientific notation, seen <a id="_idIndexMarker174"/>earlier in the form <code class="inlineCode">0xF.6E6666p3</code>, is not the topic of this recipe. However, for a clear understanding, a short description is provided, but it is recommended that you look at additional references for details (such as <a href="https://en.cppreference.com/w/cpp/language/floating_literal">https://en.cppreference.com/w/cpp/language/floating_literal</a>). A floating-point constant in the base 2 scientific notation is composed of several parts:</p>
<ul>
<li class="bulletList">The hexadecimal prefix <code class="inlineCode">0x</code>.</li>
<li class="bulletList">An integer part; in this example, it was <code class="inlineCode">F</code>, which in decimal is 15.</li>
<li class="bulletList">A fractional part, which, in this example, was <code class="inlineCode">6E6666</code>, or <code class="inlineCode">011011100110011001100110</code> in binary. To convert that into decimal, we need to add inverse powers of two: <code class="inlineCode">1/4 + 1/8 + 1/32 + 1/64 + 1/128 + ...</code>.</li>
<li class="bulletList">A suffix, representing a power of 2; in this example, <code class="inlineCode">p3</code> means 2 at the power of 3.</li>
</ul>
<p class="normal">The value of the decimal equivalent is determined by multiplying the significant (composed of the integer and fractional parts) and the base at the power of the exponent.</p>
<p class="normal">For the given hexadecimal base 2 floating-point literal, the significant is <code class="inlineCode">15.4312499...</code> (please note that digits after the seventh one are not shown), the base is 2, and the exponent is 3. Therefore, the result is <code class="inlineCode">15.4212499... * 8</code>, which is <code class="inlineCode">123.44999980926514</code>.</p>
<h2 class="heading-2" id="_idParaDest-101">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Limits and other properties of numeric types</em>, to learn about the minimum and maximum values, as well as the other properties of numerical types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-102">Understanding the various character and string types</h1>
<p class="normal">In the previous recipe, we looked at the variety of integral and floating-point types. Another category of types, character types, is often a source of misunderstanding and confusion. As of C++20, there are five character data types in the C++ language: <code class="inlineCode">char</code>, <code class="inlineCode">wchar_t</code>, <code class="inlineCode">char8_t</code>, <code class="inlineCode">char16_t</code>, and <code class="inlineCode">char32_t</code>. In this recipe, we will look at how these types differ and how they are meant to be used. </p>
<h2 class="heading-2" id="_idParaDest-103">How to do it…</h2>
<p class="normal">Use the available <a id="_idIndexMarker175"/>character types as follows:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">char</code> type to <a id="_idIndexMarker176"/>store ASCII characters, Latin character sets (defined in the ISO-8859 standard), or even individual bytes of UTF-8 encoded characters:
        <pre class="programlisting code"><code class="hljs-code">char c = 'C';
const char* s = "C++";
std::cout &lt;&lt; c &lt;&lt;  s &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">wchar_t</code> type with <a id="_idIndexMarker177"/>the Windows API to store and manipulate UTF-16LE encoded characters:
        <pre class="programlisting code"><code class="hljs-code">wchar_t c = L'Ʃ';
const wchar_t* s = L"δῆμος";
std::wcout &lt;&lt; c &lt;&lt; s &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">char8_t</code> type to store <a id="_idIndexMarker178"/>individual bytes of UTF-8 encoded code points:
        <pre class="programlisting code"><code class="hljs-code">char8_t c = u8'A';
const char8_t* s = u8"Æthelflæd";
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">char16_t</code> type <a id="_idIndexMarker179"/>to store UTF-16 encoded characters:
        <pre class="programlisting code"><code class="hljs-code">char16_t c = u'Æ';
const char16_t* s = u"Æthelflæd";
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">char32_t</code> type to <a id="_idIndexMarker180"/>store UTF-32 encoded characters:
        <pre class="programlisting code"><code class="hljs-code">char32_t c = U'<img alt="" src="img/4th_GLYPS.png"/>';
const char32_t* s = U"<img alt="" src="img/3rd_GLYPS.png"/>";
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-104">How it works…</h2>
<p class="normal">The built-in data type for storing characters from the early days of the C++ language was the <code class="inlineCode">char</code> type. This is an 8-bit data type that is different from both <code class="inlineCode">signed char</code> and <code class="inlineCode">unsigned char</code>. It is not a <code class="inlineCode">typedef</code> of any of these two data types. You can test that using the <code class="inlineCode">std::is_same</code> type trait:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::is_same_v&lt;char, signed char&gt; &lt;&lt; '\n';   // prints 0
std::cout &lt;&lt; std::is_same_v&lt;char, unsigned char&gt; &lt;&lt; '\n'; // prints 0
</code></pre>
<p class="normal">Both of these lines will print 0. This means you can have function overloads for all these three data types, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">void f(char) {}
void f(signed char) {}
void f(unsigned char) {}
</code></pre>
<p class="normal">The standard does<a id="_idIndexMarker181"/> not specify whether <code class="inlineCode">char</code> is a <code class="inlineCode">signed</code> or <code class="inlineCode">unsigned</code> type. Therefore, its signedness depends on the compiler or target platform. The type <code class="inlineCode">char</code> is a <code class="inlineCode">signed</code> type on x86 and x64 systems and <code class="inlineCode">unsigned</code> on ARM.</p>
<p class="normal">The <code class="inlineCode">char</code> data type can be used to store the characters from the ASCII character set and other 8-bit Latin character sets such as Latin-1, Latin-2, Latin/Cyrillic, Latin Nordic, and so on. It can also be used to store individual bytes of multi-byte character sets, the most widely used being the UTF-8 encoding of the Unicode set.</p>
<p class="normal">For dealing with fixed-width multi-byte character sets, the <code class="inlineCode">wchar_t</code> type was introduced in C++98. This is also a unique data type (not a <code class="inlineCode">typedef</code> of some integral type). Its size is not specified and, therefore, also varies: it is 2 bytes on Windows and typically 4 bytes on Unix systems. </p>
<p class="normal">This means that <code class="inlineCode">wchar_t</code> should not be used when writing portable code. The <code class="inlineCode">wchar_t</code> type is mostly used on Windows where it was adopted for storing 16-bit characters of the UTF-16LE encoding of the Unicode character set. This is the native character set of the Windows operating system. </p>
<p class="normal">In newer versions of the standard, three new character data types have been introduced. In C++11, <code class="inlineCode">char32_t</code> and <code class="inlineCode">char16_t</code> were added to represent 32-bit and 16-bit wide characters. They are intended to represent UTF-32 and UTF-16 encoded Unicode characters. Although they are each distinctive types, they are equal in size, signedness, and alignment with <code class="inlineCode">uint_least32_t</code> and <code class="inlineCode">uint_least16_t</code>, respectively. In C++20, the <code class="inlineCode">char8_t</code> data type was added. This is intended to store UTF-8 code units (which are 8-bit). The <code class="inlineCode">char8_t</code> type is a distinctive 8-bit type and has the same size, signedness, and alignment as <code class="inlineCode">unsigned char</code>.</p>
<p class="normal">We can summarize all this information in the following table:</p>
<table class="table-container" id="table006">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">C++ Standard</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Size (bytes)</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Sign</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char</code></p>
</td>
<td class="table-cell">
<p class="normal">All versions</p>
</td>
<td class="table-cell">
<p class="normal">1</p>
</td>
<td class="table-cell">
<p class="normal">unspecified</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">wchar_t</code></p>
</td>
<td class="table-cell">
<p class="normal">C++98</p>
</td>
<td class="table-cell">
<p class="normal">Unspecified</p>
<p class="normal">(typically, 2 or 4)</p>
</td>
<td class="table-cell">
<p class="normal">unspecified</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char8_t</code></p>
</td>
<td class="table-cell">
<p class="normal">C++20</p>
</td>
<td class="table-cell">
<p class="normal">1</p>
</td>
<td class="table-cell">
<p class="normal">unsigned</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char16_t</code></p>
</td>
<td class="table-cell">
<p class="normal">C++11</p>
</td>
<td class="table-cell">
<p class="normal">2</p>
</td>
<td class="table-cell">
<p class="normal">unsigned</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char32_t</code></p>
</td>
<td class="table-cell">
<p class="normal">C++11</p>
</td>
<td class="table-cell">
<p class="normal">4</p>
</td>
<td class="table-cell">
<p class="normal">unsigned</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.6: Summary of size and signedness of the C++ character types</p>
<p class="normal">Strings of <a id="_idIndexMarker182"/>the <code class="inlineCode">char</code> and <code class="inlineCode">char8_t</code> types are called <em class="italic">narrow strings</em>, and strings of the <code class="inlineCode">wchar_t</code>, <code class="inlineCode">char16_t</code>, and <code class="inlineCode">char32_t</code> types are called <em class="italic">wide strings</em>. The C++ standard provides a container for storing and manipulating sequences of characters. This is a class template that has several type aliases defined to simplify usage, as shown in the following table:</p>
<table class="table-container" id="table007">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Definition</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">C++ Standard</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::string</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::basic_string&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal">C++98</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::wstring</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::basic_string&lt;wchar_t&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal">C++98</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::u8string</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::basic_string&lt;char8_t&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal">C++20</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::u16string</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::basic_string&lt;char16_t&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal">C++11</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::u32string</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::basic_string&lt;char32_t&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal">C++11</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.7: The various type aliases for std::basic_string</p>
<p class="normal">Like the other standard containers, <code class="inlineCode">std::basic_string</code> provides a multitude of member functions to construct, access elements, iterate, search, or perform various operations with the contained sequence of characters. A particular mention needs to be made about how data is stored in a <code class="inlineCode">basic_string</code>. In C++11, it is guaranteed to be contiguous, like in an array. </p>
<p class="normal">On the other hand, it may be a bit confusing how it handles string termination. Let’s take an example to explain it:</p>
<pre class="programlisting code"><code class="hljs-code">std::string s = "demo";
</code></pre>
<p class="normal">The elements<a id="_idIndexMarker183"/> stored in the <code class="inlineCode">basic_string</code> object are the characters <code class="inlineCode">'d</code> <code class="inlineCode">'</code>, <code class="inlineCode">'e</code> <code class="inlineCode">'</code>, <code class="inlineCode">'m</code> <code class="inlineCode">'</code>, and <code class="inlineCode">'o</code> <code class="inlineCode">'</code>. This is what you get if you iterate over the object (e.g., <code class="inlineCode">for (auto c : s)</code>). The <code class="inlineCode">size()</code> member will return 4. However, both the <code class="inlineCode">c_str()</code> and <code class="inlineCode">data()</code> member functions will return a null terminator. That means that it’s guaranteed that <code class="inlineCode">s[s.size()]</code> is 0.</p>
<p class="normal">Characters and strings are often provided as literals in source code. There are different prefixes for the different character types, as listed in the following table:</p>
<table class="table-container" id="table008">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Literal</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">C++ Standard</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Character type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">String type</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">none</p>
</td>
<td class="table-cell">
<p class="normal">All versions</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const char*</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">L</code></p>
</td>
<td class="table-cell">
<p class="normal">C++98</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">wchar_t</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const wchar_t*</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">u8</code></p>
</td>
<td class="table-cell">
<p class="normal">C++11</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char</code> (until C++20)</p>
<p class="normal"><code class="inlineCode">char8_t</code> (since C++20)</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const char*</code> (until C++20)</p>
<p class="normal"><code class="inlineCode">const char8_t*</code> (since C++20)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">u</code></p>
</td>
<td class="table-cell">
<p class="normal">C++11</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char16_t</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const char16_t*</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">U</code></p>
</td>
<td class="table-cell">
<p class="normal">C++11</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char32_t</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const char32_t*</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.8: Prefixes for the different character and string types</p>
<pre>auto</code> is used didactically to explain the deduction rules):</pre>
<pre class="programlisting code"><code class="hljs-code">auto c1 = 'a';     // char
auto c2 = L'b';    // wchar_t
auto c3 = u8'c';   // char until C++20, char8_t in C++20
auto c4 = u'd';    // char16_t
auto c5 = U'e';    // char32_t
auto sa1 = "a";    // const char*
auto sa2 = L"a";   // const wchar_t*
auto sa3 = u8"a";  // const char* until C++20
// const char8_t* in C++20
auto sa4 = u"a";   // const char16_t*
auto sa5 = U"a";   // const char32_t*
</code></pre>
<p class="normal">In the first part, because <a id="_idIndexMarker184"/>single quotes are used, character types are deduced for variables <code class="inlineCode">c1</code> to <code class="inlineCode">c5</code>, depending on the literal prefix (the deduced type is mentioned on the right side in the comments). In the second part, because double quotes are used, string types are deduced for variables <code class="inlineCode">sa1</code> to <code class="inlineCode">sa5</code>, again, depending on the literal prefix. </p>
<p class="normal">The deduced type for <code class="inlineCode">"a"</code> is not <code class="inlineCode">std::string</code> but <code class="inlineCode">const char*</code>. If you want to use any of the <code class="inlineCode">basic_string</code> typedefs, such as <code class="inlineCode">std::string</code>, you must either define the type explicitly (and not use <code class="inlineCode">auto</code>) or use a standard user-defined literal suffix, available in the <code class="inlineCode">std::string_literals</code> namespace. This is shown in the next snippet:</p>
<pre class="programlisting code"><code class="hljs-code">using namespace std::string_literals;
auto s1 = "a"s;    // std::string
auto s2 = L"a"s;   // std::wstring
auto s3 = u8"a"s;  // std::u8string
auto s4 = u"a"s;   // std::u16string
auto s5 = U"a"s;   // std::u32string
</code></pre>
<p class="normal">To avoid confusion, the following table explains the meaning of various pointer types:</p>
<table class="table-container" id="table009">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Meaning</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char*</code></p>
</td>
<td class="table-cell">
<p class="normal">A mutable pointer to a mutable character. Both the pointer and the pointed character can be modified. </p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const char*</code></p>
</td>
<td class="table-cell">
<p class="normal">A mutable pointer to a constant character. The pointer can be modified, but not the content of the location it points to.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char * const</code></p>
</td>
<td class="table-cell">
<p class="normal">A constant pointer to a mutable character. The pointer cannot be modified, but the content of the location it points to can be.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const char * const</code></p>
</td>
<td class="table-cell">
<p class="normal">A constant pointer to a constant character. Neither the pointer nor the content of the location it points to can be modified.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">char[]</code></p>
</td>
<td class="table-cell">
<p class="normal">An array of characters.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.9: The meaning of various pointer types</p>
<p class="normal">You must have noticed that, in the previous table, the prefix <code class="inlineCode">u8</code> had different behavior with different standards:</p>
<ul>
<li class="bulletList">Since C++11, when it was introduced, until C++20, it defined a <code class="inlineCode">char</code> literal.</li>
<li class="bulletList">Since C++20, when it was repurposed with the introduction of <code class="inlineCode">char8_t</code>, it defines a <code class="inlineCode">char8_t</code> literal.</li>
</ul>
<p class="normal">This C++20 change<a id="_idIndexMarker185"/> is a breaking change. It was preferred over the introduction of yet another literal prefix that could have the potential of complicating things even further.</p>
<p class="normal">A character or string literal may contain code point values instead of actual characters. These must be escaped with either <code class="inlineCode">\u</code> (for 4 hexadecimal digit code points) or <code class="inlineCode">\U</code> (for 8 hexadecimal digit code points). Here is an example:</p>
<pre class="programlisting code"><code class="hljs-code">std::u16string hb = u"Harald Bluetooth \u16BC\u16d2"; // <img alt="" src="img/1ST_GLYPS.png"/>
std::u32string eh = U"Egyptian hieroglyphs \U00013000 \U000131B2"; // <img alt="" src="img/2nd_GLYPS.png"/>
</code></pre>
<p class="normal">In C++23, it is possible to use Unicode instead of code point values. That is done using the <code class="inlineCode">\N{xxx}</code> escape sequence, where <code class="inlineCode">xxx</code> is the Unicode assigned name. Therefore, the snippet above can also be written as follows in C++23:</p>
<pre class="programlisting code"><code class="hljs-code">std::u16string hb = u"Harald Bluetooth \N{Runic Letter Long-Branch-Hagall H}\N{Runic Letter Berkanan Beorc Bjarkan B}";
std::u32string eh = U"Egyptian hieroglyphs \N{EGYPTIAN HIEROGLYPH A001} \N{EGYPTIAN HIEROGLYPH M003A}";
</code></pre>
<p class="normal">Also, in C++23, it is possible to use code point values with an arbitrary number of hexadecimal digits. In the previous example, the string containing Egyptian hieroglyphs contained the codepoint 13000, which has 5 hexadecimal digits. However, since the <code class="inlineCode">\U</code> escape sequence requires 8 hexadecimal digits, we had to include three leading zeros <code class="inlineCode">(\U00013000</code>). This is no longer necessary in C++23, but it requires the syntax <code class="inlineCode">\u{n…}</code> (with lowercase <code class="inlineCode">u</code>), where <code class="inlineCode">n…</code> is an arbitrary number of hexadecimal digits. Therefore, this string can also be written as follows in C++23:</p>
<pre class="programlisting code"><code class="hljs-code">std::u32string eh = U"Egyptian hieroglyphs \u{13000} \u{131B2}"; // <img alt="" src="img/2nd_GLYPS.png"/>
</code></pre>
<p class="normal">Printing characters and strings to the console can be done in multiple ways:</p>
<ul>
<li class="bulletList">Using the <code class="inlineCode">std::cout</code> and <code class="inlineCode">std::wcout</code> global objects</li>
<li class="bulletList">Using the <code class="inlineCode">printf</code> family of functions</li>
<li class="bulletList">Using the <code class="inlineCode">std::print</code> family of functions in C++23</li>
<li class="bulletList">Using a third-party text processing library, such as the widely-used <strong class="keyWord">fmt</strong> library (which was the source for the <code class="inlineCode">std::format</code> and <code class="inlineCode">std::print</code> standard utilities included in C++20 and C++23)</li>
</ul>
<p class="normal">The <code class="inlineCode">std::cout</code> and <code class="inlineCode">std::wcout</code> global objects can be used to print <code class="inlineCode">char</code>/<code class="inlineCode">const char*</code>/<code class="inlineCode">std::string</code> values and, respectively, <code class="inlineCode">wchar_t</code>/<code class="inlineCode">const wchar_t*</code>/<code class="inlineCode">std::wstring</code> values to the standard <a id="_idIndexMarker186"/>output console. Printing ASCII characters does not pose problems but the handling of other character sets and encodings, such as UTF-8, is more problematic, as there is no standard support and different platforms require different solutions. You can learn more about this topic in the next recipe, <em class="italic">Printing Unicode characters to the output console</em>.</p>
<h2 class="heading-2" id="_idParaDest-105">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Understanding the various numeric types</em>, to learn about the available integral and floating-point types</li>
<li class="bulletList"><em class="italic">Formatting and printing text with std::format and std::print</em>, to learn about how to format and print text using modern utilities</li>
</ul>
<h1 class="heading-1" id="_idParaDest-106">Printing Unicode characters to the output console</h1>
<p class="normal">In the previous recipe, <em class="italic">Understanding the various character and string types</em>, we looked at the various <a id="_idIndexMarker187"/>data types for storing characters and strings of characters. This multitude of types was necessary because there are a multitude of character sets that have been developed over time. </p>
<p class="normal">The most widely <a id="_idIndexMarker188"/>used character sets are ASCII and Unicode. Although support for the former has been available on all compilers and target platforms since the creation of the language, the support for the latter has evolved at a different pace and in different forms for Windows and Unix/Linux systems. In this recipe, we will look at how to print texts in different encodings to the standard output console.</p>
<h2 class="heading-2" id="_idParaDest-107">How to do it…</h2>
<p class="normal">To write text to the standard output console, you can use the following:</p>
<ul>
<li class="bulletList">For writing ASCII characters, use <code class="inlineCode">std::cout</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; "C++\n";
</code></pre>
</li>
<li class="bulletList">For writing UTF-8 encoded Unicode characters on Linux, also use <code class="inlineCode">std::cout</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; "Erling Håland\n";
std::cout &lt;&lt; "Thomas Müller\n";
std::cout &lt;&lt; "Στέφανος Τσιτσιπάς\n";
std::string monkeys = "<img alt="" src="img/3rd_GLYPS.png"/>";
std::cout &lt;&lt; monkeys &lt;&lt; '\n';
</code></pre>
<p class="normal">For UTF-8 strings stored using the <code class="inlineCode">char8_t</code> data type, you can still use <code class="inlineCode">std::cout</code> but must reinterpret the underlying type as an array of chars:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Στέφανος Τσιτσιπάς\n");
</code></pre></li>
</ul>
<ul>
<li class="bulletList">For writing UTF-8 encoded Unicode characters on a Windows system, use <code class="inlineCode">char8_t</code> characters, and respectively, <code class="inlineCode">std::u8string</code> strings in C++20. In prior versions, you can use <code class="inlineCode">char</code> and <code class="inlineCode">std::string</code>. Make sure to call the Windows API <code class="inlineCode">SetConsoleOutputCP(CP_UTF8)</code> before writing to the standard output:
        <pre class="programlisting code"><code class="hljs-code">SetConsoleOutputCP(CP_UTF8);
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Erling Håland\n");
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Thomas Müller\n");
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Στέφανος Τσιτσιπάς\n");
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"<img alt="" src="img/3rd_GLYPS.png"/>\n");
</code></pre>
</li>
</ul>
<figure class="mediaobject"><img alt="" src="img/B21549_02_03.png"/></figure>
<p class="packt_figref">Figure 2.3: Output of the previous snippet</p>
<ul>
<li class="bulletList">For <a id="_idIndexMarker189"/>writing UTF-16 encoded Unicode <a id="_idIndexMarker190"/>characters on a Windows system, use <code class="inlineCode">wchar_t</code> characters and <code class="inlineCode">std::wstring</code> strings. Make sure to call <code class="inlineCode">_setmode(_fileno(stdout), _O_U16TEXT)</code> before writing to the standard output:
        <pre class="programlisting code"><code class="hljs-code">auto mode = _setmode(_fileno(stdout), _O_U16TEXT);
std::wcout &lt;&lt; L"Erling Håland\n";
std::wcout &lt;&lt; L"Thomas Müller\n";
std::wcout &lt;&lt; L"Στέφανος Τσιτσιπάς\n";
_setmode(_fileno(stdout), mode);
</code></pre>
</li>
</ul>
<figure class="mediaobject"><img alt="" src="img/B21549_02_04.png"/></figure>
<p class="packt_figref">Figure 2.4: Output of the previous snippet</p>
<h2 class="heading-2" id="_idParaDest-108">How it works…</h2>
<p class="normal">The<a id="_idIndexMarker191"/> ASCII encoding has been the most common character encoding format for half a century. It contains 128 characters including the lower<a id="_idIndexMarker192"/> and uppercase letters of the English language, the 10 decimal digits, and symbols. The first 32 characters of the set are non-printable and<a id="_idIndexMarker193"/> are called <em class="italic">control characters</em>. The C++ language has full support for the ASCII character set. You can use <code class="inlineCode">std::cout</code> to print ASCII characters to the standard output.</p>
<p class="normal">Since the <a id="_idIndexMarker194"/>ASCII encoding only includes the letters of the English alphabet, various attempts have been made to support other languages and alphabets. One approach is the <a id="_idIndexMarker195"/>concept of <em class="italic">code pages</em>. The ASCII encoding requires only 7 bits for encoding the 128 characters. Therefore, an additional 128 characters are available to encode using an 8-bit data type. That means that the characters in the index 128–255 can be mapped to other languages or alphabets. Such a mapping is called a code page. There are a variety of code pages, such as IBM code pages, DOS code pages, Windows code pages, and others. You can read more about this at <a href="https://en.wikipedia.org/wiki/Code_page">https://en.wikipedia.org/wiki/Code_page</a>. The following table lists several Windows code pages:</p>
<table class="table-container" id="table010">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Code page</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Name</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Languages supported</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1250</p>
</td>
<td class="table-cell">
<p class="normal">Windows Central Europe</p>
</td>
<td class="table-cell">
<p class="normal">Czech, Polish, Slovak, Hungarian, Slovene, Serbo-Croatian, Romanian, Albanian</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1251</p>
</td>
<td class="table-cell">
<p class="normal">Windows Cyrillic</p>
</td>
<td class="table-cell">
<p class="normal">Russian, Belarusian, Ukrainian, Bulgarian, Macedonian, Serbian</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1252</p>
</td>
<td class="table-cell">
<p class="normal">Windows Western</p>
</td>
<td class="table-cell">
<p class="normal">Spanish, Portuguese, French, German, Danish, Norwegian, Swedish, Finnish, Icelandic, Faroese, etc.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1253</p>
</td>
<td class="table-cell">
<p class="normal">Windows Greek</p>
</td>
<td class="table-cell">
<p class="normal">Greek</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1254</p>
</td>
<td class="table-cell">
<p class="normal">Windows Turkish</p>
</td>
<td class="table-cell">
<p class="normal">Turkish</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1255</p>
</td>
<td class="table-cell">
<p class="normal">Windows Hebrew</p>
</td>
<td class="table-cell">
<p class="normal">Hebrew</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1256</p>
</td>
<td class="table-cell">
<p class="normal">Windows Arabic</p>
</td>
<td class="table-cell">
<p class="normal">Arabic, Persian, Urdu, English, French</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1257</p>
</td>
<td class="table-cell">
<p class="normal">Windows Baltic</p>
</td>
<td class="table-cell">
<p class="normal">Estonian, Latvian, Lithuanian</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">1258</p>
</td>
<td class="table-cell">
<p class="normal">Windows Vietnamese</p>
</td>
<td class="table-cell">
<p class="normal">Vietnamese</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.10: A listing of a subset of Windows code pages</p>
<p class="normal">To understand how this <a id="_idIndexMarker196"/>works, let’s exemplify with a code snippet. The index 224 or 0xE0 (in hexadecimal) is mapped to different characters in different code pages, as shown in the following table:</p>
<table class="table-container" id="table011">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1250</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1251</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1252</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1253</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1254</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1255</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1256</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1257</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">1258</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">ŕ</p>
</td>
<td class="table-cell">
<p class="normal">а</p>
</td>
<td class="table-cell">
<p class="normal">à</p>
</td>
<td class="table-cell">
<p class="normal">ΰ</p>
</td>
<td class="table-cell">
<p class="normal">à</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="" src="img/1.png"/></p>
</td>
<td class="table-cell">
<p class="normal">à</p>
</td>
<td class="table-cell">
<p class="normal">ą</p>
</td>
<td class="table-cell">
<p class="normal">à</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.11: The character corresponding to index 224 in the several Windows code pages</p>
<div><p class="normal">In encoding terminology, the numerical value to which a character is mapped is called a <em class="italic">code point</em> (or <em class="italic">codepoint</em>). In our example, 224 is a code point, and <em class="italic">a</em>, <em class="italic">à</em>, or <em class="italic">ą</em> are specific characters mapped to this code point in different code pages.</p>
</div>
<p class="normal">In Windows, you<a id="_idIndexMarker197"/> can activate one code page for <a id="_idIndexMarker198"/>the console associated with the running process by calling the <code class="inlineCode">SetConsoleOutputCP()</code> API. An example is shown in the following snippet, where we print the character mapped to the 224 code point for all the code pages from 1250 to 1258 (the ones listed earlier):</p>
<pre class="programlisting code"><code class="hljs-code">char c = 224;
for (int codepage = 1250; codepage &lt;= 1258; codepage++)
{
   SetConsoleOutputCP(codepage);
   std::cout &lt;&lt; c &lt;&lt; ' ';
}
</code></pre>
<p class="normal">The output from running this program is shown in the next image. You can see here that the printed characters are the ones expected according to <em class="italic">Table 2.9</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_05.png"/></figure>
<p class="packt_figref">Figure 2.5: Printing of code point 224 with different code pages</p>
<p class="normal">Although <a id="_idIndexMarker199"/>code pages provide a simple approach to switching between different scripts, it is not a solution that can support languages or writing systems that include hundreds or thousands of characters or pictograms, such as Chinese or Egyptian hieroglyphs. For this purpose, another standard was developed, called <strong class="keyWord">Unicode</strong>. This encoding standard is meant to represent most of the world’s writing scripts, both present and from the past, as well as other symbols, such as emojis, which have become extremely popular for texting in recent times. Currently, the Unicode standard defines almost 150,000 characters.</p>
<p class="normal">Unicode characters <a id="_idIndexMarker200"/>can be stored in several encodings, the most popular being UTF-8 and UTF-16. There is also UTF-32 and GB18030; the latter one is not part of the Unicode specification but it’s used in China and fully implements Unicode.</p>
<p class="normal">UTF-8 is a <a id="_idIndexMarker201"/>variable-length character encoding standard, compatible with ASCII. UTF-8 uses 1, 2, 3, or 4 bytes to encode all the representable code points. The more used a code point is, the fewer bytes are used for its encoding. The 128 code points of the ASCII encoding are represented by a single byte. As a result, UTF-8 is fully “backward” compatible with ASCII. All the other Unicode code points are encoded using multiple bytes: code points in the range 128–2047 using 2 bytes, code points in the range 2048–65535 using 3 bytes, and code points in the range 65536–1114111 using 4 bytes. The first byte in the encoding is<a id="_idIndexMarker202"/> called a <em class="italic">lead byte</em> and provides information about how many bytes are used to encode the code point. Because of this, UTF-8 is a very efficient encoding system and is the preferred choice for the World Wide Web, where virtually almost all web pages use this encoding.</p>
<p class="normal">UTF-16 is also<a id="_idIndexMarker203"/> a variable-length character encoding that can encode all the Unicode code points. For this, it uses either one or two 16-bit code units, which makes it incompatible with ASCII. UTF-16 is the encoding used by the Windows operating system, as well as by the Java and JavaScript programming languages.</p>
<p class="normal">UTF-32 is a less <a id="_idIndexMarker204"/>common<a id="_idIndexMarker205"/> encoding system. It’s a fixed-length encoding that uses 32 bits for each code point. Since all the Unicode code points require at most 21 bits, the leading 11 bits are always 0. This makes it space-inefficient, which is its main disadvantage. Its primary advantage is that it takes constant time to find the Nth code point in a sequence, as opposed to a linear time for variable-length encodings such as UTF-8 and UTF-16.</p>
<p class="normal">Compilers <a id="_idIndexMarker206"/>typically assume UTF-8 encoding for source files. This is the case for GCC, Clang, and MSVC.</p>
<p class="normal">Linux distributions have native support for UTF-8. This means that writing string literals to the output console such as <code class="inlineCode">"Στέφανος Τσιτσιπάς"</code> will produce the expected result since the terminal supports UTF-8:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; "Στέφανος Τσιτσιπάς";
</code></pre>
<p class="normal">On the other hand, writing wide strings such as <code class="inlineCode">L"Στέφανος Τσιτσιπάς"</code> does not work out of the box. To get the expected result, you need to set up a locale object. The default C locale does not know how to convert from wide characters to UTF-8. For this to happen, you need to use a locale that is able to do that. You have two options:</p>
<ul>
<li class="bulletList">Initialize a locale object to match the environment’s configuration, which should typically be a locale that supports UTF-8:
        <pre class="programlisting code"><code class="hljs-code">std::locale utf8("");
std::wcout.imbue(utf8);
std::wcout &lt;&lt; L"Στέφανος Τσιτσιπάς\n";
</code></pre>
</li>
<li class="bulletList">Initialize a locale object with a specific locale, such as English (United States):
        <pre class="programlisting code"><code class="hljs-code">std::locale utf8("en_US.UTF-8");
std::wcout.imbue(utf8);
std::wcout &lt;&lt; L"Στέφανος Τσιτσιπάς\n";
</code></pre>
</li>
</ul>
<div><p class="normal">Locales are discussed in detail in <em class="chapterRef">Chapter 7</em>, <em class="italic">Using localized settings for streams</em>.</p>
</div>
<p class="normal">On a Windows system, things are different. The Windows Command Prompt (<code class="inlineCode">cmd.exe</code>) does not have support for UTF-8. Although Windows 10 added support for a beta feature called “<em class="italic">Use Unicode UTF-8 for worldwide language support</em>,” this is deeply hidden in the <em class="italic">Regional Settings</em> and is currently reported to prevent some applications from working correctly. To write UTF-8 content to the Command Prompt, you must first set the correct code page by calling <code class="inlineCode">SetConsoleOutputCP()</code> and passing <code class="inlineCode">CP_UTF8</code> as an argument (or 65001, its numerical value):</p>
<pre class="programlisting code"><code class="hljs-code">SetConsoleOutputCP(CP_UTF8);
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Erling Håland\n");
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Thomas Müller\n");
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Στέφανος Τσιτσιπάς\n");
std::u8string monkeys = u8"<img alt="" src="img/3rd_GLYPS.png"/>\n";
std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(monkeys.c_str());
</code></pre>
<p class="normal">To <a id="_idIndexMarker207"/>write UTF-16, you need to call <code class="inlineCode">_setmode()</code> (from <code class="inlineCode">&lt;io.h&gt;</code>) to set the translation mode for a file (in this case, the standard output console) to UTF-16. For this, you have to pass the <code class="inlineCode">_O_U16TEXT</code> argument. The<a id="_idIndexMarker208"/> function returns the previous translation mode that you can use to restore the translation mode after writing the desired content. </p>
<p class="normal">Passing <code class="inlineCode">_O_TEXT</code> sets the text mode (in which CR-LF combinations are translated into a single LF on input, and LF characters are translated into CR-LF on output):</p>
<pre class="programlisting code"><code class="hljs-code">auto mode = _setmode(_fileno(stdout), _O_U16TEXT);
std::wcout &lt;&lt; L"Erling Håland\n";
std::wcout &lt;&lt; L"Thomas Müller\n";
std::wcout &lt;&lt; L"Στέφανος Τσιτσιπάς\n";
_setmode(_fileno(stdout), mode);
</code></pre>
<div><p class="normal">For this to work, however, it is also important that the Command Prompt application uses a True Type font, such as Lucinda Console or Consolas, and not a Raster font that only supports ASCII.</p>
</div>
<p class="normal">Starting with Windows 10, a new terminal application is available for Windows. This is called <strong class="keyWord">Windows Terminal,</strong> and<a id="_idIndexMarker209"/> it has built-in support for UTF-8. This means that the following code prints the expected result without having to call <code class="inlineCode">SetConsoleOutputCP()</code> first:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; reinterpret_cast&lt;const char*&gt;(u8"Erling Håland\n");
</code></pre>
<p class="normal">Unlike other <a id="_idIndexMarker210"/>programming languages, support for Unicode has not been a strong point of C++. This recipe provides the basics for working with Unicode in console applications. However, in practice, matters can get more complex and require additional support. To further your<a id="_idIndexMarker211"/> understanding of this topic, it is recommended that you consult additional sources, with many being available online.</p>
<h2 class="heading-2" id="_idParaDest-109">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Understanding the various character and string types</em> to learn about the available character and string types in C++</li>
<li class="bulletList"><em class="italic">Formatting and printing text with std::format and std::print</em> to learn about how to format and print text using modern utilities</li>
<li class="bulletList"><em class="chapterRef">Chapter 7</em>, <em class="italic">Using localized settings for streams</em>, to learn about locales and how to control the behavior of input/output streams</li>
</ul>
<h1 class="heading-1" id="_idParaDest-110">Generating pseudo-random numbers</h1>
<p class="normal">Generating random numbers <a id="_idIndexMarker212"/>is necessary for a large variety of applications, from games to cryptography, from sampling to forecasting. However, the<a id="_idIndexMarker213"/> term <em class="italic">random numbers</em> is not actually correct, as the generation of numbers through mathematical formulas is deterministic and does not produce true random numbers, but rather, numbers that look random and are called <em class="italic">pseudo-random</em>. True<a id="_idIndexMarker214"/> randomness can only be achieved through hardware <a id="_idIndexMarker215"/>devices, based on physical processes, and even that can be challenged as we may consider even the universe to be actually deterministic. </p>
<p class="normal">Modern C++ provides support for generating pseudo-random numbers through a pseudo-random number library containing number generators and distributions. Theoretically, it can also produce true random numbers but, in practice, those could actually be only pseudo-random.</p>
<h2 class="heading-2" id="_idParaDest-111">Getting ready</h2>
<p class="normal">In this recipe, we’ll discuss the standard support for generating pseudo-random numbers. Understanding the difference between random and pseudo-random numbers is key. True random numbers are numbers that cannot be predicted better than by random chance and are produced with the help of hardware-based random number generators. Pseudo-random numbers are numbers produced with the help of algorithms that generate sequences with properties that approximate the ones of true random numbers.</p>
<p class="normal">Furthermore, being familiar with various statistical distributions is a plus. It is mandatory, though, that you know what a uniform distribution is because all engines in the library produce numbers that are uniformly distributed. Without going into any details, we will just mention that uniform distribution is a probability distribution that is concerned with events that are equally likely to occur (within certain bounds).</p>
<h2 class="heading-2" id="_idParaDest-112">How to do it...</h2>
<p class="normal">To generate <a id="_idIndexMarker216"/>pseudo-random numbers in your application, you should perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Include the header <code class="inlineCode">&lt;random&gt;</code>:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;random&gt;
</code></pre>
</li>
<li class="numberedList">Use an <code class="inlineCode">std::random_device</code> generator to seed a pseudo-random engine:
        <pre class="programlisting code"><code class="hljs-code">std::random_device rd{};
</code></pre>
</li>
<li class="numberedList">Use one of the available engines to generate numbers and initialize it with a random seed:
        <pre class="programlisting code"><code class="hljs-code">auto mtgen = std::mt19937{ rd() };
</code></pre>
</li>
<li class="numberedList">Use one of the available distributions to convert the output of the engine to one of the desired statistical distributions:
        <pre class="programlisting code"><code class="hljs-code">auto ud = std::uniform_int_distribution&lt;&gt;{ 1, 6 };
</code></pre>
</li>
<li class="numberedList">Generate the pseudo-random numbers:
        <pre class="programlisting code"><code class="hljs-code">for(auto i = 0; i &lt; 20; ++i)
  auto number = ud(mtgen);
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-113">How it works...</h2>
<p class="normal">The pseudo-random number<a id="_idIndexMarker217"/> library contains two types of components:</p>
<ul>
<li class="bulletList"><em class="italic">Engines</em>, which are generators of random numbers; these can produce either pseudo-random numbers with a uniform distribution or, if available, actual random numbers.</li>
<li class="bulletList"><em class="italic">Distributions</em> that convert the output of an engine to a statistical distribution.</li>
</ul>
<p class="normal">All engines (except for <code class="inlineCode">random_device</code>) produce integer numbers in a uniform distribution, and all engines implement the following methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">min()</code>: This is a static method that returns the minimum value that can be produced by the generator.</li>
<li class="bulletList"><code class="inlineCode">max()</code>: This is a static method that returns the maximum value that can be produced by the generator.</li>
<li class="bulletList"><code class="inlineCode">seed()</code>: This initializes the algorithm with a start value (except for <code class="inlineCode">random_device</code>, which cannot be seeded).</li>
<li class="bulletList"><code class="inlineCode">operator()</code>: This generates a new number uniformly distributed between <code class="inlineCode">min()</code> and <code class="inlineCode">max()</code>.</li>
<li class="bulletList"><code class="inlineCode">discard()</code>: This generates and discards a given number of pseudo-random numbers.</li>
</ul>
<p class="normal">The following engines are available:</p>
<ul>
<li class="bulletList"><code class="inlineCode">linear_congruential_engine</code>: This is a linear congruential generator that produces numbers using the following formula:
    <p class="normal"><em class="italic">x</em>(<em class="italic">i</em>) = (<em class="italic">A</em> * <em class="italic">x</em>(i – <em class="italic">1</em>) + <em class="italic">C</em>) mod <em class="italic">M</em></p></li>
</ul>
<ul>
<li class="bulletList"><code class="inlineCode">mersenne_twister_engine</code>: This is a Mersenne Twister generator that keeps a value on <em class="italic">W</em> * (<em class="italic">N</em> – 1) * <em class="italic">R</em> bits. Each time a number needs to be generated, it extracts <em class="italic">W</em> bits. When all the bits have been used, it twists the large value by shifting and mixing the bits so that it has a new set of bits to extract from.</li>
<li class="bulletList"><code class="inlineCode">subtract_with_carry_engine</code>: This is a generator that implements a <em class="italic">subtract with carry</em> algorithm based on the following formula:
    <p class="normal"><em class="italic">x</em>(<em class="italic">i</em>) = (<em class="italic">x</em>(<em class="italic">i</em> – <em class="italic">R</em>) – <em class="italic">x</em>(<em class="italic">i</em> – <em class="italic">S</em>) – <em class="italic">cy</em>(<em class="italic">i</em> – 1)) mod <em class="italic">M</em></p>
<p class="normal">In the preceding formula, <em class="italic">cy</em> is defined as:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_001.png"/></figure></li>
</ul>
<p class="normal">In addition, the<a id="_idIndexMarker218"/> library provides engine adapters that are also engines wrapping another engine and producing numbers based on the output of the base engine. Engine adapters implement the same methods mentioned earlier for the base engines. The following engine adapters are available:</p>
<ul>
<li class="bulletList"><code class="inlineCode">discard_block_engine</code>: A generator that, from every block of <em class="italic">P</em> numbers generated by the base engine, keeps only <em class="italic">R</em> numbers, discarding the rest.</li>
<li class="bulletList"><code class="inlineCode">independent_bits_engine</code>: A generator that produces numbers with a different number of bits than the base engine.</li>
<li class="bulletList"><code class="inlineCode">shuffle_order_engine</code>: A generator that keeps a shuffled table of <em class="italic">K</em> numbers produced by the base engine and returns numbers from this table, replacing them with numbers generated by the base engine.</li>
</ul>
<p class="normal">Choosing a pseudo-random number generator should be done based on the specific requirements of your application. The linear congruential engine is medium-fast but has very small storage requirements for its internal state. The subtract with carry engine is very fast, including on machines that don’t have a processor with advanced arithmetic instruction sets. However, it requires larger storage for its internal state and the sequence of generated numbers has fewer desirable characteristics. The Mersenne Twister is the slowest of these engines and has the greatest storage durations but produces the longest non-repeating sequences of pseudo-numbers.</p>
<p class="normal">All these engines and engine adaptors produce pseudo-random numbers. The library, however, provides another engine called <code class="inlineCode">random_device</code> that is supposed to produce non-deterministic numbers, but this is not an actual constraint as physical sources of random entropy might not be available. Therefore, implementations of <code class="inlineCode">random_device</code> could actually be based on a pseudo-random engine. The <code class="inlineCode">random_device</code> class cannot be seeded like the other engines and has an additional method called <code class="inlineCode">entropy()</code> that returns the random device entropy, which is 0 for a deterministic generator and nonzero for a non-deterministic generator.</p>
<p class="normal">However, this is not a reliable method for determining whether the device is actually deterministic or non-deterministic. For instance, both GNU <code class="inlineCode">libstdc++</code> and LLVM <code class="inlineCode">libc++</code> implement a non-deterministic device but return <code class="inlineCode">0</code> for entropy. On the other hand, <code class="inlineCode">VC++</code> and <code class="inlineCode">boost.random</code> return <code class="inlineCode">32</code> and <code class="inlineCode">10</code>, respectively, for entropy.</p>
<p class="normal">All these<a id="_idIndexMarker219"/> generators produce integers in a uniform distribution. This is, however, only one of the many possible statistical distributions where random numbers are needed in most applications. To be able to produce numbers (either integer or real) in other distributions, the library provides several classes called <em class="italic">distributions</em>. </p>
<p class="normal">These convert the output of an engine according to the statistical distribution it implements. The following distributions are available:</p>
<table class="table-container" id="table012">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Class name</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Numbers</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Statistical distribution</strong></p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal">Uniform</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">uniform_int_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer</p>
</td>
<td class="table-cell">
<p class="normal">Uniform</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">uniform_real_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Uniform</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="4">
<p class="normal">Bernoulli</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">bernoulli_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Boolean</p>
</td>
<td class="table-cell">
<p class="normal">Bernoulli</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">binomial_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer</p>
</td>
<td class="table-cell">
<p class="normal">Binomial</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">negative_binomial_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer</p>
</td>
<td class="table-cell">
<p class="normal">Negative binomial</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">geometric_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer</p>
</td>
<td class="table-cell">
<p class="normal">Geometric</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="5">
<p class="normal">Poisson</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">poisson_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer</p>
</td>
<td class="table-cell">
<p class="normal">Poisson</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">exponential_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Exponential</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">gamma_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Gamma</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">weibull_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Weibull</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">extreme_value_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Extreme value</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="6">
<p class="normal">Normal</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">normal_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Standard normal (Gaussian)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">lognormal_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Lognormal</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">chi_squared_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Chi-squared</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">cauchy_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Cauchy</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">fisher_f_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Fisher’s F-distribution</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">student_t_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Student’s t-distribution</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="3">
<p class="normal">Sampling</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">discrete_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer</p>
</td>
<td class="table-cell">
<p class="normal">Discrete</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">piecewise_constant_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Values distributed on constant subintervals</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">piecewise_linear_distribution</code></p>
</td>
<td class="table-cell">
<p class="normal">Real</p>
</td>
<td class="table-cell">
<p class="normal">Values distributed on defined subintervals</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.12: The list of standard distributions from the &lt;random&gt; header</p>
<p class="normal">Each of the <a id="_idIndexMarker220"/>engines provided by the library has advantages and disadvantages, as mentioned earlier. When initialized appropriately, the Mersenne Twister, although the slowest and one that has the largest internal state, can produce the longest non-repeating sequence of numbers. In the following examples, we will use <code class="inlineCode">std::mt19937</code>, a 32-bit Mersenne Twister with 19,937 bits of internal state. There is also a 64-bit Mersenne Twister, <code class="inlineCode">std::mt19937_64</code>. Both <code class="inlineCode">std::mt19937</code> and <code class="inlineCode">std::mt19937_64</code> are aliases for <code class="inlineCode">std::mersenne_twister_engine</code>.</p>
<p class="normal">The simplest way to generate random numbers looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">auto mtgen = std::mt19937 {};
for (auto i = 0; i &lt; 10; ++i)
  std::cout &lt;&lt; mtgen() &lt;&lt; '\n';
</code></pre>
<p class="normal">In this <a id="_idIndexMarker221"/>example, <code class="inlineCode">mtgen</code> is <code class="inlineCode">std::mt19937</code> for the Mersenne Twister. To generate numbers, you only need to use the call operator that advances the internal state and returns the next pseudo-random number. However, this code is flawed, as the engine is not seeded. As a result, it always produces the same sequence of numbers, which is probably not what you want in most cases.</p>
<p class="normal">There are different approaches to initializing the engine. One approach, common with the C <code class="inlineCode">random</code> library, is to use the current time. In modern C++, it should look like this:</p>
<pre class="programlisting code"><code class="hljs-code">auto seed = std::chrono::high_resolution_clock::now()
            .time_since_epoch()
            .count();
auto mtgen = std::mt19937{ static_cast&lt;unsigned int&gt;(seed) };
</code></pre>
<p class="normal">In this example, <code class="inlineCode">seed</code> is a number representing the number of ticks from the clock’s epoch until the present moment. This number is then used to seed the engine. The problem with this approach is that the value of that <code class="inlineCode">seed</code> is actually deterministic, and in some classes of applications, it could be prone to attacks. A more reliable approach is to seed the generator with actual random numbers.</p>
<p class="normal">The <code class="inlineCode">std::random_device</code> class is an engine that is supposed to return true random numbers, though implementations could actually be based on a pseudo-random generator:</p>
<pre class="programlisting code"><code class="hljs-code">std::random_device rd;
auto mtgen = std::mt19937 {rd()};
</code></pre>
<p class="normal">Numbers produced by all engines follow a uniform distribution. To convert the result to another statistical distribution, we have to use a distribution class. To show how generated numbers are distributed according to the selected distribution, we will use the following function. This function generates a specified number of pseudo-random numbers and counts their repetition in a map. The values from the map are then used to produce a bar-like diagram showing how often each number occurred:</p>
<pre class="programlisting code"><code class="hljs-code">void generate_and_print(std::function&lt;int(void)&gt; gen,
 int const iterations = 10000)
{
  // map to store the numbers and their repetition
auto data = std::map&lt;int, int&gt;{};
  // generate random numbers
for (auto n = 0; n &lt; iterations; ++n)
    ++data[gen()];
  // find the element with the most repetitions
auto max = std::max_element(
             std::begin(data), std::end(data),
             [](auto kvp1, auto kvp2) {
    return kvp1.second &lt; kvp2.second; });
  // print the bars
for (auto i = max-&gt;second / 200; i &gt; 0; --i)
  {
    for (auto kvp : data)
    {
      std::cout
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; std::setw(3)
        &lt;&lt; (kvp.second / 200 &gt;= i ? (char)219 : ' ');
    }
    std::cout &lt;&lt; '\n';
  }
  // print the numbers
for (auto kvp : data)
  {
    std::cout
      &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; std::setw(3)
      &lt;&lt; kvp.first;
  }
  std::cout &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker222"/>following code generates random numbers using the <code class="inlineCode">std::mt19937</code> engine with a uniform distribution in the range <code class="inlineCode">[1, 6]</code>; this is basically what you get when you throw a die:</p>
<pre class="programlisting code"><code class="hljs-code">std::random_device rd{};
auto mtgen = std::mt19937{ rd() };
auto ud = std::uniform_int_distribution&lt;&gt;{ 1, 6 };
generate_and_print([&amp;mtgen, &amp;ud]() {return ud(mtgen); });
</code></pre>
<p class="normal">The output of the program looks like this:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer screen  Description automatically generated" src="img/B21549_02_06.png"/></figure>
<p class="packt_figref">Figure 2.6: Uniform distribution of the range [1,6]</p>
<p class="normal">In the next <a id="_idIndexMarker223"/>and final example, we’re changing the distribution to a normal distribution with a mean of <code class="inlineCode">5</code> and a standard deviation of <code class="inlineCode">2</code>. This distribution produces real numbers; therefore, in order to use the previous <code class="inlineCode">generate_and_print()</code> function, the numbers must be rounded to integers:</p>
<pre class="programlisting code"><code class="hljs-code">std::random_device rd{};
auto mtgen = std::mt19937{ rd() };
auto nd = std::normal_distribution&lt;&gt;{ 5, 2 };
generate_and_print(
  [&amp;mtgen, &amp;nd]() {
    return static_cast&lt;int&gt;(std::round(nd(mtgen))); });
</code></pre>
<p class="normal">The following will be the output of the preceding code:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_07.png"/></figure>
<p class="packt_figref">Figure 2.7: Normal distribution with mean 5 and standard variance 2</p>
<p class="normal">Here, we can<a id="_idIndexMarker224"/> see that, based on the graphical representation, the distribution has changed from a uniform one to a normal one with the mean at value 5.</p>
<h2 class="heading-2" id="_idParaDest-114">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Properly initializing a pseudo-random number generator</em>, to learn how to properly initialize random number engines</li>
</ul>
<h1 class="heading-1" id="_idParaDest-115">Properly initializing a pseudo-random number generator</h1>
<p class="normal">In the<a id="_idIndexMarker225"/> previous recipe, we looked at the pseudo-random number library, along with its components, and how it can be used to produce numbers in different statistical distributions. One important factor that was overlooked in that recipe is the proper initialization of the pseudo-random number generators.</p>
<p class="normal">With careful analysis (which is beyond the purpose of this recipe or this book), it can be shown that the Mersenne Twister engine has a bias toward producing some values repeatedly and omitting others, thus generating numbers not in a uniform distribution, but rather in a binomial or Poisson distribution. In this recipe, you will learn how to initialize a generator in order to produce pseudo-random numbers with a true uniform distribution.</p>
<h2 class="heading-2" id="_idParaDest-116">Getting ready</h2>
<p class="normal">You should read the previous recipe, <em class="italic">Generating pseudo-random numbers</em>, to get an overview of what the pseudo-random number library offers.</p>
<h2 class="heading-2" id="_idParaDest-117">How to do it...</h2>
<p class="normal">To properly <a id="_idIndexMarker226"/>initialize a pseudo-random number generator to produce a uniformly distributed sequence of pseudo-random numbers, perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Use an <code class="inlineCode">std::random_device</code> to produce random numbers to be used as seeding values:
        <pre class="programlisting code"><code class="hljs-code">std::random_device rd;
</code></pre>
</li>
<li class="numberedList">Generate random data for all internal bits of the engine:
        <pre class="programlisting code"><code class="hljs-code">std::array&lt;int, std::mt19937::state_size&gt; seed_data {};
std::generate(std::begin(seed_data), std::end(seed_data),
              std::ref(rd));
</code></pre>
</li>
<li class="numberedList">Create an <code class="inlineCode">std::seed_seq</code> object from the previously generated pseudo-random data:
        <pre class="programlisting code"><code class="hljs-code">std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
</code></pre>
</li>
<li class="numberedList">Create an engine object and initialize all the bits representing the internal state of the engine; for example, an <code class="inlineCode">mt19937</code> has 19,937 bits of internal state:
        <pre class="programlisting code"><code class="hljs-code">auto eng = std::mt19937{ seq };
</code></pre>
</li>
<li class="numberedList">Use the appropriate distribution based on the requirements of the application:
        <pre class="programlisting code"><code class="hljs-code">auto dist = std::uniform_real_distribution&lt;&gt;{ 0, 1 };
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-118">How it works...</h2>
<p class="normal">In all the examples shown in the previous recipe, we used the <code class="inlineCode">std::mt19937</code> engine to produce pseudo-random numbers. Though the Mersenne Twister is slower than the other engines, it can produce the longest sequences of non-repeating numbers with the best spectral characteristics. However, initializing the engine in the manner shown in the previous recipe will not have this effect. The problem is that the internal state of <code class="inlineCode">mt19937</code> has 624 32-bit integers, and in the examples from the previous recipe, we have only initialized one of them.</p>
<p class="normal">When<a id="_idIndexMarker227"/> working with the pseudo-random number library, remember the following rule of thumb (shown in the information box).</p>
<div><p class="normal">In order to produce the best results, engines must have their entire internal state properly initialized before generating numbers.</p>
</div>
<p class="normal">The pseudo-random number library provides a class for this particular purpose, called <code class="inlineCode">std::seed_seq</code>. This is a generator that can be seeded with any number of 32-bit integers and produces the requested number of integers evenly distributed in the 32-bit space.</p>
<p class="normal">In the preceding code from the <em class="italic">How to do it...</em> section, we defined an array called <code class="inlineCode">seed_data</code> with a number of 32-bit integers equal to the internal state of the <code class="inlineCode">mt19937</code> generator – that is, 624 integers. Then, we initialized the array with random numbers produced by <code class="inlineCode">std::random_device</code>. The array was later used to seed <code class="inlineCode">std::seed_seq</code>, which, in turn, was used to seed the <code class="inlineCode">mt19937</code> generator.</p>
<h2 class="heading-2" id="_idParaDest-119">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Generating pseudo-random numbers</em>, to familiarize yourself with the capabilities of the standard numeric library for generating pseudo-random numbers</li>
</ul>
<h1 class="heading-1" id="_idParaDest-120">Creating cooked user-defined literals</h1>
<p class="normal">Literals are<a id="_idIndexMarker228"/> constants of built-in types (numerical, Boolean, character, character string, and pointer) that cannot <a id="_idIndexMarker229"/>be altered in a program. The language defines a series of prefixes and suffixes to specify literals (and the prefix/suffix is actually part of the literal). C++11 allows us to create user-defined literals by defining functions called <em class="italic">literal operators</em>, which introduce suffixes for specifying literals. These work only with numerical character and character string types.</p>
<p class="normal">This opens the possibility of defining both standard literals in future versions and allows developers to create their own literals. In this recipe, we will learn how to create our own cooked literals.</p>
<h2 class="heading-2" id="_idParaDest-121">Getting ready</h2>
<p class="normal">User-defined literals<a id="_idIndexMarker230"/> can have two forms: <em class="italic">raw</em> and <em class="italic">cooked</em>. Raw literals <a id="_idIndexMarker231"/>are not processed by the compiler, whereas<a id="_idIndexMarker232"/> cooked literals are values processed by the compiler (examples include <a id="_idIndexMarker233"/>handling escape sequences in a character string or identifying numerical values such as integer 2898 from literal 0xBAD). Raw literals are only available for integral and floating-point types, whereas cooked literals are also available for character and character string literals.</p>
<h2 class="heading-2" id="_idParaDest-122">How to do it...</h2>
<p class="normal">To create cooked user-defined literals, you should follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Define your literals in a separate namespace to avoid name clashes.</li>
<li class="numberedList">Always prefix the user-defined suffix with an underscore (<code class="inlineCode">_</code>).</li>
<li class="numberedList">Define a literal operator of one of the following forms for cooked literals (the forms using <code class="inlineCode">char8_t</code> are only available since C++20). Notice that in the following listing, <code class="inlineCode">T</code> is not a type template parameter, but only a placeholder for the return type of the operator:
        <pre class="programlisting code"><code class="hljs-code">T operator "" _suffix(unsigned long long int);
T operator "" _suffix(long double);
T operator "" _suffix(char);
T operator "" _suffix(wchar_t);
T operator "" _suffix(char8_t); // since C++20
T operator "" _suffix(char16_t);
T operator "" _suffix(char32_t);
T operator "" _suffix(char const *, std::size_t);
T operator "" _suffix(wchar_t const *, std::size_t);
T operator "" _suffix(char8_t const *, std::size_t); // C++20
T operator "" _suffix(char16_t const *, std::size_t);
T operator "" _suffix(char32_t const *, std::size_t);
</code></pre>
<p class="normal">The following example creates a user-defined literal for specifying kilobytes:</p>
<pre class="programlisting code"><code class="hljs-code">namespace compunits
{
  constexpr size_t operator "" _KB(unsigned long long const size)
  {
    return static_cast&lt;size_t&gt;(size * 1024);
  }
}
auto size{ 4_KB };         // size_t size = 4096;
using byte = unsigned char;
auto buffer = std::array&lt;byte, 1_KB&gt;{};
</code></pre> </li>
</ol>
<h2 class="heading-2" id="_idParaDest-123">How it works...</h2>
<p class="normal">When the <a id="_idIndexMarker234"/>compiler encounters a user-defined literal with a user-defined suffix, <code class="inlineCode">_X</code> (it always has a leading underscore for third-party suffixes, as suffixes without a leading underscore are reserved for the standard library), it does an unqualified name lookup in order to identify a function with the name <code class="inlineCode">operator "" _X</code>. If it finds one, then it calls it according to the type of the literal and the type of the literal operator. Otherwise, the compiler will yield an error.</p>
<p class="normal">In the example shown in the <em class="italic">How to do it...</em> section, the literal operator is called <code class="inlineCode">operator "" _KB</code> and has an argument of type <code class="inlineCode">unsigned long long int</code>. This is the only integral type possible for literal operators to handle integral types. Similarly, for floating-point user-defined literals, the parameter type must be <code class="inlineCode">long double</code> since, for numeric types, the literal operators must be able to handle the largest possible values. This literal operator returns a <code class="inlineCode">constexpr</code> value so that it can be used where compile-time values are expected, such as specifying the size of an array, as shown in the preceding example.</p>
<p class="normal">When the compiler identifies a user-defined literal and has to call the appropriate user-defined literal operator, it will pick the overload from the overload set according to the following rules:</p>
<ul>
<li class="bulletList"><strong class="keyWord">For integral literals</strong>: It <a id="_idIndexMarker235"/>calls in the following order: the operator that takes an <code class="inlineCode">unsigned long long</code>, the raw literal operator that takes a <code class="inlineCode">const char*</code>, or the literal operator template.</li>
<li class="bulletList"><strong class="keyWord">For floating-point literals</strong>: It<a id="_idIndexMarker236"/> calls in the following order: the operator that takes a <code class="inlineCode">long double</code>, the raw literal operator that takes a <code class="inlineCode">const char*</code>, or the literal operator template.</li>
<li class="bulletList"><strong class="keyWord">For character literals</strong>: It calls <a id="_idIndexMarker237"/>the appropriate operator, depending on the character type (<code class="inlineCode">char</code>, <code class="inlineCode">wchar_t</code>, <code class="inlineCode">char16_t</code>, and <code class="inlineCode">char32_t</code>).</li>
<li class="bulletList"><strong class="keyWord">For string literals</strong>: It <a id="_idIndexMarker238"/>calls the appropriate operator, depending on the string type, that takes a pointer to the string of characters and the size.</li>
</ul>
<p class="normal">In the following example, we’re defining a system of units and quantities. We want to operate with kilograms, pieces, liters, and other types of units. This could be useful in a system that can process orders and you need to specify the amount and unit for each article.</p>
<p class="normal">The following are <a id="_idIndexMarker239"/>defined in the <code class="inlineCode">units</code> namespace:</p>
<ul>
<li class="bulletList">A scoped enumeration for the possible types of units (kilogram, meter, liter, and pieces):
        <pre class="programlisting code"><code class="hljs-code">enum class unit { kilogram, liter, meter, piece, };
</code></pre>
</li>
<li class="bulletList">A class template to specify quantities of a particular unit (such as 3.5 kilograms or 42 pieces):
        <pre class="programlisting code"><code class="hljs-code">template &lt;unit U&gt;
class quantity
{
  const double amount;
public:
  constexpr explicit quantity(double const a) : amount(a)
  {}
  explicit operator double() const { return amount; }
};
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">operator+</code> and <code class="inlineCode">operator-</code> functions for the <code class="inlineCode">quantity</code> class template in order to be able to add and subtract quantities:
        <pre class="programlisting code"><code class="hljs-code">template &lt;unit U&gt;
constexpr quantity&lt;U&gt; operator+(quantity&lt;U&gt; const &amp;q1,
                                quantity&lt;U&gt; const &amp;q2)
{
  return quantity&lt;U&gt;(static_cast&lt;double&gt;(q1) +
                     static_cast&lt;double&gt;(q2));
}
template &lt;unit U&gt;
constexpr quantity&lt;U&gt; operator-(quantity&lt;U&gt; const &amp;q1,
                                quantity&lt;U&gt; const &amp;q2)
{
  return quantity&lt;U&gt;(static_cast&lt;double&gt;(q1) –
                     static_cast&lt;double&gt;(q2));
}
</code></pre>
</li>
<li class="bulletList">Literal <a id="_idIndexMarker240"/>operators to create <code class="inlineCode">quantity</code> literals, defined in an inner namespace called <code class="inlineCode">unit_literals</code>. The purpose of this is to avoid possible name clashes with literals from other namespaces.
    <p class="normal">If such collisions do happen, developers could select the ones that they should use using the appropriate namespace in the scope where the literals need to be defined:</p>
<pre class="programlisting code"><code class="hljs-code">namespace unit_literals
{
  constexpr quantity&lt;unit::kilogram&gt; operator "" _kg(
      long double const amount)
  {
    return quantity&lt;unit::kilogram&gt; { static_cast&lt;double&gt;(amount) };
  }
  constexpr quantity&lt;unit::kilogram&gt; operator "" _kg(
      unsigned long long const amount)
  {
    return quantity&lt;unit::kilogram&gt; { static_cast&lt;double&gt;(amount) };
  }
  constexpr quantity&lt;unit::liter&gt; operator "" _l(
      long double const amount)
  {
    return quantity&lt;unit::liter&gt; { static_cast&lt;double&gt;(amount) };
  }
  constexpr quantity&lt;unit::meter&gt; operator "" _m(
      long double const amount)
  {
    return quantity&lt;unit::meter&gt; { static_cast&lt;double&gt;(amount) };
  }
  constexpr quantity&lt;unit::piece&gt; operator "" _pcs(
      unsigned long long const amount)
  {
    return quantity&lt;unit::piece&gt; { static_cast&lt;double&gt;(amount) };
  }
}
</code></pre></li>
</ul>
<p class="normal">By looking carefully, you <a id="_idIndexMarker241"/>can note that the literal operators defined earlier are not the same:</p>
<ul>
<li class="bulletList"><code class="inlineCode">_kg</code> is defined for both integral and floating-point literals; that enables us to create both integral and floating-point values such as <code class="inlineCode">1_kg</code> and <code class="inlineCode">1.0_kg</code>.</li>
<li class="bulletList"><code class="inlineCode">_l</code> and <code class="inlineCode">_m</code> are defined only for floating-point literals; this means we can only define quantity literals for these units with floating points, such as <code class="inlineCode">4.5_l</code> and <code class="inlineCode">10.0_m</code>.</li>
<li class="bulletList"><code class="inlineCode">_pcs</code> is only defined for integral literals; this means we can only define quantities of an integer number of pieces, such as <code class="inlineCode">42_pcs</code>.</li>
</ul>
<p class="normal">Having these literal operators available, we can operate with various quantities. The following examples show both valid and invalid operations:</p>
<pre class="programlisting code"><code class="hljs-code">using namespace units;
using namespace unit_literals;
auto q1{ 1_kg };    // OK
auto q2{ 4.5_kg };  // OK
auto q3{ q1 + q2 }; // OK
auto q4{ q2 - q1 }; // OK
// error, cannot add meters and pieces
auto q5{ 1.0_m + 1_pcs };
// error, cannot have an integer number of liters
auto q6{ 1_l };
// error, can only have an integer number of pieces
auto q7{ 2.0_pcs}
</code></pre>
<p class="normal"><code class="inlineCode">q1</code> is a quantity of 1 kg; this <a id="_idIndexMarker242"/>is an integer value. Since an overloaded <code class="inlineCode">operator "" _kg(unsigned long long const)</code> exists, the literal can be correctly created from the integer 1. Similarly, <code class="inlineCode">q2</code> is a quantity of 4.5 kilograms; this is a real value. Since an overloaded <code class="inlineCode">operator "" _kg(long double)</code> exists, the literal can be created from the double floating-point value 4.5.</p>
<p class="normal">On the other hand, <code class="inlineCode">q6</code> is a quantity of 1 liter. Since there is no overloaded <code class="inlineCode">operator "" _l(unsigned long long)</code>, the literal cannot be created. It would require an overload that takes an <code class="inlineCode">unsigned long long</code>, but such an overload does not exist. Similarly, <code class="inlineCode">q7</code> is a quantity of 2.0 pieces, but piece literals can only be created from integer values and, therefore, this generates another compiler error.</p>
<h2 class="heading-2" id="_idParaDest-124">There’s more...</h2>
<p class="normal">Though user-defined literals are available from C++11, standard literal operators have been available only from C++14. Further standard user-defined literals have been added to the next versions of the standard. The following is a list of these standard literal operators:</p>
<ul>
<li class="bulletList"><code class="inlineCode">operator""s</code> for defining <code class="inlineCode">std::basic_string</code> literals and <code class="inlineCode">operator""sv</code> (in C++17) for defining <code class="inlineCode">std::basic_string_view</code> literals:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::string_literals;
auto s1{  "text"s }; // std::string
auto s2{ L"text"s }; // std::wstring
auto s3{ u"text"s }; // std::u16string
auto s4{ U"text"s }; // std::u32string
using namespace std::string_view_literals;
auto s5{ "text"sv }; // std::string_view
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">operator""h</code>, <code class="inlineCode">operator""min</code>, <code class="inlineCode">operator""s</code>, <code class="inlineCode">operator""ms</code>, <code class="inlineCode">operator""us</code>, and <code class="inlineCode">operator""ns</code> for creating an <code class="inlineCode">std::chrono::duration</code> value:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::chrono_literals;
// std::chrono::duration&lt;long long&gt;
auto timer {2h + 42min + 15s};
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">operator""y</code> for creating an <code class="inlineCode">std::chrono::year</code> literal and <code class="inlineCode">operator""d</code> for creating an <code class="inlineCode">std::chrono::day</code> literal that represents a day of a month, both added to C++20:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::chrono_literals;
auto year { 2020y }; // std::chrono::year
auto day { 15d };    // std::chrono::day
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">operator""if</code>, <code class="inlineCode">operator""i</code>, and <code class="inlineCode">operator""il</code> for creating an <code class="inlineCode">std::complex&lt;float&gt;</code>, <code class="inlineCode">std::complex&lt;double&gt;</code>, and <code class="inlineCode">std::complex&lt;long double&gt;</code> value:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::complex_literals;
auto c{ 12.0 + 4.5i }; // std::complex&lt;double&gt;
</code></pre>
</li>
</ul>
<p class="normal">The standard <a id="_idIndexMarker243"/>user-defined literals are available in multiple namespaces. For instance, the <code class="inlineCode">""s</code> and <code class="inlineCode">""sv</code> literals for strings are defined in the namespace <code class="inlineCode">std::literals::string_literals</code>.</p>
<p class="normal">However, both <code class="inlineCode">literals</code> and <code class="inlineCode">string_literals</code> are inlined namespaces. Therefore, you can access the literals with <code class="inlineCode">using namespace std::literals</code>, <code class="inlineCode">using namespace std::string_literals</code>, or <code class="inlineCode">using namespace std::literals::string_literals</code>. In the previous examples, the second form was preferred.</p>
<h2 class="heading-2" id="_idParaDest-125">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using raw string literals to avoid escaping characters</em>, to learn how to define string literals without the need to escape special characters</li>
<li class="bulletList"><em class="italic">Creating raw user-defined literals</em>, to understand how to provide a custom interpretation of an input sequence so that it changes the normal behavior of the compiler</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Using inline namespaces for symbol versioning,</em> to learn how to version your source code using inline namespaces and conditional compilation</li>
</ul>
<h1 class="heading-1" id="_idParaDest-126">Creating raw user-defined literals</h1>
<p class="normal">In the previous<a id="_idIndexMarker244"/> recipe, we looked at the way C++11 allows library implementers and developers to create user-defined literals and the user-defined literals available in the C++14 standard. However, user-defined literals have two forms: a cooked form, where the literal value is processed by the compiler before being supplied to the literal operator, and a raw form, in which the literal is not processed by the compiler before being supplied to the literal operator. The latter is only available for integral and floating-point types. Raw literals are useful for altering the compiler’s normal behavior. For instance, a sequence such as 3.1415926 is interpreted by the compiler as a floating-point value, but with the use of a raw user-defined literal, it could be interpreted as a user-defined decimal value. In this recipe, we will look at creating raw user-defined literals.</p>
<h2 class="heading-2" id="_idParaDest-127">Getting ready</h2>
<p class="normal">Before continuing with this recipe, it is strongly recommended that you go through the previous one, <em class="italic">Creating cooked user-defined literals</em>, as general details about user-defined literals will not be reiterated here.</p>
<p class="normal">To exemplify the way raw user-defined literals can be created, we will define binary literals. These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned) types. These types will be called <code class="inlineCode">byte8</code>, <code class="inlineCode">byte16</code>, and <code class="inlineCode">byte32</code>, and the literals we will create will be called <code class="inlineCode">_b8</code>, <code class="inlineCode">_b16</code>, and <code class="inlineCode">_b32</code>.</p>
<h2 class="heading-2" id="_idParaDest-128">How to do it...</h2>
<p class="normal">To create raw user-defined literals, you should follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Define your literals in a separate namespace to avoid name clashes.</li>
<li class="numberedList">Always prefix the used-defined suffix with an underscore (<code class="inlineCode">_</code>).</li>
<li class="numberedList">Define a literal operator or literal operator template of the following form:
        <pre class="programlisting code"><code class="hljs-code">T operator "" _suffix(const char*);
template&lt;char...&gt; T operator "" _suffix();
</code></pre>
</li>
</ol>
<p class="normal">The following <a id="_idIndexMarker245"/>example shows a possible implementation of 8-bit, 16-bit, and 32-bit binary literals:</p>
<pre class="programlisting code"><code class="hljs-code">namespace binary
{
  using byte8  = unsigned char;
  using byte16 = unsigned short;
  using byte32 = unsigned int;
  namespace binary_literals
  {
    namespace binary_literals_internals
    {
      template &lt;typename CharT, char... bits&gt;
      struct binary_struct;
      template &lt;typename CharT, char... bits&gt;
      struct binary_struct&lt;CharT, '0', bits...&gt;
      {
        static constexpr CharT value{
          binary_struct&lt;CharT, bits...&gt;::value };
      };
      template &lt;typename CharT, char... bits&gt;
      struct binary_struct&lt;CharT, '1', bits...&gt;
      {
        static constexpr CharT value{
          static_cast&lt;CharT&gt;(1 &lt;&lt; sizeof...(bits)) |
          binary_struct&lt;CharT, bits...&gt;::value };
      };
      template &lt;typename CharT&gt;
      struct binary_struct&lt;CharT&gt;
      {
        static constexpr CharT value{ 0 };
      };
    }
    template&lt;char... bits&gt;
    constexpr byte8 operator""_b8()
    {
      static_assert(
        sizeof...(bits) &lt;= 8,
        "binary literal b8 must be up to 8 digits long");
      return binary_literals_internals::
                binary_struct&lt;byte8, bits...&gt;::value;
    }
    template&lt;char... bits&gt;
    constexpr byte16 operator""_b16()
    {
      static_assert(
        sizeof...(bits) &lt;= 16,
        "binary literal b16 must be up to 16 digits long");
      return binary_literals_internals::
                binary_struct&lt;byte16, bits...&gt;::value;
    }
    template&lt;char... bits&gt;
    constexpr byte32 operator""_b32()
    {
      static_assert(
        sizeof...(bits) &lt;= 32,
        "binary literal b32 must be up to 32 digits long");
      return binary_literals_internals::
                binary_struct&lt;byte32, bits...&gt;::value;
    }
  }
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-129">How it works...</h2>
<p class="normal">First of all, we<a id="_idIndexMarker246"/> define everything inside a namespace called <code class="inlineCode">binary</code> and start by introducing several type aliases: <code class="inlineCode">byte8</code>, <code class="inlineCode">byte16</code>, and <code class="inlineCode">byte32</code>. These represent integral types of 8 bits, 16 bits, and 32 bits, as the names imply.</p>
<p class="normal">The implementation in the previous section enables us to define binary literals of the form <code class="inlineCode">1010_b8</code> (a <code class="inlineCode">byte8</code> value of decimal 10) or <code class="inlineCode">000010101100_b16</code> (a <code class="inlineCode">byte16</code> value of decimal 2130496). However, we want to make sure that we do not exceed the number of digits for each type. In other words, values such as <code class="inlineCode">111100001_b8</code> should be illegal and the compiler should yield an error.</p>
<p class="normal">The literal operator templates are defined in a nested namespace called <code class="inlineCode">binary_literal_internals</code>. This is a good practice in order to avoid name collisions with other literal operators from other namespaces. Should something like that happen, you can choose to use the appropriate namespace in the right scope (such as one namespace in a function or block and another namespace in another function or block).</p>
<p class="normal">The <a id="_idIndexMarker247"/>three literal operator templates are very similar. The only things that are different are their names (<code class="inlineCode">_b8</code>, <code class="inlineCode">_16</code>, and <code class="inlineCode">_b32</code>), return type (<code class="inlineCode">byte8</code>, <code class="inlineCode">byte16</code>, and <code class="inlineCode">byte32</code>), and the condition in the static assert that checks the number of digits.</p>
<p class="normal">We will explore the details of variadic templates and template recursion in a later recipe; however, for a better understanding, this is how this particular implementation works: <code class="inlineCode">bits</code> is a template parameter pack that is not a single value, but all the values the template could be instantiated with. For example, if we consider the literal <code class="inlineCode">1010_b8</code>, then the literal operator template would be instantiated as <code class="inlineCode">operator"" _b8&lt;'1', '0', '1', '0'&gt;()</code>. Before proceeding with computing the binary value, we check the number of digits in the literal. For <code class="inlineCode">_b8</code>, this must not exceed eight (including any trailing zeros). Similarly, it should be up to 16 digits for <code class="inlineCode">_b16</code> and 32 for <code class="inlineCode">_b32</code>. For this, we use the <code class="inlineCode">sizeof...</code> operator, which returns the number of elements in a parameter pack (in this case, <code class="inlineCode">bits</code>).</p>
<p class="normal">If the number of digits is correct, we can proceed to expand the parameter pack and recursively compute the decimal value represented by the binary literal. This is done with the help of an additional class template and its specializations. These templates are defined in yet another nested namespace, called <code class="inlineCode">binary_literals_internals</code>. This is also a good practice because it hides (without proper qualification) the implementation details from the client (unless an explicit <code class="inlineCode">using namespace</code> directive makes them available to the current namespace).</p>
<div><p class="normal">Even though this looks like recursion, it is not a true runtime recursion. This is because, after the compiler expands and generates the code from templates, what we end up with is basically calls to overloaded functions with a different number of parameters. This is explained in <em class="italic">Chapter 3</em> in the <em class="italic">Writing a function template with a variable number of arguments</em> recipe.</p>
</div>
<p class="normal">The <code class="inlineCode">binary_struct</code> class template has a template type of <code class="inlineCode">CharT</code> for the return type of the function (we need this because our literal operator templates should return either <code class="inlineCode">byte8</code>, <code class="inlineCode">byte16</code>, or <code class="inlineCode">byte32</code>) and a parameter pack:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename CharT, char... bits&gt;
struct binary_struct;
</code></pre>
<p class="normal">Several specializations<a id="_idIndexMarker248"/> of this class template are available with parameter pack decomposition (of which you can read more in <em class="chapterRef">Chapter 3</em> in the <em class="italic">Writing a function template with a variable number of arguments</em>) recipe. When the first digit of the pack is <code class="inlineCode">'0'</code>, the computed value remains the same, and we continue expanding the rest of the pack. If the first digit of the pack is <code class="inlineCode">'1'</code>, then the new value is 1, shifted to the left with the number of digits in the remainder of the pack bit, or the value of the rest of the pack:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename CharT, char... bits&gt;
struct binary_struct&lt;CharT, '0', bits...&gt;
{
  static constexpr CharT value{ binary_struct&lt;CharT, bits...&gt;::value };
};
template &lt;typename CharT, char... bits&gt;
struct binary_struct&lt;CharT, '1', bits...&gt;
{
  static constexpr CharT value{
    static_cast&lt;CharT&gt;(1 &lt;&lt; sizeof...(bits)) |
    binary_struct&lt;CharT, bits...&gt;::value };
};
</code></pre>
<p class="normal">The last specialization covers the case where the pack is empty; in this case, we return 0:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename CharT&gt;
struct binary_struct&lt;CharT&gt;
{
  static constexpr CharT value{ 0 };
};
</code></pre>
<p class="normal">After defining these helper classes, we could implement the <code class="inlineCode">byte8</code>, <code class="inlineCode">byte16</code>, and <code class="inlineCode">byte32</code> binary literals as intended. Note that we need to bring the content of the namespace <code class="inlineCode">binary_literals</code> into the current namespace in order to use the literal operator templates:</p>
<pre class="programlisting code"><code class="hljs-code">using namespace binary;
using namespace binary_literals;
auto b1 = 1010_b8;
auto b2 = 101010101010_b16;
auto b3 = 101010101010101010101010_b32;
</code></pre>
<p class="normal">The following definitions trigger compiler errors:</p>
<pre class="programlisting code"><code class="hljs-code">// binary literal b8 must be up to 8 digits long
auto b4 = 0011111111_b8;
// binary literal b16 must be up to 16 digits long
auto b5 = 001111111111111111_b16;
// binary literal b32 must be up to 32 digits long
auto b6 = 0011111111111111111111111111111111_b32;
</code></pre>
<p class="normal">The reason<a id="_idIndexMarker249"/> for this is that the condition in <code class="inlineCode">static_assert</code> is not met. The length of the sequence of characters preceding the literal operator is greater than expected, in all cases.</p>
<h2 class="heading-2" id="_idParaDest-130">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using raw string literals to avoid escaping characters</em>, to learn how to define string literals without the need to escape special characters</li>
<li class="bulletList"><em class="italic">Creating cooked user-defined literals</em>, to learn how to create literals of user-defined types</li>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Writing a function template with a variable number of arguments</em>, to see how variadic templates enable us to write functions that can take any number of arguments</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Creating type aliases and alias templates</em>, to learn about aliases for types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-131">Using raw string literals to avoid escaping characters</h1>
<p class="normal">Strings <a id="_idIndexMarker250"/>may contain special characters, such as <a id="_idIndexMarker251"/>non-printable characters (newline, horizontal and vertical tab, and so on), string and character delimiters (double and single quotes), or arbitrary octal, hexadecimal, or Unicode values. These special characters are introduced with an escape sequence that starts with a backslash, followed by either the character (examples include <code class="inlineCode">'</code> and <code class="inlineCode">"</code>), its designated letter (examples include <code class="inlineCode">n</code> for a new line, and <code class="inlineCode">t</code> for a horizontal tab), or its value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). As a result, the backslash character itself has to be escaped with another backslash character. This leads to more complicated literal strings that can be hard to read.</p>
<p class="normal">To avoid <a id="_idIndexMarker252"/>escaping characters, C++11 introduced raw string literals that do not process escape sequences. In this recipe, you will learn how to use the various forms of raw string literals.</p>
<h2 class="heading-2" id="_idParaDest-132">Getting ready</h2>
<p class="normal">In this recipe, and throughout the rest of this book, I will use the <code class="inlineCode">s</code> suffix to define <code class="inlineCode">basic_string</code> literals. This was covered earlier in this chapter in the <em class="italic">Creating cooked user-defined literals</em> recipe.</p>
<h2 class="heading-2" id="_idParaDest-133">How to do it...</h2>
<p class="normal">To <a id="_idIndexMarker253"/>avoid escaping characters, define the string literals with one of the following forms:</p>
<ul>
<li class="bulletList"><code class="inlineCode">R"( literal )"</code> as the default form:
        <pre class="programlisting code"><code class="hljs-code">auto filename {R"(C:\Users\Marius\Documents\)"s};
auto pattern {R"((\w+)=(\d+)$)"s};
auto sqlselect {
  R"(SELECT *
  FROM Books
  WHERE Publisher='Packtpub'
  ORDER BY PubDate DESC)"s};
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">R"delimiter( literal )delimiter"</code>, where <code class="inlineCode">delimiter</code> is any sequence of characters excluding parentheses, backslash, and spaces, and <code class="inlineCode">literal</code> is any sequence of characters with the limitation that it cannot include the closing sequence <code class="inlineCode">)delimiter"</code>. Here is an example with <code class="inlineCode">!!</code> as a delimiter:
        <pre class="programlisting code"><code class="hljs-code">auto text{ R"!!(This text contains both "( and )".)!!"s };
std::cout &lt;&lt; text &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-134">How it works...</h2>
<p class="normal">When <a id="_idIndexMarker254"/>string literals are used, escapes are not processed, and the actual content of the string is written between the delimiter (in other words, what you see is what you get). The following example shows what appears as the same raw literal string; however, the second one still contains escaped characters. Since these are not processed in the case of string literals, they will be printed as they are in the output:</p>
<pre class="programlisting code"><code class="hljs-code">auto filename1 {R"(C:\Users\Marius\Documents\)"s};
auto filename2 {R"(C:\\Users\\Marius\\Documents\\)"s};
// prints C:\Users\Marius\Documents\
std::cout &lt;&lt; filename1 &lt;&lt; '\n';
// prints C:\\Users\\Marius\\Documents\\
std::cout &lt;&lt; filename2 &lt;&lt; '\n';
</code></pre>
<p class="normal">If the text<a id="_idIndexMarker255"/> has to contain the <code class="inlineCode">)"</code> sequence, then a different delimiter must be used, in the <code class="inlineCode">R"delimiter( literal )delimiter"</code> form. According to the standard, the possible characters in a delimiter can be as follows:</p>
<blockquote class="packt_quote">
<p class="quote">Any member of the basic source character set except: space, the left parenthesis (the right parenthesis ), the backslash \, and the control characters representing horizontal tab, vertical tab, form feed, and newline.</p>
</blockquote>
<p class="normal">Raw string literals can be prefixed by one of <code class="inlineCode">L</code>, <code class="inlineCode">u8</code>, <code class="inlineCode">u</code>, and <code class="inlineCode">U</code> to indicate a wide, UTF-8, UTF-16, or UTF-32 string literal, respectively. The following are examples of such string literals:</p>
<pre class="programlisting code"><code class="hljs-code">auto t1{ LR"(text)"  };  // const wchar_t*
auto t2{ u8R"(text)" };  // const char* until C++20
 // const char8_t* in C++20
auto t3{ uR"(text)"  };  // const char16_t*
auto t4{ UR"(text)"  };  // const char32_t*
auto t5{ LR"(text)"s  }; // std::wstring
auto t6{ u8R"(text)"s }; // std::string until C++20
 // std::u8string in C++20
auto t7{ uR"(text)"s  }; // std::u16string
auto t8{ UR"(text)"s  }; // std::u32string
</code></pre>
<p class="normal">Note that the presence of the suffix <code class="inlineCode">""s</code> at the end of the string makes the compiler deduce the type <a id="_idIndexMarker256"/>as various string <a id="_idIndexMarker257"/>classes and not character arrays.</p>
<h2 class="heading-2" id="_idParaDest-135">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating cooked user-defined literals</em>, to learn how to create literals of user-defined types</li>
<li class="bulletList"><em class="italic">Understanding the various character and string types</em>, to learn more about character and string types, literal prefixes, and the changes in C++20 concerning the <code class="inlineCode">u8</code> prefix</li>
</ul>
<h1 class="heading-1" id="_idParaDest-136">Creating a library of string helpers</h1>
<p class="normal">The<a id="_idIndexMarker258"/> string types from the standard library are a general-purpose implementation that lacks many helpful methods, such as changing the case, trimming, splitting, and others that may address different developer needs. Third-party libraries that provide rich sets of string functionalities exist. However, in this recipe, we will look at implementing several simple, yet helpful, methods you may often need in practice. The purpose is to see how string methods and standard general algorithms can be used for manipulating strings but also to have a reference to reusable code that can be used in your applications.</p>
<p class="normal">In this recipe, we will implement a small library of string utilities that will provide functions for the following:</p>
<ul>
<li class="bulletList">Changing a string into lowercase or uppercase</li>
<li class="bulletList">Reversing a string</li>
<li class="bulletList">Trimming white spaces from the beginning and/or the end of the string</li>
<li class="bulletList">Trimming a specific set of characters from the beginning and/or the end of the string</li>
<li class="bulletList">Removing occurrences of a character anywhere in the string</li>
<li class="bulletList">Tokenizing a string using a specific delimiter</li>
</ul>
<p class="normal">Before we start with the implementation, let’s look at some prerequisites.</p>
<h2 class="heading-2" id="_idParaDest-137">Getting ready</h2>
<p class="normal">The string library we will be implementing should work with all the standard string types – that is, <code class="inlineCode">std::string</code>, <code class="inlineCode">std::wstring</code>, <code class="inlineCode">std::u16string</code>, and <code class="inlineCode">std::u32string</code>.</p>
<p class="normal">To avoid specifying long names such as <code class="inlineCode">std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;, std::allocator&lt;CharT&gt;&gt;</code>, we will use the following alias templates for<a id="_idIndexMarker259"/> strings and string streams:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename CharT&gt;
using tstring =
  std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;,
                    std::allocator&lt;CharT&gt;&gt;;
template &lt;typename CharT&gt;
using tstringstream =
  std::basic_stringstream&lt;CharT, std::char_traits&lt;CharT&gt;,
                          std::allocator&lt;CharT&gt;&gt;;
</code></pre>
<p class="normal">To implement these string helper functions, we need to include the header <code class="inlineCode">&lt;string&gt;</code> for strings and <code class="inlineCode">&lt;algorithm&gt;</code> for the general standard algorithms we will use.</p>
<p class="normal">In all the examples in this recipe, we will use the standard user-defined literal operators for strings from C++14, for which we need to explicitly use the <code class="inlineCode">std::string_literals</code> namespace.</p>
<h2 class="heading-2" id="_idParaDest-138">How to do it...</h2>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">To convert a string to lowercase or uppercase, apply the <code class="inlineCode">tolower()</code> or <code class="inlineCode">toupper()</code> functions to the characters of a string using the general-purpose algorithm <code class="inlineCode">std::transform()</code>:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; to_upper(tstring&lt;CharT&gt; text)
{
  std::transform(std::begin(text), std::end(text),
                 std::begin(text), toupper);
  return text;
}
template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; to_lower(tstring&lt;CharT&gt; text)
{
  std::transform(std::begin(text), std::end(text),
                 std::begin(text), tolower);
  return text;
}
</code></pre>
</li>
<li class="numberedList">To reverse a string, use the general-purpose algorithm <code class="inlineCode">std::reverse()</code>:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; reverse(tstring&lt;CharT&gt; text)
{
  std::reverse(std::begin(text), std::end(text));
  return text;
}
</code></pre>
</li>
<li class="numberedList">To trim<a id="_idIndexMarker260"/> a string at the beginning, end, or both, use the <code class="inlineCode">std::basic_string</code> methods <code class="inlineCode">find_first_not_of()</code> and <code class="inlineCode">find_last_not_of()</code>:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; trim(tstring&lt;CharT&gt; const &amp; text)
{
  auto first{ text.find_first_not_of(' ') };
  auto last{ text.find_last_not_of(' ') };
  return text.substr(first, (last - first + 1));
}
template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; trimleft(tstring&lt;CharT&gt; const &amp; text)
{
  auto first{ text.find_first_not_of(' ') };
  return text.substr(first, text.size() - first);
}
template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; trimright(tstring&lt;CharT&gt; const &amp; text)
{
  auto last{ text.find_last_not_of(' ') };
  return text.substr(0, last + 1);
}
</code></pre>
</li>
<li class="numberedList">To trim characters in a given set from a string, use overloads of the <code class="inlineCode">std::basic_string</code> methods <code class="inlineCode">find_first_not_of()</code> and <code class="inlineCode">find_last_not_of()</code>, which take a string parameter that defines the set of characters to look for:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; trim(tstring&lt;CharT&gt; const &amp; text,
                           tstring&lt;CharT&gt; const &amp; chars)
{
  auto first{ text.find_first_not_of(chars) };
  auto last{ text.find_last_not_of(chars) };
  return text.substr(first, (last - first + 1));
}
template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; trimleft(tstring&lt;CharT&gt; const &amp; text,
                               tstring&lt;CharT&gt; const &amp; chars)
{
  auto first{ text.find_first_not_of(chars) };
  return text.substr(first, text.size() - first);
}
template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; trimright(tstring&lt;CharT&gt; const &amp;text,
                                tstring&lt;CharT&gt; const &amp;chars)
{
  auto last{ text.find_last_not_of(chars) };
  return text.substr(0, last + 1);
}
</code></pre>
</li>
<li class="numberedList">To remove<a id="_idIndexMarker261"/> characters from a string, use <code class="inlineCode">std::remove_if()</code> and <code class="inlineCode">std::basic_string::erase()</code>:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; remove(tstring&lt;CharT&gt; text,
                             CharT const ch)
{
  auto start = std::remove_if(
                  std::begin(text), std::end(text),
                  [=](CharT const c) {return c == ch; });
  text.erase(start, std::end(text));
  return text;
}
</code></pre>
</li>
<li class="numberedList">To split a string based on a specified delimiter, use <code class="inlineCode">std::getline()</code> to read from an <code class="inlineCode">std::basic_stringstream</code> initialized with the content of the string. The tokens extracted from the stream are pushed into a vector of strings:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename CharT&gt;
inline std::vector&lt;tstring&lt;CharT&gt;&gt; split
  (tstring&lt;CharT&gt; text, CharT const delimiter)
{
  auto sstr = tstringstream&lt;CharT&gt;{ text };
  auto tokens = std::vector&lt;tstring&lt;CharT&gt;&gt;{};
  auto token = tstring&lt;CharT&gt;{};
  while (std::getline(sstr, token, delimiter))
  {
    if (!token.empty()) tokens.push_back(token);
  }
  return tokens;
}
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-139">How it works...</h2>
<p class="normal">To implement<a id="_idIndexMarker262"/> the utility functions from the library, we have two options:</p>
<ul>
<li class="bulletList">Functions will modify a string passed by a reference</li>
<li class="bulletList">Functions will not alter the original string but, instead, return a new string</li>
</ul>
<p class="normal">The second option has the advantage that it preserves the original string, which may be helpful in many cases. Otherwise, in those cases, you would first have to make a copy of the string and alter the copy. The implementation provided in this recipe takes the second approach.</p>
<p class="normal">The first functions we implemented in the <em class="italic">How to do it...</em> section were <code class="inlineCode">to_upper()</code> and <code class="inlineCode">to_lower()</code>. These functions change the content of a string either to uppercase or lowercase. The simplest way to implement this is by using the <code class="inlineCode">std::transform()</code> standard algorithm. This is a general-purpose algorithm that applies a function to every element of a range (defined by a begin and end iterator) and stores the result in another range for which only the begin iterator needs to be specified. The output range can be the same as the input range, which is exactly what we did to transform the string. The applied function is <code class="inlineCode">toupper()</code> or <code class="inlineCode">tolower()</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto ut{ string_library::to_upper("this is not UPPERCASE"s) };
// ut = "THIS IS NOT UPPERCASE"
auto lt{ string_library::to_lower("THIS IS NOT lowercase"s) };
// lt = "this is not lowercase"
</code></pre>
<p class="normal">The <a id="_idIndexMarker263"/>next function we considered was <code class="inlineCode">reverse()</code>, which, as the name implies, reverses the content of a string. For this, we used the <code class="inlineCode">std::reverse()</code> standard algorithm. This general-purpose algorithm reverses the elements of a range defined by a begin and end iterator:</p>
<pre class="programlisting code"><code class="hljs-code">auto rt{string_library::reverse("cookbook"s)}; // rt = "koobkooc"
</code></pre>
<p class="normal">When it comes to trimming, a string can be trimmed at the beginning, end, or both sides. For that reason, we implemented three different functions: <code class="inlineCode">trim()</code> for trimming at both ends, <code class="inlineCode">trimleft()</code> for trimming at the beginning of a string, and <code class="inlineCode">trimright()</code> for trimming at the end of a string. The first version of the function trims only spaces. In order to find the right part to trim, we use the <code class="inlineCode">find_first_not_of()</code> and <code class="inlineCode">find_last_not_of()</code> methods of <code class="inlineCode">std::basic_string</code>. These return the first and last characters in the string that are not of the specified character. Subsequently, a call to the <code class="inlineCode">substr()</code> method of <code class="inlineCode">std::basic_string</code> returns a new string. The <code class="inlineCode">substr()</code> method takes an index in the string and a number of elements to copy to the new string:</p>
<pre class="programlisting code"><code class="hljs-code">auto text1{"   this is an example   "s};
auto t1{ string_library::trim(text1) };
// t1 = "this is an example"
auto t2{ string_library::trimleft(text1) };
// t2 = "this is an example   "
auto t3{ string_library::trimright(text1) };
// t3 = "   this is an example"
</code></pre>
<p class="normal">Sometimes, it can be useful to trim other characters and then spaces from a string. In order to do that, we provided overloads for the trimming functions that specify a set of characters to be removed. That set is also specified as a string. The implementation is very similar to the previous one because both <code class="inlineCode">find_first_not_of()</code> and <code class="inlineCode">find_last_not_of()</code> have overloads that take a string containing the characters to be excluded from the search:</p>
<pre class="programlisting code"><code class="hljs-code">auto chars1{" !%\n\r"s};
auto text3{"!!  this % needs a lot\rof trimming  !\n"s};
auto t7{ string_library::trim(text3, chars1) };
// t7 = "this % needs a lot\rof trimming"
auto t8{ string_library::trimleft(text3, chars1) };
// t8 = "this % needs a lot\rof trimming  !\n"
auto t9{ string_library::trimright(text3, chars1) };
// t9 = "!!  this % needs a lot\rof trimming"
</code></pre>
<p class="normal">If <a id="_idIndexMarker264"/>removing characters from any part of the string is necessary, the trimming methods are not helpful because they only treat a contiguous sequence of characters at the start and end of a string. For that, however, we implemented a simple <code class="inlineCode">remove()</code> method. This uses the <code class="inlineCode">std:remove_if()</code> standard algorithm.</p>
<p class="normal">Both <code class="inlineCode">std::remove()</code> and <code class="inlineCode">std::remove_if()</code> work in a way that may not be very intuitive at first. They remove elements that satisfy the criteria from a range defined by a first and last iterator by rearranging the content of the range (using move assignment). The elements that need to be removed are placed at the end of the range, and the function returns an iterator to the first element in the range that represents the removed elements. This iterator basically defines the new end of the range that was modified. If no element was removed, the returned iterator is the end iterator of the original range. The value of this returned iterator is then used to call the <code class="inlineCode">std::basic_string::erase()</code> method, which actually erases the content of the string defined by two iterators. The two iterators in our case are the iterator returned by <code class="inlineCode">std::remove_if()</code> and the end of the string:</p>
<pre class="programlisting code"><code class="hljs-code">auto text4{"must remove all * from text**"s};
auto t10{ string_library::remove(text4, '*') };
// t10 = "must remove all  from text"
auto t11{ string_library::remove(text4, '!') };
// t11 = "must remove all * from text**"
</code></pre>
<p class="normal">The last method we implemented, <code class="inlineCode">split()</code>, splits the content of a string based on a specified delimiter. There are various ways to implement this. In this implementation, we used <code class="inlineCode">std::getline()</code>. This function reads characters from an input stream until a specified delimiter is found and places the characters in a string. </p>
<p class="normal">Before starting to read from the input buffer, it calls <code class="inlineCode">erase()</code> on the output string to clear its content. Calling this method in a loop produces tokens that are placed in a vector. In our implementation, empty tokens were skipped from the result set:</p>
<pre class="programlisting code"><code class="hljs-code">auto text5{"this text will be split   "s};
auto tokens1{ string_library::split(text5, ' ') };
// tokens1 = {"this", "text", "will", "be", "split"}
auto tokens2{ string_library::split(""s, ' ') };
// tokens2 = {}
</code></pre>
<p class="normal">Two examples<a id="_idIndexMarker265"/> of text splitting are shown here. In the first example, the text from the <code class="inlineCode">text5</code> variable is split into words and, as mentioned earlier, empty tokens are ignored. In the second example, splitting an empty string produces an empty vector of <code class="inlineCode">token</code>.</p>
<h2 class="heading-2" id="_idParaDest-140">There’s more…</h2>
<p class="normal">Several helper methods have been added to the <code class="inlineCode">std::basic_string</code> class template in recent versions of the standard to help users avoid defining some widely used functions. These are listed in the following table:</p>
<table class="table-container" id="table013">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Function</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">C++ version</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">starts_with</code></p>
</td>
<td class="table-cell">
<p class="normal">C++20</p>
</td>
<td class="table-cell">
<p class="normal">Checks whether the string starts with the specified prefix </p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ends_with</code></p>
</td>
<td class="table-cell">
<p class="normal">C++20</p>
</td>
<td class="table-cell">
<p class="normal">Checks whether the string ends with the specified suffix</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">contains</code></p>
</td>
<td class="table-cell">
<p class="normal">C++23</p>
</td>
<td class="table-cell">
<p class="normal">Checks whether the string contains the specified substring</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.13: Newer basic_string member functions for widely-used string operations</p>
<p class="normal">The use of these member functions is exemplified in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">std::string text = "The Lord of the Rings";
if(text.starts_with("The")) {}
if(text.ends_with("Rings")) {}
if(text.contains("Lord")) {}
</code></pre>
<h2 class="heading-2" id="_idParaDest-141">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating cooked user-defined literals</em>, to learn how to create literals of user-defined types</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Creating type aliases and alias templates</em>, to learn about aliases for types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-142">Verifying the format of a string using regular expressions</h1>
<p class="normal">Regular expressions <a id="_idIndexMarker266"/>are a language intended for performing pattern matching and replacements in texts. C++11 provides support for regular expressions <a id="_idIndexMarker267"/>within the standard library through a set of classes, algorithms, and iterators available in the <code class="inlineCode">&lt;regex&gt;</code> header. In this recipe, we will learn how regular expressions can be used to verify that a string matches a pattern (examples include verifying an email or IP address format).</p>
<h2 class="heading-2" id="_idParaDest-143">Getting ready</h2>
<p class="normal">Throughout<a id="_idIndexMarker268"/> this recipe, we will explain, whenever necessary, the details of the regular expressions that we use. However, you should have at least some basic knowledge of regular expressions in order to use the C++ standard library for regular expressions. A description of regular expression syntax and standards is beyond the purpose of this book; if you are not familiar with regular expressions, it is recommended that you read more about them before continuing with this, and the other recipes that focus on regular expressions. Good online resources for learning, building, and debugging regular expressions can be found at <a href="https://regexr.com">https://regexr.com</a> and <a href="https://regex101.com">https://regex101.com</a>.</p>
<h2 class="heading-2" id="_idParaDest-144">How to do it...</h2>
<p class="normal">In order to verify that a string matches a regular expression, perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Include the <code class="inlineCode">&lt;regex&gt;</code> and <code class="inlineCode">&lt;string&gt;</code> headers and the <code class="inlineCode">std::string_literals</code> namespace for standard user-defined literals for strings (added in C++14):
        <pre class="programlisting code"><code class="hljs-code">#include &lt;regex&gt;
#include &lt;string&gt;
using namespace std::string_literals;
</code></pre>
</li>
<li class="numberedList">Use<a id="_idIndexMarker269"/> raw string literals to specify the regular expression to avoid escaping backslashes (which can occur frequently). The following regular expression validates most email formats:
        <pre class="programlisting code"><code class="hljs-code">auto pattern {R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s};
</code></pre>
</li>
<li class="numberedList">Create <a id="_idIndexMarker270"/>an <code class="inlineCode">std::regex</code>/<code class="inlineCode">std::wregex</code> object (depending on the character set that is used) to encapsulate the regular expression:
        <pre class="programlisting code"><code class="hljs-code">auto rx = std::regex{pattern};
</code></pre>
</li>
<li class="numberedList">To ignore casing or specify other parsing options, use an overloaded constructor that has an extra parameter for regular expression flags:
        <pre class="programlisting code"><code class="hljs-code">auto rx = std::regex{pattern, std::regex_constants::icase};
</code></pre>
</li>
<li class="numberedList">Use <code class="inlineCode">std::regex_match()</code> to match the regular expression with an entire string:
        <pre class="programlisting code"><code class="hljs-code">auto valid = std::regex_match("marius@domain.com"s, rx);
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-145">How it works...</h2>
<p class="normal">Considering the problem of verifying the format of email addresses, even though this may look like a trivial problem, in practice, it is hard to find a simple regular expression that covers all the possible cases for valid email formats. In this recipe, we will not try to find that ultimate regular expression but, rather, apply a regular expression that is good enough for most cases. The regular expression we will use for this purpose is this:</p>
<pre class="programlisting code"><code class="hljs-code">^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$
</code></pre>
<p class="normal">The following table explains the structure of the regular expression:</p>
<table class="table-container" id="table014">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Part</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">^</code></p>
</td>
<td class="table-cell">
<p class="normal">Start of string</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[A-Z0-9._%+-]+</code></p>
</td>
<td class="table-cell">
<p class="normal">At least one character that is an uppercase letter, <code class="inlineCode">A-Z</code>, a digit <code class="inlineCode">0-9</code>, or one of <code class="inlineCode">.</code>, <code class="inlineCode">%</code>, <code class="inlineCode">+</code>, or <code class="inlineCode">-</code>, which represents the local part of the email address</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">@</code></p>
</td>
<td class="table-cell">
<p class="normal">The character <code class="inlineCode">@</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[A-Z0-9.-]+</code></p>
</td>
<td class="table-cell">
<p class="normal">At least one character that is an uppercase letter <code class="inlineCode">A-Z</code>, a digit <code class="inlineCode">0-9</code>, or one of the symbols <code class="inlineCode">.</code> or <code class="inlineCode">-</code>, which represents the hostname of the domain part</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">\.</code></p>
</td>
<td class="table-cell">
<p class="normal">A dot that separates the domain hostname and label</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[A-Z]{2,}</code></p>
</td>
<td class="table-cell">
<p class="normal">The DNS label of a domain, which can have between 2 and 63 characters</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">$</code></p>
</td>
<td class="table-cell">
<p class="normal">End of the string</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.14: The structure of the previously defined regular expression</p>
<p class="normal">Bear in <a id="_idIndexMarker271"/>mind that, in practice, a domain<a id="_idIndexMarker272"/> name is composed of a hostname followed by a dot-separated list of DNS labels. Examples include <code class="inlineCode">localhost</code>, <code class="inlineCode">gmail.com</code>, and <code class="inlineCode">yahoo.co.uk</code>. This regular expression we are using does not match domains without DNS labels, such as <code class="inlineCode">localhost</code> (an email address such as <code class="inlineCode">root@localhost</code> is a valid email address). The domain name can also be an IP address specified in brackets, such as <code class="inlineCode">[192.168.100.11]</code> (as in <code class="inlineCode">john.doe@[192.168.100.11]</code>). Email addresses containing such domains will not match the regular expression defined previously. Even though these rather rare formats will not be matched, the regular expression can cover most email formats.</p>
<div><p class="normal">The regular expression for the example in this chapter is provided for didactical purposes only and is not intended to be used as it is in production code. As explained earlier, this sample does not cover all possible email formats.</p>
</div>
<p class="normal">We began by including the necessary headers – that is, <code class="inlineCode">&lt;regex&gt;</code> for regular expressions and <code class="inlineCode">&lt;string&gt;</code> for strings. The <code class="inlineCode">is_valid_email()</code> function, shown in the following code (which basically contains the samples from the <em class="italic">How to do it...</em> section), takes a string representing an email address and returns a Boolean indicating whether the email has a valid format or not.</p>
<p class="normal">We first <a id="_idIndexMarker273"/>construct an <code class="inlineCode">std::regex</code> object to encapsulate the regular expression indicated with the raw string literal. Using<a id="_idIndexMarker274"/> raw string literals is helpful because it avoids escaping backslashes, which are used for escape characters in regular expressions too. The function then calls <code class="inlineCode">std::regex_match()</code>, passing the input text and the regular expression:</p>
<pre class="programlisting code"><code class="hljs-code">bool is_valid_email_format(std::string const &amp; email)
{
  auto pattern {R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s};
  auto rx = std::regex{ pattern };
  return std::regex_match(email, rx);
}
</code></pre>
<p class="normal">The <code class="inlineCode">std::regex_match()</code> method tries to match the regular expression against the entire string. If successful, it returns <code class="inlineCode">true</code>; otherwise, it returns <code class="inlineCode">false</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto ltest = [](std::string const &amp; email)
{
  std::cout &lt;&lt; std::setw(30) &lt;&lt; std::left
            &lt;&lt; email &lt;&lt; " : "
            &lt;&lt; (is_valid_email_format(email) ?
                "valid format" : "invalid format")
            &lt;&lt; '\n';
};
ltest("JOHN.DOE@DOMAIN.COM"s);         // valid format
ltest("JOHNDOE@DOMAIL.CO.UK"s);        // valid format
ltest("JOHNDOE@DOMAIL.INFO"s);         // valid format
ltest("J.O.H.N_D.O.E@DOMAIN.INFO"s);   // valid format
ltest("ROOT@LOCALHOST"s);              // invalid format
ltest("john.doe@domain.com"s);         // invalid format
</code></pre>
<p class="normal">In this simple test, the only emails that do not match the regular expression are <code class="inlineCode">ROOT@LOCALHOST</code> and <code class="inlineCode">john.doe@domain.com</code>. The first contains a domain name without a dot-prefixed DNS label, and that case is not covered in the regular expression. The second contains only lowercase letters, and in the regular expression, the valid set of characters for both the local part and the domain name was uppercase letters, A to Z.</p>
<p class="normal">Instead of<a id="_idIndexMarker275"/> complicating the regular expression with additional valid characters (such as <code class="inlineCode">[A-Za-z0-9._%+-]</code>), we can specify that the match can ignore this case. This can be done with an additional parameter to the constructor of the <code class="inlineCode">std::basic_regex</code> class. The available constants for this purpose are defined in the <code class="inlineCode">regex_constants</code> namespace. </p>
<p class="normal">The <a id="_idIndexMarker276"/>following slight change to <code class="inlineCode">is_valid_email_format()</code> will make it ignore the case and allow email addresses with both lowercase and uppercase letters to correctly match the regular expression:</p>
<pre class="programlisting code"><code class="hljs-code">bool is_valid_email_format(std::string const &amp; email)
{
  auto rx = std::regex{
    R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s,
    std::regex_constants::icase};
  return std::regex_match(email, rx);
}
</code></pre>
<p class="normal">This <code class="inlineCode">is_valid_email_format()</code> function is pretty simple, and if the regular expression was provided as a parameter, along with the text to match, it could be used for matching anything. However, it would be nice to be able to handle not only multi-byte strings (<code class="inlineCode">std::string</code>) but also wide strings (<code class="inlineCode">std::wstring</code>), with a single function. This can be achieved by creating a function template where the character type is provided as a template parameter:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename CharT&gt;
using tstring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;,
                                  std::allocator&lt;CharT&gt;&gt;;
template &lt;typename CharT&gt;
bool is_valid_format(tstring&lt;CharT&gt; const &amp; pattern,
                     tstring&lt;CharT&gt; const &amp; text)
{
  auto rx = std::basic_regex&lt;CharT&gt;{ pattern, std::regex_constants::icase };
  return std::regex_match(text, rx);
}
</code></pre>
<p class="normal">We start by creating an alias template for <code class="inlineCode">std::basic_string</code> in order to simplify its use. The new <code class="inlineCode">is_valid_format()</code> function is a function template very similar to our implementation of <code class="inlineCode">is_valid_email()</code>. However, we now use <code class="inlineCode">std::basic_regex&lt;CharT&gt;</code> instead of the typedef <code class="inlineCode">std::regex</code>, which is <code class="inlineCode">std::basic_regex&lt;char&gt;</code>, and the pattern is provided as the first argument. We now implement a new function called <code class="inlineCode">is_valid_email_format_w()</code> for wide strings that relies on<a id="_idIndexMarker277"/> this function template. The <a id="_idIndexMarker278"/>function template, however, can be reused for implementing other validations, such as whether a license plate has a particular format:</p>
<pre class="programlisting code"><code class="hljs-code">bool is_valid_email_format_w(std::wstring const &amp; text)
{
  return is_valid_format(
    LR"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s,
    text);
}
auto ltest2 = [](auto const &amp; email)
{
  std::wcout &lt;&lt; std::setw(30) &lt;&lt; std::left
     &lt;&lt; email &lt;&lt; L" : "
     &lt;&lt; (is_valid_email_format_w(email) ? L"valid" : L"invalid")
     &lt;&lt; '\n';
};
ltest2(L"JOHN.DOE@DOMAIN.COM"s);       // valid
ltest2(L"JOHNDOE@DOMAIL.CO.UK"s);      // valid
ltest2(L"JOHNDOE@DOMAIL.INFO"s);       // valid
ltest2(L"J.O.H.N_D.O.E@DOMAIN.INFO"s); // valid
ltest2(L"ROOT@LOCALHOST"s);            // invalid
ltest2(L"john.doe@domain.com"s);       // valid
</code></pre>
<p class="normal">Of all the examples shown here, the only one that does not match is <code class="inlineCode">ROOT@LOCALHOST</code>, as expected.</p>
<p class="normal">The <code class="inlineCode">std::regex_match()</code> method has, in fact, several overloads, and some of them have a parameter that is a reference to an <code class="inlineCode">std::match_results</code> object to store the result of the match. If there is no match, then <code class="inlineCode">std::match_results</code> is empty and its size is 0. Otherwise, if there is a match, the <code class="inlineCode">std::match_results</code> object is not empty and its size is 1, plus the number of matched subexpressions.</p>
<p class="normal">The <a id="_idIndexMarker279"/>following version of the function uses the mentioned overloads and returns the matched subexpressions in an <code class="inlineCode">std::smatch</code> object. Note that the regular expression is changed as three caption groups are defined – one for the local part, one for the hostname part of the domain, and one for the DNS label. If the match is successful, then the <code class="inlineCode">std::smatch</code> object will contain four submatch objects: the first (index 0) to match the entire string, the second (index 1) for the first capture group (the local part), the third (index 2) for the second capture group (the hostname), and the fourth (index 3) for the third and last capture group (the DNS label). The result is returned in a tuple, where the first item<a id="_idIndexMarker280"/> actually indicates success or failure:</p>
<pre class="programlisting code"><code class="hljs-code">std::tuple&lt;bool, std::string, std::string, std::string&gt;
is_valid_email_format_with_result(std::string const &amp; email)
{
  auto rx = std::regex{
    R"(^([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,})$)"s,
    std::regex_constants::icase };
  auto result = std::smatch{};
  auto success = std::regex_match(email, result, rx);
  return std::make_tuple(
    success,
    success ? result[1].str() : ""s,
    success ? result[2].str() : ""s,
    success ? result[3].str() : ""s);
}
</code></pre>
<p class="normal">Following the preceding code, we use C++17 structured bindings to unpack the content of the tuple into named variables:</p>
<pre class="programlisting code"><code class="hljs-code">auto ltest3 = [](std::string const &amp; email)
{
  auto [valid, localpart, hostname, dnslabel] =
    is_valid_email_format_with_result(email);
  std::cout &lt;&lt; std::setw(30) &lt;&lt; std::left
     &lt;&lt; email &lt;&lt; " : "
     &lt;&lt; std::setw(10) &lt;&lt; (valid ? "valid" : "invalid")
     &lt;&lt; "local=" &lt;&lt; localpart
     &lt;&lt; ";domain=" &lt;&lt; hostname
     &lt;&lt; ";dns=" &lt;&lt; dnslabel
     &lt;&lt; '\n';
};
ltest3("JOHN.DOE@DOMAIN.COM"s);
ltest3("JOHNDOE@DOMAIL.CO.UK"s);
ltest3("JOHNDOE@DOMAIL.INFO"s);
ltest3("J.O.H.N_D.O.E@DOMAIN.INFO"s);
ltest3("ROOT@LOCALHOST"s);
ltest3("john.doe@domain.com"s);
</code></pre>
<p class="normal">The<a id="_idIndexMarker281"/> output of the program will be as follows:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_08.png"/></figure>
<p class="packt_figref">Figure 2.8: Output of tests</p>
<h2 class="heading-2" id="_idParaDest-146">There’s more...</h2>
<p class="normal">There are <a id="_idIndexMarker282"/>multiple versions of regular expressions, and the C++ standard library supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and egrep (grep with the option <code class="inlineCode">-E</code>). The default grammar used is ECMAScript, and in order to use another, you have to explicitly specify the grammar when defining the regular expression. You can learn more about the supported grammar options at <a href="https://en.cppreference.com/w/cpp/regex/syntax_option_type">https://en.cppreference.com/w/cpp/regex/syntax_option_type</a>. In addition to specifying the grammar, you can also specify parsing options, such as matching by ignoring the case.</p>
<p class="normal">The standard library <a id="_idIndexMarker283"/>provides more classes and algorithms than we have seen so far. The main classes available in the library are as follows (all of them are class templates and, for convenience, typedefs are provided for different character types):</p>
<ul>
<li class="bulletList">The class template <code class="inlineCode">std::basic_regex</code> defines the regular expression object:
        <pre class="programlisting code"><code class="hljs-code">typedef basic_regex&lt;char&gt;    regex;
typedef basic_regex&lt;wchar_t&gt; wregex;
</code></pre>
</li>
<li class="bulletList">The class template <code class="inlineCode">std::sub_match</code> represents a sequence of characters that matches a capture group; this class is actually derived from <code class="inlineCode">std::pair</code>, and its <code class="inlineCode">first</code> and <code class="inlineCode">second</code> members represent iterators to the first and the one-past-the-end characters in the match sequence. If there is no match sequence, the two iterators are equal:
        <pre class="programlisting code"><code class="hljs-code">typedef sub_match&lt;const char *&gt;            csub_match;
typedef sub_match&lt;const wchar_t *&gt;         wcsub_match;
typedef sub_match&lt;string::const_iterator&gt;  ssub_match;
typedef sub_match&lt;wstring::const_iterator&gt; wssub_match;
</code></pre>
</li>
<li class="bulletList">The <a id="_idIndexMarker284"/>class template <code class="inlineCode">std::match_results</code> is a collection of matches; the first element is always a full match in the target, while the other elements are matches of subexpressions:
        <pre class="programlisting code"><code class="hljs-code">typedef match_results&lt;const char *&gt;            cmatch;
typedef match_results&lt;const wchar_t *&gt;         wcmatch;
typedef match_results&lt;string::const_iterator&gt;  smatch;
typedef match_results&lt;wstring::const_iterator&gt; wsmatch;
</code></pre>
</li>
</ul>
<p class="normal">The algorithms available in the regular expressions standard library are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::regex_match()</code>: This tries to match a regular expression (represented by an <code class="inlineCode">std::basic_regex</code> instance) to an entire string.</li>
<li class="bulletList"><code class="inlineCode">std::regex_search()</code>: This tries to match a regular expression (represented by an <code class="inlineCode">std::basic_regex</code> instance) to a part of a string (including the entire string).</li>
<li class="bulletList"><code class="inlineCode">std::regex_replace()</code>: This replaces matches from a regular expression according to a specified format.</li>
</ul>
<p class="normal">The iterators available in the regular expressions standard library are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::regex_interator</code>: A constant forward iterator used to iterate through the occurrences of a pattern in a string. It has a pointer to an <code class="inlineCode">std::basic_regex</code> that must live until the iterator is destroyed. Upon creation and when incremented, the iterator calls <code class="inlineCode">std::regex_search()</code> and stores a copy of the <code class="inlineCode">std::match_results</code> object returned by the algorithm.</li>
<li class="bulletList"><code class="inlineCode">std::regex_token_iterator</code>: A constant forward iterator used to iterate through the submatches of every match of a regular expression in a string. Internally, it uses a <code class="inlineCode">std::regex_iterator</code> to step through the submatches. Since it stores a pointer to an <code class="inlineCode">std::basic_regex</code> instance, the regular expression object must live until the iterator is destroyed.</li>
</ul>
<p class="normal">It should be <a id="_idIndexMarker285"/>mentioned that the standard regex library<a id="_idIndexMarker286"/> has poorer performance compared to other implementations (such as Boost.Regex) and does not support Unicode. Moreover, it could be argued that the API itself is cumbersome to use. However, using the standard library has the benefit of avoiding additional dependencies.</p>
<h2 class="heading-2" id="_idParaDest-147">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Parsing the content of a string using regular expressions</em>, to learn how to perform multiple matches of a pattern in a text</li>
<li class="bulletList"><em class="italic">Replacing the content of a string using regular expressions</em>, to see how to perform text replacements with the help of regular expressions</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Using structured bindings to handle multi-return values</em>, to learn how to bind variables to subobjects or elements from the initializing expressions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-148">Parsing the content of a string using regular expressions</h1>
<p class="normal">In the<a id="_idIndexMarker287"/> previous recipe, we looked at how to use <code class="inlineCode">std::regex_match()</code> to verify that the content of a string matches a particular format. The <a id="_idIndexMarker288"/>library provides another algorithm called <code class="inlineCode">std::regex_search()</code> that matches a regular expression against any part of a string, and not the entire string, as <code class="inlineCode">regex_match()</code> does. This function, however, does not allow us to search through all the occurrences of a regular expression in an input string. For this purpose, we need to use one of the iterator classes available in the library.</p>
<p class="normal">In this recipe, you will learn how to parse the content of a string using regular expressions. For this purpose, we will consider the problem of parsing a text file containing name-value pairs. Each such pair is defined on a different line and has the format <code class="inlineCode">name = value</code>, but lines starting with a <code class="inlineCode">#</code> represent comments and must be ignored. The following is an example:</p>
<pre class="programlisting code"><code class="hljs-code">#remove # to uncomment a line
timeout=120
server = 127.0.0.1
#retrycount=3
</code></pre>
<p class="normal">Before looking at the implementation details, let’s consider some prerequisites.</p>
<h2 class="heading-2" id="_idParaDest-149">Getting ready</h2>
<p class="normal">For general information about regular expression support in C++11, refer to the <em class="italic">Verifying the format of a string using regular expressions</em> recipe earlier in this chapter. Basic knowledge of regular expressions is required to proceed with this recipe.</p>
<p class="normal">In the following examples, <code class="inlineCode">text</code> is a variable that’s defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code">auto text {
  R"(
    #remove # to uncomment a line
    timeout=120
    server = 127.0.0.1
    #retrycount=3
  )"s};
</code></pre>
<p class="normal">The sole purpose of this is to simplify our snippets, although, in a real-world example, you will probably be reading the text from a file or other source.</p>
<h2 class="heading-2" id="_idParaDest-150">How to do it...</h2>
<p class="normal">In order to <a id="_idIndexMarker289"/>search for occurrences <a id="_idIndexMarker290"/>of a regular expression through a string, you should do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Include the headers <code class="inlineCode">&lt;regex&gt;</code> and <code class="inlineCode">&lt;string&gt;</code> and the namespace <code class="inlineCode">std::string_literals</code> for standard user-defined literals for strings (added in C++14):
        <pre class="programlisting code"><code class="hljs-code">#include &lt;regex&gt;
#include &lt;string&gt;
using namespace std::string_literals;
</code></pre>
</li>
<li class="numberedList">Use raw string literals (or raw wide string literals for <code class="inlineCode">std::wregex</code>) to specify a regular expression in order to avoid escaping backslashes (which can occur frequently). The following regular expression validates the file format proposed earlier:
        <pre class="programlisting code"><code class="hljs-code">auto pattern {R"(^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,\-:]*)$)"s};
</code></pre>
</li>
<li class="numberedList">Create an <code class="inlineCode">std::regex</code>/<code class="inlineCode">std::wregex</code> object (depending on the character set that is used) to encapsulate the regular expression:
        <pre class="programlisting code"><code class="hljs-code">auto rx = std::regex{pattern};
</code></pre>
</li>
<li class="numberedList">To search for the first occurrence of a regular expression in a given text, use the general-purpose algorithm <code class="inlineCode">std::regex_search()</code> (example 1):
        <pre class="programlisting code"><code class="hljs-code">auto match = std::smatch{};
if (std::regex_search(text, match, rx))
{
  std::cout &lt;&lt; match[1] &lt;&lt; '=' &lt;&lt; match[2] &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="numberedList">To find all the occurrences of a regular expression in a given text, use the iterator <code class="inlineCode">std::regex_iterator</code> (example 2):
        <pre class="programlisting code"><code class="hljs-code">auto end = std::sregex_iterator{};
for (auto it=std::sregex_iterator{ std::begin(text),
                                   std::end(text), rx };
     it != end; ++it)
{
  std::cout &lt;&lt; '\'' &lt;&lt; (*it)[1] &lt;&lt; "'='"
            &lt;&lt; (*it)[2] &lt;&lt; '\'' &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="numberedList">To <a id="_idIndexMarker291"/>iterate through all the subexpressions of a match, use the iterator <code class="inlineCode">std::regex_token_iterator</code> (example 3):
        <pre class="programlisting code"><code class="hljs-code">auto end = std::sregex_token_iterator{};
for (auto it = std::sregex_token_iterator{
                  std::begin(text), std::end(text), rx };
     it != end; ++it)
{
  std::cout &lt;&lt; *it &lt;&lt; '\n';
}
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-151">How it works...</h2>
<p class="normal">A <a id="_idIndexMarker292"/>simple regular expression that can parse the input file shown earlier may look like this:</p>
<pre class="programlisting code"><code class="hljs-code">^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,\-:]*)$
</code></pre>
<p class="normal">This regular expression is supposed to ignore all lines that start with a <code class="inlineCode">#</code>; for those that do not start with <code class="inlineCode">#</code>, match a name followed by the equals sign and then a value, which can be composed of alphanumeric characters and several other characters (underscore, dot, comma, and so on). The exact meaning of this regular expression is explained as follows:</p>
<table class="table-container" id="table015">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Part</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">^</code></p>
</td>
<td class="table-cell">
<p class="normal">Start of line</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(?!#)</code></p>
</td>
<td class="table-cell">
<p class="normal">A negative lookahead that makes sure that it is not possible to match the <code class="inlineCode">#</code> character</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(\w)+</code></p>
</td>
<td class="table-cell">
<p class="normal">A capturing group representing an identifier of at least a one-word character</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">\s*</code></p>
</td>
<td class="table-cell">
<p class="normal">Any white spaces</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">=</code></p>
</td>
<td class="table-cell">
<p class="normal">Equals sign</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">\s*</code></p>
</td>
<td class="table-cell">
<p class="normal">Any white spaces</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">([\w\d]+[\w\d._,\-:]*)</code></p>
</td>
<td class="table-cell">
<p class="normal">A capturing group representing a value that starts with an alphanumeric character, but can also contain a dot, comma, backslash, hyphen, colon, or underscore</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">$</code></p>
</td>
<td class="table-cell">
<p class="normal">End of line</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.15: Breaking down the regular expression</p>
<p class="normal">We can <a id="_idIndexMarker293"/>use <code class="inlineCode">std::regex_search()</code> to search for a match anywhere in the input text. This algorithm has several overloads, but in general, they work in the same way. You must specify the range of characters to work through, an output <code class="inlineCode">std::match_results</code> object that will contain the result of the match, and an <code class="inlineCode">std::basic_regex</code> object representing the regular expression and matching flags (which define the way the search is done). The function returns <code class="inlineCode">true</code> if a match was found or <code class="inlineCode">false</code> otherwise.</p>
<p class="normal">In the<a id="_idIndexMarker294"/> first example from the previous section (see the fourth list item), <code class="inlineCode">match</code> is an instance of <code class="inlineCode">std::smatch</code> that is a typedef of <code class="inlineCode">std::match_results</code> with <code class="inlineCode">string::const_iterator</code> as the template type. If a match is found, this object will contain the matching information in a sequence of values for all matched subexpressions. The submatch at index 0 is always the entire match. </p>
<p class="normal">The submatch at index 1 is the first subexpression that was matched, the submatch at index 2 is the second subexpression that was matched, and so on. Since we have two capturing groups (which are subexpressions) in our regular expression, the <code class="inlineCode">std::match_results</code> will have three submatches in the event of success. The identifier representing the name is at index 1, and the value after the equals sign is at index 2. Therefore, this code only prints the following:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_09.png"/></figure>
<p class="packt_figref">Figure 2.9: Output of the first example</p>
<p class="normal">The <code class="inlineCode">std::regex_search()</code> algorithm is not able to iterate through all the possible matches<a id="_idIndexMarker295"/> in a piece of text. To do that, we need to use an iterator. <code class="inlineCode">std::regex_iterator</code> is intended for this purpose. It allows not only iterating through all the matches but also accessing all the submatches of a match.</p>
<p class="normal">The<a id="_idIndexMarker296"/> iterator actually calls <code class="inlineCode">std::regex_search()</code> upon construction and on each increment, and it remembers the resulting <code class="inlineCode">std::match_results</code> from the call. The default constructor creates an iterator that represents the end of the sequence and can be used to test when the loop through the matches should stop.</p>
<p class="normal">In the second example from the previous section (see the fifth list item), we first create an end-of-sequence iterator, and then we start iterating through all the possible matches. When constructed, it will call <code class="inlineCode">std::regex_match()</code>, and if a match is found, we can access its results through the current iterator. This will continue until no match is found (the end of the sequence). This code will print the following output:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_10.png"/></figure>
<p class="packt_figref">Figure 2.10: Output of the second example</p>
<p class="normal">An alternative to <code class="inlineCode">std::regex_iterator</code> is <code class="inlineCode">std::regex_token_iterator</code>. This works similarly to the way <code class="inlineCode">std::regex_iterator</code> works and, in fact, it contains such an iterator internally, except that it enables us to access a particular subexpression from a match. This is shown in the third example in the <em class="italic">How to do it...</em> section (see the sixth list item). We start by creating an end-of-sequence iterator and then loop through the matches until the end-of-sequence is reached. In the constructor we used, we did not specify the index of the subexpression to access through the iterator; therefore, the default value of 0 is used. This means this program will print all the matches:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_11.png"/></figure>
<p class="packt_figref">Figure 2.11: Output of the third example</p>
<p class="normal">If we<a id="_idIndexMarker297"/> wanted to access only the first subexpression (this means the names in our case), all we had to do was specify the index of <a id="_idIndexMarker298"/>the subexpression in the constructor of the token iterator, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">auto end = std::sregex_token_iterator{};
for (auto it = std::sregex_token_iterator{ std::begin(text),
               std::end(text), rx, 1 };
     it != end; ++it)
{
  std::cout &lt;&lt; *it &lt;&lt; '\n';
}
</code></pre>
<p class="normal">This time, the output that we get contains only the names. This is shown in the following image:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_12.png"/></figure>
<p class="packt_figref">Figure 2.12: Output containing only the names</p>
<p class="normal">An interesting thing about the token iterator is that it can return the unmatched parts of the string if the index of the subexpressions is <code class="inlineCode">-1</code>, in which case it returns an <code class="inlineCode">std::match_results</code> object that corresponds to the sequence of characters between the last match and the end of the sequence:</p>
<pre class="programlisting code"><code class="hljs-code">auto end = std::sregex_token_iterator{};
for (auto it = std::sregex_token_iterator{ std::begin(text),
               std::end(text), rx, -1 };
     it != end; ++it)
{
  std::cout &lt;&lt; *it &lt;&lt; '\n';
}
</code></pre>
<p class="normal">This program <a id="_idIndexMarker299"/>will output the following:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_02_13.png"/></figure>
<p class="packt_figref">Figure 2.13: Output including empty lines</p>
<p class="normal">Please <a id="_idIndexMarker300"/>note that the empty lines in the output correspond to empty tokens.</p>
<h2 class="heading-2" id="_idParaDest-152">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Verifying the format of a string using regular expressions</em>, to familiarize yourself with the C++ library support for working with regular expressions</li>
<li class="bulletList"><em class="italic">Replacing the content of a string using regular expressions</em>, to learn how to perform multiple matches of a pattern in a text</li>
</ul>
<h1 class="heading-1" id="_idParaDest-153">Replacing the content of a string using regular expressions</h1>
<p class="normal">In the <a id="_idIndexMarker301"/>previous two recipes, we looked at how to match a regular expression on a string or a part of a string and iterate <a id="_idIndexMarker302"/>through matches and submatches. The regular expression library also supports text replacement based on regular expressions. In this recipe, we will learn how to use <code class="inlineCode">std::regex_replace()</code> to perform such text transformations.</p>
<h2 class="heading-2" id="_idParaDest-154">Getting ready</h2>
<p class="normal">For general information about regular expression support in C++11, refer to the <em class="italic">Verifying the format of a string using regular expressions</em> recipe earlier in this chapter.</p>
<h2 class="heading-2" id="_idParaDest-155">How to do it...</h2>
<p class="normal">In order to <a id="_idIndexMarker303"/>perform text transformations <a id="_idIndexMarker304"/>using regular expressions, you should perform the following:</p>
<ul>
<li class="bulletList">Include <code class="inlineCode">&lt;regex&gt;</code> and <code class="inlineCode">&lt;string&gt;</code> and the namespace <code class="inlineCode">std::string_literals</code> for C++14 standard user-defined literals for strings:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;regex&gt;
#include &lt;string&gt;
using namespace std::string_literals;
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">std::regex_replace()</code> algorithm with a replacement string as the third argument. Consider the following example. Replace all words composed of exactly three characters that are either <code class="inlineCode">a</code>, <code class="inlineCode">b</code>, or <code class="inlineCode">c</code> with three hyphens:
        <pre class="programlisting code"><code class="hljs-code">auto text{"abc aa bca ca bbbb"s};
auto rx = std::regex{ R"(\b[a|b|c]{3}\b)"s };
auto newtext = std::regex_replace(text, rx, "---"s);
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">std::regex_replace()</code> algorithm with match identifiers prefixed with a <code class="inlineCode">$</code> for the third argument. For example, replace names in the format “lastname, firstname” with names in the format “firstname lastname”, as follows:
        <pre class="programlisting code"><code class="hljs-code">auto text{ "bancila, marius"s };
auto rx = std::regex{ R"((\w+),\s*(\w+))"s };
auto newtext = std::regex_replace(text, rx, "$2 $1"s);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-156">How it works...</h2>
<p class="normal">The <code class="inlineCode">std::regex_replace()</code> algorithm has several overloads with different types of parameters, but the meaning of the parameters is as follows:</p>
<ul>
<li class="bulletList">The input string on which the replacement is performed</li>
<li class="bulletList">An <code class="inlineCode">std::basic_regex</code> object that encapsulates the regular expression used to identify the parts of the strings to be replaced</li>
<li class="bulletList">The string format used for replacement</li>
<li class="bulletList">Optional matching flags</li>
</ul>
<p class="normal">The<a id="_idIndexMarker305"/> return value is, depending on the overload used, either a string or a copy of the output iterator provided as <a id="_idIndexMarker306"/>an argument. The string format used for replacement can either be a simple string or a match identifier, indicated with a <code class="inlineCode">$</code> prefix:</p>
<ul>
<li class="bulletList"><code class="inlineCode">$&amp;</code> indicates the entire match.</li>
<li class="bulletList"><code class="inlineCode">$1</code>, <code class="inlineCode">$2</code>, <code class="inlineCode">$3</code>, and so on indicate the first, second, and third submatches, and so on.</li>
<li class="bulletList"><code class="inlineCode">$`</code> indicates the part of the string before the first match.</li>
<li class="bulletList"><code class="inlineCode">$'</code> indicates the part of the string after the last match.</li>
</ul>
<p class="normal">In the first example shown in the <em class="italic">How to do it...</em> section, the initial text contains two words made of exactly three <code class="inlineCode">a</code>, <code class="inlineCode">b</code>, and <code class="inlineCode">c</code> characters: <code class="inlineCode">abc</code> and <code class="inlineCode">bca</code>. The regular expression indicates an expression of exactly three characters between word boundaries. This means a subtext, such as <code class="inlineCode">bbbb</code>, will not match the expression. The result of the replacement is that the string text will be <code class="inlineCode">--- aa --- ca bbbb</code>.</p>
<p class="normal">Additional flags for the match can be specified for the <code class="inlineCode">std::regex_replace()</code> algorithm. By default, the matching flag is <code class="inlineCode">std::regex_constants::match_default</code>, which basically specifies ECMAScript as the grammar used for constructing the regular expression. If we want, for instance, to replace only the first occurrence, then we can specify <code class="inlineCode">std::regex_constants::format_first_only</code>. In the following example, the result is <code class="inlineCode">--- aa bca ca bbbb</code> as the replacement stops after the first match is found:</p>
<pre class="programlisting code"><code class="hljs-code">auto text{ "abc aa bca ca bbbb"s };
auto rx = std::regex{ R"(\b[a|b|c]{3}\b)"s };
auto newtext = std::regex_replace(text, rx, "---"s,
                 std::regex_constants::format_first_only);
</code></pre>
<p class="normal">The replacement string, however, can contain special indicators for the whole match, a particular submatch, or the parts that were not matched, as explained earlier. In the second example shown in the <em class="italic">How to do it...</em> section, the regular expression identifies a word of at least one character, followed by a comma and possible white spaces, and then another word of at least one character. The first word is supposed to be the last name, while the second word is supposed to be the first name. The replacement string is in the <code class="inlineCode">$2 $1</code> format. This is an instruction that’s used to replace the matched expression (in this example, the entire original string) with another string formed of the second submatch, followed by a space, and then the first submatch.</p>
<p class="normal">In this case, the <a id="_idIndexMarker307"/>entire string was a<a id="_idIndexMarker308"/> match. In the following example, there will be multiple matches inside the string, and they will all be replaced with the indicated string. In this example, we are replacing the indefinite article <em class="italic">a</em> when preceding a word that starts with a vowel (this, of course, does not cover words that start with a vowel sound) with the indefinite article <em class="italic">an</em>:</p>
<pre class="programlisting code"><code class="hljs-code">auto text{"this is a example with a error"s};
auto rx = std::regex{R"(\ba ((a|e|i|u|o)\w+))"s};
auto newtext = std::regex_replace(text, rx, "an $1");
</code></pre>
<p class="normal">The regular expression identifies the letter <em class="italic">a</em> as a single word (<code class="inlineCode">\b</code> indicates a word boundary, so <code class="inlineCode">\ba</code> means a word with a single letter, <em class="italic">a</em>), followed by a space and a word of at least two characters starting with a vowel. When such a match is identified, it is replaced with a string formed of the fixed string <em class="italic">an</em>, followed by a space and the first subexpression of the match, which is the word itself. In this example, the <code class="inlineCode">newtext</code> string will be <code class="inlineCode">this is an example with an error</code>.</p>
<p class="normal">Apart from the identifiers of the subexpressions (<code class="inlineCode">$1</code>, <code class="inlineCode">$2</code>, and so on), there are other identifiers for the entire match (<code class="inlineCode">$&amp;</code>), the part of the string before the first match (<code class="inlineCode">$`</code>), and the part of the string after the last match (<code class="inlineCode">$'</code>). In the last example, we change the format of a date from <code class="inlineCode">dd.mm.yyyy</code> to <code class="inlineCode">yyyy.mm.dd</code>, but also show the matched parts:</p>
<pre class="programlisting code"><code class="hljs-code">auto text{"today is 1.06.2023!!"s};
auto rx = std::regex{R"((\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4}))"s};
// today is 2023.06.1!!
auto newtext1 = std::regex_replace(text, rx, R"($5$4$3$2$1)");
// today is [today is ][1.06.2023][!!]!!
auto newtext2 = std::regex_replace(text, rx, R"([$`][$&amp;][$'])");
</code></pre>
<p class="normal">The regular expression matches a one- or two-digit number followed by a dot, hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen, or slash; and lastly, a four-digit number. Keep in mind this is only an example, and there are better expressions for parsing a date.</p>
<p class="normal">For <code class="inlineCode">newtext1</code>, the replacement string is <code class="inlineCode">$5$4$3$2$1</code>; this means year, followed by the second separator, then month, the first separator, and finally, day. Therefore, for the input string <code class="inlineCode">today is 1.06.2023!</code>, the result is <code class="inlineCode">today is 2023.06.1!!</code>.</p>
<p class="normal">For <code class="inlineCode">newtext2</code>, the <a id="_idIndexMarker309"/>replacement string is <code class="inlineCode">[$`][$&amp;][$']</code>; this means the part before the first match, followed by the <a id="_idIndexMarker310"/>entire match, and finally, the part after the last match are in square brackets. However, the result is not <code class="inlineCode">[!!][1.06.2023][today is ]</code> as you perhaps might expect at first glance, but <code class="inlineCode">today is [today is ][1.06.2023][!!]!!</code>. The reason for this is that what is replaced is the matched expression, and, in this case, that is only the date (<code class="inlineCode">1.06.2023</code>). This substring is replaced with another string formed of all the parts of the initial string.</p>
<h2 class="heading-2" id="_idParaDest-157">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Verifying the format of a string using regular expressions</em>, to familiarize yourself with the C++ library support for working with regular expressions</li>
<li class="bulletList"><em class="italic">Parsing the content of a string using regular expressions</em>, to learn how to perform multiple matches of a pattern in a text</li>
</ul>
<h1 class="heading-1" id="_idParaDest-158">Using std::string_view instead of constant string references</h1>
<p class="normal">When <a id="_idIndexMarker311"/>working with strings, temporary objects are created all the time, even if you might not be really aware of it. Many times, these temporary objects are irrelevant and only serve the purpose of copying data from one place to another (for example, from a function to its caller). This represents a performance issue because they require memory allocation and data copying, which should be avoided. For this purpose, the C++17 standard provides a new string class template called <code class="inlineCode">std::basic_string_view</code>, which represents a non-owning constant reference to a string (that is, a sequence of characters). In this recipe, you will learn when and how you should use this class.</p>
<h2 class="heading-2" id="_idParaDest-159">Getting ready</h2>
<p class="normal">The <code class="inlineCode">string_view</code> class is available in the namespace <code class="inlineCode">std</code> in the <code class="inlineCode">string_view</code> header.</p>
<h2 class="heading-2" id="_idParaDest-160">How to do it...</h2>
<p class="normal">You should use <code class="inlineCode">std::string_view</code> to pass a parameter to a function (or return a value from a function), instead of <code class="inlineCode">std::string const &amp;</code>, unless your code needs to call other functions<a id="_idIndexMarker312"/> that take <code class="inlineCode">std::string</code> parameters (in which case, conversions would be necessary):</p>
<pre class="programlisting code"><code class="hljs-code">std::string_view get_filename(std::string_view str)
{
  auto const pos1 {str.find_last_of('')};
  auto const pos2 {str.find_last_of('.')};
  return str.substr(pos1 + 1, pos2 - pos1 - 1);
}
char const file1[] {R"(c:\test\example1.doc)"};
auto name1 = get_filename(file1);
std::string file2 {R"(c:\test\example2)"};
auto name2 = get_filename(file2);
auto name3 = get_filename(std::string_view{file1, 16});
</code></pre>
<h2 class="heading-2" id="_idParaDest-161">How it works...</h2>
<p class="normal">Before we look at how the new string type works, let’s consider the following example of a function that is supposed to extract the name of a file without its extension. This is basically how you would write the function from the previous section before C++17:</p>
<pre class="programlisting code"><code class="hljs-code">std::string get_filename(std::string const &amp; str)
{
  auto const pos1 {str.find_last_of('\\')};
  auto const pos2 {str.find_last_of('.')};
  return str.substr(pos1 + 1, pos2 - pos1 - 1);
}
auto name1 = get_filename(R"(c:\test\example1.doc)"); // example1
auto name2 = get_filename(R"(c:\test\example2)");     // example2
if(get_filename(R"(c:\test\_sample_.tmp)").front() == '_') {}
</code></pre>
<div><p class="normal">Note that, in this example, the file separator is <code class="inlineCode">\</code> (backslash), as in Windows. For Linux-based systems, it has to be changed to <code class="inlineCode">/</code> (slash).</p>
</div>
<p class="normal">The <code class="inlineCode">get_filename()</code> function is relatively simple. It takes a constant reference to an <code class="inlineCode">std::string</code> and identifies a substring bounded by the last file separator and the last dot, which basically represents a filename without an extension (and without folder names).</p>
<p class="normal">The<a id="_idIndexMarker313"/> problem with this code, however, is that it creates one, two, or possibly even more temporaries, depending on the compiler optimizations. The function parameter is a constant <code class="inlineCode">std::string</code> reference, but the function is called with a string literal, which means <code class="inlineCode">std::string</code> needs to be constructed from the literal. These temporaries need to allocate and copy data, which is both time- and resource-consuming. In the last example, all we want to do is check whether the first character of the filename is an underscore, but we create at least two temporary string objects for that purpose.</p>
<p class="normal">The <code class="inlineCode">std::basic_string_view</code> class template is intended to solve this problem. This class template is very similar to <code class="inlineCode">std::basic_string</code>, with the two having almost the same interface. The reason for this is that <code class="inlineCode">std::basic_string_view</code> is intended to be used instead of a constant reference to an <code class="inlineCode">std::basic_string</code> without further code changes. Just like with <code class="inlineCode">std::basic_string</code>, there are specializations for all types of standard characters:</p>
<pre class="programlisting code"><code class="hljs-code">typedef basic_string_view&lt;char&gt;     string_view;
typedef basic_string_view&lt;wchar_t&gt;  wstring_view;
typedef basic_string_view&lt;char16_t&gt; u16string_view;
typedef basic_string_view&lt;char32_t&gt; u32string_view;
</code></pre>
<p class="normal">The <code class="inlineCode">std::basic_string_view</code> class template defines a reference to a constant contiguous sequence of characters. As the name implies, it represents a view and cannot be used to modify the reference sequence of characters. An <code class="inlineCode">std::basic_string_view</code> object has a relatively small size because all it needs is a pointer to the first character in the sequence and the length. It can be constructed not only from an <code class="inlineCode">std::basic_string</code> object but also from a pointer and a length, or from a null-terminated sequence of characters (in which case, it will require an initial traversal of the string in order to find the length). Therefore, the <code class="inlineCode">std::basic_string_view</code> class template can also be used as a common interface for multiple types of strings (as long as data only needs to be read). On the other hand, converting from an <code class="inlineCode">std::basic_string_view</code> to an <code class="inlineCode">std::basic_string</code> is not possible.</p>
<p class="normal">You must explicitly construct an <code class="inlineCode">std::basic_string</code> object from a <code class="inlineCode">std::basic_string_view</code>, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">std::string_view sv{ "demo" };
std::string s{ sv };
</code></pre>
<p class="normal">Passing <code class="inlineCode">std::basic_string_view</code> to functions and returning <code class="inlineCode">std::basic_string_view</code> still creates temporaries of this type, but these are small-sized objects on the stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore, they should incur fewer performance costs than allocating heap space and copying data.</p>
<div><p class="normal">Note that all major compilers provide an implementation of <code class="inlineCode">std::basic_string</code>, which includes a small string optimization. Although the implementation details are different, they typically rely on having a statically allocated buffer of a number of characters (16 for VC++ and GCC 5 or newer) that does not involve heap operations, which are only required when the size of the string exceeds that number of characters.</p>
</div>
<p class="normal">In<a id="_idIndexMarker314"/> addition to the methods that are identical to those available in <code class="inlineCode">std::basic_string</code>, the <code class="inlineCode">std::basic_string_view</code> has two more:</p>
<ul>
<li class="bulletList"><code class="inlineCode">remove_prefix()</code>: Shrinks the view by incrementing the start with <em class="italic">N</em> characters and decrementing the length with <em class="italic">N</em> characters</li>
<li class="bulletList"><code class="inlineCode">remove_suffix()</code>: Shrinks the view by decrementing the length with <em class="italic">N</em> characters</li>
</ul>
<p class="normal">The two member functions are used in the following example to trim spaces from an <code class="inlineCode">std::string_view</code>, both at the beginning and the end. The implementation of the function first looks for the first element that is not a space and then for the last element that is not a space. Then, it removes from the end everything after the last non-space character, and from the beginning, everything until the first non-space character. The function returns the new view, trimmed at both ends:</p>
<pre class="programlisting code"><code class="hljs-code">std::string_view trim_view(std::string_view str)
{
  auto const pos1{ str.find_first_not_of(" ") };
  auto const pos2{ str.find_last_not_of(" ") };
  str.remove_suffix(str.length() - pos2 - 1);
  str.remove_prefix(pos1);
  return str;
}
auto sv1{ trim_view("sample") };
auto sv2{ trim_view("  sample") };
auto sv3{ trim_view("sample  ") };
auto sv4{ trim_view("  sample  ") };
std::string s1{ sv1 };
std::string s2{ sv2 };
std::string s3{ sv3 };
std::string s4{ sv4 };
</code></pre>
<p class="normal">When <a id="_idIndexMarker315"/>using <code class="inlineCode">std::basic_string_view</code>, you must be aware of two things: you cannot change the underlying data referred to by a view and you must manage the lifetime of the data, as the view is a non-owning reference.</p>
<h2 class="heading-2" id="_idParaDest-162">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating a library of string helpers</em>, to see how to create useful text utilities that are not directly available in the standard library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-163">Formatting and printing text with std::format and std::print</h1>
<p class="normal">The C++ language has two ways of formatting text: the <code class="inlineCode">printf</code> family of functions and the I/O streams library. The <code class="inlineCode">printf</code> functions are inherited from C and provide a separation of the formatting text and the arguments. The streams library provides safety and extensibility and is usually recommended over <code class="inlineCode">printf</code> functions, but is, in general, slower. The C++20 standard proposes a new formatting library alternative for output formatting, which <a id="_idIndexMarker316"/>is similar in form to <code class="inlineCode">printf</code> but safe and extensible and is intended to complement the existing streams library. In this recipe, we will learn how to use the new functionalities instead of the <code class="inlineCode">printf</code> functions or the streams library.</p>
<h2 class="heading-2" id="_idParaDest-164">Getting ready</h2>
<p class="normal">The new formatting<a id="_idIndexMarker317"/> library is available in the <code class="inlineCode">&lt;format&gt;</code> header. You must include this header for the following samples to work.</p>
<h2 class="heading-2" id="_idParaDest-165">How to do it...</h2>
<p class="normal">The <code class="inlineCode">std::format()</code> function formats its arguments according to the provided formatting<a id="_idIndexMarker318"/> string. You <a id="_idIndexMarker319"/>can use it as follows:</p>
<ul>
<li class="bulletList">Provide empty replacement fields, represented by <code class="inlineCode">{}</code>, in the format string for each argument:
        <pre class="programlisting code"><code class="hljs-code">auto text = std::format("{} is {}", "John", 42);
</code></pre>
</li>
<li class="bulletList">Specify the 0-based index of each argument in the argument list inside the replacement field, such as <code class="inlineCode">{0}</code>, <code class="inlineCode">{1}</code>, and so on. The order of the arguments is not important, but the index must be valid:
        <pre class="programlisting code"><code class="hljs-code">auto text = std::format("{0} is {1}", "John", 42);
</code></pre>
</li>
<li class="bulletList">Control the output text with format specifiers provided in the replacement field after a colon (<code class="inlineCode">:</code>). For basic and string types, this is a standard format specification. For chrono types, this is a chrono format specification:
        <pre class="programlisting code"><code class="hljs-code">auto text = std::format("{0} hex is {0:08X}", 42);
auto now = std::chrono::system_clock::now();
auto date = std::format("Today is {:%Y-%m-%d}", now);
std::cout &lt;&lt; date &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<p class="normal">You can also write the arguments in an out format using an iterator with either <code class="inlineCode">std::format_to()</code> or <code class="inlineCode">std::format_to_n()</code>, as follows:</p>
<ul>
<li class="bulletList">Write to a buffer, such as an <code class="inlineCode">std::string</code> or <code class="inlineCode">std::vector&lt;char&gt;</code>, using <code class="inlineCode">std::format_n()</code> and using the <code class="inlineCode">std::back_inserter()</code> helper function:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;char&gt; buf;
std::format_to(std::back_inserter(buf), "{} is {}", "John", 42);
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::formatted_size()</code> to retrieve the number of characters necessary to store the formatted representation of the arguments:
        <pre class="programlisting code"><code class="hljs-code">auto size = std::formatted_size("{} is {}", "John", 42);
std::vector&lt;char&gt; buf(size);
std::format_to(buf.data(), "{} is {}", "John", 42);
</code></pre>
</li>
<li class="bulletList">To limit the number of characters written to the output buffer, you can use <code class="inlineCode">std::format_to_n()</code>, which<a id="_idIndexMarker320"/> is similar to <code class="inlineCode">std::format_to()</code> but<a id="_idIndexMarker321"/> writes, at most, <code class="inlineCode">n</code> characters:
        <pre class="programlisting code"><code class="hljs-code">char buf[100];
auto result = std::format_to_n(buf, sizeof(buf), "{} is {}", "John", 42);
</code></pre>
</li>
</ul>
<p class="normal">In C++23, you <a id="_idIndexMarker322"/>can write formatted text directly to a file stream, such <a id="_idIndexMarker323"/>as the standard output console, using the following functions from the new <code class="inlineCode">&lt;print&gt;</code> header:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::print</code>, to write the arguments according to the format string:
        <pre class="programlisting code"><code class="hljs-code">std::print("The answer is {}", 42);
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::println</code>, to write the arguments according to the format string followed by a new line character (<code class="inlineCode">'\n'</code>):
        <pre class="programlisting code"><code class="hljs-code">std::println("The answer is {}", 42);
std::FILE* stream = std::fopen("demo.txt", "w");
if (stream)
{
   std::println(stream, "The answer is {}", 42);
   std::fclose(stream);
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-166">How it works...</h2>
<p class="normal">The <code class="inlineCode">std::format()</code> function <a id="_idIndexMarker324"/>has multiple overloads. You can specify the format string either as a string view or a wide string view, with the function returning either an <code class="inlineCode">std::string</code> or an <code class="inlineCode">std::wstring</code>. You can also specify, as the first argument, an <code class="inlineCode">std::locale</code>, which is used for locale-specific formatting. The function overloads are all variadic function templates, which means you can specify any number of arguments after the format.</p>
<p class="normal">The format string consists of ordinary characters, replacement fields, and escape sequences. The escape sequences are <code class="inlineCode">{{</code> and <code class="inlineCode">}}</code> and are replaced with <code class="inlineCode">{</code> and <code class="inlineCode">}</code> in the output. A replacement field is provided within curly brackets <code class="inlineCode">{}</code>. It can optionally contain a non-negative number, representing the 0-based index of the argument to be formatted, and a colon (<code class="inlineCode">:</code>), followed by a format specifier. If the format specifier is invalid, an exception of the type <code class="inlineCode">std::format_error</code> is thrown.</p>
<p class="normal">In a similar <a id="_idIndexMarker325"/>manner, <code class="inlineCode">std::format_to()</code> has multiple overloads, just like <code class="inlineCode">std::format()</code>. The difference between these two is that <code class="inlineCode">std::format_to()</code> always takes an iterator to the output buffer as the first argument and returns an iterator past the end of the output range (and not a string as <code class="inlineCode">std::format()</code> does). On the other hand, <code class="inlineCode">std::format_to_n()</code> has one more parameter than <code class="inlineCode">std::format_to()</code>. Its second parameter is a number representing the maximum number of characters to be written to the buffer.</p>
<p class="normal">The following<a id="_idIndexMarker326"/> listing shows the signature of the simplest overload of each of these three function templates:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class... Args&gt;
std::string format(std::string_view fmt, const Args&amp;... args);
template&lt;class OutputIt, class... Args&gt;
OutputIt format_to(OutputIt out,
                   std::string_view fmt, const Args&amp;... args);
template&lt;class OutputIt, class... Args&gt;
std::format_to_n_result&lt;OutputIt&gt;
format_to_n(OutputIt out, std::iter_difference_t&lt;OutputIt&gt; n,
            std::string_view fmt, const Args&amp;... args);
</code></pre>
<p class="normal">When you provide the format string, you can supply argument identifiers (their 0-based index) or omit them. However, it is illegal to use both. If the indexes are omitted in the replacement fields, the arguments are processed in the provided order, and the number of replacement fields must not be greater than the number of supplied arguments. If indexes are provided, they must be valid for the format string to be valid.</p>
<p class="normal">When a format specification is used, then:</p>
<ul>
<li class="bulletList">For basic types and string types, it is considered to be a standard format specification.</li>
<li class="bulletList">For chrono types, it is considered to be a chrono format specification.</li>
<li class="bulletList">For user-defined types, it is defined by a user-defined specialization of the <code class="inlineCode">std::formatter</code> class for the desired type.</li>
</ul>
<p class="normal">The standard format specification is based on the format specification in Python and has the following syntax:</p>
<pre class="programlisting code"><code class="hljs-code">fill-and-align(optional) sign(optional) #(optional) 0(optional) width(optional) precision(optional) L(optional) type(optional)
</code></pre>
<p class="normal">These syntax parts<a id="_idIndexMarker327"/> are briefly described here.</p>
<p class="normal"><code class="inlineCode">fill-and-align</code> is an optional fill character, followed by one of the align options:</p>
<ul>
<li class="bulletList"><code class="inlineCode">&lt;</code>: Forces the field to be left-aligned with the available space.</li>
<li class="bulletList"><code class="inlineCode">&gt;</code>: Forces the field to be right-aligned with the available space.</li>
<li class="bulletList"><code class="inlineCode">^</code>: Forces the field to be centered with the available space. To do so, it will insert n/2 characters to the left and n/2 characters to the right:
        <pre class="programlisting code"><code class="hljs-code">auto t1 = std::format("{:5}", 42);    // "   42"
auto t2 = std::format("{:5}", 'x');   // "x    "
auto t3 = std::format("{:*&lt;5}", 'x'); // "x****"
auto t4 = std::format("{:*&gt;5}", 'x'); // "****x"
auto t5 = std::format("{:*^5}", 'x'); // "**x**"
auto t6 = std::format("{:5}", true);  // "true "
</code></pre>
</li>
</ul>
<p class="normal"><code class="inlineCode">sign</code>, <code class="inlineCode">#</code>, and <code class="inlineCode">0</code> are only<a id="_idIndexMarker328"/> valid when a number (either an integer or a floating-point) is used. The sign can be one of:</p>
<ul>
<li class="bulletList"><code class="inlineCode">+</code>: Specifies that the sign must be used for both negative and positive numbers</li>
<li class="bulletList"><code class="inlineCode">-</code>: Specifies that the sign must be used only for negative numbers (which is the implicit behavior)</li>
<li class="bulletList">A space: Specifies that the sign must be used for negative numbers and that a leading space must be used for non-negative numbers:
        <pre class="programlisting code"><code class="hljs-code">auto t7 = std::format("{0:},{0:+},{0:-},{0: }", 42);
// "42,+42,42, 42"
auto t8 = std::format("{0:},{0:+},{0:-},{0: }", -42);
// "-42,-42,-42,-42"
</code></pre>
</li>
</ul>
<p class="normal">The <code class="inlineCode">#</code> symbol causes the alternate form to be used. This can be one of the following:</p>
<ul>
<li class="bulletList">For integral types, when binary, octal, or hexadecimal representation is specified, the alternate form adds the prefix <code class="inlineCode">0b</code>, <code class="inlineCode">0</code>, or <code class="inlineCode">0x</code> to the output.</li>
<li class="bulletList">For floating-point types, the alternate form causes a decimal-point character to always be present in the formatted value, even if no digits follow it. In addition, when <code class="inlineCode">g</code> or <code class="inlineCode">G</code> are used, the trailing zeros are not removed from the output.</li>
</ul>
<p class="normal">The digit <code class="inlineCode">0</code> specifies that leading zeros should be outputted to the field width, except when the value of a floating-point type is infinity or <code class="inlineCode">NaN</code>. When present alongside an align option, the specifier <code class="inlineCode">0</code> is ignored:</p>
<pre class="programlisting code"><code class="hljs-code">auto t9  = std::format("{:+05d}", 42); // "+0042"
auto t10 = std::format("{:#05x}", 42); // "0x02a"
auto t11 = std::format("{:&lt;05}", -42); // "-42  "
</code></pre>
<p class="normal"><code class="inlineCode">width</code> specifies <a id="_idIndexMarker329"/>the minimum field width and can be either a positive decimal number or a nested replacement field. The <code class="inlineCode">precision</code> field indicates the precision for<a id="_idIndexMarker330"/> floating-point types or, for string types, how many characters will be used from the string. It is specified with a dot (<code class="inlineCode">.</code>), followed by a non-negative decimal number or a nested replacement field.</p>
<p class="normal">Locale-specific formatting is specified with the uppercase <code class="inlineCode">L</code> and causes the locale-specific form to be used. This option is only available for arithmetic types.</p>
<p class="normal">The optional <code class="inlineCode">type</code> determines how the data will be presented in the output. The available string presentation types are shown in the following table:</p>
<table class="table-container" id="table016">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Presentation type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Strings</p>
</td>
<td class="table-cell">
<p class="normal">none, <code class="inlineCode">s</code></p>
</td>
<td class="table-cell">
<p class="normal">Copies the string to the output.</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="7">
<p class="normal">Integral types</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">b</code></p>
</td>
<td class="table-cell">
<p class="normal">Binary format with 0b as a prefix.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">B</code></p>
</td>
<td class="table-cell">
<p class="normal">Binary format with 0B as a prefix.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">C</code></p>
</td>
<td class="table-cell">
<p class="normal">Character format. Copies the value to the output as it was a character type.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">none or <code class="inlineCode">d</code></p>
</td>
<td class="table-cell">
<p class="normal">Decimal format.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">O</code></p>
</td>
<td class="table-cell">
<p class="normal">Octal format with 0 as a prefix (unless the value is 0).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">x</code></p>
</td>
<td class="table-cell">
<p class="normal">Hexadecimal format with 0x as a prefix.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">X</code></p>
</td>
<td class="table-cell">
<p class="normal">Hexadecimal format with 0X as a prefix.</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal"><code class="inlineCode">char</code> and <code class="inlineCode">wchar_t</code></p>
</td>
<td class="table-cell">
<p class="normal">none or <code class="inlineCode">c</code></p>
</td>
<td class="table-cell">
<p class="normal">Copies the character to the output.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">b</code>, <code class="inlineCode">B</code>, <code class="inlineCode">c</code>, <code class="inlineCode">d</code>, <code class="inlineCode">o</code>, <code class="inlineCode">x</code>, <code class="inlineCode">X</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer presentation types.</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal"><code class="inlineCode">bool</code></p>
</td>
<td class="table-cell">
<p class="normal">none or <code class="inlineCode">s</code></p>
</td>
<td class="table-cell">
<p class="normal">Copies true or false as a textual representation (or their local-specific form) to the output.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">b</code>, <code class="inlineCode">B</code>, <code class="inlineCode">c</code>, <code class="inlineCode">d</code>, <code class="inlineCode">o</code>, <code class="inlineCode">x</code>, <code class="inlineCode">X</code></p>
</td>
<td class="table-cell">
<p class="normal">Integer presentation types.</p>
</td>
</tr>
<tr>
<td class="table-cell" rowspan="7">
<p class="normal">Floating-point</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a</code></p>
</td>
<td class="table-cell">
<p class="normal">Hexadecimal representation. Same as if calling <code class="inlineCode">std::to_chars(first, last, value, std::chars_format::hex, precision)</code> or <code class="inlineCode">std::to_chars(first, last, value, std::chars_format::hex)</code>, depending on whether precision is specified or not.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">A</code></p>
</td>
<td class="table-cell">
<p class="normal">Same as <code class="inlineCode">a</code> except that it uses uppercase letters for digits above 9 and uses P to indicate the exponent.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">e</code></p>
</td>
<td class="table-cell">
<p class="normal">Scientific representation. Produces the output as if calling <code class="inlineCode">std::to_chars(first, last, value, std::chars_format::scientific, precision)</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">E</code></p>
</td>
<td class="table-cell">
<p class="normal">Similar to <code class="inlineCode">e</code> except that it uses <code class="inlineCode">E</code> to indicate the exponent.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">f</code>, <code class="inlineCode">F</code></p>
</td>
<td class="table-cell">
<p class="normal">Fixed representation. Produces the output as if by calling <code class="inlineCode">std::to_chars(first, last, value, std::chars_format::fixed, precision)</code>. When no precision is specified, the default is 6.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">g</code></p>
</td>
<td class="table-cell">
<p class="normal">General floating-point representation. Produces the output as if by calling <code class="inlineCode">std::to_chars(first, last, value, std::chars_format::general, precision)</code>. When no precision is specified, the default is 6.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">G</code></p>
</td>
<td class="table-cell">
<p class="normal">Same as <code class="inlineCode">g</code> except that it uses <code class="inlineCode">E</code> to indicate the exponent.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Pointer</p>
</td>
<td class="table-cell">
<p class="normal">none or <code class="inlineCode">p</code></p>
</td>
<td class="table-cell">
<p class="normal">Pointer representation. Produces the output as if by calling <code class="inlineCode">std::to_chars(first, last, reinterpret_cast&lt;std::uintptr_t&gt;(value), 16)</code> with the prefix <code class="inlineCode">0x</code> added to the output. This is available only when <code class="inlineCode">std::uintptr_t</code> is defined; otherwise, the output is implementation-defined.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.16: The list of available presentation types</p>
<p class="normal">The chrono format <a id="_idIndexMarker331"/>specification has the following form:</p>
<pre class="programlisting code"><code class="hljs-code">fill-and-align(optional) width(optional) precision(optional) chrono-spec(optional)
</code></pre>
<p class="normal">The <code class="inlineCode">fill-and-align</code>, <code class="inlineCode">width</code>, and <code class="inlineCode">precision</code> fields have the same meaning as in the standard format <a id="_idIndexMarker332"/>specification, described previously. The precision is only valid for <code class="inlineCode">std::chrono::duration</code> types when the representation type is a floating-point type. Using it in other cases throws an <code class="inlineCode">std::format_error</code> exception.</p>
<p class="normal">The chrono specification can be empty, in which case the argument is formatted as if by streaming it to an <code class="inlineCode">std::stringstream</code> and copying the result string. Alternatively, it can consist of a series of conversion specifiers and ordinary characters. Some of these format specifiers are presented in the following table:</p>
<table class="table-container" id="table017">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Conversion specifier</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%%</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes a literal <code class="inlineCode">%</code> character.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%n</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes a newline character.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%t</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes a horizontal tab character.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%Y</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the year as a decimal number. If the result is less than four digits, it is left-padded with <code class="inlineCode">0</code> to four digits.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%m</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the month as a decimal number (January is <code class="inlineCode">01</code>). If the result is a single digit, it is prefixed with <code class="inlineCode">0</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%d</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the day of the month as a decimal number. If the result is a single decimal digit, it is prefixed with <code class="inlineCode">0</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%w</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the weekday as a decimal number (<code class="inlineCode">0</code>-<code class="inlineCode">6</code>), where Sunday is <code class="inlineCode">0</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%D</code></p>
</td>
<td class="table-cell">
<p class="normal">Equivalent to <code class="inlineCode">%m/%d/%y</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%F</code></p>
</td>
<td class="table-cell">
<p class="normal">Equivalent to <code class="inlineCode">%Y-%m-%d</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%H</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the hour (24-hour clock) as a decimal number. If the result is a single digit, it is prefixed with <code class="inlineCode">0</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%I</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the hour (12-hour clock) as a decimal number. If the result is a single digit, it is prefixed with <code class="inlineCode">0</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%M</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the minute as a decimal number. If the result is a single digit, it is prefixed with <code class="inlineCode">0</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%S</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the second as a decimal number. If the number of seconds is less than 10, the result is prefixed with <code class="inlineCode">0</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%R</code></p>
</td>
<td class="table-cell">
<p class="normal">Equivalent to <code class="inlineCode">%H:%M</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%T</code></p>
</td>
<td class="table-cell">
<p class="normal">Equivalent to <code class="inlineCode">%H:%M:%S</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%X</code></p>
</td>
<td class="table-cell">
<p class="normal">Writes the locale’s time representation.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.17: A list of the most commonly used chrono specifiers</p>
<p class="normal">The complete list of format specifiers for the chrono library can be consulted at <a href="https://en.cppreference.com/w/cpp/chrono/system_clock/formatter">https://en.cppreference.com/w/cpp/chrono/system_clock/formatter</a>.</p>
<p class="normal">Because writing <a id="_idIndexMarker333"/>formatted text to the console or a file stream requires two<a id="_idIndexMarker334"/> operations (formatting text into a string or a vector of characters and then writing that buffer to the output stream), the C++23 standard introduced a couple of new functions to simplify this process. </p>
<p class="normal">The new <code class="inlineCode">std::print</code> and <code class="inlineCode">std::println</code> functions are very similar. The only difference is that <code class="inlineCode">std::println</code> appends a <code class="inlineCode">\n</code> character (new line) after the formatted text. These two functions have two overloads each:</p>
<ul>
<li class="bulletList">One that takes an <code class="inlineCode">std::FILE*</code> as the first argument, representing the output file stream</li>
<li class="bulletList">One that does not have such an argument, and uses the C output stream stdout implicitly</li>
</ul>
<p class="normal">Because of this, the following two calls to <code class="inlineCode">std::println</code> are equivalent:</p>
<pre class="programlisting code"><code class="hljs-code">std::println("The answer is {}", 42);
std::println(stdout, "The answer is {}", 42);
</code></pre>
<p class="normal">Also, the following two calls to <code class="inlineCode">std::print</code> and <code class="inlineCode">std::println</code> have the same result on the standard output stream:</p>
<pre class="programlisting code"><code class="hljs-code">std::println("The answer is {}", 42);
std::print("The answer is {}\n", 42);
</code></pre>
<p class="normal">The format string specification is the same as for <code class="inlineCode">std::format</code> and was presented previously.</p>
<h2 class="heading-2" id="_idParaDest-167">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::format with user-defined types</em>, to learn how to create custom formatting specialization for user-defined types</li>
<li class="bulletList"><em class="italic">Converting between numeric and string types</em>, to learn how to convert between numbers and strings</li>
</ul>
<h1 class="heading-1" id="_idParaDest-168">Using std::format with user-defined types</h1>
<p class="normal">The<a id="_idIndexMarker335"/> C++20 formatting library is <a id="_idIndexMarker336"/>a modern alternative to using <code class="inlineCode">printf</code>-like functions or the I/O streams library, which it actually complements. Although the standard provides default<a id="_idIndexMarker337"/> formatting for basic types, such as integral and floating-point types, <code class="inlineCode">bool</code>, character types, strings, and chrono types, the user can create custom specializations for user-defined types. In this recipe, we will learn how to do that.</p>
<h2 class="heading-2" id="_idParaDest-169">Getting ready</h2>
<p class="normal">You should read the previous recipe, <em class="italic">Formatting and printing text with std::format and std::print</em>, to familiarize yourself with the formatting library.</p>
<p class="normal">In the examples that we’ll be showing here, we will use the following class:</p>
<pre class="programlisting code"><code class="hljs-code">struct employee
{
   int         id;
   std::string firstName;
   std::string lastName;
};
</code></pre>
<p class="normal">In the next section, we’ll introduce the necessary steps to implement to enable text formatting using <code class="inlineCode">std::format()</code> for user-defined types.</p>
<h2 class="heading-2" id="_idParaDest-170">How to do it...</h2>
<p class="normal">To enable formatting using the new formatting library for user-defined types, you must do the following:</p>
<ul>
<li class="bulletList">Define a specialization of the <code class="inlineCode">std::formatter&lt;T, CharT&gt;</code> class in the <code class="inlineCode">std</code> namespace.</li>
<li class="bulletList">Implement the <code class="inlineCode">parse()</code> method to parse the portion of the format string corresponding to the current argument. If the class inherits from another formatter, then this method can be omitted.</li>
<li class="bulletList">Implement the <code class="inlineCode">format()</code> method to format the argument and write the output via <code class="inlineCode">format_context</code>.</li>
</ul>
<p class="normal">For the <code class="inlineCode">employee</code> class<a id="_idIndexMarker338"/> listed here, a formatter that formats <code class="inlineCode">employee</code> to the form <code class="inlineCode">[42]</code> <code class="inlineCode">John Doe</code> (that is, <code class="inlineCode">[id] firstName lastName</code>) can be implemented as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;&gt;
struct std::formatter&lt;employee&gt;
{
   constexpr auto parse(format_parse_context&amp; ctx)
 {
      return ctx.begin();
   }
   auto format(employee const &amp; e, format_context&amp; ctx) const 
 {
      return std::format_to(ctx.out(),
                            "[{}] {} {}",
                            e.id, e.firstName, e.lastName);
   }
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-171">How it works...</h2>
<p class="normal">The formatting <a id="_idIndexMarker339"/>library uses the <code class="inlineCode">std::formatter&lt;T, CharT&gt;</code> class template to define formatting rules for a given type. Built-in types, string types, and chrono types have formatters provided by the library. These are implemented as specializations of the <code class="inlineCode">std::formatter&lt;T, CharT&gt;</code> class template.</p>
<p class="normal">This class has two methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">parse()</code>, which takes a single argument of the type <code class="inlineCode">std::basic_format_parse_context&lt;CharT&gt;</code> and parses the format’s specification for the type <code class="inlineCode">T</code>, provided by the parse context. The result of the parsing is supposed to be stored in member fields of the class. If the parsing succeeds, this function should return a value of the type <code class="inlineCode">std::basic_format_parse_context&lt;CharT&gt;::iterator</code>, which represents the end of the format specification. If the parsing fails, the function should throw an exception of the type <code class="inlineCode">std::format_error</code> to provide details about the error.</li>
<li class="bulletList"><code class="inlineCode">format()</code>, which takes two arguments, with the first being the object of the type <code class="inlineCode">T</code> to format and the second being a formatting context object of the type <code class="inlineCode">std::basic_format_context&lt;OutputIt, CharT&gt;</code>. This function should write the output to <code class="inlineCode">ctx.out()</code> according to the desired specifiers (which could be something implicit or the result of parsing the format specification). The function must return a value of the type <code class="inlineCode">std::basic_format_context&lt;OutputIt, CharT&gt;::iterator</code>, representing the end of the output.</li>
</ul>
<p class="normal">In the<a id="_idIndexMarker340"/> implementation shown in the previous section, the <code class="inlineCode">parse()</code> function does not do anything other than return an iterator <a id="_idIndexMarker341"/>representing the beginning of the format specification. The formatting is always done by printing the employee identifier between square brackets, followed by the first name and the last name, such as in <code class="inlineCode">[42] John Doe</code>. An attempt to use a format specifier would result in a compile-time error:</p>
<pre class="programlisting code"><code class="hljs-code">employee e{ 42, "John", "Doe" };
auto s1 = std::format("{}", e);   // [42] John Doe
auto s2 = std::format("{:L}", e); // error
</code></pre>
<p class="normal">If you want your user-defined types to support format specifiers, then you must properly implement the <code class="inlineCode">parse()</code> method. To show how this can be done, we will support the several specifiers for the <code class="inlineCode">employee</code> class, as defined in the following table:</p>
<table class="table-container" id="table018">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Specifier</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Example</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">L</code></p>
</td>
<td class="table-cell">
<p class="normal">Lexicographic order</p>
</td>
<td class="table-cell">
<p class="normal">[42] Doe, John</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">l</code></p>
</td>
<td class="table-cell">
<p class="normal">Lowercase</p>
</td>
<td class="table-cell">
<p class="normal">[42] john doe</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">u</code></p>
</td>
<td class="table-cell">
<p class="normal">Uppercase</p>
</td>
<td class="table-cell">
<p class="normal">[42] JOHN DOE</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.18: Specifiers supported for the user-defined employee class</p>
<p class="normal">When the <code class="inlineCode">L</code> specifier is used, the <code class="inlineCode">employee</code> is formatted with the identifier in square brackets, followed by the last name, a comma, and then the first name, such as in <em class="italic">[42] Doe, John</em>. A combination of these specifiers is also possible. For instance <code class="inlineCode">{:Ll}</code> would produce <em class="italic">[42] doe, john</em>, while <code class="inlineCode">{:uL}</code> would produce <em class="italic">[42] DOE, JOHN</em>.</p>
<p class="normal">The specialization of the <code class="inlineCode">std::formatter</code> class for the employee class that implements the defined <a id="_idIndexMarker342"/>requirements may look as<a id="_idIndexMarker343"/> follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;&gt;
struct std::formatter&lt;employee&gt;
{
   constexpr auto parse(std::format_parse_context&amp; ctx)
 {
      auto iter = begin(ctx);
      while(iter != ctx.end() &amp;&amp; *iter != '}')
      {
         switch (*iter)
         {
         case 'L': lexicographic_order = true; break;
         case 'u': uppercase = true; break;
         case 'l': lowercase = true; break;
         }
         ++iter;
      }
      return iter;
   }
   auto format(employee const&amp; e, std::format_context&amp; ctx) const
 {
      if (lexicographic_order)
         return std::format_to(ctx.out(), 
                               "[{}] {}, {}", 
                               e.id, 
                               text_format(e.lastName), 
                               text_format(e.firstName));
      return std::format_to(ctx.out(), 
                            "[{}] {} {}", 
                            e.id, 
                            text_format(e.firstName),
                            text_format(e.lastName));
   }
private:
   bool lexicographic_order = false;
   bool uppercase = false;
   bool lowercase = false;
   
   constexpr std::string text_format(std::string text) const
 {
      if(lowercase)
         std::transform(text.begin(), text.end(), text.begin(),                         ::tolower);
      else if(uppercase)
         std::transform(text.begin(), text.end(), text.begin(),                         ::toupper);
      return text;
   }
};
</code></pre>
<p class="normal">The <code class="inlineCode">parse()</code> function <a id="_idIndexMarker344"/>receives the parsing context that<a id="_idIndexMarker345"/> includes the format string. The <code class="inlineCode">begin()</code> iterator points to the first element of the format string after the format delimiter (<code class="inlineCode">:</code>). An example is provided in the next table:</p>
<table class="table-container" id="table019">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Format</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">begin() iterator</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Range</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">"{}"</code></p>
</td>
<td class="table-cell">
<p class="normal">Equal to <code class="inlineCode">end()</code></p>
</td>
<td class="table-cell">
<p class="normal">Empty</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">"{0}"</code></p>
</td>
<td class="table-cell">
<p class="normal">Equal to <code class="inlineCode">end()</code></p>
</td>
<td class="table-cell">
<p class="normal">Empty</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">"{0:L}"</code></p>
</td>
<td class="table-cell">
<p class="normal">Points to <code class="inlineCode">'L'</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">L}</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">"{:L}"</code></p>
</td>
<td class="table-cell">
<p class="normal">Points to <code class="inlineCode">'L'</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">L}</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">"{:Lul}"</code></p>
</td>
<td class="table-cell">
<p class="normal">Points to <code class="inlineCode">'L'</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">Lul}</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 2.19: Examples of the content of the parsing context</p>
<p class="normal">With this defined, the preceding sample code (using the <code class="inlineCode">{:L}</code> format argument) would work. Moreover, various combinations of the <code class="inlineCode">L</code>, <code class="inlineCode">u</code>, and <code class="inlineCode">l</code> specifiers can be used, as exemplified next:</p>
<pre class="programlisting code"><code class="hljs-code">auto s1 = std::format("{}", e);     // [42] John Doe
auto s2 = std::format("{:L}", e);   // [42] Doe, John
auto s3 = std::format("{:u}", e);   // [42] JOHN DOE
auto s4 = std::format("{:lL}", e);  // [42] doe, john
// uppercase ignored when lowercase also specified
auto s5 = std::format("{:ulL}", e); // [42] doe, john
</code></pre>
<p class="normal">Multiple usage of the same argument is also possible, as in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">auto s6 = std::format("{0} = {0:L}", e);
// [42] John Doe = [42] Doe, John
</code></pre>
<p class="normal">However, using other format specifiers (such as <code class="inlineCode">A</code>, for example) would not work; the specifier is simply ignored and the default formatting is used:</p>
<pre class="programlisting code"><code class="hljs-code">auto s7 = std::format("{:A}", e);   // [42] John Doe
</code></pre>
<p class="normal">If you <a id="_idIndexMarker346"/>do not need to parse the format <a id="_idIndexMarker347"/>specifier in order to support various options, you could entirely omit the <code class="inlineCode">parse()</code> method. However, in order to do so, your <code class="inlineCode">std::formatter</code> specialization must derive from another <code class="inlineCode">std::formatter</code> class. An implementation is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;&gt;
struct std::formatter&lt;employee&gt; : std::formatter&lt;char const*&gt;
{
   auto format(employee const&amp; e, std::format_context&amp; ctx) const
 {
      return std::format_to(ctx.out(), "[{}] {} {}",
                            e.id, e.firstName, e.lastName);
   }
};
</code></pre>
<p class="normal">This specialization for the <code class="inlineCode">employee</code> class is equivalent to the first implementation shown earlier in the <em class="italic">How to do it...</em> section.</p>
<h2 class="heading-2" id="_idParaDest-172">There’s more…</h2>
<p class="normal">The C++23 standard introduces a new concept called <code class="inlineCode">std::formattable</code> (also in the <code class="inlineCode">&lt;format&gt;</code> header), which specifies that a type is formattable. That means that a specialization of <code class="inlineCode">std::format</code> is available for a type <code class="inlineCode">T</code> and that it defines the <code class="inlineCode">parse()</code> and <code class="inlineCode">format()</code> member functions, as described in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-173">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Formatting text with std::format</em>, to get a good introduction to the new C++20 text formatting library</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_02.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>