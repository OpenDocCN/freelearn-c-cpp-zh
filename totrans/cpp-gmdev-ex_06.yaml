- en: Creating Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will make our project more flexible by adding game objects
    as classes instead of adding them to the `source.cpp` file. In this case, we will
    use classes to make the main character and the enemy. We will create a new rocket
    class that the player will be able to shoot at the enemy. We will then spawn enemies
    at regular intervals along with new rockets when we press a button. We will finally
    check for a collision between the rocket and the enemy and, accordingly, remove
    the enemy from the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting afresh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `Hero` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `Enemy` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `Rocket` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding rockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting afresh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to create a new class for the main character, we will remove
    the code pertaining to the player character in the main file. Let's learn how
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove all player-related code from the `main.cpp` file. After doing this, the
    file should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Hero class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now move on to create a new class by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the project in the solution explorer and then right-click and select
    Add | Class. In this class name, specify the name as `Hero`. You will see the
    `.h` and `.cpp` file sections automatically populated as `Hero.h` and `Hero.cpp`
    respectively. Click on Ok.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Hero.h` file, add the SFML graphics header and create the `Hero` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Hero` class, we will create the methods and variables that will be
    required by the class. We will also create some public properties that will be
    accessible outside the class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the constructor and destructor, which will be respectively called
    when an object is created and destroyed. We add an `init` function to pass a texture
    name, spawn the player, and specify a mass. We are specifying a mass here because
    we will be creating some very basic physics so that when we hit the jump button,
    the player will jump up and land back down on their feet.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `update`, `jump`, and `getSprite` functions will update the
    player position, make the player jump, and get the sprite of the player that is
    used for depicting the player character respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these `public` variables, we will also need some `private` variables
    that can only be accessed within the class. Add these in the `Hero` class, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the `private` section, we create variables for `texture`, `sprite`, and `position`
    so that we can set these values locally. We have the `int` variable called `jumpCount`
    so that we can check the number of times the player character has jumped. This
    is needed because the player can sometimes double jump, which is something we
    don't want.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need the `float` variables to store the player's mass, the velocity
    when they jump, and the gravitational force when they fall back to the ground,
    which is a constant. The `const` keyword tells the program that it is a constant
    and under no circumstance should the value be made changeable.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we add a `bool` value to check whether the player is on the ground.
    Only when the player is on the ground can they start jumping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `Hero.cpp` file, we will implement the functions that we added
    in the `.h` file. At the top of the `.cpp` file, include the `Hero.h` file and
    then add the constructor and destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `::` symbol represents the scope resolution operator. Functions that have
    the same name can be defined in two different classes. In order to access the
    methods of a particular class, the scope resolution operator is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `Hero` function is scoped to the `Hero` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will set up the `init` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We set the position and mass to the local variable and set the grounded state
    to `false`. Then, we set the texture by calling `loadFromFile` and passing in
    the string of the texture name to it. The `c_str()` phrase returns a pointer to
    an array that contains a null-terminated sequence of characters (that is, a `C`
    string) representing the current value of the `string` object ([http://www.cplusplus.com/reference/string/string/c_str/](http://www.cplusplus.com/reference/string/string/c_str/)).
    We then set the sprite texture, position, and the origin of the sprite itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we add the `update` function where we implement the logic for updating
    the player position. The player''s character cannot move left or right; instead,
    it can only move up, which is the *y* direction. When an initial velocity is applied,
    the player will jump up and then start falling down because of gravity. Add the
    `update` function to update the position of the hero, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the velocity is applied to the character, the player will initially go
    up because of the force, but will then start coming down because of gravity. The
    resulting velocity acts in the downward direction, and is calculated by the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Velocity = Acceleration × Time*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We multiply the acceleration by the mass so that the player falls faster. To
    calculate the distance moved vertically, we use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Distance = Velocity × Time*'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we calculate the distance moved between the previous and the current frame.
    We then set the position of the sprite based on the position that we calculated.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a condition to check whether the player is at one-fourth of the
    distance from the bottom of the screen. We multiply this by `768`, which is the
    height of the window, and then multiply it by `.75f`, at which point the player
    is considered to be on the ground. If that condition is satisfied, we set the
    position of the player, set the resulting velocity to `0`, set the grounded Boolean
    to `true`, and, finally, reset the jump counter to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to make the player jump, we call the `jump` function, which takes
    an initial velocity. We will now add the `jump` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first check whether `jumpCount` is less than `2` as we only want the
    player to jump twice. If `jumpCount` is less than `2`, then increase the `jumpCount`
    value by `1`, set the initial velocity, and set the grounded Boolean to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the `getSprite` function, which simply gets the current sprite,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Congrats! We now have our `Hero` class ready. Let''s use it in the `source.cpp`
    file by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include `Hero.h` at the top of the `main.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add an instance of the `Hero` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init` function, initialize the `Hero` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the texture picture; to do so, set the position to be at `.25`
    (or 25%) from the left of the screen and center it along the `y` axis. We also
    set the mass as `200`, as our character is quite chubby.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want the player to jump when we press the up arrow key. Therefore,
    in the `updateInput` function, while polling for window events, we add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check whether a key was pressed by the player. If a key is pressed
    and the button is the up arrow on the keyboard, then we call the `hero.jump` function
    and pass in an initial velocity value of `750`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `update` function, we call the `hero.update` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `draw` function, we draw the hero sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the game. When the player is on the ground, press the up arrow
    button on the keyboard to see the player jump. When the player is in the air,
    press the jump button again and you will see the player jump again in midair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af75e5e7-b61e-49ac-ba1c-7c5fdde8c175.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Enemy class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The player character looks very lonely. She is ready to cause some mayhem,
    but there is nothing to shoot right now. Let''s add some enemies to solve this
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: The enemies will be created using an enemy class; let's create a new class and
    call it `Enemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just like the `Hero` class, the `Enemy` class will have a `.h` file and a `.cpp`
    file. In the `Enemy.h` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Enemy` class, just like the `Hero` class, also has a constructor
    and destructor. Additionally, it has an `init` function that takes in the texture
    and position; however, instead of mass, it takes in a float variable that will
    be used to set the initial velocity of the enemy. The enemy won't be affected
    by gravity and will only spawn from the right of the screen and move toward the
    left of the screen. There are also `update` and `getSprite` functions; since the
    enemy won't be jumping, there won't be a `jump` function. Lastly, in the private
    section, we create local variables for texture, sprite, position, and speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Enemy.cpp` file, we add the constructor, destructor, `init`, `update`,
    and `getSprite` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to include `Enemy.h` at the top of the main function. We then add
    the constructor and destructor. In the `init` function, we set the local speed
    and position values. Next, we load `Texture` from the file and set the texture,
    position, and origin of the enemy sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` and `getSprite` functions, we update the position and get the
    enemy sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have our `Enemy` class ready. Let's now see how we can use it in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `main.cpp` class, include the `Enemy` header file. Since we want more
    than one enemy instance, we need to add a vector called `enemies` and then add
    all the newly-created enemies to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of the following code, the `vector` phrase has absolutely nothing
    to do with math, but rather with a list of objects. In fact, it is like an array
    in which we can store multiple objects. Vectors are used instead of an array because
    vectors are dynamic in nature, so it makes it easier to add and remove objects
    from the list (unlike an array, which, by comparison, is a static list). Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include `<vector>` in the `main.cpp` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a new variable called `enemies` of the `vector` type, which will
    store the `Enemy` data type in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a vector of a certain object type, you use the `vector` keyword,
    and inside the arrow brackets, specify the data type that the vector will hold,
    and then specify a name for the vector you have created. In this way, we can create
    a new function called `spawnEnemy()` and add a prototype for it at the top of
    the main function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When any function is written below the main function, the main function will
    not be aware that such a function exists. Therefore, a prototype will be created
    and placed above the main function. This means that the function can now be implemented
    below the main function—essentially, the prototype tells the main function that
    there is a function that will be implemented below it, and so to keep a lookout
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we want the enemy to spawn from the right of the screen, but we also want
    the enemy to spawn at either the same height as the player, slightly higher than
    the player, or much higher than the player, so that the player will have to use
    a single jump or a double jump to attack the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we add some randomness to the game to make it less predictable.
    For this, we add the following line of code underneath the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `srand` phrase is a pseudorandom number that is initialized by passing a
    seed value. In this case, we are passing in the current time as a seed value.
  prefs: []
  type: TYPE_NORMAL
- en: For each seed value, a series of numbers will be generated. If the seed value
    is always the same, then the same series of numbers will be generated. That is
    why we pass in the time value—so that the sequence of numbers that is generated
    will be different each time. We can get the next random number in the series by
    calling the `rand` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the `spawnEnemy` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first get a random number—this will create a new random number from
    `0` to `2` because of the modulo operator while getting the random location. So
    the value of `randLoc` will either be `0`, `1`, or `2` each time the function
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: A new `enemyPos` variable is created that will be assigned depending upon the
    `randLoc` value. We will also set the speed of the enemy depending on the `randLoc`
    value; for this, we create a new float called `speed`, which we will assign later.
    We then create a `switch` statement that takes in the `randLoc` value—this enables
    the random location to spawn the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending upon the scenario, we can set the `enemyPosition` variable and the
    `speed` of the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: When `randLoc` is `0`, the enemy spawns from the bottom and moves with a speed
    of `-400`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `randLoc` is `1`, the enemy spawns from the middle of the screen and moves
    at a speed of `-500`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the value of `randLoc` is `2`, then the enemy spawns from the top of the
    screen and moves at the faster speed of `-650`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `randLoc` is none of these values, then a message is printed out saying that
    the value of *y* is incorrect, and instead of breaking, we return to make sure
    that the enemy doesn't spawn in a random location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To print out the message to the console, we can use the `printf` function, which
    takes a string value. At the end of the string, we specify `\n`; this is a keyword
    to tell the compiler that it is the end of the line, and whatever is written after
    needs to be put in a new line, similar to when calling `std::cout`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know the position and speed, we can then create the enemy object itself
    and initialize it. Note that the enemy is created as a pointer; otherwise, the
    reference to the texture is lost and the texture won't display when the enemy
    is spawned. Additionally, when we create the enemy as a raw pointer with a new
    keyword, the system allocates memory, which we will have to delete later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the enemy is created, we add it to the `enemies` vector by calling the
    `push` function of the vectors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the enemy to spawn automatically at regular intervals. For this, we
    create two new variables to keep track of the current time and spawn a new enemy
    every `1.125` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create two new variables of the `float` type, called `currentTime` and
    `prevTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `update` function, after updating the `hero` function, add the
    following lines of code in order to create a new enemy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, we increment the `currentTime` variable. This variable will begin increasing
    as soon as the game starts so that we can track how long it has been since we
    started the game. Next, we check whether the current time is greater than or equal
    to the previous time plus `1.125` seconds, as that is when we want the new enemy
    to spawn. If it is `true`, then we call the `spawnEnemy` function, which will
    create a new enemy. We also set the previous time as equal to the current time
    so that we know when the last enemy was spawned. Good! So, now that we have enemies
    spawning in the game, we can `update` the enemies and also `draw` them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` function, we also create a `for` loop to update the enemies
    and delete the enemies once they go beyond the left of the screen. To do this,
    we add the following code to the `update` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is where the use of vectors is really helpful. With vectors, we are able
    to add, delete, and insert elements in the vector. In the example here, we get
    the reference of the enemy at the location index of `i` in the vector. If that
    enemy goes offscreen and needs to be deleted, then we can just use the `erase`
    function and pass the location index from the beginning of the vector to remove
    the enemy at that index. When we reset the game, we also delete the local reference
    of the enemy we created. This will also free the memory space that was allocated
    when we created the new enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `draw` function, we go through each of the enemies in a `for...each`
    loop and draw them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use the `for...each` loop to go through all the enemies, since the `getSprite`
    function needs to be called on all of them. Interestingly, we didn't use `for...each`
    when we had to update the enemies because with the `for` loop, we can simply use
    the index of the enemy if we have to delete it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the `Enemy.png` file to the `Assets/graphics` folder. Now, when
    you run the game, you will see enemies spawning at different heights and moving
    toward the left of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d000619-b80f-4cdd-9aa3-7c05f5092e44.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Rocket class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game has enemies in it now, but the player still can''t shoot at them.
    Let''s create some rockets so that these can be launched from the player''s bazooka
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project, create a new class called `Rocket`. As you can see from the
    following code block, the `Rocket.h` class is very similar to the `Enemy.h` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `public` section contains the `init`, `update`, and `getSprite` functions.
    The `init` function takes in the name of the texture to load, the position to
    set, and the speed at which the object is initialized. The `private` section has
    local variables for the `texture`, `sprite`, `position`, and `speed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Rocket.cpp` file, we add the constructor and destructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the `init` function, we set the sp`e`ed and `position` variables. Then, we
    set the `texture` variable and initialize the sprite with the `texture` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set the `position` variable and origin of the sprite, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `update` function, the object is moved according to the `speed` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getSprite` function returns the current sprite, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Adding rockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created the rockets, let''s learn how to add them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.cpp` file, we include the `Rocket.h` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a new vector of `Rocket` called `rockets`, which takes in `Rocket`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `update` function, after we have updated all the enemies, we update
    all the rockets. We also delete the rockets that go beyond the right of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we draw all the rockets with the `draw` function by going through
    each rocket in the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can actually shoot the rockets. In the `main.cpp`, class, create a new
    function called `shoot()` and add a prototype for it at the top of the main function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `shoot` function, we will add the functionality to shoot the rockets.
    We will spawn new rockets and push them back to the `rockets` vector. You can
    add the `shoot` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When this function is called, it creates a new `Rocket` and initializes it with
    the `Rocket.png` file, sets the position of it as equal to the position of the
    hero sprite, and then sets the velocity to `400.0f`. The rocket is then added
    to the `rockets` vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `updateInput` function, add the following code so that when the
    down arrow key is pressed, the `shoot` function is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to place the `rocket.png` file in the `assets` folder. Now, when
    you run the game and press the down arrow key, a rocket is fired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f55476be-9e97-4fe2-9e6c-c0d5afdd0fc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the final section of this chapter, let''s add some collision detection
    so that the rocket actually kills an enemy when they `both` come into contact
    with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `checkCollision`, and then create a prototype
    for it at the top of the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two sprites so that we can check the intersection of one
    with the other. Add the following code for the function in the same place that
    we added the `shoot` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Inside this `checkCollision` function, we create two local variables of the
    `FloatRect` type. We then assign the `GlobalBounds` of the sprites to each `FloatRect`
    variable named `shape1` and `shape2`. The `GlobalBounds` gets the rectangular
    region of the sprite that the object is spanning from where it is currently.
  prefs: []
  type: TYPE_NORMAL
- en: The `FloatRect` type is simply a rectangle; we can use the `intersects` function
    to check whether this rectangle intersects with another rectangle. If the first
    rectangle intersects with another rectangle, then we return `true` to say that
    there is an intersection or collision between the sprites. If there is no intersection,
    then we return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` function, after updating the `enemy` and `rocket` classes,
    we check the collision between each rocket and each enemy in a nested `for` loop.
    You can add the collision check as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a double `for` loop, call the `checkCollision` function, and
    then pass each rocket and enemy into it to check the intersection between them.
  prefs: []
  type: TYPE_NORMAL
- en: If there is an intersection, we remove the rocket and enemy from the vector
    and delete them from the scene. With this, we are done with collision detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a separate `Hero` class so that all the code pertaining
    to the `Hero` class was in one single file. In this `Hero` class, we managed jumping
    and the shooting of the rockets in the class. Next, we created the `Enemy` class, because
    for every hero, there needs to be a villain in the story! We learned how to add
    enemies to a vector so that it is easier to loop between the enemies in order
    to update their position. We also created a `Rocket` class and managed the rockets
    using a vector. Finally, we learned how to check for collisions between the enemies
    and the rockets. This creates the foundation of the gameplay loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finish the game, adding sound and text to it in
    order to give audio feedback to the player and show the current score.
  prefs: []
  type: TYPE_NORMAL
