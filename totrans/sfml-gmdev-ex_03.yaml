- en: Chapter 3. Get Your Hands Dirty – What You Need to Know
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 沾满泥土——你需要知道的内容
- en: Game development can often be a tedious process to bear. In many instances,
    the amount of time spent on writing a specific chunk of code, implementing a certain
    set of features, or revising an old code that you or someone else had written
    shows very few results that can be immediately appreciated; which is why you may
    at some point see a game developer's face light up in instant joy when a flashier
    segment of their project sees the light of day. Seeing your game actually come
    to life and begin changing before your very eyes is the reason most of our fellow
    game developers do what they do. Those moments make writing tons of code that
    show little stimulating results possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发往往是一个令人厌烦的过程。在许多情况下，花费在编写特定代码块、实现特定功能集或修订你或其他人编写的旧代码上的时间很少能立即得到认可；这就是为什么你可能会在某些时候看到游戏开发者的脸上突然露出喜悦的表情，当他们的项目中的一个更炫目的部分得以展示时。看到你的游戏真正地在你眼前开始变化，这是大多数游戏开发者所做事情的原因。那些时刻使得编写大量看似没有刺激结果的代码成为可能。
- en: So, now that we have our game structure ready, it's time to focus on the fun,
    flashy parts!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经准备好了游戏结构，是时候专注于有趣、炫目的部分了！
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The game of choice for our first project and its history
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们第一个项目的游戏选择及其历史
- en: Building the game we've chosen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们选择的游戏
- en: Common game programming elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的游戏编程元素
- en: Additional SFML elements needed to complete our project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成我们项目所需的额外SFML元素
- en: Building helper elements for all our game projects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们所有的游戏项目构建辅助元素
- en: Effective debugging and common problem solving in games
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的有效调试和常见问题解决
- en: Introducing snake
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍蛇
- en: 'If right now you''re imagining building a game with *Solid Snake* wearing his
    trademark bandana, we''re not quite there yet, although the eagerness to do so
    is understandable. However, if you pictured something like the following, you''re
    right on point:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想象的是用戴着标志性头巾的*Solid Snake*来构建游戏，我们还没有达到那个阶段，尽管这样做的心情是可以理解的。然而，如果你想象的是以下这样的东西，你就完全正确：
- en: '![Introducing snake](img/4284_03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![介绍蛇](img/4284_03_01.jpg)'
- en: 'First published by *Gremlin* in 1976 under the name "Blockade", the snake concept
    is one of the most famous game types of all time. Countless ports have been written
    for this type of mechanic, such as *Surround* by *Atari* in 1978 and *Worm* by
    *Peter Trefonas*. Pretty much any platform that crosses one''s mind has a port
    of snake on it, even including the early monochrome *Nokia* phones, such as the
    *3310* and *6110*. The graphics changed from port to port and improved with time.
    However, the main idea and the rules remained the same ever since its humble beginnings:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首次由*Gremlin*于1976年以“Blockade”之名发布，蛇的概念是有史以来最著名的游戏类型之一。为这种机制编写了无数移植版本，例如1978年由*Atari*发布的*Surround*和由*Peter
    Trefonas*发布的*Worm*。几乎任何能想到的平台都有蛇的移植版本，甚至包括早期的单色*Nokia*手机，如*3310*和*6110*。图形从移植到移植，随着时间的推移而改进。然而，自从其简朴的起点以来，主要思想和规则始终保持不变：
- en: 'The snake can move in four total directions: up, down, left, and right'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛇可以沿四个方向移动：上、下、左和右
- en: Eating an apple makes the snake grow in length
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吃苹果会使蛇变长
- en: You cannot touch the walls or your own body, otherwise the game is over
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能触碰墙壁或自己的身体，否则游戏结束
- en: Other things may vary depending on which version of the game you play, such
    as the score you receive for eating an apple, the amount of lives you have, the
    speed at which the snake moves, the size of the playing field, obstacles, and
    so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你玩的游戏版本，其他一些事情可能会有所不同，例如吃苹果获得的分数、你的生命值、蛇移动的速度、游戏场的尺寸、障碍物等等。
- en: Game design decisions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计决策
- en: 'Certain versions of snake run differently; however, for the sake of paying
    homage to the classical approach, we will be implementing a snake that moves based
    on a **grid**, as illustrated next:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 某些版本的蛇运行方式不同；然而，为了致敬经典方法，我们将实现一个基于**网格**移动的蛇，如下所示：
- en: '![Game design decisions](img/4284_03_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计决策](img/4284_03_02.jpg)'
- en: Taking this approach makes it easier to later check for collision between the
    snake segments and the apple. Grid movement basically means updating at a static
    rate. This can be achieved by utilizing a fixed time-step, which we covered back
    in [Chapter 2](ch02.html "Chapter 2. Give It Some Structure – Building the Game
    Framework"), *Give It Some Structure – Building the Game Framework*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法使得以后检查蛇段和苹果之间的碰撞变得更容易。网格移动基本上意味着以静态速率更新。这可以通过使用固定的时间步长来实现，这是我们之前在 [第2章](ch02.html
    "第2章。给它一些结构 - 构建游戏框架") 中提到的，*给它一些结构 - 构建游戏框架*。
- en: The outside area symbolizes the boundaries of the game, which in the case of
    a grid-based movement would be in the range of *[1;Width-1]* and *[1;Height-1]*.
    If the snake head isn't within that range, it's safe to say that the player has
    crashed into a wall. All the grid segments here are 16px by 16px big; however,
    that can be adjusted at any time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 外部区域象征着游戏的边界，在基于网格的移动中，这将是范围 *[1;Width-1]* 和 *[1;Height-1]*。如果蛇头不在这个范围内，那么可以肯定地说，玩家已经撞到了墙壁。这里所有的网格段都是
    16px x 16px 大小；然而，这可以在任何时候进行调整。
- en: Unless the player runs out of lives, we want to cut the snake at the point of
    intersection if its head collides with its body and decrease the amount of lives
    left. This adds a little variety to the game without being too unbalanced.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除非玩家用完生命，否则我们希望在蛇头与身体相交的点切断蛇，并减少剩余的生命值。这给游戏增添了一些多样性，但不会过于失衡。
- en: Lastly, you've probably already picked up on the fact that we're using very
    simplistic graphical representations of what a snake is in this game. This is
    done mainly to keep things simple for now, as well as to add the charm of a classic
    to the mix. It wouldn't be terribly complicated to use sprites for this, however,
    let's not worry about that just yet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能已经注意到了，我们在游戏中使用的是非常简单的蛇的图形表示。这样做主要是为了保持简单，同时也为了给经典元素增添魅力。然而，使用精灵来做到这一点并不复杂，但让我们先不考虑这一点。
- en: Implementing the snake structure
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现蛇结构
- en: 'Let''s now create the two files we''ll be working with: `Snake.h` and `Snake.cpp`.
    Prior to actually developing the snake class, a definition of some data types
    and structures is in order. We can begin by actually defining the structure that
    our apple eating serpent will be made out of, right in the snake header file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们将要工作的两个文件：`Snake.h` 和 `Snake.cpp`。在真正开发蛇类之前，我们需要定义一些数据类型和结构。我们可以从在蛇头文件中实际定义我们的苹果吞噬蛇的结构开始：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can tell, it's a very simple structure that contains a single member,
    which is an *integer vector* representing the position of the segment on the grid.
    The constructor here is utilized to set the position of the segment through an
    *initializer list*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的结构，它包含一个单一成员，即一个表示段在网格上位置的 *整数向量*。这里的构造函数被用来通过 *初始化列表* 设置段的位置。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before moving past this point, make sure you're competent with the **Standard
    Template Library** and the data containers it provides. We will specifically be
    using `std::vector` for our needs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，请确保您熟悉 **标准模板库** 和它提供的数据容器。我们将特别使用 `std::vector` 来满足我们的需求。
- en: 'We now have the segment type defined, so let''s get started on actually storing
    the snake somewhere. For beginner purposes, `std::vector` will do nicely! Before
    going too far with that, here''s a neat little trick for curing our code of "long-line-itus":'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了段类型，所以让我们开始考虑将蛇存储在某个地方。出于初学者的目的，`std::vector` 将会非常合适！在深入之前，这里有一个小技巧可以帮助我们消除代码中的“长行病”：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you should already know from your *C/C++* background, `using` is a neat
    little keyword that allows the user to define aliases for the known data types.
    By using our clean new definitions together with the `auto` keyword, we''re preventing
    a scenario like the following from ever happening:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从您的 *C/C++* 背景中应该已经知道的，`using` 是一个很棒的小关键字，它允许用户为已知的数据类型定义别名。通过结合使用我们干净的新定义和
    `auto` 关键字，我们防止了以下情况的发生：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's a simple matter of convenience and is completely optional to use, however,
    we will be equipping this useful tool all the way through this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个方便的问题，使用它是完全可选的，然而，我们将在这个书中一直使用这个有用的工具。
- en: 'One last type we need to define before beginning to really work on the snake
    class, is the direction enumeration:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正开始编写蛇类之前，我们还需要定义一个类型枚举：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once again, it's nothing too fancy. The snake has four directions it can move
    in. We also have a possibility of it standing still, in which case we can just
    set the direction to `NONE`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不复杂。蛇有四个可以移动的方向。我们还有一个可能性，即它保持静止，在这种情况下，我们可以将方向设置为`NONE`。
- en: The snake class
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蛇类
- en: 'Before designing any object, one must ask oneself what it needs. In our case,
    the snake needs to have a direction to move towards. It also needs to have lives,
    keep track of the score, its speed, whether it lost or not, and whether it lost
    or not. Lastly, we''re going to store a rectangle shape that will represent every
    segment of the snake. When all these are addressed, the header of the snake class
    would look something like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计任何对象之前，必须问自己它需要什么。在我们的例子中，蛇需要有一个移动的方向。它还需要有生命值，跟踪分数，速度，是否失败，以及是否失败。最后，我们将存储一个矩形形状，它将代表蛇的每个部分。当所有这些问题都得到解决后，蛇类的头文件将看起来像以下这样：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we're using our new type alias for the snake segment vector. This
    doesn't look that helpful just yet, but it's about to be, really soon.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用我们为蛇段向量创建的新类型别名。这看起来目前并不那么有用，但它很快就会变得非常有用。
- en: 'As you can see, our class has a few methods defined that are designed to split
    up the functionality, such as `Lose()`, `Extend()`, `Reset()`, and `CheckCollision()`.
    This will increase code re-usability as well as readability. Let''s begin actually
    implementing these methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的类定义了一些方法，旨在分割功能，例如`Lose()`、`Extend()`、`Reset()`和`CheckCollision()`。这将增加代码的可重用性和可读性。让我们开始实际实现这些方法：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The constructor is pretty straightforward. It takes one argument, which is
    the size of our graphics. This value gets stored for later use and the member
    of type `sf::RectangleShape` gets its size adjusted based on it. The subtraction
    of one pixel from the size is a very simple way of maintaining that the snake
    segments appear visually slightly separated, as illustrated here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数相当直接。它接受一个参数，即我们图形的大小。这个值将被存储以供以后使用，并且`sf::RectangleShape`成员的大小将根据它进行调整。从大小中减去一个像素是一个非常简单的方法，以保持蛇段在视觉上略微分离，如图所示：
- en: '![The snake class](img/4284_03_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![蛇类](img/4284_03_03.jpg)'
- en: 'The constructor also calls the `Reset()` method on the last line. A comment
    in the header file states that this method is responsible for moving the snake
    into its starting position. Let''s make that happen:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数也在最后一行调用了`Reset()`方法。头文件中的注释表明，此方法负责将蛇移动到起始位置。让我们实现这一点：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This chunk of code will be called every time a new game begins. First, it will
    clear the snake segment vector from the previous game. After that, some snake
    segments will get added. Because of our implementation, the first element in the
    vector is always going to be the head. The coordinates for the snake pieces are
    hardcoded for now, just to keep it simple.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在每次新游戏开始时被调用。首先，它将清除上一局游戏中的蛇段向量。之后，将添加一些蛇段。由于我们的实现方式，向量中的第一个元素始终将是头部。蛇片的坐标目前是硬编码的，只是为了保持简单。
- en: Now we have a three-piece snake. The first thing we do now is set its direction
    to `None`. We want no movement to happen until a player presses a key to move
    the snake. Next, we set up some arbitrary values for the speed, the lives, and
    the starting score. These can be adjusted to your liking later. We also set the
    `m_lost` flag to `false` in order to signify a new round taking place.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个三段蛇。我们现在要做的第一件事是将它的方向设置为`None`。我们希望在没有玩家按下键移动蛇之前不发生任何移动。接下来，我们为速度、生命值和起始分数设置一些任意值。这些可以在以后根据您的喜好进行调整。我们还设置了`m_lost`标志为`false`，以表示正在进行新的一轮。
- en: 'Before moving on to more difficult to implement methods, let''s quickly cover
    all the helper ones:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到更难实现的方法之前，让我们快速覆盖所有辅助方法：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These methods are fairly simple. Having descriptive names helps a lot. Let''s
    take a look at the `Extend` method now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法相当简单。有描述性的名称非常有帮助。现在让我们看看`Extend`方法：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This preceding method is the one responsible for actually growing out our snake
    when it touches an apple. The first thing we did was create a reference to the
    *last* element in the segment vector, called `tail_head`. We have a fairly large
    *if-else statement* chunk of code next, and both cases of it require access to
    the last element, so it's a good idea to create the reference now in order to
    prevent duplicated code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法是负责在蛇触碰到苹果时实际增长蛇的。我们首先做的事情是创建一个指向该段向量中**最后一个**元素的引用，称为`tail_head`。接下来，我们有一个相当大的**if-else语句**代码块，并且它的两种情况都需要访问最后一个元素，所以现在创建这个引用是一个好主意，以避免代码重复。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `std::vector` container overloads the **bracket operator** in order to support
    random access via a numeric index. It being similar to an array enables us to
    reference the last element by simply using an index of `size() - 1`. The random
    access speed is also constant, regardless of the number of elements in this container,
    which is what makes the `std::vector` a good choice for this project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`容器重载了**方括号运算符**以支持通过数字索引进行随机访问。它与数组类似，使我们能够通过使用`size() - 1`的索引来引用最后一个元素。随机访问速度也是恒定的，无论容器中的元素数量如何，这就是为什么`std::vector`是此项目的良好选择。'
- en: 'Essentially, it comes down to two cases: either the snake is longer than one
    segment or it''s not. If it does have more than one piece, we create another reference,
    called `tail_bone`, which points to the *next to last* element. This is needed
    in order to determine where a new piece of the snake should be placed upon extending
    it, and the way we check for that is by comparing the `position.x` and `position.y`
    values of the `tail_head` and `tail_bone` segments. If the x values are the same,
    it''s safe to say that the difference between the two pieces is on the y axis
    and vice versa. Consider the following illustration, where the orange rectangle
    is `tail_bone` and the red rectangle is `tail_head`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这归结为两种情况：要么蛇的长度超过一个段，要么不超过。如果蛇有多于一个部分，我们创建另一个引用，称为`tail_bone`，它指向**倒数第二个**元素。这是为了确定在扩展蛇时新的一段应该放置的位置，而我们检查这个位置的方法是通过比较`tail_head`和`tail_bone`段的位置`position.x`和`position.y`值。如果x值相同，可以说两个部分之间的差异在y轴上，反之亦然。考虑以下插图，其中橙色矩形是`tail_bone`，红色矩形是`tail_head`：
- en: '![The snake class](img/4284_03_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![蛇类](img/4284_03_04.jpg)'
- en: 'Let''s take the example that''s facing left and analyze it: `tail_bone` and
    `tail_head` have the same *y* coordinate, and the *x* coordinate of `tail_head`
    is greater than that of `tail_bone`, so the next segment will be added at the
    same coordinates as `tail_head`, except the x value will be increased by one.
    Because the `SnakeSegment` constructor is conveniently overloaded to accept coordinates,
    it''s easy to perform this simple math at the same time as pushing the segment
    onto the back of our vector.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以面向左的例子为例进行分析：`tail_bone`和`tail_head`具有相同的**y**坐标，而`tail_head`的**x**坐标大于`tail_bone`，所以下一个段将添加到与`tail_head`相同的坐标，除了x值将增加一。由于`SnakeSegment`构造函数方便地重载以接受坐标，因此可以在将段推入向量的末尾的同时轻松执行这个简单的数学运算。
- en: In the case of there only being one segment in the vector, we simply check the
    direction of our snake and perform the same math as we did before, except that
    this time it's based on which way the head is facing. The preceding illustration
    applies to this as well, where the orange rectangle is the head and the red rectangle
    is the piece that's about to be added. If it's facing left, we increase the *x*
    coordinate by one while leaving *y* the same. Subtracting from x happens if it's
    facing right, and so on. Take your time to analyze this picture and associate
    it with the previous code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量中只有一个段的情况下，我们只需检查蛇的方向并执行之前所做的相同数学运算，只是这次是基于头部朝向的方向。前面的插图也适用于这种情况，其中橙色矩形是头部，红色矩形是即将添加的部分。如果它面向左，我们将x坐标增加一，而y坐标保持不变。如果它面向右，则从x坐标中减去，依此类推。花点时间分析这张图片，并将其与之前的代码联系起来。
- en: 'Of course, none of this would matter if our snake didn''t move. That''s exactly
    what is being handled in the update method, which in our case of a *fixed time-step*
    is referred to as a "tick":'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们的蛇不动，这一切都没有意义。这正是更新方法所处理的内容，在我们的固定时间步长案例中，这被称为“tick”：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first two lines in the method are used to check if the snake should be
    moved or not, based on its size and direction. As mentioned earlier, the `Direction::None`
    value is used specifically for the purpose of keeping it still. The snake movement
    is contained entirely within the `Move` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的前两行用于检查蛇是否应该移动，这取决于其大小和方向。如前所述，`Direction::None`值专门用于使其保持静止。蛇的移动完全包含在`Move`方法中：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We start by iterating over the vector *backwards*. This is done in order to
    achieve an *inchworm* effect of sorts. It is possible to do it without iterating
    over the vector in reverse as well, however, this serves the purpose of simplicity
    and makes it easier to understand how the game works. We''re also utilizing the
    *random access operator* again to use numeric indices instead of the vector *iterators*
    for the same reasons. Consider the following illustration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从向量中*向后*迭代。这样做是为了达到一种类似“ inchworm”的效果。当然，也可以不反向迭代向量来做这件事，然而，这样做简化了过程，并使得理解游戏的工作原理更容易。我们还在使用*随机访问运算符*，再次使用数字索引而不是向量*迭代器*，出于同样的原因。考虑以下插图：
- en: '![The snake class](img/4284_03_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![蛇类](img/4284_03_05.jpg)'
- en: 'We have a set of segments in their positions before we call the `tick` method,
    which can be referred to as the "beginning state". As we begin iterating over
    our vector backwards, we start with the segment #3\. In our `for` loop, we check
    if the index is equal to `0` or not in order to determine if the current segment
    is the front of the snake. In this case, it''s not, so we set the position of
    segment #3 to be the *same* as the segment #2\. The preceding illustration shows
    the piece to be, sort of, in between the two positions, which is only done for
    the purpose of being able to see both of them. In reality, segment #3 is sitting
    right on top of segment #2.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`tick`方法之前，我们有一组段的位置，这可以被称为“初始状态”。当我们开始从我们的向量中向后迭代时，我们首先从段#3开始。在我们的`for`循环中，我们检查索引是否等于`0`，以确定当前段是否是蛇的前端。在这种情况下，它不是，所以我们把段#3的位置设置为与段#2的*相同*。前面的插图显示了该部分似乎位于两个位置之间，这样做只是为了能够看到它们。实际上，段#3正坐在段#2的上面。
- en: After the same process is applied again to the second part of the snake, we
    move on to its head. At this point, we simply move it across one space in the
    axis that corresponds to its facing direction. The same idea applies here as it
    did in the illustration before this one, but the sign is reversed. Since in our
    example, the snake is facing right, it gets moved to the coordinates *(x+1;y)*.
    Once that is done, we have successfully moved our snake by one space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在对蛇的第二部分应用同样的过程之后，我们继续处理它的头部。在这个时候，我们只需将其移动到对应其面向方向的轴上的一个空间。这里的应用思想与之前的插图相同，但符号相反。由于在我们的例子中，蛇面向右，它被移动到坐标*(x+1;y)*。一旦这样做，我们就成功地移动了我们的蛇一个空间。
- en: 'One last thing our tick does is call the `CheckCollision()` method. Let''s
    take a look at its implementation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小虫子最后要做的一件事是调用`CheckCollision()`方法。让我们看看它的实现：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, there's no need to check for a collision unless we have over four segments.
    Understanding certain scenarios of your game and putting in checks to not waste
    resources is an important part of game development. If we have over four segments
    of our snake, we create a reference to the head again, because in any case of
    collision, that's the first part that would hit another segment. There is no need
    to check for a collision between all of its parts twice. We also skip an iteration
    for the head of the snake, since there's obviously no need to check if it's colliding
    with itself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除非我们有超过四个段，否则没有必要检查碰撞。理解你的游戏中的某些场景，并添加检查以避免资源浪费是游戏开发的重要部分。如果我们有超过四个蛇的段，我们再次创建对头部的引用，因为在任何碰撞的情况下，那将是首先撞到另一个段的部分。没有必要两次检查所有部分之间的碰撞。我们还在蛇的头部跳过一个迭代，因为显然没有必要检查它是否与自己碰撞。
- en: The basic way we check for a collision in this grid-based game is essentially
    by comparing the position of the head to the position of the current segment represented
    by our iterator. If both positions are the same, the head is intersecting with
    the body. The way we resolve this was briefly covered in the *Game design decisions*
    section of this chapter. The snake has to be cut at the point of collision until
    the player runs out of lives. We do this by first obtaining an integer value of
    the segment count between the end and the segment being hit. STL is fairly flexible
    with its iterators, and since the memory in the case of using a vector is all
    laid out contiguously, we can simply subtract our current iterator from the last
    element in the vector to obtain this value. This is done in order to know how
    many elements to remove from the back of the snake up until the point of intersection.
    We then invoke the method that is responsible for cutting the snake. Also, since
    there can only be one collision at a time, we break out of the `for` loop to not
    waste any more clock cycles.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基于网格的游戏中，我们检查碰撞的基本方式是本质上通过比较头部位置和由我们的迭代器表示的当前片段位置。如果两个位置相同，头部与身体相交。我们解决这个问题的方法在本书的*游戏设计决策*部分有简要介绍。蛇必须在碰撞点被切断，直到玩家用完生命。我们通过首先获取从末端到被击中的片段之间的片段计数整数值来完成此操作。STL在迭代器方面相当灵活，并且由于使用向量时内存都是连续布局的，我们可以简单地从向量的最后一个元素中减去我们的当前迭代器来获得这个值。这样做是为了知道需要从蛇的尾部移除多少个元素，直到交点。然后我们调用负责切割蛇的方法。此外，由于一次只能有一个碰撞，我们跳出`for`循环，以避免浪费更多的时钟周期。
- en: 'Let''s take a look at the `Cut` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Cut`方法：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, it's as simple as looping a certain amount of times based on
    the `l_segments` value and popping the elements from the back of the vector. This
    effectively slices through the snake.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这就像基于`l_segments`值循环一定次数，并从向量的末尾弹出元素一样简单。这实际上是在蛇上切割。
- en: The rest of the code simply decreases the amount of lives left, checks if it's
    at zero, and calls the `Lose()` method if there are no more lives.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码只是减少剩余的生命值，检查是否为零，如果没有更多生命，则调用`Lose()`方法。
- en: 'Phew! That''s quite a bit of code. One thing still remains, however, and that
    is rendering our square serpent to the screen:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这相当多的代码。然而，仍然有一件事要做，那就是将我们的方形蛇渲染到屏幕上：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Quite similarly to a lot of the methods we've implemented here, there's a need
    to iterate over each segment. The head itself is drawn outside of the loop in
    order to avoid unnecessary checks. We set the position of our `sf::RectangleShape`
    that graphically represents a snake segment to its grid position multiplied by
    the `m_size` value in order to obtain the pixel coordinates on the screen. Drawing
    the rectangle is the last step of implementing the snake class in its entirety!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在这里实施的大多数方法非常相似，我们需要遍历每个片段。头部本身是在循环外部绘制的，以避免不必要的检查。我们将代表蛇片段的`sf::RectangleShape`图形形状的位置设置为网格位置乘以`m_size`值，以便在屏幕上获得像素坐标。绘制矩形是完整实现蛇类的最后一步！
- en: The World class
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界类
- en: Our snake can now move and collide with itself. While functional, this doesn't
    make a really exciting game. Let's give it some boundaries and something to munch
    on to increase the score by introducing the `World` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的蛇现在可以移动并与其自身碰撞。虽然功能齐全，但这并不足以让游戏变得真正有趣。让我们通过引入`World`类来给它一些边界和可以咀嚼的东西，以增加分数。
- en: While it's possible to just make separate objects for everything we talk about
    in here, this project is simple enough to allow certain aspects of itself to be
    nicely contained within a single class that can manage them without too much trouble.
    This class takes care of everything to do with keeping the game boundaries, as
    well as maintaining the apple the player will be trying to grab.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然我们可以为这里提到的每一件事都创建单独的对象，但这个项目足够简单，足以允许其某些方面被很好地包含在一个类中，这个类可以轻松地管理它们。这个类负责处理与保持游戏边界相关的一切，以及维护玩家将尝试抓取的苹果。 '
- en: 'Let''s take a look at the class header:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类头：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see from the preceding code, this class also keeps track of how
    big the objects in the game are. Aside from that, it simply retains four rectangles
    for the boundary graphics, a circle for drawing the apple, and an integer vector
    to keep track of the apple''s coordinates, which is named `m_item`. Let''s start
    implementing the constructor:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中可以看到，这个类还跟踪游戏中对象的大小。除此之外，它仅仅保留四个矩形用于边界图形，一个圆用于绘制苹果，以及一个整数向量用于跟踪苹果的坐标，该向量命名为
    `m_item`。让我们开始实现构造函数：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Up until the complex looking `for` loops, we simply initialize some member values
    from the local constructor variables, set the color and radius of the apple circle,
    and call the `RespawnApple()` method in order to place it somewhere on the grid.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在看起来复杂的 `for` 循环之前，我们只是从局部构造函数变量中初始化一些成员值，设置苹果圆的颜色和半径，并调用 `RespawnApple()` 方法来将其放置在网格上的某个位置。
- en: 'The first `for` loop just iterates four times for each of the four sides of
    the game screen in order to set up a red rectangle wall on each side. It sets
    a dark red color for the rectangle fill and proceeds with checking the index value.
    First, we determine if the index is an even or an odd value by checking it with
    the following expression: `if(!((i + 1) % 2)){...`. This is done in order to know
    how big each wall has to be on a specific axis. Because it has to be as large
    as one of the screen dimensions, we simply make the other one as large as all
    the other graphics on the screen, which is represented by the `m_blockSize` value.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `for` 循环只是对游戏屏幕的四边各迭代四次，以便在每一边设置一个红色矩形墙。它为矩形填充设置深红色颜色，并继续检查索引值。首先，我们通过以下表达式确定索引是偶数还是奇数：`if(!((i
    + 1) % 2)){...}`。这是为了知道在特定轴上每堵墙需要有多大。因为它必须与屏幕尺寸之一一样大，所以我们简单地使另一个与屏幕上的所有其他图形一样大，这由
    `m_blockSize` 值表示。
- en: The last `if` statement checks if the index is below two. If it is, we're working
    with the top-left corner, so we simply set the position of the rectangle to (0,0).
    Since the origin of all the rectangle-based drawables in SFML is always the top-left
    corner, we don't need to worry about that in this case. However, if the index
    is 2 or higher, we set the origin to the size of the rectangle, which effectively
    makes it the bottom right corner. Afterwards, we set the position of the rectangle
    to be the same as the size of the screen, which puts the shape all the way down
    to the bottom right corner. You can simply set all the coordinates and origins
    by hand, but this approach makes the initialization of the basic features more
    automated. It may be hard to see the use for it now, but in more complicated projects
    this kind of thinking will come in handy, so why not start now?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `if` 语句检查索引是否小于2。如果是，我们正在处理左上角，所以我们只需将矩形的位置设置为（0,0）。由于SFML中所有基于矩形的可绘制对象的坐标原点始终是左上角，所以我们在这个情况下不需要担心。然而，如果索引是2或更高，我们将原点设置为矩形的尺寸，这实际上使其成为右下角。之后，我们将矩形的位置设置为与屏幕尺寸相同，这样就将形状放置到底部右下角。您可以简单地手动设置所有坐标和原点，但这种方法使基本特征的初始化更加自动化。现在可能很难看到它的用途，但在更复杂的项目中，这种思维方式会很有用，所以为什么不从现在开始呢？
- en: 'Since we have our walls, let''s take a look at how one might go about re-spawning
    the apple:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有我们的墙壁，让我们看看一个人可能会如何重新生成苹果：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first thing we must do is determine the boundaries within which the apple
    can be spawned. We do so by defining two values: `maxX` and `maxY`. These are
    set to the window size divided by the block size, which gives us the number of
    spaces in the grid, from which we must then subtract 2\. This is due to the fact
    that the grid indices begin with 0, not 1, and because we don''t want to spawn
    the apple within the right or bottom walls.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是确定苹果可以生成的边界。我们通过定义两个值来完成此操作：`maxX` 和 `maxY`。这些值设置为窗口尺寸除以块大小，这给出了网格中的空间数量，然后我们必须从中减去2。这是因为网格索引从0开始，而不是1，并且我们不希望在右侧或底部墙壁内生成苹果。
- en: The next step is to actually generate the random values for the apple coordinates.
    We use our pre-calculated values here and set the *lowest* possible random value
    to `1`, because we don't want anything spawning in the top wall or the left wall.
    Since the coordinates of the apple are now available, we can set the `m_appleShape`
    graphic's position in pixel coordinates by multiplying the grid coordinates by
    the size of all our graphics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实际生成苹果坐标的随机值。我们在这里使用预先计算好的值，并将最低可能的随机值设置为`1`，因为我们不希望任何东西在顶部墙壁或左侧墙壁上生成。由于苹果的坐标现在可用，我们可以通过将网格坐标乘以所有图形的大小来设置`m_appleShape`图形的像素坐标。
- en: 'Let''s actually make all these features come to life by implementing the update
    method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现更新方法来让所有这些功能变得生动起来：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we check if the player's position is the same as that of the apple. If
    it is, we have a collision and the snake gets extended, the score increases, and
    the apple gets re-spawned. Next, we determine our grid size and check if the player
    coordinates are anywhere outside of the designated boundaries. If that's the case,
    we call the `Lose()` method to illustrate the collision with the wall and give
    the player a "game over".
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查玩家的位置是否与苹果的位置相同。如果是，我们就有了碰撞，蛇变长，分数增加，苹果重新生成。接下来，我们确定网格大小，并检查玩家坐标是否在任何指定的边界之外。如果是这种情况，我们调用`Lose()`方法来展示与墙壁的碰撞，并给玩家一个“游戏结束”的提示。
- en: 'In order to not keep the player blind, we must display the boundaries of the
    game, as well as the main point of interest - the apple. Let''s draw everything
    on screen:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不让玩家处于盲目状态，我们必须显示游戏的边界，以及主要兴趣点——苹果。让我们在屏幕上绘制一切：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All we have to do is iterate four times and draw each of the four respective
    boundaries. Then we draw the apple, which concludes our interest in this method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是迭代四次，绘制四个相应的边界。然后我们绘制苹果，这标志着我们对这个方法的兴趣结束。
- en: 'One more thing to point out is that the other classes might need to know how
    big the graphics need to be, and for this reason, let''s implement a simple method
    for obtaining that value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点需要指出的是，其他类可能需要知道图形需要有多大，因此让我们实现一个简单的方法来获取这个值：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This concludes the `World` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`World`类的编写。
- en: Time to integrate
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候整合了
- en: 'Much like how a hammer is useless without someone using it, so are our two
    classes without being properly adopted by the `Game` class. Since we didn''t write
    all that code just to practise typing, let''s work on putting all the pieces together.
    First, we need to actually add two new members to the `Game` class, and you might
    already have guessed what they are:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如没有人在使用它时锤子毫无用处一样，我们的两个类如果没有被`Game`类正确采用，也是无用的。既然我们写所有这些代码并不是仅仅为了练习打字，那么让我们来把这些碎片拼在一起。首先，我们需要实际上向`Game`类添加两个新成员，你可能已经猜到了它们是什么：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let''s initialize these members. Since both of them have constructors
    that take arguments, it''s the time for *initializer list*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们初始化这些成员。由于它们都有接受参数的构造函数，现在是初始化列表的时间了：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we need to process some input. As you may recall from the previous chapters,
    utilizing events for live input is really delayed and should never be used for
    anything else but checking for key presses that aren''t time sensitive. Luckily,
    SFML provides means of obtaining the real-time state of the keyboard through the
    `sf::Keyboard` class. It only contains the static functions and is never meant
    to be initialized. One of those functions is exactly what we need here: `isKeyPressed(sf::Keyboard::Key)`.
    The sole argument that it takes is the actual key you want to check the state
    of, which can be obtained through the use of the `sf::Keyboard::Key` enumeration,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理一些输入。正如你可能从前面的章节中回忆起来的那样，利用事件进行实时输入是非常延迟的，并且绝对不应该用于除检查非时间敏感的按键以外的任何其他目的。幸运的是，SFML通过`sf::Keyboard`类提供了获取键盘实时状态的方法。它只包含静态函数，并且从不打算被初始化。其中有一个函数正是我们需要的：`isKeyPressed(sf::Keyboard::Key)`。它接受的唯一参数是你想要检查状态的键的实际键值，这可以通过使用`sf::Keyboard::Key`枚举来获得，如下所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Something we don't want the snake to do is to go in the direction that is opposite
    to its current one. At any given time, there should only be three directions it
    can go in, and the use of the `GetDirection()` method ensures that we don't send
    the snake in reverse, essentially eating itself. If we have the proper combination
    of input and its current direction, it's safe to adjust its direction through
    the use of the `SetDirection()` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望蛇做的某件事是朝与当前方向相反的方向移动。在任何给定的时间，它只能朝三个方向移动，使用`GetDirection()`方法确保我们不会让蛇反向移动，从而吃掉自己。如果我们有适当的输入组合及其当前方向，就可以通过使用`SetDirection()`方法安全地调整其方向。
- en: 'Let''s get things moving by updating both our classes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新我们的两个类来开始行动：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As mentioned previously, we're using *fixed time-step* here, which incorporates
    the snake speed in order to update the appropriate amount of times per second.
    This is also where we check if the player has lost the game and reset the snake
    if he has.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在这里使用的是*固定时间步长*，它包含了蛇的速度，以便每秒更新适当的次数。这也是我们检查玩家是否输掉游戏并重置蛇的地方，如果玩家输了。
- en: 'We''re really close now. Time to draw everything on screen:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在非常接近了。是时候在屏幕上绘制一切了：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Much like before, we simply invoke the `Render` methods of both our classes
    and pass in a reference to `sf::RenderWindow`. With that, our game is actually
    playable! Upon successful compilation and execution of our project, we should
    end up with something looking like this following image:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们只是简单地调用我们两个类的`Render`方法，并传入`sf::RenderWindow`的引用。有了这个，我们的游戏实际上就可以玩了！在项目成功编译和执行后，我们应该得到以下图像所示的内容：
- en: '![Time to integrate](img/4284_03_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![整合时间](img/4284_03_06.jpg)'
- en: The snake will be still at first, until one of the four arrow keys is pressed.
    Once it does start moving, it will be able to eat the apple and grow by one segment,
    collide with its own tail and lose it twice before it dies, and end the game if
    the player crashes into a wall. The core version of our game is complete! Pat
    yourself on the back, as you just created your first game.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 蛇最初是静止的，直到按下四个方向键中的任意一个。一旦开始移动，它就能吃掉苹果并增长一个节段，在与自己的尾巴碰撞并失去两次之前死亡，如果玩家撞到墙壁，游戏结束。我们游戏的核心版本已经完成！给自己鼓掌吧，因为你刚刚创建了你第一个游戏。
- en: Hunting bugs
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕捉虫子
- en: 'As proud and satisfied as you may be with your first project, nothing is ever
    perfect. If you''ve spent some time actually playing the game, you may have noticed
    an odd event when quickly mashing the buttons, looking something like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你对自己的第一个项目感到自豪和满足，但没有任何事情是完美的。如果你花了一些时间实际玩游戏，你可能注意到了当快速按键时发生的奇怪事件，看起来像这样：
- en: '![Hunting bugs](img/4284_03_07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉虫子](img/4284_03_07.jpg)'
- en: The image represents the difference between two sequential updates. It seems
    that earlier it was facing the right direction and then it's facing left and missing
    its tail. What happened? Try to figure it out on your own before continuing, as
    it perfectly illustrates the experience of fixing game flaws.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片代表了两次连续更新之间的差异。看起来它之前面向正确的方向，然后面向左边，并且没有撞到自己的尾巴。发生了什么？在继续之前，试着自己找出答案，因为它完美地说明了修复游戏缺陷的经历。
- en: 'Playing around with it some more reveals certain details that narrow down our
    problem. Let''s break down what happens when a player starts mashing keys quickly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再多玩一会儿，可以揭示一些缩小我们问题的细节。让我们分析一下当玩家开始快速按键时会发生什么：
- en: The snake is facing right.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛇面向右。
- en: Any arrow key other than the left or right is pressed.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下除了左键或右键之外的任意箭头键。
- en: The direction of the snake gets set to something else, let's say up.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛇的方向被设置为其他方向，比如说向上。
- en: The right key is pressed before the game has a chance to update.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏有机会更新之前，正确的按键已经被按下。
- en: Since the snake's direction is no longer set to right or left, `if` statement
    in the input handler is satisfied and sets the direction to left.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于蛇的方向不再设置为向右或向左，输入处理程序中的`if`语句被满足，并将方向设置为向左。
- en: The game updates the snake and moves it left by one space. The head collides
    with its tail and it gets cut off.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏更新蛇的位置，并将其向左移动一个空间。头部与尾巴相撞，蛇被切断。
- en: Yes, it seems that our direction checking is flawed and causes this bug. Once
    again, spend some time trying to think of a way to fix this before moving on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，看起来我们的方向检查有缺陷，导致了这个错误。再次，在继续之前，花些时间想想如何解决这个问题。
- en: Fixing bugs
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复bug
- en: Let's discuss the several approaches that might be used in a situation like
    this. First, the programmer might think about putting a flag somewhere that remembers
    if the direction has already been set for the current iteration and gets reset
    afterwards. This would prevent the bug we're experiencing, but would also lock
    down the number of times a player can interact with the snake. Let's say it moves
    once a second. That would mean that if you press a key at the beginning of that
    second, you wouldn't be able to change your mind and hit another key quickly to
    rectify your wrong decision before the snake moves. That's no good. Let's move
    on to a new idea.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论在这种情况下可能使用的几种方法。首先，程序员可能会考虑在某个地方放置一个标志，以记住方向是否已经为当前迭代设置，并在之后重置。这将防止我们遇到的错误，但也会锁定玩家与蛇交互的次数。假设蛇每秒移动一次。这意味着如果你在那一秒的开始按下一个键，你就无法改变主意并快速按下另一个键来纠正你的错误决定，因为蛇会移动。这不好。让我们转向一个新的想法。
- en: 'Another approach may be to keep track of the original direction before any
    changes were made to that *iteration*. Then, once the update method gets called,
    we could check if the original direction, before any changes were made, is the
    opposite of the newest direction that we''ve received. If it is, we could simply
    ignore it and move the snake in the direction before any changes were made. This
    would fix the bug and not present us with a new one, but it comes with keeping
    track of one more variable and might get confusing. Imagine that in the future
    you''re presented with a similar bug or a request for a feature that needs you
    to keep track of another variable on top of this one. Imagine that happens one
    more time, then another. Very soon, your checking statement might look a little
    something like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是记录在更改任何迭代之前原始方向。然后，一旦调用更新方法，我们可以检查在做出任何更改之前原始方向是否与我们收到的最新方向相反。如果是这样，我们可以简单地忽略它，并将蛇移动到任何更改之前的方向。这将修复错误，而不会给我们带来新的错误，但这也意味着需要跟踪一个额外的变量，可能会变得令人困惑。想象一下，在未来你遇到了一个类似的错误或需要跟踪另一个变量的功能请求。想象这种情况发生一次，然后又一次。很快，你的检查语句可能看起来有点像这样：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that is what we call a mess. On top of that, imagine you have to check the
    same variables four times for four different conditions. It quickly becomes apparent
    that this is a bad design and it shouldn't be used by anyone with intentions of
    ever showing their code to another person.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们称之为混乱。更不用说，想象一下你不得不为四种不同的条件检查相同的变量四次。很快就会很明显，这是一个糟糕的设计，任何打算向他人展示其代码的人都不应该使用它。
- en: 'You may ask how we can rectify our problem then. Well, we could simply not
    rely on the use of a variable in the snake class to determine its direction, and
    instead implement a method that looks at its structure and spits out the direction
    it''s facing, as shown next:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我们如何纠正我们的问题。好吧，我们可以简单地不依赖蛇类中变量的使用来确定其方向，而是实现一个查看其结构并输出其面对的方向的方法，如下所示：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First, we check if the snake is *1* segment long or less; in this case, it
    doesn''t matter which direction it''s facing as it wouldn''t eat itself if it
    only had a head, and it wouldn''t even have a direction if there are no segments
    in the vector at all. Assuming it''s longer than one segment, we obtain two references:
    the head and the neck, which is the second piece of the snake right after the
    head. Then, we simply check the positions of both of them and determine the direction
    the snake is facing using the same logic as before, while implementing the snake
    class, as illustrated in the following image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查蛇是否只有1个或更少的段；在这种情况下，它朝哪个方向不重要，因为它如果只有头部，就不会吃掉自己，如果没有段在向量中，甚至没有方向。假设它比一个段更长，我们获得两个引用：头部和颈部，这是蛇头后面的第二部分。然后，我们简单地检查它们的位置，并使用与之前相同的逻辑确定蛇的方向，就像在实现蛇类时所示，如下面的图像所示：
- en: '![Fixing bugs](img/4284_03_08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![修复错误](img/4284_03_08.jpg)'
- en: 'This will return a proper direction that won''t be altered unless the snake
    moves, so let''s adjust our input handling code to cater to these changes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个正确的方向，除非蛇移动，否则不会改变，所以让我们调整我们的输入处理代码以适应这些变化：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Voila! No more of our snake turning inside out.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的蛇不再会翻转了。
- en: There's one more fault with the game that didn't get addressed here on purpose.
    Try to find it and fix it in order to practise resolving problems like this in
    the future.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中还有一个故意没有解决的错误。试着找出它并修复它，以便在将来练习解决这类问题。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Hint: It has to do with how many segments the snake has when the game starts.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：这与游戏开始时蛇有多少段有关。
- en: If you want to do this one fairly, do your best not to reference the code of
    the finished project that came with this book, as that has it fixed already.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要公平地完成这个任务，尽量不参考这本书附带已完成项目的代码，因为那已经固定了。
- en: Going the extra mile
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 走得更远
- en: 'A functional game is far from a fully finished product. Sure, we have everything
    we wanted in the beginning, but it still leaves things to be desired, such as
    keeping track of the score and showing how many lives we have. At first, your
    main instinct might be to just add a bit of text somewhere on the screen that
    simply prints the number of lives you have left. You may even be tempted to do
    as little as simply printing it out in the console window. If that''s the case,
    the purpose of this part is to change your way of thinking by introducing something
    that we will be using and improving over the course of this book: the textbox.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个功能性的游戏远非一个完全完成的产品。当然，我们一开始就拥有了所有想要的东西，但它仍然留有遗憾，比如跟踪分数和显示我们有多少条命。起初，你的主要本能可能就是简单地在一个屏幕上的某个地方添加一些文本，简单地打印出你剩余的命数。你甚至可能被诱惑只简单地将其打印到控制窗口中。如果是这样的话，这部分的目的就是通过引入我们将在这本书的整个过程中使用和改进的东西来改变你的思维方式：文本框。
- en: 'If that name doesn''t really mean anything to you, simply imagine a chat window
    on any given communication application, such as *MSN Messenger* or *Skype*. Whenever
    a new message is added, it''s added to the bottom as the older messages are moved
    up. The window holds a certain number of messages that are visible at one time.
    That''s not only useful for the purpose of the game printing a casual message,
    but can also be used for debugging. Let''s start by writing our header, as usual:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个名字对你来说没有任何意义，只需想象在任何通信应用上的一个聊天窗口，例如 *MSN Messenger* 或 *Skype*。每当有新消息添加时，它会被添加到底部，而较旧的消息则被向上移动。窗口中可以同时显示一定数量的消息。这不仅对游戏打印轻松消息很有用，还可以用于调试。让我们先从编写我们的标题开始，就像往常一样：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We begin by defining the data type for the container of all the messages. In
    this case, we went with `std::vector` again, simply because that''s the more familiar
    choice at this point. Just to make it look better and more readable, we''ve added
    a rectangle shape as one of the members of the class that will be used as a backdrop.
    On top of that, we have introduced a new data type: `sf::Text`. This is a drawable
    type that represents any typed characters or strings of characters, and can be
    adjusted in size, font, and color, as well as transformed, much like any other
    drawable in SFML.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了所有消息容器的数据类型。在这种情况下，我们再次选择了 `std::vector`，因为这在这个阶段更熟悉。为了使其看起来更好、更易读，我们添加了一个矩形形状作为类的一个成员，该类将用作背景。除此之外，我们还引入了一个新的数据类型：`sf::Text`。这是一个可绘制的类型，代表任何键入的字符或字符字符串，并且可以调整大小、字体和颜色，就像SFML中的任何其他可绘制对象一样。
- en: 'Let''s start implementing our fancy new feature:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现我们的新特性：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, it has two constructors, one of which can be used to initialize
    some default values and the other that allows customization by passing in some
    values as arguments. The first argument is the number of lines that are visible
    in the textbox. It is followed by the character size in pixels, the width of the
    entire textbox in pixels, and float vector that represents the position on the
    screen where it should be drawn at. All that these constructors do is invoke the
    `Setup` method and pass all these arguments to it, so let''s take a look at it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它有两个构造函数，其中一个可以用来初始化一些默认值，另一个允许通过传递一些参数来自定义。第一个参数是文本框中可见的行数。它后面跟着字符大小（以像素为单位）、整个文本框的宽度（以像素为单位），以及一个表示应在屏幕上绘制位置的浮点向量。所有这些构造函数所做的只是调用
    `Setup` 方法并将所有这些参数传递给它，所以让我们来看看它：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Aside from initializing its member values, this method defines an offset float
    vector that will be used to space the text appropriately and provide some padding
    from the top-left corner. It also sets up our `sf::Text` member by first creating
    a font to which it's bound, setting the initial string to nothing, setting up
    the character size and color, and setting its position on the screen to the provided
    position argument with the proper offset factored in. Additionally, it sets up
    the size of the backdrop by using the width that was provided and multiplying
    the number of visible lines by the result of the multiplication of the character
    size and a constant floating point value of 1.2, in order to account for spacing
    between the lines.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始化其成员值之外，此方法定义了一个偏移浮点向量，它将被用来适当地间隔文本并提供从左上角的一些填充。它还通过首先创建一个与之绑定的字体，设置初始字符串为空，设置字符大小和颜色，以及将其屏幕位置设置为提供的位置参数（考虑了适当的偏移量）来设置我们的`sf::Text`成员。此外，它通过使用提供的宽度并乘以可见行数与字符大小和1.2这个常量浮点值的乘积来设置背景的大小，以考虑到行之间的间隔。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: From time to time, it does simply come down to playing with code to seeing what
    really works. Finding certain numeric constants that work in all cases is one
    of the situations where it's just a matter of testing in order to determine the
    correct value. Don't be afraid to try out new things and see what works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这仅仅归结为玩代码，看看什么真正有效。找到在所有情况下都起作用的某些数值常数，就是测试以确定正确值的情况之一。不要害怕尝试新事物并看看什么有效。
- en: 'Since we''re utilizing a vector to store our messages, adding a new one or
    removing them all is as simple as using the `push_back` and `clear` methods:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用向量来存储我们的消息，添加一个新消息或删除所有消息就像使用`push_back`和`clear`方法一样简单：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the case of adding a new message, checking whether we have more of them than
    we can see would be a good idea. Having something around that we're not going
    to see or need ever again is wasteful, so the very first message that is definitely
    out of sight at that time is removed from the message container.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新消息的情况下，检查我们是否比我们看到的多，这是一个好主意。如果我们周围有我们永远不会看到或需要的物品，那就是浪费，所以当时肯定看不见的第一条消息就被从消息容器中移除了。
- en: 'We''re very close to actually finishing this neat feature. The only thing left
    now is drawing it, which, as always, is taken care of by the `Render` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经非常接近完成这个整洁的功能了。现在唯一剩下的事情就是绘制它，这，就像往常一样，由`Render`方法来处理：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code begins with `std::string` being set up to hold all the visible messages
    on the screen. Afterwards, it's as simple as looping over the message vector and
    appending the text of each message to our local `std::string` variable with a
    new line symbol at the end. Lastly, after checking the local variable and making
    sure it isn't empty, we must set our `m_content` member of type `sf::Text` to
    hold the string we've been pushing our messages to and draw both the background
    and the text on the screen. That's all there is to the `Textbox` class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从设置`std::string`以存储屏幕上所有可见消息开始。之后，它就像遍历消息向量并将每条消息的文本追加到我们的本地`std::string`变量一样简单，在末尾加上换行符。最后，在检查本地变量并确保它不为空后，我们必须将我们的`m_content`成员（类型为`sf::Text`）设置为包含我们一直在推送消息的字符串，并在屏幕上绘制背景和文本。这就是`Textbox`类的全部内容。
- en: 'After adding an instance of `Textbox` as a member to our game class, we can
    start setting it up:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`Textbox`实例作为成员添加到我们的游戏类之后，我们可以开始设置它：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After passing some constant values to the `Setup` method of our `m_textbox`
    member, we immediately start using it right there in the constructor by actually
    outputting our first message. Let''s finish integrating it fully by making one
    last adjustment to the `Game::Render()` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在向我们的`m_textbox`成员的`Setup`方法传递一些常量值后，我们立即在构造函数中使用它，实际上输出我们的第一条消息。让我们通过最后调整`Game::Render()`方法来完全集成它：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It''s the same as both the classes we''ve implemented before this, except that
    the text box is now the last thing we draw, which means it will be displayed over
    everything else. After adding more messages to the game to be printed and compiling
    our project, we should end up with something like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在之前实现的所有类都一样，只是现在文本框是我们最后绘制的，这意味着它将显示在其他所有内容之上。在向游戏中添加更多要打印的消息并编译我们的项目后，我们最终应该得到如下所示的内容：
- en: '![Going the extra mile](img/4284_03_09.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![走得更远](img/4284_03_09.jpg)'
- en: This text box, in its most basic form, is the last addition to our snake game
    that we will be covering in this book. Feel free to play around with it and see
    what else you can come up with to spice up the game!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文本框，在其最基本的形式中，是我们将在本书中涵盖的蛇游戏中的最后一个新增功能。请随意尝试，看看你还能想出什么来让游戏更加有趣！
- en: Common mistakes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见错误
- en: 'A fairly common thing people often forget is the following line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常忘记的一个相当常见的事情是以下这一行：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you notice, the numbers being generated are exactly the same each time you
    launch the game-chances are that you haven't seeded the random number generator
    or you haven't provided a proper seed. It's recommended to always use a unix timestamp,
    as shown.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，每次启动游戏时生成的数字都是完全相同的，那么很可能是你没有对随机数生成器进行初始化，或者你没有提供一个合适的种子。建议始终使用Unix时间戳，如下所示。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The use of this particular random function should be restricted to something
    that isn't related to security and cryptography. Using it in combination with
    the modulus operator can produce incredibly non-uniform results due to the introduced
    bias.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 应该限制使用这个特定的随机函数，以避免与安全性和密码学相关。与模运算符结合使用时，由于引入的偏差，可能会产生非常不均匀的结果。
- en: 'Another fairly common problem is the programmers'' choice of the data container
    to hold their structures. Let''s take the following for example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当常见的问题是程序员选择的数据容器来存储他们的结构。以下是一个例子：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This defines the type of our `SnakeContainer`. If you''ve compiled the code
    we''ve written, you will notice that it runs fairly smoothly. Now consider this
    next line of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们的`SnakeContainer`的类型。如果你已经编译了我们编写的代码，你会注意到它运行得相当顺畅。现在考虑下一行代码：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because of the way these two containers are implemented in STL, nothing else
    changes in our code, so feel free to try to change the data type of your `SnakeContainer`
    from `std::vector` to `std::deque`. After compiling and running the project, you
    will definitely pick up on the hit on performance. Why is that happening? Well,
    even though `std::vector` and `std::deque` can be used basically in the same way,
    they're fundamentally different under the hood. The vector offers the certainty
    of its elements being contiguous in memory, while the double ended queue does
    not. There are also differences in performances, depending on where the most inserts
    and removals are done. If you're unsure about which container to use, make sure
    to either look it up or benchmark it yourself. Never just blindly assume, unless
    performance isn't the main concern to you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个容器在STL中的实现方式，我们的代码中没有任何其他变化，所以请随意尝试将你的`SnakeContainer`的数据类型从`std::vector`更改为`std::deque`。编译并运行项目后，你肯定会注意到性能的提升。为什么会这样呢？好吧，尽管`std::vector`和`std::deque`基本上可以以相同的方式使用，但它们在底层是根本不同的。向量提供了其元素在内存中连续的确定性，而双端队列则没有。根据插入和删除操作最频繁的位置，性能上也有差异。如果你不确定使用哪个容器，请确保查阅或自己进行基准测试。永远不要盲目假设，除非性能不是你主要关心的问题。
- en: Lastly, on a more open-ended note, don't be afraid to play with, modify, change,
    hack, or otherwise alter any piece of code that you see. The biggest mistake you
    can make is the mistake of not learning by breaking and fixing things. Consider
    the code we've written as only a push in the right direction and not a specific
    recipe. If understanding something better means you have to break it first, so
    be it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在更开放的话题上，不要害怕尝试、修改、更改、破解或以其他方式改变你看到的任何代码。你最大的错误可能是没有通过破坏和修复来学习。考虑我们编写的代码只是正确的方向上的一个推动，而不是一个具体的食谱。如果你必须先破坏它才能更好地理解某些东西，那就这么做吧。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Game development is a great journey to embark on. You had taken your first and
    second steps earlier, but now you have boarded the plane with your first, fully
    functional game in the bag. You are now officially a game developer! Where will
    this plane of opportunity take you and how long will it be there for? All of that
    is entirely up to you. While you're still not in the air, however, we will do
    our best to inspire you and show you all the different places to go to and the
    wonderful experiences to be had there. One thing is definitely for sure, however,
    and that is that this is not the end. If your enthusiasm has led you this far,
    there's only one direction to head to, and that's forward.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发是一次伟大的旅程，你之前已经迈出了第一步和第二步，但现在你已经带着你的第一个、功能齐全的游戏登上了飞机。你现在正式成为一名游戏开发者了！这架机会之飞机将带你到何方，它将停留多久？这一切完全取决于你。然而，在你还在空中之前，我们将尽我们所能来激励你，并展示你可以去的不同地方以及在那里可以获得的美好体验。然而，有一件事是肯定的，那就是这并不是终点。如果你的热情让你走到了这一步，那么只有一个方向可以前进，那就是向前。
- en: A lot was covered in this chapter, and now it's impossible to say that you haven't
    gotten your hands dirty while paying homage to one of the all time arcade classics.
    In the next chapter, we will take on input handling and event management in order
    to provide flexibility and fluent means of interaction between you and your application,
    all while introducing our brand new project for the next few chapters. There's
    still a lot to learn and many lines of code to write, so don't spend too much
    time hesitating to proceed onto the next chapter. A brand new adventure is waiting
    to unfold. See you there!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容，现在可以说你在向所有时代街机经典之一致敬时已经动手实践了。在下一章中，我们将处理输入处理和事件管理，以便在提供你与应用程序之间灵活和流畅的交互方式的同时，引入我们为下一章准备的新项目。还有很多东西要学习，还有很多代码要编写，所以不要花太多时间犹豫是否进入下一章。一场全新的冒险正在等待展开。在那里见！
