<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating an Application from Scratch</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now it's time to apply your knowledge! Since one of WebAssembly's primary design goals is to execute within and integrate well with the existing web platform, it makes sense to build a web application to test it out. Even though WebAssembly's current feature set is rather limited, we can utilize the technology at a basic level. In this chapter, we will build a single-page application from scratch that utilizes Wasm modules within the context of the <em>Core Specification</em>.</p>
<p class="mce-root">By the end of this chapter, you'll know how to:</p>
<ul>
<li class="mce-root">Write functions that perform simple computations with C</li>
<li class="mce-root">Build a basic JavaScript application with Vue</li>
<li class="mce-root">Integrate Wasm into your JavaScript application</li>
<li class="mce-root">Identify the capabilities and limitations of WebAssembly in its current form</li>
<li class="mce-root">Run and test a JavaScript application using <kbd>browser-sync</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cook the Books – making WebAssembly accountable</h1>
                </header>
            
            <article>
                
<p>As mentioned before, WebAssembly's current feature set is rather limited. We can use Emscripten to greatly extend the capabilities of a web application, but that carries the cost of noncompliance with the official specification and the addition of glue code. We can still use WebAssembly effectively today, which brings us to the application we'll build in this chapter. In this section, we will review the libraries and tools we'll use to build the application, as well as a brief overview of its functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview and functionality</h1>
                </header>
            
            <article>
                
<p>In WebAssembly's current form, we can pass numbers between a Wasm module and JavaScript code with relative ease. An accounting application seems like a logical choice in terms of real-world applicability. The only contention I have with accounting software is that it's a little boring (no offense). We're going to <em>spice it up</em> a bit by building in some unethical accounting practices. The application is named <em>Cook the Books</em>, a term associated with accounting fraud. Investopedia provides the following definition of Cook the Books:</p>
<div class="packt_quote">"Cook the Books is an idiom describing fraudulent activities performed by corporations in order to falsify their financial statements. Typically, cooking the books involves augmenting financial data to yield previously nonexistent earnings. Examples of techniques used to cook the books involve accelerating revenues, delaying expenses, manipulating pension plans, and implementing synthetic leases."</div>
<p>The Investopedia page at <a href="https://www.investopedia.com/terms/c/cookthebooks.asp">https://www.investopedia.com/terms/c/cookthebooks.asp</a> offers detailed examples of what constitutes cooking the books. We'll take a simple approach for our application. We will allow the user to enter a transaction with a raw and cooked amount. The raw amount represents the actual amount of money that was either deposited or withdrawn, while the cooked amount is what everyone else will see. The application will generate pie charts that display expenses and income by category for either the raw or cooked transactions. The user will be able to easily toggle between the two views. The application consists of the following components:</p>
<ul>
<li>Tabs for switching between transactions and charts</li>
<li>Table that displays transactions</li>
<li>Buttons that allow a user to add, edit, or remove a transaction</li>
<li>Modal dialog for adding/updating a transaction</li>
<li>Pie charts to display the income/expenses by category</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript libraries used</h1>
                </header>
            
            <article>
                
<p>The JavaScript portion of the application will use several libraries served from a CDN. It will also use one locally installed library to watch for changes in the code. The following sections will describe each library and its purpose in the application.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vue</h1>
                </header>
            
            <article>
                
<p>Vue is a JavaScript framework that allows you to split an application into individual components for ease of development and debugging. We're using it to avoid having one monolithic JavaScript file with all of our application logic and another monolithic HTML file with the entire UI. Vue was chosen because it doesn't require the added complexity of a build system and allows us to use HTML, CSS, and JavaScript without having to do any transpiling. The official website is <a href="https://vuejs.org">https://vuejs.org</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UIkit</h1>
                </header>
            
            <article>
                
<p>UIkit is the frontend framework we will use to add styling and layout to our application. There are dozens of alternatives, like Bootstrap or Bulma, that offer comparable components and functionality. But I chose UIkit because of the helpful utility classes and added JavaScript functionality. You can view the documentation at <a href="https://getuikit.com">https://getuikit.com</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lodash</h1>
                </header>
            
            <article>
                
<p>Lodash is an excellent utility library that provides methods for performing common actions in JavaScript that aren't already built into the language. We will use it to perform calculations and manipulate the transactions data. Documentation and installation instructions can be found at <a href="https://lodash.com">https://lodash.com</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data-driven documents</h1>
                </header>
            
            <article>
                
<p><span><strong>Data-driven documents</strong> (</span><strong>D3</strong>) is a multi-faceted library that allows you to translate data into impressive visualizations. D3's API consists of several modules that range from array manipulation to charting and transitions. We will use D3 primarily to create the pie charts, but we'll also take advantage of some of the utility methods it provides. You can find more information at <a href="https://d3js.org">https://d3js.org</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other libraries</h1>
                </header>
            
            <article>
                
<p>In order to display currency values in the correct format and ensure the user enters a valid dollar amount, we will utilize the <strong>accounting.js</strong> (<a href="http://openexchangerates.github.io/accounting.js">http://openexchangerates.github.io/accounting.js</a>) and <strong>vue-numeric</strong> (<a href="https://kevinongko.github.io/vue-numeric">https://kevinongko.github.io/vue-numeric</a>) libraries. To simplify development, we'll set up a basic <kbd>npm</kbd> project and use <strong>browser-sync</strong> (<a href="https://www.browsersync.io">https://www.browsersync.io</a>) to immediately see code changes reflected in the running application.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C and the build process</h1>
                </header>
            
            <article>
                
<p>The application uses C since we're performing simple calculations with basic algebra. It wouldn't make sense to use C++ in this case. That would introduce the added step of ensuring the functions we need to call from JavaScript are wrapped in an <kbd>extern</kbd> block. We'll write the calculation functions in a single C file and compile it down to a single Wasm module. We can continue to use VS Code's Tasks functionality to perform the build, but the arguments will need to be updated since we'll only compile a single file. Let's move on to project configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the project</h1>
                </header>
            
            <article>
                
<p>WebAssembly hasn't been around long enough to have established best practices with regard to folder structure, file naming conventions, and so on. If you were to search for best practices for C/C++ or JavaScript projects, you'd encounter a great deal of conflicting advice and strongly held opinions. With that in mind, let's spend this section setting up our project with the required configuration files.</p>
<p class="mce-root">The code for this project is located in the <kbd>/chapter-07-cook-the-books</kbd> folder in the <kbd>learn-webassembly</kbd> repository. You must have this code available when we get to the JavaScript portion of the application. I won't be providing the source code for all of the Vue components in the book, so you need to copy them from the repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring for Node.js</h1>
                </header>
            
            <article>
                
<p>In the interest of keeping the application as simple as possible, we'll avoid a build/bundling tool like Webpack or Rollup.js. This allows us to cut down on the number of required dependencies and ensures that any issues you run into aren't caused by a breaking change in a build dependency.</p>
<p class="mce-root">We'll create a Node.js project because it allows us to run scripts and install a dependency locally for development purposes. We've used the <kbd>/book-examples</kbd> folder up to this point, but we'll create a new project folder outside of <kbd>/book-examples</kbd> to configure a different default build task in VS Code. Open a terminal, <kbd>cd</kbd> into the desired folder, and enter the following commands:</p>
<pre>// Create a new directory and cd into it:<br/><strong>mkdir cook-the-books<br/>cd cook-the-books</strong><br/><br/>// Create a package.json file with default values<br/><strong>npm init -y</strong></pre>
<p class="mce-root">The <kbd>-y</kbd> command forgoes the prompts and populates the <kbd>package.json</kbd> file with sensible defaults. Once completed, run the following command to install <kbd>browser-sync</kbd>:</p>
<pre class="mce-root"><strong>npm install -D browser-sync@^2.24.4</strong></pre>
<p class="mce-root">The <kbd>-D</kbd> is optional and indicates that the library is a development dependency. You would use the <kbd>-D</kbd> flag if you were building and distributing the application, so I included it to adhere to common practice. I'd recommend installing that specific version to ensure the <kbd>start</kbd> script runs without any issues. After <kbd>browser-sync</kbd> installs, add the following entry to the <kbd>scripts</kbd> entry in the <kbd>package.json</kbd> file:</p>
<pre class="mce-root">...<br/>"scripts": {<br/> ...<br/> "start": "browser-sync start --server \"src\" --files \"src/**\" --single --no-open --port 4000"<br/>},<br/>…</pre>
<div class="mce-root packt_infobox">If you run <kbd>npm init</kbd> with the <kbd>-y</kbd> flag, there should be an existing script named <kbd>test</kbd>, which I omitted for clarity. If you didn't run it with the <kbd>-y</kbd> flag, you may need to create the <kbd>scripts</kbd> entry.</div>
<p class="mce-root">You can populate the <kbd>"description"</kbd> and <kbd>"author"</kbd> keys if desired. The file should end up looking similar to this:</p>
<pre>{<br/>  "name": "cook-the-books",<br/>  "version": "1.0.0",<br/>  "description": "Example application for Learn WebAssembly",<br/>  "main": "src/index.js",<br/>  "scripts": {<br/>    "start": "browser-sync start --server \"src\" --files \"src/**\" --single --no-open --port 4000",<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "Mike Rourke",<br/>  "license": "MIT",<br/>  "devDependencies": {<br/>    "browser-sync": "^2.24.4"<br/>  }<br/>}</pre>
<div class="packt_tip">If you omit the <kbd>--no-open</kbd> flag from the <kbd>start</kbd> script, the browser will open automatically. The flag was included to prevent issues with users running in a headless environment.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding files and folders</h1>
                </header>
            
            <article>
                
<p>Create two new folders within the root folder: <kbd>/lib</kbd> and <kbd>/src</kbd>. The JavaScript, HTML, CSS, and Wasm files will be located in the <kbd>/src</kbd> folder while the C file will be in <kbd>/lib</kbd>. I only want to include files that are used by the web application in <kbd>/src</kbd>. We'll never use the C file directly from the application, only the compiled output.</p>
<p class="mce-root">Copy the <kbd>/.vscode</kbd> folder from your <kbd>/book-examples</kbd> project into the root folder. This will ensure you're using the existing C/C++ settings and give you a good starting point for the build task.</p>
<div class="packt_infobox">If you're using macOS or Linux, you'll have to use the terminal to copy the folder; you can accomplish this by running the <kbd>cp -r command</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the build step</h1>
                </header>
            
            <article>
                
<p>We need to modify the default build step in the <kbd>/.vscode/tasks.json</kbd> file to accommodate our updated workflow. The arguments for the build step we used in our <kbd>/book-examples</kbd> project allowed us to compile whichever file was currently active in the editor. It also output the <kbd>.wasm</kbd> file into the same folder as the source C file. However, this configuration doesn't make sense for this project. We'll always compile the same C file that is output to the compiled <kbd>.wasm</kbd> file in a specific folder. To accomplish this, update the <kbd>args</kbd> array in the <kbd>Build</kbd> task in <kbd>/.vscode/tasks.json</kbd> with the following contents:</p>
<pre class="mce-root">"args": [<br/>  "${workspaceFolder}/lib/main.c",<br/>  "-Os",<br/>  "-s", "WASM=1",<br/>  "-s", "SIDE_MODULE=1",<br/>  "-s", "BINARYEN_ASYNC_COMPILATION=0",<br/>  "-o", "${workspaceFolder}/src/assets/main.wasm"<br/>],</pre>
<p class="mce-root"/>
<p class="mce-root">We changed the input and output paths, which are the first and last elements in the <kbd>args</kbd> array. Now both are static paths that always compile and output the same files regardless of which file is open in the active editor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a mock API</h1>
                </header>
            
            <article>
                
<p class="mce-root">We need some mock data and a means of persisting any updates. If you store the data locally in a JSON file, any changes you make to the transactions will be lost as soon as you refresh the page. We could set up a local server with a library like Express, mock a database, write routes, and so on. But instead we're going to take advantage of the excellent development tooling available online. The online too jsonstore.io is allows you to store JSON data for small projects and provides endpoints out of the box. Take the following steps to get your mock API up and running:</p>
<ol>
<li class="mce-root">Navigate to <a href="https://www.jsonstore.io/">https://www.jsonstore.io/</a> and press the <span class="packt_screen">Copy</span> button to copy the endpoint to your clipboard; this is the endpoint you'll be making HTTP requests to.</li>
<li class="mce-root">Go to the JSFiddle at <a href="https://jsfiddle.net/mikerourke/cta0km6d">https://jsfiddle.net/mikerourke/cta0km6d</a>, paste your jsonstore.io endpoint into the input, and press the <span class="packt_screen">Populate Data</span> button.</li>
<li class="mce-root">Open up a new tab and paste your jsonstore.io endpoint in the address bar and add <kbd>/transactions</kbd> to the end of the URL and press <em>Enter</em>. If you see the contents of the JSON file in your browser, the API setup was successful.</li>
</ol>
<p class="mce-root">Keep that jsonstore.io endpoint handy—you'll need it when we build the JavaScript portion of the app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Downloading the C stdlib Wasm</h1>
                </header>
            
            <article>
                
<p class="mce-root">We need the <kbd>malloc()</kbd> and <kbd>free()</kbd> functions from C's standard library for the functionality in our C code. WebAssembly doesn't have these functions built in, so we need to provide our own implementation.</p>
<p class="mce-root">Fortunately, someone has already built that for us; we just need to download the module and include it in the instantiation step. The module can be downloaded from Guy Bedford's <kbd>wasm-stdlib-hack</kbd> GitHub repository at <a href="https://github.com/guybedford/wasm-stdlib-hack">https://github.com/guybedford/wasm-stdlib-hack</a>. You need the <kbd>memory.wasm</kbd> file from the <kbd>/dist</kbd> folder. Once the file is downloaded, create a folder named <kbd>/assets</kbd> in the <kbd>/src</kbd> folder of your project and copy the <kbd>memory.wasm</kbd> file there.</p>
<p class="mce-root"/>
<div class="mce-root packt_tip">You can copy the <kbd>memory.wasm</kbd> file from the <kbd>/chapter-07-cook-the-books/src/assets</kbd> folder of the <kbd>learn-webassembly</kbd> repository instead of downloading it from GitHub.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The final result</h1>
                </header>
            
            <article>
                
<p class="mce-root">After performing these steps, your project should look like this:</p>
<pre>├── /.vscode<br/>│    ├── tasks.json<br/>│    └── c_cpp_properties.json<br/>├── /lib<br/>├── /src<br/>│    └── /assets<br/>│         └── memory.wasm<br/>├── package.json<br/>└── package-lock.json</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the C portion</h1>
                </header>
            
            <article>
                
<p>The C portion of the application will aggregate transaction and category amounts. The calculations we perform in C could be done just as easily in JavaScript, but WebAssembly is ideal for computation. We'll dive deeper into more complex usage of C/C++ in <a href="384a3356-a9ca-4c3c-99e7-e632c6228a0b.xhtml">Chapter 8</a>, <em>Porting a Game with Emscripten</em>, but for now we're trying to limit our scope to what can be done within the confines of the <em>Core Specification</em>. In this section, we'll write some C code to demonstrate how to integrate WebAssembly with a web application without the use of Emscripten.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview</h1>
                </header>
            
            <article>
                
<p>We will write some C functions that calculate the grand totals as well as the ending balances for raw and cooked transactions. In addition to calculating the grand totals, we need to calculate the totals for each category for display in the pie charts. All of these calculations will be performed in a single C file and compiled down to a single Wasm file that will be instantiated when the application loads. C can be a little daunting for the uninitiated, so our code will be sacrificing some efficiency for the sake of clarity. I'd like to take a moment to apologize to the C/C++ programmers reading this book; you're not going to like what you C.</p>
<p class="mce-root"/>
<p class="mce-root">In order to perform calculations dynamically, we need to allocate and deallocate memory as transactions are added and deleted. To accomplish this, we'll use a <strong>doubly linked list</strong>. A doubly linked list is a data structure that allows us to remove items or <em>nodes</em> inside a list and add and edit nodes as needed. Nodes are added using <kbd>malloc()</kbd> and removed using <kbd>free()</kbd>, both of which are provided by the <kbd>memory.wasm</kbd> module you downloaded in the previous section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A note regarding workflow</h1>
                </header>
            
            <article>
                
<p>The order of operations in terms of development doesn't reflect how you would normally build an application that uses WebAssembly. The workflow would consist of jumping between C/C++ and JavaScript to achieve the desired results. In this case, the functionality that we're offloading from JavaScript into WebAssembly is already known, so we'll write the C code up front.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C file contents</h1>
                </header>
            
            <article>
                
<p>Let's walk through each section of the C file. Create a file in the <kbd>/lib</kbd> folder named <kbd>main.c</kbd> and populate it with the following contents in each section. It'll be easier to comprehend what's happening in the C file if we break it into smaller chunks. Let's start with the <em>Declarations </em>section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declarations</h1>
                </header>
            
            <article>
                
<p>The first section contains declarations we will use to create and traverse the doubly linked list, as follows:</p>
<pre class="mce-root">#include &lt;stdlib.h&gt;<br/><br/>struct Node {<br/>  int id;<br/>  int categoryId;<br/>  float rawAmount;<br/>  float cookedAmount;<br/>  struct Node *next;<br/>  struct Node *prev;<br/>};<br/><br/>typedef enum {<br/>  RAW = 1,<br/>  COOKED = 2<br/>} AmountType;<br/><br/>struct Node *transactionsHead = NULL;<br/>struct Node *categoriesHead = NULL;</pre>
<p class="mce-root">The <kbd>Node</kbd> struct is used to represent a transaction or category. The <kbd>transactionsHead</kbd> and <kbd>categoriesHead</kbd> node instances represent the first node in each linked list we'll use (one for transactions and one for categories). The <kbd>AmountType</kbd> the <kbd>enum</kbd> isn't required, but we'll discuss how it's useful when we get to the section of code that utilizes it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linked list operations</h1>
                </header>
            
            <article>
                
<p class="mce-root">The second section contains the two functions used to add and delete nodes from the linked list:</p>
<pre class="mce-root">void deleteNode(struct Node **headNode, struct Node *delNode) {<br/>    // Base case:<br/>    if (*headNode == NULL || delNode == NULL) return;<br/><br/>    // If node to be deleted is head node:<br/>    if (*headNode == delNode) *headNode = delNode-&gt;next;<br/><br/>    // Change next only if node to be deleted is NOT the last node:<br/>    if (delNode-&gt;next != NULL) delNode-&gt;next-&gt;prev = delNode-&gt;prev;<br/><br/>    // Change prev only if node to be deleted is NOT the first node:<br/>    if (delNode-&gt;prev != NULL) delNode-&gt;prev-&gt;next = delNode-&gt;next;<br/><br/>    // Finally, free the memory occupied by delNode:<br/>    free(delNode);<br/>}<br/><br/>void appendNode(struct Node **headNode, int id, int categoryId,<br/>                float rawAmount, float cookedAmount) {<br/>    // 1. Allocate node:<br/>    struct Node *newNode = (struct Node *) malloc(sizeof(struct Node));<br/>    struct Node *last = *headNode; // Used in Step 5<br/><br/>    // 2. Populate with data:<br/>    newNode-&gt;id = id;<br/>    newNode-&gt;categoryId = categoryId;<br/>    newNode-&gt;rawAmount = rawAmount;<br/>    newNode-&gt;cookedAmount = cookedAmount;<br/><br/>    // 3. This new node is going to be the last node, so make next NULL:<br/>    newNode-&gt;next = NULL;<br/><br/>    // 4. If the linked list is empty, then make the new node as head:<br/>    if (*headNode == NULL) {<br/>        newNode-&gt;prev = NULL;<br/>        *headNode = newNode;<br/>        return;<br/>    }<br/><br/>    // 5. Otherwise, traverse till the last node:<br/>    while (last-&gt;next != NULL) {<br/>        last = last-&gt;next;<br/>    }<br/><br/>    // 6. Change the next of last node:<br/>    last-&gt;next = newNode;<br/><br/>    // 7. Make last node as previous of new node:<br/>    newNode-&gt;prev = last;<br/>}</pre>
<p class="mce-root">The comments within the code describe what's happening at each step. When we need to add a Node to the list, we have to allocate the memory taken up by the <kbd>struct</kbd><span><span> </span></span><kbd>Node</kbd> using <kbd>malloc()</kbd> and append it to the last node in the linked list. If we need to delete a node, we have to remove it from the linked list and deallocate the memory that the node was using by calling the <kbd>free()</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">transactions operations</h1>
                </header>
            
            <article>
                
<p class="mce-root">The third section contains functions to add, edit, and remove transactions from the <kbd>transactions</kbd> linked list, as follows:</p>
<pre class="mce-root">struct Node *findNodeById(int id, struct Node *withinNode) {<br/>    struct Node *node = withinNode;<br/>    while (node != NULL) {<br/>        if (node-&gt;id == id) return node;<br/>        node = node-&gt;next;<br/>    }<br/>    return NULL;<br/>}<br/><br/>void addTransaction(int id, int categoryId, float rawAmount,<br/>                    float cookedAmount) {<br/>    appendNode(&amp;transactionsHead, id, categoryId, rawAmount, cookedAmount);<br/>}<br/><br/>void editTransaction(int id, int categoryId, float rawAmount,<br/>                     float cookedAmount) {<br/>    struct Node *foundNode = findNodeById(id, transactionsHead);<br/>    if (foundNode != NULL) {<br/>        foundNode-&gt;categoryId = categoryId;<br/>        foundNode-&gt;rawAmount = rawAmount;<br/>        foundNode-&gt;cookedAmount = cookedAmount;<br/>    }<br/>}<br/><br/>void removeTransaction(int id) {<br/>    struct Node *foundNode = findNodeById(id, transactionsHead);<br/>    if (foundNode != NULL) deleteNode(&amp;transactionsHead, foundNode);<br/>}</pre>
<p class="mce-root">The <kbd>appendNode()</kbd> and <kbd>deleteNode()</kbd> functions we reviewed in the previous section aren't intended to be called from the JavaScript code. Instead, calls to <kbd>addTransaction()</kbd>, <kbd>editTransaction()</kbd>, and <kbd>removeTransaction()</kbd> are used to update the local linked list. The <kbd>addTransaction()</kbd> function calls the <kbd>appendNode()</kbd> function to add the data passed in as arguments to a new node in the local linked list. The <kbd>removeTransaction()</kbd> calls the <kbd>deleteNode()</kbd> function to delete the corresponding transaction node. The <kbd>findNodeById()</kbd> function is used to determine which node needs to be updated or deleted within the linked list based on the specified ID.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">transactions calculations</h1>
                </header>
            
            <article>
                
<p class="mce-root">The fourth section contains functions to calculate the grand totals and final balances for raw and cooked <kbd>transactions</kbd>, as follows:</p>
<pre class="mce-root">void calculateGrandTotals(float *totalRaw, float *totalCooked) {<br/>    struct Node *node = transactionsHead;<br/>    while (node != NULL) {<br/>        *totalRaw += node-&gt;rawAmount;<br/>        *totalCooked += node-&gt;cookedAmount;<br/>        node = node-&gt;next;<br/>    }<br/>}<br/><br/>float getGrandTotalForType(AmountType type) {<br/>    float totalRaw = 0;<br/>    float totalCooked = 0;<br/>    calculateGrandTotals(&amp;totalRaw, &amp;totalCooked);<br/><br/>    if (type == RAW) return totalRaw;<br/>    if (type == COOKED) return totalCooked;<br/>    return 0;<br/>}<br/><br/>float getFinalBalanceForType(AmountType type, float initialBalance) {<br/>    float totalForType = getGrandTotalForType(type);<br/>    return initialBalance + totalForType;<br/>}</pre>
<p class="mce-root">The <kbd>AmountType enum</kbd> we declared in the declarations section is used here to avoid <strong>magic numbers</strong>. It makes it easy to remember that <kbd>1</kbd> represents raw transactions and <kbd>2</kbd> represents cooked transactions. The grand totals for both raw and cooked transactions are calculated in the <kbd>calculateGrandTotals()</kbd> function, even though we're only asking for one type in <kbd>getGrandTotalForType()</kbd>. Since we can only return a single value from a Wasm function, we end up looping through all of the transactions twice when we call <kbd>getGrandTotalForType()</kbd> for both raw and cooked transactions. With a relatively small amount of transactions and the simplicity of the calculation, this doesn't present any issues. The <kbd>getFinalBalanceForType()</kbd> returns the grand total plus the specified <kbd>initialBalance</kbd>. You'll see this in action when we add the ability to change initial balances in the web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category calculations</h1>
                </header>
            
            <article>
                
<p class="mce-root">The fifth and final section contains functions to calculate totals by category, which we'll utilize in the pie charts, as follows:</p>
<pre class="mce-root">void upsertCategoryNode(int categoryId, float transactionRaw,<br/>                        float transactionCooked) {<br/>    struct Node *foundNode = findNodeById(categoryId, categoriesHead);<br/>    if (foundNode != NULL) {<br/>        foundNode-&gt;rawAmount += transactionRaw;<br/>        foundNode-&gt;cookedAmount += transactionCooked;<br/>    } else {<br/>        appendNode(&amp;categoriesHead, categoryId, categoryId, transactionRaw,<br/>                   transactionCooked);<br/>    }<br/>}<br/><br/>void buildValuesByCategoryList() {<br/>    struct Node *node = transactionsHead;<br/>    while (node != NULL) {<br/>        upsertCategoryNode(node-&gt;categoryId, node-&gt;rawAmount,<br/>                           node-&gt;cookedAmount);<br/>        node = node-&gt;next;<br/>    }<br/>}<br/><br/>void recalculateForCategories() {<br/>    categoriesHead = NULL;<br/>    buildValuesByCategoryList();<br/>}<br/><br/>float getCategoryTotal(AmountType type, int categoryId) {<br/>    // Ensure the category totals have been calculated:<br/>    if (categoriesHead == NULL) buildValuesByCategoryList();<br/> <br/>    struct Node *categoryNode = findNodeById(categoryId, categoriesHead);<br/>    if (categoryNode == NULL) return 0;<br/><br/>    if (type == RAW) return categoryNode-&gt;rawAmount;<br/>    if (type == COOKED) return categoryNode-&gt;cookedAmount;<br/>    return 0;<br/>}</pre>
<p class="mce-root">The <kbd>buildValuesByCategoryList()</kbd> function is called whenever the <kbd>recalculateForCategories()</kbd> or <kbd>getCategoryTotal()</kbd> functions are called. The function loops through all of the transactions in the <kbd>transactions</kbd> linked list and creates a node in a separate linked list for each corresponding category with the aggregated raw and total amounts. The <kbd>upsertCategoryNode()</kbd> function looks for a node that corresponds to the <kbd>categoryId</kbd> in the <kbd>categories</kbd> linked list. If it finds it, the raw and cooked transaction amounts are added to the existing amounts on that node, otherwise a new node is created for said category. The <kbd>recalculateForCategories()</kbd> function is called to ensure the category totals are up to date with any transactions changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling to Wasm</h1>
                </header>
            
            <article>
                
<p>After populating the file, we need to compile it down to Wasm for use in the JavaScript portion of the application. Run the build task by selecting <span class="packt_screen">Tasks | Run Build Task...</span> from the menu or using the keyboard shortcut <em>Cmd</em>/<em>Ctrl</em> + <em>Shift</em> + <em>B</em>. If the build was successful, you'll see a file named <kbd>main.wasm</kbd> in the <kbd>/src/assets</kbd> folder. If an error occurred, the terminal should provide details on how to resolve it.</p>
<p>If you're not using VS Code, open a terminal instance in the <kbd>/cook-the-books</kbd> folder and run the following command:</p>
<pre><strong>emcc lib/main.c -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o src/assets/main.wasm</strong></pre>
<p>That's it for the C code. Let's move on to the JavaScript portion.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the JavaScript portion</h1>
                </header>
            
            <article>
                
<p>The JavaScript portion of the application presents the transactions data to the user and allows them to easily add, edit, and remove transactions. The application is split across several files to simplify the development process and uses the libraries described in the <em>JavaScript libraries used</em> section of this chapter. In this section, we will build the application step by step, starting with the API and global state interaction layer. We'll write functions to instantiate and interact with our Wasm module and review the Vue components required to build the user interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview</h1>
                </header>
            
            <article>
                
<p>The application is broken down into contexts to simplify the development process. We'll build the application from the bottom up to ensure we don't have to bounce back and forth between the different contexts when writing code. We'll start with the Wasm interaction code, then move on to the global store and API interaction. I'll describe the purpose of each Vue component, but the source code will only be provided for a select few. If you're following along and wish to run the application locally, you'll need to copy the <kbd>/src/components</kbd> folder from the <kbd>/chapter-07-cook-the-books</kbd> folder in the <kbd>learn-webassembly</kbd> repository into the <kbd>/src</kbd> folder of your project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A note about browser compatibility</h1>
                </header>
            
            <article>
                
<p>Before we start writing any code, you must ensure your browser supports the newer JavaScript features we'll use in the application. Your browser has to support ES Modules (<kbd>import</kbd> and <kbd>export</kbd>), the Fetch API, and <kbd>async</kbd> / <kbd>await</kbd>. You need at least Version 61 of Google Chrome or Version 60 of Firefox. You can check which version you're currently using by selecting <span class="packt_screen">About Chrome</span> or <span class="packt_screen">About Firefox</span> from the menu bar. I'm currently running the application with Chrome Version 67 and Firefox Version 61 without any issues.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Wasm instance in initializeWasm.js</h1>
                </header>
            
            <article>
                
<p>You should have two compiled Wasm files in the <kbd>/src/assets</kbd> folder of your project: <kbd>main.wasm</kbd> and <kbd>memory.wasm</kbd>. Since we need to utilize the <kbd>malloc()</kbd> and <kbd>free()</kbd> functions exported from <kbd>memory.wasm</kbd> in the <kbd>main.wasm</kbd> code, our loading code is going to look different from the earlier examples. Create a file in the <kbd>/src/store</kbd> folder named <kbd>initializeWasm.js</kbd> and populate it with the following contents:</p>
<pre>/**<br/> * Returns an array of compiled (not instantiated!) Wasm modules.<br/> * We need the main.wasm file we created, as well as the memory.wasm file<br/> * that allows us to use C functions like malloc() and free().<br/> */<br/>const fetchAndCompileModules = () =&gt;<br/>  Promise.all(<br/>    ['../assets/main.wasm', '../assets/memory.wasm'].map(fileName =&gt;<br/>      fetch(fileName)<br/>        .then(response =&gt; {<br/>          if (response.ok) return response.arrayBuffer();<br/>          throw new Error(`Unable to fetch WebAssembly file: ${fileName}`);<br/>        })<br/>        .then(bytes =&gt; WebAssembly.compile(bytes))<br/>    )<br/>  );<br/><br/>/**<br/> * Returns an instance of the compiled "main.wasm" file.<br/> */<br/>const instantiateMain = (compiledMain, memoryInstance, wasmMemory) =&gt; {<br/>  const memoryMethods = memoryInstance.exports;<br/>  return WebAssembly.instantiate(compiledMain, {<br/>    env: {<br/>      memoryBase: 0,<br/>      tableBase: 0,<br/>      memory: wasmMemory,<br/>      table: new WebAssembly.Table({ initial: 16, element: 'anyfunc' }),<br/>      abort: console.log,<br/>      _consoleLog: value =&gt; console.log(value),<br/>      _malloc: memoryMethods.malloc,<br/>      _free: memoryMethods.free<br/>    }<br/>  });<br/>};<br/><br/>/**<br/> * Compiles and instantiates the "memory.wasm" and "main.wasm" files and<br/> * returns the `exports` property from main's `instance`.<br/> */<br/>export default async function initializeWasm() {<br/>  const wasmMemory = new WebAssembly.Memory({ initial: 1024 });<br/>  const [compiledMain, compiledMemory] = await fetchAndCompileModules();<br/><br/>  const memoryInstance = await WebAssembly.instantiate(compiledMemory, {<br/>    env: {<br/>      memory: wasmMemory<br/>    }<br/>  });<br/><br/>  const mainInstance = await instantiateMain(<br/>    compiledMain,<br/>    memoryInstance,<br/>    wasmMemory<br/>  );<br/><br/>  return mainInstance.exports;<br/>}</pre>
<p class="mce-root">The file's default <kbd>export</kbd> function, <kbd>initializeWasm()</kbd>, performs the following steps:</p>
<ol>
<li class="mce-root">Create a new <kbd>WebAssembly.Memory</kbd> instance (<kbd>wasmMemory</kbd>).</li>
<li class="mce-root">Call the <kbd>fetchAndCompileModules()</kbd> function to get a <kbd>WebAssembly.Module</kbd> instance for <kbd>memory.wasm</kbd> (<kbd>compiledMemory</kbd>) and <kbd>main.wasm</kbd> (<kbd>compiledMain</kbd>).</li>
<li class="mce-root">Instantiate <kbd>compiledMemory</kbd> (<kbd>memoryInstance</kbd>) and pass the <kbd>wasmMemory</kbd> into the <kbd>importObj</kbd>.</li>
<li class="mce-root">Pass <kbd>compiledMain</kbd>, <kbd>memoryInstance</kbd>, and <kbd>wasmMemory</kbd> into the <kbd>instantiateMain()</kbd> function.</li>
<li class="mce-root">Instantiate <kbd>compiledMain</kbd> and pass the exported <kbd>malloc()</kbd> and <kbd>free()</kbd> functions from <kbd>memoryInstance</kbd> along with <kbd>wasmMemory</kbd> into the <kbd>importObj</kbd>.</li>
<li class="mce-root">Return the <kbd>exports</kbd> property of the <kbd>Instance</kbd> returned from <kbd>instantiateMain</kbd> (<kbd>mainInstance</kbd>).</li>
</ol>
<p class="mce-root">As you can see, the process is more complex when you have dependencies within Wasm modules.</p>
<div class="mce-root packt_infobox">You may have noticed that the <kbd>malloc</kbd> and <kbd>free</kbd> methods on the <kbd>memoryInstance</kbd> <kbd>exports</kbd> property weren't prefixed with an underscore. This is because the <kbd>memory.wasm</kbd> file was compiled using LLVM without Emscripten, which doesn't add the <kbd>_</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with Wasm in WasmTransactions.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">We will use JavaScript's <kbd>class</kbd> syntax to create a wrapper that encapsulates the Wasm interaction functions. This allows us to make changes to the C code quickly without having to search through the entire application to find where Wasm functions are being called. If you rename a method in the C file, you only need to rename it one place. Create a new file in the <kbd>/src/store</kbd> folder named <kbd>WasmTransactions.js</kbd> and populate it with the following contents:</p>
<pre>import initializeWasm from './initializeWasm.js';<br/><br/>/**<br/> * Class used to wrap the functionality from the Wasm module (rather<br/> * than access it directly from the Vue components or store).<br/> * @class<br/> */<br/>export default class WasmTransactions {<br/>  constructor() {<br/>    this.instance = null;<br/>    this.categories = [];<br/>  }<br/><br/>  async initialize() {<br/>    this.instance = await initializeWasm();<br/>    return this;<br/>  }<br/><br/>  getCategoryId(category) {<br/>    return this.categories.indexOf(category);<br/>  }<br/><br/>  // Ensures the raw and cooked amounts have the proper sign (withdrawals<br/>  // are negative and deposits are positive).<br/>  getValidAmounts(transaction) {<br/>    const { rawAmount, cookedAmount, type } = transaction;<br/>    const getAmount = amount =&gt;<br/>      type === 'Withdrawal' ? -Math.abs(amount) : amount;<br/>    return {<br/>      validRaw: getAmount(rawAmount),<br/>      validCooked: getAmount(cookedAmount)<br/>    };<br/>  }<br/><br/>  // Adds the specified transaction to the linked list in the Wasm module.<br/>  addToWasm(transaction) {<br/>    const { id, category } = transaction;<br/>    const { validRaw, validCooked } = this.getValidAmounts(transaction);<br/>    const categoryId = this.getCategoryId(category);<br/>    this.instance._addTransaction(id, categoryId, validRaw, validCooked);<br/>  }<br/><br/>  // Updates the transaction node in the Wasm module:<br/>  editInWasm(transaction) {<br/>    const { id, category } = transaction;<br/>    const { validRaw, validCooked } = this.getValidAmounts(transaction);<br/>    const categoryId = this.getCategoryId(category);<br/>    this.instance._editTransaction(id, categoryId, validRaw, validCooked);<br/>  }<br/><br/>  // Removes the transaction node from the linked list in the Wasm module:<br/>  removeFromWasm(transactionId) {<br/>    this.instance._removeTransaction(transactionId);<br/>  }<br/><br/>  // Populates the linked list in the Wasm module. The categories are<br/>  // needed to set the categoryId in the Wasm module.<br/>  populateInWasm(transactions, categories) {<br/>    this.categories = categories;<br/>    transactions.forEach(transaction =&gt; this.addToWasm(transaction));<br/>  }<br/><br/>  // Returns the balance for raw and cooked transactions based on the<br/>  // specified initial balances.<br/>  getCurrentBalances(initialRaw, initialCooked) {<br/>    const currentRaw = this.instance._getFinalBalanceForType(<br/>      AMOUNT_TYPE.raw,<br/>      initialRaw<br/>    );<br/>    const currentCooked = this.instance._getFinalBalanceForType(<br/>      AMOUNT_TYPE.cooked,<br/>      initialCooked<br/>    );<br/>    return { currentRaw, currentCooked };<br/>  }<br/><br/>  // Returns an object that has category totals for all income (deposit)<br/>  // and expense (withdrawal) transactions.<br/>  getCategoryTotals() {<br/>    // This is done to ensure the totals reflect the most recent<br/>    // transactions:<br/>    this.instance._recalculateForCategories();<br/>    const categoryTotals = this.categories.map((category, idx) =&gt; ({<br/>      category,<br/>      id: idx,<br/>      rawTotal: this.instance._getCategoryTotal(AMOUNT_TYPE.raw, idx),<br/>      cookedTotal: this.instance._getCategoryTotal(AMOUNT_TYPE.cooked, idx)<br/>    }));<br/><br/>    const totalsByGroup = { income: [], expenses: [] };<br/>    categoryTotals.forEach(categoryTotal =&gt; {<br/>      if (categoryTotal.rawTotal &lt; 0) {<br/>        totalsByGroup.expenses.push(categoryTotal);<br/>      } else {<br/>        totalsByGroup.income.push(categoryTotal);<br/>      }<br/>    });<br/>    return totalsByGroup;<br/>  }<br/>}</pre>
<p class="mce-root">When the <kbd>initialize()</kbd> function is called on an instance of the class, the return value of the <kbd>initializeWasm()</kbd> function is assigned to the <kbd>instance</kbd> property of the class. The <kbd>class</kbd> methods call functions from <kbd>this.instance</kbd> and, if applicable, return the desired results. Note the <kbd>AMOUNT_TYPE</kbd> object referenced in the <kbd>getCurrentBalances()</kbd> and <kbd>getCategoryTotals()</kbd> functions. This corresponds to the <kbd>AmountType enum</kbd> in our C file. The <kbd>AMOUNT_TYPE</kbd> object is declared globally in the <kbd>/src/main.js</kbd> file where the application is loaded. Now that we have our Wasm interaction code written, let's move on to API interaction code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing the API in api.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">The API provides means for adding, editing, removing, and querying transactions in the form of HTTP methods defined on a fetch call. To simplify the process of performing these actions, we'll write some API <kbd>wrapper</kbd> functions. Create a file in the <kbd>/src/store</kbd> folder named <kbd>api.js</kbd> and populate it with the following contents:</p>
<pre>// Paste your jsonstore.io endpoint here (no ending slash):<br/>const API_URL = '[JSONSTORE.IO ENDPOINT]';<br/><br/>/**<br/> * Wrapper for performing API calls. We don't want to call response.json()<br/> * each time we make a fetch call.<br/> * @param {string} endpoint Endpoint (e.g. "/transactions" to make API call to<br/> * @param {Object} init Fetch options object containing any custom settings<br/> * @returns {Promise&lt;*&gt;}<br/> * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch<br/> */<br/>const performApiFetch = (endpoint = '', init = {}) =&gt;<br/>  fetch(`${API_URL}${endpoint}`, {<br/>    headers: {<br/>      'Content-type': 'application/json'<br/>    },<br/>    ...init<br/>  }).then(response =&gt; response.json());<br/><br/>export const apiFetchTransactions = () =&gt;<br/>  performApiFetch('/transactions').then(({ result }) =&gt;<br/>    /*<br/>     * The response object looks like this:<br/>     * {<br/>     *   "result": {<br/>     *     "1": {<br/>     *       "category": "Sales Revenue",<br/>     *       ...<br/>     *     },<br/>     *     "2": {<br/>     *       "category": "Hotels",<br/>     *       ...<br/>     *     },<br/>     *     ...<br/>     *   }<br/>     * }<br/>     * We need the "1" and "2" values for deleting or editing existing<br/>     * records, so we store that in the transaction record as "apiId".<br/>     */<br/>    Object.keys(result).map(apiId =&gt; ({<br/>      ...result[apiId],<br/>      apiId<br/>    }))<br/>  );<br/><br/>export const apiEditTransaction = transaction =&gt;<br/>  performApiFetch(`/transactions/${transaction.apiId}`, {<br/>    method: 'POST',<br/>    body: JSON.stringify(transaction)<br/>  });<br/><br/>export const apiRemoveTransaction = transaction =&gt;<br/>  performApiFetch(`/transactions/${transaction.apiId}`, {<br/>    method: 'DELETE'<br/>  });<br/><br/>export const apiAddTransaction = transaction =&gt;<br/>  performApiFetch(`/transactions/${transaction.apiId}`, {<br/>    method: 'POST',<br/>    body: JSON.stringify(transaction)<br/>  });</pre>
<p class="mce-root">You'll need the jsonstore.io endpoint you created in the <em>Setting up the project</em> section in order to interact with the API. Replace <kbd>[JSONSTORE.IO ENDPOINT]</kbd> with your jsonstore.io endpoint. Ensure the endpoint doesn't end with a forward slash or the word transactions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing global state in store.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">The file that manages global state in the application has a lot of moving parts. Consequently, we will break the code down into smaller chunks and walk through each section individually. Create a file in the <kbd>/src/store</kbd> folder named <kbd>store.js</kbd> and populate it with the contents from each of the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The import and store declarations</h1>
                </header>
            
            <article>
                
<p class="mce-root">The first section contains <kbd>import</kbd> statements and the <kbd>wasm</kbd> and <kbd>state</kbd> properties on the exported <kbd>store</kbd> object, as follows:</p>
<pre>import {<br/>  apiFetchTransactions,<br/>  apiAddTransaction,<br/>  apiEditTransaction,<br/>  apiRemoveTransaction<br/>} from './api.js';<br/>import WasmTransactions from './WasmTransactions.js';<br/><br/>export const store = {<br/>  wasm: null,<br/>  state: {<br/>    transactions: [],<br/>    activeTransactionId: 0,<br/>    balances: {<br/>      initialRaw: 0,<br/>      currentRaw: 0,<br/>      initialCooked: 0,<br/>      currentCooked: 0<br/>    }<br/>  },<br/>  ...</pre>
<p class="mce-root"/>
<p class="mce-root">All API interaction is limited to the <kbd>store.js</kbd> file. Since we need to manipulate, add, and search transactions, all of the exported functions from <kbd>api.js</kbd> are imported. The <kbd>store</kbd> object holds the <kbd>WasmTransactions</kbd> instance in the <kbd>wasm</kbd> property and initial state in the <kbd>state</kbd> property. The values in <kbd>state</kbd> are referenced in multiple locations throughout the application. The <kbd>store</kbd> object will be added to the global <kbd>window</kbd> object when the application loads, so all components have access to the global state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transactions operations</h1>
                </header>
            
            <article>
                
<p class="mce-root">The second section contains functions that manage transactions in the Wasm instance (through the <kbd>WasmTransactions</kbd> instance) and the API, as follows:</p>
<pre>...<br/>  getCategories() {<br/>    const categories = this.state.transactions.map(<br/>      ({ category }) =&gt; category<br/>    );<br/>    // Remove duplicate categories and sort the names in ascending order:<br/>    return _.uniq(categories).sort();<br/>  },<br/><br/>  // Populate global state with the transactions from the API response:<br/>  populateTransactions(transactions) {<br/>    const sortedTransactions = _.sortBy(transactions, [<br/>      'transactionDate',<br/>      'id'<br/>    ]);<br/>    this.state.transactions = sortedTransactions;<br/>    store.wasm.populateInWasm(sortedTransactions, this.getCategories());<br/>    this.recalculateBalances();<br/>  },<br/><br/>  addTransaction(newTransaction) {<br/>    // We need to assign a new ID to the transaction, so this just adds<br/>    // 1 to the current maximum transaction ID:<br/>    newTransaction.id = _.maxBy(this.state.transactions, 'id').id + 1;<br/>    store.wasm.addToWasm(newTransaction);<br/>    apiAddTransaction(newTransaction).then(() =&gt; {<br/>      this.state.transactions.push(newTransaction);<br/>      this.hideTransactionModal();<br/>    });<br/>  },<br/><br/>  editTransaction(editedTransaction) {<br/>    store.wasm.editInWasm(editedTransaction);<br/>    apiEditTransaction(editedTransaction).then(() =&gt; {<br/>      this.state.transactions = this.state.transactions.map(<br/>        transaction =&gt; {<br/>          if (transaction.id === editedTransaction.id) {<br/>            return editedTransaction;<br/>          }<br/>          return transaction;<br/>        }<br/>      );<br/>      this.hideTransactionModal();<br/>    });<br/>  },<br/><br/>  removeTransaction(transaction) {<br/>    const transactionId = transaction.id;<br/>    store.wasm.removeFromWasm(transactionId);<br/><br/>    // We're passing the whole transaction record into the API call<br/>    // for the sake of consistency:<br/>    apiRemoveTransaction(transaction).then(() =&gt; {<br/>      this.state.transactions = this.state.transactions.filter(<br/>        ({ id }) =&gt; id !== transactionId<br/>      );<br/>      this.hideTransactionModal();<br/>    });<br/>  },<br/>...</pre>
<p class="mce-root">The <kbd>populateTransactions()</kbd> function fetches all of the transactions from the API and loads them into the global state and the Wasm instance. The category names are extrapolated from the <kbd>transactions</kbd> array in the <kbd>getCategories()</kbd> function. The results are passed to the <kbd>WasmTransactions</kbd> instance when <kbd>store.wasm.populateInWasm()</kbd> is called.</p>
<p class="mce-root">The <kbd>addTransaction()</kbd>, <kbd>editTransaction()</kbd>, and <kbd>removeTransaction()</kbd> functions perform the actions that correspond with their names. All three functions manipulate the Wasm instance and update the data on the API through a fetch call. Each of the functions call <kbd>this.hideTransactionModal()</kbd> because changes to a transaction can only be made through the <kbd>TransactionModal</kbd> component. Once the change is successfully made, the modal should close. Let's look at the <kbd>TransactionModal</kbd> management code next.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TransactionModal management</h1>
                </header>
            
            <article>
                
<p class="mce-root">The third section contains functions to manage the visibility and content of the <kbd>TransactionModal</kbd> component (located in <kbd>/src/components/TransactionsTab/TransactionModal.js</kbd>) as follows:</p>
<pre>...<br/>  showTransactionModal(transactionId) {<br/>    this.state.activeTransactionId = transactionId || 0;<br/>    const transactModal = document.querySelector('#transactionModal');<br/>    UIkit.modal(transactModal).show();<br/>  },<br/><br/>  hideTransactionModal() {<br/>    this.state.activeTransactionId = 0;<br/>    const transactModal = document.querySelector('#transactionModal');<br/>    UIkit.modal(transactModal).hide();<br/>  },<br/><br/>  getActiveTransaction() {<br/>    const { transactions, activeTransactionId } = this.state;<br/>    const foundTransaction = transactions.find(transaction =&gt;<br/>      transaction.id === activeTransactionId);<br/>    return foundTransaction || { id: 0 };<br/>  },<br/>...</pre>
<p class="mce-root">The <kbd>showTransactionModal()</kbd> and <kbd>hideTransactionModal()</kbd> functions should be self-explanatory. The <kbd>hide()</kbd> or <kbd>show()</kbd> method of <kbd>UIkit.modal()</kbd> is called on the DOM element representing the <kbd>TransactionModal</kbd>. The <kbd>getActiveTransaction()</kbd> function returns the transaction record associated with the <kbd>activeTransactionId</kbd> value in global state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Balances calculation</h1>
                </header>
            
            <article>
                
<p class="mce-root">The fourth section contains functions that calculate and update the balances object in global state:</p>
<pre>...<br/>  updateInitialBalance(amount, fieldName) {<br/>    this.state.balances[fieldName] = amount;<br/>  },<br/><br/>  // Update the "balances" object in global state based on the current<br/>  // initial balances:<br/>  recalculateBalances() {<br/>    const { initialRaw, initialCooked } = this.state.balances;<br/>    const { currentRaw, currentCooked } = this.wasm.getCurrentBalances(<br/>      initialRaw,<br/>      initialCooked<br/>    );<br/>    this.state.balances = {<br/>      initialRaw,<br/>      currentRaw,<br/>      initialCooked,<br/>      currentCooked<br/>    };<br/>  }<br/>};</pre>
<p class="mce-root">The <kbd>updateInitialBalance()</kbd> function sets the property value in the <kbd>balances</kbd> object in global state based on the <kbd>amount</kbd> and <kbd>fieldName</kbd> arguments. The <kbd>recalculateBalances()</kbd> function updates all of the fields on the <kbd>balances</kbd> object to reflect any changes made to the initial balances or transactions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Store initialization</h1>
                </header>
            
            <article>
                
<p class="mce-root">The final section of code in the file initializes the store:</p>
<pre class="mce-root">/**<br/> * This function instantiates the Wasm module, fetches the transactions<br/> * from the API endpoint, and loads them into state and the Wasm<br/> * instance.<br/> */<br/>export const initializeStore = async () =&gt; {<br/>  const wasmTransactions = new WasmTransactions();<br/>  store.wasm = await wasmTransactions.initialize();<br/>  const transactions = await apiFetchTransactions();<br/>  store.populateTransactions(transactions);<br/>};</pre>
<p class="mce-root">The <kbd>initializeStore()</kbd> function instantiates the Wasm module, fetches all transactions from the API, and populates the contents of state. This function is called from the application loading code in <kbd>/src/main.js</kbd>, which we'll cover in the next section.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading the application in main.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">We need an entry point to load our application. Create a file in the <kbd>/src</kbd> folder named <kbd>main.js</kbd> and populate it with the following contents:</p>
<pre class="mce-root">import App from './components/App.js';<br/>import { store, initializeStore } from './store/store.js';<br/><br/>// This allows us to use the &lt;vue-numeric&gt; component globally:<br/>Vue.use(VueNumeric.default);<br/><br/>// Create a globally accessible store (without having to pass it down<br/>// as props):<br/>window.$store = store;<br/><br/>// Since we can only pass numbers into a Wasm function, these flags<br/>// represent the amount type we're trying to calculate:<br/>window.AMOUNT_TYPE = {<br/>  raw: 1,<br/>  cooked: 2<br/>};<br/><br/>// After fetching the transactions and initializing the Wasm module,<br/>// render the app.<br/>initializeStore()<br/>  .then(() =&gt; {<br/>    new Vue({ render: h =&gt; h(App), el: '#app' });<br/>  })<br/>  .catch(err =&gt; {<br/>    console.error(err);<br/>  });</pre>
<p class="mce-root">This file is loaded after the libraries are fetched and loaded from CDNs in <kbd>/src/index.html</kbd>. We use the global <kbd>Vue</kbd> object to specify that we want to use the <kbd>VueNumeric</kbd> component. We add the <kbd>store</kbd> object exported from <kbd>/store/store.js</kbd> to <kbd>window</kbd> as <kbd>$store</kbd>. This isn't the most robust solution, but will be sufficient given the scope of the application. If you were creating a production application, you'd use a library like <strong>Vuex</strong> or <strong>Redux</strong> for global state management. We'll forego this approach in the interest of keeping things simple.</p>
<p class="mce-root">We also added <kbd>AMOUNT_TYPE</kbd> to the <kbd>window</kbd> object. This was done to ensure the entire application can reference the <kbd>AMOUNT_TYPE</kbd> value, rather than specify a magic number. After values are assigned to <kbd>window</kbd>, the <kbd>initializeStore()</kbd> function is called. If the <kbd>initializeStore()</kbd> function fired successfully, a new <kbd>Vue</kbd> instance is created to render the application. Let's add the web assets next, then move on to the Vue components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the web assets</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before we start adding Vue components to the application, let's create the HTML and CSS files that house our markup and styles. Create a file in the <kbd>/src</kbd> folder named <kbd>index.html</kbd> and populate it with the following contents:</p>
<pre>&lt;!doctype html&gt;<br/>&lt;html lang="en-us"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Cook the Books&lt;/title&gt;<br/>  &lt;link<br/>    rel="stylesheet"<br/>    type="text/css"<br/>    href="https://cdnjs.cloudflare.com/ajax/libs/uikit/3.0.0-rc.6/css/uikit.min.css"<br/>  /&gt;<br/>  &lt;link rel="stylesheet" type="text/css" href="styles.css" /&gt;<br/>  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/uikit/3.0.0-rc.6/js/uikit.min.js"&gt;&lt;/script&gt;<br/>  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/uikit/3.0.0-rc.6/js/uikit-icons.min.js"&gt;&lt;/script&gt;<br/>  &lt;script src="https://unpkg.com/accounting-js@1.1.1/dist/accounting.umd.js"&gt;&lt;/script&gt;<br/>  &lt;script src="https://unpkg.com/lodash@4.17.10/lodash.min.js"&gt;&lt;/script&gt;<br/>  &lt;script src="https://unpkg.com/d3@5.5.0/dist/d3.min.js"&gt;&lt;/script&gt;<br/>  &lt;script src="https://unpkg.com/vue@2.5.16/dist/vue.min.js"&gt;&lt;/script&gt;<br/>  &lt;script src="https://unpkg.com/vue-numeric@2.3.0/dist/vue-numeric.min.js"&gt;&lt;/script&gt;<br/>  &lt;script src="main.js" type="module"&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;div id="app"&gt;&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">We're only using the HTML file to fetch libraries from CDNs, specify a <kbd>&lt;div&gt;</kbd> that Vue can render to, and load <kbd>main.js</kbd> to start the application. Note the <kbd>type="module"</kbd> attribute on the final <kbd>&lt;script&gt;</kbd> element. This allows us to use ES modules throughout our application. Now let's add the CSS file. Create a file in the <kbd>/src</kbd> folder named <kbd>styles.css</kbd> and populate it with the following contents:</p>
<pre class="mce-root">@import url("https://fonts.googleapis.com/css?family=Quicksand");<br/><br/>:root {<br/>  --blue: #2889ed;<br/>}<br/><br/>* {<br/>  font-family: "Quicksand", Helvetica, Arial, sans-serif !important;<br/>}<br/><br/>#app {<br/>  -webkit-font-smoothing: antialiased;<br/>  -moz-osx-font-smoothing: grayscale;<br/>}<br/><br/>.addTransactionButton {<br/>  color: white;<br/>  height: 64px;<br/>  width: 64px;<br/>  background: var(--blue);<br/>  position: fixed;<br/>  bottom: 24px;<br/>  right: 24px;<br/>}<br/><br/>.addTransactionButton:hover {<br/>  color: white;<br/>  background-color: var(--blue);<br/>  opacity: .6;<br/>}<br/><br/>.errorText {<br/>  color: white;<br/>  font-size: 36px;<br/>}<br/><br/>.appHeader {<br/>  height: 80px;<br/>  margin: 0;<br/>}<br/><br/>.balanceEntry {<br/>  font-size: 2rem;<br/>}<br/><br/>.tableAmount {<br/>  white-space: pre;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">This file <span>has </span>only a few classes because most of the styling will be handled at the component level. In the next section, we'll review the Vue components that make up our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Vue components</h1>
                </header>
            
            <article>
                
<p>With Vue, we can create separate components that encapsulate their own functionality, then compose these components to build an application. This makes debugging, extensibility, and change management much easier than storing the application in a single monolithic file.</p>
<p class="mce-root">The application uses a single-component-per-file development methodology. Before we start reviewing the component files, let's look at the finished product. The following screenshot is of the application with the <span class="packt_screen">TRANSACTIONS</span> tab selected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5fd7ee43-480d-4d13-8b0c-370bd2f851ba.png" style="width:41.58em;height:32.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Running the application with TRANSACTIONS tab visible</div>
<p>Here's a screenshot of the application with the <span class="packt_screen">CHARTS</span> tab selected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/593e5d7b-16ae-416e-91c6-a44a890d495c.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Running the application with the CHARTS tab visible</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The structure of a Vue component</h1>
                </header>
            
            <article>
                
<p>A Vue component is simply a file with an exported object containing properties that define how that component should look and behave. The properties must be given names that adhere to the Vue API. You can read about these properties and other aspects of the Vue API at <a href="https://vuejs.org/v2/api">https://vuejs.org/v2/api</a>. The following code represents an example component containing the elements of the Vue API used in this application:</p>
<pre>import SomeComponent from './SomeComponent.js';<br/><br/>export default {<br/>  name: 'dummy-component',<br/><br/>  // Props passed from other components:<br/>  props: {<br/>    label: String,<br/>  },<br/><br/>  // Other Vue components to render within the template:<br/>  components: {<br/>    SomeComponent<br/>  },<br/><br/>  // Used to store local data/state:<br/>  data() {<br/>    return {<br/>      amount: 0<br/>    }<br/>  },<br/><br/>  // Used to store complex logic that outside of the `template`:<br/>  computed: {<br/>    negativeClass() {<br/>      return {<br/>        'negative': this.amount &lt; 0<br/>      };<br/>    }<br/>  },<br/><br/>  // Methods that can be performed within the component:<br/>  methods: {<br/>    addOne() {<br/>      this.amount += 1;<br/>    }<br/>  },<br/><br/>  // Perform actions if the local data changes:<br/>  watch: {<br/>    amount(val, oldVal) {<br/>      console.log(`New: ${val} | Old: ${oldVal}`);<br/>    }<br/>  },<br/><br/>  // Contains the HTML to render the component:<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;some-component&gt;&lt;/some-component&gt;<br/>      &lt;label for="someAmount"&gt;{{ label }}&lt;/label&gt;<br/>      &lt;input<br/>        id="someAmount"<br/>        :class="negativeClass"<br/>        v-model="amount"<br/>        type="number"<br/>      /&gt;<br/>      &lt;button @click="addOne"&gt;Add One&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  `<br/>};</pre>
<p class="mce-root">The comments above each property describe its purpose, albeit at a very high level. Let's see Vue in action by reviewing the <kbd>App</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The App component</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>App</kbd> component is the base component that renders all of the child components in the application. We'll briefly review the <kbd>App</kbd> component's code to gain a better understanding of Vue. Going forward, we'll describe the role each remaining component plays, but only review sections of the corresponding code. The contents of the <kbd>App</kbd> component file, located at <kbd>/src/components/App.js</kbd>, are shown as follows:</p>
<pre>import BalancesBar from './BalancesBar/BalancesBar.js';<br/>import ChartsTab from './ChartsTab/ChartsTab.js';<br/>import TransactionsTab from './TransactionsTab/TransactionsTab.js';<br/><br/>/**<br/> * This component is the entry point for the application. It contains the<br/> * header, tabs, and content.<br/> */<br/>export default {<br/>  name: 'app',<br/>  components: {<br/>    BalancesBar,<br/>    ChartsTab,<br/>    TransactionsTab<br/>  },<br/>  data() {<br/>    return {<br/>      balances: $store.state.balances,<br/>      activeTab: 0<br/>    };<br/>  },<br/>  methods: {<br/>    // Any time a transaction is added, edited, or removed, we need to<br/>    // ensure the balance is updated:<br/>    onTransactionChange() {<br/>      $store.recalculateBalances();<br/>      this.balances = $store.state.balances;<br/>    },<br/><br/>    // When the "Charts" tab is activated, this ensures that the charts<br/>    // get automatically updated:<br/>    onTabClick(event) {<br/>      this.activeTab = +event.target.dataset.tab;<br/>    }<br/>  },<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;div class="appHeader uk-background-primary uk-flex uk-flex-middle"&gt;<br/>        &lt;h2 class="uk-light uk-margin-remove-bottom uk-margin-left"&gt;<br/>          Cook the Books<br/>        &lt;/h2&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="uk-position-relative"&gt;<br/>        &lt;ul uk-tab class="uk-margin-small-bottom uk-margin-top"&gt;<br/>          &lt;li class="uk-margin-small-left"&gt;<br/>            &lt;a href="#" data-tab="0" @click="onTabClick"&gt;Transactions&lt;/a&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;a href="#" data-tab="1" @click="onTabClick"&gt;Charts&lt;/a&gt;<br/>          &lt;/li&gt;<br/>        &lt;/ul&gt;<br/>        &lt;balances-bar<br/>          :balances="balances"<br/>          :onTransactionChange="onTransactionChange"&gt;<br/>        &lt;/balances-bar&gt;<br/>        &lt;ul class="uk-switcher"&gt;<br/>          &lt;li&gt;<br/>            &lt;transactions-tab :onTransactionChange="onTransactionChange"&gt;<br/>            &lt;/transactions-tab&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;charts-tab :isActive="this.activeTab === 1"&gt;&lt;/charts-tab&gt;<br/>          &lt;/li&gt;<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `<br/>};</pre>
<p class="mce-root">We use the <kbd>components</kbd> property to specify the other Vue components we'll render in the <kbd>template</kbd> for the <kbd>App</kbd> component. The <kbd>data()</kbd> function, which returns the local state, is used to keep track of balances and which tab is active (<span class="packt_screen">TRANSACTIONS</span> or <span class="packt_screen">CHARTS</span>). The <kbd>methods</kbd> property contains two functions: <kbd>onTransactionChange()</kbd> and <kbd>onTabClick()</kbd>. The <kbd>onTransactionChange()</kbd> function calls <kbd>$store.recalculateBalances()</kbd> and updates <kbd>balances</kbd> in local state if a change is made to a transaction record. The <kbd>onTabClick()</kbd> function changes the value of <kbd>activeTab</kbd> in the local state to the <kbd>data-tab</kbd> attribute of the clicked tab. Finally, the <kbd>template</kbd> property contains the markup used to render the component.</p>
<div class="mce-root packt_infobox">If you're not using single file components in Vue (<kbd>.vue</kbd> extension), you need to convert the component name to kebab case in the template property. For example, in the <kbd>App</kbd> component shown earlier, <kbd>BalancesBar</kbd> was changed to <kbd>&lt;balances-bar&gt;</kbd> in the <kbd>template</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The BalancesBar</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>/components/BalancesBar</kbd> folder contains two component files: <kbd>BalanceCard.js</kbd> and <kbd>BalancesBar.js</kbd>. The <kbd>BalancesBar</kbd> component persists across the <span class="packt_screen">TRANSACTIONS</span> and <span class="packt_screen">CHARTS</span> tabs and is located directly under the tab control. It contains four of the <kbd>BalanceCard</kbd> components, one for each balance type: initial raw, current raw, initial cooked, and current cooked. The first and third cards representing the initial balances contain inputs so the balance can be changed. The second and fourth cards representing the current balances are calculated dynamically in the Wasm module (using the <kbd>getFinalBalanceForType()</kbd> function). The following snippet, taken from the <kbd>BalancesBar</kbd> component, demonstrates Vue's binding syntax:</p>
<pre>&lt;balance-card<br/>  title="Initial Raw Balance"<br/>  :value="balances.initialRaw"<br/>  :onChange="amount =&gt; onBalanceChange(amount, 'initialRaw')"&gt;<br/>&lt;/balance-card&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The <kbd>:</kbd> preceding the <kbd>value</kbd> and <kbd>onChange</kbd> attributes indicate that these properties are bound to the Vue component. If the value of <kbd>balances.initialRaw</kbd> changes, the value displayed in the <kbd>BalanceCard</kbd> will update as well. The <kbd>onBalanceChange()</kbd> function for this card updates the value of <kbd>balances.initialRaw</kbd> in global state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The TransactionsTab</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>/components/TransactionsTab</kbd> folder contains the following four component files:</p>
<ul>
<li class="mce-root"><kbd>ConfirmationModal.js</kbd></li>
<li class="mce-root"><kbd>TransactionModal.js</kbd></li>
<li class="mce-root"><kbd>TransactionsTab.js</kbd></li>
<li class="mce-root"><kbd>TransactionsTable.js</kbd></li>
</ul>
<p class="mce-root">The <kbd>TransactionsTab</kbd> component contains the <kbd>TransactionsTable</kbd> and <kbd>TransactionsModal</kbd> components, as well as a button used to add new transactions. Changes and additions are done through the <kbd>TransactionModal</kbd> component. The <kbd>TransactionsTable</kbd> contains all of the current transactions with buttons on each row to either edit or delete the transaction. If the user presses the <span class="packt_screen">Delete</span> button, the <kbd>ConfirmationModal</kbd> component appears and prompts the user to proceed. If the user presses <span class="packt_screen">Yes</span>, the transaction is deleted. The following snippet, taken from the <kbd>methods</kbd> property in the <kbd>TransactionsTable</kbd> component, demonstrates how display values are formatted:</p>
<pre>getFormattedTransactions() {<br/>  const getDisplayAmount = (type, amount) =&gt; {<br/>    if (amount === 0) return accounting.formatMoney(amount);<br/>    return accounting.formatMoney(amount, {<br/>      format: { pos: '%s %v', neg: '%s (%v)' }<br/>    });<br/>  };<br/><br/>  const getDisplayDate = transactionDate =&gt; {<br/>    if (!transactionDate) return '';<br/>    const parsedTime = d3.timeParse('%Y-%m-%d')(transactionDate);<br/>    return d3.timeFormat('%m/%d/%Y')(parsedTime);<br/>  };<br/><br/>  return $store.state.transactions.map(<br/>    ({<br/>      type,<br/>      rawAmount,<br/>      cookedAmount,<br/>      transactionDate,<br/>      ...transaction<br/>    }) =&gt; ({<br/>      ...transaction,<br/>      type,<br/>      rawAmount: getDisplayAmount(type, rawAmount),<br/>      cookedAmount: getDisplayAmount(type, cookedAmount),<br/>      transactionDate: getDisplayDate(transactionDate)<br/>    })<br/>  );<br/>}</pre>
<p class="mce-root">The preceding <kbd>getFormattedTransactions()</kbd> function shown applies formatting to the <kbd>rawAmount</kbd>, <kbd>cookedAmount</kbd>, and <kbd>transactionDate</kbd> fields within each <kbd>transaction</kbd> record. This is done to ensure the value being displayed includes a dollar sign (for amounts) and is presented in a user-friendly format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ChartsTab</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>/components/ChartsTab</kbd> folder contains two component files: <kbd>ChartsTab.js</kbd> and <kbd>PieChart.js</kbd>. The <kbd>ChartsTab</kbd> component contains two instances of the <kbd>PieChart</kbd> component, one for income and one for expenses. Each <kbd>PieChart</kbd> component displays either the raw or cooked percentages by category. The user can switch between raw or cooked views via buttons directly above the chart. The <kbd>drawChart()</kbd> method in <kbd>PieChart.js</kbd> uses D3 to render the pie chart and legend. It uses D3's built-in animations to animate each piece of the pie when loading:</p>
<pre>arc<br/>  .append('path')<br/>  .attr('fill', d =&gt; colorScale(d.data.category))<br/>  .transition()<br/>  .delay((d, i) =&gt; i * 100)<br/>  .duration(500)<br/>  .attrTween('d', d =&gt; {<br/>    const i = d3.interpolate(d.startAngle + 0.1, d.endAngle);<br/>    return t =&gt; {<br/>      d.endAngle = i(t);<br/>      return arcPath(d);<br/>    };<br/>  });</pre>
<p class="mce-root"/>
<p class="mce-root">The preceding snippet, taken from <kbd>drawChart()</kbd> in <kbd>PieChart.js</kbd>, defines the animation for the pie piece in only a few lines of code. If you're interested in learning more about D3's capabilities, check out some the examples at <a href="https://bl.ocks.org">https://bl.ocks.org</a>. That's it for the components review; let's try running the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p class="p1">You've written and compiled the C code and added the frontend logic. It's time to start the application and interact with it. In this section, we will validate your application's <kbd><span class="s1">/src</span></kbd> folder, run the application, and test out the features to ensure everything is working correctly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating the /src folder</h1>
                </header>
            
            <article>
                
<p>Before starting the application, reference the following structure to ensure your <kbd>/src</kbd> folder is structured correctly and contains the following contents:</p>
<pre>├── /assets<br/>│    ├── main.wasm<br/>│    └── memory.wasm<br/>├── /components<br/>│    ├── /BalancesBar<br/>│    │    ├── BalanceCard.js<br/>│    │    └── BalancesBar.js<br/>│    ├── /ChartsTab<br/>│    │    ├── ChartsTab.js<br/>│    │    └── PieChart.js<br/>│    ├── /TransactionsTab<br/>│    │    ├── ConfirmationModal.js<br/>│    |    ├── TransactionModal.js<br/>│    |    ├── TransactionsTab.js<br/>│    |    └── TransactionsTable.js<br/>│    └── App.js<br/>├── /store<br/>│    ├── api.js<br/>│    ├── initializeWasm.js<br/>│    ├── store.js<br/>│    └── WasmTransactions.js<br/>├── index.html<br/>├── main.js<br/>└── styles.css</pre>
<p class="mce-root">If everything matches up, you're ready to proceed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Start it up!</h1>
                </header>
            
            <article>
                
<p class="mce-root">To start the application, open up a terminal in the <kbd>/cook-the-books</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>npm start</strong></pre>
<p class="mce-root"><kbd>browser-sync</kbd> the development dependency we installed in the first section of this chapter, acts as a local server (like the <kbd>serve</kbd> library). It makes the application accessible in the browser from the port specified in the <kbd>package.json</kbd> file (in this case, <kbd>4000</kbd>). If you navigate to <kbd>http://localhost:4000/index.html</kbd> in your browser, you should see this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc07674b-a7b5-4fd6-8593-6a0429558e2e.png"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Application on initial load</div>
<div class="mce-root packt_infobox">We're using <kbd>browser-sync</kbd> instead of <kbd>serve</kbd> because it watches for changes in your files and automatically reloads the application if you make a change. To see this in action, try changing the contents of the title bar in <kbd>App.js</kbd> from <kbd>Cook the Books</kbd> to <kbd>Broil the Books</kbd>. The browser will refresh and you'll see the updated text in the title bar.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing it out</h1>
                </header>
            
            <article>
                
<p>To ensure everything is working correctly, let's test out the application. Each of the following sections describes an action and expected behavior for a particular function of the application. Follow along to see if you're getting the expected results. If you run into an issue, you can always refer back to the <kbd>/chapter-07-cook-the-books</kbd> folder in the <kbd>learn-webassembly</kbd> repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing initial balances</h1>
                </header>
            
            <article>
                
<p class="mce-root">Try changing the input values on the <span class="packt_screen">INITIAL RAW BALANCE</span> and <span><span class="packt_screen">INITIAL</span></span><span class="packt_screen"> COOKED <span>BALANCE</span></span> <kbd>BalanceCard</kbd> components. The <span class="packt_screen">CURRENT <span>RAW BALANCE</span></span> and <span class="packt_screen">CURRENT COOKED<span> </span><span>BALANCE</span></span> card values should update to reflect your changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new transaction</h1>
                </header>
            
            <article>
                
<p class="mce-root">Make a note of the current raw and cooked balances, then press the blue <span class="packt_screen">Add</span> button at the bottom-right corner of the window. It should load the <kbd>TransactionModal</kbd> component. Populate the inputs, make a note of the <strong><span class="packt_screen">Type</span></strong>, <strong><span class="packt_screen">Raw Amount</span></strong>, and <span class="packt_screen"><strong>Cooked Amount</strong></span> you entered, then press the <span class="packt_screen">Save</span> button.</p>
<p class="mce-root">The balances should have updated to reflect the new amounts. If you picked <span class="packt_screen">Withdrawal</span> for the <strong><span class="packt_screen">Type</span></strong>, the balances should decrease, otherwise, they increase (for <span class="packt_screen">Deposit</span>) as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dace2c59-c6f4-4039-ae01-3b6f3293777a.png" style="width:53.33em;height:44.42em;"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">TransactionModal when adding a new transaction</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting an existing transaction</h1>
                </header>
            
            <article>
                
<p class="mce-root">Pick a row within the <kbd>TransactionsTable</kbd> component, note the amounts, and press the button that looks like a trash can for that record. The <kbd>ConfirmationModal</kbd> component should appear. When you press the <strong><span class="packt_screen">Yes</span></strong> button, the transaction record should no longer be present in the table and the current balances should update to reflect the amounts associated with the deleted transaction as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/850ece1d-3df5-4919-9380-e268ba3975b6.png" style="width:41.58em;height:34.67em;"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Confirmation modal shown after delete button is pressed</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing an existing transaction</h1>
                </header>
            
            <article>
                
<p class="mce-root">Follow the same procedure as you did for creating a new transaction, except change the existing amounts. Check the current balances to ensure they reflect the updated transaction amounts.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the Charts tab</h1>
                </header>
            
            <article>
                
<p class="mce-root">Select the <span class="packt_screen">Charts</span> tab to load the <kbd>ChartsTab</kbd> component. Press the buttons in each <kbd>PieChart</kbd> component to switch between the raw and cooked views. The pie charts should re-render with the updated values:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/24cbe04a-2d49-49cb-9d5b-09cb6f6c3699.png"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Contents of CHARTS tab with different amount types selected</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrap up</h1>
                </header>
            
            <article>
                
<p class="mce-root">Congratulations, you just built an application that uses WebAssembly! Tell your friends! Now that you understand the capabilities and limitations of WebAssembly, it's time to expand our horizons and use some of the excellent features Emscripten provides.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we built an accounting application from scratch that uses WebAssembly without any of the extra features Emscripten provides. By adhering to the <em>Core Specification</em>, we demonstrated the limitations of WebAssembly in its current form. However, we were able to perform computation quickly through the use of Wasm modules, which is well suited for accounting. We used Vue to split our application into components, UIkit for the design and layout, and D3 to create pie charts from our transactions data. In <a href="384a3356-a9ca-4c3c-99e7-e632c6228a0b.xhtml">Chapter 8</a>, <em>Porting a Game with Emscripten</em>, we'll take full advantage of Emscripten to port an existing C++ code base to WebAssembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why did we use Vue for this application (instead of React or Angular)?</li>
<li>Why did we use C instead of C++ for this project?</li>
<li>Why did we need to set up a mock API using jsonstore.io instead of storing the data locally in a JSON file?</li>
<li>What is the name of the data structure we used for managing transactions in the C file?</li>
<li>Which functions did we need from the <kbd>memory.wasm</kbd> file and what are they used for?</li>
<li>Why did we create a wrapper class around the Wasm module?</li>
<li>Why did we make the <kbd>$store</kbd> object global?</li>
<li>Which libraries could you use in a production application for managing global state?</li>
<li>Why are we using <kbd>browser-sync</kbd>, instead of <kbd>serve</kbd>, to run the application?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Vue: <a href="https://vuejs.org">https://vuejs.org</a></li>
</ul>


            </article>

            
        </section>
    </body></html>