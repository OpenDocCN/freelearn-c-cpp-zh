- en: Chapter 07
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章
- en: Composition and Aggregation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组成和聚合
- en: In the previous chapter, we talked about encapsulation and information hiding.
    In this chapter, we continue with object orientation in C and we'll discuss the
    various relationships that can exist between two classes. Eventually, this will
    allow us to expand our object model and express the relations between objects
    as part of the upcoming chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了封装和信息隐藏。在这一章中，我们继续讨论C语言中的面向对象，我们将讨论两个类之间可能存在的各种关系。最终，这将使我们能够扩展我们的对象模型，并将对象之间的关系作为即将到来的章节中的内容表达出来。
- en: 'As part of this chapter, we discuss:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们讨论：
- en: 'Types of relations that can exist between two objects and their corresponding
    classes: We will talk about *to-have* and *to-be* relationships, but our focus
    will be on to-have relations in this chapter.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象及其对应类之间可能存在的关系类型：我们将讨论**拥有**和**存在**关系，但本章的重点将是拥有关系。
- en: '*Composition* as our first to-have relation: An example will be given to demonstrate
    a real composition relationship between two classes. Using the given example,
    we explore the memory structure which we usually have in case of composition.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**作为我们的第一种拥有关系：我们将给出一个示例来演示两个类之间的真实组合关系。使用这个示例，我们探索了在组合情况下通常具有的内存结构。'
- en: '*Aggregation* as the second to-have relation: It is similar to composition
    since both of them address a to-have relationship. But they are different. We
    will give a separate complete example to cover an aggregation case. The difference
    among aggregation and composition will shine over the memory layout associated
    with these relationships.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**作为第二种拥有关系：它与组合类似，因为它们都处理拥有关系。但它们是不同的。我们将给出一个单独的完整示例来涵盖聚合案例。聚合和组合之间的区别将在与这些关系相关的内存布局中显现。'
- en: This is the second of the four chapters covering OOP in C. The to-be relationship,
    which is also called *inheritance*, will be covered in the next chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是涵盖C语言中面向对象编程的四个章节中的第二个。下一章将介绍被称为**继承**的“存在”关系。
- en: Relations between classes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类之间的关系
- en: 'An object model is a set of related objects. The number of relations can be
    many, but there are a few relationship types that can exist between two objects.
    Generally, there are two categories of relationships found between objects (or their
    corresponding classes): to-have relationships and to-be relationships.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对象模型是一组相关对象。关系数量可能很多，但两个对象之间可能存在的关系类型却有限。通常，在对象（或其对应的类）之间可以发现两种关系类别：拥有关系和存在关系。
- en: We'll explore to-have relationships in depth in this chapter, and we'll cover
    to-be relationships in the next chapter. In addition, we will also see how the
    relationships between various objects can lead to relationships between their
    corresponding classes. Before dealing with that, we need to be able to distinguish
    between a class and an object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章深入探讨拥有关系，并在下一章涵盖存在关系。此外，我们还将看到各种对象之间的关系如何导致它们对应类之间的关系。在处理这些关系之前，我们需要能够区分类和对象。
- en: Object versus class
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象与类
- en: If you remember from the previous chapter, we have two approaches for constructing
    objects. One approach is *prototype-based* and the other is *class-based*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得前一章，我们有两种构建对象的方法。一种方法是**原型基于**的，另一种是**类基于**的。
- en: In the prototype-based approach, we construct an object either empty (without
    any attribute or behavior), or we clone it from an existing object. In this context,
    *instance* and *object* mean the same thing. So, the prototype-based approach
    can be read as the object-based approach; an approach that begins from empty objects
    instead of classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于原型的方法中，我们构建一个对象要么是空的（没有任何属性或行为），要么是从现有对象克隆而来。在这种情况下，“实例”和“对象”意味着同一件事。因此，基于原型的方法可以读作基于对象的方法；一种从空对象而不是类开始的方法。
- en: In the class-based approach, we cannot construct an object without having a blueprint
    that is often called a *class*. So, we should start from a class. And then, we
    can instantiate an object from it. In the previous chapter, we explained the implicit
    encapsulation technique that defines a class as a set of declarations put in a
    header file. We also gave some examples showing how this works in C.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于类的方法中，我们无法在没有蓝图的情况下构建对象，这个蓝图通常被称为**类**。因此，我们应该从类开始。然后，我们可以从这个类中实例化一个对象。在前一章中，我们解释了隐式封装技术，它将类定义为一组放入头文件中的声明。我们还给出了一些示例，展示了这在C语言中的实现方式。
- en: Now, as part of this section, we want to talk more about the differences between
    a class and an object. While the differences seem to be trivial, we want to dive
    deeper and study them carefully. We begin by giving an example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为本节的一部分，我们想更多地讨论类和对象之间的差异。虽然这些差异似乎很微不足道，但我们想深入研究并仔细研究它们。我们首先通过一个例子开始。
- en: 'Suppose that we define a class, `Person`. It has the following attributes:
    `name`, `surname`, and `age`. We won''t talk about the behaviors because the differences
    usually come from the attributes, and not the behaviors.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义一个类，`Person`。它具有以下属性：`name`、`surname`和`age`。我们不会讨论行为，因为差异通常来自属性，而不是行为。
- en: 'In C, we can write the `Person` class with public attributes as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，我们可以这样编写具有公共属性的`Person`类：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 7-1: The Person attribute structure in C'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框7-1：C中的Person属性结构
- en: 'And in C++:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 7-2: The Person class''s class in C++'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框7-2：C++中的Person类
- en: The preceding code boxes are identical. In fact, the current discussion can
    be applied to both C and C++, and even other OOP languages such as Java. A class
    (or an object template) is a blueprint that only determines the attributes required
    to be present in every object, and *not* the values that these attributes might
    have in one specific object. In fact, each object has its own specific set of
    values for the same attributes that exist in other objects instantiated from the
    same class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码框是相同的。事实上，当前的讨论可以应用于C和C++，甚至其他面向对象的语言，如Java。一个类（或对象模板）是一个蓝图，它只决定了每个对象所需的属性，而不是这些属性在一个特定对象中可能具有的值。实际上，每个对象都有其自己的特定值集，这些值与从同一类实例化的其他对象中存在的相同属性相对应。
- en: When an object is created based on a class, its memory is allocated first. This
    allocated memory will be a placeholder for the attribute values. After that, we
    need to initialize the attribute values with some values. This is an important
    step, otherwise, the object might have an invalid state after being created. As
    you've already seen, this step is called *construction*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于一个类创建一个对象时，首先分配其内存。这个分配的内存将作为属性值的占位符。之后，我们需要用一些值初始化属性值。这是一个重要的步骤，否则，对象在被创建后可能会处于无效状态。正如您已经看到的，这个步骤被称为*构造*。
- en: There is usually a dedicated function that performs the construction step, which
    is called the *constructor*. The functions `list_init` and `car_construct` in
    the examples, found in the previous chapter, were constructor functions. It is
    quite possible that as part of constructing an object, we need to allocate even
    more memory for resources such as other objects, buffers, arrays, streams, and
    so on required by that object. The resources owned by the object must have been
    released before having the owner object freed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有一个专门执行构造步骤的函数，这被称为*构造函数*。在上一章中找到的示例中的`list_init`和`car_construct`函数是构造函数。完全有可能在构建对象的过程中，我们需要为该对象所需的其他对象、缓冲区、数组、流等资源分配更多的内存。对象拥有的资源必须在释放拥有者对象之前被释放。
- en: We also have another function, similar to the constructor, which is responsible
    for freeing any allocated resources. It is called the *destructor*. Similarly,
    the functions `list_destroy` and `car_destruct` in the examples found in the previous
    chapter were destructors. After destructing an object, its allocated memory is
    freed, but before that, all the owned resources and their corresponding memories
    must be freed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个另一个与构造函数类似的功能，它负责释放任何分配的资源。它被称为*析构函数*。同样，在上一章中找到的示例中的`list_destroy`和`car_destruct`函数是析构函数。在析构一个对象后，其分配的内存被释放，但在那之前，所有拥有的资源和它们相应的内存必须被释放。
- en: 'Before moving on, let''s sum up what we''ve explained so far:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们总结一下到目前为止我们已经解释的内容：
- en: A class is a blueprint that is used as a map for creating objects.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是一个蓝图，用作创建对象的映射。
- en: Many objects can be made from the same class.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从同一个类中创建许多对象。
- en: A class determines which attributes should be present in every future object
    created based on that class. It doesn't say anything about the possible values
    they can have.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类决定了每个基于该类创建的未来对象应该具有哪些属性。它并没有说明它们可能具有的值。
- en: A class itself does not consume any memory (except in some programming languages
    other than C and C++) and only exists at the source level and at compile time.
    But objects exist at runtime and consume memory.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类本身不消耗任何内存（除了C和C++以外的某些编程语言之外）并且只存在于源级别和编译时。但对象存在于运行时并且消耗内存。
- en: When creating an object, memory allocation happens first. In addition, memory
    deallocation is the last operation for an object.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建对象时，首先发生内存分配。此外，内存释放是对象的最后一个操作。
- en: When creating an object, it should be constructed right after memory allocation.
    It should be also destructed right before deallocation.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建对象时，应该在内存分配之后立即构造它。它也应该在分配之前立即销毁。
- en: An object might be owning some resources such as streams, buffers, arrays, and
    so on, that must be released before having the object destroyed.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象可能拥有一些资源，如流、缓冲区、数组等，在对象被销毁之前必须释放。
- en: Now that you know the differences between a class and an object, we can move
    on and explain the different relationships that can exist between two objects
    and their corresponding classes. We'll start with composition.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经知道了类和对象之间的区别，我们可以继续解释两个对象及其对应类之间可能存在的不同关系。我们将从组合开始。
- en: Composition
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: As the term "composition" implies, when an object contains or possesses another
    object – in other words, it is composed of another object – we say that there
    is a composition relationship between them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如“组合”一词所暗示的，当一个对象包含或拥有另一个对象——换句话说，它由另一个对象组成——我们说它们之间存在组合关系。
- en: 'As an example, a car has an engine; a car is an object that contains an engine
    object. Therefore, the car and engine objects have a composition relationship.
    There is an important condition that a composition relationship must have: *the
    lifetime of the contained object is bound to the lifetime of the container object*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一辆汽车有一个引擎；汽车是一个包含引擎对象的物体。因此，汽车和引擎对象之间存在组合关系。组合关系必须满足的一个重要条件是：*包含对象的生存期绑定到容器对象的生存期*。
- en: As long as the container object exists, the contained object must exist. But
    when the container object is about to get destroyed, the contained object must
    have been destructed first. This condition implies that the contained object is
    often internal and private to the container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只要容器对象存在，包含对象就必须存在。但是当容器对象即将被销毁时，包含对象必须先被销毁。这个条件意味着包含对象通常是容器内部的私有对象。
- en: Some parts of the contained object may be still accessible through the public
    interface (or behavior functions) of the container class, but the lifetime of
    the contained object must be managed internally by the container object. If a
    piece of code can destruct the contained object without destructing the container
    object, it is a breach of the composition relationship and the relationship is
    no longer a composition.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 包含对象的一些部分可能仍然可以通过容器类的公共接口（或行为函数）访问，但包含对象的生存期必须由容器对象内部管理。如果一段代码可以在不破坏容器对象的情况下破坏包含对象，那么它违反了组合关系，这种关系就不再是组合关系。
- en: The following example, *example 7.1*, demonstrates the composition relationship
    between a car object and an engine object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例 7.1*，展示了汽车对象和引擎对象之间的组合关系。
- en: 'It is composed of five files: two header files, which declare the public interfaces
    of the `Car` and `Engine` classes; two source files, which contain the implementation
    of the `Car` and `Engine` classes; and finally, a source file, which contains
    the `main` function and executes a simple scenario using a car and its engine
    object.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它由五个文件组成：两个头文件，声明了 `Car` 和 `Engine` 类的公共接口；两个源文件，包含了 `Car` 和 `Engine` 类的实现；最后是一个源文件，包含了
    `main` 函数并执行了一个使用汽车及其引擎对象的简单场景。
- en: Note that, in some domains, we can have engine objects outside of the car objects;
    for example, in mechanical engineering CAD software. So, the type of relationships
    between the various objects is determined by the problem domain. For the sake
    of our example, imagine a domain in which engine objects could not exist outside
    of car objects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些领域，我们可以在汽车对象之外拥有引擎对象；例如，在机械工程 CAD 软件中。因此，各种对象之间的关系类型由问题域决定。为了我们的示例，想象一个引擎对象不能存在于汽车对象之外的领域。
- en: 'The following code box shows the header file for the `Car` class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了 `Car` 类的头文件：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 7-3 [ExtremeC_examples_chapter7_1_car.h]: The public interface of
    the Car class'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 7-3 [ExtremeC_examples_chapter7_1_car.h]：`Car` 类的公共接口
- en: As you see, the preceding declarations have been made in a similar way to what
    we did for the `List` class in the last example of the previous chapter, *example
    6.3*. One of the differences is that we have chosen a new suffix for the constructor
    function; `car_new` instead of `car_construct`. The other difference is that we
    have only declared the attribute structure `car_t`. We have not defined its fields,
    and this is called a *forward declaration*. The definition for the structure `car_t`
    will be in the source file which comes in the code box 7-5\. Note that in the
    preceding header file, the type `car_t` is considered an incomplete type which
    is not defined yet.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，前面的声明是以与我们上一章最后一个例子中 `List` 类所做的方式进行的，*例子 6.3*。其中一个不同之处在于我们为构造函数选择了一个新的后缀；`car_new`
    而不是 `car_construct`。另一个不同之处在于我们只声明了属性结构 `car_t`。我们没有定义其字段，这被称为 *前向声明*。`car_t`
    结构的定义将在代码框 7-5 所示的源文件中。请注意，在前面的头文件中，类型 `car_t` 被视为一个不完整类型，尚未定义。
- en: 'The following code box contains the header file for the `Engine` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含了 `Engine` 类的头文件：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 7-4 [ExtremeC_examples_chapter7_1_engine.h]: The public interface
    of the Engine class'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 7-4 [ExtremeC_examples_chapter7_1_engine.h]: Engine 类的公共接口'
- en: 'The following code boxes contains the implementations done for the `Car` and
    `Engine` classes. We begin with the `Car` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含了为 `Car` 和 `Engine` 类实现的代码。我们首先从 `Car` 类开始：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 7-5 [ExtremeC_examples_chapter7_1_car.c]: The definition of the Car
    class'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 7-5 [ExtremeC_examples_chapter7_1_car.c]: Car 类的定义'
- en: The preceding code box shows how the car has contained the engine. As you see,
    we have a new attribute as part of the `car_t` attribute structure, and it is
    of the `struct engine_t*` type. Composition happens because of this attribute.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码框展示了汽车是如何包含发动机的。正如你所见，我们有一个新的属性作为 `car_t` 属性结构的一部分，它是 `struct engine_t*`
    类型。组合正是因为这个属性而发生的。
- en: Though the type `struct engine_t*` is still incomplete inside this source file,
    it can point to an object from a complete `engine_t` type at runtime. This attribute
    will point to an object that is going to be constructed as part of the `Car` class's
    constructor, and it will be freed inside the destructor. At both places, the car
    object exists, and this means that the engine's lifetime is included in the car's
    lifetime.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个源文件中，类型 `struct engine_t*` 仍然是不完整的，但在运行时它可以指向一个完整的 `engine_t` 类型的对象。这个属性将指向作为
    `Car` 类构造函数一部分将要构建的对象，它将在析构函数中释放。在两个地方，汽车对象都存在，这意味着发动机的生命周期包含在汽车的生命周期中。
- en: The `engine` pointer is private, and no pointer is leaking from the implementation.
    That's an important note. When you are implementing a composition relationship,
    no pointer should be leaked out otherwise it causes external code to be able to
    change the state of the contained object. Just like encapsulation, no pointer
    should be leaked out when it gives direct access to the private parts of an object.
    Private parts should always be accessed indirectly via behavior functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine` 指针是私有的，并且没有指针从实现中泄漏出来。这是一个重要的注意事项。当你实现组合关系时，不应该有指针泄漏出来，否则它会使外部代码能够改变包含对象的内部状态。就像封装一样，当它提供对对象私有部分的直接访问时，不应该有指针泄漏出来。私有部分应该始终通过行为函数间接访问。'
- en: The `car_get_engine_temperature` function in the code box gives access to the
    `temperature` attribute of the engine. However, there is an important note regarding
    this function. It uses the public interface of the engine. If you pay attention,
    you'll see that the *car's private implementation* is consuming the *engine's
    public interface*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框中的 `car_get_engine_temperature` 函数提供了对发动机的 `temperature` 属性的访问。然而，关于这个函数有一个重要的注意事项。它使用了发动机的公共接口。如果你注意观察，你会看到
    *汽车的私有实现* 正在消耗 *发动机的公共接口*。
- en: This means that the car itself doesn't know anything about the implementation
    details of the engine. This is the way that it should be.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着汽车本身对发动机的实现细节一无所知。这正是它应该的方式。
- en: '*Two objects that are not of the same type, in most cases, must not know about
    each other''s implementation details*. This is what information hiding dictates.
    Remember that the car''s behaviors are considered external to the engine.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*两个不同类型的对象，在大多数情况下，不应该知道彼此的实现细节*。这是信息隐藏所规定的。记住，汽车的行为被认为是发动机的外部行为。'
- en: This way, we can replace the implementation of the engine with an alternative
    one, and it should work, as long as the new implementation provides definitions
    for the same public functions declared in the engine's header file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以用替代的实现替换引擎的实现，只要新的实现提供了引擎头文件中声明的相同公共函数的定义，它应该就能正常工作。
- en: 'Now, let''s look at the implementation of the `Engine` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Engine`类的实现：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 7-6 [ExtremeC_examples_chapter7_1_engine.c]: The definition of the
    Engine class'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 7-6 [ExtremeC_examples_chapter7_1_engine.c]：引擎类的定义
- en: The preceding code is just using the implicit encapsulation approach for its
    private implementation, and it is very similar to previous examples. But there
    is one thing to note about this. As you see, the `engine` object doesn't know
    that an external object is going to contain it in a composition relationship.
    This is like the real world. When a company is building engines, it is not clear
    which engine will go into which car. Of course, we could have kept a pointer to
    the container `car` object, but in this example, we didn't need to.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是使用了隐式封装方法来处理其私有实现，这与之前的示例非常相似。但有一点需要注意。如您所见，`engine`对象并不知道一个外部对象将要将其包含在组合关系中。这就像现实世界一样。当一家公司制造引擎时，并不清楚哪个引擎将进入哪辆汽车。当然，我们本可以保留对容器`car`对象的指针，但在这个例子中，我们不需要这样做。
- en: 'The following code box demonstrates the scenario in which we create a `car`
    object and invoke some of its public API to extract information about the car''s
    engine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码框演示了创建`car`对象并调用其一些公开API以提取有关汽车引擎信息的场景：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 7-7 [ExtremeC_examples_chapter7_1_main.c]: The main function of example
    7.1'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 7-7 [ExtremeC_examples_chapter7_1_main.c]：示例7.1的主函数
- en: To build the preceding example, firstly we need to compile the previous three
    source files. Then, we need to link them together to generate the final executable
    object file. Note that the main source file (the source file that contains the
    `main` function) only depends on the car's public interface. So, when linking,
    it only needs the private implementation of the `car` object. However, the private
    implementation of the `car` object relies on the public interface of the engine
    interface; then, while linking, we need to provide the private implementation
    of the `engine` object. Therefore, we need to link all three object files in order
    to have the final executable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建前面的示例，首先我们需要编译前三个源文件。然后，我们需要将它们链接在一起以生成最终的可执行目标文件。请注意，主源文件（包含`main`函数的源文件）只依赖于汽车公开的接口。因此，在链接时，它只需要`car`对象的私有实现。然而，`car`对象的私有实现依赖于引擎接口的公开接口；因此，在链接时，我们需要提供`engine`对象的私有实现。因此，我们需要链接所有三个目标文件才能得到最终的可执行文件。
- en: 'The following commands show how to build the example and run the final executable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了如何构建示例并运行最终的可执行文件：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 7-1: The compilation, linking, and execution of example 7.1'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 7-1：示例7.1的编译、链接和执行
- en: In this section, we explained one type of relationship that can exist between
    two objects. In the next section, we'll talk about the next relationship. It shares
    a similar concept to the composition relationship, but there are some significant
    differences.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了两个对象之间可能存在的一种关系类型。在下一节中，我们将讨论另一种关系。它与组合关系有相似的概念，但有一些显著的区别。
- en: Aggregation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: Aggregation also involves a container object that contains another object. The
    main difference is that in aggregation, the lifetime of the contained object is
    independent of the lifetime of the container object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合也涉及一个包含另一个对象的容器对象。主要区别在于，在聚合中，包含对象的生存期独立于容器对象的生存期。
- en: In aggregation, the contained object could be constructed even before the container
    object is constructed. This is opposite to composition, in which the contained
    object should have a lifetime shorter than or equal to the container object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚合中，包含的对象甚至可以在容器对象构建之前就被构建。这与组合相反，在组合中，包含的对象的生存期应该短于或等于容器对象的生存期。
- en: The following example, *example 7.2*, demonstrates an aggregation relationship.
    It describes a very simple game scenario in which a player picks up a gun, fires
    multiple times, and drops the gun.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例7.2*，演示了聚合关系。它描述了一个非常简单的游戏场景，其中玩家拿起枪，射击多次，然后放下枪。
- en: The `player` object would be a container object for a while, and the `gun` object
    would be a contained object as long as the player object holds it. The lifetime
    of the gun object is independent of the lifetime of the player object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`player` 对象将暂时成为容器对象，而 `gun` 对象将作为被包含对象，只要玩家对象持有它。枪对象的生命周期独立于玩家对象的生命周期。'
- en: 'The following code box shows the header file of the `Gun` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了 `Gun` 类的头文件：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 7-8 [ExtremeC_examples_chapter7_2_gun.h]: The public interface of
    the Gun class'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 7-8 [ExtremeC_examples_chapter7_2_gun.h]: 枪类的公共接口'
- en: As you see, we have only declared the `gun_t` attribute structure as we have
    not defined its fields. As we have explained before, this is called a forward
    declaration and it results in an incomplete type which cannot be instantiated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们只声明了 `gun_t` 属性结构，因为我们还没有定义其字段。正如我们之前解释的，这被称为前置声明，它导致了一个不完整类型，不能被实例化。
- en: 'The following code box shows the header file of the `Player` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了 `Player` 类的头文件：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 7-9 [ExtremeC_examples_chapter7_2_player.h]: The public interface
    of the Player class'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 7-9 [ExtremeC_examples_chapter7_2_player.h]: 玩家类的公共接口'
- en: The preceding code box defines the public interface of all player objects. In
    other words, it defines the public interface of the `Player` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码框定义了所有玩家对象的公共接口。换句话说，它定义了 `Player` 类的公共接口。
- en: Again, we have to forward the declaration of the `gun_t` and `player_t` structures.
    We need to have the `gun_t` type declared since some behavior functions of the
    `Player` class have arguments of this type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们必须转发 `gun_t` 和 `player_t` 结构的声明。我们需要声明 `gun_t` 类型，因为 `Player` 类的一些行为函数的参数是这种类型。
- en: 'The implementation of the `Player` class is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 类的实现如下：'
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 7-10 [ExtremeC_examples_chapter7_2_player.c]: The definition of the
    Player class'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 7-10 [ExtremeC_examples_chapter7_2_player.c]: 玩家类的定义'
- en: Inside the `player_t` structure, we declare the pointer attribute `gun` that
    is going to point to a `gun` object soon. We need to nullify this in the constructor
    because unlike composition, this attribute is not meant to be set as part of the
    constructor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `player_t` 结构内部，我们声明了一个即将指向 `gun` 对象的指针属性 `gun`。我们需要在构造函数中将它置为空，因为与组合不同，这个属性不是作为构造函数的一部分设置的。
- en: If an aggregation pointer is required to be set upon construction, the address
    of the target object should be passed as an argument to the constructor. Then,
    this situation is called a *mandatory aggregation*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在构造时设置聚合指针，则应将目标对象的地址作为参数传递给构造函数。然后，这种情况被称为 *强制聚合*。
- en: If the aggregation pointer can be left as null in the constructor, then it is
    an *optional aggregation*, as in the preceding code. It is important to nullify
    the optional aggregation pointers in the constructor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果聚合指针可以在构造函数中留为 `null`，那么它就是一个 *可选聚合*，如前面的代码所示。在构造函数中置空可选聚合指针是很重要的。
- en: In the function `player_pickup_gun`, the aggregation relationship begins, and it ends
    in the function `player_drop_gun` when the player drops the gun.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 `player_pickup_gun` 中，聚合关系开始，当玩家丢弃枪时，在函数 `player_drop_gun` 中结束。
- en: Note that we need to nullify the pointer `gun` after dropping the aggregation
    relationship. Unlike in composition, the container object is not the *owner* of
    the contained object. So, it has no control over its lifetime. Therefore, we should
    not free the gun object in any place inside the player's implementation code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在解除聚合关系后，我们需要将指针 `gun` 置为空。与组合不同，容器对象不是被包含对象的 *所有者*。因此，它对其生命周期没有控制权。因此，我们不应该在任何地方释放玩家实现代码中的枪对象。
- en: In optional aggregation relations, we may not have set the contained object
    at some point in the program. Therefore, we should be careful while using the
    aggregation pointer since any access to a pointer that is not set, or a pointer
    that is `null`, can lead to a segmentation fault. That's basically why in the
    function `player_shoot`, we check the `gun` pointer is valid. If the aggregation
    pointer is null, it means that the code using the player object is misusing it.
    If that's the case, we abort the execution by returning 1 as the *exit* code of
    the process.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在可选的聚合关系中，我们可能在程序中的某个点没有设置被包含对象。因此，在使用聚合指针时应该小心，因为对未设置或 `null` 的指针的任何访问都可能导致段错误。这就是为什么在函数
    `player_shoot` 中，我们检查 `gun` 指针是否有效的原因。如果聚合指针为空，这意味着使用玩家对象的代码正在误用它。如果是这种情况，我们将通过返回进程的
    *退出* 代码 1 来中止执行。
- en: 'The following code is the implementation of the `Gun` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `Gun` 类的实现：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 7-11 [ExtremeC_examples_chapter7_2_gun.c]: The definition of the Gun
    class'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 7-11 [ExtremeC_examples_chapter7_2_gun.c]：枪类定义
- en: The preceding code is straightforward, and it is written in a way that a gun
    object doesn't know that it will be contained in any object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码很简单，并且以这种方式编写，枪对象不知道它将被包含在任何对象中。
- en: 'Finally, the following code box demonstrates a short scenario that creates
    a `player` object and a `gun` object. Then, the player picks up the gun and fires
    with it until no ammo is left. After that, the player refills the gun and does
    the same. Finally, they drop the gun:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码框演示了一个简短的场景，该场景创建了一个 `player` 对象和一个 `gun` 对象。然后，玩家拿起枪并使用它直到没有弹药。之后，玩家重新装填枪并重复同样的操作。最后，他们丢弃了枪：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 7-12 [ExtremeC_examples_chapter7_2_main.c]: The main function of example
    7.2'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 7-12 [ExtremeC_examples_chapter7_2_main.c]：示例 7.2 的主函数
- en: As you see here, the `gun` and `player` objects are independent of each other.
    The responsible logic for creating and destroying these objects is the `main`
    function. At some point in the execution, they form an aggregation relationship
    and perform their roles, then at another point, they become separated. The important
    thing in aggregation is that the container object shouldn't alter the lifetime
    of the contained object, and as long as this rule is followed, no memory issues
    should arise.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`gun` 和 `player` 对象是相互独立的。创建和销毁这些对象的责任逻辑是 `main` 函数。在执行过程中某个时刻，它们形成一个聚合关系并执行其角色，然后在另一个时刻，它们再次分离。在聚合关系中重要的是，容器对象不应改变包含对象的生存期，只要遵循这个规则，就不会出现内存问题。
- en: 'The following shell box shows how to build the example and run the resulting
    executable file. As you see, the `main` function in *Code Box 7-12* doesn''t produce
    any output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 shell 框中展示了如何构建示例并运行生成的可执行文件。正如你所见，*代码框 7-12* 中的 `main` 函数没有产生任何输出：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Shell Box 7-2: The compilation, linking, and execution of example 7.2'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 7-2：示例 7.2 的编译、链接和执行
- en: In an object model created for a real project, the amount of aggregation relationships
    is usually greater than the number of composition relationships. Also, aggregation
    relationships are more visible externally because, in order to make an aggregation
    relationship, some dedicated behavior functions are required, at least in the
    public interface of the container object, to set and reset the contained object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在为真实项目创建的对象模型中，聚合关系的数量通常大于组合关系的数量。此外，由于为了建立聚合关系，至少在容器对象的公共接口中需要一些专门的行为函数来设置和重置包含的对象，因此聚合关系在外部更明显。
- en: As you see in the preceding example, the `gun` and `player` objects are separated
    from the start. They become related for a short period of time, and then they
    become separated again. This means that the aggregation relationship is temporary,
    unlike the composition relationship, which is permanent. This shows that composition
    is a stronger form of *possession* (to-have) relationship between objects, while
    aggregation exhibits a weaker relationship.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`gun` 和 `player` 对象从一开始就是分离的。它们短暂地建立关系，然后再次分离。这意味着聚合关系是临时的，而组合关系是永久的。这表明组合是对象之间一种更强的*拥有*（to-have）关系形式，而聚合则表现出较弱的关系。
- en: Now, a question comes to mind. If an aggregation relationship is temporary between
    two objects, is it temporary between their corresponding classes? The answer is
    no. The aggregation relationship is permanent between the types. If there is a
    small chance that in the future, two objects from two different types become related
    based on an aggregation relationship, their types should be in the aggregation
    relationship permanently. This holds for composition as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个问题浮现在脑海中。如果两个对象之间的聚合关系是临时的，那么它们对应的类之间的聚合关系也是临时的吗？答案是：不是。聚合关系在类型之间是永久的。如果将来有极小的可能性，两个不同类型的对象基于聚合关系建立关系，那么它们的类型应该永久处于聚合关系中。这也适用于组合关系。
- en: Even a low chance of there being an aggregation relationship should cause us
    to declare some pointers in the attribute structure of the container object, and
    this means that the attribute structure is changed permanently. Of course, this
    is only true for class-based programming languages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即使存在聚合关系的可能性很低，我们也应该在容器对象的属性结构中声明一些指针，这意味着属性结构将永久改变。当然，这仅适用于基于类的编程语言。
- en: Composition and aggregation both describe the possession of some objects. In
    other words, these relationships describe a "to-have" or "has-a" situation; a
    player **has** a gun, or a car **has** an engine. Every time you feel that an
    object possesses another one, it means there should either be a composition relationship
    or an aggregation relationship between them (and their corresponding classes).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 组合和聚合都描述了某些对象的拥有。换句话说，这些关系描述了一种“拥有”或“有”的情况；一个玩家**拥有**一把枪，或者一辆车**有**一个引擎。每次你感觉到一个对象拥有另一个对象时，这意味着它们之间（以及它们对应的类）应该存在组合关系或聚合关系。
- en: In the next chapter, we'll continue our discussion regarding relationship types
    by looking at the *inheritance* or *extension* relationship.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过查看*继承*或*扩展*关系来继续我们关于关系类型的讨论。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, the following topics have been discussed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了以下主题：
- en: The possible relationship types between classes and objects.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象之间可能的关系类型。
- en: The differences and similarities between a class, an object, an instance, and
    a reference.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类、对象、实例和引用之间的区别和相似之处。
- en: Composition, which entails that a contained object is totally dependent on its
    container object.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合，意味着包含的对象完全依赖于其容器对象。
- en: Aggregation, in which the contained object can live freely without any dependency
    on its container object.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合，其中包含的对象可以自由地生活，而不依赖于其容器对象。
- en: The fact that aggregation can be temporary between objects, but it is defined
    permanently between their types (or classes).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合可以在对象之间是临时的，但在它们的类型（或类）之间是永久定义的。
- en: 'In the next chapter, we continue to explore OOP, primarily addressing the two further
    pillars upon which it is based: inheritance and polymorphism.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们继续探索面向对象编程（OOP），主要解决它基于的两个进一步支柱：继承和多态。
