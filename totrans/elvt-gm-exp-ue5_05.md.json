["```cpp\n    // The camera follows at this distance behind the \n    // character\n    CameraBoom->TargetArmLength = 900.0f;\n    ```", "```cpp\n    //The camera looks down at the player\n    CameraBoom->SetRelativeRotation(FRotator(-70.f, 0.f, 0.f));\n    ```", "```cpp\n    // Don't rotate the arm based on the controller\n    CameraBoom->bUsePawnControlRotation = false;\n    ```", "```cpp\n    // Ignore pawn's pitch, yaw and roll\n    CameraBoom->bInheritPitch = false;\n    CameraBoom->bInheritYaw = false;\n    CameraBoom->bInheritRoll = false;\n    ```", "```cpp\n    // REMOVE THESE LINES\n    PlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, \n      &ACharacter::Jump);\n    PlayerInputComponent->BindAction(\"Jump\", IE_Released, this, \n      Acharacter::StopJumping);\n    ```", "```cpp\n    // REMOVE THESE LINES\n    PlayerInputComponent->BindAxis(\"Turn\", this, \n      &APawn::AddControllerYawInput);\n    PlayerInputComponent->BindAxis(\"TurnRate\", this, \n      &ADodgeballCharacter::TurnAtRate);\n    PlayerInputComponent->BindAxis(\"LookUp\", this, \n      &APawn::AddControllerPitchInput);\n    PlayerInputComponent->BindAxis(\"LookUpRate\", this, \n      &ADodgeballCharacter::LookUpAtRate);\n    ```", "```cpp\n// Change the rotation of the character to face the given \n// actor\nvoid LookAtActor(AActor* TargetActor);\n```", "```cpp\n    // Can we see the given actor\n    bool CanSeeActor(const AActor* TargetActor) const;\n    ```", "```cpp\n    #include \"EnemyCharacter.h\"\n    ```", "```cpp\n#include \"Engine/World.h\"\n```", "```cpp\n    bool AEnemyCharacter::CanSeeActor(const AActor * TargetActor) \n      const\n    {\n      if (TargetActor == nullptr)\n      {\n        return false;\n      }\n    }\n    ```", "```cpp\n    // Store the results of the Line Trace\n    FHitResult Hit;\n    ```", "```cpp\n    // Where the Line Trace starts and ends\n    FVector Start = GetActorLocation();\n    FVector End = TargetActor->GetActorLocation();\n    ```", "```cpp\n    // The trace channel we want to compare against\n    ECollisionChannel Channel = ECollisionChannel::ECC_Visibility;\n    ```", "```cpp\n    // Execute the Line Trace\n    GetWorld()->LineTraceSingleByChannel(Hit, Start, End, \n      Channel);\n    ```", "```cpp\n    FCollisionQueryParams QueryParams;\n    ```", "```cpp\n    // Ignore the actor that's executing this Line Trace\n    QueryParams.AddIgnoredActor(this);\n    ```", "```cpp\n    // Ignore the target we're checking for\n    QueryParams.AddIgnoredActor(TargetActor);\n    ```", "```cpp\n    // Execute the Line Trace\n    GetWorld()->LineTraceSingleByChannel(Hit, Start, End, Channel, \n      QueryParams);\n    ```", "```cpp\n    return !Hit.bBlockingHit;\n    ```", "```cpp\n#include \"DrawDebugHelpers.h\"\n```", "```cpp\n// Execute the Line Trace\nGetWorld()->LineTraceSingleByChannel(Hit, Start, End, Channel, \n  QueryParams);\n// Show the Line Trace inside the game\nDrawDebugLine(GetWorld(), Start, End, FColor::Red);\n```", "```cpp\n    void AEnemyCharacter::LookAtActor(AActor * TargetActor)\n    {\n      if (TargetActor == nullptr)\n      {\n        return;\n      }\n    }\n    ```", "```cpp\n    if (CanSeeActor(TargetActor))\n    {\n    }\n    ```", "```cpp\n    #include \"Kismet/KismetMathLibrary.h\"\n    ```", "```cpp\n    FVector Start = GetActorLocation();\n    FVector End = TargetActor->GetActorLocation();\n    // Calculate the necessary rotation for the Start \n    // point to face the End point\n    FRotator LookAtRotation = \n      UKismetMathLibrary::FindLookAtRotation(Start, End);\n    ```", "```cpp\n    //Set the enemy's rotation to that rotation\n    SetActorRotation(LookAtRotation);\n    ```", "```cpp\n    #include \"Kismet/GameplayStatics.h\"\n    ```", "```cpp\n    // Fetch the character currently being controlled by \n    // the player\n    ACharacter* PlayerCharacter = \n      UGameplayStatics::GetPlayerCharacter(this, 0);\n    ```", "```cpp\n    // Look at the player character every frame\n    LookAtActor(PlayerCharacter);\n    ```", "```cpp\n// Store the results of the Line Trace\nFHitResult Hit;\n```", "```cpp\n// Where the Sweep Trace starts and ends\nFVector Start = GetActorLocation();\nFVector End = TargetActor->GetActorLocation();\n```", "```cpp\n    // Rotation of the shape used in the Sweep Trace\n    FQuat Rotation = FQuat::Identity; \n    ```", "```cpp\n    // The trace channel we want to compare against\n    ECollisionChannel Channel = ECollisionChannel::ECC_Visibility;\n    ```", "```cpp\n    // Shape of the object used in the Sweep Trace\n    FCollisionShape Shape = FCollisionShape::MakeBox(FVector(20.f, \n      20.f, 20.f));\n    ```", "```cpp\n    GetWorld()->SweepSingleByChannel(Hit,\n                                     Start,\n                                     End,\n                                     Rotation,\n                                     Channel,\n                                     Shape);\n    ```", "```cpp\n    // The trace channel we want to compare against\n    ECollisionChannel Channel = ECollisionChannel::ECC_Visibility;\n    ```", "```cpp\n    +DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,\n      DefaultResponse=ECR_Block,bTraceType=True,\n      bStaticObject=False,\n      Name=\"EnemySight\")\n    ```", "```cpp\n// The trace channel we want to compare against\nECollisionChannel Channel = \n  ECollisionChannel::ECC_GameTraceChannel1;\n```"]