["```cpp\n$ ninja opt clang\n```", "```cpp\n$ sudo apt install graphviz\n```", "```cpp\nint foo(int a, int b) {\n  return a > 0? a – b : a + b;\n}\n```", "```cpp\n$ clang -emit-llvm -S foo.c\n```", "```cpp\n<result> = <operator / op-code> <type>, [operand1, operand2, …]\n```", "```cpp\n%12 = load i32, i32* %3\n```", "```cpp\n// `BB` has the type of `BasicBlock&`\nfor (Instruction &I : BB) {\n  // Work on `I`\n}\n```", "```cpp\n// `F` has the type of `Function&`\nfor (BasicBlock &BB : F) {\n  for (Instruction &I : BB) {\n    // Work on `I`\n  }\n}\n```", "```cpp\n#include \"llvm/IR/InstIterator.h\"\n…\n// `F` has the type of `Function&`\nfor (Instruction &I : instructions(F)) {\n  // Work on `I`\n}\n```", "```cpp\nfor (Instruction &I : instructions(F)) {\n  switch (I.getOpcode()) {\n  case Instruction::BinaryOperator:\n  // this instruction is a binary operator like `add` or `sub`\n    break;\n  case Instruction::Return:\n    // this is a return instruction\n    break;\n  …\n  }\n}\n```", "```cpp\n#include \"llvm/IR/InstVisitor.h\"\nclass MyInstVisitor : public InstVisitor<MyInstVisitor> {\n  void visitBinaryOperator(BinaryOperator &BOp) {\n    // Work on binary operator instruction\n    …\n  }\n  void visitReturnInst(ReturnInst &RI) {\n    // Work on return instruction\n    …\n  }\n};\n```", "```cpp\n// `F` has the type of `Function&`\nMyInstVisitor Visitor;\nVisitor.visit(F);\n```", "```cpp\n$ opt -dot-cfg -disable-output foo.ll\n```", "```cpp\n$ dot -Tpng foo.cfg.dot > foo.cfg.png\n```", "```cpp\n#include \"llvm/ADT/PostOrderIterator.h\"\n#include \"llvm/IR/CFG.h\"\n// `F` has the type of `Function*`\nfor (BasicBlock *BB : post_order(F)) {\n  BB->printAsOperand(errs());\n  errs() << \"\\n\";\n}\n```", "```cpp\nlabel %12\nlabel %9\nlabel %5\nlabel %7\nlabel %3\nlabel %10\nlabel %1\n```", "```cpp\n// `F` has the type of `Function*`\nBasicBlock &EntryBB = F->getEntryBlock();\nfor (BasicBlock *BB : post_order(&EntryBB)) {\n  BB->printAsOperand(errs());\n  errs() << \"\\n\";\n}\n```", "```cpp\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/IR/CFG.h\"\n// `F` has the type of `Function*`\nfor (BasicBlock *BB : depth_first(F)) {\n  BB->printAsOperand(errs());\n  errs() << \"\\n\";\n}\n```", "```cpp\nlabel %1\nlabel %3\nlabel %5\nlabel %9\nlabel %12\nlabel %7\nlabel %10\n```", "```cpp\nlabel %1\nlabel %3\nlabel %10\nlabel %5\nlabel %7\nlabel %12\nlabel %9\n```", "```cpp\n#include \"llvm/ADT/SCCIterator.h\"\n#include \"llvm/IR/CFG.h\"\n// `F` has the type of `Function*`\nfor (auto SCCI = scc_begin(&F); !SCCI.isAtEnd(); ++SCCI) {\n  const std::vector<BasicBlock*> &SCC = *SCCI;\n  for (auto *BB : SCC) {\n    BB->printAsOperand(errs());\n    errs() << \"\\n\";\n  }\n  errs() << \"====\\n\";\n}\n```", "```cpp\nlabel %6\n====\nlabel %4\nlabel %2\n====\nlabel %1\n====\n```", "```cpp\n#include \"llvm/Analysis/CallGraph.h\"\nstruct SimpleIPO : public PassInfoMixin<SimpleIPO> {\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &MAM) {\n    CallGraph CG(M);\n    for (auto &Node : CG) {\n      // Print function name\n      if (Node.first)\n        errs() << Node.first->getName() << \"\\n\";\n    }\n    return PreservedAnalysis::all();\n  }\n};\n```", "```cpp\ntemplate <typename T>\nstruct Distance {\n  static T compute(T &PointA, T &PointB) {\n    return PointA – PointB;\n  }\n};\n```", "```cpp\nDistance<int>::compute(94, 87); // Success\n…\nstruct SimplePoint {\n  float X, Y;\n};\nSimplePoint A, B;\nDistance<SimplePoint>::compute(A, B); // Compilation Error\n```", "```cpp\n// After the original declaration of struct Distance…\ntemplate<>\nstruct Distance<SimplePoint> {\n  SimplePoint compute(SimplePoint &A, SimplePoint &B) {\n    return std::sqrt(std::pow(A.X – B.X, 2),…);\n  }\n};\n…\nSimplePoint A, B;\nDistance<SimplePoint>::compute(A, B); // Success\n```", "```cpp\ntemplate<>\nstruct GraphTraits<Function*> {…}\n```", "```cpp\ntemplate<>\nstruct GraphTraits<Function*> {\n  typedef pointer_iterator<Function::iterator> nodes_iterator;\n  static node_iterator nodes_begin(Function *F) {\n    return nodes_iterator(F->begin());\n  }\n  …\n};\n```", "```cpp\ntemplate<>\nstruct GraphTraits<CallGraph*> {\n  typedef mapped_iterator<CallGraph::iterator, \n  decltype(&CGGetValuePtr)> nodes_iterator;\n  static node_iterator nodes_begin(CallGraph *CG) {\n    return nodes_iterator(CG->begin(), &CGGetValuePtr);\n  }\n};\n```", "```cpp\ntemplate<class GraphTy,\n         typename GT = GraphTraits<GraphTy>>\n  auto find_tail(GraphTy G) {\n  for(auto NI = GT::nodes_begin(G); NI != GT::nodes_end(G);    ++NI) {\n    // A node in this graph\n    auto Node = *NI;\n    // Child iterator for this particular node\n    auto ChildIt = GT::child_begin(Node);\n    auto ChildItEnd = GT::child_end(Node);\n    if (ChildIt == ChildItEnd)\n      // No child nodes\n      return Node;\n  }\n  …\n}\n```", "```cpp\n// `F` has the type of `Function*`\nBasicBlock *TailBB = find_tail(F);\n// `CG` has the type of `CallGraph*`\nCallGraphNode *TailCGN = find_tail(CG);\n```", "```cpp\n// the following code is NOT in SSA form\nx = 94;\nx = 87; // `x` is assigned the second time, not SSA!\n```", "```cpp\nx = 94;\ny = x + 4; // first time `x` is used\nz = x + 2; // second time `x` is used\n```", "```cpp\nx = 94;\nx = x * y; // `x` is assigned more than once, not SSA!\nx = x + 5;\n```", "```cpp\nx0 = 94;\nx1 = x0 * y;\nx2 = x1 + 5;\n```", "```cpp\n// let's say `I` represents an instruction `x = a + b`\nInstruction *I = …;\nValue *V = I; // `V` effectively represents the value `x`\n```", "```cpp\nInstruction *BinI = BinaryOperator::Create(Instruction::Add,…);\nInstruction *RetI = ReturnInst::Create(…, BinI, …);\n```", "```cpp\nx = a + b;\nreturn x;\n```", "```cpp\n// `Usr` has the type of `User*`\nfor (Value *V : Usr->operand_values()) {\n  // Working with `V`\n}\n```", "```cpp\nvoid vulnerable() {\n  v = get_password();\n  …\n  bar(v); // WARNING: sensitive information leak to `bar`!\n}\n```", "```cpp\nUser *find_leakage(CallInst *GetPWDCall) {\n  for (auto *Usr : GetPWDCall->users()) {\n    if (isa<CallInst>(Usr)) {\n      return Usr;\n    }\n  }\n  …\n}\n```", "```cpp\n// `V` has the type of `Value*`\nfor (User *Usr : V->users()) {\n  // Working with `Usr`\n}\n```", "```cpp\nclass Parent {…};\nclass Child1 : public Parent {…};\nclass Child2 : public Parent {…};\nvoid foo() {\n  Parent *P = new Child1();\n  Child1 *C = dynamic_cast<Child1*>(P); // OK\n  Child2 *O = dynamic_cast<Child2*>(P); // Error: bails out at                                         // runtime\n}\n```", "```cpp\n// `I` has the type of `Instruction*`\nif (isa<BinaryOperator>(I)) {\n  // `I` can be casted to `BinaryOperator*`\n}\n```", "```cpp\n// `I` has the type of `Instruction*`\nif (isa<BinaryOperator>(I)) {\n  BinaryOperator *BinOp = cast<BinaryOperator>(I);\n}\n```", "```cpp\n// `I` has the type of `Instruction*`\nif (BinaryOperator *BinOp = dyn_cast<BinaryOperator>(I)) {\n  // Work with `BinOp`\n}\n```", "```cpp\nInstruction *BinI = BinaryOperator::Create(…);\nInstruction *RetI = ReturnInst::Create(…, BinI, …);\n```", "```cpp\n    Instruction *BinOp will be placed before the one represented by BeforeI. This method, however, can't be ported across different instruction classes. Not every instruction class has factory methods that provide this feature and even if they do provide them, the API might not be the same.\n    ```", "```cpp\n    // `BB` has the type of `BasicBlock*`\n    IRBuilder instance, we need to designate an *insertion point* as one of the constructor arguments. This insertion point argument can be a BasicBlock, which means we want to insert a new instruction at the end of BasicBlock; it can also be an Instruction instance, which means that new instructions are going to be inserted *before* that specific Instruction. You are encouraged to use `IRBuilder` over other mechanisms if possible whenever you need to create and insert new instructions in sequential order.\n    ```", "```cpp\n    void replacePow2Mul(BinaryOperator &Mul) {\n      // Find the operand that is a power-of-2 integer   // constant\n      int ConstIdx = isa<ConstantInt>(Mul.getOperand(0))? 0    : 1;\n      ConstantInt *ShiftAmount = getLog2(Mul.   getOperand(ConstIdx));\n    }\n    ```", "```cpp\n    void replacePow2Mul(BinaryOperator &Mul) {\n      …\n      // Get the other operand from the original instruction\n      auto *Base = Mul.getOperand(ConstIdx? 0 : 1);\n      // Create an instruction representing left-shifting\n      IRBuilder<> Builder(&Mul);\n      auto *Shl = Builder.CreateShl(Base, ShiftAmount);\n    }\n    ```", "```cpp\n    void replacePow2Mul(BinaryOperator &Mul) {\n      …\n      // Using `replaceAllUsesWith` to update users of `Mul`\n      Mul.Mul are using Shl instead. Thus, we can safely remove Mul from the program.\n    ```", "```cpp\n// `BB` has the type of `BasicBlock&`\nfor (Instruction &I : BB) {\n  if (auto *BinOp = dyn_cast<BinaryOperator>(&I)) {\n    if (isMulWithPowerOf2(BinOp))\n      replacePow2Mul(BinOp);\n  }\n}\n```", "```cpp\n// `BB` has the type of `BasicBlock&`\nstd::vector<BinaryOperator*> Worklist;\n// Only perform the feasibility check\nfor (auto &I : BB) {\n  if (auto *BinOp = dyn_cast<BinaryOperator>(&I)) {\n    if (isMulWithPowerOf2(BinOp)) Worklist.push_back(BinOp);\n  }\n}\n// Replace the target instructions at once\nfor (auto *BinOp : Worklist) {\n  replacePow2Mul(BinOp);\n}\n```", "```cpp\n#include \"llvm/Analysis/LoopInfo.h\"\n…\nPreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM) {\n  LoopInfo &LI = FAM.getResult<LoopAnalysis>(F);\n  // `LI` contains ALL `Loop` instances in `F`\n  for (Loop *LP : LI) {\n    // Working with one of the loops, `LP`\n  }\n  …\n}\n```", "```cpp\nfor (int i = 0; i < 87; ++i){…}\n```", "```cpp\n// `N` is not a constant\nfor (int i = 0; i < N; ++i){…}\n```", "```cpp\nif (i < N) {\n  do {\n    …\n    ++i;\n  } while(i < N);\n}\n```", "```cpp\nPreservedAnalyses run(<IR unit class> &Unit,\n                      <IR unit>AnalysisManager &AM);\n```", "```cpp\nPreservedAnalyses run(Loop &LP, LoopAnalysisManager &LAM,\n                      LoopStandardAnalysisResults &LAR,\n                      LPMUpdater &U);\n```", "```cpp\nPreservedAnalyses run(Loop &LP, LoopAnalysisManager &LAM,\n                      LoopStandardAnalysisResults &LAR,\n                      LPMUpdater &U) {\n  …\n  LoopNest &LN = LAM.getResult<LoopNestAnalysis>(LP, LAR);\n  …\n}\n```", "```cpp\n// `LP` has the type of `Loop&`\nfor (Loop *SubLP : LP) {\n  // `SubLP` is one of the sub-loops at the next layer\n}\n```", "```cpp\n    #include \"llvm/Analysis/LoopInfo.h\"\n    #include \"llvm/ADT/DepthFirstIterator.h\"\n    …\n    // `RootL` has the type of `Loop*`\n    for (GraphTraits, we can have more flexibility when it comes to traversing a loop tree.\n    ```", "```cpp\n    // Perfect loops\n    for(int i=…) {\n      for(int j=…){…}\n    }\n    // Non-perfect loops\n    for(int x=…) {\n      foo call site is the gap between the upper and lower loops.Perfect loops are preferrable in many loop optimizations. For example, it's easier to *unroll* perfectly nested loops – ideally, we only need to duplicate the body of the innermost loop.\n    ```"]