["```cpp\n    void DepthPeeling::draw(\n        VkCommandBuffer commandBuffer, int index,\n        const std::vector<\n            std::shared_ptr<VulkanCore::Buffer>>\n            &buffers,\n        uint32_t numMeshes) {\n      {\n        // Clear Depth 1\n        vkCmdClearDepthStencilImage(\n            commandBuffer,\n            depthTextures_[1]->vkImage(),\n            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n            &clearDepth, 1, &range);\n      }\n      {\n        // Clear color attachments\n        vkCmdClearColorImage(\n            commandBuffer,\n            colorTextures_[0]->vkImage(),\n            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n            &clearColor, 1, &range);\n        vkCmdClearColorImage(\n            commandBuffer,\n            colorTextures_[1]->vkImage(),\n            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n            &clearColor, 1, &range);\n      }\n    ```", "```cpp\n      VulkanCore::DynamicRendering::\n          AttachmentDescription colorAttachmentDesc{\n              .imageView =\n                  colorTextures_[0]->vkImageView(),\n              .imageLayout =\n                  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,\n              .attachmentLoadOp =\n                  VK_ATTACHMENT_LOAD_OP_LOAD,\n              .attachmentStoreOp =\n                  VK_ATTACHMENT_STORE_OP_STORE,\n              .clearValue = clearValues[0],\n          };\n      VulkanCore::DynamicRendering::\n          AttachmentDescription depthAttachmentDesc{\n              .imageView =\n                  depthTextures_[0]->vkImageView(),\n              .imageLayout =\n                  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,\n              .attachmentLoadOp =\n                  VK_ATTACHMENT_LOAD_OP_CLEAR,\n              .attachmentStoreOp =\n                  VK_ATTACHMENT_STORE_OP_STORE,\n              .clearValue = clearValues[1],\n          };\n    ```", "```cpp\n      for (uint32_t currentPeel = 0;\n           currentPeel < numPeels_; ++currentPeel) {\n        colorTextures_[currentPeel % 2]\n            ->transitionImageLayout(\n                commandBuffer,\n                VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n        colorTextures_[(currentPeel + 1) % 2]\n            ->transitionImageLayout(\n                commandBuffer,\n                VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n        depthTextures_[currentPeel % 2]\n            ->transitionImageLayout(\n                commandBuffer,\n                VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);\n        depthTextures_[(currentPeel + 1) % 2]\n            ->transitionImageLayout(\n                commandBuffer,\n                VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n        colorAttachmentDesc.imageView =\n            colorTextures_[currentPeel % 2]\n                ->vkImageView();\n        depthAttachmentDesc.imageView =\n            depthTextures_[currentPeel % 2]\n                ->vkImageView();\n    ```", "```cpp\n        VulkanCore::DynamicRendering::beginRenderingCmd(\n            commandBuffer,\n            colorTextures_[currentPeel % 2]\n                ->vkImage(),\n            0,\n            {{0, 0},\n             {colorTextures_[currentPeel % 2]\n                  ->vkExtents()\n                  .width,\n              colorTextures_[currentPeel % 2]\n                  ->vkExtents()\n                  .height}},\n            1, 0, {colorAttachmentDesc},\n            &depthAttachmentDesc, nullptr,\n            colorTextures_[currentPeel % 2]\n                ->vkLayout(),\n            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n        vkCmdSetViewport(commandBuffer, 0, 1,\n                         &viewport_);\n        vkCmdSetScissor(commandBuffer, 0, 1,\n                        &scissor_);\n        pipeline_->bind(commandBuffer);\n        ... // Perform the draw call\n        VulkanCore::DynamicRendering::endRenderingCmd(\n            commandBuffer,\n            colorTextures_[currentPeel % 2]\n                ->vkImage(),\n            VK_IMAGE_LAYOUT_UNDEFINED,\n            VK_IMAGE_LAYOUT_UNDEFINED);\n    ```", "```cpp\n        vkCmdBlitImage(\n            commandBuffer,\n            colorTextures_[currentPeel % 2]\n                ->vkImage(),\n            VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,\n            colorTextures_[(currentPeel + 1) % 2]\n                ->vkImage(),\n            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1,\n            &region, VK_FILTER_NEAREST);\n    ```", "```cpp\n    #version 460\n    layout(set = 1,\n           binding = 0) uniform ObjectProperties {\n      vec4 color;\n      mat4 model;\n    }objectProperties;\n    layout(set = 2,\n           binding = 0) uniform sampler2D depth;\n    layout(set = 2, binding = 2) uniform sampler2D\n        temporaryColor;\n    layout(location = 0) out vec4 outColor;\n    void main() {\n      float fragDepth = gl_FragCoord.z;\n      float peelDepth =\n          texture(depth, gl_FragCoord.xy /\n                             textureSize(depth, 0))\n              .r;\n      if (fragDepth <= peelDepth) {\n        discard;\n      }\n      vec4 tmpColor =\n          texture(temporaryColor,\n                  gl_FragCoord.xy /\n                      textureSize(temporaryColor, 0));\n      vec3 mulTmpColor = tmpColor.xyz * tmpColor.a;\n      vec3 mulObjProp = objectProperties.color.xyz *\n                        (1.0 - tmpColor.a);\n      outColor = vec4(\n          tmpColor.a * (objectProperties.color.a *\n                        objectProperties.color.rgb) +\n              tmpColor.rgb,\n          (1 - objectProperties.color.a) *\n              tmpColor.a);\n    }\n    ```", "```cpp\n    const VkPipelineColorBlendAttachmentState\n        depthBlendState = {\n        .blendEnable = true,\n        .srcColorBlendFactor =\n            VK_BLEND_FACTOR_SRC_ALPHA,\n        .dstColorBlendFactor =\n            VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,\n        .colorBlendOp = VK_BLEND_OP_MAX,\n        .srcAlphaBlendFactor =\n            VK_BLEND_FACTOR_SRC_ALPHA,\n        .dstAlphaBlendFactor =\n            VK_BLEND_FACTOR_DST_ALPHA,\n        .alphaBlendOp = VK_BLEND_OP_MAX,\n        .colorWriteMask =\n            VK_COLOR_COMPONENT_R_BIT |\n            VK_COLOR_COMPONENT_G_BIT |\n            VK_COLOR_COMPONENT_B_BIT |\n            VK_COLOR_COMPONENT_A_BIT,\n    };\n    const VkPipelineColorBlendAttachmentState\n        frontBlendState = {\n        // front color attachment\n        .blendEnable = true,\n        .srcColorBlendFactor =\n            VK_BLEND_FACTOR_DST_ALPHA,\n        .dstColorBlendFactor =\n            VK_BLEND_FACTOR_ONE,\n        .colorBlendOp = VK_BLEND_OP_ADD,\n        .srcAlphaBlendFactor =\n            VK_BLEND_FACTOR_ZERO,\n        .dstAlphaBlendFactor =\n            VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,\n        .alphaBlendOp = VK_BLEND_OP_ADD,\n        .colorWriteMask =\n            VK_COLOR_COMPONENT_R_BIT |\n            VK_COLOR_COMPONENT_G_BIT |\n            VK_COLOR_COMPONENT_B_BIT |\n            VK_COLOR_COMPONENT_A_BIT,\n    };\n    const VkPipelineColorBlendAttachmentState\n        backBlendState = {\n        // back color attachment\n        .blendEnable = true,\n        .srcColorBlendFactor =\n            VK_BLEND_FACTOR_SRC_ALPHA,\n        .dstColorBlendFactor =\n            VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,\n        .colorBlendOp = VK_BLEND_OP_ADD,\n        .srcAlphaBlendFactor =\n            VK_BLEND_FACTOR_ZERO,\n        .dstAlphaBlendFactor =\n            VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,\n        .alphaBlendOp = VK_BLEND_OP_ADD,\n        .colorWriteMask =\n            VK_COLOR_COMPONENT_R_BIT |\n            VK_COLOR_COMPONENT_G_BIT |\n            VK_COLOR_COMPONENT_B_BIT |\n            VK_COLOR_COMPONENT_A_BIT,\n    };\n    ```", "```cpp\n    void DualDepthPeeling::draw(\n        VkCommandBuffer commandBuffer, int index,\n        const std::vector<\n            std::shared_ptr<VulkanCore::Buffer>>\n            &buffers,\n        uint32_t numMeshes) {\n      // Clear Depth 0\n      {\n        vkCmdClearColorImage(\n            commandBuffer,\n            depthMinMaxTextures_[0]->vkImage(),\n            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n            &clearColor, 1, &range);\n      }\n      // Clear Depth 1\n      {\n        vkCmdClearColorImage(\n            commandBuffer,\n            depthMinMaxTextures_[1]->vkImage(),\n            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n            &clearColor, 1, &range);\n      }\n      // Clear color attachments\n      {\n        for (uint32_t i = 0;\n             i < colorTextures_.size(); ++i) {\n          vkCmdClearColorImage(\n              commandBuffer,\n              colorTextures_[i]->vkImage(),\n              VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n              &clearColor, 1, &range);\n        }\n      }\n    ```", "```cpp\n      depthMinMaxTextures_[0]->transitionImageLayout(\n          commandBuffer,\n          VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n      depthMinMaxTextures_[1]->transitionImageLayout(\n          commandBuffer,\n          VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n    ```", "```cpp\n      VulkanCore::DynamicRendering::AttachmentDescription\n          colorAttachmentDesc_Front{\n              .imageView = colorTextures_[0]\n                               ->vkImageView(),\n              .imageLayout =\n                  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,\n              .attachmentLoadOp =\n                  VK_ATTACHMENT_LOAD_OP_LOAD,\n              .attachmentStoreOp =\n                  VK_ATTACHMENT_STORE_OP_STORE,\n          };\n      VulkanCore::DynamicRendering::AttachmentDescription\n          colorAttachmentDesc_Back{\n              .imageView = colorTextures_[1]\n                               ->vkImageView(),\n              .imageLayout =\n                  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,\n              .attachmentLoadOp =\n                  VK_ATTACHMENT_LOAD_OP_LOAD,\n              .attachmentStoreOp =\n                  VK_ATTACHMENT_STORE_OP_STORE,\n          };\n      const VkClearValue clearDepthMinMax = {\n          .color = {-99999.0f, -99999.0f, 0.0f,\n                    0.0f},\n      };\n      VulkanCore::DynamicRendering::AttachmentDescription\n          depthMinMaxAttachmentDesc{\n              .imageView =\n                  depthMinMaxTextures_[0]\n                      ->vkImageView(),\n              .imageLayout =\n                  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,\n              .attachmentLoadOp =\n                  VK_ATTACHMENT_LOAD_OP_CLEAR,\n              .attachmentStoreOp =\n                  VK_ATTACHMENT_STORE_OP_STORE,\n              .clearValue = clearDepthMinMax,\n          };\n    ```", "```cpp\n      for (uint32_t currentPeel = 0;\n           currentPeel < numPeels_;\n           ++currentPeel) {\n        const uint32_t readIdx = currentPeel % 2;\n        colorTextures_[0]->transitionImageLayout(\n            commandBuffer,\n            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n        colorTextures_[1]->transitionImageLayout(\n            commandBuffer,\n            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n        depthMinMaxTextures_[currentPeel % 2]\n            ->transitionImageLayout(\n                commandBuffer,\n                VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n        depthMinMaxTextures_[(currentPeel + 1) %\n                             2]\n            ->transitionImageLayout(\n                commandBuffer,\n                VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n        depthMinMaxAttachmentDesc.imageView =\n            depthMinMaxTextures_[readIdx]\n                ->vkImageView();\n    ```", "```cpp\n        VulkanCore::DynamicRendering::\n            beginRenderingCmd(\n                commandBuffer,\n                colorTextures_[0]->vkImage(), 0,\n                {{0, 0},\n                 {colorTextures_[0]\n                      ->vkExtents()\n                      .width,\n                  colorTextures_[0]\n                      ->vkExtents()\n                      .height}},\n                1, 0,\n                {depthMinMaxAttachmentDesc,\n                 colorAttachmentDesc_Front,\n                 colorAttachmentDesc_Back},\n                &depthAttachmentDesc, nullptr,\n                colorTextures_[0]->vkLayout(),\n                VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n        vkCmdSetViewport(commandBuffer, 0, 1,\n                         &viewport_);\n        vkCmdSetScissor(commandBuffer, 0, 1,\n                        &scissor_);\n        pipeline_->bind(commandBuffer);\n        // Draw geometry\n        VulkanCore::DynamicRendering::\n            endRenderingCmd(\n                commandBuffer,\n                colorTextures_[0]->vkImage(),\n                VK_IMAGE_LAYOUT_UNDEFINED,\n                VK_IMAGE_LAYOUT_UNDEFINED);\n      }\n    ```", "```cpp\n      {\n        VulkanCore::DynamicRendering::\n            beginRenderingCmd(...);\n        vkCmdSetViewport(commandBuffer, 0, 1,\n                         &viewport_);\n        vkCmdSetScissor(commandBuffer, 0, 1,\n                        &scissor_);\n        pipelineFinal_->bind(commandBuffer);\n        vkCmdDraw(commandBuffer, 4, 1, 0, 0);\n        VulkanCore::DynamicRendering::\n            endRenderingCmd(...);\n      }\n    }\n    ```", "```cpp\n    #version 460\n    const float MAX_DEPTH = 99999.0;\n    void main() {\n      float fragDepth = gl_FragCoord.z;\n      vec2 lastDepth =\n          texture(depth,\n                  gl_FragCoord.xy /\n                      textureSize(depth, 0)).rg;\n      depthMinMax.rg = vec2(-MAX_DEPTH);\n      frontColorOut = vec4(0.0f);\n      backColorOut = vec4(0.0f);\n      float nearestDepth = -lastDepth.x;\n      float furthestDepth = lastDepth.y;\n      float alphaMultiplier = 1.0 - lastFrontColor.a;\n      if (fragDepth < nearestDepth ||\n          fragDepth > furthestDepth) {\n        return;\n      }\n      if (fragDepth > nearestDepth &&\n          fragDepth < furthestDepth) {\n        depthMinMax = vec2(-fragDepth, fragDepth);\n        return;\n      }\n      vec4 color = objectProperties.color;\n      if (fragDepth == nearestDepth) {\n        frontColorOut = vec4(\n            color.rgb * color.a, color.a);\n      } else {\n        backColorOut = color;\n      }\n    }\n    ```", "```cpp\n    #version 460\n    layout(set = 0, binding = 0)\n        uniform sampler2D front;\n    layout(set = 0, binding = 1)\n        uniform sampler2D back;\n    layout(location = 0) in vec2\n        fragTexCoord;\n    layout(location = 0) out vec4 outColor;\n    void main() {\n      const vec4 frontColor =\n          texture(front, fragTexCoord);\n      const vec4 backColor =\n          texture(back, fragTexCoord);\n      outColor =\n          vec4(((backColor)*frontColor.a +\n                frontColor)\n                   .rgb,\n               (1.0 - backColor.a) *\n                   frontColor.a);\n    }\n    ```", "```cpp\n    atomicCounterBuffer_ = context->createBuffer(\n        sizeof(AtomicCounter), ...);\n    auto bufferSize = width * height *\n                      slotsPerPixel *\n                      sizeof(Node);\n    linkedListBuffer_ = context_->createBuffer(\n        bufferSize, ...);\n    linkedListHeadPtrTexture_ =\n        context->createTexture(...);\n    ```", "```cpp\n    vkCmdClearColorImage(\n        commandBuffer,\n        linkedListHeadPtrTexture_\n            ->vkImage(),\n        VK_IMAGE_LAYOUT_GENERAL,\n        &clearColor, 1, &auxClearRanges);\n    vkCmdFillBuffer(\n        commandBuffer,\n        linkedListBuffer_->vkBuffer(), 0,\n        VK_WHOLE_SIZE, 0);\n    vkCmdFillBuffer(\n        commandBuffer,\n        atomicCounterBuffer_->vkBuffer(), 0,\n        VK_WHOLE_SIZE, 0);\n    ```", "```cpp\n    const VkPipelineStageFlags\n        srcStageFlags =\n            VK_PIPELINE_STAGE_TRANSFER_BIT;\n    const VkPipelineStageFlags dstStageFlags =\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;\n    {\n      const VkMemoryBarrier barrier = {\n          .sType =\n              VK_STRUCTURE_TYPE_MEMORY_BARRIER,\n          .srcAccessMask =\n              VK_ACCESS_TRANSFER_WRITE_BIT,\n          .dstAccessMask =\n              VK_ACCESS_SHADER_READ_BIT |\n              VK_ACCESS_SHADER_WRITE_BIT,\n      };\n      vkCmdPipelineBarrier(\n          commandBuffer, srcStageFlags,\n          dstStageFlags,\n          0,\n          1, &barrier,\n          0, VK_NULL_HANDLE,\n          0, VK_NULL_HANDLE);\n    ```", "```cpp\n      const VkBufferMemoryBarrier bufferBarriers[2] = {\n          {\n              .sType =\n                  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,\n              .srcAccessMask =\n                  VK_ACCESS_TRANSFER_WRITE_BIT,\n              .dstAccessMask =\n                  VK_ACCESS_SHADER_READ_BIT |\n                  VK_ACCESS_SHADER_WRITE_BIT,\n              .buffer = linkedListBuffer_->vkBuffer(),\n              .size = linkedListBuffer_->size(),\n          },\n          {\n              .sType =\n                  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,\n              .srcAccessMask =\n                  VK_ACCESS_TRANSFER_WRITE_BIT,\n              .dstAccessMask =\n                  VK_ACCESS_SHADER_READ_BIT |\n                  VK_ACCESS_SHADER_WRITE_BIT,\n              .buffer = atomicCounterBuffer_->vkBuffer(),\n              .size = atomicCounterBuffer_->size(),\n          },\n      };\n      vkCmdPipelineBarrier(\n          commandBuffer, srcStageFlags,\n          dstStageFlags, 0, 0, nullptr, 2,\n          &bufferBarriers[0], 0, nullptr);\n    }\n    ```", "```cpp\n    pipeline_->bind(commandBuffer);\n    for (uint32_t meshIdx = 0;\n         meshIdx < numMeshes; ++meshIdx) {\n      // ...\n      vkCmdDrawIndexed(commandBuffer,\n                       vertexCount, 1, 0, 0,\n                       0);\n    }\n    ```", "```cpp\n    struct Node {\n      vec4 color;\n      uint previousIndex;\n      float depth;\n      uint padding1; // add 4 byte padding\n                     // for alignment\n      uint padding2; // add 4 byte padding\n                     // for alignment\n    };\n    layout(set = 1, binding = 0) uniform\n        ObjectProperties {\n      vec4 color;\n      mat4 model;\n    }\n    objectProperties;\n    layout(set = 2, binding = 0) buffer\n        AtomicCounter {\n      uint counter;\n    };\n    layout(set = 2,\n           binding = 1) buffer LinkedList {\n      Node transparencyList[];\n    }\n    transparencyLinkedList;\n    layout(set = 2, binding = 2,\n           r32ui) uniform coherent uimage2D\n        headPointers;\n    ```", "```cpp\n    void main() {\n      // Set the output color to transparent\n      outputColor = vec4(0.0);\n      // Atomic operation to get unique\n      // index for each fragment, don't\n      // return 0 since that will be used as\n      // ll terminator\n      uint newNodeIndex =\n          atomicAdd(counter, 1) + 1;\n      ivec2 size = imageSize(headPointers);\n      // max size of linked list * width *\n      // height\n      if (newNodeIndex >\n          (10 * size.x * size.y) - 1) {\n        return;\n      }\n      // Atomic operation to insert the new\n      // node at the beginning of the linked\n      // list\n      uint oldHeadIndex =\n          imageAtomicExchange(\n              headPointers,\n              ivec2(gl_FragCoord.xy),\n              newNodeIndex);\n      transparencyLinkedList\n          .transparencyList[newNodeIndex]\n          .previousIndex = oldHeadIndex;\n      transparencyLinkedList\n          .transparencyList[newNodeIndex]\n          .color = objectProperties.color;\n      transparencyLinkedList\n          .transparencyList[newNodeIndex]\n          .depth = gl_FragCoord.z;\n      transparencyLinkedList\n          .transparencyList[newNodeIndex]\n          .padding1 = 0;\n      transparencyLinkedList\n          .transparencyList[newNodeIndex]\n          .padding2 = 0;\n    }\n    ```", "```cpp\n    void main() {\n      outputColor = vec4(0.0);\n      // Get the head of the linked list for\n      // the current pixel\n      uint nodeIndex = imageLoad(headPointers,\n                    ivec2(gl_FragCoord.xy)).x;\n      // Create a temporary array to store\n      // the nodes for sorting\n      Node nodes[20]; // Assuming a maximum\n                      // of 20 overlapping\n                      // fragments\n      int numNodes = 0;\n      // Iterate over the linked list\n      while (nodeIndex != 0 &&\n             numNodes < 20) {\n        nodes[numNodes] = transparencyLinkedList.transparencyList[nodeIndex];\n        nodeIndex = nodes[numNodes].previousIndex;\n        numNodes++;\n      }\n    ```", "```cpp\n      for (int i = 0; i < numNodes; i++) {\n        for (int j = i + 1; j < numNodes; j++) {\n          if (nodes[j].depth > nodes[i].depth) {\n            Node temp = nodes[i];\n            nodes[i] = nodes[j];\n            nodes[j] = temp;\n          }\n        }\n      }\n    ```", "```cpp\n      // Blend the colors from back to front\n      for (int i = 0; i < numNodes; i++) {\n        outputColor = mix(outputColor, nodes[i].color,\n                nodes[i].color.a);\n      }\n    }\n    ```", "```cpp\n    colorTexture_ =\n          context->createTexture(VK_IMAGE_TYPE_2D, VK_FORMAT_R16G16B16A16_SFLOAT ...\n    ```", "```cpp\n    alphaTexture_ =\n          context->createTexture(VK_IMAGE_TYPE_2D, VK_FORMAT_R16_SFLOAT ...\n    ```", "```cpp\n    const VulkanCore::Pipeline::\n      GraphicsPipelineDescriptor gpDesc = {\n        .blendAttachmentStates_ = {\n          VkPipelineColorBlendAttachmentState{\n            .blendEnable = VK_TRUE,\n            .srcColorBlendFactor =\n              VK_BLEND_FACTOR_ONE,\n            .dstColorBlendFactor =\n              VK_BLEND_FACTOR_ONE,\n            .colorBlendOp = VK_BLEND_OP_ADD,\n            .srcAlphaBlendFactor =\n              VK_BLEND_FACTOR_ONE,\n            .dstAlphaBlendFactor =\n              VK_BLEND_FACTOR_ONE,\n            .alphaBlendOp = VK_BLEND_OP_ADD,\n            .colorWriteMask =\n              VK_COLOR_COMPONENT_R_BIT |\n              VK_COLOR_COMPONENT_G_BIT |\n              VK_COLOR_COMPONENT_B_BIT |\n              VK_COLOR_COMPONENT_A_BIT,\n          },\n    ```", "```cpp\n             VkPipelineColorBlendAttachmentState{\n              .blendEnable = VK_TRUE,\n              .srcColorBlendFactor =\n                VK_BLEND_FACTOR_ZERO,\n              .dstColorBlendFactor =\n                VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,\n              .colorBlendOp = VK_BLEND_OP_ADD,\n              .srcAlphaBlendFactor =\n                VK_BLEND_FACTOR_ZERO,\n              .dstAlphaBlendFactor =\n                VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,\n              .alphaBlendOp = VK_BLEND_OP_ADD,\n              .colorWriteMask =\n                VK_COLOR_COMPONENT_R_BIT |\n                VK_COLOR_COMPONENT_G_BIT |\n                VK_COLOR_COMPONENT_B_BIT |\n                VK_COLOR_COMPONENT_A_BIT,\n            },\n          },\n    };\n    ```", "```cpp\n    void main() {\n      const float scaledDepth =\n          -(inViewSpaceDepth * 3.0) / 200;\n      float maxColorComponent =\n          max(max(objectProperties.color.r,\n                  objectProperties.color.g),\n              objectProperties.color.b);\n      float weightedColor =\n          maxColorComponent *\n          objectProperties.color.a;\n      float weightedColorAlpha =\n          max(min(1.0, weightedColor),\n              objectProperties.color.a);\n      float depthWeight =\n          0.03 /\n          (1e-5 + pow(scaledDepth, 4.0));\n      depthWeight =\n          clamp(depthWeight, 0.01, 4000);\n      const float weight =\n          weightedColorAlpha * depthWeight;\n      outputColor =\n          vec4(objectProperties.color.rgb *\n                   objectProperties.color.a,\n               objectProperties.color.a) *\n          weight;\n      outputAlpha =\n          objectProperties.color.a;\n    }\n    ```", "```cpp\n    void main() {\n      vec4 accumulateColor =\n          texture(colorData, fragTexCoord);\n      float alpha =\n          texture(alphaData, fragTexCoord)\n              .r;\n      outColor = vec4(\n          accumulateColor.rgb /\n              max(accumulateColor.a, .0001),\n          alpha);\n    }\n    ```"]