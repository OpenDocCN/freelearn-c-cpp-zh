<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-195"><a id="_idTextAnchor196"/>10</h1>
<h1 id="_idParaDest-196"><a id="_idTextAnchor197"/>Enhancing the Player Experience</h1>
<p>One of the best ways to improve a video game is to add a good look and feel to it. A great-looking game will create an immersive experience that will engage players and make them want to keep coming back for more.</p>
<p>For this reason, it’s important for developers to focus on tweaking visual and audio feedback until everything looks just right! It might take some time, but getting these last touches right will make sure your video game has an awesome look and feel – something that players won’t forget anytime soon!</p>
<p>Keeping this in mind, the following chapter will concentrate on improving certain aspects, such as <a id="_idIndexMarker546"/>using different animations together and synchronizing them over the network, or adding <strong class="bold">non-player characters</strong> (<strong class="bold">NPCs</strong>) to interact with – features that your protagonist has longed for a considerable amount of time.</p>
<p>Additionally, you’ll be providing a purpose for your players to fight for: the daring rescue of some imprisoned comrades!</p>
<p>Finally, I’ll share some additional ideas to help guide you in completing your multiplayer game. This book may not have enough pages to cover every detail, but that shouldn’t stop your creativity and imagination from taking flight!</p>
<p>By the end of this chapter, you will possess a sleek and robust prototype for your multiplayer game and be well equipped and prepared to embark on the next phase – learning how to optimize it.</p>
<p>In this chapter, I will guide you through the following sections:</p>
<ul>
<li>Animating the character</li>
<li>Adding NPC Actors</li>
<li>Making further improvements to the game</li>
</ul>
<h1 id="_idParaDest-197"><a id="_idTextAnchor198"/>Technical requirements</h1>
<p>To follow the topics presented in this chapter, you should have completed the previous ones and understood their content.</p>
<p>Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the <code>.zip</code> project files provided:</p>
<p><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a></p>
<p>You can download the files that are up to date with the end of the last chapter by clicking the <code>Unreal Shadows – </code><code>Chapter 09</code><code> </code><code>End</code> link.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/>Animating the character</h1>
<p>So far, your hero has been exploring the dungeon and searching for hidden treasures while avoiding <a id="_idIndexMarker547"/>enemies, but there’s something missing that will really bring it to life – a proper animation system.</p>
<p>In this section, I’ll guide you through the creation of simple animations that will work on the networked environment of your project. This will involve creating Blueprints specifically designed for the animation system and establishing their connection to your character class – you will be creating the needed animation assets and then adding the needed code to make everything work properly.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Creating the animation assets</h2>
<p>Animating characters in <a id="_idIndexMarker548"/>Unreal Engine involves creating <strong class="bold">Animation Blueprints</strong> that handle the motion and logic of character movement and actions. This <a id="_idIndexMarker549"/>book doesn’t prioritize this topic – in fact, it’s not usually the main focus for game programmers! However, having some <a id="_idIndexMarker550"/>basic knowledge of how things work under the hood will be a good addition to your game development arsenal.</p>
<p>To create a simple but fully functional animation system for the player character, we will need three assets:</p>
<ul>
<li>An asset to control the movement transitions from idle to walk to run, and vice versa</li>
<li>An asset used to play the throw animation</li>
<li>A Blueprint to control the two aforementioned assets</li>
</ul>
<p>To get started, we first <a id="_idIndexMarker551"/>need a folder to put all the assets in. So, open the Unreal Editor and, in <code>Animations</code>. Once it is created, you will be ready to add the first asset.</p>
<h3>Creating the movement Blend Space</h3>
<p>In Unreal Engine, a <strong class="bold">Blend Space</strong> is a special <a id="_idIndexMarker552"/>asset that allows for the blending of animations based on the values of two inputs. It allows multiple animations <a id="_idIndexMarker553"/>to be blended by plotting them onto a one- or two-dimensional graph. Animators and game developers often use blend <a id="_idIndexMarker554"/>spaces to create smooth and realistic transitions between different animations for characters in games.</p>
<p>In our case, we will need to blend three animations – the idle, walk, and sprint ones – that will be managed depending on the character’s speed.</p>
<p>To create this Blend Space, complete the following steps:</p>
<ol>
<li>Inside the <code>Animations</code> folder, right-click and select <strong class="bold">Animation | Blend Space</strong>. Then, from the <strong class="bold">Pick Skeleton</strong> window that will pop up, select <strong class="bold">rogue_Skeleton</strong>, as depicted in <em class="italic">Figure 10</em><em class="italic">.1</em>:</li>
</ol>
<div><div><img alt="Figure 10.1 – Blend Space creation" src="img/Figure_10_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Blend Space creation</p>
<ol>
<li value="2">Name the <a id="_idIndexMarker555"/>newly-created <a id="_idIndexMarker556"/>asset <code>BS_WalkRun</code> and double-click it to open the <strong class="bold">Blend Space </strong><strong class="bold">Editor</strong> window.</li>
<li>In <code>Speed</code></li><li>Set the <code>500</code></li></ul></li>
<li>Leave the <strong class="bold">Vertical Axis</strong> section as it is (i.e., set to <strong class="bold">None</strong>), as we won’t use it.</li>
</ol>
<p>What we have done here is initialize the main setting values for the animation blend, exposing the <strong class="bold">Speed</strong> property that will be used by the controlling Blueprint we will be adding later.</p>
<p>Now, you will be adding the animation assets that will be blended together.</p>
<ol>
<li value="5">Locate the <strong class="bold">rogue_Idle</strong> animation in the <strong class="bold">Asset Browser</strong> and drag it into the graph at the center of the editor. This will create a point in the coordinate system of the diagram.</li>
<li>Select the <a id="_idIndexMarker557"/>point and set its <code>0</code> and its <code>0</code>.</li>
</ol>
<p>You should <a id="_idIndexMarker558"/>get a graph that looks like the one depicted in <em class="italic">Figure 10</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 10.2 – Idle animation settings" src="img/Figure_10_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Idle animation settings</p>
<p>Now, we will add two more assets to the graph – one for the walk animation and one for the run animation.</p>
<ol>
<li value="7">Drag the <code>45</code> and its <code>0</code>.</li>
<li>Again, drag the <code>100</code> and its <code>0</code>.</li>
<li>Drag the <code>500</code> and its <code>0</code>.</li>
</ol>
<p>The complete Blend Space asset can be seen in <em class="italic">Figure 10</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 10.3 – Complete blend space" src="img/Figure_10_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Complete blend space</p>
<p>To test the <a id="_idIndexMarker559"/>animation blends on the character, you can simply press the <em class="italic">Ctrl</em> key and hover the mouse on the zone of the graph <a id="_idIndexMarker560"/>you want to check – you will see the character start a walk-and-move cycle, the animation assets blending seamlessly. The Blend Space is complete, so we can now start creating the asset that will handle the throw animation.</p>
<h3>Creating the throw Animation Montage</h3>
<p>An <strong class="bold">Animation Montage</strong> is a type <a id="_idIndexMarker561"/>of asset that enables the combination <a id="_idIndexMarker562"/>of multiple animations and their selective play from a Blueprint. Animation Montages are commonly used <a id="_idIndexMarker563"/>for creating complex animation sequences such as attack combos, cutscenes, and other interactive gameplay elements. In our project, we will use one to play the single-throw animation from the controlling Blueprint.</p>
<p>To create the Animation Montage, complete the following steps:</p>
<ol>
<li>Inside the <code>Animations</code> folder, right-click and select <strong class="bold">Animation | Animation Montage</strong>. Then, from the <strong class="bold">Pick Skeleton</strong> window that will pop up, select <strong class="bold">rogue_Skeleton</strong>.</li>
<li>Name the newly created asset <code>AM_Throw</code> and double-click it to open the <strong class="bold">Animation Montage </strong><strong class="bold">Editor</strong> window.</li>
<li>From the <strong class="bold">Asset Browser</strong>, drag the <strong class="bold">rogue_Throw</strong> asset – in the <strong class="bold">DefaultGroup.DefaultSlot</strong> line – onto the timeline at the center of the editor.</li>
</ol>
<p>The final <a id="_idIndexMarker564"/>result for the Animation Montage <a id="_idIndexMarker565"/>is shown in <em class="italic">Figure 10</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 10.4 – Throw Animation Montage" src="img/Figure_10_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Throw Animation Montage</p>
<p>This Montage and the previous <strong class="bold">Blend Space</strong> asset will be controlled by a dedicated Blueprint that we are going to add to the project in the next steps.</p>
<h3>Creating the character Animation Blueprint</h3>
<p>An <strong class="bold">Animation Blueprint</strong> is a <a id="_idIndexMarker566"/>specialized type of Blueprint that <a id="_idIndexMarker567"/>is used to create and control complex <a id="_idIndexMarker568"/>animation behaviors for Actors in the game. It defines how animations should be processed and blended together, as well as how animation inputs should be mapped.</p>
<p>In our case, we need to control the Blend Space <strong class="bold">Speed</strong> parameter in order to let the character walk and run when needed, and start the throw Animation Montage when the character is attacking.</p>
<p>To create <a id="_idIndexMarker569"/>the Animation Blueprint, complete <a id="_idIndexMarker570"/>the following steps:</p>
<ol>
<li>Inside the <code>Animations</code> folder, right-click and select <strong class="bold">Animation | Animation Blueprint</strong>. Then, from the <strong class="bold">Create Animation Blueprint</strong> window that will pop up, select <strong class="bold">rogue_Skeleton</strong>, as depicted in <em class="italic">Figure 10</em><em class="italic">.5</em>:</li>
</ol>
<div><div><img alt="Figure 10.5 – Animation Blueprint creation" src="img/Figure_10_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Animation Blueprint creation</p>
<ol>
<li value="2">Name the newly-created asset <code>AB_Character</code> and double-click it to open the editor window.</li>
</ol>
<p>If you are not already familiar with Animation Blueprints, you will notice some similarities to a regular Blueprint class, such as the <strong class="bold">My Blueprints</strong> and <strong class="bold">Event Graph</strong> tabs. If it is not already selected, open <strong class="bold">Event Graph</strong> to start some Visual Scripting code and then continue with the following steps.</p>
<ol>
<li value="3">Add an <strong class="bold">Event Blueprint Initialize </strong><strong class="bold">Animation</strong> node.</li>
<li>Click and <a id="_idIndexMarker571"/>drag from the <strong class="bold">Return Value</strong> outgoing pin of <strong class="bold">Try Get Pawn Owner</strong> (which will already be present in the graph) and add a <strong class="bold">Cast To </strong><strong class="bold">US_Character</strong> node.</li>
<li> Connect <a id="_idIndexMarker572"/>the event execution pin to the cast node incoming execution pin.</li>
<li>From the <code>Character</code>.</li>
<li>From the outgoing pin of the <strong class="bold">Set Character</strong> node, click and drag to add a <strong class="bold">Character Movement</strong> getter node.</li>
<li>From this getter node outgoing pin, click and drag and select <code>Movement Component</code> and connect the <strong class="bold">Set Movement Component</strong> node that will be automatically added to the graph to the execution pin of the <strong class="bold">Set </strong><strong class="bold">Character</strong> node.</li>
</ol>
<p>The final graph is shown in <em class="italic">Figure 10</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 10.6 – Event Blueprint Initialize Animation graph" src="img/Figure_10_06_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Event Blueprint Initialize Animation graph</p>
<p>This visual script is executed when the Blueprint is initialized and basically sets the variables you will need later on, during gameplay.</p>
<p>Now, locate the <strong class="bold">Event Blueprint Update</strong> animation node that should be already present in the graph.</p>
<ol>
<li value="9">From the <strong class="bold">Variables</strong> section, drag a getter node for the <strong class="bold">Character</strong> property. Right-click it <a id="_idIndexMarker573"/>and select the <strong class="bold">Convert to Validated Get</strong> option; this will change the node into an executable <a id="_idIndexMarker574"/>one that will check whether the <strong class="bold">Character</strong> variable is valid.</li>
<li>Connect the <strong class="bold">Event Blueprint Update Animation</strong> execution pin to the incoming execution pin of the <strong class="bold">Get Validated </strong><strong class="bold">Character</strong> node.</li>
<li>In the <code>CharacterSpeed</code>. Drag a <strong class="bold">Set</strong> node for this variable into the graph.</li>
<li>From the <strong class="bold">Variables</strong> section, drag a <strong class="bold">Get</strong> node for the <strong class="bold">Movement </strong><strong class="bold">Component</strong> variable.</li>
<li>Click and drag from the outgoing pin of the <strong class="bold">Movement Component</strong> node and create a <strong class="bold">Get Velocity</strong> property node.</li>
<li>Click and drag from the outgoing pin of the <strong class="bold">Get Velocity</strong> node and create a <strong class="bold">Vector Length </strong><strong class="bold">XY</strong> node.</li>
<li>Connect the <a id="_idIndexMarker575"/>outgoing pin of the <strong class="bold">Vector Length XY</strong> node to the incoming pin of the <strong class="bold">Set Character </strong><strong class="bold">Speed</strong> node.</li>
</ol>
<p>The final <a id="_idIndexMarker576"/>result of the graph is shown in <em class="italic">Figure 10</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 10.7 – Event Blueprint Update graph" src="img/Figure_10_07_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Event Blueprint Update graph</p>
<p>This Visual Scripting code basically tracks the velocity magnitude of the character and stores it in the <strong class="bold">Character Speed</strong> variable, which will be used in the following steps to blend the movement animation.</p>
<p>Next, select the <strong class="bold">AnimGraph</strong> tab of the editor, which will display a single <strong class="bold">Output Pose</strong> – this node represents the final animation pose of the character. We now need to tell the graph how to animate the character.</p>
<ol>
<li value="16">Drag the <strong class="bold">Character Speed</strong> property from the <strong class="bold">Variables</strong> section to create a getter node.</li>
<li>Click and drag from the <strong class="bold">Character Speed</strong> outgoing pin and create a <strong class="bold">Blendspace Player ‘</strong><strong class="bold">BS_WalkRun’</strong> node.</li>
<li>Click and drag the outgoing pin of the <strong class="bold">Blendspace Player ‘BS_WalkRun’</strong> node and <a id="_idIndexMarker577"/>create a <strong class="bold">Slot ‘Default Slot’</strong> node – we will use this node from the C++ code to execute the throw Animation Montage.</li>
<li>Connect the <a id="_idIndexMarker578"/>outgoing pin of <strong class="bold">Slot ‘Default Slot’</strong> to the incoming pin of the <strong class="bold">Output </strong><strong class="bold">Pose</strong> node.</li>
</ol>
<p>The final result of the AnimGraph is depicted in <em class="italic">Figure 10</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 10.8 – AnimGraph" src="img/Figure_10_08_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – AnimGraph</p>
<p>With this final step, the Animation Blueprint is complete; now, you just need to connect it to the character Blueprint to make it work.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor201"/>Adding the Animation System to the character</h2>
<p>To add the animation system to the character, you just have to declare the Animation Blueprint inside <a id="_idIndexMarker579"/>the Blueprint class. To do so, open the <strong class="bold">BP_Character</strong> Blueprint and select the <strong class="bold">Mesh</strong> property. Then, in the <strong class="bold">Details</strong> panel, locate the <strong class="bold">Anim Class</strong> property. From the drop-down menu next to it, select <strong class="bold">AB_Character</strong> as shown in <em class="italic">Figure 10</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 10.9 – Animation Blueprint assigned to the Blueprint class" src="img/Figure_10_09_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Animation Blueprint assigned to the Blueprint class</p>
<p>If you test the game right now, you should see the character starting the animation loop and reacting to the player input when walking and running. However, the run animation will be weirdly jumpy and buggy – this is happening because these animations are not replicated and are just checking the character speed to update.</p>
<p>From a technical point of view, the speed value (i.e., <code>MaxWalkSpeed</code>) is just stored in the server instance of the character, but the client will have its own <code>MaxWalkSpeed</code> value. While this may be acceptable if you are just moving an Actor around, as the server will be constantly updating the Actor position, animating a Skeletal Mesh component based on its speed is a totally different beast. In fact, the Animation System is using the local value (i.e., the client one) and the system will continuously conflict between server and client data, resulting in a broken animation.</p>
<p>That’s why we need to move the start-and-stop sprint logic we implemented in <a href="B18203_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a><em class="italic">, Using Remote Procedure Calls (RPCs),</em> from the server to the client and call the corresponding methods as multicast ones so that all the clients will be aware of this change.</p>
<p>To do so, open the <code>US_Character.h</code> header file and add the following client declarations:</p>
<pre class="source-code">
UFUNCTION(NetMulticast, Reliable)
void SprintStart_Client();
UFUNCTION(NetMulticast, Reliable)
void SprintEnd_Client();</pre>
<p>As you can see, we used the <code>NetMulticast</code> specifier in order to let all the clients know that the character has started sprinting. Additionally, this call needs to be a <code>Reliable</code> one so you are guaranteed to send all the data to the recipients without any packet loss.</p>
<p class="callout-heading">Note</p>
<p class="callout">For a refresher on RPCs and the <code>NetMulticast</code> specifier, please refer to <a href="B18203_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a><em class="italic">, Using Remote Procedure </em><em class="italic">Calls (RPCs)</em>.</p>
<p>Now, open the <code>US_Character.cpp</code> file and locate <code>SprintStart_Server_Implementation()</code> and <code>SprintEnd_Server_Implementation()</code>. You are going to move all the content of both methods <a id="_idIndexMarker580"/>to the corresponding client-side calls. To do so, remove all the content (i.e., the code in between the brackets) and, in <code>SprintStart_Server_Implementation()</code>, add the client-side call:</p>
<pre class="source-code">
SprintStart_Client();</pre>
<p>For the <code>SprintEnd_Server_Implementation()</code> method, add the following:</p>
<pre class="source-code">
SprintEnd_Client();</pre>
<p>After that, move the previously removed code to the client-side implementations:</p>
<pre class="source-code">
void AUS_Character::SprintStart_Client_Implementation()
{
 if (GetCharacterStats())
 {
  GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;SprintSpeed;
 }
}
void AUS_Character::SprintEnd_Client_Implementation()
{
 if (GetCharacterStats())
 {
  GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;
 }
}</pre>
<p>The overall behavior will then be as follows:</p>
<ul>
<li>The client controlled by the player receives the movement inputs and sends this data to the server</li>
<li>The server handles this input and sends the update request to all clients</li>
<li>All the clients update the <code>MaxWalkSpeed</code> value accordingly</li>
</ul>
<p>Once you have <a id="_idIndexMarker581"/>compiled the project, try testing the game – our character can now move and sprint like a pro, and you’ll get to see their animations shine in all their glory!</p>
<p>For some extra practice, try working on the minion character and implementing the same animation logic. This is the true meaning of summoning a bunch of bones to a fully-fledged, reanimated minion, and who knows? The Lichlord might just reward you with a surprise or two for a job well done!</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>Adding the throw animation</h2>
<p>What’s missing <a id="_idIndexMarker582"/>at the moment is the throw animation and, in this <a id="_idIndexMarker583"/>case, network synchronization is something we really want – every connected player in the game will need to see the character animation whenever it is throwing the dagger in the dungeon, and this animation should be played at the same time for all clients.</p>
<p>The first thing to do is to ensure that the WeaponProjectile component will be properly replicated. To do so, open the <code>US_Character.cpp</code> file. Then, in the constructor, locate the <code>Weapon</code> component initialization, and add the following line of code:</p>
<pre class="source-code">
Weapon-&gt;SetIsReplicated(true);</pre>
<p>Next, open <code>US_WeaponProjectileComponent.h</code> and, in the <code>private</code> section, add the following Animation Montage reference:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Projectile", meta=(AllowPrivateAccess = "true"))
UAnimMontage* ThrowAnimation;</pre>
<p>After that, in the <code>protected</code> section, add the following declaration:</p>
<pre class="source-code">
UFUNCTION(NetMulticast, Unreliable)
void Throw_Client();</pre>
<p>This is the <a id="_idIndexMarker584"/>throw method that will be executed from the client side. Notice that we are RPC multicasting to all clients with the <code>Unreliable</code> property specifier – even though we want this animation synchronized over the network, it is just <a id="_idIndexMarker585"/>an aesthetic add-on, so we can afford to lose the data over the network. The other clients won’t see the animation, but the dagger will be spawned anyway.</p>
<p>With the header declarations complete, open the <code>US_WeaponProjectileComponent.cpp</code> file and add the client-side throw method:</p>
<pre class="source-code">
void UUS_WeaponProjectileComponent::Throw_Client_Implementation()
{
 const auto Character = Cast&lt;AUS_Character&gt;(GetOwner());
 if (ThrowAnimation != nullptr)
 {
  if (const auto AnimInstance = Character-&gt;GetMesh()-&gt;GetAnimInstance(); AnimInstance != nullptr)
  {
   AnimInstance-&gt;Montage_Play(ThrowAnimation, 1.f);
  }
 }
}</pre>
<p>As you can see, the code will get the owner of this component and, if it is of the <code>US_Character</code> type, will play the Animation Montage.</p>
<p>This method will be called from its server-side counterpart, so locate the <code>Throw_Server_Implementation()</code> method. We could just execute the method call, but we need to give a slight delay to the spawn logic because the throw animation will take some <a id="_idIndexMarker586"/>time to complete, and spawning the dagger ahead of time would return ugly visual feedback to the player. To do so, remove all the content <a id="_idIndexMarker587"/>of the function and replace it with the following code:</p>
<pre class="source-code">
if (ProjectileClass)
{
 Throw_Client();
 FTimerHandle TimerHandle;
 GetWorld()-&gt;GetTimerManager().SetTimer(TimerHandle, [&amp;]()
 {
  const auto Character = Cast&lt;AUS_Character&gt;(GetOwner());
  const auto ProjectileSpawnLocation = GetComponentLocation();
  const auto ProjectileSpawnRotation = GetComponentRotation();
  auto ProjectileSpawnParams = FActorSpawnParameters();
  ProjectileSpawnParams.Owner = GetOwner();
  ProjectileSpawnParams.Instigator = Character;
  GetWorld()-&gt;SpawnActor&lt;AUS_BaseWeaponProjectile&gt;(ProjectileClass, ProjectileSpawnLocation, ProjectileSpawnRotation, ProjectileSpawnParams);
 }, .4f, false);
}</pre>
<p>Here, we have <a id="_idIndexMarker588"/>just moved the spawn logic inside a timer handle to <a id="_idIndexMarker589"/>delay the spawn process while calling the client-side throw logic, in order to start the animation immediately.</p>
<p class="callout-heading">Note</p>
<p class="callout">Unreal Engine <a id="_idIndexMarker590"/>provides more advanced methods for synchronizing animations beyond simply delaying method calls, such as <strong class="bold">Animation Notifies</strong> (<a href="https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/">https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/</a>). However, for the purpose of this book, the delay method is a quick and dirty solution that will suffice for our needs.</p>
<p>As the last step, open the <strong class="bold">BP_Character</strong> Blueprint, select the <strong class="bold">Weapon</strong> component and, in the <strong class="bold">Details</strong> panel, look for the <strong class="bold">Throw Animation</strong> property and assign the <strong class="bold">AM_Throw</strong> montage you have already created.</p>
<p>You can now test the game and the character should throw the dagger and synchronize correctly with the throw animation.</p>
<p>In this section, you have dipped your toes into the mystical realm of animation (although you’re not quite ready to battle the Lichlord just yet) and conjured up a basic animation system that networked players will appreciate. In the next section, you’re about to bring some friendly characters to life and add even more fun to your game by giving players someone to rescue.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor203"/>Adding NPC Actors</h1>
<p>While taking <a id="_idIndexMarker591"/>a leisurely stroll in the underground and dodging or stabbing zombies can be amusing, let’s not forget the big bucks the king’s shelling out for us. We’ve got a rescue mission on our hands – liberate his knights from the Lichlord’s dungeons before they’re turned into undead abominations. Time to get down to business, my fearless developer!</p>
<p>In this section, you’ll create an Actor Blueprint that will serve as a prisoner your beloved thief <a id="_idIndexMarker592"/>needs to rescue (in order to get more experience points). To implement such a system, you will make good use of the <code>Interactable</code> interface you implemented in <a href="B18203_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a><em class="italic">, Using Remote Procedure </em><em class="italic">Calls (RPCs)</em>.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor204"/>Creating the NPC character</h2>
<p>The NPC<strong class="bold"> </strong>you <a id="_idIndexMarker593"/>will be creating is a simple, replicated Actor that will cheer when the player has interacted with it and will <a id="_idIndexMarker594"/>grant some experience points. The first things we <a id="_idIndexMarker595"/>need are the Animation Montages that will play the idle and cheer animations. To do so, complete the following steps:</p>
<ol>
<li>In the <code>Animations</code> folder, add a new <code>AM_KnightIdle</code>.</li>
<li>Add the <strong class="bold">knight_Idle</strong> animation to the <strong class="bold">DefaultGroup.DefaultSlot</strong> section of the montage.</li>
<li>Add another <code>AM_KnightCheer</code>.</li>
<li>Add the <strong class="bold">knight_cheer</strong> animation to the montage.</li>
</ol>
<p>With these two animation assets ready, you can start creating the prisoner Blueprint. Open the <code>Blueprints</code> folder and complete the following steps.</p>
<ol>
<li value="5">Create a new Blueprint based on the <code>BP_KnightPrisoner</code>. Double-click it to open it.</li>
<li>In the <strong class="bold">Components</strong> panel, add a <strong class="bold">Skeletal </strong><strong class="bold">Mesh</strong> component.</li>
<li>In the <strong class="bold">Details</strong> panel, tick the <strong class="bold">Replicates</strong> property in order to replicate the Actor over the network.</li>
<li>Create an <code>EarnedXp</code>. Set its <code>20</code>. Tick the <strong class="bold">Instance Editable</strong> property to make the variable public.</li>
<li>Create an <code>MontageIdle</code>. Set its <strong class="bold">Default Value</strong> to <strong class="bold">AM_KnightIdle</strong>. Tick the <strong class="bold">Instance </strong><strong class="bold">Editable</strong> property.</li>
<li>Create another <code>MontageCheer</code>. Set its default value to <strong class="bold">AM_KnightCheer</strong>. Tick the <strong class="bold">Instance </strong><strong class="bold">Editable</strong> property.</li>
</ol>
<p>With these <a id="_idIndexMarker596"/>base settings available, you can start adding some <a id="_idIndexMarker597"/>Visual Scripting to the Event Graph in order to make the Actor fully functional. You will start from the <strong class="bold">Begin Play</strong> event to start the idle animation. To do so, complete the following steps:</p>
<ol>
<li>Add an <strong class="bold">Event BeginPlay</strong> node to the graph.</li>
<li>From the <strong class="bold">Components</strong> panel, drag into the graph a reference of the <strong class="bold">Skeletal </strong><strong class="bold">Mesh</strong> component.</li>
<li>From the <strong class="bold">Variables</strong> panel, drag a getter node for the <strong class="bold">MontageIdle</strong> variable.</li>
<li>From the <strong class="bold">Event BeginPlay</strong> execution pin, create a <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
<li>Connect the <strong class="bold">Skeletal Mesh</strong> pin to the <strong class="bold">Target</strong> pin of the <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
<li>Connect the <strong class="bold">Montage Idle</strong> pin to the <strong class="bold">New Anim to Play</strong> pin of the <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
<li>Tick the <strong class="bold">Looping</strong> property of the <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
</ol>
<p>The final result for this part of the graph is shown in <em class="italic">Figure 10</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 10.10 – Event BeginPlay graph" src="img/Figure_10_10_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Event BeginPlay graph</p>
<p>Then, create a <a id="_idIndexMarker598"/>custom event that will start the cheer animation <a id="_idIndexMarker599"/>when the prisoner is rescued by the player character. This event needs to be executed as a <strong class="bold">Multicast</strong> event in order to start the animation on all clients. To do so, complete the following steps:</p>
<ol>
<li>Right-click on the graph and create a <code>CharacterCheer</code>. With the event selected, locate the <strong class="bold">Replicates</strong> property in the <strong class="bold">Details</strong> panel and, from its drop-down menu, select <strong class="bold">Multicast</strong>, leaving the <strong class="bold">Reliable</strong> checkmark unticked, as shown in <em class="italic">Figure 10</em><em class="italic">.11</em>:</li>
</ol>
<div><div><img alt="Figure 10.11 – Custom Event replication" src="img/Figure_10_11_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Custom Event replication</p>
<ol>
<li value="2">From <a id="_idIndexMarker600"/>the <strong class="bold">Components</strong> panel, drag into the graph a <a id="_idIndexMarker601"/>reference to the <strong class="bold">Skeletal </strong><strong class="bold">Mesh</strong> component.</li>
<li>From the <strong class="bold">Variables</strong> panel, drag a getter node for the <strong class="bold">MontageCheer</strong> variable.</li>
<li>From the <strong class="bold">Event BeginPlay</strong> execution pin, create a <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
<li>Connect the <strong class="bold">Skeletal Mesh</strong> pin to the <strong class="bold">Target</strong> pin of the <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
<li>Connect the <strong class="bold">Montage Idle</strong> pin to the <strong class="bold">New Anim to Play</strong> pin of the <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
<li>Tick the <strong class="bold">Looping</strong> property of the <strong class="bold">Play </strong><strong class="bold">Animation</strong> node.</li>
</ol>
<p>The final result for this part of the graph is shown in <em class="italic">Figure 10</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 10.12 – CharacterCheer Custom Event" src="img/Figure_10_12_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – CharacterCheer Custom Event</p>
<p>The last step <a id="_idIndexMarker602"/>needed to make the Actor work properly is to make <a id="_idIndexMarker603"/>it interactable with the player character by implementing the <code>US_Interactable</code> interface. To do so, complete the following steps:</p>
<ol>
<li>Open the <strong class="bold">Class Settings</strong> panel and locate the <strong class="bold">Interfaces</strong> category.</li>
<li>In <strong class="bold">Implemented Interfaces</strong>, add the <strong class="bold">US_Interactable</strong> interface.</li>
<li>In the <strong class="bold">My Blueprint</strong> panel, locate the <strong class="bold">Interfaces</strong> category and right-click the <strong class="bold">Interact</strong> method, selecting <strong class="bold">Implement event</strong>. An <strong class="bold">Event Interact</strong> node will be added to the Event Graph.</li>
<li>Click and drag from the event <strong class="bold">Character Instigator</strong> pin to add a <strong class="bold">PlayerState</strong> node and connect its <strong class="bold">Target</strong> pin to the <strong class="bold">Character Instigator</strong> pin of the <strong class="bold">Event </strong><strong class="bold">Interact</strong> node.</li>
<li>Click and drag from the outgoing pin of the <strong class="bold">PlayerState</strong> node and create a <strong class="bold">Cast To US_PlayerState</strong> node. Connect its incoming execution pin to the outgoing execution pin of the <strong class="bold">Event </strong><strong class="bold">Interact</strong> node.</li>
<li>Click and <a id="_idIndexMarker604"/>drag from the <strong class="bold">As US PlayerState</strong> of the cast <a id="_idIndexMarker605"/>node and create an <strong class="bold">Add Xp</strong> node. Connect its incoming execution pin to the <strong class="bold">Success</strong> execution pin of the cast node.</li>
<li>From the <strong class="bold">Variables</strong> panel, drag a getter node for the <strong class="bold">EarnedXp</strong> variable. Connect its outgoing pin to the <strong class="bold">Value</strong> pin of the <strong class="bold">Add </strong><strong class="bold">Xp</strong> node.</li>
<li>Click and drag from the outgoing pin of the <strong class="bold">Add Xp</strong> node and create a <strong class="bold">Character Cheer</strong> node to complete the graph, as shown in <em class="italic">Figure 10</em><em class="italic">.13</em>:</li>
</ol>
<div><div><img alt="Figure 10.13 – Interaction graph" src="img/Figure_10_13_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Interaction graph</p>
<p>You may have noticed that we didn’t use any authority checks in the previous graph; this is because we know that this event will only be called on the server.</p>
<p>The Blueprint is now complete, so it’s time to do some testing.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor205"/>Testing the NPC Actor</h2>
<p>To test the <a id="_idIndexMarker606"/>Blueprint, you can drag an instance of it into the level and start a gameplay session. The thief character should be able to reach the NPC and, if we use the interaction button, the animation should show them cheering. The hero who liberates the NPC characters will receive a well-deserved pool of experience points as a reward. Time to level up and become an even greater hero!</p>
<p><em class="italic">Figure 10</em><em class="italic">.14</em> shows the final result of the NPC Actor, once it has been liberated by the thief hero:</p>
<div><div><img alt="Figure 10.14 – A ﻿liberated Actor during gameplay" src="img/Figure_10_14_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – A liberated Actor during gameplay</p>
<p>Well, it seems we <a id="_idIndexMarker607"/>now have a new prisoner to play with! But why settle for one when we can have variations? Feel free to get creative and give our captive some fresh looks to keep things interesting. By creating child Blueprints and changing the Actor’s Skeletal Mesh component and Animation Montages, you will be able to make good use of the barbarian and mage models available in the project. You may even create a rogue prisoner variation – who says we can’t go off-script a little? The king may have paid us to rescue his knights and warriors, but hey, a skilled hero or two in the Thief Guild never hurt anyone!</p>
<p>Congratulations – you’ve completed this part of the adventure. Now it’s time to let your imagination run wild and add your own game logic! In the next section, I won’t be teaching you any new techniques, but I’ll provide you with some fresh ideas to enhance the gameplay and make it more exciting.</p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor206"/>Making further improvements to the game</h1>
<p>Now that you have solid knowledge of how the Unreal multiplayer system works, it’s time to unleash <a id="_idIndexMarker608"/>your creativity and bring your own ideas to life, making your game truly unique and personalized. In this section, I will give you some hints on how to spice up your project, but don’t hesitate to add your own twist to make it uniquely yours.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor207"/>Let’s make some noise!</h2>
<p>Currently, the minions’ hearing senses are only utilized to detect when a character is running. Why not tweak the system and let other elements in the game alert the Lichlord’s minions?</p>
<p>Unfortunately, <code>PawnNoiseEmitterComponent</code> can only be used on, well... pawns, so you cannot attach it to other Actors (it simply won’t work); however, in <a href="B18203_09.xhtml#_idTextAnchor174"><em class="italic">Chapter 9</em></a><em class="italic">, Extending AI Behaviors</em>, you built a strong system to alert enemy minions that makes use of the Game Mode. As the Game Mode can be reached by any Actor in the level, you can exploit the <code>AlertMinions()</code> function and send messages that will call for help when activated.</p>
<p>One of the best ways to use this method is through traps – whenever the player character steps into one such device, all the minions around will be alerted. Some examples of this kind of game feature include the following:</p>
<ul>
<li><em class="italic">Creaking doors</em>: Whenever the character opens a door, it will make a creaking or squeaking sound that will alert the Lichlord’s servants to the intruders.</li>
<li><em class="italic">Traps</em>: Some dungeon areas will be more protected than others – set some mechanical devices that will rally all nearby enemies. After all, this is just a matter of creating a collision area and calling a method in the Game Mode!</li>
<li><em class="italic">Magical items</em>: Create some magical artifact that can be interacted with by the player. The Lichlord is a sneaky one: he cast an alert spell, which condemned the hapless thief hero to their inevitable fate. Whenever the character tries to use that juicy item, an alarm will be sent to nearby minions, alerting them. Think of the possibilities! You can even use the floating book we created at the beginning of the project.</li>
</ul>
<h2 id="_idParaDest-207"><a id="_idTextAnchor208"/>I need a key!</h2>
<p>Opening doors in a dungeon can be a fun game, but things can get even more interesting when you come across a locked door. Why not give it a try and see what other surprises lie in wait?</p>
<p>In <a href="B18203_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a><em class="italic">, Using Remote Procedure Calls (RPCs)</em>, you created the <code>US_Interactable</code> interface and made use of the <code>Interact()</code> method. However, the interface also exposes the <code>CanInteract()</code> method, which can be used to check whether the Actor can be interacted with.</p>
<p>A door may <a id="_idIndexMarker609"/>implement a system that will only return <code>true</code> to the <code>CanInteract()</code> method if the player character has a key – this means creating a key pickup item and adding the <code>US_Character</code> system to track whether they have one or more keys to use. These locked doors can be used to keep the NPCs locked in some cellars and only able to be freed if the corresponding key is found somewhere in the level.</p>
<p>Watch out for the Lichlord! His prisoners are double-locked up tighter than a merchant’s coin purse in the deepest and most heavily guarded cells of his dungeon!</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor209"/>Improve your arsenal, my hero!</h2>
<p>While it’s nice to have a pointy dagger to throw at your hated opponents, it’s even nicer to have a magical one that will inflict more damage, or even defeat enemies with a single hit. You can implement a pickup Blueprint that will make good use of the <code>SetProjectileClass()</code> function you implemented in the <code>US_WeaponProjectileComponent</code> class.</p>
<p>Upon picking up the item, the character will be granted a variant of the <code>US_BaseWeaponProjectile</code> class with augmented damage. You can even think about letting defeated enemies drop weapon pickups instead of coins!</p>
<p>As an additional feature, you may even think to create throwing rocks that will send alert messages upon hitting the ground – just remember to enable gravity for the projectile. Having items that can be thrown and that will make noise to alert minions and direct them far away from the player characters will add some fresh gameplay logic that will improve the overall game experience.</p>
<p>Get ready for a wickedly clever twist, and use your quick wit to dazzle the Lichlord’s mindless servants! With brains like yours, who needs brawn?</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor210"/>You are not a machine gun</h2>
<p>Currently, players have the ability to throw an unlimited number of daggers during gameplay. While this may be enjoyable initially, it will ultimately disrupt the balance of the game and result in a monotonous experience over time.</p>
<p>To make things more interesting (and in favor of the Lichlord’s shadowy plans), limit the players to just one <a id="_idIndexMarker610"/>throwing dagger projectile at a time. Once the character has thrown the weapon, it won’t be able to throw it again until the dagger has been recovered.</p>
<p>Implementing this feature is quite straightforward – once the character throws the projectile, set the <code>ProjectileClass</code> weapon component to a <code>null</code> value so that the character won’t be able to spawn any more objects. Upon hitting something, the thrown weapon will spawn a dagger pickup (see the previous subsection) before destroying itself. This will force the character to get to the dropped weapon and pick it up in order to attack again.</p>
<p>As an alternative feature, you may give your character a limited number of knives and use a count variable to check whether the character has any knives available every time the player tries to throw one.</p>
<p>Whoever said life in the dungeon would be a walk in the park obviously never encountered a horde of undead monsters while armed with a simple (and single!) weapon.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor211"/>No time to waste</h2>
<p>At the moment, your characters can walk around calmly and take their time in rescuing the prisoners. Why not spice things up by adding a time counter? The Lichlord is hosting a grand celebration with the intention of transforming the king’s knight into a loyal member of his undead army! Your hero must hurry up before it is too late!</p>
<p>You can make good use of the <code>US_GameMode</code> class and create a time manager that will start as soon as the first player enters the dungeon – if the players can’t free every captive from the dungeon, they’ll be royally out of luck and the game will be a total flop. It looks like it’s all or nothing for this quest!</p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>Tables, tables everywhere!</h2>
<p>As your project progresses, it will become increasingly difficult to keep track of all the variations in enemies and weapons. To ease the pain, you can use the struct and data table system introduced in <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a><em class="italic">, Replicating Properties </em><em class="italic">Over</em><em class="italic"> the Network,</em> to create dedicated structures for the throwing weapons and AI opponents.</p>
<p>Let your creative <a id="_idIndexMarker611"/>side run wild and come up with a ton of amazing Blueprint options based on the stats you like best – get ready for your hero adventurers to embark on thrilling journeys full of surprises in your game!</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/>Need some help?</h2>
<p>As you may have noticed from the previous subsections, once you become familiar with your game, the potential outcomes become limitless. You can add any new gameplay logic and test it until you are happy.</p>
<p>On my end, I’ll be working on creating exciting new features for the game and storing them in my own GitHub repository. Feel free to check in from time to time to see what wild and crazy ideas I’ve come up with! The link to the repository is <a href="https://github.com/marcosecchi/unrealshadows-ltol">https://github.com/marcosecchi/unrealshadows-ltol</a>.</p>
<p>And if you come up with a clever idea, feel free to contact me and tell me about it – if time permits, I will try to implement it and upload it to the repository in order to make this project grow!</p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor214"/>Summary</h1>
<p>Throughout this chapter, you fine-tuned the gameplay logic and added the finishing touches. You began by incorporating some nice animations for character movements and attacks, elevating the game’s overall appeal.</p>
<p>Additionally, you created someone for the players to rescue: a prisoner Actor that can be interacted with and that will grant the thief hero some well-deserved experience points.</p>
<p>Last but not least, I shared a few fresh ideas to take your gameplay to the next level. By incorporating these ideas, you can make the game truly your own and one of a kind. So, get creative and have fun!</p>
<p>Get ready for the next chapter, where you’ll dive into debugging and testing a networked game. This will take your development skills to the next level, something that’s necessary if you want to become a top-notch multiplayer programmer!</p>
</div>
</body></html>