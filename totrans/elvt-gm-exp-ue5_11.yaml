- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Working with Blend Space 1D, Key Bindings, and State Machines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与1D混合空间、按键绑定和状态机一起工作
- en: In the previous chapter, we had a high-level look at animation and developing
    the game design for our `SuperSideScroller` project. You were provided with just
    the beginning steps in terms of developing the project itself. Then, you prepared
    the player character’s Animation Blueprint and character Blueprint, and also imported
    all of the required skeletal and animation assets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们高屋建瓴地探讨了动画和为我们的`SuperSideScroller`项目开发游戏设计。您只得到了项目开发方面的初步步骤。然后，您准备了玩家角色的动画蓝图和角色蓝图，并导入了所有必需的骨骼和动画资产。
- en: In this chapter, we will set up the walking and jumping animations of our player
    character so that the movement has a sense of locomotion. To accomplish this,
    you will be introduced to **Blend Spaces**, **Animation Blueprints**, and **Animation
    State Machines**, the three pillars behind how character animations are controlled.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置玩家角色的行走和跳跃动画，使移动具有运动感。为了实现这一点，您将介绍**混合空间**、**动画蓝图**和**动画状态机**，这是控制角色动画背后的三个支柱。
- en: At this point, the character can move around the level, but is stuck in the
    T-Pose and does not animate at all. This can be fixed by creating a new Blend
    Space for the player character, which will be done in the very first exercise
    of this chapter. Once the Blend Space is complete, you will use it to implement
    the character Animation Blueprint for the character to animate while moving.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，角色可以在关卡中移动，但被固定在T-Pose，并且根本不会进行动画。这可以通过为玩家角色创建一个新的混合空间来修复，这将在本章的第一个练习中完成。一旦混合空间完成，您将使用它来实现角色在移动时的动画蓝图。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Creating Blend Spaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建混合空间
- en: Main character Animation Blueprint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要角色动画蓝图
- en: What are velocity vectors?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度向量是什么？
- en: Enhanced input system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强输入系统
- en: Using Animation State Machines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画状态机
- en: By the end of the chapter, the player character will be able to walk, sprint,
    and jump, thus providing a better game feel to how the character will move in
    our game. By creating and learning about Blend Space 1D and Animation Blueprint
    assets, you will add a layer of sophistication to how the player movement is handled,
    while also establishing the groundwork for further animations, such as the projectile
    throw.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，玩家角色将能够行走、冲刺和跳跃，从而为游戏中的角色移动提供更好的游戏体验。通过创建和学习1D混合空间和动画蓝图资产，您将为玩家移动的处理方式增加一层复杂性，同时也为后续动画，如投掷物动画，打下基础。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要以下内容：
- en: Unreal Engine 5 installed
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Unreal Engine 5
- en: Visual Studio 2019 installed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Visual Studio 2019
- en: 'The project for this chapter can be found in the `Chapter11` folder of the
    code bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的`Chapter11`文件夹中找到，该代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: We’ll start this chapter by learning about Blend Spaces before creating the
    Blend Space asset that you will need to animate the player character.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，先学习混合空间，然后再创建您需要为玩家角色动画的混合空间资产。
- en: Creating Blend Spaces
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建混合空间
- en: 'Blend Spaces allow you to blend between multiple animations based on one or
    more conditions. Blend Spaces are used in different types of video games, but,
    more often than not, in games where the player can view the entire character.
    Blend Spaces are not usually used when the player can only see the character’s
    arms, such as in the **First-Person** project template provided in UE5, as shown
    here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 混合空间允许您根据一个或多个条件在多个动画之间进行混合。混合空间用于不同类型的视频游戏，但更常见的是在玩家可以查看整个角色的游戏中使用。当玩家只能看到角色的手臂时，通常不会使用混合空间，例如在UE5提供的**第一人称**项目模板中，如下所示：
- en: '![Figure 11.1 – The first-person perspective of the default character in the
    First-Person project template in UE5 ](img/Figure_11.01_B18531.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – UE5中第一人称项目模板中默认角色的第一人称视角](img/Figure_11.01_B18531.jpg)'
- en: Figure 11.1 – The first-person perspective of the default character in the First-Person
    project template in UE5
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – UE5 中 First-Person 项目模板中默认角色的第一人称视角
- en: 'It is more common in third-person games where there is a need to use Blend
    Spaces to smoothly blend movement-based animations of the character. A good example
    is the **Third-Person** template project provided in UE5, as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要使用 Blend Spaces 来平滑过渡基于移动的动画的第三人称游戏中更为常见。一个很好的例子是 UE5 中提供的 **Third-Person**
    模板项目，如此处所示：
- en: '![Figure 11.2 – The third-person perspective of the default character in the
    First-Person project template in UE5 ](img/Figure_11.02_B18531.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – UE5 中 First-Person 项目模板中默认角色的第三人称视角](img/Figure_11.02_B18531.jpg)'
- en: Figure 11.2 – The third-person perspective of the default character in the First-Person
    project template in UE5
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – UE5 中 First-Person 项目模板中默认角色的第三人称视角
- en: Let’s look at the Blend Space asset provided by Unreal Engine when creating
    the `Third Person template` project template by opening `/Characters/Mannequins/Animations/Quinn/BS_MF_Unarmed_WalkRun`.
    This is a Blend Space 1D asset created for the `Side Scroller` mannequin skeletal
    mesh so that the player character can smoothly blend between `Idle`, `Walking`,
    and `Running` animations based on the speed of the character.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Unreal Engine 提供的 Blend Space 资产，当通过打开 `/Characters/Mannequins/Animations/Quinn/BS_MF_Unarmed_WalkRun`
    创建 `Third Person` 模板项目模板时。这是一个为 `Side Scroller` 人偶骨骼网格创建的 Blend Space 1D 资产，以便玩家角色可以根据角色的速度在
    `Idle`、`Walking` 和 `Running` 动画之间平滑过渡。
- en: 'If you check `Horizontal Axis` parameter, where we have settings for this axis,
    which essentially acts as a variable that we can reference in our Animation Blueprint.
    Please refer to the following screenshot to see the **AXIS SETTINGS** category
    within **Persona**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查 `水平轴` 参数，其中我们为此轴设置了设置，它本质上是一个变量，我们可以在我们的动画蓝图中进行引用。请参考以下截图以查看 **Persona**
    中的 **AXIS SETTINGS** 类别：
- en: '![Figure 11.3 – The axis settings for the Blend Space 1D ](img/Figure_11.03_B18531.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Blend Space 1D 的轴设置](img/Figure_11.03_B18531.jpg)'
- en: Figure 11.3 – The axis settings for the Blend Space 1D
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Blend Space 1D 的轴设置
- en: 'Below the preview window, we will also see a small graph with points along
    the line from left to right; one of these points will be highlighted `green`,
    while the others will be `white`. We can hold *Shift* and drag this `green` point
    along the horizontal axis to preview the blended animation based on its value.
    At speed `0`, our character is in an `Idle` state. As we move our preview along
    the axis, the animation will begin to blend into `Walking`, followed by `Running`.
    The following screenshot shows the single-axis graph:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览窗口下方，我们还将看到一个从左到右沿线的点的小图；其中一点将被突出显示为 `绿色`，而其他点将是 `白色`。我们可以按住 *Shift* 并将这个
    `绿色` 点沿水平轴拖动以预览基于其值的混合动画。在速度 `0` 时，我们的角色处于 `Idle` 状态。当我们沿着轴移动预览时，动画将开始混合到 `Walking`，然后是
    `Running`。以下截图显示了单轴图：
- en: '![Figure 11.4 – The key frame timeline of the 1D Blend Space 1D ](img/Figure_11.04_B18531.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 1D Blend Space 的关键帧时间线](img/Figure_11.04_B18531.jpg)'
- en: Figure 11.4 – The key frame timeline of the 1D Blend Space 1D
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 1D Blend Space 的关键帧时间线
- en: In the next section, we will look at Blend Space 1Ds versus a normal Blend Space,
    and when to use them based on your animation needs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 Blend Space 1D 与普通 Blend Space 的比较，以及根据您的动画需求何时使用它们。
- en: Blend Space 1D versus normal Blend Space
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blend Space 1D 与普通 Blend Space 的比较
- en: 'Before moving forward with the Blend Space 1D, let’s take a moment to look
    at the main differences between a Blend Space 1D and a normal Blend Space in UE5:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用 Blend Space 1D 之前，让我们花一点时间来查看 UE5 中 Blend Space 1D 与普通 Blend Space 之间的主要区别：
- en: The Blend Space in Unreal Engine is controlled by two variables, represented
    by the X and *Y* axes of the Blend Space graph.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 中，Blend Space 由两个变量控制，这些变量由 Blend Space 图的 X 和 *Y* 轴表示。
- en: On the other hand, the Blend Space 1D only supports one axis.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，Blend Space 1D 只支持一个轴。
- en: Try to imagine this as a 2D graph. Since you know that each axis has a direction,
    you can visualize why and when you would need to use this Blend Space rather than
    a Blend Space 1D, which only supports a single axis.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试想象这是一个 2D 图。由于你知道每个轴都有一个方向，你可以可视化为什么以及何时需要使用这个 Blend Space 而不是只支持单个轴的 Blend
    Space 1D。
- en: 'Say, for example, you wanted to make the player character strafe left and right
    while also supporting forward and backward movement. If you were to map this movement
    out on a graph, it would look as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想使玩家角色在左右横移的同时支持前后移动。如果将这种移动映射到图上，它将看起来如下：
- en: '![Figure 11.5 – What a Blend Space movement would look like on a simple graph
    ](img/Figure_11.05_B18531.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 混合空间移动在简单图上的样子](img/Figure_11.05_B18531.jpg)'
- en: Figure 11.5 – What a Blend Space movement would look like on a simple graph
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 混合空间移动在简单图上的样子
- en: Now, visualize the movement of the player character, keeping in mind the fact
    that the game is a `Side Scroller`. The character won’t be supporting left or
    right strafing or forward and backward movement. The player character will only
    need to animate in one direction because the `Side Scroller` character rotates
    toward the direction of movement by default. Having to only support one direction
    is why you are using a Blend Space 1D instead of a normal Blend Space.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象玩家角色的移动，考虑到游戏是 `侧滚动`。角色将不支持左右横移或前后移动。玩家角色只需要在一个方向上动画化，因为 `侧滚动` 角色默认会旋转到移动的方向。只需要支持一个方向，这就是为什么您使用的是
    Blend Space 1D 而不是普通混合空间的原因。
- en: We will need to set up this type of Blend Space asset for our main character
    and use the Blend Space for the same purpose, for movement-based animation blending.
    In the next exercise, we’ll create the Blend Space asset using our custom animation
    assets.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为主角设置这种类型的混合空间资产，并使用混合空间进行基于移动的动画混合。在下一个练习中，我们将使用我们的自定义动画资产创建混合空间资产。
- en: Exercise 11.01 – creating the CharacterMovement Blend Space 1D
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.01 – 创建 CharacterMovement 混合空间 1D
- en: To get the player character to animate while they move, you need to create a
    Blend Space.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使玩家角色在移动时进行动画，您需要创建一个混合空间。
- en: In this exercise, you will create the `CharacterMovement` component so that
    you assign an appropriate walking speed value that corresponds with the Blend
    Space.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建 `CharacterMovement` 组件，以便分配与混合空间相对应的适当行走速度值。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Navigate to the `/MainCharacter/Animation` folder in the **Content Drawer**
    window, where all the new animations you imported in the previous chapter are
    located.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容抽屉** 窗口中导航到 `/MainCharacter/Animation` 文件夹，其中包含您在上一章中导入的所有新动画。
- en: Now, *right-click* in the main area of the **Content Drawer** window and, from
    the drop-down menu, hover over the **Animation** option. From its additional drop-down
    menu, select **Blend Space 1D**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **内容抽屉** 窗口的主区域中 *右键单击*，然后从下拉菜单中悬停在 **动画** 选项上。从其附加下拉菜单中选择 **混合空间 1D**。
- en: Make sure to select `MainCharacter_Skeleton`, not `UE4_Mannequin_Skeleton`,
    as the skeleton for the Blend Space.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择 `MainCharacter_Skeleton` 而不是 `UE4_Mannequin_Skeleton` 作为混合空间的骨骼。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you apply the incorrect skeleton, the Blend Space will not be functional
    for the player character, nor will the custom skeletal mesh when you select the
    skeleton assets, such as Blend Spaces or Animation Blueprints, that are required.
    Here, you are telling this asset which skeleton it is compatible with. By doing
    so, in the case of a Blend Space, you can use animations that have been made for
    this skeleton, thereby ensuring that everything is compatible with everything
    else.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您应用了错误的骨骼，混合空间将无法为玩家角色工作，当您选择所需的骨骼资产，如混合空间或动画蓝图时，自定义骨骼网格也将无法工作。在这里，您正在告诉这个资产它兼容哪种骨骼。通过这样做，在混合空间的情况下，您可以使用为该骨骼制作的动画，从而确保一切与一切兼容。
- en: Name this Blend Space asset `SideScroller_IdleRun_1D`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个混合空间资产命名为 `SideScroller_IdleRun_1D`。
- en: 'Next, open the `SideScroller_IdleRun_`Blend Space 1D asset. You can see the
    single-axis graph below the preview window:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `SideScroller_IdleRun_` 混合空间 1D 资产。您可以在预览窗口下方看到单轴图：
- en: '![Figure 11.6 – The editing tool used to create Blend Spaces in UE5 ](img/Figure_11.06_B18531.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 用于在 UE5 中创建混合空间的编辑工具](img/Figure_11.06_B18531.jpg)'
- en: Figure 11.6 – The editing tool used to create Blend Spaces in UE5
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 用于在 UE5 中创建混合空间的编辑工具
- en: 'On the left-hand side of the editor, you have the `Animation Blueprint` property
    for the player character. The following screenshot shows the default values that
    have been set for `Horizontal Axis`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器的左侧，您有玩家角色的 `Animation Blueprint` 属性。以下截图显示了为 `水平轴` 设置的默认值：
- en: '![Figure 11.7 – The axis settings that affect the axis of the Blend Space ](img/Figure_11.07_B18531.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 影响混合空间轴的轴设置](img/Figure_11.07_B18531.jpg)'
- en: Figure 11.7 – The axis settings that affect the axis of the Blend Space
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 影响混合空间轴的轴设置
- en: 'Now, change the name of `Speed`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更改 `Speed` 的名称：
- en: '![Figure 11.8 – The horizontal axis is now named Speed ](img/Figure_11.08_B18531.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 现在水平轴被命名为速度](img/Figure_11.08_B18531.jpg)'
- en: Figure 11.8 – The horizontal axis is now named Speed
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 现在水平轴被命名为速度
- en: The next step is to establish `0.0f`, which is set by default, because the player
    character will be in an `Idle` state when they are not moving at all.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置默认的 `0.0f`，因为当玩家角色完全不动时，它们将处于 `空闲` 状态。
- en: 'But what about **Maximum Axis Value**? This one is a little trickier because
    you need to bear the following points in mind:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于 **最大轴值** 呢？这一点稍微有点复杂，因为您需要记住以下几点：
- en: You will be supporting a sprinting behavior for the character that allows the
    player to move faster when holding down the *Left Shift* keyboard button. When
    released, the player will return to the default walking speed.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将支持一个允许玩家在按下 *左 Shift* 键盘按钮时移动更快的冲刺行为。当释放时，玩家将返回到默认的行走速度。
- en: The walking speed must match the characters’ `Max Walk Speed` parameter of `CharacterMovementComponent`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行走速度必须与角色的 `CharacterMovementComponent` 的 `Max Walk Speed` 参数相匹配。
- en: Before you set `SuperSideScroller` game.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置 `SuperSideScroller` 游戏之前。
- en: For this, navigate to `/Game/MainCharacter/Blueprints/` and open the `BP_SuperSideScroller_MainCharacter`
    Blueprint.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，导航到 `/Game/MainCharacter/Blueprints/` 并打开 `BP_SuperSideScroller_MainCharacter`
    蓝图。
- en: Select the `Character Movement` component and, in the `Max Walk Speed` parameter
    and set its value to `300.0f`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Character Movement` 组件，并在 `Max Walk Speed` 参数中设置其值为 `300.0f`。
- en: With the `Max Walk Speed` parameter set, return to the `SideScroller_IdleRun_`Blend
    Space 1D and set the `Maximum Axis Value` parameter. If the walking speed was
    `300.0f`, what should the maximum value be? Keeping in mind that you will support
    sprinting for the player character, this maximum value needs to be more than the
    walking speed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `Max Walk Speed` 参数后，返回到 `SideScroller_IdleRun_` 1D 混合空间并设置 `Maximum Axis
    Value` 参数。如果行走速度是 `300.0f`，最大值应该是多少？考虑到您将支持玩家的冲刺，这个最大值需要超过行走速度。
- en: Update the `Maximum Axis Value` parameter so that its value is `500.0f`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Maximum Axis Value` 参数，使其值为 `500.0f`。
- en: Lastly, set the `Number of Grid Divisions` parameter to a value of `5`. The
    reason for this is that when working with divisions, a `100` unit spacing between
    each grid point makes it easier to work with since `Maximum Axis Value` is `500.0f`.
    This is useful in the case of grid point snapping when you apply the movement
    animations along the grid.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `Number of Grid Divisions` 参数设置为 `5`。这样做的原因是，当使用部分时，每个网格点之间 `100` 单位的间距使得工作更加容易，因为
    `Maximum Axis Value` 是 `500.0f`。这在应用沿网格的移动动画时进行网格点吸附时很有用。
- en: 'Leave the remaining properties set as their defaults:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的属性设置为默认值：
- en: '![Figure 11.9 – The final axis settings for the Blend Space ](img/Figure_11.09_B18531.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 混合空间的最终轴设置](img/Figure_11.09_B18531.jpg)'
- en: Figure 11.9 – The final axis settings for the Blend Space
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 混合空间的最终轴设置
- en: With these settings, you are telling the Blend Space to use an incoming float
    value between `0.0f` and `500.0f` to blend between the animations that you will
    place in the next step and the activity. By dividing the grid into `5` divisions,
    you can easily add the animations needed at the correct float value along the
    axis graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，您正在告诉混合空间使用介于 `0.0f` 和 `500.0f` 之间的传入浮点值，在您将在下一步放置的动画和活动之间进行混合。通过将网格分为
    `5` 个部分，您可以轻松地在轴图上添加所需的动画，并确保它们在正确的浮点值处。
- en: 'Let’s continue creating the Blend Space by adding our first animation to the
    axis graph: the `Idle` animation.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建混合空间，通过将我们的第一个动画添加到轴图：`空闲` 动画。
- en: To the right of the grid, there is the `MainCharacter_Skeleton` asset when creating
    the Blend Space.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建混合空间时，网格右侧是 `MainCharacter_Skeleton` 资产。
- en: 'Next, left-click and drag the `Idle` animation to our grid at position `0.0`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，左键单击并拖动 `空闲` 动画到我们的网格位置 `0.0`：
- en: '![Figure 11.10 – Dragging the Idle animation to our grid at position 0.0 ](img/Figure_11.10_B18531.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 将空闲动画拖动到我们的网格位置 0.0](img/Figure_11.10_B18531.jpg)'
- en: Figure 11.10 – Dragging the Idle animation to our grid at position 0.0
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 将空闲动画拖动到我们的网格位置 0.0
- en: 'Notice that when dragging this animation to the grid, it will snap to the grid
    point. Once the animation has been added to the Blend Space, the player character
    will change from its default T-Pose and start to play the `Idle` animation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当你将这个动画拖动到网格上时，它会自动对齐到网格点。一旦动画被添加到 Blend Space 中，玩家角色将从默认的 T-Pose 变换，并开始播放“空闲”动画：
- en: '![Figure 11.11 – With the Idle animation added to the Blend Space 1D, the player
    character begins to animate ](img/Figure_11.11_B18531.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – 将空闲动画添加到 1D Blend Space 后，玩家角色开始动画](img/Figure_11.11_B18531.jpg)'
- en: Figure 11.11 – With the Idle animation added to the Blend Space 1D, the player
    character begins to animate
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – 将空闲动画添加到 1D Blend Space 后，玩家角色开始动画
- en: With this exercise complete, you now have an understanding of how to create
    a Blend Space 1D and, more importantly, you know the differences between a Blend
    Space 1D and a normal Blend Space. Additionally, you know the importance of aligning
    the values between the player character movement component and the Blend Space
    and why you need to ensure that the walking speed correlates appropriately with
    the values in the Blend Space.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在已经了解了如何创建一维 Blend Space，更重要的是，你知道一维 Blend Space 和普通 Blend Space
    之间的区别。此外，你还知道在玩家角色运动组件和 Blend Space 之间对齐值的重要性，以及为什么你需要确保行走速度与 Blend Space 中的值相关联。
- en: Now, let’s move on to the first activity of this chapter, where you will be
    applying the remaining `Walking` and `Running` animations to the Blend Space,
    just as you added the `Idle` animation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续本章的第一个活动，在这个活动中，你将应用剩余的“行走”和“跑步”动画到 Blend Space 中，就像你添加“空闲”动画一样。
- en: Activity 11.01 – adding the Walking and Running animations to the Blend Space
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01 – 将行走和跑步动画添加到 Blend Space
- en: The 1D movement Blend Space is coming together nicely so far, but you are missing
    the `Walking` and `Running` animations. In this activity, you will finish the
    Blend Space by adding these animations to the Blend Space at the appropriate horizontal
    axis values that make sense for the main character.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，一维运动 Blend Space 的组合进行得相当顺利，但你缺少了“行走”和“跑步”动画。在这个活动中，你将通过将这些动画添加到 Blend
    Space 中合适的水平轴值（对主要角色来说是有意义的）来完成 Blend Space。
- en: 'Using the knowledge you acquired from *Exercise 11.01 – creating the CharacterMovement
    Blend Space 1D*, follow these steps to finish up the character movement Blend
    Space:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在 *练习 11.01 – 创建 CharacterMovement Blend Space 1D* 中获得的知识，按照以下步骤完成角色运动 Blend
    Space：
- en: Continuing from *Exercise 11.01 – creating the CharacterMovement Blend Space
    1D*, head back to the **Asset Browser** window.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *练习 11.01 – 创建 CharacterMovement Blend Space 1D* 继续进行，返回到 **资产浏览器** 窗口。
- en: Now, add the `Walking` animation to the horizontal grid position `300.0f`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将“行走”动画添加到水平网格位置 `300.0f`。
- en: Finally, add the `Running` animation to the horizontal grid position `500.0f`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“跑步”动画添加到水平网格位置 `500.0f`。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you can hold *shift* and drag the green preview grid point along
    the grid axis to see how the animation blends together based on the axis value,
    so pay attention to the character animation preview window to make sure that it
    looks correct.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以按住 *shift* 并沿着网格轴拖动绿色的预览网格点，以查看动画如何根据轴值混合，因此请注意角色动画预览窗口，以确保它看起来正确。
- en: 'The expected output is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 11.12 – The Running animation in the Blend Space ](img/Figure_11.12_B18531.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – Blend Space 中的跑步动画](img/Figure_11.12_B18531.jpg)'
- en: Figure 11.12 – The Running animation in the Blend Space
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – Blend Space 中的跑步动画
- en: At this point, you should have a functional Blend Space that blends the character
    movement animations from `Idle` to `Walking` to `Running` based on the value of
    the horizontal axis that represents the player character’s speed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经拥有了一个功能性的 Blend Space，它可以根据代表玩家角色速度的水平轴值，将角色从“空闲”状态切换到“行走”状态再到“跑步”状态。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: The Main Character Animation Blueprint
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要角色动画蓝图
- en: With the animations added to the Blend Space, you should be able to walk around
    and see those animations at work, right? Well, no. If you select **Play-In-Editor**,
    you will notice that the main character is still moving in the T-Pose. The reason
    is that you aren’t telling the Animation Blueprint to use our Blend Space asset
    yet, which you will do later in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在将动画添加到混合空间后，你应该能够四处走动并看到这些动画在工作，对吧？嗯，不对。如果你选择**在编辑器中播放**，你会注意到主要角色仍然在T姿势中移动。原因是你没有告诉动画蓝图使用我们的混合空间资产，你将在本章的后面做到这一点。
- en: Animation Blueprints
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画蓝图
- en: Before jumping into using the Animation Blueprint you created in the previous
    chapter, let’s briefly discuss what this type of Blueprint is, and what its main
    function is. An Animation Blueprint is a type of Blueprint that allows you to
    control the animation of a skeleton and skeletal mesh – in this instance, the
    player character skeleton and mesh you imported in the previous chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳入使用上一章创建的动画蓝图之前，让我们简要讨论一下这种蓝图是什么类型，以及它的主要功能是什么。动画蓝图是一种蓝图，允许你控制骨骼和骨骼网格的动画 –
    在这种情况下，是你在上一章中导入的玩家角色骨骼和网格。
- en: 'An Animation Blueprint is broken into two main graphs:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动画蓝图被分为两个主要图：
- en: Event Graph
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件图
- en: Anim Graph
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画图
- en: The Event Graph works as in a normal Blueprint where you can use events, functions,
    and variables to script gameplay logic. The Anim Graph, on the other hand, is
    unique to an Animation Blueprint, and this is where you use logic to determine
    the final pose of the skeleton and skeletal mesh at any given frame. It is here
    where you can use elements such as State Machines, anim slots, Blend Spaces, and
    other animation-related nodes to then output the final animation for the character.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 事件图的工作方式与正常蓝图一样，你可以在其中使用事件、函数和变量来编写游戏逻辑。另一方面，动画图是动画蓝图特有的，这是你使用逻辑来确定在任意给定帧中骨骼和骨骼网格的最终姿势的地方。正是在这里，你可以使用诸如状态机、动画槽、混合空间和其他与动画相关的节点，然后输出最终的角色动画。
- en: Let’s look at an example.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。
- en: Open the `AnimBP_SuperSideScroller_MainCharacter` Animation Blueprint in the
    `MainCharacter/Blueprints` directory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainCharacter/Blueprints`目录中打开`AnimBP_SuperSideScroller_MainCharacter`动画蓝图。
- en: By default, **AnimGraph** should open, where you will see the character preview,
    the **Asset Browser** window, and the main graph. It is inside this **AnimGraph**
    that you will implement the Blend Space you just created to have the player character
    animate correctly when moving around the level.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**AnimGraph**应该打开，在那里你会看到角色预览、**资产浏览器**窗口和主要图。正是在这个**AnimGraph**中，你将实现你刚刚创建的混合空间，以便在玩家角色在关卡中移动时正确地动画化。
- en: Let’s get started with the next exercise, where we will do this and learn more
    about Animation Blueprints.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始下一个练习，我们将做这个练习并了解更多关于动画蓝图的知识。
- en: Exercise 11.02 – adding the Blend Space to the character Animation Blueprint
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.02 – 将混合空间添加到角色动画蓝图
- en: For this exercise, you will add the Blend Space to the Animation Blueprint and
    prepare the necessary variable to help control this Blend Space based on the movement
    speed of the player character. Let’s begin by adding the Blend Space to **AnimGraph**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你将向动画蓝图添加混合空间，并准备必要的变量来帮助根据玩家角色的移动速度控制这个混合空间。让我们首先将混合空间添加到**AnimGraph**。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Add the Blend Space to `SideScroller_IdleRun_`Blend Space 1D asset into **AnimGraph**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将混合空间添加到`SideScroller_IdleRun_`混合空间1D资产到**AnimGraph**。
- en: 'Notice that the variable input for this Blend Space node is labeled `Speed`,
    just like the horizontal axis inside the Blend Space. Please refer to *Figure
    11.14* to see the Blend Space in the **Asset Browser** window:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个混合空间节点的变量输入被标记为`Speed`，就像混合空间内部的水平轴一样。请参考*图 11.14*以查看**资产浏览器**窗口中的混合空间：
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you were to name **Horizontal Axis** differently, the new name would be shown
    as the input parameter of the Blend Space.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将**水平轴**重命名为不同的名称，新的名称将显示为混合空间的输入参数。
- en: '![Figure 11.13 – Asset Browser gives you access to all animation assets related
    to MainCharacter_Skeleton ](img/Figure_11.13_B18531.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 资产浏览器让您访问与MainCharacter_Skeleton相关的所有动画资产](img/Figure_11.13_B18531.jpg)'
- en: Figure 11.13 – Asset Browser gives you access to all animation assets related
    to MainCharacter_Skeleton
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 资产浏览器让您访问与MainCharacter_Skeleton相关的所有动画资产
- en: 'Next, connect the `Output Pose` asset of the Blend Space node to the `Result`
    pin of the `Output Pose` node. Now, the animation pose in the preview will show
    the character in the `Idle` animation pose:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 Blend Space 节点的 `Output Pose` 资产连接到 `Output Pose` 节点的 `Result` 引脚。现在，预览中的动画姿态将显示角色的
    `Idle` 动画姿态：
- en: '![Figure 11.14 – You now have limited control of the Blend Space and can manually
    enter values into the Speed parameter ](img/Figure_11.14_B18531.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 您现在可以有限地控制 Blend Space，并可以手动输入 Speed 参数的值](img/Figure_11.14_B18531.jpg)'
- en: Figure 11.14 – You now have limited control of the Blend Space and can manually
    enter values into the Speed parameter
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 您现在可以有限地控制 Blend Space，并可以手动输入 Speed 参数的值
- en: 'If you use `Idle` animation instead of remaining in the T-Pose position:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用 `Idle` 动画而不是保持 T-Pose 姿势：
- en: '![Figure 11.15 – The player character now plays the Idle animation in-game
    ](img/Figure_11.15_B18531.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 玩家角色现在在游戏中播放 Idle 动画](img/Figure_11.15_B18531.jpg)'
- en: Figure 11.15 – The player character now plays the Idle animation in-game
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 玩家角色现在在游戏中播放 Idle 动画
- en: Now, we can control our Blend Space with our `Speed` input variable. With the
    ability to use the Blend Space in place, you need a way to store the character’s
    movement speed and pass that value to the `Speed` input parameter of the Blend
    Space. Let’s learn how to do this.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的 `Speed` 输入变量来控制我们的 Blend Space。在使用 Blend Space 的能力到位后，您需要一种方法来存储角色的移动速度并将该值传递给
    Blend Space 的 `Speed` 输入参数。让我们学习如何做到这一点。
- en: 'Navigate to the `Event Graph` property of our Animation Blueprint. By default,
    there will be the `Event Blueprint Update Animation` event and a pure `Try Get
    Pawn Owner` function. The following screenshot shows the default setup of `Event
    Graph`. The event is updated each frame that the animation is updated, and returns
    the `SuperSideScroller` player character Blueprint class before attempting to
    get any more information:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到我们的动画蓝图的事件图属性。默认情况下，将会有 `Event Blueprint Update Animation` 事件和一个纯 `Try Get
    Pawn Owner` 函数。以下截图显示了 `Event Graph` 的默认设置。事件在动画更新的每一帧都会更新，并在尝试获取更多信息之前返回 `SuperSideScroller`
    玩家角色蓝图类：
- en: '![Figure 11.16 – Animation Blueprints include this event and function pair
    by default for use in your Event Graph ](img/Figure_11.16_B18531.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – 动画蓝图默认包含此事件和函数对，以便在事件图中使用](img/Figure_11.16_B18531.jpg)'
- en: Figure 11.16 – Animation Blueprints include this event and function pair by
    default for use in your Event Graph
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – 动画蓝图默认包含此事件和函数对，以便在事件图中使用
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between a `Pure` and `Impure` function in UE5 is that a
    `Pure` function implies that the logic it contains will not modify a variable
    or member of the class that it is being used in. In the case of `Try` `Get` `Pawn`
    `Owner`, it is simply returning a reference to the `Pawn` owner of the Animation
    Blueprint. `Impure` functions do not have this implication and are free to modify
    any variable or member it wants.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 中，`Pure` 函数和 `Impure` 函数的主要区别在于 `Pure` 函数意味着它所包含的逻辑不会修改它所使用的类中的变量或成员。在
    `Try Get Pawn Owner` 的情况下，它只是返回动画蓝图的所有者 `Pawn` 的引用。"Impure" 函数没有这种暗示，可以自由修改它想要的任何变量或成员。
- en: 'Get the `Return Value` property from the `Try Get Pawn Owner` function and,
    from the `Context Sensitive` menu that appears, search for the cast to `SuperSideScrollerCharacter`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Try Get Pawn Owner` 函数获取 `Return Value` 属性，并在出现的 `Context Sensitive` 菜单中搜索
    `SuperSideScrollerCharacter` 的 Cast：
- en: '![Figure 11.17 – Casting ensures we are working with the correct class ](img/Figure_11.17_B18531.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17 – 强制转换确保我们使用的是正确的类](img/Figure_11.17_B18531.jpg)'
- en: Figure 11.17 – Casting ensures we are working with the correct class
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – 强制转换确保我们使用的是正确的类
- en: 'Connect the execution output pin from `Event Blueprint Update Animation` to
    the execution input pin of the cast:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Event Blueprint Update Animation` 的执行输出引脚连接到 Cast 的执行输入引脚：
- en: '![Figure 11.18 – Use the Try Get Pawn Owner function to cast the returned Pawn
    object to the SuperSideScrollerCharacter class ](img/Figure_11.18_B18531.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18 – 使用 Try Get Pawn Owner 函数将返回的 Pawn 对象转换为 SuperSideScrollerCharacter
    类](img/Figure_11.18_B18531.jpg)'
- en: Figure 11.18 – Use the Try Get Pawn Owner function to cast the returned Pawn
    object to the SuperSideScrollerCharacter class
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – 使用 Try Get Pawn Owner 函数将返回的 Pawn 对象转换为 SuperSideScrollerCharacter
    类
- en: The character Blueprint you created inherits from the `SuperSideScrollerCharacter`
    class. Since the owning pawn of this Animation Blueprint is your `BP_SuperSideScroller_MainCharacter`
    character Blueprint and this Blueprint inherits from the `SuperSideScrollerCharacter`
    class, the cast function will execute successfully.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的角色蓝图 `Blueprint` 继承自 `SuperSideScrollerCharacter` 类。由于这个动画蓝图的所有者 pawn 是你的
    `BP_SuperSideScroller_MainCharacter` 角色蓝图，并且这个蓝图继承自 `SuperSideScrollerCharacter`
    类，因此 cast 函数将成功执行。
- en: 'Next, store the returned value from the cast to its own variable; that way,
    we have a reference to it in case we need to use it again in our Animation Blueprint.
    Refer to *Figure 11.20* and make sure to name this new variable `MainCharacter`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 cast 返回的值存储在其自己的变量中；这样，我们就可以在需要时在动画蓝图中再次使用它。参考 *图 11.20* 并确保将这个新变量命名为
    `MainCharacter`：
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Promote to Variable` option is available in the context-sensitive dropdown,
    and allows you to store any valid value type in its own variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文相关的下拉菜单中，有“提升为变量”选项，允许你将任何有效的值类型存储在其自己的变量中。
- en: '![Figure 11.19 – So long as the cast is successful, you will want to keep track
    of the owning character ](img/Figure_11.19_B18531.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19 – 只要铸造成功，你将想要跟踪拥有该角色的信息](img/Figure_11.19_B18531.jpg)'
- en: Figure 11.19 – So long as the cast is successful, you will want to keep track
    of the owning character
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – 只要铸造成功，你将想要跟踪拥有该角色的信息
- en: 'Now, to track the character’s speed, use the `Get Velocity` function from the
    `MainCharacter` variable. Every object from the `Actor` class has access to this
    function and returns the magnitude and direction vector that the object is moving
    in:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了跟踪角色的速度，使用 `MainCharacter` 变量中的 `Get Velocity` 函数。`Actor` 类的每个对象都可以访问此函数，并返回对象移动的方向和大小向量：
- en: '![Figure 11.20 – The GetVelocity function can be found under Utilities/Transformation
    ](img/Figure_11.20_B18531.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20 – GetVelocity 函数可以在 Utilities/Transformation 下找到](img/Figure_11.20_B18531.jpg)'
- en: Figure 11.20 – The GetVelocity function can be found under Utilities/Transformation
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20 – GetVelocity 函数可以在 Utilities/Transformation 下找到
- en: 'From `Get Velocity`, you can use the `VectorLength` function to get the actual
    speed:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Get Velocity`，你可以使用 `VectorLength` 函数来获取实际的速度：
- en: '![Figure 11.21 – The VectorLength function returns the magnitude of the vector
    ](img/Figure_11.21_B18531.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.21 – VectorLength 函数返回向量的模](img/Figure_11.21_B18531.jpg)'
- en: Figure 11.21 – The VectorLength function returns the magnitude of the vector
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21 – VectorLength 函数返回向量的模
- en: '`Return Value` from the `VectorLength` function can then be promoted to its
    own variable named `Speed`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VectorLength` 函数的 `Return Value` 可以提升为其自己的变量 `Speed`：'
- en: '![Figure 11.22 – Every actor has the Get Velocity function ](img/Figure_11.22_B18531.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – 每个演员都有 Get Velocity 函数](img/Figure_11.22_B18531.jpg)'
- en: Figure 11.22 – Every actor has the Get Velocity function
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – 每个演员都有 Get Velocity 函数
- en: In this exercise, you obtained the player character speed by using the `GetVelocity`
    function. The vector that was returned from the `GetVelocity` function gives the
    length of the vector to ascertain the actual speed. By storing this value in the
    `Speed` variable, you can now reference this value in the **AnimGraph** property
    of the Animation Blueprint to update your Blend Space, which you will do in the
    next exercise. But first, let’s briefly discuss velocity vectors and how we use
    vector mathematics to determine the speed of our player character.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你通过使用 `GetVelocity` 函数获得了玩家角色的速度。从 `GetVelocity` 函数返回的向量给出了向量的长度，以确定实际的速度。通过将此值存储在
    `Speed` 变量中，你现在可以在动画蓝图的 **AnimGraph** 属性中引用此值来更新你的 Blend Space，你将在下一个练习中这样做。但首先，让我们简要讨论一下速度向量以及我们如何使用向量数学来确定玩家角色的速度。
- en: What are velocity vectors?
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度向量是什么？
- en: Before moving on to the next step, let’s explain what you are doing when you
    get the velocity of the character and promote the vector length of that vector
    to the `Speed` variable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，让我们解释一下当你获取角色的速度并将该向量的长度提升到 `Speed` 变量时你在做什么。
- en: What is velocity? Velocity is a vector that has a given **magnitude** and **direction**.
    To think about it another way, a vector can be drawn like an *arrow*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 速度是什么？速度是一个具有给定 **大小** 和 **方向** 的向量。换一种方式思考，向量可以像 *箭头* 一样绘制。
- en: 'The l*ength of the arrow* represents the `GetVelocity` function and the `VectorLength`
    function on the returned velocity vector; you are getting the value of the `Speed`
    variable of your character. That is why you store that value in a variable and
    use it to control the Blend Space, as shown in the following diagram. Here, you
    can see an example of vectors. One has a positive (right) direction with a magnitude
    of `100`, while the other has a negative (left) direction with a magnitude of
    `35`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头的长度代表 `GetVelocity` 函数和返回速度向量的 `VectorLength` 函数；你正在获取你角色的 `Speed` 变量的值。这就是为什么你将那个值存储在变量中，并使用它来控制混合空间，如图所示。在这里，你可以看到一个向量的例子。一个有正（右）方向，大小为
    `100`，而另一个有负（左）方向，大小为 `35`：
- en: '![Figure 11.23 – Two different vectors ](img/Figure_11.23_B18531.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.23 – 两个不同的向量](img/Figure_11.23_B18531.jpg)'
- en: Figure 11.23 – Two different vectors
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – 两个不同的向量
- en: In the following exercise, you will use the `Speed` variable you created from
    the `VectorLength` function of the velocity parameter of the player character
    from the previous exercise to drive how the Blend Space 1D will animate the character.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将使用从上一个练习中玩家角色的速度参数的 `VectorLength` 函数创建的 `Speed` 变量来驱动 1D 混合空间如何动画化角色。
- en: Exercise 11.03 – passing the character’s Speed variable into the Blend Space
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.03 – 将角色的速度变量传递到混合空间
- en: Now that you have a better understanding of vectors and how to store the `Speed`
    variable of the player character from the previous exercise, let’s apply the speed
    to the Blend Space 1D you created earlier in this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了向量以及如何从上一个练习中存储玩家角色的 `Speed` 变量，让我们将速度应用到本章 earlier 创建的 1D 混合空间中。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Navigate to the `AnimBP_SuperSideScroller_MainCharacter` Animation Blueprint.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `AnimBP_SuperSideScroller_MainCharacter` 动画蓝图。
- en: Use the `Speed` variable to update the Blend Space in real time in `Speed` variable
    onto the graph, and connecting the variable to the input of the `Blendspace Player`
    function:![Figure 11.24 – Using the Speed variable to update the Blend Space on
    every frame ](img/Figure_11.24_B18531.jpg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Speed` 变量在实时中更新混合空间，将变量连接到 `Blendspace Player` 函数的输入：![图 11.24 – 使用速度变量在每一帧更新混合空间](img/Figure_11.24_B18531.jpg)
- en: Figure 11.24 – Using the Speed variable to update the Blend Space on every frame
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – 使用速度变量在每一帧更新混合空间
- en: Next, compile the Animation Blueprint.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编译动画蓝图。
- en: 'With that, you can update the Blend Space based on the speed of the player
    character. When you use PIE, you will see the character in the `Idle` state and
    the `Walking` state when you move:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以根据玩家的速度更新混合空间。当你使用 PIE 时，当你移动时，你会看到角色的 `Idle` 状态和 `Walking` 状态：
- en: '![Figure 11.25 – The player character is finally able to walk around in the
    level ](img/Figure_11.25_B18531.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.25 – 玩家角色最终能够在关卡中四处走动](img/Figure_11.25_B18531.jpg)'
- en: Figure 11.25 – The player character is finally able to walk around in the level
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.25 – 玩家角色最终能够在关卡中四处走动
- en: Finally, the main character is using the movement animations based on movement
    speed. In the next activity, you will update the character movement component
    so that you can preview the character’s `Running` animation from the Blend Space.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主要角色正在使用基于移动速度的移动动画。在下一个活动中，你将更新角色移动组件，以便你可以从混合空间中预览角色的 `Running` 动画。
- en: Activity 11.02 – previewing the Running animation in-game
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.02 – 在游戏中预览跑步动画
- en: With the Animation Blueprint updating and getting the speed of the player character,
    you can preview the `Idle` and `Walking` animations in-game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新动画蓝图并获取玩家角色的速度，你可以在游戏中预览 `Idle` 和 `Walking` 动画。
- en: In this activity, you will update the `CharacterMovement` component of the player
    character Blueprint so that you can preview the `Running` animation in-game as
    well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将更新玩家角色蓝图的 `CharacterMovement` 组件，以便你可以在游戏中预览 `Running` 动画。
- en: 'Follow these steps to complete this activity:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Navigate to, and open, the `BP_SuperSideScroller_MainCharacter` player character
    Blueprint.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到并打开 `BP_SuperSideScroller_MainCharacter` 玩家角色蓝图。
- en: Access the `CharacterMovement` component.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `CharacterMovement` 组件。
- en: Modify the `Max Walk Speed` parameter to a value of `500.0` so that your character
    can move fast enough to blend its animation from `Idle` to `Walking` and, finally,
    to `Running`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Max Walk Speed` 参数修改为 `500.0` 的值，以便您的角色可以移动得足够快，以便从 `Idle` 动画平滑过渡到 `Walking`，最后到
    `Running`。
- en: By doing this, the player character can reach a speed that allows you to preview
    the `Running` animation in-game.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，玩家角色可以达到一个速度，允许您在游戏中预览 `Running` 动画。
- en: 'The expected output is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 11.26 – The player character running ](img/Figure_11.26_B18531.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.26 – 玩家角色正在奔跑](img/Figure_11.26_B18531.jpg)'
- en: Figure 11.26 – The player character running
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.26 – 玩家角色正在奔跑
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: Now that you have handled the player character movement blending from `Idle`
    to `Walking` and finally to `Running`, let’s add the functionality that allows
    the player character to move even quicker by sprinting.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经处理了玩家角色从 `Idle` 到 `Walking`，最后到 `Running` 的移动混合，让我们添加允许玩家角色通过冲刺更快移动的功能。
- en: Enhanced input system
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强型输入系统
- en: Every game requires input from the player, whether it is the keys on a keyboard
    such as *W*, *A*, *S*, and *D* for moving the player character, or the thumb sticks
    on a controller; this is what makes video games an interactive experience. We
    will be using the Enhanced Input System to add an input binding for the sprint
    action of the player character. For a refresher on how to enable and set up the
    Enhanced Input System plugin, please review [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099),
    *Getting Started with Player Input*; moving forward, the exercises in this chapter
    assume you have enabled the plugin.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都需要玩家的输入，无论是键盘上的 *W*、*A*、*S* 和 *D* 键来移动玩家角色，还是控制器上的摇杆；这就是使电子游戏成为一种交互式体验的原因。我们将使用增强型输入系统为玩家角色的冲刺动作添加输入绑定。有关如何启用和设置增强型输入系统插件的复习，请参阅
    [*第 4 章*](B18531_04.xhtml#_idTextAnchor099)，*玩家输入入门*；从现在开始，本章的练习假设您已经启用了插件。
- en: UE5 allows us to map keyboard, mouse, gamepad, and other types of controls to
    labeled actions or axes that you can then reference in Blueprints or C++ to allow
    character or gameplay functionality to occur. It is important to point out that
    each unique action or axis mapping can have one or more key bindings, and that
    the same key binding can be used for multiple mappings. Input bindings are saved
    into an initialization file called `DefaultInput.ini` and can be found in the
    `Config` folder of your project directory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: UE5 允许我们将键盘、鼠标、游戏手柄和其他类型的控制映射到标记的动作或轴，然后您可以在蓝图或 C++ 中引用这些动作或轴，以便允许角色或游戏玩法功能发生。重要的是要指出，每个独特的动作或轴映射可以有一个或多个键绑定，并且相同的键绑定可以用于多个映射。输入绑定被保存到一个名为
    `DefaultInput.ini` 的初始化文件中，并位于您项目目录的 `Config` 文件夹中。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Legacy input bindings can be edited directly via the `DefaultInput.ini` file
    or through **Project Settings** in the editor itself. The latter is more easily
    accessible and less error-prone when editing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版输入绑定可以直接通过 `DefaultInput.ini` 文件或在编辑器本身的 **项目设置** 中进行编辑。后者在编辑时更容易访问且更不容易出错。
- en: In the next exercise, we’ll add a new input binding for the player character’s
    `Sprint` functionality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将为玩家的 `Sprint` 功能添加一个新的输入绑定。
- en: Exercise 11.04 – adding input for sprinting
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.04 – 添加冲刺输入
- en: With the player character moving around the level, you will now implement a
    unique character class for the player character that derives from the base `SuperSideScrollerCharacter`
    C++ class. The reason to do this is so that you can easily differentiate between
    classes of the player character and the enemy later on, instead of relying solely
    on unique Blueprint classes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家角色在关卡中移动时，您现在将实现一个独特的角色类，该类从基类 `SuperSideScrollerCharacter` C++ 类派生。这样做的原因是，您可以轻松区分玩家角色和敌人的类别，而不是完全依赖于唯一的蓝图类。
- en: While creating the unique C++ character class, you will implement the *sprinting*
    behavior to allow the player character to *walk* and *sprint* as desired.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建独特的 C++ 角色类时，你将实现 *冲刺* 行为，允许玩家角色按需 *行走* 和 *冲刺*。
- en: 'Let’s begin by implementing the `Sprinting` mechanic by adding an `Input Action`
    for `Sprint`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过添加 `Sprint` 的 `Input Action` 来实现 `Sprinting` 机制：
- en: Navigate to the `Content` directory, add a new folder called `Input`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Content` 目录，添加一个名为 `Input` 的新文件夹。
- en: In the `Sprint`. It is in this directory that we will create both the `Input
    Action` and `Input Mapping Context` assets.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Sprint` 目录中。它就是在这个目录中我们将创建 `Input Action` 和 `Input Mapping Context` 资产。
- en: 'In the `Sprint` folder, right-click and find the **Input Action** option, under
    the **Input** category of the menu, as shown here:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Sprint` 文件夹中，右键单击并找到 **输入动作** 选项，在菜单的 **输入** 类别下，如图所示：
- en: '![Figure 11.27 – The Input Action class ](img/Figure_11.27_B18531.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.27 – 输入动作类](img/Figure_11.27_B18531.jpg)'
- en: Figure 11.27 – The Input Action class
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.27 – 输入动作类
- en: Name this `IA_Sprint` and open the asset.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此命名为 `IA_Sprint` 并打开资产。
- en: 'Under the **Triggers** section, add a new **Trigger** by left-clicking on the
    **+** icon. Under the **Index[0]** parameter, select the **Down** type:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **触发器** 部分中，通过左键单击 **+** 图标添加一个新的 **触发器**。在 **Index[0]** 参数下选择 **向下** 类型：
- en: '![Figure 11.28 – The IA_Sprint Input Action class using the Down Trigger type
    ](img/Figure_11.28_B18531.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.28 – 使用向下触发类型的 IA_Sprint 输入动作类](img/Figure_11.28_B18531.jpg)'
- en: Figure 11.28 – The IA_Sprint Input Action class using the Down Trigger type
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.28 – 使用向下触发类型的 IA_Sprint 输入动作类
- en: Now that we have our **Input Action**, let’s create the **Input Mapping Context**
    asset and add the action to it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的 **输入动作**，接下来让我们创建 **输入映射上下文** 资产并将其动作添加到其中。
- en: 'In the **Input** directory, right-click and find the **Input Mapping Context**
    option, under the **Input** category of the menu, as shown here:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **输入** 目录中，右键单击并找到 **输入映射上下文** 选项，在菜单的 **输入** 类别下，如图所示：
- en: '![Figure 11.29 – The Input Mapping Context class ](img/Figure_11.29_B18531.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.29 – 输入映射上下文类](img/Figure_11.29_B18531.jpg)'
- en: Figure 11.29 – The Input Mapping Context class
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.29 – 输入映射上下文类
- en: Name this `IC_SideScrollerCharacter` and open the asset.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此命名为 `IC_SideScrollerCharacter` 并打开资产。
- en: In the `IA_Sprint`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IA_Sprint` 中。
- en: Next, we want to assign *Left Shift* as the binding to use for sprinting.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望将 *左 Shift* 作为用于冲刺的绑定。
- en: 'In the **Triggers** section, add a new **Trigger** by left-clicking on the
    **+** icon. Under the **Index[0]** parameter, select **Down**. The final **Input
    Mapping Context** should look like this:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **触发器** 部分中，通过左键单击 **+** 图标添加一个新的 **触发器**。在 **Index[0]** 参数下选择 **向下**。最终的
    **输入映射上下文** 应该看起来像这样：
- en: '![Figure 11.30 – IC_SideScrollerCharacter using the IA_Sprint Input Action
    mapping ](img/Figure_11.30_B18531.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.30 – 使用 IA_Sprint 输入动作映射的 IC_SideScrollerCharacter](img/Figure_11.30_B18531.jpg)'
- en: Figure 11.30 – IC_SideScrollerCharacter using the IA_Sprint Input Action mapping
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.30 – 使用 IA_Sprint 输入动作映射的 IC_SideScrollerCharacter
- en: With the `Sprint` input binding in place, you need to create a new C++ class
    for the player character based on the `SuperSideScrollerCharacter` class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Sprint` 输入绑定就绪后，你需要基于 `SuperSideScrollerCharacter` 类创建一个新的 C++ 类用于玩家角色。
- en: 'Make sure that you update the `SuperSideScroller.Build.cs` file so that it
    includes the Enhanced Input plugin; otherwise, your code will not compile. Add
    the following line inside the `public SuperSideScroller(ReadOnlyTargetRues Target)
    : base(Target)` function:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '确保更新 `SuperSideScroller.Build.cs` 文件，使其包含 Enhanced Input 插件；否则，你的代码将无法编译。在
    `public SuperSideScroller(ReadOnlyTargetRues Target) : base(Target)` 函数内部添加以下行：'
- en: '`PrivateDependencyModuleNames.AddRange(new string[] {“EnhancedInput”});`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrivateDependencyModuleNames.AddRange(new string[] {“EnhancedInput”});`'
- en: Then, head back inside the editor, navigate to **Tools**, and, from the drop-down
    list, select the **New C++ Class** option.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，回到编辑器内部，导航到 **工具**，从下拉列表中选择 **新建 C++ 类** 选项。
- en: 'The new player character class will inherit from the `SuperSideScrollerCharacter`
    parent class because this base class contains the majority of the functionality
    needed for the player character. After selecting the parent class, click `SuperSideScrollerCharacter`
    class:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的玩家角色类将继承自 `SuperSideScrollerCharacter` 父类，因为这个基类包含了玩家角色所需的大部分功能。在选择了父类后，点击
    `SuperSideScrollerCharacter` 类：
- en: '![Figure 11.31 – Selecting the SuperSideScrollerCharacter parent class ](img/Figure_11.31_B18531.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.31 – 选择 SuperSideScrollerCharacter 父类](img/Figure_11.31_B18531.jpg)'
- en: Figure 11.31 – Selecting the SuperSideScrollerCharacter parent class
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.31 – 选择 SuperSideScrollerCharacter 父类
- en: Name this new class `SuperSideScroller_Player`. Leave the path as the default
    that Unreal Engine provides for you unless you need to adjust the file directory
    of this new class. After naming the new class and selecting the directory to save
    the class in, click `Create Class`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新类命名为 `SuperSideScroller_Player`。除非您需要调整这个新类的文件目录，否则请保留虚幻引擎提供的默认路径。在命名新类并选择保存类的目录后，点击“创建类”。
- en: After selecting `Create Class`, Unreal Engine will generate the source and header
    files for you, and Visual Studio will automatically open these files. You will
    notice that both the header file and the source file are almost empty. This is
    OK because you are inheriting from the `SuperSideScrollerCharacter` class and
    much of the logic you want is done in that class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择“创建类”后，虚幻引擎将为您生成源文件和头文件，并且 Visual Studio 将自动打开这些文件。您会注意到头文件和源文件几乎都是空的。这是正常的，因为您是从
    `SuperSideScrollerCharacter` 类继承的，您想要的很多逻辑都在这个类中完成。
- en: 'In `SuperSideScroller_Player`, you will only add the functionality you need
    on top of what you inherit. You can view the line where the inheritance is taking
    place inside `SuperSideScroller_Player.h`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SuperSideScroller_Player` 中，您只需添加您需要的功能，覆盖继承的内容。您可以在 `SuperSideScroller_Player.h`
    内部查看继承发生的行：
- en: '[PRE0]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class declaration is saying that the new `ASuperSideScroller_Player` class
    inherits from the `ASuperSideScrollerCharacter` class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类声明表明新的 `ASuperSideScroller_Player` 类继承自 `ASuperSideScrollerCharacter` 类。
- en: By completing this exercise, you added an `Sprint` mechanic that can then be
    referenced in C++ and used to allow the player to sprint. Now that you have also
    created the C++ class for the player character, you can update the code with the
    `Sprint` functionality, but first, you will need to update the `Blueprint` character
    and the Animation Blueprint to reference this new class. We’ll do this in the
    next exercise.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您添加了一个 `Sprint` 力学机制，然后可以在 C++ 中引用并允许玩家进行冲刺。现在您也已经创建了玩家角色的 C++ 类，您可以更新代码以包含
    `Sprint` 功能，但首先，您需要更新 `Blueprint` 角色和动画蓝图以引用这个新类。我们将在下一个练习中这样做。
- en: What happens when you reparent a Blueprint to a new class? Each Blueprint inherits
    from a parent class. In most cases, this is `Actor`, but in the case of your character
    Blueprint, its parent class is `SuperSideScrollerCharacter`. Inheriting from a
    parent class allows a Blueprint to inherit the functionality and variables of
    that class so that the logic can be reused at the Blueprint level.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将蓝图重新父化到一个新类时会发生什么？每个蓝图都继承自父类。在大多数情况下，这是 `Actor`，但就您的角色蓝图而言，其父类是 `SuperSideScrollerCharacter`。从父类继承允许蓝图继承该类的功能变量，以便在蓝图级别重用逻辑。
- en: For example, when inheriting from the `SuperSideScrollerCharacter` class, the
    Blueprint inherits components such as the `CharacterMovement` component and the
    `Mesh` skeletal mesh component, which can then be modified in the Blueprint.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当从 `SuperSideScrollerCharacter` 类继承时，蓝图会继承如 `CharacterMovement` 组件和 `Mesh`
    骨骼网格组件等组件，这些组件可以在蓝图中进行修改。
- en: Exercise 11.05 – reparenting the character Blueprint
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.05 – 重新父化角色蓝图
- en: Now that you have created a new character class for the player character, you
    need to update the `BP_SuperSideScroller_MainCharacter` Blueprint so that it uses
    the `SuperSideScroller_Player` class as its parent class. If you don’t, then any
    logic you add to the new class will not affect the character made in the Blueprint.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为玩家角色创建了一个新的角色类，您需要更新 `BP_SuperSideScroller_MainCharacter` 蓝图，使其使用 `SuperSideScroller_Player`
    类作为其父类。如果不这样做，您添加到新类中的任何逻辑都不会影响在蓝图中所创建的角色。
- en: 'Follow these steps to reparent the Blueprint to the new character class:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将蓝图重新父化到新角色类：
- en: Navigate to `/Game/MainCharacter/Blueprints/` and open the `BP_SuperSideScroller_MainCharacter`
    Blueprint.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/Game/MainCharacter/Blueprints/` 并打开 `BP_SuperSideScroller_MainCharacter`
    蓝图。
- en: Select the **File** option on the toolbar and, from the drop-down menu, select
    the **Reparent Blueprint** option.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏上选择“文件”选项，然后从下拉菜单中选择“重新父化蓝图”选项。
- en: When selecting the `SuperSideScroller_Player` and select that option from the
    dropdown by left-clicking.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择 `SuperSideScroller_Player` 并通过左键点击从下拉菜单中选择该选项。
- en: Once you select the new parent class for the Blueprint, Unreal Engine will reload
    the Blueprint and recompile it, both of which will happen automatically.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为蓝图选择了新的父类，Unreal Engine 将重新加载蓝图并重新编译，这两者都将自动发生。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when reparenting Blueprints to new parent classes as this can lead
    to compile errors or settings to be erased or reverted to class defaults. Unreal
    Engine will display any warnings or errors that may occur after compiling the
    Blueprint and reparenting it to a new class. These warnings and errors usually
    occur if there is Blueprint logic that references variables or other class members
    that no longer exist in the new parent class. Even if there are no compile errors,
    it is best to confirm that any logic or settings you have added to your Blueprint
    are still present after the reparenting before moving on with your work.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在将蓝图重新分配到新的父类时要小心，因为这可能导致编译错误或设置被清除或重置为类默认值。Unreal Engine 将在编译蓝图并将其重新分配到新类后显示任何可能发生的警告或错误。这些警告和错误通常发生在蓝图逻辑引用了在新父类中不再存在的变量或其他类成员的情况下。即使没有编译错误，最好在继续工作之前确认您添加到蓝图中的任何逻辑或设置在重新分配后仍然存在。
- en: Now that your character Blueprint has been correctly reparented to the new `SuperSideScroller_Player`
    class, you need to update the `AnimBP_SuperSideScroller_MainCharacter` Animation
    Blueprint to ensure that you are casting to the correct class when using the `Try
    Get Pawn Owner` function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的角色蓝图已正确重新分配到新的 `SuperSideScroller_Player` 类，您需要更新 `AnimBP_SuperSideScroller_MainCharacter`
    动画蓝图，以确保在使用 `Try Get Pawn Owner` 函数时正在调用正确的类。
- en: Next, navigate to the `/MainCharacter/Blueprints/` directory and open the `AnimBP_SuperSideScroller_MainCharacter`
    Animation Blueprint.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到 `/MainCharacter/Blueprints/` 目录并打开 `AnimBP_SuperSideScroller_MainCharacter`
    动画蓝图。
- en: 'Open `Return Value` property of the `Try Get Pawn Owner` function, search for
    `Cast` `to` `SuperSideScroller_Player`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Try Get Pawn Owner` 函数的 `Return Value` 属性，搜索 `Cast to SuperSideScroller_Player`：
- en: '![Figure 11.32 – Casting to the new SuperSideScroller_Player class ](img/Figure_11.32_B18531.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.32 – 调用新的 SuperSideScroller_Player 类](img/Figure_11.32_B18531.jpg)'
- en: Figure 11.32 – Casting to the new SuperSideScroller_Player class
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.32 – 调用新的 SuperSideScroller_Player 类
- en: 'Now, you can connect the output as a `SuperSideScroller_Player` cast to the
    `MainCharacter` variable. This works because the `MainCharacter` variable is of
    the `SuperSideScrollerCharacter` type and the new `SuperSideScroller_Player` class
    inherits from that class:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以将输出连接为 `SuperSideScroller_Player` 调用到 `MainCharacter` 变量。这是因为 `MainCharacter`
    变量是 `SuperSideScrollerCharacter` 类型，而新的 `SuperSideScroller_Player` 类从该类继承而来：
- en: '![Figure 11.33 – You can still use the MainCharacter variable because SuperSideScroller_Player
    is based on SuperSideScrollerCharacter due to inheritance ](img/Figure_11.33_B18531.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.33 – 由于继承，您仍然可以使用 MainCharacter 变量，因为 SuperSideScroller_Player 基于 SuperSideScrollerCharacter](img/Figure_11.33_B18531.jpg)'
- en: Figure 11.33 – You can still use the MainCharacter variable because SuperSideScroller_Player
    is based on SuperSideScrollerCharacter due to inheritance
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.33 – 由于继承，您仍然可以使用 MainCharacter 变量，因为 SuperSideScroller_Player 基于 SuperSideScrollerCharacter
- en: Now that both the `BP_SuperSideScroller_MainCharacter` character Blueprint and
    the `AnimBP_SuperSideScroller_MainCharacter` Animation Blueprint are referencing
    your new `SuperSideScroller_Player` class, it is safe to venture into C++ and
    code the character’s sprint functionality.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于 `BP_SuperSideScroller_MainCharacter` 角色蓝图和 `AnimBP_SuperSideScroller_MainCharacter`
    动画蓝图都引用了您的新 `SuperSideScroller_Player` 类，您可以安全地进入 C++ 编写角色的冲刺功能。
- en: Exercise 11.06 – coding the character’s sprint functionality
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.06 – 编写角色的冲刺功能
- en: With the new `SuperSideScroller_Player` class reference correctly implemented
    in a Blueprint, it is time to start coding the functionality that will allow the
    player character to sprint.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图正确实现了新的 `SuperSideScroller_Player` 类引用后，是时候开始编写允许玩家角色冲刺的功能了。
- en: 'Follow these steps to add the `Sprinting` mechanic to the character:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将 `Sprinting` 力学添加到角色中：
- en: The first thing to take care of is the constructor of the `SuperSideScroller_Player`
    class. Navigate back to Visual Studio and open the `SuperSideScroller_Player.h`
    header file.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要处理的是 `SuperSideScroller_Player` 类的构造函数。导航回 Visual Studio 并打开 `SuperSideScroller_Player.h`
    头文件。
- en: 'You will use the `constructor` function later in this exercise to set initialized
    values for variables. For now, it will be an empty constructor. Make sure that
    the declaration is made under the `public` access modifier heading, as shown in
    the following code:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在本练习的后面使用`constructor`函数来设置变量的初始化值。现在，它将是一个空构造函数。确保在`public`访问修饰符标题下进行声明，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the constructor declared, create the constructor function definition in
    the `SuperSideScroller_Player.cpp` source file:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数声明后，在`SuperSideScroller_Player.cpp`源文件中创建构造函数定义：
- en: '[PRE2]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the constructor in place, it’s time to create the `SetupPlayerInputComponent`
    function so that you can use the key bindings you created earlier to call functions
    within the `SuperSideScroller_Player` class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数就绪后，是时候创建`SetupPlayerInputComponent`函数了，这样你就可以使用你之前创建的键绑定在`SuperSideScroller_Player`类中调用函数。
- en: The `SetupPlayerInputComponent` function is a function that the character class
    has built-in by default, so you need to declare it as a `virtual` function with
    the `override` specifier. This tells Unreal Engine that you are using this function
    and intend to redefine its functionality in this new class. Make sure that the
    declaration is made under the `Protected` access modifier heading.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupPlayerInputComponent`函数是角色类默认内置的函数，因此你需要将其声明为带有`override`指定符的`virtual`函数。这告诉虚幻引擎你正在使用此函数并打算在这个新类中重新定义其功能。确保在`Protected`访问修饰符标题下进行声明。'
- en: 'The `SetupPlayerInputComponent` function requires an object of the `UInputComponent`
    class to be passed into the function, like so:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetupPlayerInputComponent`函数需要一个`UInputComponent`类的对象传递给函数，如下所示：'
- en: '[PRE3]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UInputComponent* PlayerInputComponent` variable is inherited from the `UCharacter`
    base class that our `ASuperSideScroller_Player()` class derives from, so it must
    be used as the input parameter of the `SetupPlayerInputComponent()` function.
    Using any other name will result in a compilation error.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`UInputComponent* PlayerInputComponent`变量是从我们的`ASuperSideScroller_Player()`类继承的`UCharacter`基类，因此它必须作为`SetupPlayerInputComponent()`函数的输入参数使用。使用任何其他名称将导致编译错误。'
- en: 'Now, in the source file, create the definition of the `SetupPlayerInputComponent`
    function. In the body of the function, we will use the `Super` keyword to call
    it:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在源文件中创建`SetupPlayerInputComponent`函数的定义。在函数体中，我们将使用`Super`关键字来调用它：
- en: '[PRE4]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Super` keyword enables us to call the `SetupPlayerInputComponent` parent
    method. With the `SetupPlayerInputComponent` function ready, you need to include
    the following header files to continue with this exercise without any compile
    errors:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Super`关键字使我们能够调用`SetupPlayerInputComponent`父方法。在`SetupPlayerInputComponent`函数准备好后，你需要包含以下头文件，以继续此练习而不会出现任何编译错误：'
- en: '`#include “Components/InputComponent.h”`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include “Components/InputComponent.h”`'
- en: '`#include “GameFramework/CharacterMovementComponent.h”`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include “GameFramework/CharacterMovementComponent.h”`'
- en: 'You will need to include the header for the input component to bind the key
    mappings to the sprint functions you will be creating next. The header for the
    `Character Movement` component will be necessary for the sprint functions because
    you will be updating the `Max Walk Speed` parameter based on whether the player
    is sprinting. The following code contains all of the headers that need to be included
    for the player character:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要包含输入组件的头文件来绑定你将要创建的冲刺函数的键映射。`Character Movement`组件的头文件对于冲刺函数是必要的，因为你将根据玩家是否在冲刺来更新`Max
    Walk Speed`参数。以下代码包含需要包含的所有头文件，用于玩家角色：
- en: '[PRE5]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the necessary headers included in the source file of the `SuperSideScroller_Player`
    class, you can create the sprint functions to make the player character move faster.
    Let’s begin by declaring the required variable and functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Player`类的源文件中包含必要的头文件后，你可以创建冲刺函数来使玩家角色移动得更快。让我们首先声明所需的变量和函数。
- en: 'Under the `Private` access modifier in the header file of the `SuperSideScroller_Player`
    class, declare a new Boolean variable called `bIsSprinting`. This variable will
    be used as a failsafe so that you know whether the player character is sprinting
    before making any changes to the movement speed:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Player`类的头文件中的`Private`访问修饰符下，声明一个新的布尔变量`bIsSprinting`。这个变量将用作安全措施，以便在更改移动速度之前知道玩家角色是否正在冲刺：
- en: '[PRE6]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, declare two new functions, `Sprint();` and `StopSprinting();`. These
    two functions will not take any arguments and will not return anything. Declare
    these functions under the `Protected` access modifier:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明两个新的函数，`Sprint();`和`StopSprinting();`。这两个函数将不接受任何参数，也不会返回任何内容。在`受保护`访问修饰符下声明这些函数：
- en: '[PRE7]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Sprint();` function will be called when the player presses/holds the `Sprint`
    key mapped to the binding; `StopSprinting()` will be called when the player releases
    the key mapped to the binding.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下/保持与绑定映射的`Sprint`键时，将调用`Sprint();`函数；当玩家释放与绑定映射的键时，将调用`StopSprinting()`函数。
- en: 'Start with the definition of the `Sprint();` function. In the source file of
    the `SuperSideScroller_Player` class, create the definition for this function,
    as shown here:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Sprint();`函数的定义开始。在`SuperSideScroller_Player`类的源文件中，为这个函数创建定义，如下所示：
- en: '[PRE8]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Within the function, you will want to check the value of the `bIsSprinting`
    variable. If the player is *NOT* sprinting, meaning that `bIsSprinting` is `False`,
    then you can create the rest of the function.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，你将想要检查`bIsSprinting`变量的值。如果玩家**没有**冲刺，意味着`bIsSprinting`是`False`，那么你可以创建函数的其余部分。
- en: 'Within the `If` statement, set the `bIsSprinting` variable to `True`. Then,
    access the `GetCharacterMovement()` function and modify the `MaxWalkSpeed` parameter.
    Set `MaxWalkSpeed` to `500.0f`. Remember that the `Maximum Axis Value` parameter
    of the movement Blend Space is `500.0f`. This means that the player character
    will reach the speed necessary to use the `Running` animation:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`If`语句中，将`bIsSprinting`变量设置为`True`。然后，访问`GetCharacterMovement()`函数并修改`MaxWalkSpeed`参数。将`MaxWalkSpeed`设置为`500.0f`。记住，移动混合空间的最大轴值参数是`500.0f`。这意味着玩家角色将达到使用`Running`动画所需的速度：
- en: '[PRE9]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `StopSprinting()` function will look almost identical to the `Sprint()`
    function you just wrote, but it works in the opposite manner. First, you want
    to check whether the player is sprinting, meaning that `bIsSprinting` is `True`.
    If so, you can create the rest of the function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopSprinting()`函数将几乎与刚刚编写的`Sprint()`函数相同，但它的工作方式相反。首先，你想要检查玩家是否在冲刺，意味着`bIsSprinting`是`True`。如果是这样，你可以创建函数的其余部分。'
- en: 'Inside the `If` statement, set `bIsSprinting` to `False`. Then, access the
    `GetCharacterMovement()` function to modify `MaxWalkSpeed`. Set `MaxWalkSpeed`
    back to `300.0f`, which is the default speed for the player character when they’re
    walking. This means that the player character will only reach the speed that’s
    necessary for the `Walking` animation:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`If`语句中，将`bIsSprinting`设置为`False`。然后，访问`GetCharacterMovement()`函数来修改`MaxWalkSpeed`。将`MaxWalkSpeed`恢复到`300.0f`，这是玩家角色行走时的默认速度。这意味着玩家角色将只能达到`Walking`动画所需的速度：
- en: '[PRE10]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you have the functions needed for sprinting, it is time to bind these
    functions to the action mappings you created earlier. To do this, you need to
    create variables that hold a reference to the Input Mapping Context and Input
    Action that were created earlier in this chapter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了所需的冲刺函数，是时候将这些函数绑定到你之前创建的动作映射上了。为此，你需要创建变量来保存对之前在本章中创建的输入映射上下文和输入动作的引用。
- en: 'Inside the `SuperSideScroller_Player` header file, under the **Protected**
    category, add the following lines of code to create the properties for the Input
    Mapping Context and Input Action:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Player`头文件中，在**受保护**类别下，添加以下代码行以创建输入映射上下文和输入动作的属性：
- en: '[PRE11]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We must remember to assign these properties within our character Blueprint before
    we attempt to test the sprinting functionality.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住在我们尝试测试冲刺功能之前，在我们的角色蓝图内分配这些属性。
- en: 'Next, inside the `SuperSideScroller_Player` source file, within the `SetupPlayerInputComponent()`
    function, we need to get a reference to the Enhanced Input Component by writing
    the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`SuperSideScroller_Player`源文件内部，在`SetupPlayerInputComponent()`函数中，我们需要通过编写以下代码来获取增强输入组件的引用：
- en: '[PRE12]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we are referencing `UEnhancedInputComponent`, we need to remember
    to include this class as well:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在引用`UEnhancedInputComponent`，我们需要记住将这个类也包含在内：
- en: '[PRE13]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we want to support both legacy input and the Enhanced Input System, let’s
    add a specific `if` statement to our code to check if the `EnhancedPlayerInput`
    variable is valid:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要支持旧版输入和增强输入系统，让我们在我们的代码中添加一个特定的`if`语句来检查`EnhancedPlayerInput`变量是否有效：
- en: '[PRE14]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the `EnhancedPlayerInput` variable is valid, then we want to get a reference
    to our Player Controller so that we can get access to the `EnhancedInputLocalPlayerSubsystem`
    class, which will allow us to assign our Input Mapping Context:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `EnhancedPlayerInput` 变量有效，我们想要获取我们的玩家控制器的引用，以便我们可以访问 `EnhancedInputLocalPlayerSubsystem`
    类，这将允许我们分配我们的输入映射上下文：
- en: '[PRE15]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we are referencing the `UEnhancedInputLocalPlayerSubsystem` class,
    we need to add the following `include` header file:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们正在引用 `UEnhancedInputLocalPlayerSubsystem` 类，我们需要添加以下 `include` 头文件：
- en: '[PRE16]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we will add another `if` statement that checks if the `EnhancedSubsystem`
    variable is valid and then call the `AddMappingContext` function to add our `IC_Character`
    Input Mapping Context to our Player Controller:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加另一个 `if` 语句来检查 `EnhancedSubsystem` 变量是否有效，然后调用 `AddMappingContext` 函数将我们的
    `IC_Character` 输入映射上下文添加到我们的玩家控制器中：
- en: '[PRE17]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have applied the Input Mapping Context to the player characters’
    `EnhancedSubsystem`, we can bind the `Sprint()` and `StopSprinting()` functions
    to the Input Action we created earlier.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将输入映射上下文应用到玩家角色的 `EnhancedSubsystem` 上，我们可以将 `Sprint()` 和 `StopSprinting()`
    函数绑定到我们之前创建的输入动作。
- en: 'At the end of the `if(EnhancedPlayerInput)` statement, we will add a `BindAction`
    to bind `ETriggerEvent::Triggered` to the `Sprint()` function:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if(EnhancedPlayerInput)` 语句的末尾，我们将添加一个 `BindAction` 来绑定 `ETriggerEvent::Triggered`
    到 `Sprint()` 函数：
- en: '[PRE18]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we can add our `BindAction` to bind `ETriggerEvent::Completed` to
    the `StopSprinting()` function:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将我们的 `BindAction` 添加到绑定 `ETriggerEvent::Completed` 到 `StopSprinting()`
    函数：
- en: '[PRE19]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information regarding the `ETriggerEvent` enumerator type, as well
    as more details about the Enhanced Input System, please revisit [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099),
    *Getting Started with Player Input*, or refer to the following documentation from
    Epic Games: [https://docs.unrealengine.com/5.0/en-US/GameplayFeatures/EnhancedInput/.](https://docs.unrealengine.com/5.0/en-US/GameplayFeatures/EnhancedInput/%0D)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `ETriggerEvent` 枚举类型以及增强输入系统的更多详细信息，请重新查看 [*第4章*](B18531_04.xhtml#_idTextAnchor099)，*玩家输入入门*，或参考
    Epic Games 的以下文档：[https://docs.unrealengine.com/5.0/en-US/GameplayFeatures/EnhancedInput/](https://docs.unrealengine.com/5.0/en-US/GameplayFeatures/EnhancedInput/%0D)
- en: With `Action Mappings` bound to the sprint functions, the last thing you need
    to do is set the default initialized values of the `bIsSprinting` variable and
    the `MaxWalkSpeed` parameter from the `Character Movement` component.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Action Mappings` 绑定到冲刺函数后，你需要做的最后一件事是将 `bIsSprinting` 变量的默认初始化值和 `Character
    Movement` 组件的 `MaxWalkSpeed` 参数的默认初始化值设置好。
- en: Inside the `constructor` function in the source file of your `SuperSideScroller_Player`
    class, add the `bIsSprinting = false` line. This variable is constructed as false
    because the player character should not be sprinting by default.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `SuperSideScroller_Player` 类的源文件中的 `constructor` 函数内，添加 `bIsSprinting =
    false` 行。这个变量被构造为 false，因为玩家角色默认不应该冲刺。
- en: 'Finally, set the `MaxWalkSpeed` parameter of the character movement component
    to `300.0f` by adding `GetCharacterMovement()->MaxWalkSpeed = 300.0f`. Please
    review the following code:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过添加 `GetCharacterMovement()->MaxWalkSpeed = 300.0f` 将角色移动组件的 `MaxWalkSpeed`
    参数设置为 `300.0f`。请查看以下代码：
- en: '[PRE20]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the variables that have been added to the constructor initialized, the
    `SuperSideScroller_Player` class is done, for now. Return to Unreal Engine and
    left-click on the **Compile** button on the toolbar. This will recompile the code
    and perform a hot-reload of the editor.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中添加的变量初始化完成后，`SuperSideScroller_Player` 类目前就完成了。返回 Unreal Engine 并在工具栏上左键单击
    **编译** 按钮。这将重新编译代码并执行编辑器的热重载。
- en: After recompiling and hot-reloading the editor, we need to remember to assign
    both the Input Mapping Context and the Input Action inside our player character.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新编译和热重载编辑器后，我们需要记住在我们的玩家角色内部分配输入映射上下文和输入动作。
- en: Navigate to the `MainCharacter/Blueprints` directory and open the `BP_SuperSideScroller_MainCharacter`
    Blueprint.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `MainCharacter/Blueprints` 目录并打开 `BP_SuperSideScroller_MainCharacter` 蓝图。
- en: 'In the `IC_Character` and `IA_Sprint`. Assign the Input Context Mapping and
    Input Action assets we created earlier to these parameters:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IC_Character` 和 `IA_Sprint` 中，将我们之前创建的输入上下文映射和输入动作资产分配给这些参数：
- en: '![Figure 11.34 – The IC_Character and IA_Sprint parameters ](img/Figure_11.34_B18531.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图11.34 – IC_Character 和 IA_Sprint 参数](img/Figure_11.34_B18531.jpg)'
- en: Figure 11.34 – The IC_Character and IA_Sprint parameters
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34 – IC_Character 和 IA_Sprint 参数
- en: 'Upon compiling the `BP_SuperSideScroller_MainCharacter` Blueprint, you can
    use `Running` animation:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 `BP_SuperSideScroller_MainCharacter` 蓝图后，你可以使用 `Running` 动画：
- en: '![Figure 11.35 – The player character can now sprint ](img/Figure_11.35_B18531.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.35 – 玩家角色现在可以冲刺](img/Figure_11.35_B18531.jpg)'
- en: Figure 11.35 – The player character can now sprint
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.35 – 玩家角色现在可以冲刺
- en: With the player character able to sprint, let’s move on to the next activity,
    where you will implement the base `Throw` functionality in a very similar way.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家角色能够冲刺时，让我们继续进行下一个活动，在这个活动中，你将以非常相似的方式实现基本的 `Throw` 功能。
- en: Activity 11.03 – implementing the throwing input
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.03 – 实现投掷输入
- en: One of the features included with this game is the ability for the player to
    throw projectiles at the enemy. You won’t be creating the projectile or implementing
    the animation in this chapter, but you will set up the key bindings and the C++
    implementation for use in the next chapter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本游戏包含的一个功能是玩家能够向敌人投掷投射物。你不会在本章中创建投射物或实现动画，但你将设置键绑定和 C++ 实现，以便在下一章中使用。
- en: In this activity, you need to set up the Enhanced Input Mapping for the `Throw`
    projectile functionality and implement a debug log in C++ for when the player
    presses the key(s) mapped to `Throw`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你需要设置 `Throw` 投射物功能的高级输入映射，并在 C++ 中实现当玩家按下映射到 `Throw` 的键时的调试日志。
- en: 'Follow these steps to complete this activity:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Create a new folder inside of the `Throw`, and create a new `IA_Throw`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Throw` 文件夹内创建一个新的文件夹，并创建一个新的 `IA_Throw`。
- en: Use the `Trigger` type called `Pressed` inside `IA_Throw`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IA_Throw` 中使用 `Trigger` 类型的 `Pressed`。
- en: Add the new `IA_Throw` `IC_SideScrollerCharacter` with bindings to both `Left
    Mouse Button` and `Gamepad Right Trigger`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的 `IA_Throw` `IC_SideScrollerCharacter`，并将其绑定到 `Left Mouse Button` 和 `Gamepad
    Right Trigger`。
- en: Within Visual Studio, add a new `UInputAction` variable called `IA_Throw` and
    add the appropriate `UPROPERTY()` macro to the variable.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，添加一个新的 `UInputAction` 变量，命名为 `IA_Throw`，并将适当的 `UPROPERTY()`
    宏添加到该变量。
- en: Add a new function to the header file of `SuperSideScroller_Player`. Name this
    function `ThrowProjectile()`. This will be a void function without parameters.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SuperSideScroller_Player` 的头文件中添加一个新的函数。将此函数命名为 `ThrowProjectile()`。这将是一个无参数的
    void 函数。
- en: Create the definition in the source file of the `SuperSideScroller_Player` class.
    In the definition of this function, use `UE_LOG` to print a message that lets
    you know that the function is being called successfully.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SuperSideScroller_Player` 类的源文件中创建定义。在这个函数的定义中，使用 `UE_LOG` 打印一条消息，让你知道该函数正在成功调用。
- en: Add a new `BindAction` function call using the `EnhancedPlayerInput` variable
    to bind the new `Throw` `ThrowProjectile()` function.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `EnhancedPlayerInput` 变量添加一个新的 `BindAction` 函数调用，用于绑定新的 `Throw` `ThrowProjectile()`
    函数。
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about `UE_LOG` here: [https://nerivec.github.io/old-ue4-wiki/pages/logs-printing-messages-to-yourself-during-runtime.xhtml](https://nerivec.github.io/old-ue4-wiki/pages/logs-printing-messages-to-yourself-during-runtime.xhtml).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 `UE_LOG` 的信息：[https://nerivec.github.io/old-ue4-wiki/pages/logs-printing-messages-to-yourself-during-runtime.xhtml](https://nerivec.github.io/old-ue4-wiki/pages/logs-printing-messages-to-yourself-during-runtime.xhtml).
- en: Compile the code and return to the editor. Next, add `IA_Throw` to the `BP_SuperSideScroller_MainCharacter`
    parameter, `IA_Throw`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并返回到编辑器。接下来，将 `IA_Throw` 添加到 `BP_SuperSideScroller_MainCharacter` 参数 `IA_Throw`。
- en: The expected result is that when you use the *left mouse button* or the *gamepad
    right trigger*, a log will appear in `Output Log`, letting you know that the `ThrowProjectile`
    function is being called successfully. You will use this function later to spawn
    your projectile.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是，当你使用 *左鼠标按钮* 或 *游戏手柄右扳机* 时，`Output Log` 中将出现一条日志，告诉你 `ThrowProjectile`
    函数正在成功调用。你将使用此函数在后续章节中生成你的投射物。
- en: 'The expected output is as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 11.36 – The expected output log ](img/Figure_11.36_B18531.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.36 – 预期输出日志](img/Figure_11.36_B18531.jpg)'
- en: Figure 11.36 – The expected output log
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.36 – 预期输出日志
- en: Note
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
- en: With this activity complete, you now have functionality in place for when you
    create the player projectile in [*Chapter 13*](B18531_13.xhtml#_idTextAnchor268),
    *Creating and Adding the Enemy Artificial Intelligence*. You also have the knowledge
    and experience of adding new key mappings to your game and implementing functionality
    in C++ that utilizes these mappings to enable gameplay functionality. Now, you
    will continue updating the player character’s movement to allow the jumping animation
    to play correctly when the player jumps. But first, let’s take a moment to learn
    about Animation State Machines.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这项活动后，你现在已经有了在 [*第 13 章*](B18531_13.xhtml#_idTextAnchor268) *创建和添加敌人人工智能*
    中创建玩家投射物的功能。你还掌握了添加新键映射到你的游戏以及实现利用这些映射的 C++ 功能来启用游戏玩法功能的知识和经验。现在，你将继续更新玩家角色的移动，以便在玩家跳跃时正确播放跳跃动画。但首先，让我们花点时间来了解动画状态机。
- en: Using Animation State Machines
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画状态机
- en: 'State Machines are a means of categorizing an animation, or sets of animations,
    into a state. A state can be thought of as a condition that the player character
    is in at a specific time. Is the player currently walking? Is the player jumping?
    In many third-person games such as *The Last of Us*, this involves separating
    the movement, jumping, crouching, and climbing animations into their own states.
    Each state is then accessible when certain conditions are met while the game is
    played. Conditions can include whether the player is jumping, the speed of the
    player character, and whether or not the player is in the crouched state. The
    job of the state machine is to transition between each state using logical decisions
    called `ThirdPerson_AnimBP` Animation Blueprint:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是一种将动画或动画集分类到状态中的方法。一个状态可以被视为玩家角色在特定时间所处的条件。玩家当前是在行走吗？玩家是在跳跃吗？在许多第三人称游戏，如
    *The Last of Us* 中，这涉及到将移动、跳跃、蹲下和攀爬动画分别归入它们自己的状态。每个状态在游戏进行时满足某些条件时都是可访问的。条件可以包括玩家是否在跳跃、玩家角色的速度以及玩家是否处于蹲下状态。状态机的任务是使用称为
    `ThirdPerson_AnimBP` 的动画蓝图中的逻辑决策在各个状态之间进行转换：
- en: Note
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A general overview of State Machines can be found here: [https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.xhtml).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 关于状态机的概述可以在这里找到：[https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.xhtml)。
- en: '![Figure 11.37 – The state machine of ThirdPerson_AnimBP ](img/Figure_11.37_B18531.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.37 – ThirdPerson_AnimBP 的状态机](img/Figure_11.37_B18531.jpg)'
- en: Figure 11.37 – The state machine of ThirdPerson_AnimBP
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.37 – ThirdPerson_AnimBP 的状态机
- en: In the case of the state machine for the player character, this state machine
    will handle the states of the default player’s movement and jumping. Currently,
    you have the player character animating simply by using a Blend Space that is
    controlled by the speed of the character. In the next exercise, you will create
    a new state machine and move the movement Blend Space logic into its own state
    within that state machine. Let’s start creating the new state machine.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家角色的状态机，这个状态机将处理默认玩家移动和跳跃的状态。目前，你通过使用由角色速度控制的混合空间来简单地动画化玩家角色。在下一个练习中，你将创建一个新的状态机，并将移动混合空间逻辑移动到该状态机中的自己的状态。让我们开始创建新的状态机。
- en: Exercise 11.07 – player character movement and jump state machine
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.07 – 玩家角色移动和跳跃状态机
- en: In this exercise, you will implement a new animation state machine and integrate
    the existing movement Blend Space into the state machine. Additionally, you will
    set up the states for when the player jump starts, and for when the player is
    in the air during that jump.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将实现一个新的动画状态机，并将现有的移动混合空间集成到状态机中。此外，你将设置玩家开始跳跃和跳跃过程中在空中的状态。
- en: 'Let’s start by adding this new state machine:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加这个新的状态机：
- en: Navigate to the `/MainCharacter/Blueprints/` directory and open the `AnimBP_SuperSideScroller_MainCharacter`
    Animation Blueprint.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/MainCharacter/Blueprints/` 目录并打开 `AnimBP_SuperSideScroller_MainCharacter`
    动画蓝图。
- en: In `state machine` inside the context-sensitive search to find the `Add New
    State Machine` option. Name this new state machine `Movement`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上下文相关搜索中的 `state machine` 内部查找 `添加新状态机` 选项。将这个新的状态机命名为 `Movement`。
- en: 'Now, instead of plugging the output pose of the `SideScroller_IdleRun` Blend
    Space, we can connect the output pose of the new state machine, `Movement`, to
    the output pose of the animation:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不再将 `SideScroller_IdleRun` Blend Space 的输出姿态连接起来，而是可以将新状态机 `Movement` 的输出姿态连接到动画的输出姿态：
- en: '![Figure 11.38 – The new Movement state machine replaces the old Blend Space
    ](img/Figure_11.38_B18531.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.38 – 新的 Movement 状态机取代了旧的 Blend Space](img/Figure_11.38_B18531.jpg)'
- en: Figure 11.38 – The new Movement state machine replaces the old Blend Space
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.38 – 新的 Movement 状态机取代了旧的 Blend Space
- en: 'Connecting an empty state machine to the `Output Pose` property of the Animation
    Blueprint will result in the warnings shown in the following screenshot. All this
    means is that nothing is happening within that state machine and that the result
    will be invalid to `Output Pose`. Don’t worry; you will fix this next:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 将空状态机连接到动画蓝图的 `Output Pose` 属性将导致以下截图所示的警告。这仅仅意味着在该状态机内部没有发生任何事情，并且结果将无效于 `Output
    Pose`。不要担心；您将在下一步修复这个问题：
- en: '![Figure 11.39 – The empty state machine results in compile warnings ](img/Figure_11.39_B18531.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.39 – 空状态机会导致编译警告](img/Figure_11.39_B18531.jpg)'
- en: Figure 11.39 – The empty state machine results in compile warnings
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.39 – 空状态机会导致编译警告
- en: Double left-click on the `Movement` state machine to open the state machine
    itself.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 双击左键点击 `Movement` 状态机以打开状态机本身。
- en: You will start by adding a new state that will handle what the character was
    doing previously; that is `Idle`, `Walking`, or `Running`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先添加一个新的状态来处理角色之前所做的事情；即 `Idle`、`Walking` 或 `Running`。
- en: 'From the `Entry` point, left-click and drag out to open the context-sensitive
    search. You will notice that there are only two options – `Add Conduit` and `Add
    State`. For now, you will add a new state and name this state `Movement`. The
    following screenshot shows how the `Movement` state was created:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Entry` 点开始，左键点击并拖动以打开上下文相关搜索。您会注意到只有两个选项 – `Add Conduit` 和 `Add State`。目前，您将添加一个新的状态并将此状态命名为
    `Movement`。以下截图显示了如何创建 `Movement` 状态：
- en: '![Figure 11.40 – Inside the state machine, you need to add a new state ](img/Figure_11.40_B18531.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.40 – 在状态机内部，您需要添加一个新的状态](img/Figure_11.40_B18531.jpg)'
- en: Figure 11.40 – Inside the state machine, you need to add a new state
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.40 – 在状态机内部，您需要添加一个新的状态
- en: After selecting `Add` `State`, you can rename the state to `Movement` and it
    should automatically connect to the `Entry` node of the State Machine.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 `Add` `State` 后，您可以重命名状态为 `Movement`，并且它应该自动连接到状态机的 `Entry` 节点。
- en: '![Figure 11.41 – The new Movement state ](img/Figure_11.41_B18531.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.41 – 新的 Movement 状态](img/Figure_11.41_B18531.jpg)'
- en: Figure 11.41 – The new Movement state
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.41 – 新的 Movement 状态
- en: 'Copy and paste the logic you had where you connected the `Speed` variable to
    the `SideScroller_IdleRun` Blend Space into the new `Movement` state you created
    in the previous step. Connect it to the `Result` pin of the `Output Animation
    Pose` node of this state:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您之前连接 `Speed` 变量到 `SideScroller_IdleRun` Blend Space 的逻辑复制并粘贴到之前步骤中创建的新的 `Movement`
    状态中。将其连接到本状态 `Output Animation Pose` 节点的 `Result` 插针：
- en: '![Figure 11.42 – Connecting the output pose of the Blend Space to the output
    pose of this state ](img/Figure_11.42_B18531.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.42 – 将 Blend Space 的输出姿态连接到本状态的输出姿态](img/Figure_11.42_B18531.jpg)'
- en: Figure 11.42 – Connecting the output pose of the Blend Space to the output pose
    of this state
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.42 – 将 Blend Space 的输出姿态连接到本状态的输出姿态
- en: Now, if you recompile the Animation Blueprint, you will notice that the warnings
    you saw earlier are now gone. This is because you added a new state that outputs
    an animation to `Output Animation Pose` instead of having an empty state machine.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您重新编译动画蓝图，您会注意到之前看到的警告现在已经消失了。这是因为您添加了一个新的状态，该状态输出动画到 `Output Animation
    Pose` 而不是有一个空的状态机。
- en: By completing this exercise, you have constructed your very first state machine.
    Although it is a very simple one, you are now telling the character to enter and
    use the `Movement` state by default. Now, if you use `PIE`, you will see that
    the player character is moving around like they were earlier before you made the
    state machine. This means that your state machine is functioning and that you
    can continue to the next step, which will be adding the initial states that are
    required for jumping. Let’s start by creating the `JumpStart` state.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经构建了你自己的第一个状态机。虽然它非常简单，你现在正在告诉角色默认进入并使用`Movement`状态。现在，如果你使用`PIE`，你会看到玩家角色像你之前在创建状态机之前那样四处移动。这意味着你的状态机正在运行，你可以继续到下一步，这将包括添加跳跃所需的初始状态。让我们先创建`JumpStart`状态。
- en: Transition rules
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡规则
- en: 'Conduits are a way of telling each state the conditions under which it can
    transition from one state to another. In this case, a Transition Rule is created
    as a connection between the `Movement` and `JumpStart` states. This is indicated
    by the directional arrow of the connection between the states again. The tooltip
    mentions the term Transition Rule, which means that you need to define how the
    transition between these states will happen, using a Boolean value to do so:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 导管是一种告诉每个状态它可以在什么条件下从一个状态过渡到另一个状态的方式。在这种情况下，创建了一个过渡规则，作为`Movement`和`JumpStart`状态之间的连接。这再次由状态之间的连接方向箭头表示。工具提示中提到了过渡规则这个术语，这意味着你需要定义这些状态之间的过渡将如何发生，使用布尔值来完成：
- en: '![Figure 11.43 – There needs to be a Transition Rule to go from Movement to
    the start of JumpStart ](img/Figure_11.43_B18531.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图11.43 – 从Movement到JumpStart开始需要过渡规则](img/Figure_11.43_B18531.jpg)'
- en: Figure 11.43 – There needs to be a Transition Rule to go from Movement to the
    start of JumpStart
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.43 – 从Movement到JumpStart开始需要过渡规则
- en: 'The main difference between a simple Transition Rule and a conduit is that
    a Transition Rule can only connect between two states, whereas a conduit can serve
    as a means to transition between one and many other states. For more information,
    please refer to the following documentation: [https://docs.unrealengine.com/5.0/en-US/state-machines-in-unreal-engine/#conduits](https://docs.unrealengine.com/5.0/en-US/state-machines-in-unreal-engine/#conduits).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 简单过渡规则和导管之间的主要区别是，过渡规则只能连接两个状态，而导管可以作为在单一状态和许多其他状态之间过渡的手段。有关更多信息，请参阅以下文档：[https://docs.unrealengine.com/5.0/en-US/state-machines-in-unreal-engine/#conduits](https://docs.unrealengine.com/5.0/en-US/state-machines-in-unreal-engine/#conduits)。
- en: In the next exercise, you will be adding this new `JumpStart` state and adding
    the proper Transition Rule necessary for the character to go from the `Movement`
    state to the `JumpStart` state.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将添加这个新的`JumpStart`状态，并添加必要的过渡规则，以便角色可以从`Movement`状态过渡到`JumpStart`状态。
- en: Exercise 11.08 – adding states and transition rules to the state machine
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.08 – 向状态机添加状态和过渡规则
- en: In the case of transitioning from the player character’s default movement Blend
    Space to the beginning of the jump animation, you will need to know when the player
    decides to jump. This can be done using a useful function called `IsFalling` from
    the `Character Movement` component of the player character. You will want to track
    whether the player is currently falling to transition in and out of jumping. The
    best way to do this is to store the result of the `IsFalling` function in its
    own variable, just like you did when tracking the player’s speed.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在从玩家角色的默认移动 Blend Space 过渡到跳跃动画开始时，你需要知道玩家何时决定跳跃。这可以通过使用玩家角色“角色移动”组件中的一个有用函数`IsFalling`来实现。你将想要跟踪玩家是否正在下落，以便在跳跃的进入和退出之间进行过渡。最好的方法是将`IsFalling`函数的结果存储在其自己的变量中，就像你跟踪玩家速度时做的那样。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Back in the overview of the state machine itself, left-click and drag from the
    edge of the `Movement` state to open the context-sensitive menu.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在状态机的概述中，左键单击并从`Movement`状态的边缘拖动以打开上下文相关菜单。
- en: 'Select the `JumpStart`. When you do this, Unreal Engine will automatically
    connect these states and implement an empty Transition Rule for you:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`JumpStart`。当你这样做时，Unreal Engine会自动连接这些状态，并为你实现一个空的过渡规则：
- en: '![Figure 11.44 – The Transition Rule that Unreal automatically creates for
    you when connecting two states ](img/Figure_11.44_B18531.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图11.44 – 当连接两个状态时，Unreal自动为你创建的转换规则](img/Figure_11.44_B18531.jpg)'
- en: Figure 11.44 – The Transition Rule that Unreal automatically creates for you
    when connecting two states
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.44 – 当连接两个状态时，Unreal自动为你创建的转换规则
- en: 'Navigate back to `Speed` value of the player character:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到玩家角色的`Speed`值：
- en: '![Figure 11.45 – We are now storing the Vector Length of the Main Character
    as Speed ](img/Figure_11.45_B18531.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图11.45 – 我们现在将主角色的向量长度存储为速度](img/Figure_11.45_B18531.jpg)'
- en: Figure 11.45 – We are now storing the Vector Length of the Main Character as
    Speed
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.45 – 我们现在将主角色的向量长度存储为速度
- en: 'Create a getter variable for `MainCharacter` and access the `Character Movement`
    component. From the `Character Movement` component, left-click and drag to access
    the context-sensitive menu. Search for `IsFalling`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`MainCharacter`创建一个getter变量，并访问`Character Movement`组件。从`Character Movement`组件中，左键单击并拖动以访问上下文相关菜单。搜索`IsFalling`：
- en: '![Figure 11.46 – How to find the IsFalling function ](img/Figure_11.46_B18531.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图11.46 – 如何找到IsFalling函数](img/Figure_11.46_B18531.jpg)'
- en: Figure 11.46 – How to find the IsFalling function
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.46 – 如何找到IsFalling函数
- en: 'The character movement component can tell you whether the player character
    is currently in the air with the help of the `IsFalling` function:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`IsFalling`函数的帮助，角色运动组件可以告诉你玩家角色当前是否在空中：
- en: '![Figure 11.47 – The Character Movement component showing the state of the
    player character ](img/Figure_11.47_B18531.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图11.47 – 显示玩家角色状态的Character Movement组件](img/Figure_11.47_B18531.jpg)'
- en: Figure 11.47 – The Character Movement component showing the state of the player
    character
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.47 – 显示玩家角色状态的Character Movement组件
- en: 'From the `Return Value` Boolean of the `IsFalling` function, left-click and
    drag to search for the `bIsInAir`. When promoting to a variable, the `Return Value`
    output pin should automatically connect to the input pin of the newly promoted
    variable. If it doesn’t, remember to connect them:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`IsFalling`函数的`Return Value`布尔值，左键单击并拖动以搜索`bIsInAir`。在提升为变量时，`Return Value`输出引脚应自动连接到新提升变量的输入引脚。如果不自动连接，请记住将它们连接起来：
- en: '![Figure 11.48 – A new variable, bIsInAir, that contains the value of the IsFalling
    function ](img/Figure_11.48_B18531.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图11.48 – 包含IsFalling函数值的新的变量bIsInAir](img/Figure_11.48_B18531.jpg)'
- en: Figure 11.48 – A new variable, bIsInAir, that contains the value of the IsFalling
    function
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.48 – 包含IsFalling函数值的新的变量bIsInAir
- en: Now that you are storing the state of the player and whether or not they are
    falling, this is the perfect candidate for the Transition Rule between the `Movement`
    and `JumpStart` states.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你存储了玩家的状态以及他们是否在空中，这是在`Movement`和`JumpStart`状态之间作为转换规则的完美候选。
- en: 'In the `Movement State` machine, double left-click on `Transition Rule` to
    enter its graph. You will find only one output node, `Result`, with the `Can Enter
    Transition` parameter. All you need to do here is use the `bIsInAir` variable
    and connect it to that output. Now, `Transition Rule` is saying that if the player
    is in the air, the transition between the `Movement` state and the `JumpStart`
    states can happen:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Movement State`机器中，双击左键点击`Transition Rule`以进入其图。你将找到一个只有一个输出节点，即`Result`，带有`Can
    Enter Transition`参数。在这里你所需要做的就是使用`bIsInAir`变量并将其连接到那个输出。现在，`Transition Rule`表示如果玩家在空中，则`Movement`状态和`JumpStart`状态之间的转换可以发生：
- en: '![Figure 11.49 – When in the air, the player will transition to the start of
    the jumping animation ](img/Figure_11.49_B18531.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图11.49 – 当玩家在空中时，将过渡到跳跃动画的开始](img/Figure_11.49_B18531.jpg)'
- en: Figure 11.49 – When in the air, the player will transition to the start of the
    jumping animation
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.49 – 当玩家在空中时，将过渡到跳跃动画的开始
- en: With your `Transition Rule` in place between the `Movement` and `JumpStart`
    states, all you must do is tell the `JumpStart` state which animation to use.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Movement`和`JumpStart`状态之间设置了你的`Transition Rule`之后，你所需要做的就是告诉`JumpStart`状态使用哪个动画。
- en: 'From the state machine graph, double left-click on the `JumpStart` state to
    enter its graph. From the `JumpingStart` animation to the graph:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态机图中，双击左键点击`JumpStart`状态以进入其图。从`JumpingStart`动画到图：
- en: '![Figure 11.50 – Ensure you have the JumpingStart animation selected in Asset
    Browser ](img/Figure_11.50_B18531.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图11.50 – 确保你在资源浏览器中选择了JumpingStart动画](img/Figure_11.50_B18531.jpg)'
- en: Figure 11.50 – Ensure you have the JumpingStart animation selected in Asset
    Browser
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.50 – 确保在资源浏览器中已选择JumpingStart动画
- en: 'Connect the output of the `Play JumpingStart` node to the `Result` pin of the
    `Output Animation Pose` node:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Play JumpingStart`节点的输出连接到`Output Animation Pose`节点的`Result`引脚：
- en: '![Figure 11.51 – Connecting the JumpingStart animation to Output Animation
    Pose of the JumpStart state ](img/Figure_11.51_B18531.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.51 – 将JumpingStart动画连接到JumpStart状态的Output Animation Pose](img/Figure_11.51_B18531.jpg)'
- en: Figure 11.51 – Connecting the JumpingStart animation to Output Animation Pose
    of the JumpStart state
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.51 – 将JumpingStart动画连接到JumpStart状态的Output Animation Pose
- en: Before you can move forward with the next state, some settings need to be changed
    on the `JumpingStart` animation node.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以继续下一个状态之前，需要在`JumpingStart`动画节点上更改一些设置。
- en: Left-click on the `Play JumpingStart` animation node and update the `Loop Animation
    = False`
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Play JumpingStart`动画节点上左键单击并更新`Loop Animation = False`
- en: '`Play Rate = 2.0`'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Play Rate = 2.0`'
- en: 'The following screenshot shows the final settings for the `Play JumpingStart`
    animation node:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Play JumpingStart`动画节点的最终设置：
- en: '![Figure 11.52 – Increasing the play rate will result in a smoother jumping
    animation overall ](img/Figure_11.52_B18531.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.52 – 提高播放速率将使整体跳跃动画更加平滑](img/Figure_11.52_B18531.jpg)'
- en: Figure 11.52 – Increasing the play rate will result in a smoother jumping animation
    overall
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.52 – 提高播放速率将使整体跳跃动画更加平滑
- en: Here, you are setting the `Loop Animation` parameter to `False` because there
    is no reason that this animation should loop; it should only play once in any
    case. The only way that this animation would loop is if the player character is
    somehow stuck in this state, but this will never happen because of the next state
    you will create. The reason for setting `Play Rate` to `2.0` is because the animation
    itself, `JumpingStart`, is too long for the game you are making. The animation
    has the character bend their knees drastically, and jump upward for more than
    a second. For the `JumpStart` state, you want the character to play this animation
    quicker so that it is more fluid and offers a smoother transition to the next
    state; that is, `JumpLoop`. To give additional context to the `Play Rate` parameter
    that’s available in an animation, there is both `Play Rate` and `Play Rate Basis`.
    The `Play Rate Basis` parameter allows you to change where the `Play Rate` parameter
    is expressed; so, by default, this is set to 1.0\. If you wanted to, you could
    change this value to 10.0, meaning that the `Play Rate` input will be divided
    by 10\. So, depending on `Play Rate Basis`, the value that’s used in `Play Rate`
    can lead to different results; for simplicity, we will keep `Play Rate Basis`
    at its default value of 1.0.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将`Loop Animation`参数设置为`False`，因为没有理由让这个动画循环；在任何情况下它都只应该播放一次。唯一能让这个动画循环的方式是玩家角色以某种方式卡在这个状态，但这种情况永远不会发生，因为您将创建下一个状态。将`Play
    Rate`设置为`2.0`的原因是，动画本身`JumpingStart`对于您正在制作的游戏来说太长了。这个动画让角色大幅度弯曲膝盖，向上跳跃超过一秒。对于`JumpStart`状态，您希望角色更快地播放这个动画，使其更加流畅，并提供更平滑的过渡到下一个状态；即`JumpLoop`。为了给动画中可用的`Play
    Rate`参数提供额外的上下文，存在`Play Rate`和`Play Rate Basis`两个参数。`Play Rate Basis`参数允许您更改`Play
    Rate`参数的表达方式；因此，默认情况下，这个值设置为1.0。如果您想改变这个值到10.0，这意味着`Play Rate`输入将被除以10。所以，根据`Play
    Rate Basis`的不同，`Play Rate`中使用的值可以导致不同的结果；为了简化，我们将保持`Play Rate Basis`的默认值1.0。
- en: Once the player character has begun the `JumpStart` animation, there is a point
    in time during that animation where the player is in the air and should transition
    to a new state. This new state will loop until the player is no longer in the
    air and can transition into the final state of ending the jump. Next, we will
    create a new state that will transition from the `JumpStart` state.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家角色开始`JumpStart`动画，在动画过程中有一个时刻玩家处于空中，应该过渡到新状态。这个新状态将循环，直到玩家不再在空中，可以过渡到跳跃结束的最终状态。接下来，我们将创建一个新的状态，将从`JumpStart`状态过渡。
- en: 'From the state machine graph, *left-click* and drag from the `JumpStart` state
    and select the `Add State` option. Name this new state `JumpLoop`. Again, Unreal
    Engine will automatically provide you with a `Transition Rule` between these states
    that you will add to in the next exercise. Finally, recompile the Animation Blueprint
    and ignore any warnings that may appear under **Compiler Results**:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态机图中，*左键点击*并从“JumpStart”状态拖动，选择“添加状态”选项。将这个新状态命名为“JumpLoop”。同样，虚幻引擎将自动为你提供这些状态之间的“过渡规则”，你将在下一个练习中添加。最后，重新编译动画蓝图，并忽略在**编译结果**下可能出现的任何警告：
- en: '![Figure 11.53 – A new state to handle the animation of the character while
    they’re in the air  ](img/Figure_11.53_B18531.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图11.53 – 处理角色空中动画的新状态](img/Figure_11.53_B18531.jpg)'
- en: Figure 11.53 – A new state to handle the animation of the character while they’re
    in the air
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.53 – 处理角色空中动画的新状态
- en: By completing this exercise, you have added and connected states for `JumpStart`
    and `JumpLoop`. Each of these states is connected via a `Transition Rule`. You
    should now have a better understanding of how states within a state machine transition
    from one to another via the rules established in each Transition Rule.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经为“JumpStart”和“JumpLoop”添加并连接了状态。这些状态中的每一个都通过“过渡规则”连接。你现在应该更好地理解了状态机中的状态是如何通过每个过渡规则中建立的规则从一个状态过渡到另一个状态的。
- en: In the next exercise, you will learn how to transition from the `JumpStart`
    state to the `JumpLoop` state via the `Time Remaining Ratio` function.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将学习如何通过“剩余时间比例”函数从“JumpStart”状态过渡到“JumpLoop”状态。
- en: Exercise 11.09 – The Time Remaining Ratio function
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.09 – 剩余时间比例函数
- en: For the `JumpStart` state to smoothly transition to the `JumpLoop` state, you
    need to take a moment to think about exactly how you want this transition to work.
    Based on how the `JumpStart` and `JumpLoop` animations work, it is best to transition
    to the `JumpLoop` animation after a specified set of time has elapsed on the `JumpStart`
    animation. That way, the `JumpLoop` state plays smoothly after `X` seconds of
    the `JumpStart` animation playing.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使“JumpStart”状态能够平滑地过渡到“JumpLoop”状态，你需要花点时间思考这个过渡应该如何进行。根据“JumpStart”和“JumpLoop”动画的工作方式，最好在“JumpStart”动画上经过指定的时间后过渡到“JumpLoop”动画。这样，在“JumpStart”动画播放了X秒之后，“JumpLoop”状态可以平滑播放。
- en: 'Perform the following steps to achieve this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作：
- en: Double left-click on the `Transition Rule` property between `JumpStart` and
    `JumpLoop` to open its graph. This `Transition Rule` will check how much time
    is remaining from the `JumpingStart` animation. This is done because a certain
    percentage of time remains in the `JumpingStart` animation, and you can safely
    assume that the player is in the air and is ready to transition to the `JumpingLoop`
    animation state.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“JumpStart”和“JumpLoop”之间的“过渡规则”属性以打开其图。这个“过渡规则”将检查“JumpingStart”动画中剩余多少时间。这样做是因为“JumpingStart”动画中剩余一定比例的时间，你可以安全地假设玩家正在空中，并准备过渡到“JumpingLoop”动画状态。
- en: To do this, make sure that the `JumpingStart` animation is selected in the `Event
    Graph` of `Transition Rule` and find the `Time Remaining Ratio` function.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成这个操作，请确保在“过渡规则”的“事件图”中选择了“JumpingStart”动画，并找到“剩余时间比例”函数。
- en: Let’s take a moment to talk about the `Time Remaining Ratio` function and what
    it is doing. This function returns a float between `0.0f` and `1.0f` that tells
    you how much time is remaining in the specified animation. The values `0.0f` and
    `1.0f` can directly be translated into a percentage value so that they are easier
    to consider. In the case of the `JumpingStart` animation, you want to know whether
    less than 60% of the animation is remaining to transition successfully to the
    `JumpingLoop` state. This is what you will do now.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来谈谈“剩余时间比例”函数以及它的作用。此函数返回一个介于`0.0f`和`1.0f`之间的浮点数，告诉你指定动画中剩余多少时间。`0.0f`和`1.0f`的值可以直接转换为百分比值，这样更容易考虑。在“JumpingStart”动画的情况下，你想要知道动画剩余时间是否少于60%，以便成功过渡到“JumpingLoop”状态。这就是你现在要做的。
- en: 'From the `Return Value` float output parameter of the `Time Remaining Ratio`
    function, search for the `Less Than comparative operative` node from the context-sensitive
    search menu. Since you are working with a returned value between `0.0f` and `1.0f`
    to find out whether less than 60% of the animation remains, you need to compare
    this returned value with a value of `0.6f`. The final result is as follows:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Time Remaining Ratio`函数的`Return Value`浮点输出参数中，在上下文相关搜索菜单中搜索`Less Than comparative
    operative`节点。由于您正在使用返回值在`0.0f`和`1.0f`之间来找出动画是否剩余少于60%，您需要将这个返回值与`0.6f`的值进行比较。最终结果如下：
- en: '![Figure 11.54 – The new Transition Rule between the JumpingStart and JumpingLoop
    states ](img/Figure_11.54_B18531.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图11.54 – 跳跃开始和跳跃循环状态之间的新过渡规则](img/Figure_11.54_B18531.jpg)'
- en: Figure 11.54 – The new Transition Rule between the JumpingStart and JumpingLoop
    states
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.54 – 跳跃开始和跳跃循环状态之间的新过渡规则
- en: With this `Transition Rule` in place, all you need to do is add the `JumpLoop`
    animation to the `JumpLoop` state.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里设置了`Transition Rule`后，您只需要将`JumpLoop`动画添加到`JumpLoop`状态。
- en: 'In the `Movement` state machine, double left-click on the `JumpLoop` state
    to enter its graph. With the `JumpLoop` animation asset selected in the `Result`
    input of `Output Animation Pose`, as shown in the following screenshot. The default
    settings of the `Play JumpLoop` node will remain unchanged:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Movement`状态机中，双击`JumpLoop`状态进入其图。在`Output Animation Pose`的`Result`输入中选择`JumpLoop`动画资产，如下截图所示。`Play
    JumpLoop`节点的默认设置将保持不变：
- en: '![Figure 11.55 – The JumpLoop animation connected to Output Animation Pose
    of the new state ](img/Figure_11.55_B18531.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图11.55 – 连接到新状态输出动画姿态的JumpLoop动画](img/Figure_11.55_B18531.jpg)'
- en: Figure 11.55 – The JumpLoop animation connected to Output Animation Pose of
    the new state
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.55 – 连接到新状态输出动画姿态的JumpLoop动画
- en: 'With the `JumpLoop` animation in place in the `JumpLoop` state, you can compile
    the Animation Blueprint and PIE. You will notice that the movement and sprinting
    animations are still present, but what happens when you try to jump? The player
    character begins the `JumpStart` state and plays the `JumpLoop` animation while
    in the air. This is great – the state machine is working, but what happens when
    the player character reaches the ground and is no longer in the air? The player
    character does not transition back to the `Movement` state, which makes sense
    because you haven’t added the state for `JumpEnd`, nor the transitions between
    `JumpLoop` and `JumpEnd`, and from `JumpEnd` back to the `Movement` state. You
    will do this in the next activity. The following screenshot shows an example of
    a player character stuck in the `JumpLoop` state:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在`JumpLoop`状态中设置了`JumpLoop`动画后，您可以编译动画蓝图和PIE。您会注意到移动和冲刺动画仍然存在，但当你尝试跳跃时会发生什么？玩家角色开始进入`JumpStart`状态，并在空中播放`JumpLoop`动画。这很好——状态机正在工作，但当玩家角色到达地面并且不再在空中时会发生什么？玩家角色不会返回到`Movement`状态，这是有道理的，因为您还没有添加`JumpEnd`状态，也没有添加`JumpLoop`和`JumpEnd`之间的过渡，以及从`JumpEnd`返回到`Movement`状态的过渡。您将在下一个活动中完成这些。以下截图显示了玩家角色卡在`JumpLoop`状态的一个示例：
- en: '![Figure 11.56 – The player character can now play the JumpingStart and JumpLoop
    animations ](img/Figure_11.56_B18531.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图11.56 – 玩家角色现在可以播放跳跃开始和跳跃循环动画](img/Figure_11.56_B18531.jpg)'
- en: Figure 11.56 – The player character can now play the JumpingStart and JumpLoop
    animations
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.56 – 玩家角色现在可以播放跳跃开始和跳跃循环动画
- en: 'By completing this exercise, you successfully transitioned from the `JumpStart`
    state to the `JumpLoop` state by using the `Time Remaining Ratio` function. This
    function allows you to know how far along an animation has played, and with this
    information, you had the state machine transition into the `JumpLoop` state. The
    player can now successfully transition from the default `Movement` state to the
    `JumpStart` state and then to the `JumpLoop` state. However, this results in an
    interesting issue: the player is now stuck in the `JumpLoop` state because the
    state machine does not contain the transition backs to the `Movement` state. We’ll
    fix this in the next activity.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您成功使用`Time Remaining Ratio`函数从`JumpStart`状态过渡到`JumpLoop`状态。这个函数允许您知道动画播放的进度，并且有了这个信息，您让状态机过渡到`JumpLoop`状态。现在玩家可以成功从默认的`Movement`状态过渡到`JumpStart`状态，然后到`JumpLoop`状态。然而，这引发了一个有趣的问题：玩家现在卡在`JumpLoop`状态，因为状态机不包含返回到`Movement`状态的过渡。我们将在下一个活动中解决这个问题。
- en: Activity 11.04 – finishing the Movement and Jumping state machines
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.04 – 完成移动和跳跃状态机
- en: With half of the state machine completed, it’s time to add the state for when
    the jump ends, as well as the Transition Rules that allow you to transition from
    the `JumpLoop` state to this new state, and then transition from this new state
    back to the `Movement` state.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态机完成了一半时，是时候添加跳跃结束时的状态，以及允许你从 `JumpLoop` 状态转换到这个新状态，然后从这个新状态转换回 `Movement`
    状态的转换规则。
- en: 'Follow these steps to complete the `Movement` state machine:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成 `Movement` 状态机：
- en: Add a new state for `Jump End` that transitions from `JumpLoop`. Name this state
    `JumpEnd`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Jump End` 添加一个新状态，该状态从 `JumpLoop` 转换而来。将此状态命名为 `JumpEnd`。
- en: Add the `JumpEnd` animation to the new `JumpEnd` state.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `JumpEnd` 动画添加到新的 `JumpEnd` 状态。
- en: Based on the `JumpEnd` animation and how quickly we want to transition between
    the `JumpLoop`, `JumpEnd`, and `Movement` states, consider modifying the parameters
    of the animation like you did for the `JumpStart` animation. The `loop animation`
    parameter needs to be `False` and the `Play Rate` parameter needs to be set to
    `3.0`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据动画 `JumpEnd` 和我们想要在 `JumpLoop`、`JumpEnd` 和 `Movement` 状态之间快速转换的速度，考虑修改动画参数，就像你为
    `JumpStart` 动画所做的那样。`loop animation` 参数需要设置为 `False`，而 `Play Rate` 参数需要设置为 `3.0`。
- en: Add a `Transition Rule` from the `JumpLoop` state to the `JumpEnd` state based
    on the `bIsInAir` variable.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据变量 `bIsInAir`，从 `JumpLoop` 状态添加一个 `Transition Rule` 到 `JumpEnd` 状态。
- en: Add a `Transition Rule` from the `JumpEnd` state to the `Movement` state based
    on the `Time Remaining Ratio` function of the `JumpEnd` animation. (Look at the
    `JumpStart` to `JumpLoop` Transition Rule).
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据动画 `JumpEnd` 的 `Time Remaining Ratio` 函数，从 `JumpEnd` 状态添加一个 `Transition Rule`
    到 `Movement` 状态。（参考 `JumpStart` 到 `JumpLoop` 的转换规则）。
- en: By the end of this activity, you will have a fully functioning movement state
    machine that allows the player character to idle, walk, and sprint, as well as
    jump and animate correctly at the start of the jump, while in the air, and when
    landing.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个活动后，你将拥有一个完全功能性的移动状态机，允许玩家角色空闲、行走和冲刺，以及正确地开始跳跃、在空中和落地时的动画。
- en: 'The expected output is as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 11.57 – The player character can now idle, walk, sprint, and jump
    ](img/Figure_11.57_B18531.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.57 – 玩家角色现在可以空闲、行走、冲刺和跳跃](img/Figure_11.57_B18531.jpg)'
- en: Figure 11.57 – The player character can now idle, walk, sprint, and jump
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.57 – 玩家角色现在可以空闲、行走、冲刺和跳跃
- en: Note
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: By completing this activity, you have finished the `Movement` state machine
    for the player character. By adding the remaining `JumpEnd` state and `Transition
    Rules` to transition to the `JumpEnd` state from the `JumpLoop` state, and to
    transition from the `JumpEnd` state back to the `Movement` state, you have successfully
    created your first animation state machine. Now, you can run around the map and
    jump onto elevated platforms, all while animating correctly and transitioning
    between the `Movement` and jump states.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你已完成了玩家角色的 `Movement` 状态机。通过添加剩余的 `JumpEnd` 状态和转换规则，从 `JumpLoop` 状态转换到
    `JumpEnd` 状态，以及从 `JumpEnd` 状态转换回 `Movement` 状态，你已成功创建了你的第一个动画状态机。现在，你可以在地图上四处跑动并跳上高台，同时正确地动画化和在移动和跳跃状态之间转换。
- en: Summary
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With the player movement Blend Space created and the player character Animation
    Blueprint using a State Machine to transition from movement to jumping, you are
    ready to move on to the next chapter, where you will prepare the required animation
    slot and animation montage, and then update the Animation Blueprint for the throw
    animation, which will only use the upper body of the character.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建玩家移动 Blend Space 并使用状态机将动画从移动转换到跳跃的玩家角色动画蓝图之后，你就可以进入下一章了，在那里你将准备所需的动画槽和动画蒙太奇，然后更新动画蓝图以进行投掷动画，该动画将仅使用角色的上半身。
- en: From the exercises and activities in this chapter, you learned how to create
    a Blend Space 1D that allows you to smoothly blend movement-based animations such
    as idling, walking, and running using the speed of the player character to control
    the blending of animations.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的练习和活动，你学习了如何创建一个一维混合空间，它允许你使用玩家角色的速度来控制基于移动的动画（如闲置、行走和奔跑）的平滑混合。
- en: Additionally, you learned how to integrate new key bindings into the project
    settings and bind those keys in C++ to enable character gameplay mechanics such
    as sprinting and throwing.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你学习了如何将新的快捷键集成到项目设置中，并将这些键绑定到 C++ 中，以启用如冲刺和投掷等角色游戏机制。
- en: Lastly, you learned how to implement your very own animation state machine within
    the character Animation Blueprint for the player to transition between movement
    animations, to the various states of jumping, and back to movement again. With
    all of this logic in place, in the next chapter, we’ll create the assets and logic
    that allow the player character to play the throwing animation, and set up the
    base class for the enemy.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了如何在玩家的角色动画蓝图内实现自己的动画状态机，以便在移动动画、跳跃的各种状态之间以及再次回到移动状态之间进行转换。在所有这些逻辑就绪之后，在下一章中，我们将创建允许玩家角色播放投掷动画的资源和逻辑，并为敌人设置基类。
