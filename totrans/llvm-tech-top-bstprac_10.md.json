["```cpp\n$ ninja clang\n```", "```cpp\n$ clang++ -### -std=c++11 -Wall hello_world.cpp -o hello_world\n\"/path/to/clang\" \"-cc1\" \"-triple\" \"x86_64-apple-macosx11.0.0\" \"-Wdeprecated-objc-isa-usage\" \"-Werror=deprecated-objc-isa-usage\" \"-Werror=implicit-function-declaration\" \"-emit-obj\" \"-mrelax-all\" \"-disable-free\" \"-disable-llvm-verifier\" … \"-fno-strict-return\" \"-masm-verbose\" \"-munwind-tables\" \"-target-sdk-version=11.0\" … \"-resource-dir\" \"/Library/Developer/CommandLineTools/usr/lib/clang/12.0.0\" \"-isysroot\" \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk\" \"-I/usr/local/include\" \"-stdlib=libc++\" … \"-Wall\" \"-Wno-reorder-init-list\" \"-Wno-implicit-int-float-conversion\" \"-Wno-c99-designator\" … \"-std=c++11\" \"-fdeprecated-macro\" \"-fdebug-compilation-dir\" \"/Users/Rem\" \"-ferror-limit\" \"19\" \"-fmessage-length\" \"87\" \"-stack-protector\" \"1\" \"-fstack-check\" \"-mdarwin-stkchk-strong-link\" … \"-fexceptions\" … \"-fdiagnostics-show-option\" \"-fcolor-diagnostics\" \"-o\" \"/path/to/temp/hello_world-dEadBeEf.o\" \"-x\" \"c++\" \"hello_world.cpp\"…\n```", "```cpp\n$ sudo apt install openssl\n```", "```cpp\n$ clang hello_world.c -o hello_world\n```", "```cpp\n#ifndef SIMPLE_LOG_H\n#define SIMPLE_LOG_H\n#include <iostream>\n#include <string>\n#ifdef SLG_ENABLE_DEBUG\ninline void print_debug(const std::string &M) {\n  std::cout << \"[DEBUG] \" << M << std::endl;\n}\n#endif\n#ifdef SLG_ENABLE_ERROR\ninline void print_error(const std::string &M) {\n  std::cout << \"[ERROR] \" << M << std::endl;\n}\n#endif\n#ifdef SLG_ENABLE_INFO\ninline void print_info(const std::string &M) {\n  std::cout << \"[INFO] \" << M << std::endl;\n}\n#endif\n#endif\n```", "```cpp\nint main() {\n  print_info(\"Hello world!!\");\n  return 0;\n}\n```", "```cpp\n$ clang++ -fuse-simple-log test.cc -o test\n$ ./test\n[INFO] Hello world!!\n$\n```", "```cpp\n$ clang++ -fuse-simple-log -fno-use-info-simple-log test.cc -o test\ntest.cc:2:3: error: use of undeclared identifier 'print_info'\n  print_info(\"Hello World!!\");\n  ^\n1 error generated\n$\n```", "```cpp\n$ clang++ -fuse-simple-log=/home/user/advanced_log.h test.cc -o test\n[01/28/2021 20:51 PST][INFO] Hello World!!\n$\n```", "```cpp\ndef g_Flag : Flag<[\"-\"], \"g\">, Group<g_Group>,\n  HelpText<\"Generate source-level debug information\">;\n```", "```cpp\ndef std_EQ : Joined<[\"-\", \"--\"], \"std=\">, Flags<[CC1Option]>, …;\n```", "```cpp\n    def fuse_simple_log : Flag<[\"-\"], \"fuse-simple-log\">,\n                      Group<f_Group>, Flags<[NoXarchOption]>;\n    ```", "```cpp\n    defm use_error_simple_log : BooleanFFlag<\"use-error-simple-log\">, Group<f_Group>, Flags<[NoXarchOption]>;\n    ```", "```cpp\n    defm use_debug_simple_log : BooleanFFlag<\"use-debug-simple-log\">, Group<f_Group>, Flags<[NoXarchOption]>;\n    defm use_info_simple_log : BooleanFFlag<\"use-info-simple-log\">, Group<f_Group>, Flags<[NoXarchOption]>;\n    ```", "```cpp\n    def fsimple_log_path_EQ : Joined<[\"-\"], \"fsimple-log-path=\">, Group<f_Group>, Flags<[NoXarchOption]>;\n    def fuse_simple_log_EQ : Joined<[\"-\"], \"fuse-simple-log=\">, Group<f_Group>, Flags<[NoXarchOption]>;\n    ```", "```cpp\n    -include frontend flag, as its name suggests, *implicitly* includes the designated file in the compiling source code.Using the same logic, if `-fuse-simple-log=/other/file.h` or `-fuse-simple-log -fsimple-log-path=/other/file.h` are given, they will be translated into the following:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    -D flag implicitly defines a macro variable for the compiling source code.However, if only `-fuse-simple-only` is given, the flag will implicitly include all the log printing functions. In other words, `-fuse-simple-only` will not only be translated into the `-include` flag, as introduced in previous bullet point, but also the following flags:\n\n    ```", "```cpp\n    -fuse-simple-log -fno-use-error-simple-log\n    ```", "```cpp\n    -include \"simple_log.h\" -D SLG_ENABLE_DEBUG -D SLG_ENABLE_INFO\n    ```", "```cpp\n    -fuse-info-simple-log -fsimple-log-path=\"my_log.h\"\n    ```", "```cpp\n    -include \"my_log.h\" -D SLG_ENABLE_INFO\n    ```", "```cpp\n\n    ```", "```cpp\n    struct SimpleLogOpts {\n      // If a certain log level is enabled\n      bool Error = false,\n           Info = false,\n           Debug = false;\n      static inline SimpleLogOpts All() { \n        return {true, true, true};\n      }\n      // If any of the log level is enabled\n      inline operator bool() const {\n        return Error || Info || Debug;\n      }\n    };\n    // The object we are going to work on later\n    SimpleLogOpts SLG;\n    ```", "```cpp\n    if (SLG) {\n      // At least one log level is enabled!\n    }\n    ```", "```cpp\n    if (Args.hasArg(options::OPT_fuse_simple_log)) {\n      SLG = SimpleLogOpts::All();\n    }\n    ```", "```cpp\n    if (Args.hasArg(options::OPT_fuse_simple_log,\n                    options::OPT_fuse_simple_log_EQ)) {\n      SLG = SimpleLogOpts::All();\n    }\n    ```", "```cpp\n    SLG.Error = Args.hasFlag(options::OPT_fuse_error_simple_log, options::OPT_fno_use_error_simple_log, SLG.Error);\n    ```", "```cpp\n    if (SLG) {\n      CmdArgs.push_back(\"-include\");\n      …\n    }\n    ```", "```cpp\n    if (SLG) {\n      CmdArgs.push_back(\"-include\");\n      if (Arg *A = Args.getLastArg(options::OPT_fuse_simple_  log_EQ, options::OPT_fsimple_log_path_EQ))\n        CmdArgs.push_back(A->getValue());\n      else\n        CmdArgs.push_back(\"simple_log.h\");\n      …\n    }\n    ```", "```cpp\n    if (SLG) {\n      …\n      if (SLG.Error) {\n        CmdArgs.push_back(\"-D\");\n        CmdArgs.push_back(\"SLG_ENABLE_ERROR\");\n      }\n      …\n    }\n    ```", "```cpp\n$ clang++ -### -fuse-simple-log -c test.cc\n```", "```cpp\n\"-include\" \"simple_log.h\" \"-D\" \"SLG_ENABLE_ERROR\" \"-D\" \"SLG_ENABLE_INFO\" \"-D\" \"SLG_ENABLE_DEBUG\"\n```", "```cpp\n$ clang++ -### -fuse-simple-log=my_log.h -fno-use-error-simple-log -c test.cc\n```", "```cpp\n\"-include\" \"my_log.h\" \"-D\" \"SLG_ENABLE_INFO\" \"-D\" \"SLG_ENABLE_DEBUG\"\n```", "```cpp\n$ clang++ -### -fuse-info-simple-log -fsimple-log-path=my_log.h -c test.cc\n```", "```cpp\n\"-include\" \"my_log.h\" \"-D\" \"SLG_ENABLE_INFO\"\n```", "```cpp\n$ clang++ -fplugin=MyPlugin.so \\\n          -Xclang -plugin -Xclang ternary-converter \\\n          -fsyntax-only test.cc\n```", "```cpp\n# Error: `ternary-converter` will not be recognized\n$ clang++ -fplugin=MyPlugin.so \\\n          -Xclang -plugin ternary-converter \\\n          -fsyntax-only test.cc\n```", "```cpp\ndef foo : Flag<[\"-\"], \"foo\">, Flags<[NoDriverOption]>;\n```", "```cpp\n$ ls\nmain.cc simple_log.h\n$ clang++ -fuse-simple-log -fsyntax-only main.cc\n$ # OK\n```", "```cpp\n$ ls .\n# No simple_log.h in current folder\nmain.cc\n$ clang++ -fuse-simple-log=/path/to/simple_log.h -fsyntax-only main.cc\n$ # OK\n```", "```cpp\n$ ls .\n# No simple_log.h in current folder\nmain.cc\n$ ls ~/my_include\nsimple_log.h\n$ clang++ -zipline -fuse-simple-log -fsyntax-only main.cc\n$ # OK\n```", "```cpp\n$ clang -zipline -c test.c\n$ file test.o\ntest.o: ASCII text # Not (binary) object file anymore\n$ cat test.o\nCS50ZXh0CgkuZmlsZQkidGVzdC5jYyIKCS 5nbG9ibAlfWjNmb29pCgkucDJhbGln\nbgk0LCAweDkwCgkudHlwZQlfWjNmb29p LEBmdW5jdGlvbgpfWjNmb29pOgoJLmNm\n… # Base64 encoded contents\n$\n```", "```cpp\n$ clang -zipline test.c -o test.zip\n$ file test.zip\ntest.zip: Zip archive, at least v2.0 to extract\n$\n```", "```cpp\n$ clang -zipline -fuse-ld=tar test.c -o test.tar.gz\n$ file test.tar.gz\ntest.tar.gz: gzip compressed data, from Unix, original size…\n$\n```", "```cpp\n    // zipline toolchain\n    def zipline : Flag<[\"-\", \"--\"], \"zipline\">,\n                  Flags<[NoXarchOption]>; \n    ```", "```cpp\n    namespace clang {\n    namespace driver {\n    namespace toolchains {\n    struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain \n      : public Generic_ELF {\n      ZiplineToolChain(const Driver &D, const llvm::Triple    &Triple, const llvm::opt::ArgList &Args)\n        : Generic_ELF(D, Triple, Args) {}\n      ~ZiplineToolChain() override {}\n      // Disable the integrated assembler\n      bool IsIntegratedAssemblerDefault() const override\n        { return false; }\n      bool useIntegratedAs() const override { return false; }\n      void\n      AddClangSystemIncludeArgs(const llvm::opt::ArgList    &DriverArgs, llvm::opt::ArgStringList &CC1Args) \n        const override;\n    protected:\n      Tool *buildAssembler() const override;\n      Tool *buildLinker() const override;\n    };\n    } // end namespace toolchains\n    } // end namespace driver\n    } // end namespace clang\n    ```", "```cpp\n    void ZiplineToolChain::AddClangSystemIncludeArgs(\n                           const ArgList &DriverArgs,\n                           ArgStringList &CC1Args) const {\n      using namespace llvm;\n      SmallString<16> CustomIncludePath;\n      sys::fs::expand_tilde(\"~/my_include\",                         CustomIncludePath);\n      addSystemInclude(DriverArgs,\n                       CC1Args, CustomIncludePath.c_str());\n    }\n    ```", "```cpp\n    const ToolChain\n    &Driver::getToolChain(const ArgList &Args,\n                          const llvm::Triple &Target) const {\n      …\n      switch (Target.getOS()) {\n      case llvm::Triple::Linux:\n      …\n        else if (Args.hasArg(options::OPT_zipline))\n         TC = std::make_unique<toolchains::ZiplineToolChain>     (*this, Target, Args);\n      …\n        break;\n      case …\n      case …\n      }\n    }\n    ```", "```cpp\n    namespace clang {\n    namespace driver {\n    namespace tools {\n    namespace zipline {\n    struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {\n      Assembler(const ToolChain &TC)\n        : Tool(\"zipeline::toBase64\", \"toBase64\", TC) {}\n      bool hasIntegratedCPP() const override { return false; }\n      void ConstructJob(Compilation &C, const JobAction &JA,\n                        const InputInfo &Output,\n                        const InputInfoList &Inputs,\n                        const llvm::opt::ArgList &TCArgs,\n                        const char *LinkingOutput) const                     override;\n    };\n    } // end namespace zipline\n    } // end namespace tools\n    namespace toolchains {\n    struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain … {\n    …\n    };\n    } // end namespace toolchains\n    } // end namespace driver\n    } // end namespace clang\n    ```", "```cpp\n    void\n    tools::zipline::Assembler::ConstructJob(Compilation &C,\n                                const JobAction &JA,\n                                const InputInfo &Output,\n                                const InputInfoList &Inputs,\n                                const ArgList &Args,\n                                const char *LinkingOutput)                            const {\n                                ArgStringList CmdArgs;\n                                const InputInfo &II =                             Inputs[0];\n      std::string Exec =\n        Args.MakeArgString(getToolChain().     GetProgramPath(\"openssl\"));\n      // opeenssl base64 arguments\n      CmdArgs.push_back(\"base64\");\n      CmdArgs.push_back(\"-in\");\n      CmdArgs.push_back(II.getFilename());\n      CmdArgs.push_back(\"-out\");\n      CmdArgs.push_back(Output.getFilename());\n\n      C.addCommand(\n        std::make_unique<Command>(\n               JA, *this, ResponseFileSupport::None(),\n               Args.MakeArgString(Exec), CmdArgs,\n               Inputs, Output));\n    }\n    ```", "```cpp\n    $ openssl base64 -in <input file> -out <output file>\n    ```", "```cpp\n    Tool *ZiplineToolChain::buildAssembler() const {\n      return new tools::zipline::Assembler(*this);\n    }\n    ```", "```cpp\n    namespace zipline {\n    struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {\n    …\n    };\n    struct LLVM_LIBRARY_VISIBILITY Linker : public Tool {\n      Linker(const ToolChain &TC)\n        : Tool(\"zipeline::zipper\", \"zipper\", TC) {}\n      bool hasIntegratedCPP() const override { return false; }\n      bool isLinkJob() const override { return true; }\n      void ConstructJob(Compilation &C, const JobAction &JA,\n                        const InputInfo &Output,\n                        const InputInfoList &Inputs,\n                        const llvm::opt::ArgList &TCArgs,\n                        const char *LinkingOutput) const                     override;\n    private:\n      void buildZipArgs(const JobAction&, const InputInfo&,\n                        const InputInfoList&,\n                        const llvm::opt::ArgList&, \n                        llvm::opt::ArgStringList&) const;\n      void buildTarArgs(const JobAction&,\n                        const InputInfo&,                     const InputInfoList&,\n                        const llvm::opt::ArgList&, \n                        llvm::opt::ArgStringList&) const;\n    };\n    } // end namespace zipline\n    ```", "```cpp\n    void\n    tools::zipline::Linker::ConstructJob(Compilation &C,\n                            const JobAction &JA,\n                            const InputInfo &Output,\n                            const InputInfoList &Inputs,\n                            const ArgList &Args,\n                            const char *LinkingOutput) const {\n      ArgStringList CmdArgs;\n      std::string Compressor = \"zip\";\n      if (Arg *A = Args.getLastArg(options::OPT_fuse_ld_EQ))\n        Compressor = A->getValue();\n      std::string Exec = Args.MakeArgString(\n          getToolChain().GetProgramPath(Compressor.c_str()));\n      if (Compressor == \"zip\")\n        buildZipArgs(JA, Output, Inputs, Args, CmdArgs);\n      if (Compressor == \"tar\" || Compressor == \"gzip\")\n        buildTarArgs(JA, Output, Inputs, Args, CmdArgs);\n      else\n        llvm_unreachable(\"Unsupported compressor name\");\n      C.addCommand(\n        std::make_unique<Command>(\n          JA, *this, ResponseFileSupport::None(), \n          Args.MakeArgString(Exec),\n          CmdArgs, Inputs, Output));\n    }\n    ```", "```cpp\n    $ zip <output zip file> <input file 1> <input file 2>…\n    ```", "```cpp\n    void\n    tools::zipline::Linker::buildZipArgs(const JobAction &JA,\n                                 const InputInfo &Output,\n                                 const InputInfoList &Inputs,\n                                 const ArgList &Args,\n                                 ArgStringList &CmdArgs)                             const {\n      // output file\n      CmdArgs.push_back(Output.getFilename());\n      // input files\n      AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs, JA);\n    }\n    ```", "```cpp\n    $ tar -czf <output tar.gz file> <input file 1> <input file 2>…\n    ```", "```cpp\n    void\n    tools::zipline::Linker::buildTarArgs(const JobAction &JA,\n                                 const InputInfo &Output,\n                                 const InputInfoList &Inputs,\n                                 const ArgList &Args,\n                                 ArgStringList &CmdArgs)                              const {\n      // arguments and output file\n      CmdArgs.push_back(\"-czf\");\n      CmdArgs.push_back(Output.getFilename());\n      // input files\n      AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,    JA);\n    }\n    ```", "```cpp\n    Tool *ZiplineToolChain::buildLinker() const {\n      return new tools::zipline::Linker(*this);\n    }\n    ```", "```cpp\n$ clang -### -zipline -c test.c\n```", "```cpp\n$ clang -### -zipline -c test.c\n\"/path/to/clang\" \"-cc1\" …\n\"/usr/bin/openssl\" \"base64\" \"-in\" \"/tmp/test_ae4f5b.s\" \"-out\" \"test.o\"\n$\n```", "```cpp\n$ clang -### -zipline test.c -o test.zip\n\"/path/to/clang\" \"-cc1\" …\n\"/usr/bin/openssl\" \"base64\" \"-in\" \"/tmp/test_ae4f5b.s\" \"-out\" \"/tmp/test_ae4f5b.o\"\n\"/usr/bin/zip\" \"test.zip\" \"/tmp/test_ae4f5b.o\"\n$\n```"]