<html><head></head><body>
		<div class="Content" id="_idContainer015">
			<h1 id="_idParaDest-26"><em class="italics"><a id="_idTextAnchor027"/>Chapter 2</em></h1>
		</div>
		<div class="Content" id="_idContainer016">
			<h1 id="_idParaDest-27"><a id="_idTextAnchor028"/>Thesis</h1>
		</div>
		<div class="Content" id="_idContainer017">
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>Objects Are Independent Programs</h2>
			<p>The thread running through a lot of different presentations is that objects are isolated computer programs that communicate by sending and receiving messages. Often, there is an <em class="italics">and</em>, but the second clause differs greatly. Let’s ignore it and focus on that first clause.</p>
			<p>For example, in Smalltalk-80 and (most of) its descendants, objects could be described as isolated computer programs that communicate by sending and receiving messages <em class="italics">and</em> are instances of classes that are organized in a tree structure. The second part here, the part about classes, weakens the first part by reducing the scope of isolation. Why is it required that both the sender and recipient of a message are instances of a class, and that both classes are members of the same tree structure? It is not, so let’s strengthen the idea of isolated programs by removing the constraint on inheritance.</p>
			<p>An existing example of an OOP environment with this form of isolation is COM (yes, the Microsoft <strong class="bold">Component Object Model</strong>, that <strong class="bold">COM</strong>). When you receive an object, you know nothing about it but that it responds to the messages defined in the <strong class="bold">IUnknown</strong>—<a href="https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown">https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown</a> interface, which let you keep a reference to the object, relinquish that reference, or find out what other interfaces it supports. It tells you nothing about where that object came from, whether it inherited from another object, or whether it has fresh, hand-crafted, artisanal implementations of each of its methods.</p>
			<p>An inference you can make about both <strong class="inline">COM</strong> objects and <strong class="inline">Smalltalk</strong> objects is that they exist in the same process, that is, the same blob of memory and execution context, as the thing sending them the message. Maybe they internally forward their messages over some <strong class="bold">IPC</strong> (<strong class="bold">inter-process communication</strong>) or <strong class="bold">RPC</strong> (<strong class="bold">remote procedure call</strong>) mechanism, but there is at least part of the object that needs to be in your part of the computer. If it crashes that process, or accesses memory beyond its own instance variables, that impacts the other objects around it. If a <strong class="inline">Smalltalk</strong> object hogs the CPU, other objects do not get to run.</p>
			<p>So, while <strong class="inline">Smalltalk</strong> objects <em class="italics">approximate</em> the <strong class="keyword">isolated computer programs</strong> concept, the approximation is inexact. Meanwhile, on Mach, the only thing a sender knows about an object is a “port,” a number that the kernel can use to work out what object is being messaged. An object could be on a different thread, on the same thread, in a different process, or (at least in theory) on a different computer, and sending it a message works in the same way. The receiver and the sender could share all of their code, inherit from a common ancestor, or be written in different programming languages and running on CPUs that store numbers in a different way, but they can still send each other a message.</p>
			<p>Between the extreme of <strong class="inline">Smalltalk</strong> (all objects are the same sort of objects and are related to each other) and Mach there is the concept of the <strong class="inline">MetaObject</strong>—<a href="http://wiki.c2.com/?MetaObjectProtocol">http://wiki.c2.com/?MetaObjectProtocol</a>. As the objects in a software system define how the system models some problem, the metaobjects define how the software system expresses the behavior of its objects. The <strong class="inline">MetaObject</strong> protocol exposes messages that change the meaning of the <em class="italics">object model</em> inside the system.</p>
			<p>A <strong class="inline">MetaObject</strong> protocol, in other words, lets a programmer choose different rules for their programming environment for different sections of their program. Consider method lookup, for example: in Part One, we saw how any of prototypical inheritance, single inheritance and multiple inheritance, have benefits and drawbacks, and each impose different constraints on the design of an object system. Why not have all of these inheritance tools – and indeed any others, and other forms of delegation – to hand at the same time? With a <strong class="inline">MetaObject</strong> protocol, that’s possible.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor030"/>The Open-Closed Nature of Independent Objects</h2>
			<p>In his book <em class="italics">Object-Oriented Software Construction</em>, <em class="italics">Bertrand Meyer</em> introduced the Open-Closed Principle. This principle may be one of the most confusingly stated ideas in all of computing and has led to a whole sub-industry of articles and podcasts explaining how a <strong class="inline">ShapeRenderer</strong> can draw <strong class="inline">Squares</strong> and <strong class="inline">Circles</strong> (of course, I have also partaken of such, and will continue here).</p>
			<p>The Open-Closed Principle says that a module (an object, in our case) should be open to extension – it should be possible to extend its behavior for new purposes – and yet closed to modification – you should not need to change it. This design principle comes with a cost, as you need to design your objects to support extensibility along lines that are not yet known (or at least, to make it clear which lines are or are not going to be fruitful) in return for the benefit that maintainers and users of the objects know that they are going to be stable and will not introduce breakages into a system through unexpected changes.</p>
			<p>The nature of objects explored above, their treatment as completely independent programs, supports the Open-Closed Principle by keeping each object at arm’s length from the others. Their only point of contact is their messaging interface, even to their parent classes (remembering, of course, that they may not have any).</p>
			<p>Therefore, to be open and closed, an object also needs to be ignorant: it should know as little as possible about its context. It knows what to do when it receives messages, and it knows when to send messages, but should otherwise remain uninformed as to what is happening around it. An ignorant object can be used in multiple contexts – open to extensions of its use – due to the fact that it cannot distinguish these contexts. It requires no contextual changes, and thus is closed to modification.</p>
			<h3 id="_idParaDest-30"><a id="_idTextAnchor031"/>The Correctness of Independent Objects</h3>
			<p>When each object is its own separate program, then we turn the problem of “does this big system work” into two separate problems:</p>
			<ul>
				<li>Do these independent objects work?</li>
				<li>Are these independent objects communicating correctly?</li>
			</ul>
			<p>Each of these problems has been solved repeatedly in software engineering, and particularly in OOP. An object’s message interface makes a natural boundary between “this unit” and “everything else”, for the purposes of defining unit tests. Kent Beck’s Test-Driven Development approach sees developers designing objects from the message boundary inwards, by asking themselves what messages they would like to send to the object and what outcomes they would expect. This answers the question “do these independent objects work?” by considering each of the objects as a separate system under test.</p>
			<p>The London School of TDD, exemplified by the book <em class="italics">Growing Object-Oriented Software, Guided by Tests</em>, takes an extreme interpretation of the message-boundary-as-system-boundary rule, by using <strong class="bold">mock objects</strong>—<a href="http://xunitpatterns.com/Mock%20Object.html">http://xunitpatterns.com/Mock%20Object.html</a> as stand-ins for all collaborators of the object under test. <em class="italics">This</em> object (the one being tested) needs to send a message to <em class="italics">that</em> object (some collaborator), but there’s no reason to know anything about that object other than that it will respond to the message. In this way, the London School promotes the ignorance described above as supporting the <strong class="keyword">Open-Closed Principle</strong>.</p>
			<p>With the Eiffel programming language, Bertrand Meyer also addressed the question of whether each object works by allowing developers to associate a <em class="italics">contract</em> with each class. The contract is based on work Edsger Dijkstra and others had done on using mathematical induction to prove statements about programs, using the object’s message interface as the natural outer edge of the program. The contract explains what an object requires to be true before handling a given message (the preconditions), what an object will arrange to be true after executing its method (the postconditions), and the things that will always be true when the object is not executing a method (the invariants). These contracts are then run as checks whenever the objects are used, unlike unit tests which are only executed with the inputs and outputs that the test author originally thought of.</p>
			<p>Contracts have turned up in a limited way in the traditional software development approach in the form of <strong class="bold">property-based testing</strong>—<a href="http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html">http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html</a>, embodied in Haskell’s <strong class="bold">QuickCheck</strong>, Scala’s <strong class="bold">ScalaCheck</strong>, and other tools. In Eiffel, the contract is part of the system being constructed and describes how an object is to be used when combined with other objects. Property-based tests encapsulate the contract as an external verifier of the object under test by using the contract as a test oracle from which any number of automated tests can be constructed. A contract might say “if you supply a list of e-mail messages, each of which has a unique identifier, this method will return a list containing the same messages, sorted by sent date and then by identifier if the dates are equal”. A property-based test might say “for all lists of e-mail messages with unique identifiers, the result of calling this method is...”. A developer may generate a hundred or a thousand tests of that form, checking for no counter-examples as part of their release pipeline.</p>
			<p>The second part of the problem – are these independent objects communicating correctly? – can also be approached in multiple ways. It is addressed in a contract world such as Eiffel by ensuring that at each point where an object sends a message to a collaborator, the preconditions for that collaborator are satisfied. For everybody else, there are integration tests.</p>
			<p>If a unit test reports the behavior of a single object, then an integration test is trivially any test of an assembly containing more than one object. Borrowing Brad Cox’s Software ICs metaphor, a unit test tells you that a chip works, an integration test tells you that a circuit works. A special case of the integration test is the system test, which integrates all of the objects needed to solve some particular problem: it tells you that the whole board does what it ought to.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>The Design of Independent Objects</h2>
			<p>It is appropriate to digress into a discussion of design here, because the activities of testing and design are closely related. Eric Evans’s book <strong class="keyword">Domain-Driven Design</strong> discusses a form of what was previously called object-oriented analysis: finding the objects needed to solve a problem by interpreting a description of the problem. The process is straightforward. Take a description of the problem, and the <em class="italics">things</em> that do things are objects, the things they <em class="italics">do</em> are methods, and the things they <em class="italics">tell</em> or <em class="italics">ask</em> other things are messages. Evans proposes having a single “ubiquitous” language across the whole development team, so that the words used by the person who has the problem – the <strong class="bold">Goal Donor</strong>—<a href="http://wiki.c2.com/?GoalDonor">http://wiki.c2.com/?GoalDonor</a> are the same words as those used by the people building the solution. Borrowing an idea from Christopher Alexander, it is the ubiquitous language of the problem and solution domain in which one would expect to find a pattern language, as common aspects of problems become addressed in similar ways.</p>
			<p><strong class="bold">Behavior-Driven Development</strong> marries the technical process of <strong class="bold">Test-Driven Development</strong> with the design concept of the ubiquitous language by encouraging developers to collaborate with the rest of their team on defining statements of desired behavior in the ubiquitous language and using those to drive the design and implementation of the objects in the solution domain. In that way, the statement of what the Goal Donor needs is also the statement of sufficiency and correctness – that is, the description of the problem that needs solving is also the description of a working solution. This ends up looking tautological enough not to be surprising.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor033"/>Constructing Independent Objects</h2>
			<p>The theme running through this is that sufficiency is sufficient. When an object has been identified as part of the solution to a problem and contributes to that solution to the extent needed (even if for now that extent is “demonstrate that a solution is viable”), then it is ready to use. There is no <em class="italics">need</em> to situate the object in a taxonomy of inherited classes, but if that helps to solve the problem, then by all means do it. There is no <em class="italics">need</em> to show that various objects demonstrate a strict subtype relationship and can be used interchangeably, unless solving your problem requires that they be used interchangeably. There is no <em class="italics">need</em> for an object to make its data available to the rest of the program, unless the problem can be better solved (or cheaper solved, or some other desirable property) by doing so.</p>
			<p>I made quite a big deal earlier of the <strong class="keyword">Open-Closed Principle</strong>, and its suggestion that the objects we build be “open to modification.” Doesn’t that mean that anticipating the ways in which a system will change and making it possible for the objects to flex in those ways?</p>
			<p>To some extent, yes, and indeed that consideration can be valuable. If your problem is working out how much to bill snooker players for their time on the tables in your local snooker hall, then it is indeed possible that your solution will be used in the same hall on the pool tables, or in a different snooker hall. But which of those will happen first? Will either happen soon? Those are questions to work with the Goal Donor and the <strong class="bold">Gold Owner</strong>—<a href="http://wiki.c2.com/?GoldOwner">http://wiki.c2.com/?GoldOwner</a>, the person paying for the solution) on answering. Is it worth paying to solve this related problem <em class="italics">now</em>, or not?</p>
			<p>Regardless of the answer, the fact is that the objects are still ready to go to work as soon as they address <em class="italics">the problem you have now</em>. And there are other ways to address related problems anyway, which don’t require “future-proofing” the object designs to anticipate the uses to which they may be put. Perhaps your <strong class="inline">SnookerTable</strong> isn’t open to the extension of representing a pool table too, but the rest of the objects in your solution can send messages to a <strong class="inline">PoolPlayer</strong> in its stead. As the variant on the Open-Closed Principle showed, these other objects could be ignorant of the game played on the table.</p>
			<p>Some amount of planning is always helpful, whether or not the plan turns out to be. The goal at every turn should be to understand how we get to <em class="italics">what we now want</em> from <em class="italics">what we have now</em>, not to <em class="italics">already have</em> that which <em class="italics">we will probably want sometime</em>. Maybe the easiest thing to do is to start afresh: so, do that.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor034"/>Working with Independent Objects</h2>
			<p>The traditional way of writing and changing software has led to Continuous Deployment, a principle of automating the pipeline between writing source code and deploying the production artifact in a live environment, with a goal of reducing the time taken for changes to flow through the pipeline while maintaining a high level of quality.</p>
			<p>Environments such as <strong class="bold">Pharo</strong>—<a href="https://pharo.org/">https://pharo.org/</a>, <strong class="bold">SqueakJS</strong> (<a href="https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&amp;zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip]">https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&amp;zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip]</a>, or even in their limited ways <strong class="bold">Swift Playgrounds</strong>—<a href="https://www.apple.com/swift/playgrounds/">https://www.apple.com/swift/playgrounds/</a> and <strong class="bold">Project Jupyter</strong>—<a href="https://jupyter.org/">https://jupyter.org/</a> show that this pipeline <em class="italics">can</em> be zero length, and that software can be written directly in the environment it is intended for. The result of a test failure does not need to be a log file served by Jenkins that must be pored over so a fix can be hypothesized in “local dev”, it can be an opportunity to correct the program running in the live environment and continue (or, at worst, restart) the operation that failed.</p>
			<p>This liveness property is not restricted to Smalltalk-like environments or REPLs. Consider the Mach microkernel operating system; any server that is registered to the name server (or, in the case of the HURD, as a translator on the filesystem) is a “live object” that can receive messages from the rest of the system and participate in its behavior. They are also tasks that can be inspected, debugged, changed, restarted, or replaced.</p>
			<p>A server application composed of microservice<a id="_idTextAnchor035"/>s presents similar properties. The “objects” (the running instances of the services) find each other by URL: whatever service is configured to receive HTTP requests at a given route “responds” to the “messages”. Each of these services can be independently inspected, debugged, edited, or replaced.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor036"/>Conclusion to Part Two</h2>
			<p>When the additional complexity, and the attempts to appeal to traditional software delivery techniques, are removed, Object-Oriented Programming is an attempt to represent complicated problems through a network of small, independent programs that each model one (simpler) aspect of the problem. These programs can be independently written, verified, deployed, changed, and used. They should ideally be ignorant of each other as much as possible, relying only on the knowledge that they should respond to certain messages and can send other messages to other objects.</p>
		</div>
	</body></html>