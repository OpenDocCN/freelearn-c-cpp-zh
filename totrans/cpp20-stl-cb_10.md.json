["```cpp\nnamespace fs = std::filesystem;\n```", "```cpp\n    namespace fs = std::filesystem;\n    ```", "```cpp\n    template<>\n    struct std::formatter<fs::path>: std::formatter<std::string> {\n        template<typename FormatContext>\n        auto format(const fs::path& p, FormatContext& ctx) {\n            return format_to(ctx.out(), \"{}\", p.string());\n        }\n    };\n    ```", "```cpp\n    int main(const int argc, const char** argv) {\n        if(argc != 2) {\n            fs::path fn{ argv[0] };\n            cout << format(\"usage: {} <path>\\n\", \n              fn.filename());\n            return 0;\n        }\n        fs::path dir{ argv[1] };\n        if(!fs::exists(dir)) {\n            cout << format(\"path: {} does not exist\\n\", \n              dir);\n            return 1;\n        }\n        cout << format(\"path: {}\\n\", dir);\n        cout << format(\"filename: {}\\n\", dir.filename());\n        cout << format(\"cannonical: {}\\n\", \n          fs::canonical(dir));\n    }\n    ```", "```cpp\n$ ./formatter ./formatter.cpp\npath: ./formatter.cpp\nfilename: formatter.cpp\ncannonical: /home/billw/working/chap10/formatter.cpp\n```", "```cpp\nfs::path p{ \"~/include/bwprint.h\" };\ncout << format(\"{}\\n\", p);\nfor(auto& x : p) cout << format(\"[{}] \", x);\ncout << '\\n';\n```", "```cpp\n~/include/bwprint.h\n[~] [include] [bwprint.h]\n```", "```cpp\nfs::path p{ \"~/include/bwprint.h\" };\ncout << format(\"{}\\n\", p);\ncout << format(\"{}\\n\", p.stem());\ncout << format(\"{}\\n\", p.extension());\ncout << format(\"{}\\n\", p.filename());\ncout << format(\"{}\\n\", p.parent_path());\n```", "```cpp\n~/include/bwprint.h\nbwprint\n.h\nbwprint.h\n~/include\n```", "```cpp\n    namespace fs = std::filesystem;\n    template<>\n    struct std::formatter<fs::path>: std::formatter<std::string> {\n        template<typename FormatContext>\n        auto format(const fs::path& p, FormatContext& ctx) {\n            return format_to(ctx.out(), \"{}\", p.string());\n        }\n    };\n    ```", "```cpp\n    cout << format(\"current_path: {}\\n\", fs::current_path());\n    ```", "```cpp\ncurrent_path: /home/billw/chap10\n```", "```cpp\n    cout << format(\"absolute(p): {}\\n\", fs::absolute(p));\n    ```", "```cpp\nabsolute(p): /home/billw/chap10/testdir/foo.txt\n```", "```cpp\n    cout << format(\"concatenate: {}\\n\",\n        fs::path{ \"testdir\" } += \"foo.txt\");\n    ```", "```cpp\nconcatenate: testdirfoo.txt\n```", "```cpp\n    cout << format(\"append: {}\\n\",\n        fs::path{ \"testdir\" } /= \"foo.txt\");\n    ```", "```cpp\nappend: testdir/foo.txt\n```", "```cpp\n    cout << format(\"canonical: {}\\n\",\n        fs::canonical(fs::path{ \".\" } /= \"testdir\"));\n    ```", "```cpp\ncanonical: /home/billw/chap10/testdir\n```", "```cpp\n    cout << format(\"equivalent: {}\\n\", \n        fs::equivalent(\"testdir/foo.txt\", \n            \"testdir/../testdir/foo.txt\"));\n    ```", "```cpp\nequivalent: true\n```", "```cpp\n    try {\n        fs::path p{ fp };\n        cout << format(\"p: {}\\n\", p);\n        ...\n        cout << format(\"equivalent: {}\\n\", \n            fs::equivalent(\"testdir/foo.txt\", \n                \"testdir/../testdir/foo.txt\"));\n    } catch (const fs::filesystem_error& e) {\n        cout << format(\"{}\\n\", e.what());\n        cout << format(\"path1: {}\\n\", e.path1());\n        cout << format(\"path2: {}\\n\", e.path2());\n    }\n    ```", "```cpp\ncout << format(\"equivalent: {}\\n\", \n    fs::equivalent(\"testdir/foo.txt/x\", \n        \"testdir/../testdir/foo.txt/y\"));\n```", "```cpp\nfilesystem error: cannot check file equivalence: No such file or directory [testdir/foo.txt/x] [testdir/../testdir/foo.txt/y]\npath1: testdir/foo.txt/x\npath2: testdir/../testdir/foo.txt/y\n```", "```cpp\n    fs::path p{ fp };\n    std::error_code e;\n    cout << format(\"canonical: {}\\n\", \n        fs::canonical(p /= \"foo\", e));\n    cout << format(\"error: {}\\n\", e.message());\n    ```", "```cpp\ncanonical:\nerror: Not a directory\n```", "```cpp\n    p: testdir/foo.txt\n    current_path: C:\\Users\\billw\\chap10\n    absolute(p): C:\\Users\\billw\\chap10\\testdir\\foo.txt\n    concatenate: testdirfoo.txt\n    append: testdir\\foo.txt\n    canonical: C:\\Users\\billw\\chap10\\testdir\n    equivalent: true\n    ```", "```cpp\npath absolute(const path& p);\npath absolute(const path& p, std::error_code& ec);\n```", "```cpp\nbool equivalent( const path& p1, const path& p2 );\nbool equivalent( const path& p1, const path& p2,\n    std::error_code& ec );\n```", "```cpp\np1 += source; // concatenate\np1 /= source; // append\n```", "```cpp\n    namespace fs = std::filesystem;\n    template<>\n    struct std::formatter<fs::path>: std::formatter<std::string> {\n        template<typename FormatContext>\n        auto format(const fs::path& p, FormatContext& ctx) {\n            return format_to(ctx.out(), \"{}\", p.string());\n        }\n    };\n    ```", "```cpp\n    int main() {\n        constexpr const char* fn{ \".\" };\n        const fs::path fp{fn};\n        for(const auto& de : fs::directory_iterator{fp}) {\n            cout << format(\"{} \", de.path().filename());\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\nchrono Makefile include chrono.cpp working formatter testdir formatter.cpp working.cpp\n```", "```cpp\n    int main(const int argc, const char** argv) {\n        fs::path fp{ argc > 1 ? argv[1] : \".\" };\n        if(!fs::exists(fp)) {\n            const auto cmdname { \n              fs::path{argv[0]}.filename() };\n            cout << format(\"{}: {} does not exist\\n\",\n                cmdname, fp);\n            return 1;\n        }\n        if(is_directory(fp)) {\n            for(const auto& de : \n              fs::directory_iterator{fp}) {\n                cout << format(\"{} \", \n                  de.path().filename());\n            }\n        } else {\n            cout << format(\"{} \", fp.filename());\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n$ ./working\nchrono Makefile include chrono.cpp working formatter testdir formatter.cpp working.cpp\n$ ./working working.cpp\nworking.cpp\n$ ./working foo.bar\nworking: foo.bar does not exist\n```", "```cpp\nusing de = fs::directory_entry;\n```", "```cpp\nvector<de> entries{};\n```", "```cpp\nif(is_directory(fp)) {\n    for(const auto& de : fs::directory_iterator{fp}) {\n        entries.emplace_back(de);\n    }\n    std::sort(entries.begin(), entries.end());\n    for(const auto& e : entries) {\n        cout << format(\"{} \", e.path().filename());\n    }\n} else { ...\n```", "```cpp\nMakefile chrono chrono.cpp formatter formatter.cpp include testdir working working.cpp\n```", "```cpp\n    string strlower(string s) {\n        auto char_lower = [](const char& c) -> char {\n            if(c >= 'A' && c <= 'Z') return c + ('a' - 'A');\n            else return c;\n        };\n        std::transform(s.begin(), s.end(), s.begin(),\n            char_lower);\n        return s;\n    }\n    ```", "```cpp\nbool dircmp_lc(const de& lhs, const de& rhs) {\n    const auto lhstr{ lhs.path().string() };\n    const auto rhstr{ rhs.path().string() };\n    return strlower(lhstr) < strlower(rhstr);\n}\n```", "```cpp\nstd::sort(entries.begin(), entries.end(), dircmp_lc);\n```", "```cpp\nchrono chrono.cpp formatter formatter.cpp include Makefile testdir working working.cpp\n```", "```cpp\nvoid print_dir(const de& dir) {\n    using fs::perms;\n    const auto fpath{ dir.path() };\n    const auto fstat{ dir.symlink_status() };\n    const auto fperm{ fstat.permissions() };\n    const uintmax_t fsize{ \n        is_regular_file(fstat) ? file_size(fpath) : 0 };\n    const auto fn{ fpath.filename() };\n    string suffix{};\n    if(is_directory(fstat)) suffix = \"/\";\n    else if((fperm & perms::owner_exec) != perms::none) {\n        suffix = \"*\";\n    }\n    cout << format(\"{}{}\\n\", fn, suffix);\n}\n```", "```cpp\nstd::sort(entries.begin(), entries.end(), dircmp_lc);\nfor(const auto& e : entries) {\n    print_dir(e);\n}\n```", "```cpp\nchrono*\nchrono.cpp\nformatter*\nformatter.cpp\ninclude*\nMakefile\ntestdir/\nworking*\nworking.cpp\n```", "```cpp\n    string suffix{};\n    if(is_symlink(fstat)) {\n        suffix = \" -> \";\n        suffix += fs::read_symlink(fpath).string();\n    }\n    else if(is_directory(fstat)) suffix = \"/\";\n    else if((fperm & perms::owner_exec) != perms::none) suffix = \"*\";\n    ```", "```cpp\nchrono*\nchrono.cpp\nformatter*\nformatter.cpp\ninclude -> /Users/billw/include\nMakefile\ntestdir/\nworking*\nworking.cpp\n```", "```cpp\nchar type_char(const fs::file_status& fstat) {\n         if(is_symlink(fstat))        return 'l';\n    else if(is_directory(fstat))      return 'd';\n    else if(is_character_file(fstat)) return 'c';\n    else if(is_block_file(fstat))     return 'b';\n    else if(is_fifo(fstat))           return 'p';\n    else if(is_socket(fstat))         return 's';\n    else if(is_other(fstat))          return 'o';\n    else if(is_regular_file(fstat))   return '-';\n    return '?';\n}\n```", "```cpp\nstring rwx(const fs::perms& p) {\n    using fs::perms;\n    auto bit2char = [&p](perms bit, char c) {\n        return (p & bit) == perms::none ? '-' : c;\n    };\n    return { bit2char(perms::owner_read,   'r'),\n             bit2char(perms::owner_write,  'w'),\n             bit2char(perms::owner_exec,   'x'),\n             bit2char(perms::group_read,   'r'),\n             bit2char(perms::group_write,  'w'),\n             bit2char(perms::group_exec,   'x'),\n             bit2char(perms::others_read,  'r'),\n             bit2char(perms::others_write, 'w'),\n             bit2char(perms::others_exec,  'x') };\n}\n```", "```cpp\nconst auto permstr{ type_char(fstat) + rwx(fperm) };\n```", "```cpp\ncout << format(\"{} {}{}\\n\", permstr, fn, suffix);\n```", "```cpp\n-rwxr-xr-x chrono*\n-rw-r--r-- chrono.cpp\n-rwxr-xr-x formatter*\n-rw-r--r-- formatter.cpp\nlrwxr-xr-x include -> /Users/billw/include\n-rw-r--r-- Makefile\ndrwxr-xr-x testdir/\n-rwxr-xr-x working*\n-rw-r--r-- working.cpp\n```", "```cpp\n    string size_string(const uintmax_t fsize) {\n        constexpr const uintmax_t kilo{ 1024 };\n        constexpr const uintmax_t mega{ kilo * kilo };\n        constexpr const uintmax_t giga{ mega * kilo };\n        string s;\n        if(fsize >= giga ) return\n            format(\"{}{}\", (fsize + giga / 2) / giga, 'G');\n        else if (fsize >= mega) return\n            format(\"{}{}\", (fsize + mega / 2) / mega, 'M');\n        else if (fsize >= kilo) return\n            format(\"{}{}\", (fsize + kilo / 2) / kilo, 'K');\n        else return format(\"{}B\", fsize);\n    }\n    ```", "```cpp\ncout << format(\"{} {:>6} {}{}\\n\",\n    permstr, size_string(fsize), fn, suffix);\n```", "```cpp\n-rwxr-xr-x   284K chrono*\n-rw-r--r--     2K chrono.cpp\n-rwxr-xr-x   178K formatter*\n-rw-r--r--   906B formatter.cpp\nlrwxr-xr-x     0B include -> /Users/billw/include\n-rw-r--r--   642B Makefile\ndrwxr-xr-x     0B testdir/\n-rwxr-xr-x   197K working*\n-rw-r--r--     5K working.cpp\n```", "```cpp\nstring time_string(const fs::directory_entry& dir) {\n    using std::chrono::file_clock;\n    auto file_time{ dir.last_write_time() };\n    return format(\"{:%F %T}\", \n        file_clock::to_sys(dir.last_write_time()));\n}\n```", "```cpp\nconst string timestr{ time_string(dir) };\n```", "```cpp\ncout << format(\"{} {:>6} {} {}{}\\n\",\n    permstr, sizestr, timestr, fn, suffix);\n```", "```cpp\n-rwxr-xr-x   248K 2022-03-09 09:39:49 chrono*\n-rw-r--r--     2K 2022-03-09 09:33:56 chrono.cpp\n-rwxr-xr-x   178K 2022-03-09 09:39:49 formatter*\n-rw-r--r--   906B 2022-03-09 09:33:56 formatter.cpp\nlrwxrwxrwx     0B 2022-02-04 11:39:53 include -> /home/billw/include\n-rw-r--r--   642B 2022-03-09 14:08:37 Makefile\ndrwxr-xr-x     0B 2022-03-09 10:38:39 testdir/\n-rwxr-xr-x   197K 2022-03-12 17:13:46 working*\n-rw-r--r--     5K 2022-03-12 17:13:40 working.cpp\n```", "```cpp\n    namespace fs = std::filesystem;\n    using de = fs::directory_entry;\n    using rdit = fs::recursive_directory_iterator;\n    using match_v = vector<std::pair<size_t, std::string>>;\n    ```", "```cpp\n    template<>\n    struct std::formatter<fs::path>: std::formatter<std::string> {\n        template<typename FormatContext>\n        auto format(const fs::path& p, FormatContext& ctx) {\n            return format_to(ctx.out(), \"{}\", p.string());\n        }\n    };\n    ```", "```cpp\n    match_v matches(const fs::path& fpath, const regex& re) {\n        match_v matches{};\n        std::ifstream instrm(fpath.string(),\n            std::ios_base::in);\n        string s;\n        for(size_t lineno{1}; getline(instrm, s); ++lineno) {\n            if(std::regex_search(s.begin(), s.end(), re)) {\n                matches.emplace_back(lineno, move(s));\n            }\n        }\n        return matches;\n    }\n    ```", "```cpp\n    int main() {\n        constexpr const char * fn{ \"working.cpp\" };\n        constexpr const char * pattern{ \"path\" };\n        fs::path fpath{ fn };\n        regex re{ pattern };\n        auto regmatches{ matches(fpath, re) };\n        for(const auto& [lineno, line] : regmatches) {\n            cout << format(\"{}: {}\\n\", lineno, line);\n        }\n        cout << format(\"found {} matches\\n\", regmatches.size());\n    }\n    ```", "```cpp\n25: struct std::formatter<fs::path>: std::formatter<std::string> {\n27:     auto format(const fs::path& p, FormatContext& ctx) {\n32: match_v matches(const fs::path& fpath, const regex& re) {\n34:     std::ifstream instrm(fpath.string(), std::ios_base::in);\n62:     constexpr const char * pattern{ \"path\" };\n64:     fs::path fpath{ fn };\n66:     auto regmatches{ matches(fpath, re) };\n```", "```cpp\nsize_t pmatches(const regex& re, const fs::path& epath,\n        const fs::path& search_path) {\n    fs::path target{epath};\n    auto regmatches{ matches(epath, re) };\n    auto matchcount{ regmatches.size() };\n    if(!matchcount) return 0;\n    if(!(search_path == epath)) {\n        target = \n          epath.lexically_relative(search_path);\n    }\n    for (const auto& [lineno, line] : regmatches) {\n        cout << format(\"{} {}: {}\\n\", target, lineno, \n          line);\n    }\n    return regmatches.size();\n}\n```", "```cpp\n    int main(const int argc, const char** argv) {\n        const char * arg_pat{};\n        regex re{};\n        fs::path search_path{};\n        size_t matchcount{};\n        ...\n    ```", "```cpp\n    if(argc < 2) {\n        auto cmdname{ fs::path(argv[0]).filename() };\n        cout << format(\"usage: {} pattern [path/file]\\n\", \n            cmdname);\n        return 1;\n    }\n    ```", "```cpp\n    arg_pat = argv[1];\n    try {\n        re = regex(arg_pat, std::regex_constants::icase);\n    } catch(const std::regex_error& e) {\n        cout << format(\"{}: {}\\n\", e.what(), arg_pat);\n        return 1;\n    }\n    ```", "```cpp\n    if(argc == 2) {\n        search_path = \".\";\n            for (const auto& entry : rdit{ search_path }) {\n            const auto epath{ entry.path() };\n            matchcount += pmatches(re, epath, \n              search_path);\n        }\n    }\n    ```", "```cpp\n    int count{ argc - 2 };\n    while(count-- > 0) {\n        fs::path p{ argv[count + 2] };\n        if(!exists(p)) {\n            cout << format(\"not found: {}\\n\", p);\n            continue;\n        }\n        if(is_directory(p)) {\n            for (const auto& entry : rdit{ p }) {\n                const auto epath{ entry.path() };\n                matchcount += pmatches(re, epath, p);\n            }\n        } else {\n            matchcount += pmatches(re, p, p);\n        }\n    }\n    ```", "```cpp\n    $ ./bwgrep using\n    dir.cpp 12: using std::format;\n    dir.cpp 13: using std::cout;\n    dir.cpp 14: using std::string;\n    ...\n    formatter.cpp 10: using std::cout;\n    formatter.cpp 11: using std::string;\n    formatter.cpp 13: using namespace std::filesystem;\n    found 33 matches\n    ```", "```cpp\n$ ./bwgrep using ..\nchap04/iterator-adapters.cpp 12: using std::format;\nchap04/iterator-adapters.cpp 13: using std::cout;\nchap04/iterator-adapters.cpp 14: using std::cin;\n...\nchap01/hello-version.cpp 24: using std::print;\nchap01/chrono.cpp 8: using namespace std::chrono_literals;\nchap01/working.cpp 15: using std::cout;\nchap01/working.cpp 34:     using std::vector;\nfound 529 matches\n```", "```cpp\n$ ./bwgrep using bwgrep.cpp\nbwgrep.cpp 13: using std::format;\nbwgrep.cpp 14: using std::cout;\nbwgrep.cpp 15: using std::string;\n...\nbwgrep.cpp 22: using rdit = fs::recursive_directory_iterator;\nbwgrep.cpp 23: using match_v = vector<std::pair<size_t, std::string>>;\nfound 9 matches\n```", "```cpp\n    namespace fs = std::filesystem;\n    using dit = fs::directory_iterator;\n    using pat_v = vector<std::pair<regex, string>>;\n    ```", "```cpp\n    template<>\n    struct std::formatter<fs::path>: std::formatter<std::string> {\n        template<typename FormatContext>\n        auto format(const fs::path& p, FormatContext& ctx) {\n            return format_to(ctx.out(), \"{}\", p.string());\n        }\n    };\n    ```", "```cpp\n    string replace_str(string s, const pat_v& replacements) {\n        for(const auto& [pattern, repl] : replacements) {\n            s = regex_replace(s, pattern, repl);\n        }\n        return s;\n    }\n    ```", "```cpp\n    int main(const int argc, const char** argv) {\n        pat_v patterns{};\n        if(argc < 3 || argc % 2 != 1) {\n            fs::path cmdname{ fs::path{argv[0]}.filename() };\n            cout << format(\n                \"usage: {} [regex replacement] ...\\n\", \n                cmdname);\n            return 1;\n        }\n    ```", "```cpp\n    for(int i{ 1 }; i < argc; i += 2) {\n        patterns.emplace_back(argv[i], argv[i + 1]);\n    }\n    ```", "```cpp\n    for(const auto& entry : dit{fs::current_path()}) {\n        fs::path fpath{ entry.path() };\n        string rname{\n            replace_str(fpath.filename().string(), \n    patterns) };\n        if(fpath.filename().string() != rname) {\n            fs::path rpath{ fpath };\n            rpath.replace_filename(rname);\n            if(exists(rpath)) {\n                cout << \"Error: cannot rename - destination file exists.\\n\";\n            } else {\n                fs::rename(fpath, rpath);\n                cout << format(\n                    \"{} -> {}\\n\", \n                    fpath.filename(), \n                    rpath.filename());\n            }\n        }\n    }\n    ```", "```cpp\n    $ ls\n    bwfoo.txt bwgrep.cpp chrono.cpp dir.cpp formatter.cpp path-ops.cpp working.cpp\n    ```", "```cpp\n    $ ../rerename .cpp .Cpp\n    dir.cpp -> dir.Cpp\n    path-ops.cpp -> path-ops.Cpp\n    bwgrep.cpp -> bwgrep.Cpp\n    working.cpp -> working.Cpp\n    formatter.cpp -> formatter.Cpp\n    ```", "```cpp\n$ ../rerename .Cpp .cpp\nformatter.Cpp -> formatter.cpp\nbwgrep.Cpp -> bwgrep.cpp\ndir.Cpp -> dir.cpp\nworking.Cpp -> working.cpp\npath-ops.Cpp -> path-ops.cpp\n```", "```cpp\n    $ ../rerename '^' bw\n    bwgrep.cpp -> bwbwgrep.cpp\n    chrono.cpp -> bwchrono.cpp\n    formatter.cpp -> bwformatter.cpp\n    bwfoo.txt -> bwbwfoo.txt\n    working.cpp -> bwworking.cpp\n    ```", "```cpp\n$ ../rerename '^bw' ''\nbwbwgrep.cpp -> bwgrep.cpp\nbwworking.cpp -> working.cpp\nbwformatter.cpp -> formatter.cpp\nbwchrono.cpp -> chrono.cpp\nbwbwfoo.txt -> bwfoo.txt\n```", "```cpp\n$ ../rerename '^(?!bw)' bw\nchrono.cpp -> bwchrono.cpp\nformatter.cpp -> bwformatter.cpp\nworking.cpp -> bwworking.cpp\n```", "```cpp\n$ ../rerename foo bar '\\.cpp$' '.xpp' grep grok\nbwgrep.cpp -> bwgrok.xpp\nbwworking.cpp -> bwworking.xpp\nbwformatter.cpp -> bwformatter.xpp\nbwchrono.cpp -> bwchrono.xpp\nbwfoo.txt -> bwbar.txt\n```", "```cpp\nfor(const auto& entry : dit{fs::current_path()}) {\n    fs::path fpath{ entry.path() };\n    ...\n}\n```", "```cpp\nfs::path rpath{ fpath };\nrpath.replace_filename(rname);\n```", "```cpp\nfs::rename(fpath, rpath);\n```", "```cpp\ns = regex_replace(s, pattern, repl);\n```", "```cpp\n$ ../rerename '(bw)(.*\\.)(.*)$' '$3$2$1'\nbwgrep.cpp -> cppgrep.bw\nbwfoo.txt -> txtfoo.bw\n```", "```cpp\n    namespace fs = std::filesystem;\n    using dit = fs::directory_iterator;\n    using de = fs::directory_entry;\n    ```", "```cpp\n    template<>\n    struct std::formatter<fs::path>: std::formatter<std::string> {\n        template<typename FormatContext>\n        auto format(const fs::path& p, FormatContext& ctx) {\n            return format_to(ctx.out(), \"{}\", p.string());\n        }\n    };\n    ```", "```cpp\n    string make_commas(const uintmax_t& num) {\n        string s{ std::to_string(num) };\n        for(long l = s.length() - 3; l > 0; l -= 3) {\n            s.insert(l, \",\");\n        }\n        return s;\n    }\n    ```", "```cpp\n    string strlower(string s) {\n        auto char_lower = [](const char& c) -> char {\n            if(c >= 'A' && c <= 'Z') return c + ('a' – \n               'A');\n            else return c;\n        };\n        std::transform(s.begin(), s.end(), s.begin(), \n          char_lower);\n        return s;\n    }\n    ```", "```cpp\n    bool dircmp_lc(const de& lhs, const de& rhs) {\n        const auto lhstr{ lhs.path().string() };\n        const auto rhstr{ rhs.path().string() };\n        return strlower(lhstr) < strlower(rhstr);\n    }\n    ```", "```cpp\n    string size_string(const uintmax_t fsize) {\n        constexpr const uintmax_t kilo{ 1024 };\n        constexpr const uintmax_t mega{ kilo * kilo };\n        constexpr const uintmax_t giga{ mega * kilo };\n        if(fsize >= giga ) return format(\"{}{}\",\n            (fsize + giga / 2) / giga, 'G');\n        else if (fsize >= mega) return format(\"{}{}\",\n            (fsize + mega / 2) / mega, 'M');\n        else if (fsize >= kilo) return format(\"{}{}\",\n            (fsize + kilo / 2) / kilo, 'K');\n        else return format(\"{}B\", fsize);\n    }\n    ```", "```cpp\n    uintmax_t entry_size(const fs::path& p) {\n        if(fs::is_regular_file(p)) return \n           fs::file_size(p);\n        uintmax_t accum{};\n        if(fs::is_directory(p) && ! fs::is_symlink(p)) {\n            for(auto& e : dit{ p }) {\n                accum += entry_size(e.path());\n            }\n        }\n        return accum;\n    }\n    ```", "```cpp\n    int main(const int argc, const char** argv) {\n        auto dir{ argc > 1 ? \n            fs::path(argv[1]) : fs::current_path() };\n        vector<de> entries{};\n        uintmax_t accum{};\n        if (!exists(dir)) {\n            cout << format(\"path {} does not exist\\n\", \n              dir);\n            return 1;\n        }\n        if(!is_directory(dir)) {\n            cout << format(\"{} is not a directory\\n\", \n              dir);\n            return 1;\n        }\n        cout << format(\"{}:\\n\", absolute(dir));\n    ```", "```cpp\n    for (const auto& e : dit{ dir }) {\n        entries.emplace_back(e.path());\n    }\n    std::sort(entries.begin(), entries.end(), dircmp_lc);\n    ```", "```cpp\n    for (const auto& e : entries) {\n        fs::path p{ e };\n        uintmax_t esize{ entry_size(p) };\n        string dir_flag{};\n        accum += esize;\n        if(is_directory(p) && !is_symlink(p)) dir_flag = \n           \" ![](img/6.png)\";\n        cout << format(\"{:>5} {}{}\\n\",\n            size_string(esize), p.filename(), dir_flag);\n    }\n    cout << format(\"{:->25}\\n\", \"\");\n    cout << format(\"total bytes: {} ({})\\n\",\n        make_commas(accum), size_string(accum));\n    ```", "```cpp\n/home/billw/working/cpp-stl-wkbk/chap10:\n 327K bwgrep\n   3K bwgrep.cpp\n 199K dir\n   4K dir.cpp\n 176K formatter\n 905B formatter.cpp\n   0B include\n   1K Makefile\n 181K path-ops\n   1K path-ops.cpp\n 327K rerename\n   2K rerename.cpp\n11K testdir ![](img/6.png)\n11K testdir-backup ![](img/6.png)\n 203K working\n   3K working.cpp\n-------------------------\ntotal bytes: 1,484,398 (1M)\n```", "```cpp\nuintmax_t entry_size(const fs::path& p) {\n    if(fs::is_regular_file(p)) return fs::file_size(p);\n    uintmax_t accum{};\n    if(fs::is_directory(p) && !fs::is_symlink(p)) {\n        for(auto& e : dit{ p }) {\n            accum += entry_size(e.path());\n        }\n    }\n    return accum;\n}\n```"]