["```cpp\nccall(ident, returnType, argTypes, args, opts)\n```", "```cpp\n// Call C from JavaScript\nvar result = Module.ccall(\n  'c_add', // name of C function\n  'number', // return type\n  ['number', 'number'], // argument types\n  [10, 20] // arguments\n);\n\n// result is 30\n```", "```cpp\ncwrap(ident, returnType, argTypes)\n```", "```cpp\n// Call C from JavaScript\nvar c_javascript_add = Module.cwrap(\n  'c_add', // name of C function\n  'number', // return type\n  ['number', 'number'] // argument types\n);\n\n// Call c_javascript_add normally\nconsole.log(c_javascript_add(10, 20)); // 30\nconsole.log(c_javascript_add(20, 30)); // 50\n```", "```cpp\nint addNumbers(int num1, int num2) {\n    return num1 + num2;\n}\n\nint addNumbers(int num1, int num2, int num3) {\n    return num1 + num2 + num3;\n}\n\nint addNumbers(int num1, int num2, int num3, int num4) {\n    return num1 + num2 + num3 + num4;\n}\n\n// The function will return a value based on how many\n// arguments you pass it:\nint getSumOfTwoNumbers = addNumbers(1, 2);\n// returns 3\n\nint getSumOfThreeNumbers = addNumbers(1, 2, 3);\n// returns 6\n\nint getSumOfFourNumbers = addNumbers(1, 2, 3, 4);\n// returns 10\n```", "```cpp\nextern \"C\" {\nint addTwoNumbers(int num1, int num2) {\n    return num1 + num2;\n}\n\nint addThreeNumbers(int num1, int num2, int num3) {\n    return num1 + num2 + num3;\n}\n\nint addFourNumbers(int num1, int num2, int num3, int num4) {\n    return num1 + num2 + num3 + num4;\n}\n}\n```", "```cpp\nPromise<ResultObject> WebAssembly.instantiateStreaming(source, importObject);\n```", "```cpp\n// Assume the importObj is already defined.\nWebAssembly.instantiateStreaming(\n  fetch('simple.wasm'),\n  importObj\n)\n  .then(result => {\n    const addedNumbers = result.instance.exports._addTwoNumbers(1, 2);\n    // result is 3\n  });\n```", "```cpp\n// Using Emscripten's Module\nModule()\n  .then(result => {\n    // \"asm\" is essentially \"instance\"\n    const exports = result.asm;\n    const addedNumbers = exports._addTwoNumbers(1, 2);\n    // result is 3\n  });\n```", "```cpp\nemscripten_run_script(\"alert('hi')\");\n```", "```cpp\n#include <emscripten.h>\n\nint main() {\n    EM_ASM(\n        console.log('This is some JS code.');\n    );\n    return 0;\n}\n```", "```cpp\nEM_ASM({\n    console.log('I received: ' + [ $0, $1 ]);\n}, 100, 35.5);\n```", "```cpp\nEM_JS(return_type, function_name, arguments, code)\n```", "```cpp\n#include <emscripten.h>\n\nEM_JS(void, take_args, (int x, float y), {\n    console.log(`I received ${x} and ${y}`);\n});\n\nint main() {\n    take_args(100, 35.5);\n    return 0;\n}\n```", "```cpp\n/*\n * This file interacts with the canvas through imported functions.\n * It moves a blue rectangle diagonally across the canvas\n * (mimics the SDL example).\n */\n#include <emscripten.h>\n#include <stdbool.h>\n\n#define BOUNDS 255\n#define RECT_SIDE 50\n#define BOUNCE_POINT (BOUNDS - RECT_SIDE)\n\nbool isRunning = true;\n\ntypedef struct Rect {\n  int x;\n  int y;\n  char direction;\n} Rect;\n\nstruct Rect rect;\n\n/*\n * Updates the rectangle location by 1px in the x and y in a\n * direction based on its current position.\n */\nvoid updateRectLocation() {\n    // Since we want the rectangle to \"bump\" into the edge of the\n    // canvas, we need to determine when the right edge of the\n    // rectangle encounters the bounds of the canvas, which is why\n    // we're using the canvas width - rectangle width:\n    if (rect.x == BOUNCE_POINT) rect.direction = 'L';\n\n    // As soon as the rectangle \"bumps\" into the left side of the\n    // canvas, it should change direction again.\n    if (rect.x == 0) rect.direction = 'R';\n\n    // If the direction has changed based on the x and y\n    // coordinates, ensure the x and y points update\n    // accordingly:\n    int incrementer = 1;\n    if (rect.direction == 'L') incrementer = -1;\n    rect.x = rect.x + incrementer;\n    rect.y = rect.y + incrementer;\n}\n\nEM_JS(void, js_clear_rect, (), {\n    // Clear the rectangle to ensure there's no color where it\n    // was before:\n    var canvas = document.querySelector('#myCanvas');\n    var ctx = canvas.getContext('2d');\n    ctx.fillStyle = '#ff0000';\n    ctx.fillRect(0, 0, 255, 255);\n});\n\nEM_JS(void, js_fill_rect, (int x, int y, int width, int height), {\n    // Fill the rectangle with blue in the specified coordinates:\n    var canvas = document.querySelector('#myCanvas');\n    var ctx = canvas.getContext('2d');\n    ctx.fillStyle = '#0000ff';\n    ctx.fillRect(x, y, width, height);\n});\n\n/*\n * Clear the existing rectangle element from the canvas and draw a\n * new one in the updated location.\n */\nEMSCRIPTEN_KEEPALIVE\nvoid moveRect() {\n    // Event though the js_clear_rect doesn't have any\n    // parameters, we pass 0 in to prevent a compiler warning:\n    js_clear_rect(0);\n    updateRectLocation();\n    js_fill_rect(rect.x, rect.y, RECT_SIDE, RECT_SIDE);\n}\n\nEMSCRIPTEN_KEEPALIVE\nbool getIsRunning() {\n    return isRunning;\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid setIsRunning(bool newIsRunning) {\n    isRunning = newIsRunning;\n    EM_ASM({\n        // isRunning is either 0 or 1, but in JavaScript, 0\n        // is \"falsy\", so we can set the status text based\n        // without explicitly checking if the value is 0 or 1:\n        var newStatus = $0 ? 'Running' : 'Paused';\n        document.querySelector('#runStatus').innerHTML = newStatus;\n    }, isRunning);\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid init() {\n    emscripten_run_script(\"console.log('Initializing rectangle...')\");\n    rect.x = 0;\n    rect.y = 0;\n    rect.direction = 'R';\n    setIsRunning(true);\n    emscripten_run_script(\"console.log('Rectangle should be moving!')\");\n}\n```", "```cpp\n<!doctype html>\n<html lang=\"en-us\">\n<head>\n  <title>Interact with JS using Glue Code</title>\n</head>\n<body>\n  <h1>Interact with JS using Glue Code</h1>\n  <canvas id=\"myCanvas\" width=\"255\" height=\"255\"></canvas>\n  <div style=\"margin-top: 16px;\">\n    <button id=\"actionButton\" style=\"width: 100px; height: 24px;\">Pause</button>\n    <span style=\"width: 100px; margin-left: 8px;\">Status:</span>\n    <span id=\"runStatus\" style=\"width: 100px;\"></span>\n  </div>\n  <script type=\"application/javascript\" src=\"img/js-with-glue.js\"></script>\n  <script type=\"application/javascript\">\n    Module()\n      .then(result => {\n        const m = result.asm;\n        m._init();\n\n        // Move the rectangle by 1px in the x and y every 20 milliseconds:\n        const loopRectMotion = () => {\n          setTimeout(() => {\n            m._moveRect();\n            if (m._getIsRunning()) loopRectMotion();\n          }, 20)\n        };\n\n        // Enable you to pause and resume the rectangle movement:\n        document.querySelector('#actionButton')\n          .addEventListener('click', event => {\n            const newIsRunning = !m._getIsRunning();\n            m._setIsRunning(newIsRunning);\n            event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';\n            if (newIsRunning) loopRectMotion();\n          });\n\n        loopRectMotion();\n      });\n  </script>\n</body>\n</html>\n```", "```cpp\nemcc js-with-glue.c -O3 -s WASM=1 -s MODULARIZE=1 -o js-with-glue.js\n```", "```cpp\nserve -l 8080\n```", "```cpp\n// You can define the function inside of the env object:\nconst env = {\n  // Make sure you prefix the function name with \"_\"!\n  _logValueToConsole: value => {\n    console.log(`'The value is ${value}'`);\n  }\n};\n\n// Or define it outside of env and reference it within env:\nconst logValueToConsole = value => {\n  console.log(`'The value is ${value}'`);\n};\n\nconst env = {\n  _logValueToConsole: logValueToConsole\n};\n```", "```cpp\n// index.html <script> contents\nconst env = {\n  _logAndMultiplyTwoNums: (num1, num2) => {\n    const result = num1 * num2;\n    console.log(result);\n    return result;\n  },\n};\n\nloadWasm('main.wasm', { env })\n  .then(({ instance }) => {\n    const result = instance.exports._callMultiply(5.5, 10);\n    console.log(result);\n    // 55 is logged to the console twice\n  });\n```", "```cpp\n// main.c (compiled to main.wasm)\nextern float logAndMultiplyTwoNums(float num1, float num2);\n\nfloat callMultiply(float num1, float num2) {\n    return logAndMultiplyTwoNums(num1, num2);\n}\n```", "```cpp\n/*\n * This file interacts with the canvas through imported functions.\n * It moves a circle diagonally across the canvas.\n */\n#define BOUNDS 255\n#define CIRCLE_RADIUS 50\n#define BOUNCE_POINT (BOUNDS - CIRCLE_RADIUS)\n\nbool isRunning = true;\n\ntypedef struct Circle {\n  int x;\n  int y;\n  char direction;\n} Circle;\n\nstruct Circle circle;\n\n/*\n * Updates the circle location by 1px in the x and y in a\n * direction based on its current position.\n */\nvoid updateCircleLocation() {\n    // Since we want the circle to \"bump\" into the edge of the canvas,\n    // we need to determine when the right edge of the circle\n    // encounters the bounds of the canvas, which is why we're using\n    // the canvas width - circle width:\n    if (circle.x == BOUNCE_POINT) circle.direction = 'L';\n\n    // As soon as the circle \"bumps\" into the left side of the\n    // canvas, it should change direction again.\n    if (circle.x == CIRCLE_RADIUS) circle.direction = 'R';\n\n    // If the direction has changed based on the x and y\n    // coordinates, ensure the x and y points update accordingly:\n    int incrementer = 1;\n    if (circle.direction == 'L') incrementer = -1;\n    circle.x = circle.x + incrementer;\n    circle.y = circle.y - incrementer;\n}\n\n// We need to wrap any imported or exported functions in an\n// extern block, otherwise the function names will be mangled.\nextern \"C\" {\n// These functions are passed in through the importObj.env object\n// and update the circle on the <canvas>:\nextern int jsClearCircle();\nextern int jsFillCircle(int x, int y, int radius);\n\n/*\n * Clear the existing circle element from the canvas and draw a\n * new one in the updated location.\n */\nvoid moveCircle() {\n    jsClearCircle();\n    updateCircleLocation();\n    jsFillCircle(circle.x, circle.y, CIRCLE_RADIUS);\n}\n\nbool getIsRunning() {\n    return isRunning;\n}\n\nvoid setIsRunning(bool newIsRunning) {\n    isRunning = newIsRunning;\n}\n\nvoid init() {\n    circle.x = 0;\n    circle.y = 255;\n    circle.direction = 'R';\n    setIsRunning(true);\n}\n}\n```", "```cpp\n<!doctype html>\n<html lang=\"en-us\">\n<head>\n  <title>Interact with JS without Glue Code</title>\n  <script\n    type=\"application/javascript\"\n    src=\"img/load-wasm.js\">\n  </script>\n  <style>\n    #myCanvas {\n      border: 2px solid black;\n    }\n    #actionButtonWrapper {\n      margin-top: 16px;\n    }\n    #actionButton {\n      width: 100px;\n      height: 24px;\n    }\n  </style>\n</head>\n<body>\n  <h1>Interact with JS without Glue Code</h1>\n  <canvas id=\"myCanvas\" width=\"255\" height=\"255\"></canvas>\n  <div id=\"actionButtonWrapper\">\n    <button id=\"actionButton\">Pause</button>\n  </div>\n  <script type=\"application/javascript\">\n    const canvas = document.querySelector('#myCanvas');\n    const ctx = canvas.getContext('2d');\n\n    const fillCircle = (x, y, radius) => {\n      ctx.fillStyle = '#fed530';\n      // Face outline:\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n      ctx.closePath();\n\n      // Eyes:\n      ctx.fillStyle = '#000000';\n      ctx.beginPath();\n      ctx.arc(x - 15, y - 15, 6, 0, 2 * Math.PI);\n      ctx.arc(x + 15, y - 15, 6, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.closePath();\n\n      // Mouth:\n      ctx.beginPath();\n      ctx.moveTo(x - 20, y + 10);\n      ctx.quadraticCurveTo(x, y + 30, x + 20, y + 10);\n      ctx.lineWidth = 4;\n      ctx.stroke();\n      ctx.closePath();\n    };\n\n    const env = {\n      table: new WebAssembly.Table({ initial: 8, element: 'anyfunc' }),\n      _jsFillCircle: fillCircle,\n      _jsClearCircle: function() {\n        ctx.fillStyle = '#fff';\n        ctx.fillRect(0, 0, 255, 255);\n      },\n    };\n\n    loadWasm('js-without-glue.wasm', { env }).then(({ instance }) => {\n      const m = instance.exports;\n      m._init();\n\n      // Move the circle by 1px in the x and y every 20 milliseconds:\n      const loopCircleMotion = () => {\n        setTimeout(() => {\n          m._moveCircle();\n          if (m._getIsRunning()) loopCircleMotion();\n        }, 20)\n      };\n\n      // Enable you to pause and resume the circle movement:\n      document.querySelector('#actionButton')\n        .addEventListener('click', event => {\n          const newIsRunning = !m._getIsRunning();\n          m._setIsRunning(newIsRunning);\n          event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';\n          if (newIsRunning) loopCircleMotion();\n        });\n\n      loopCircleMotion();\n    });\n  </script>\n</body>\n</html>\n```", "```cpp\nemcc js-without-glue.cpp -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o js-without-glue.wasm\n```", "```cpp\nserve -l 8080\n```", "```cpp\n// example.cpp\n#include <emscripten/bind.h>\n\nusing namespace emscripten;\n\nfloat lerp(float a, float b, float t) {\n    return (1 - t) * a + t * b;\n}\n\nEMSCRIPTEN_BINDINGS(my_module) {\n    function(\"lerp\", &lerp);\n}\n```", "```cpp\n<!-- example.html -->\n<!doctype html>\n<html>\n<script src=\"img/example.js\"></script>\n<script>\n  // example.js was generated by running this command:\n  // emcc --bind -o example.js example.cpp\n  console.log('lerp result: ' + Module.lerp(1, 2, 0.5));\n</script>\n</html>\n```", "```cpp\nconsole.log(Module().asm);\n```", "```cpp\nemcc chapter-06-interact-with-js/js-without-glue.cpp -O1 -g4 -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o chapter-06-interact-with-js/js-without-glue.wasm --source-map-base http://localhost:8080/chapter-06-interact-with-js/\n```", "```cpp\nserve -l 8080\n```"]