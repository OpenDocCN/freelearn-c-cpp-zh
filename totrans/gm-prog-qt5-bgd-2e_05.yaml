- en: Animations in Graphics View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形视图中的动画
- en: The previous chapter gave you a lot of information about powers of Graphics
    View framework. With that knowledge, we can now proceed to implementing our first
    2D game. Down the road, we will learn more about Qt's property system, explore
    multiple ways of performing animations, and add gamepad support to our application.
    By the end of the chapter, you will know all the most useful features of Graphics
    View.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章为你提供了大量关于 Graphics View 框架功能的信息。有了这些知识，我们现在可以继续实现我们的第一个 2D 游戏。将来，我们将学习更多关于
    Qt 的属性系统，探索执行动画的多种方式，并将游戏手柄支持添加到我们的应用程序中。到本章结束时，你将了解 Graphics View 的所有最有用的功能。
- en: 'Main topics covered in this chapter are as listed:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Using timers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器
- en: Camera control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机控制
- en: Parallax scrolling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直滚动
- en: Qt's property system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 的属性系统
- en: The Animation framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画框架
- en: Using Qt Gamepad module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt 游戏手柄模块
- en: The jumping elephant or how to animate the scene
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳跃的大象或如何动画化场景
- en: By now, you should have a good understanding of the items, the scene, and the
    view. With your knowledge of how to create items, standard and custom ones, of
    how to position them on the scene, and of how to set up the view to show the scene,
    you can make pretty awesome things. You can even zoom and move the scene with
    the mouse. That's surely good, but for a game, one crucial point is still missing—you
    have to animate the items.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对物品、场景和视图有了很好的理解。凭借你创建物品（标准或自定义）、在场景中定位它们以及设置视图以显示场景的知识，你可以制作出相当酷的东西。你甚至可以用鼠标缩放和移动场景。这当然很好，但对于一个游戏来说，还有一个关键点仍然缺失——你必须动画化物品。
- en: 'Instead of going through all possibilities of how to animate a scene, let''s
    develop a simple jump-and-run game where we recap parts of the previous topics
    and learn how to animate items on a screen. So let''s meet Benjamin, the elephant:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不通过所有可能的场景动画方式，而是开发一个简单的跳跃跑酷游戏，在这个游戏中我们会回顾之前的一些主题，并学习如何在屏幕上动画化物品。那么，让我们来认识一下本杰明，这只大象：
- en: '![](img/cf9b50c4-ec05-414d-9adc-2556f4e0d602.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf9b50c4-ec05-414d-9adc-2556f4e0d602.jpg)'
- en: The game play
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法
- en: 'The goal of the game is for Benjamin to collect the coins that are placed all
    over the game field. Besides walking right and left, Benjamin can, of course,
    also jump. In the following screenshot, you see what this minimalistic game should
    look like at the end:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是让本杰明收集游戏场地上所有放置的硬币。除了左右移动，本杰明当然也可以跳跃。在下面的截图中，你可以看到这个简约游戏最终应该是什么样子：
- en: '![](img/27c2c13b-fbef-429e-8a1d-f5323ee7778b.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27c2c13b-fbef-429e-8a1d-f5323ee7778b.png)'
- en: Time for action - Creating an item for Benjamin
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 为本杰明创建一个物品
- en: Let's create a new Qt Widgets project and start making our game. Since the project
    will become more complex than our previous projects, we will not be giving you
    precise instructions for editing the code. If at any time you are unsure about
    the changes you make, you can look at the reference implementation provided with
    the book. It also contains the image files you can use to implement the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Qt Widgets 项目，并开始制作我们的游戏。由于这个项目将比我们之前的项目更复杂，我们不会给出精确的代码编辑指令。如果你在任何时候对所做的更改不确定，可以查看书中提供的参考实现。它还包含了你可以用来实现游戏的图像文件。
- en: 'Let''s now look at how we can mobilize Benjamin. First, we need a custom item
    class for him. We call the `Player` class and choose `QGraphicsPixmapItem` as
    the base class, because Benjamin is a PNG image. In the item''s `Player` class,
    we further create a private field of integer type and call it `m_direction`. Its
    value signifies in which direction Benjamin walks—left or right—or if he stands
    still. Next, we implement the constructor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何让本杰明动起来。首先，我们需要为他创建一个自定义的物品类。我们调用 `Player` 类，并选择 `QGraphicsPixmapItem`
    作为基类，因为本杰明是一个 PNG 图像。在 `Player` 物品类中，我们进一步创建一个整型私有字段，并称其为 `m_direction`。它的值表示本杰明走向哪个方向——左或右——或者如果他静止不动。接下来，我们实现构造函数：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the constructor, we set `m_direction` to `0`, which means that Benjamin isn't
    moving at all. If `m_direction` is `1`, Benjamin moves right, and if the value
    is `-1`, he moves left. In the body of the constructor, we set the image for the
    item by calling `setPixmap()`. The image of Benjamin is stored in the Qt Resource
    system; thus, we access it through `QPixmap(":/elephant")`, with elephant as the
    given alias for the actual image of Benjamin. Finally, we use the `setOffset()`
    function to change how the pixmap is positioned in the item's coordinate system.
    By default, the origin point corresponds to the top-left corner of the pixmap,
    but we prefer to have it at the center of the pixmap so that applying transformations
    is easier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将 `m_direction` 设置为 `0`，这意味着本杰明根本不会移动。如果 `m_direction` 是 `1`，本杰明会向右移动，如果值是
    `-1`，他会向左移动。在构造函数的主体中，我们通过调用 `setPixmap()` 来设置物品的图像。本杰明的图像存储在 Qt 资源系统中；因此，我们通过
    `QPixmap(":/elephant")` 来访问它，其中 elephant 是本杰明实际图像的给定别名。最后，我们使用 `setOffset()` 函数来改变图像在物品坐标系中的位置。默认情况下，原点对应于图像的左上角，但我们更喜欢将其放在图像的中心，这样应用变换会更加容易。
- en: When you are unsure of how to specify the path to your resource, you can ask
    Qt Creator about it. To do that, expand the Resources branch in the project tree,
    locate the resource, and select the Copy Path... entry in its context menu.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定如何指定资源路径时，你可以询问 Qt Creator。为此，展开项目树中的资源分支，定位资源，并在其上下文菜单中选择复制路径...条目。
- en: 'Next, we create a getter and setter function for the `m_direction` field:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为 `m_direction` 字段创建一个获取器和设置器函数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `direction()` function is a standard getter function for `m_direction` returning
    its value. The `setDirection()` setter function additionally checks in which direction
    Benjamin is moving. If he is moving left, we need to flip his image so that Benjamin
    looks to the left, the direction in which he is moving. If he is moving toward
    the right, we restore the normal state by assigning an empty `QTransform` object,
    which is an identity matrix.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`direction()` 函数是 `m_direction` 的标准获取器函数，返回其值。`setDirection()` 设置器函数还检查本杰明正在向哪个方向移动。如果他正在向左移动，我们需要翻转他的图像，使本杰明看起来向左，这是他移动的方向。如果他正在向右移动，我们通过分配一个空的
    `QTransform` 对象来恢复正常状态，这是一个单位矩阵。'
- en: We cannot use `QGraphicsItem::setScale` here, because it only supports the same
    scale factors for *x* and *y* axes. Fortunately, `setTransform()` enables us to
    set any affine or perspective transformation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里使用 `QGraphicsItem::setScale`，因为它只支持 *x* 和 *y* 轴相同的缩放因子。幸运的是，`setTransform()`
    允许我们设置任何仿射或透视变换。
- en: So, we now have our item of the `Player` class for the game's character, which
    shows the image of Benjamin. The item also stores the current moving direction,
    and based on that information, the image is flipped vertically if needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了游戏角色的 `Player` 类的物品，它显示了本杰明的图像。该物品还存储当前的移动方向，并根据该信息，如果需要，图像会垂直翻转。
- en: The playing field
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比赛场地
- en: Since we will have to do some work on the scene, we subclass `QGraphicsScene` and
    name the new class `MyScene`. There, we implement one part of the game logic.
    This is convenient since `QGraphicsScene` inherits `QObject` and thus we can use
    Qt's signal and slot mechanism.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在场景上做一些工作，我们派生 `QGraphicsScene` 并将新类命名为 `MyScene`。在那里，我们实现游戏逻辑的一部分。这是方便的，因为
    `QGraphicsScene` 继承自 `QObject`，因此我们可以使用 Qt 的信号和槽机制。
- en: The scene creates the  environment in which our elephant will be walking and
    jumping. Overall, we have a view fixed in size holding a scene, which is exactly
    as big as the view. We do not take size changes of the view into account, since
    they will complicate the example too much.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 场景创建了一个环境，我们的象将在其中行走和跳跃。总的来说，我们有一个固定大小的视图，其中包含一个场景，其大小正好与视图相同。我们不考虑视图的大小变化，因为它们会使示例过于复杂。
- en: All animations inside the playing field are done by moving the items, not the
    scene. So we have to distinguish between the view's, or rather the scene's, width
    and the width of the elephant's virtual "world" in which he can move. In order
    to handle the movement properly, we need to create a few private fields in the `MyScene`
    class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛场地内的所有动画都是通过移动物品而不是场景来完成的。因此，我们必须区分视图的宽度（或者更确切地说，场景的宽度）和象虚拟“世界”的宽度，在这个虚拟世界中象可以移动。为了正确处理移动，我们需要在
    `MyScene` 类中创建一些私有字段。
- en: The width of this virtual world is defined by the `int m_fieldWidth` field and
    has no (direct) correlation with the scene. Within the range of `m_fieldWidth`,
    which is 500 pixels in the example, Benjamin or the graphics item can be moved
    from the minimum *x* coordinate, defined by `qreal m_minX`, to the maximum x coordinate,
    defined by `qreal m_maxX`. We keep track of his actual *x* position with the `qreal
    m_currentX` variable. Next, the minimum *y* coordinate the item is allowed to
    have is defined by `qreal m_groundLevel`. We have to also take into account the
    item's size.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚拟世界的宽度由 `int m_fieldWidth` 字段定义，并且与场景没有（直接）关联。在 `m_fieldWidth` 的范围内，例如示例中的
    500 像素，本杰明或图形项可以从由 `qreal m_minX` 定义的最低 *x* 坐标移动到由 `qreal m_maxX` 定义的最高 x 坐标。我们使用
    `qreal m_currentX` 变量跟踪其实际 *x* 位置。接下来，允许项目拥有的最低 *y* 坐标由 `qreal m_groundLevel`
    定义。我们还需要考虑项目的大小。
- en: 'Lastly, what is left is the view, which has a fixed size defined by the scene''s
    bounding rectangle size, which is not as wide as `m_fieldWidth`. So the scene
    (and the view) follows the elephant while he walks through his virtual world of
    the `m_fieldWidth` length. Take a look at the following diagram to see the variables
    in their graphical representation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，剩下的就是视图，其大小由场景的边界矩形大小固定定义，它不如 `m_fieldWidth` 宽。因此，场景（和视图）在象走过其 `m_fieldWidth`
    长度的虚拟世界时跟随。请看下面的图解以了解变量的图形表示：
- en: '![](img/020be3fc-c2f7-4b63-9d9f-e010c72e9ea4.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/020be3fc-c2f7-4b63-9d9f-e010c72e9ea4.png)'
- en: Time for action - Making Benjamin move
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 让本杰明移动
- en: 'The next thing we want to do is make our elephant movable. In order to achieve
    that, we add a `QTimer m_timer` private member to `MyScene`. `QTimer` is a class
    that can emit the `timeout()` signal periodically with the given interval. In
    the `MyScene` constructor, we set up the timer with the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们想要做的是让我们的象可以移动。为了实现这一点，我们在 `MyScene` 中添加了一个私有成员 `QTimer m_timer`。`QTimer`
    是一个可以定期以给定间隔发出 `timeout()` 信号的类。在 `MyScene` 构造函数中，我们使用以下代码设置定时器：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we define that the timer emits the timeout signal every 30 milliseconds.
    Then, we connect that signal to the scene's slot called `movePlayer()`, but we
    do not start the timer yet. The timer will be started when the player presses
    a key to move.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义定时器每 30 毫秒发出一次超时信号。然后，我们将该信号连接到场景的 `movePlayer()` 插槽，但我们还没有启动定时器。定时器将在玩家按下键移动时启动。
- en: 'Next, we need to handle the input events properly and update the player''s
    direction. We introduce the `Player * m_player` field that will contain a pointer
    to the player object and the `int m_horizontalInput` field that will accumulate
    the movement commands, as we''ll see in the next piece of code. Finally, we reimplement
    the `keyPressEvent` virtual function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要正确处理输入事件并更新玩家的方向。我们引入 `Player * m_player` 字段，它将包含指向玩家对象的指针，以及 `int m_horizontalInput`
    字段，它将累积移动命令，正如我们将在下一部分代码中看到的那样。最后，我们重新实现了 `keyPressEvent` 虚拟函数：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As a small side note, whenever code snippets in the following code passages
    are irrelevant for the actual detail, we will skip the code but will indicate
    missing code with `//...` so that you know that it is not the entire code. We
    will cover the skipped parts later when it is more appropriate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小插曲，当以下代码段中的代码片段对于实际细节不重要时，我们将跳过代码，但会用 `//...` 指示缺失的代码，这样您就知道这不是完整的代码。我们将在更合适的时候覆盖跳过的部分。
- en: What just happened?
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: In the key press event handler, we first check whether the key event was triggered
    because of an auto-repeat. If this is the case, we exit the function, because
    we only want to react on the first real key press event. Also, we do not call
    the base class implementation of that event handler since no item on the scene
    needs to get a key press event. If you do have items that could and should receive
    events, do not forget to forward them while reimplementing event handlers at the
    scene.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在按键事件处理程序中，我们首先检查按键事件是否是由于自动重复触发的。如果是这种情况，我们退出函数，因为我们只想对第一个实际按键事件做出反应。此外，我们不会调用该事件处理程序的基类实现，因为场景上的任何项目都不需要获得按键事件。如果您确实有可以并且应该接收事件的项目，在重新实现场景的事件处理程序时，不要忘记转发它们。
- en: If you press and hold a key down, Qt will continuously deliver the key press
    event. To determine whether it was the first real key press or an autogenerated
    event, use `QKeyEvent::isAutoRepeat()`. It returns `true` if the event was automatically
    generated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下并保持一个键，Qt 将持续传递按键事件。为了确定这是否是第一次真正的按键还是自动生成的事件，请使用 `QKeyEvent::isAutoRepeat()`。如果事件是自动生成的，则返回
    `true`。
- en: As soon as we know that the event was not delivered by an auto repeat, we react
    to the different key presses. Instead of calling the `setDirection()` method of
    the `Player *m_player` field directly, we use the `m_horizontalInput` class field
    to accumulate the input value. Whenever it's changed, we ensure the correctness
    of the value before passing it to `setDirection()`. For that, we use `qBound()`,
    which returns a value that is bound by the first and the last arguments. The argument
    in the middle is the actual value that we want to get bound, so the possible values
    in our case are restricted to -1, 0, and 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道事件不是由自动重复产生的，我们就对不同的按键做出反应。我们不是直接调用 `Player *m_player` 字段的 `setDirection()`
    方法，而是使用 `m_horizontalInput` 类字段来累积输入值。每当它发生变化时，我们确保在将其传递给 `setDirection()` 之前值的正确性。为此，我们使用
    `qBound()`，它返回一个由第一个和最后一个参数限制的值。中间的参数是我们想要获取限制的实际值，因此在我们的情况下，可能的值被限制为 -1、0 和 1。
- en: You might wonder, why not simply call `m_player->setDirection(1)` when the right
    key is pressed? Why accumulate the inputs in the  `m_horizontalInput` variable?
    Well, Benjamin is moved by the left and right arrow keys. If the right key is
    pressed, 1 is added; if it gets released, -1 is added. The same applies for the
    left key, but only the other way around. The addition of the value rather than
    setting it is now necessary because of a situation where a user presses and holds
    the right key, and the value of `m_direction` is therefore 1\. Now, without releasing
    the right key, they also press and hold the left key. Therefore, the value of
    `m_direction` is getting decreased by one; the value is now 0 and Benjamin stops.
    However, remember that both keys are still being pressed. What happens when the
    left key is released? How would you know in this situation in which direction
    Benjamin should move? To achieve that, you would have to find out an additional
    bit of information—whether the right key is still pressed down or not, which seems
    too much trouble and overhead. In our implementation, when the left key is released,
    1 is added and the value of `m_direction` becomes 1, making Benjamin move right.
    Voilà! All without any concern about what the state of the other button might
    be.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么当按下右键时，不直接调用 `m_player->setDirection(1)` 呢？为什么要在 `m_horizontalInput`
    变量中累积输入？嗯，本杰明是由左右箭头键控制的。如果按下右键，则加1；如果释放，则减1。左键的情况相同，但方向相反。现在，由于用户按下并保持右键，`m_direction`
    的值因此为1。现在，如果没有释放右键，他们也会按下并保持左键。因此，`m_direction` 的值会减少1；现在值为0，本杰明停止。然而，记住两个键仍然被按下。当左键释放时会发生什么？在这种情况下，你如何知道本杰明应该朝哪个方向移动？为了实现这一点，你需要找到额外的信息——即右键是否仍然被按下，这似乎太麻烦且开销太大。在我们的实现中，当左键释放时，加1，使
    `m_direction` 的值变为1，使本杰明向右移动。哇！没有任何关于其他按钮状态的担忧。
- en: 'After calling `setDirection()`, we call the `checkTimer()` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `setDirection()` 之后，我们调用 `checkTimer()` 函数：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function first checks whether the player moves. If not, the timer is stopped,
    because nothing has to be updated when our elephant stands still. Otherwise, the
    timer gets started, but only if it isn't already running. We check this by calling
    `isActive()` on the timer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先检查玩家是否移动。如果没有移动，则停止计时器，因为当我们的象静止时，不需要更新任何内容。否则，如果计时器尚未运行，则启动计时器。我们通过在计时器上调用
    `isActive()` 来检查这一点。
- en: When the user presses the right key, for example, at the beginning of the game,
    `checkTimer()` will start `m_timer`. Since its `timeout` signal was connected
    to `movePlayer()`, the slot will be called every 30 milliseconds till the key
    is released.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在游戏开始时按下右键，例如，`checkTimer()` 将启动 `m_timer`。由于它的 `timeout` 信号连接到了 `movePlayer()`，槽将在按键释放之前每30毫秒被调用一次。
- en: 'Since the `movePlayer()` function is a bit longer, let''s go through it step
    by step:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `movePlayer()` 函数有点长，让我们一步一步地过一遍：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, we cache the player''s current direction in a local variable to avoid
    multiple calls of `direction()`. Then, we check whether the player is moving at
    all. If they aren''t, we exit the function because there is nothing to animate:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将玩家的当前方向缓存在一个局部变量中，以避免多次调用 `direction()`。然后，我们检查玩家是否在移动。如果没有，我们退出函数，因为没有东西可以动画化：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we calculate the shift the player item should get and store it in `dx`.
    The distance the player should move every 30 milliseconds is defined by the `int m_velocity` member
    variable, expressed in pixels. You can create setter and getter functions for
    that variable if you like. For us, the default value of 4 pixels will do the job.
    Multiplied by the direction (which could only be 1 or -1 at this point), we get
    a shift of the player by 4 pixels to the right or to the left. Based on this shift,
    we calculate the new *x* position of the player. Next, we check whether that new
    position is inside the range of `m_minX` and `m_maxX`, two member variables that
    are already calculated and set up properly at this point. Then, if the new position
    is not equal to the actual position, which is stored in `m_currentX`, we proceed
    by assigning the new position as the current one. Otherwise, we exit the function
    since there is nothing to move.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算玩家项应该获得的移动量并将其存储在 `dx` 中。玩家每 30 毫秒应该移动的距离由 `int m_velocity` 成员变量定义，以像素为单位。如果你喜欢，可以为该变量创建设置器和获取器函数。对我们来说，默认的
    4 像素值将足够用。乘以方向（此时只能是 1 或 -1），我们得到玩家向右或向左移动 4 像素的移动。基于这个移动，我们计算玩家的新 *x* 位置。接下来，我们检查这个新位置是否在
    `m_minX` 和 `m_maxX` 的范围内，这两个成员变量已经计算并正确设置。然后，如果新位置不等于存储在 `m_currentX` 中的实际位置，我们就将新位置赋值为当前位置。否则，我们退出函数，因为没有东西要移动。
- en: 'The next question to tackle is whether the view should always move when the
    elephant is moving, which means that the elephant would always stay, say, in the
    middle of the view. No, he shouldn''t stay at a specific point inside the view.
    Rather, the view should be fixed when the elephant is moving. Only if he reaches
    the borders should the view follow. Let''s say that when the distance between
    the elephant''s center and the window''s border is less than 150 pixels, we will
    try to shift the view:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要解决的问题是在大象移动时视图是否应该始终移动，这意味着大象将始终保持在视图的中间，比如说。不，他不应该停留在视图内部的某个特定点上。相反，当大象移动时，视图应该是固定的。只有当它达到边界时，视图才应该跟随。比如说，当大象中心与窗口边界的距离小于
    150 像素时，我们将尝试移动视图：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `int m_worldShift` class field shows how much we have already shifted our
    world to the right. First, we calculate the actual coordinate of our elephant
    in the view and save it to the `visiblePlayerPos` variable. Then, we calculate
    its position relative to the allowed area defined by the `shiftBorder` and `rightShiftBorder`
    variables. If `visiblePlayerPos` is beyond the right border of the allowed area,
    `newWorldShiftRight` will be positive, we need to shift the world by `newWorldShiftRight`
    to the right. Similarly, when we need to shift it to the left, `newWorldShiftLeft`
    will be positive, and it will contain the needed amount of shift. Finally, we
    update the position of `m_player` using a `setX()` helper method that is similar
    to `setPos()` but leaves the *y* coordinate unchanged.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`int m_worldShift` 类字段显示了我们已经将世界向右移动了多少。首先，我们计算大象在视图中的实际坐标并将其保存到 `visiblePlayerPos`
    变量中。然后，我们计算其相对于由 `shiftBorder` 和 `rightShiftBorder` 变量定义的允许区域的相对位置。如果 `visiblePlayerPos`
    超出了允许区域的右边界，`newWorldShiftRight` 将为正值，我们需要将世界向右移动 `newWorldShiftRight`。同样，当我们需要将其向左移动时，`newWorldShiftLeft`
    将为正值，它将包含所需的移动量。最后，我们使用一个类似于 `setPos()` 但不改变 *y* 坐标的 `setX()` 辅助方法来更新 `m_player`
    的位置。'
- en: Note that the value for `shiftBorder` is randomly chosen. You can alter it as
    you like. Of course, you can create a setter and getter for this parameter too.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`shiftBorder` 的值是随机选择的。你可以按需更改它。当然，你也可以为这个参数创建设置器和获取器。
- en: The last important part to do here is to apply the new value of `m_worldShift`
    by setting positions of the other world items. While we're at it, we will implement
    parallax scrolling.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要做的最后一个重要部分是应用新的 `m_worldShift` 值，通过设置其他世界项的位置来实现。在这个过程中，我们将实现垂直滚动。
- en: Parallax scrolling
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直滚动
- en: 'Parallax scrolling is a trick to add an illusion of depth to the background
    of the game. This illusion occurs when the background has different layers that
    move at different speeds. The nearest background must move faster than the ones
    farther away. In our case, we have these four backgrounds ordered from the most
    distant to the nearest:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直滚动是一种技巧，用于为游戏背景添加深度错觉。这种错觉发生在背景有不同层，并且以不同速度移动时。最近的背景必须比远离的背景移动得更快。在我们的例子中，我们有这些四个背景，从最远到最近排序：
- en: 'The sky:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 天空：
- en: '![](img/1acb98b6-41ce-451d-a796-4cb4ba3178cf.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1acb98b6-41ce-451d-a796-4cb4ba3178cf.png)'
- en: 'The trees:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 树木：
- en: '![](img/daaf9dd3-06e5-4035-8036-c6bd39caf251.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/daaf9dd3-06e5-4035-8036-c6bd39caf251.jpg)'
- en: 'The grass:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 草地：
- en: '![](img/3e86e498-e1a9-4832-afdd-035d7cf2cd6c.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e86e498-e1a9-4832-afdd-035d7cf2cd6c.jpg)'
- en: 'The ground:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 地面：
- en: '![](img/0862d948-cce9-4aac-949f-5283d933e3e9.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0862d948-cce9-4aac-949f-5283d933e3e9.png)'
- en: Time for action - Moving the background
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 移动背景
- en: 'The scene will create a graphics item for each part of the background and store
    pointers to them in the `m_sky`, `m_grass`, and `m_trees` private fields. Now
    the question is how to move them at different speeds. The solution is quite simple—the
    slowest one, the sky, is the smallest image. The fastest background, the ground
    and the grass, are the largest images. Now when we take a look at the end of the
    `movePlayer()` function''s slot, we see this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 场景将为背景的每一部分创建一个图形项，并将它们的指针存储在`m_sky`、`m_grass`和`m_trees`私有字段中。现在的问题是，如何以不同的速度移动它们。解决方案相当简单——最慢的一个，天空，是最小的图像。最快的背景，地面和草地，是最大的图像。现在当我们查看`movePlayer()`函数槽的末尾时，我们看到这个：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `applyParallax()` helper method contains the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyParallax()` 辅助方法包含以下代码：'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What just happened?
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: What are we doing here? At the beginning, the sky's left border is the same
    as the view's left border, both at point (0, 0). At the end, when Benjamin has
    walked to the maximum right, the sky's right border should be the same as the
    view's right border. So, at this position, the shift of the sky will be equal
    to the sky's width (`m_sky->boundingRect().width()`) minus the width of the view
    (`width()`). The shift of the sky depends on the position of the camera and, consequently,
    the value of the `m_worldShift` variable; if it is far to the left, the sky isn't
    shifted, and if the camera is far to the right, the sky is maximally shifted.
    Thus, we have to multiply the sky's maximum shift value with a factor based on
    the current position of the camera. The relation to the camera's position is the
    reason this is handled in the `movePlayer()` function. The factor we have to calculate
    has to be between 0 and 1\. So we get the minimum shift (`0 * shift`, which equals
    0) and the maximum shift (`1 * shift`, which equals `shift`). We name this factor
    as `ratio`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做什么？一开始，天空的左边界与视图的左边界相同，都在点(0, 0)。在Benjamin走到最右边的时候，天空的右边界应该与视图的右边界相同。所以，在这个位置，天空的移动量将等于天空的宽度（`m_sky->boundingRect().width()`）减去视图的宽度（`width()`）。天空的移动量取决于摄像机的位置，从而决定了`m_worldShift`变量的值；如果它远离左边，天空不会移动；如果摄像机远离右边，天空会最大程度地移动。因此，我们必须将天空的最大移动值乘以一个基于当前摄像机位置的系数。与摄像机位置的关系是为什么这个处理在`movePlayer()`函数中完成的原因。我们必须计算的系数必须在0到1之间。所以我们得到最小移动量（`0
    * shift`，等于0）和最大移动量（`1 * shift`，等于`shift`）。我们将这个系数命名为`ratio`。
- en: How far the world was shifted is saved in `m_worldShift`, so by dividing `m_worldShift`
    by `maxWorldShift`, we get the needed factor. It is 0 when the player is to the
    far left and 1 if they are to the far right. Then, we have to simply multiply
    `ratio` with the maximum shift of the sky.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 世界移动的距离被保存在`m_worldShift`中，所以通过将`m_worldShift`除以`maxWorldShift`，我们得到所需的系数。当玩家在最左边时，它是0；如果他们在最右边，则是1。然后，我们必须简单地用`ratio`乘以天空的最大移动量。
- en: The same calculation is used for the other background items, so it is moved
    to a separate function. The calculation also explains why a smaller image is moving
    slower. It's because the overlap of the smaller image is less than that of the
    larger one, and since the backgrounds are moved in the same time period, the larger
    one has to move faster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他背景项也使用相同的计算，所以它被移动到单独的函数中。这个计算也解释了为什么较小的图像移动较慢。这是因为较小图像的重叠小于较大图像的重叠，并且由于背景在同一时间段内移动，较大的图像必须移动得更快。
- en: Have a go hero - Adding new background layers
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试添加新的背景层
- en: Try to add additional background layers to the game, following the preceding
    example. As an idea, you can add a barn behind the trees or let an airplane fly
    through the sky.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试根据前面的示例添加额外的背景层到游戏中。作为一个想法，你可以在树后面添加一个谷仓或者让飞机在天空中飞行。
- en: The Animation framework
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画框架
- en: For now, we have calculated and applied new positions for our graphics items
    manually. However, Qt provides a way to do it automatically, called the Animation
    framework.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们手动计算并应用了我们的图形项的新位置。然而，Qt提供了一种自动执行此操作的方法，称为动画框架。
- en: The framework is an abstract implementation of animations, so it can be applied
    to any `QObject`, such as widgets, or even plain variables. Graphics, items can
    be animated too, and we will get to this topic soon. Animations are not restricted
    to the object's coordinates. You can animate color, opacity, or a completely invisible
    property.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架是动画的抽象实现，因此它可以应用于任何`QObject`，例如小部件，甚至是普通变量。图形项也可以进行动画处理，我们很快就会讨论这个话题。动画不仅限于对象的坐标。你可以对颜色、不透明度或完全不可见的属性进行动画处理。
- en: 'To create an animation, you typically need to perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个动画，通常需要执行以下步骤：
- en: Create an animation object (such as `QPropertyAnimation`)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个动画对象（例如`QPropertyAnimation`）
- en: Set the object that should be animated
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应进行动画的对象
- en: Set the name of the property to be animated
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置要动画化的属性名称
- en: Define how exactly the value should change (for example, set starting and ending
    values)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义值应该如何精确地改变（例如，设置起始和结束值）
- en: Start the animation
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画
- en: As you probably know, calling an arbitrary method by name is not possible in
    C++, and yet, the animation objects are able to change arbitrary properties at
    will. This is possible because "property" is not only a fancy name, but also another
    powerful feature of the `QObject` class and Qt meta-object compiler.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在C++中通过名称调用任意方法是不可能的，而动画对象却能随意更改任意属性。这是因为“属性”不仅是一个花哨的名称，也是`QObject`类和Qt元对象编译器的一个强大功能。
- en: Properties
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: In [Chapter 3](ebffc011-752f-4dbe-a383-0917a002841d.xhtml), *Qt GUI Programming*,
    we edited predefined properties of widgets in the form editor and used their getter
    and setter methods in the code. However, until now, there wasn't a real reason
    for us to declare a new property. It'll be useful with the Animation framework,
    so let's pay more attention to properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ebffc011-752f-4dbe-a383-0917a002841d.xhtml)，“Qt GUI编程”，我们在表单编辑器中编辑了小部件的预定义属性，并在代码中使用它们的获取器和设置器方法。然而，直到现在，我们还没有真正的原因去声明一个新的属性。在动画框架中这将很有用，所以让我们更加关注属性。
- en: 'Only classes that inherit `QObject` can declare properties. To create a property,
    we first need to declare it in a private section of the class (usually right after
    the `Q_OBJECT` mandatory macro) using a special `Q_PROPERTY` macro. That macro
    allows you to specify the following information about the new property:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有继承自`QObject`的类可以声明属性。要创建一个属性，我们首先需要在类的私有部分（通常在`Q_OBJECT`强制宏之后）使用特殊的`Q_PROPERTY`宏声明它。该宏允许你指定关于新属性的信息：
- en: The property name—a string that identifies the property in the Qt meta system.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名称——一个字符串，用于在Qt元系统中标识属性。
- en: The property type—any valid C++ type can be used for a property, but animations
    will only work with a limited set of types.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性类型——任何有效的C++类型都可以用于属性，但动画仅与有限的一组类型一起工作。
- en: Names of the getter and setter method for this property. If declared in `Q_PROPERTY`,
    you must add them to your class and implement them properly.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该属性的获取器和设置器方法的名称。如果在`Q_PROPERTY`中声明，你必须将它们添加到你的类中并正确实现它们。
- en: Name of the signal that is emitted when the property changes. If declared in
    `Q_PROPERTY`, you must add the signal and ensure that it's properly emitted.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性改变时发出的信号名称。如果在`Q_PROPERTY`中声明，你必须添加该信号并确保它被正确发出。
- en: There are more configuration options, but they are less frequently needed. You
    can learn more about them from the The Property System documentation page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的配置选项，但它们不太常用。你可以从《属性系统文档页面》了解更多关于它们的信息。
- en: 'The Animation framework supports the following property types: `int`, `unsigned
    int`, `double`, `float`, `QLine`, `QLineF`, `QPoint`, `QPointF`, `QSize`, `QSizeF`,
    `QRect`, `QRectF`, and `QColor`. Other types are not supported, because Qt doesn''t
    know how to interpolate them, that is, how to calculate intermediate values based
    on the start and end values. However, it''s possible to add support for custom
    types if you really need to animate them.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 动画框架支持以下属性类型：`int`、`unsigned int`、`double`、`float`、`QLine`、`QLineF`、`QPoint`、`QPointF`、`QSize`、`QSizeF`、`QRect`、`QRectF`
    和 `QColor`。其他类型不受支持，因为 Qt 不知道如何插值它们，也就是说，不知道如何根据起始值和结束值计算中间值。然而，如果你真的需要为它们添加动画支持，是有可能添加对自定义类型的支持的。
- en: Similar to signals and slots, properties are powered by **moc**, which reads
    the header file of your class and generates extra code that enables Qt (and you)
    to access the property at runtime. For example, you can use the `QObject::property()`
    and `QObject::setProperty()` methods to get and set properties by name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与信号和槽类似，属性由 **moc** 驱动，它读取你的类的头文件并生成额外的代码，使 Qt（以及你）能够在运行时访问属性。例如，你可以使用 `QObject::property()`
    和 `QObject::setProperty()` 方法通过名称获取和设置属性。
- en: Time for action - Adding a jump animation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加跳跃动画
- en: 'Go to the `myscene.h` file and add a private `qreal m_jumpFactor` field. Next,
    declare a getter, a setter, and a change signal for this field:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `myscene.h` 文件并添加一个私有 `qreal m_jumpFactor` 字段。接下来，声明这个字段的获取器、设置器和更改信号：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the header file, we declare the `jumpFactor` property by adding the following
    code just after the `Q_OBJECT` macro:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们在 `Q_OBJECT` 宏之后添加以下代码来声明 `jumpFactor` 属性：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `qreal` is the type of the property, `jumpFactor` is the registered name,
    and the following three lines register the corresponding member functions of the `MyScene`
    class in the property system. We'll need this property to make Benjamin jump,
    as we will see later on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`qreal` 是属性的类型，`jumpFactor` 是注册的名称，接下来的三行注册了属性系统中 `MyScene` 类的相应成员函数。我们稍后会看到，我们需要这个属性来让本杰明跳跃。
- en: 'The `jumpFactor()` getter function simply returns the `m_jumpFactor` private
    member, which is used to store the actual position. The implementation of the
    setter looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`jumpFactor()` 获取函数简单地返回 `m_jumpFactor` 私有成员，它用于存储实际位置。设置器的实现如下：'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is important to check whether `pos` will change the current value of `m_jumpFactor`.
    If this is not the case, exit the function, because we don't want the change signal
    to be emitted even if nothing has changed. Otherwise, we set `m_jumpFactor` to
    `pos` and emit the signal that informs about the change.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `pos` 是否会改变 `m_jumpFactor` 的当前值非常重要。如果不是这样，退出函数，因为我们不希望即使没有任何变化也发出更改信号。否则，我们将
    `m_jumpFactor` 设置为 `pos` 并发出关于更改的信号。
- en: Property animations
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性动画
- en: We implemented the horizontal movement using a `QTimer`. Now, let's try a second
    way to animate items—the Animation framework.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `QTimer` 实现了水平移动。现在，让我们尝试第二种动画项目的方法——动画框架。
- en: Time for action - Using animations to move items smoothly
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用动画平滑移动项目
- en: 'Let''s add a new private member called `m_jumpAnimation` of the `QPropertyAnimation
    *` type, and initialize it in the constructor of `MyScene`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `MyScene` 的构造函数中添加一个新的私有成员 `m_jumpAnimation`，类型为 `QPropertyAnimation *`
    并进行初始化：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What just happened?
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: For the instance of `QPropertyAnimation` created here, we define the item as
    a parent; thus, the animation will get deleted when the scene deletes the item,
    and we don't have to worry about freeing the used memory. Then, we define the
    target of the animation—our `MyScene` class—and the property that should be animated, `jumpFactor`,
    in this case. Then, we define the start and the end value of that property; in
    addition to that, we also define a value in between, by setting `setKeyValueAt()`.
    The first argument of the `qreal` type defines time inside the animation, where
    0 is the beginning and 1 the end, and the second argument defines the value that
    the animation should have at that time. So your `jumpFactor` element will get
    animated from 0 to 1 and back to 0 in 800 milliseconds. This was defined by `setDuration()`.
    Finally, we define how the interpolation between the start and end value should
    be done and call `setEasingCurve()`, with `QEasingCurve::OutInQuad` as an argument.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在这里创建的 `QPropertyAnimation` 实例，我们将项目定义为父项；因此，当场景删除项目时，动画将被删除，我们不必担心释放使用的内存。然后，我们定义动画的目标——我们的
    `MyScene` 类——以及应该动画化的属性，在这种情况下是 `jumpFactor`。然后，我们定义该属性的起始和结束值；除此之外，我们还通过设置 `setKeyValueAt()`
    定义一个中间值。`qreal` 类型的第一个参数定义动画中的时间，其中 0 是开始，1 是结束，第二个参数定义动画在该时间应具有的值。因此，你的 `jumpFactor`
    元素将在 800 毫秒内从 0 动画到 1，然后再回到 0。这是由 `setDuration()` 定义的。最后，我们定义起始值和结束值之间的插值方式，并调用
    `setEasingCurve()`，将 `QEasingCurve::OutInQuad` 作为参数。
- en: Qt defines up to 41 different easing curves for linear, quadratic, cubic, quartic,
    quintic, sinusoidal, exponential, circular, elastic, back easing, and bounce functions.
    These are too many to describe here. Instead, take a look at the documentation;
    simply search for `QEasingCurve::Type`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 定义了多达 41 种不同的缓动曲线，用于线性、二次、三次、四次、五次、正弦、指数、圆形、弹性、回弹和弹跳函数。这些在这里难以一一描述。相反，请查看文档；只需简单地搜索
    `QEasingCurve::Type`。
- en: 'In our case, `QEasingCurve::OutInQuad` ensures that the jump speed of Benjamin
    looks like an actual jump: fast in the beginning, slow at the top, and fast at
    the end again. We start this animation with the `jump` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`QEasingCurve::OutInQuad` 确保本杰明的跳跃速度看起来像真正的跳跃：开始时快，顶部时慢，然后再次变快。我们使用
    `jump` 函数开始这个动画：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We only start the animation by calling `start()` when the animation isn''t
    running. Therefore, we check the animation''s state to see whether it has been
    stopped. Other states could be `Paused` or `Running`. We want this jump action
    to be activated whenever the player presses the Space key on their keyboard. Therefore,
    we expand the `switch` statement inside the key press event handler using this
    code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有在动画未运行时才通过调用 `start()` 来启动动画。因此，我们检查动画的状态，看它是否已被停止。其他状态可能是 `Paused` 或 `Running`。我们希望这个跳跃动作在玩家按下键盘上的空格键时被激活。因此，我们使用此代码扩展按键事件处理程序内的
    `switch` 语句：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the property gets animated, but Benjamin will still not jump. Therefore,
    we handle the changes of the `jumpFactor` value at the end of the `setJumpFactor`
    function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在属性开始动画，但本杰明仍然不会跳跃。因此，我们在 `setJumpFactor` 函数的末尾处理 `jumpFactor` 值的变化：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When our `QPropertyAnimation` is running, it will call our `setJumpFactor()`
    function to update the property's value. Inside that function, we calculate the
    *y* coordinate of the player item to respect the ground level defined by `m_groundLevel`.
    This is done by subtracting half of the item's height from the ground level's
    value since the item's origin point is in its center. Then, we subtract the maximum
    jump height, defined by `m_jumpHeight`, which is multiplied by the actual jump
    factor. Since the factor is in the range of 0 and 1, the new *y* coordinate stays
    inside the allowed jump height. Then, we alter the player item's *y* position
    by calling `setY()`, leaving the *x* coordinate as the same. Et voilà, Benjamin
    is jumping!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `QPropertyAnimation` 正在运行时，它将调用我们的 `setJumpFactor()` 函数来更新属性的值。在该函数内部，我们计算玩家项目的
    *y* 坐标，以尊重由 `m_groundLevel` 定义的地面水平。这是通过从地面水平值中减去项目高度的一半来完成的，因为项目原点在其中心。然后，我们减去由
    `m_jumpHeight` 定义的最大的跳跃高度，该高度乘以实际的跳跃因子。由于因子在 0 和 1 的范围内，新的 *y* 坐标保持在允许的跳跃高度内。然后，我们通过调用
    `setY()` 改变玩家项目的 *y* 位置，同时保持 *x* 坐标不变。Et voilà，本杰明正在跳跃！
- en: Have a go hero - Letting the item handle Benjamin's jump
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 让项目处理本杰明的跳跃
- en: Since the scene is already a `QObject`, adding a property to it was easy. However,
    imagine that you want to create a game for two players, each controlling a separate
    `Player` item. In this case, the jump factors of two elephants need to be animated
    independently, so you want to make an animated property in the `Player` class,
    instead of putting it to the scene.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于场景已经是`QObject`，向其中添加属性很容易。然而，想象一下，你想为两个玩家创建一个游戏，每个玩家控制一个单独的`Player`项。在这种情况下，两个大象的跳跃因子需要独立动画，所以你希望在`Player`类中创建一个动画属性，而不是将其放入场景中。
- en: 'The `QGraphicsItem` item and all standard items introduced so far don''t inherit 
    `QObject` and thus can''t have slots or emit signals; they don''t benefit from
    the `QObject` property system either. However, we can make them use `QObject`! All
    you have to do is add `QObject` as a base class and add the `Q_OBJECT` macro:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止引入的所有`QGraphicsItem`项和标准项都不继承`QObject`，因此不能有槽或发出信号；它们也不受益于`QObject`属性系统。然而，我们可以使它们使用`QObject`！你只需要将`QObject`作为基类，并添加`Q_OBJECT`宏：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now you can use properties, signals, and slots with items too. Be aware that `QObject` must
    be the first base class of an item.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用属性、信号和槽与项一起使用。请注意，`QObject`必须是项的第一个基类。
- en: A word of warning
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告
- en: Only use `QObject` with items if you really need its capabilities. `QObject`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在真正需要其功能时才使用`QObject`与项一起使用。`QObject`
- en: adds a lot of overhead to the item, which will have a noticeable impact on performance
    when you have many items, so use it wisely and not only because you can.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为项添加了很多开销，当你有许多项时，这将对性能产生明显影响，所以请明智地使用它，而不仅仅是因为你可以。
- en: If you make this change, you can move the `jumpFactor` property from `MyScene`
    to `Player`, along with a lot of related code. You can make the code even more
    consistent by handling the horizontal movement in `Player` as well. Let `MyScene`
    handle the input events and forward the movement commands to `Player`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行这个更改，你可以将`jumpFactor`属性从`MyScene`移动到`Player`，以及大量相关代码。你还可以通过在`Player`中处理水平移动来使代码更加一致。让`MyScene`处理输入事件，并将移动命令转发给`Player`。
- en: Time for action - Keeping multiple animations in sync
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 保持多个动画同步
- en: 'Now we''ll start implementing the coin class. We can use a simple `QGraphicsEllipseItem`
    object, but we''ll need to animate its properties, so let''s create a new `Coin`
    class and derive it from `QObject` and `QGraphicsEllipseItem`. Define two properties:
    `opacity` of the `qreal` type and `rect` of the `QRect` type. This is done only
    by the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始实现硬币类。我们可以使用一个简单的`QGraphicsEllipseItem`对象，但我们需要对其属性进行动画处理，所以让我们创建一个新的`Coin`类，并从`QObject`和`QGraphicsEllipseItem`派生。定义两个属性：`opacity`为`qreal`类型和`rect`为`QRect`类型。这只需以下代码即可完成：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: No function or slot was added, because we simply used built-in functions of
    `QGraphicsItem` and associated them with the properties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 没有添加任何函数或槽，因为我们只是使用了`QGraphicsItem`的内置函数，并将它们与属性相关联。
- en: If you want an item that inherits from `QObject` and `QGraphicsItem`, you can
    directly inherit `QGraphicsObject`. Moreover, it already registers all general
    `QGraphicsItem` properties in the metasystem, including `pos`, `scale`, `rotation`,
    and `opacity`. All properties come with corresponding notification signals, such
    as `opacityChanged()`. However, when you inherit `QGraphicsObject`, you cannot,
    at the same time, inherit `QGraphicsEllipseItem` or any other item class. So in
    this case, we will need to either implement painting of the ellipse manually or
    add a child `QGraphicsEllipseItem` that can perform the painting for us.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个继承自`QObject`和`QGraphicsItem`的项，你可以直接继承`QGraphicsObject`。此外，它已经将所有通用的`QGraphicsItem`属性注册到元系统中，包括`pos`、`scale`、`rotation`和`opacity`。所有属性都带有相应的通知信号，例如`opacityChanged()`。然而，当你继承`QGraphicsObject`时，你不能同时继承`QGraphicsEllipseItem`或任何其他项类。因此，在这种情况下，我们需要手动实现椭圆的绘制，或者添加一个可以为我们执行绘制的子`QGraphicsEllipseItem`。
- en: 'Next, we''ll create the `explode()` function that will start some animations
    when the player collects the coin. Create a Boolean private field in the class
    and use it to ensure that each coin can only explode once:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`explode()`函数，当玩家收集到硬币时，该函数将启动一些动画。在类中创建一个布尔私有字段，并使用它来确保每个硬币只能爆炸一次：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We want to animate our two properties by two `QPropertyAnimation` objects.
    One fades the coin out, while the other scales the coin in. To ensure that both
    animations get started at the same time, we use `QParallelAnimationGroup`, as
    follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想通过两个`QPropertyAnimation`对象来动画化我们的两个属性。一个使硬币淡出，另一个使硬币放大。为了确保两个动画同时开始，我们使用`QParallelAnimationGroup`，如下所示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What just happened?
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: You already know how to set up a single property animation, so we omitted the
    code for it. After setting up both animations, we add them to the group animation
    by calling `addAnimation()` on the group, while passing a pointer to the animation
    we would like to add. Then, when we start the group; `QParallelAnimationGroup`
    ensures that all assigned animations start at the same time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何设置单个属性动画，所以我们省略了它的代码。在设置好两个动画后，我们通过在组动画上调用`addAnimation()`并将我们想要添加的动画的指针传递给它，将它们添加到组动画中。然后，当我们启动组时，`QParallelAnimationGroup`确保所有分配的动画同时开始。
- en: When both animations have finished, `group` will emit the `finished()` signal.
    We connected that signal to the `deleteLater()` slot of our class so that the
    coin object gets deleted when it's no longer visible. This handy slot is declared
    in the `QObject` class and is useful in many cases.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个动画都完成时，`group`将发出`finished()`信号。我们将该信号连接到我们类的`deleteLater()`槽，这样当硬币对象不再可见时，它就会被删除。这个实用的槽在`QObject`类中声明，并在许多情况下很有用。
- en: In some cases, you may want to stop an animation. You can do that by calling
    the `stop()` method. It's also possible to pause and resume an animation using
    `pause()` and `resume()`. Using these methods on a `QParallelAnimationGroup` will
    affect all transformations added to that group.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想停止一个动画。你可以通过调用`stop()`方法来实现。你也可以使用`pause()`和`resume()`方法暂停和恢复动画。在`QParallelAnimationGroup`上使用这些方法将影响该组添加的所有变换。
- en: Chaining multiple animations
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接多个动画
- en: 'What if we wanted to perform an animation at the end of another animation?
    We could connect the `finished()` signal of the first animation to the `start()`
    slot of the second one. However, a much more convenient solution is to use `QSequentialAnimationGroup`.
    For example, if we want coins to scale and *then* to fade, the following code
    will do the trick:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在另一个动画的末尾执行一个动画，我们可以将第一个动画的`finished()`信号连接到第二个动画的`start()`槽。然而，一个更方便的解决方案是使用`QSequentialAnimationGroup`。例如，如果我们想让硬币先放大然后淡出，以下代码就能实现这个效果：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding gamepad support
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加游戏手柄支持
- en: The player can use the keyboard to play our game, but it would be nice to also
    allow playing it using a gamepad. Fortunately, Qt provides the Qt Gamepad add-on
    that allows us to do this easily. As opposed to Qt Essentials (for example, Qt
    Widgets), add-ons may be supported on a limited number of platforms. As of Qt
    5.9, Qt Gamepad supports Windows, Linux, Android, macOS, iOS, and tvOS (including
    the tvOS remote).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以使用键盘来玩我们的游戏，但允许使用游戏手柄来玩会更好。幸运的是，Qt提供了Qt Gamepad插件，使我们能够轻松实现这一点。与Qt Essentials（例如Qt
    Widgets）不同，插件可能只在有限数量的平台上受支持。截至Qt 5.9，Qt Gamepad支持Windows、Linux、Android、macOS、iOS和tvOS（包括tvOS遥控器）。
- en: Working with gamepads in Qt
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt中使用游戏手柄
- en: The starting point of the gamepad API is the `QGamepadManager` class. The singleton
    object of this class can be obtained using the `QGamepadManager::instance()` function.
    It allows you to request the list of identifiers of the available gamepads using
    the `connectedGamepads()` function. The `gamepadConnected()` signal can be used
    to detect new gamepads on the fly. `QGamepadManager` also provides API for configuring
    buttons and axes on the gamepad and is able to save the configuration to the specified
    settings file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏手柄API的起点是`QGamepadManager`类。可以使用`QGamepadManager::instance()`函数获取该类的单例对象。它允许你使用`connectedGamepads()`函数请求可用游戏手柄的标识符列表。可以使用`gamepadConnected()`信号实时检测新的游戏手柄。`QGamepadManager`还提供了配置游戏手柄按钮和轴的API，并且能够将配置保存到指定的设置文件中。
- en: After you detected that one or multiple gamepads are available in the system,
    you should create a new `QGamepad` object and pass the obtained device identifier
    as a constructor's argument. You can use the first available gamepad or allow
    the user to select which gamepad to use. In this case, you can utilize the gamepad's `name`
    property that returns a readable name of the device.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到系统中有可用的一个或多个游戏手柄后，你应该创建一个新的`QGamepad`对象，并将获得的设备标识符作为构造函数的参数传递。你可以使用第一个可用的游戏手柄，或者允许用户选择要使用哪个游戏手柄。在这种情况下，你可以利用游戏手柄的`name`属性，它返回设备的可读名称。
- en: The `Gamepad` object contains a dedicated property for each axis and button.
    This gives you two ways to receive the information about the state of the controls. First,
    you can use the getter of the property to check the current state of a button
    or an axis. For example, the `buttonL1()` function will return `true` if the L1
    button is currently pressed, and the `axisLeftX()` will return the current horizontal
    position of the left stick as a `double` value that is in the range of -1 to 1\.
    For trigger buttons (for example, `buttonL2()`), the property contains a `double`
    value that ranges from 0 (not pressed) to 1 (fully pressed).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gamepad` 对象包含每个轴和按钮的专用属性。这为你提供了两种接收控制状态信息的方式。首先，你可以使用属性的获取器来检查按钮或轴的当前状态。例如，`buttonL1()`
    函数将在 L1 按钮当前被按下时返回 `true`，而 `axisLeftX()` 将返回左摇杆当前水平位置的 `double` 值，该值在 -1 到 1
    的范围内。对于触发按钮（例如，`buttonL2()`），属性包含一个从 0（未按下）到 1（完全按下）的范围内的 `double` 值。'
- en: The second way is to use the signals corresponding to each property. For example,
    you can connect to the gamepad's `buttonL1Changed(bool value)` and `axisLeftXChanged(double
    value)` signals to monitor the changes of the corresponding properties.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是使用对应每个属性的信号。例如，你可以连接到游戏手柄的 `buttonL1Changed(bool value)` 和 `axisLeftXChanged(double
    value)` 信号来监控相应属性的变化。
- en: Finally, the `QGamepadKeyNavigation` class can be used to quickly add gamepad
    support to a keyboard-oriented application. When you create an object of this
    class, your application will begin receiving key events caused by gamepads. By
    default, `GamepadKeyNavigation` will emulate up, down, left, right, back, forward,
    and return keys when the corresponding gamepad buttons are pressed. However, you
    can override the default mapping or add your own mapping for other gamepad buttons.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`QGamepadKeyNavigation` 类可以用来快速为以键盘为导向的应用程序添加游戏手柄支持。当你创建这个类的对象时，你的应用程序将开始接收由游戏手柄引起的关键事件。默认情况下，`GamepadKeyNavigation`
    将在相应的游戏手柄按钮被按下时模拟上、下、左、右、后退、前进和回车键。然而，你可以覆盖默认映射或为其他游戏手柄按钮添加自己的映射。
- en: Time for action - Handling gamepad events
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 处理游戏手柄事件
- en: 'Let''s start with adding the Qt Gamepad add-on to our project by editing the `jrgame.pro` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通过编辑 `jrgame.pro` 文件将 Qt 游戏手柄插件添加到我们的项目中开始：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will make the headers of the library available to our project and tell `qmake` to
    link the project against this library. Now add the following code to the constructor
    of the `MyScene` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使库的标题对我们项目可用，并告诉 `qmake` 将项目链接到这个库。现在将以下代码添加到 `MyScene` 类的构造函数中：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code is pretty straightforward. First, we use
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当直接。首先，我们使用
- en: '`QGamepadManager::connectedGamepads`  to get the list of IDs of the available
    gamepads. If some gamepads were found, we create a `QGamepad` object for the first
    found gamepad. We pass `this` to its constructor, so it becomes a child of our `MyScene` object,
    and we don''t need to worry about deleting it. Finally, we connect the gamepad''s `axisLeftXChanged()` and `axisLeftYChanged()` signals
    to new slots in the `MyScene` class. Now, let''s implement these slots:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QGamepadManager::connectedGamepads` 获取可用游戏手柄的ID列表。如果找到了一些游戏手柄，我们为第一个找到的游戏手柄创建一个
    `QGamepad` 对象。我们将 `this` 传递给其构造函数，使其成为我们的 `MyScene` 对象的子对象，因此我们不需要担心删除它。最后，我们将游戏手柄的
    `axisLeftXChanged()` 和 `axisLeftYChanged()` 信号连接到 `MyScene` 类中的新槽位。现在，让我们实现这些槽位：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `value` argument of the signals contains a number from -1 to 1\. It allows
    us not
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 信号的 `value` 参数包含一个从 -1 到 1 的数字。这允许我们
- en: only to detect whether a thumbstick was pressed, but also to get more precise
    information
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅要检测是否有摇杆被按下，还要获取更精确的信息
- en: about its position. However, in our simple game, we don't need this precision.
    In the `axisLeftXChanged()` slot, we calculate and set the elephant's `direction` based
    on the sign of the received value. In the `axisLeftYChanged()` slot, if we receive
    a large enough negative value, we interpret it as a `jump` command. This will
    help us avoid accidental jumps. That's all! Our game now supports both keyboards
    and gamepads.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于其位置。然而，在我们的简单游戏中，我们不需要这种精度。在 `axisLeftXChanged()` 槽位中，我们根据接收到的值的符号计算并设置大象的
    `direction`。在 `axisLeftYChanged()` 槽位中，如果我们收到足够大的负值，我们将其解释为 `jump` 命令。这将帮助我们避免意外跳跃。就这样！我们的游戏现在支持键盘和游戏手柄。
- en: If you need to react to other buttons and thumbsticks of the gamepad, use the
    other signals of the `QGamepad` class. It's also possible to read multiple gamepads
    at the same time by creating multiple `QGamepad` objects with different IDs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要响应游戏手柄上的其他按钮和摇杆，请使用`QGamepad`类的其他信号。同时读取多个游戏手柄也是可能的，通过创建具有不同ID的多个`QGamepad`对象来实现。
- en: Item collision detection
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目碰撞检测
- en: Whether the player item collides with a coin is checked by the scene's `checkColliding()`
    function, which is called after the player item has moved horizontally or vertically.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检查玩家项目是否与硬币碰撞是通过场景的`checkColliding()`函数来完成的，该函数在玩家项目水平或垂直移动后调用。
- en: Time for action - Making the coins explode
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使硬币爆炸
- en: 'The implementation of `checkColliding()` looks like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkColliding()`函数的实现如下：'
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What just happened?
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, we call the scene's `QGraphicsScene::collidingItems()` function, which
    takes the item for which colliding items should be detected as a first argument.
    With the second, optional argument, you can define how the collision should be
    detected. The type of that argument is `Qt::ItemSelectionMode`, which was explained
    earlier. By default, an item will be considered colliding with `m_player` if the
    shapes of the two items intersect.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用场景的`QGraphicsScene::collidingItems()`函数，它接受一个参数，即要检测碰撞项目的项。通过第二个可选参数，你可以定义如何检测碰撞。该参数的类型是`Qt::ItemSelectionMode`，这在前面已经解释过了。默认情况下，如果一个项目的形状与`m_player`相交，则认为该项目与`m_player`发生碰撞。
- en: Next, we loop through the list of found items and check whether the current
    item is a `Coin` object. This is done by trying to cast the pointer to `Coin`.
    If it is successful, we explode the coin by calling `explode()`. Calling the `explode()`
    function multiple times is no problem, since it will not allow more than one explosion.
    This is important since `checkColliding()` will be called after each movement
    of the player. So the first time the player hits a coin, the coin will explode,
    but this takes time. During this explosion, the player will most likely be moved
    again and thus collides with the coin once more. In such a case, `explode()` may
    be called multiple times.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历找到的项目列表，检查当前项目是否是`Coin`对象。这是通过尝试将指针转换为`Coin`来完成的。如果成功，我们通过调用`explode()`来使硬币爆炸。多次调用`explode()`函数没有问题，因为它不会允许发生多次爆炸。这很重要，因为`checkColliding()`将在玩家的每次移动之后被调用。所以当玩家第一次击中硬币时，硬币会爆炸，但这需要时间。在这场爆炸期间，玩家很可能会再次移动，因此会再次与硬币碰撞。在这种情况下，`explode()`可能会被多次调用。
- en: The `qgraphicsitem_cast<>()` is a faster alternative to `dynamic_cast<>()`.
    However, it will properly work for custom types only if they implement `type()`
    properly. This virtual function must return a different value for each custom
    item class in the application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`qgraphicsitem_cast<>()`是`dynamic_cast<>()`的一个更快的替代品。然而，只有当自定义类型正确实现了`type()`时，它才会正确地工作。这个虚拟函数必须为应用程序中的每个自定义项目类返回不同的值。'
- en: 'The `collidingItems()` function will always return the background items as
    well, since the player item is above all of them most of the time. To avoid the
    continuous check if they actually are coins, we use a trick. Instead of using `QGraphicsPixmapItem`
    directly, we subclass it and reimplement its virtual `shape()` function, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`collidingItems()`函数总是会返回背景项目，因为玩家项目通常位于所有这些项目之上。为了避免持续检查它们是否实际上是硬币，我们使用了一个技巧。我们不是直接使用`QGraphicsPixmapItem`，而是从它派生出一个子类并重新实现其虚拟`shape()`函数，如下所示：'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We already used the `QPainterPath` class in the previous chapter. This function
    just returns an empty `QPainterPath`. Since the collision detection is done with
    the item's shape, the background items can't collide with any other item since
    their shape is permanently empty. Don't try this trick with `boundingRect()` though,
    because it must always be valid.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中使用了`QPainterPath`类。这个函数只是返回一个空的`QPainterPath`。由于碰撞检测是通过项目的形状来完成的，背景项目不能与其他任何项目发生碰撞，因为它们的形状始终是空的。不过，不要尝试使用`boundingRect()`来玩这个技巧，因为它必须始终有效。
- en: Had we done the jumping logic inside `Player`, we could have implemented the
    item collision detection from within the item itself. `QGraphicsItem` also offers
    a `collidingItems()` function that checks against colliding items with itself.
    So `scene->collidingItems(item)` is equivalent to `item->collidingItems()`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`Player`内部实现跳跃逻辑，我们就可以从项目本身内部实现项目碰撞检测。`QGraphicsItem`还提供了一个`collidingItems()`函数，用于检查与自身碰撞的项目。所以`scene->collidingItems(item)`等同于`item->collidingItems()`。
- en: If you are only interested in whether an item collides with another item, you
    can call `collidesWithItem()` on the item, passing the other item as an argument.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只关心一个物品是否与另一个物品发生碰撞，你可以在该物品上调用`collidesWithItem()`方法，并将另一个物品作为参数传递。
- en: Finishing the game
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成游戏
- en: 'The last part we have to discuss is the scene''s initialization. Set the initial
    values for all fields and the constructor, create the `initPlayField()` function
    that will set up all the items, and call that function in the constructor. First, we
    initialize the sky, trees, ground, and player item:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须讨论的最后一部分是场景的初始化。为所有字段和构造函数设置初始值，创建一个`initPlayField()`函数来设置所有物品，并在构造函数中调用该函数。首先，我们初始化天空、树木、地面和玩家物品：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we create coin objects:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建金币对象：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In total, we are adding 25 coins. First, we set up an invisible item with the
    size of the virtual world, called `m_coins`. This item should be the parent to
    all coins. Then, we calculate the width between `m_minX` and `m_maxX`. That is
    the space where Benjamin can move. To make it a little bit smaller, we only take
    94 percent of that width. Then, in the `for` loop, we create a coin and randomly
    set its *x* and *y* position, ensuring that Benjamin can reach them by calculating
    the modulo of the available width and of the maximal jump height. After all 25
    coins are added, we place the parent item holding all the coins on the scene.
    Since most coins are outside the actual view''s rectangle, we also need to move
    the coins while Benjamin is moving. Therefore, `m_coins` must behave like any
    other background. For this, we simply add the following code to the `movePlayer()`
    function, where we also move the background by the same pattern:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 总共我们添加了25个金币。首先，我们设置一个大小与虚拟世界相同、不可见的物品，称为`m_coins`。这个物品应该是所有金币的父级。然后，我们计算`m_minX`和`m_maxX`之间的宽度。这是本杰明可以移动的空间。为了使其稍微小一点，我们只取94%的宽度。然后，在`for`循环中，我们创建一个金币并随机设置其*x*和*y*位置，确保本杰明可以通过计算可用宽度和最大跳跃高度的模数来到达它们。添加完所有25个金币后，我们将持有所有金币的父级物品放置在场景中。由于大多数金币都在实际视图矩形之外，我们还需要在移动本杰明时移动金币。因此，`m_coins`必须像任何其他背景一样表现。为此，我们只需将以下代码添加到`movePlayer()`函数中，我们在其中也以相同的模式移动背景：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Have a go hero - Extending the game
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 扩展游戏
- en: That's it. This is our little game. Of course, there is much room to improve
    and extend it. For example, you can add some barricades Benjamin has to jump over.
    Then, you would have to check whether the player item collides with such a barricade
    item when moving forward, and if so, refuse movement. You have learned all the
    necessary techniques you need for that task, so try to implement some additional
    features to deepen your knowledge.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这是我们的小游戏。当然，还有很多改进和扩展的空间。例如，你可以添加一些本杰明需要跳过的障碍物。然后，你将不得不检查玩家物品在向前移动时是否与这样的障碍物发生碰撞，如果是，则拒绝移动。你已经学会了完成这项任务所需的所有必要技术，所以尝试实现一些额外的功能来加深你的知识。
- en: A third way of animation
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画的第三种方式
- en: Besides `QTimer` and `QPropertyAnimation`, there is a third way to animate the
    scene. The scene provides a slot called `advance()`. If you call that slot, the
    scene will forward that call to all items it holds by calling `advance()` on each
    one. The scene does that twice. First, all item `advance()` functions are called
    with `0` as an argument. This means that the items are about to advance. Then,
    in the second round, all items are called passing 1 to the item's `advance()`
    function. In that phase, each item should advance, whatever that means—maybe moving,
    maybe a color change, and so on. The scene's slot advance is typically called
    by a `QTimeLine` element; with this, you can define how many times during a specific
    period of time the timeline should be triggered.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`QTimer`和`QPropertyAnimation`之外，还有第三种方法可以动画化场景。场景提供了一个名为`advance()`的槽。如果你调用该槽，场景将通过在每一个物品上调用`advance()`方法将调用传递给它所持有的所有物品。场景这样做两次。首先，所有物品的`advance()`函数都使用`0`作为参数被调用。这意味着物品即将前进。然后，在第二轮中，所有物品都被调用，并将`1`传递给物品的`advance()`函数。在这个阶段，每个物品都应该前进，无论这意味着什么——可能是移动，可能是颜色变化，等等。场景的`advance`槽通常由一个`QTimeLine`元素调用；通过这个，你可以定义在特定时间段内时间轴应该被触发多少次。
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This timeline will emit the `frameChanged()` signal every 5 seconds for 10 times.
    All you have to do is connect that signal to the scene's `advance()` slot, and
    the scene will advance 10 times in 50 seconds. However, since all items receive
    two calls for each advance, this may not be the best animation solution for scenes
    with a lot of items where only a few should advance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此时间表将在 10 次内每 5 秒发出一次 `frameChanged()` 信号。你所要做的就是将此信号连接到场景的 `advance()` 槽，场景将在
    50 秒内前进 10 次。然而，由于每个前进都会对每个项目进行两次调用，这可能不是场景中有许多项目而只有少数应该前进的最佳动画解决方案。
- en: Pop quiz
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which of the following is a requirement for animating a property?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 以下哪项是动画属性的要求？
- en: The name of the property must start with "`m_`".
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性的名称必须以 "`m_`" 开头。
- en: Getter and setter of the property must be slots.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性的获取器和设置器必须是槽。
- en: The property must be declared using the `Q_PROPERTY` macro.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性必须使用 `Q_PROPERTY` 宏声明。
- en: Q2\. Which class sends a signal when a gamepad button is pressed or released?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 哪个类在游戏手柄按钮被按下或释放时发送信号？
- en: '`QGamepad`'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGamepad`'
- en: '`QWidget`'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QWidget`'
- en: '`QGraphicsScene`'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsScene`'
- en: Q3\. What is the difference between the `shape()` and `boundingRect()` functions
    of `QGraphicsItem`?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. `QGraphicsItem` 的 `shape()` 和 `boundingRect()` 函数之间的区别是什么？
- en: '`shape()` returns the bounding rectangle as a `QPainterPath` instead of a `QRectF`'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shape()` 返回一个 `QPainterPath` 作为边界矩形，而不是 `QRectF`'
- en: '`shape()` causes the item to be repainted.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shape()` 导致项目被重新绘制。'
- en: '`share()` can return a more precise description of the item''s boundaries than
    `boundingRect()`'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`share()` 可以返回比 `boundingRect()` 更精确的项目边界描述'
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you deepened your knowledge about items, about the scene, and
    about the view. While developing the game, you became familiar with different
    approaches of how to animate items, and you were taught how to detect collisions.
    As an advanced topic, you were introduced to parallax scrolling.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你加深了对项目、场景和视图的知识。在开发游戏的过程中，你熟悉了不同的动画项目的方法，并学习了如何检测碰撞。作为一个高级话题，你被引入了视差滚动的概念。
- en: After having completed the two chapters describing Graphics View, you should
    now know almost everything about it. You are able to create complete custom items,
    you can alter or extend standard items, and with the information about the level
    of detail, you even have the power to alter an item's appearance, depending on
    its zoom level. You can transform items and the scene, and you can animate items
    and thus the entire scene.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成描述图形视图的两个章节之后，你现在应该几乎了解关于图形视图的所有内容。你能够创建完整的自定义项目，你可以修改或扩展标准项目，并且根据细节级别，你甚至有权根据缩放级别改变项目的外观。你可以变换项目和场景，并且你可以动画化项目以及整个场景。
- en: Furthermore, as you saw while developing the game, your skills are good enough
    to develop a jump-and-run game with parallax scrolling, as it is used in highly
    professional games. We also learned how to add gamepad support to our game. To
    keep it fluid and highly responsive, finally we saw some tricks on how to get
    the most out of Graphics View.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你在开发游戏时所看到的，你的技能足够开发一个具有视差滚动的跳跃和跑酷游戏，正如它在高度专业的游戏中所使用的那样。我们还学习了如何将游戏手柄支持添加到我们的游戏中。为了保持流畅和高度响应，最后我们看到了如何充分利用图形视图的一些技巧。
- en: When we worked with widgets and the Graphics View framework, we had to use some
    general purpose Qt types, such as `QString` or `QVector`. In simple cases, their
    API is pretty obvious. However, these and many other classes provided by Qt Core
    module are very powerful, and you will greatly benefit from deeper knowledge of
    them. When you develop a serious project, it's very important to understand how
    these basic types work and what dangers they may pose when used incorrectly. In
    the next chapter, we will turn our attention to this topic. You will learn how
    you can work with text in Qt, which containers you should use in different cases,
    and how to manipulate various kind of data and implement a persistent storage.
    This is essential for any game that is more complicated than our simple examples.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与小部件和图形视图框架一起工作时，我们必须使用一些通用目的的 Qt 类型，例如 `QString` 或 `QVector`。在简单的情况下，它们的
    API 很明显。然而，Qt 核心模块提供的这些和其他许多类都非常强大，你将极大地从对它们的深入了解中受益。当你开发一个严肃的项目时，了解这些基本类型的工作原理以及它们在使用不当时可能带来的危险非常重要。在下一章中，我们将关注这个话题。你将学习如何在
    Qt 中处理文本，在不同情况下应该使用哪些容器，以及如何操作各种类型的数据和实现持久化存储。这对于任何比我们的简单示例更复杂的游戏都是必不可少的。
