- en: Machines Talking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine automation and IoT use various APIs for communication with each other.
  prefs: []
  type: TYPE_NORMAL
- en: I like to say that you cannot have IoT without sensors. They truly define IoT.
    Sensors are everywhere these days. Cars, lights, and mobile phones all have a
    myriad of sensors. Laptop computers have led, light, touch, and proximity sensors.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT and WebSockets are communication and messaging protocols. One use of them
    is to send sensors to remote locations.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about using Qt APIs for machine-to-machine automation and communication
    to web applications using the `QWebSocket` and `QWebSocketServer` classes.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT is a publish-and-subscribe-based TCP/IP protocol for sending sensor data
    over a limited bandwidth network using `QMqttMessage` to a `QMqttClient` and `QMqttSubscription`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sensory control **- QtSensor data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebSockets **- Bi-directional web communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QMqtt **- Brokers of machine talk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensory control – QtSensor data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt Sensors API started with Qt Mobility, which itself grew from Qtopia,
    which was later renamed Qt Extended.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Mobility was a collection of APIs useful for mobile and embedded devices.
    It was intended specifically for use in Nokia phones. Some of the Mobility API
    was integrated into Qt 4 and later into Qt 5.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Sensors, on the other hand, was put into its own repository when Qt 5 split
    into modules. Qt Sensors started out targeting mobile phone platforms, but as
    computers, such as laptops and Raspberry Pis, gained sensors, the backends expanded.
    You can find backends for iOS, Android, WinRT, generic Linux, Sensorfw, as well
    as Texas Instrument's SensorTag. At my GitHub repository, you can find additional
    sensor backends for Raspberry Pi Sense HAT, and MATRIX Creator for Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sensor Framework** (**SensorFW**) is a framework and backend for configuring
    and reading sensor data in a variety of ways. It is tried, tested, and used on
    some of the best alternative mobile devices. It has support for Hybris (which
    is used in Sailfish OS), Linux IIO sensors, as well as for reading directly from
    the Linux filesystem. If you are integrating a new device and need to read various
    sensors, I recommend using Sensor Framework, available from [https://git.merproject.org/mer-core/sensorfw/](https://git.merproject.org/mer-core/sensorfw/)[. ](https://git.merproject.org/mer-core/sensorfw/)'
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of different sensors for monitoring the environment. Qt Sensors
    handles the most common sensors found in mobile phones and tablets, and provides
    tools to help implement new sensor types that may be developed and become popular.
  prefs: []
  type: TYPE_NORMAL
- en: Not only are sensors for monitoring the environment; they can also be used as
    an input to the system. The Qt Sensor API includes an ad-hoc `QSensorGestures`,
    which is an API for various device gestures, such as shake, free-fall, hover,
    cover, turnover, and pickup.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Sensors has the C++ and QML APIs. Let's start with the C++ API.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually three ways to use this API. The first is the generic way.
    All the sensor classes are derived from `QSensor`. A more generic way to use them
    is to just use `QSensor`.
  prefs: []
  type: TYPE_NORMAL
- en: QSensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QSensor` has two static functions that we can use. `QSensor::sensorTypes()` which
    returns a `QList` of sensor types; for example, it could be `QLightSensor` or
    `QOrientationSensor`. You can then use `QSensor::sensorForType` or `defaultSensorForType`.
    Usually there is only one sensor for a type, so, using the latter will suffice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need to tell `qmake` that we want to use the `sensors` module,
    so in the `.pro` file, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter07-1` directory,
    in the `cp7` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To include all `QSensors` headers, the include file line is `#include <QtSensors>`,
    so let's add this to our file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a list of all sensor types known to the system by using `QSensor::sensorTypes()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`QSensor` is created by supplying a `QSensor::type` argument, and then you
    call the `setIdentifier` function with a `String` indicating the sensor you want
    to use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a `QSensor`. You must then call `connectToBackend()` if you are
    using `QSensor` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then connect to the `readingChanged()` signal and read the values from
    there. To get the `QSensor`, you can use the `sender()` function in any slot,
    and then `qobject_cast` to cast to a `QSensor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readingChanged()` slot looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We cast the `QSensor` using the `sender()` function, which returns the object
    that the slot is connected to. We then use that to get the `QSensorReading` using
    the `reading()` function. From the reading, we can get the values the sensor signaled
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: We still need to call `start()` on the sensor, so we will add this somewhere
    after we connect to the `readingChanged()` signal. This will activate the sensor's backend
    and start reading data from the device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another way to access a sensor, and that is by using a `QSensor` subclass.
    Let''s have a look at how we will use `QSensor` as a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: The QSensor subclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more popular way to use Qt Sensors is to use the standard `QSensors` derived
    classes, such as `QLightSensor` or `QAccelerometer`. This is useful if you know
    exactly which sensors your device has or what you are going to use. It also reduces
    the need for type-casting. In this way, it is also easier to use a class''s sensor-specific
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of a generic `QSensorReading`, we get a sensor specific reading, `QLightReading`
    in this case, with a sensor-specific value accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another way to access sensor data is to use a `QSensorFilter`. Let's go there.
  prefs: []
  type: TYPE_NORMAL
- en: QSensorFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a third way to access sensor data in C++, which is to use the sensor-specific
    filter class. This provides an efficient callback when signals and slots might
    be too slow, as in the case of `QAccelerometer` and other motion sensors which
    might be running at 200 cycles per second. It also provides a way to apply one
    or more filters that affect the values before they get emitted by the sensor reading
    signals. You could provide additional smoothing and noise reduction, or amplify
    the signal to a greater range.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, our class would inherit from `QLightFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We then implement the filter override.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `filter` function returns `true`, it will store the `QLightReading`
    of the `QLightSensor` and the new values will be emitted by, in our case, the
    `QLightSensor` class. Let''s apply a simple moving-average filter to our light
    sensor data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then create a new `LightFilter` object and set `QLightSensor` to use
    it. Add this before the call to `start()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now let's find out about the `QSensor` data and how to access it.
  prefs: []
  type: TYPE_NORMAL
- en: QSensor data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QSensor` has values that are specific to the respective sensor. You can access
    them either generically with `QSensor`, or by sensor value.'
  prefs: []
  type: TYPE_NORMAL
- en: QSensorReading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are using the more generic `QSensor` class, there is a corresponding
    `QSensorReading` that you can use to retrieve the generic data. For getting any
    sensor-specific data you will need to use the corresponding sensors'' `QSensorReading`
    subclass, such as `QAccelerometerReading`. For example, if we are using the `QSensor`
    to grab accelerometer data, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, using the `QAccelerometer` and `QAccelerometerReading` classes to do
    the same thing, would look like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some data explanations for common sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sensor reading** | **Values** | **Unit** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `QAccelerometerReading` | `x`, `y`, `z` | ms², meters per second squared
    | Linear acceleration along x, y, z axis |'
  prefs: []
  type: TYPE_TB
- en: '| `QAltimeterReading` | `altitude` | Meters | Meters above average sea level
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QAmbientLightReading` | `lightLevel` | Dark, Twilight, Light, Bright, Sunny
    | General light level |'
  prefs: []
  type: TYPE_TB
- en: '| `QAmbientTemperatureReading` | `temperature` | Celsius | Degrees Celsius
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QCompassReading` | `azimuth` | Degrees | Degrees from magnetic north |'
  prefs: []
  type: TYPE_TB
- en: '| `QGyroscopeReading` | `x`, `y`, `z` | Degrees per second | Angular velocity
    around the axis |'
  prefs: []
  type: TYPE_TB
- en: '| `QHumidityReading` | `absoluteHumidity`,`relativeHumidty` | gm³, grams per
    cubic meter | Water vapor in air |'
  prefs: []
  type: TYPE_TB
- en: '| `QIrProximityReading` | `reflectance` | Decimal fraction 0 - 1 | How much
    infrared light was returned |'
  prefs: []
  type: TYPE_TB
- en: '| `QLidReading` | `backLidClosed`,`frontLidClosed` | Bool | Laptop lid |'
  prefs: []
  type: TYPE_TB
- en: '| `QLightReading` | `lux` | Lux | Light measured in lux |'
  prefs: []
  type: TYPE_TB
- en: '| `QMagnetometerReading` | `x`, `y`, `z` |  Magnetic flux density | Raw flux
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QOrientationReading` | `orientation` | TopUp, TopDown, LeftUp, RightUp,
    FaceUp, FaceDown | Enum device orientation |'
  prefs: []
  type: TYPE_TB
- en: '| `QPressureReading` | `pressure`, `temperature` | Pascals, Celsius | Atmospheric
    pressure |'
  prefs: []
  type: TYPE_TB
- en: '| `QProximityReading` | `close` | Bool | Close or far away |'
  prefs: []
  type: TYPE_TB
- en: '| `QRotationReading` | `x`, `y`, `z` | Degrees | Rotation around axis in degrees
    |'
  prefs: []
  type: TYPE_TB
- en: Some of these have sensor-specific readings, such as `QCompass` and `QMagnetometer`—both
    contain calibration levels.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, C++ is not the only way to implement Qt's sensors; you can use them
    in QML as well. Let's find out how.
  prefs: []
  type: TYPE_NORMAL
- en: QML sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, you can also use Qt Sensors from QML. In a lot of ways, it is easier
    to implement them this way, as the Qt Quick API has been optimized and simplified,
    so it takes less time to get the sensor up and running. Following our previous
    use of the light sensors, we will continue here. First off is the ever-present
    `import` statement: instead of calling a `start()` function to get it rolling,
    there is an `active` property. Instead of a `Lux` value, the property is `illuminance`.
    Not quite sure why there''s a difference, but there you go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It cannot get much simpler than that. `QtSensors` QML has no filter, so if you
    need to filter anything, you will have to use C++.
  prefs: []
  type: TYPE_NORMAL
- en: Custom QSensor and the backend engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to briefly touch on how to create a custom sensor and engine backend.
    If you are on an embedded device, Qt Sensors may not have support for your sensor
    if it is a moisture or an air-quality sensor. You would need to implement your
    own `QSensor` and `QSensorBackend` engine.
  prefs: []
  type: TYPE_NORMAL
- en: There is a script in the directory, `src/sensors/make_sensor.pl`, that you can
    run which will generate a simple `QSensor` derived class, but additionally this
    script will generate Qt Quick classes that derive from `QmlSensor` . The `make_sensor.pl` script
    needs to be run from the `src/sensors` directory. For this exercise, we are going
    to create a sensor for monitoring salt concentrations in our saltwater swimming
    pool, so the name will be `QSaltSensor`.
  prefs: []
  type: TYPE_NORMAL
- en: You can then open these files in an editor, such as Qt Creator, and add what
    you need. Having a new `QSensor` type will also require a new backend that reads
    from the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Custom QSensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a helper script named `QtSensors/src/sensors/make_sensor.pl`, which
    will create a basic template for a new `QSensor`, `QSensorReading`. It generates
    a simple `QSensor` derived class, but also classes for `QmlSensor` derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have it in your source directory, it can be found in the Git repository
    at [https://code.qt.io/cgit/qt/qtsensors.git/tree/src/sensors/make_sensor.pl](https://code.qt.io/cgit/qt/qtsensors.git/tree/src/sensors/make_sensor.pl).
  prefs: []
  type: TYPE_NORMAL
- en: The `make_sensor.pl` script needs to be run from the `src/sensors` directory.
  prefs: []
  type: TYPE_NORMAL
- en: You will have to edit the resulting files and fill in a thing. For this example,
    I chose `QSaltSensor` as a class name. Execute the script with the class name
    as the first argument: `make_sensor.pl QSaltSensor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It creates the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<sensorname>.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sensorname>.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sensorname>_p.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports/sensors/<sensorname>.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports/sensors/<sensorname>.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of using the `make_sensor.pl` command will appear like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Like the output says, you will need to add `qsaltsensor` to the `src/sensors.pro`
    file to the `SENSORS` variable that is used there. Add the `qmlsaltsensor` filepaths
    in the file, `src/imports/sensors/sensors.pro`.
  prefs: []
  type: TYPE_NORMAL
- en: Start by editing `qsaltsensor.cpp`, which is the class we will use as our `QSensorBackend`.
    The `perl` script we used to create the template has added comments where you
    should edit to customize. You will also need to add any properties.
  prefs: []
  type: TYPE_NORMAL
- en: Custom QSensorBackend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many reasons why you might want to implement your own sensor backend.
    One of these might be if you have a new type of sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would need to start implementing a backend engine for your new `QSensor`
    type. Begin by deriving from `QSensorBackend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `QSensorBackend`, has two pure virtual functions you need to implement: `start()`
    and `stop()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter07-2` directory,
    in the `cp7` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the backend functionality is up to you, based on if you have a
    salt sensor device you want to use. Of course you will have to compile and deploy
    your own Qt Sensors when you do so.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about custom `QSensors` and the backend, look at the Grue
    sensor example in Qt sensors. There is some rather amusing documentation on how
    to implement a custom sensor at [https://doc.qt.io/qt-5/qtsensors-grue-example.html](https://doc.qt.io/qt-5/qtsensors-grue-example.html)
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes there are more than one sensor plugin on a system for any sensor.
    In this case we will need to tell the system which sensor to use. Let's look at
    how to configure `QSensors`.
  prefs: []
  type: TYPE_NORMAL
- en: Sensors.conf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is more than one backend for a particular sensor, you might need to
    specify which is the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add `qsaltsensor` to the `Sensors.conf` configuration file so the system
    can determine which sensor type is the default for a certain sensor. Of course,
    developers are free to choose whichever registered sensor on the system they want
    to use. The config file''s format is `SensorType = sensor.id`, where `SensorType`
    is the base sensor class name, such as `QLightSensor`, and `sensor.id` is a `String`
    identifier for the specific sensor backend. The following code uses our `saltsensor`
    from the Linux backend and the list sensor from the `sensorfw` backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: QSensorGesture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QSensorGesture` is an API for device gestures using sensors. As I mentioned in
    the introduction, they use ad-hoc gestures, which is to say there is no machine
    learning involved. Qt Sensors offers the following already-baked gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cover`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doubletap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`freefall`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hover`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slam`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shake`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`turnover`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twist`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions on how to perform specific gestures in Qt Sensors are detailed
    at [http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html](http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html).
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that `QSensorGesture` uses signals specific to the recognizer.
    The `slam` gesture has the `slam()` signal, which gets emitted when it detects
    the `slam` gesture. It also has the standard `detected("<gesture>")` signal. The `shake2` gesture
    has the `shakeLeft`, `shakeRight`, `shakeUp` and `shakeDown` signals, but also
    the corresponding `detected` signals.
  prefs: []
  type: TYPE_NORMAL
- en: The `QSensorGesture` class does not have the `Q_OBJECT` macro, and creates its
    signals at runtime directly on the `meta` object. As such, `qobject_cast` and
    subclassing `QSensorGesture` while using `Q_OBJECT` will not work.
  prefs: []
  type: TYPE_NORMAL
- en: '`QSensorGestureManager` has the `recognizerSignals` function, which takes a
    `gestureId` so you can discover signals specific to the gesture, if you need to.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter07-3` directory,
    in the `cp7` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `QSensorGestures`, create a `QSensorGesture` object, which takes a `QStringList`
    argument of a list of gesture IDs you want to use. You can specify directly which
    gestures you want using a `QStringList` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively you can also use `QSensorGestureManager` to get a list of all
    the registered gestures, calling `gestureIds()`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the atypical implementation of `QSensorGesture` (because the signals
    get dynamically created at runtime), using the new style connect syntax, `connect(gesture,
    &QSensorGesture::detected, this, &SomeClass::detectedGesture);`, will result in
    a compiler error, as the new style syntax has compile-time checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have these signals connected correctly, you call `startDetection()`
    for `QSensorGesture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: QSensorGestureManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can get a list of all sensor gestures registered on the system by using
    `QSensorGestureManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `gestureId` from the preceding code to create a new `QSensorGesture`
    object and connect to the detected signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: SensorGesture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, sensor gestures can be used from QML. The API is slightly different
    in that there is only one type, `SensorGesture`, so it is like using the generic
    `QSensor` class, except that, instead of one gesture per object, `SensorGesture`
    can represent one or more gestures.
  prefs: []
  type: TYPE_NORMAL
- en: '`SensorGesture` does not have its own import, and is lumped into `QtSensors`,
    so we need to use that to indicate we are using the `QtSensors` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You specify which gestures you want by writing to the `gestures` property,
    which takes a list of strings of the `id` recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there is only one generic `SensorGesture`, there are no gesture-specific
    signals. The gesture signal is `onDetected`, and a string of which gesture was
    detected is set in the `gesture` property. You will have to use some logic to
    filter for a certain gesture if you are using the component for more than one
    gesture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the detection, write `true` to the `SensorGesture` enabled property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can grab your device and perform the slam gesture as outlined in the Qt
    documentation at [http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html](http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html).
    Depending on your device, it will detect a slam.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets – Bi-directional web communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are starting to get into the realm of network and the internet. WebSockets
    are a protocol that allows two-way data exchange between a web browser or client
    and a server without polling. You can stream data or send data at any time. Qt
    has support for WebSockets through the use of the `QWebSocket` API. Like normal
    TCP sockets, `QWebSockets` needs a server.
  prefs: []
  type: TYPE_NORMAL
- en: QWebSocketServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QWebSocketServer` can work in two modes: non-secure and SSL. We start by adding
    `websockets` to the `.pro` file so `qmake` sets up the proper library and header
    paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then include the `QWebSocketServer` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter07-3` directory,
    in the `cp7` branch.
  prefs: []
  type: TYPE_NORMAL
- en: To create a `QWebSocketServer`, it takes a server name as a string, a mode,
    and a parent object. The mode can be `SecureMode` or `NonSecureMode`.
  prefs: []
  type: TYPE_NORMAL
- en: '`SecureMode` is is like HTTPS, uses SSL, and the protocol is wss. `NonSecureMode`
    is like HTTPS with the ws protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `QSocket`, there is a `newConnection` signal that gets emitted when a
    client attempts to connect to this server. If you are using `SecureMode`, you
    will want to connect to the `sslErrors(const QList<QSslError> &errors)` signal.
    Once the signals you want to use are connected, call `listen` to start the server,
    with a `QHostAddress` and a port number. `QHostAddress::Any` will listen to all
    network interfaces. You can specify one interface''s address. The port number
    is optional and a port of 0 will be assigned a port automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `QWebSocketServer` object that listens to incoming connections.
    We can handle this much like we did with the `QSocketServer` using `nextPendingConnection`
    in the corresponding slot we used to connect with the `newConnection` signal.
    That will give us a `QWebSocket` object that represents the connecting client.
  prefs: []
  type: TYPE_NORMAL
- en: QWebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a new connection comes in, `QWebSocketServer` emits the `newConnection` signal,
    which, here, calls the `newConnection` slot. We grab `QWebSocket` using the `nextPendingConnection`
    of the server object. With this, we connect to the `QWebSocket` signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first signal I like to connect is the error signal, as it can help debug.
    Like the `QBluetooth` class, the `error` function is overloaded, so special syntax
    is needed to use this signal.
  prefs: []
  type: TYPE_NORMAL
- en: The `QWebSocket` `error` signal is overloaded, so it needs unique handling to
    compile. `QOverload` is what you need to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two types of messages that can be sent and received: `text` and `binary`.
    We have to deal with those differently, so there are signals for each. They get
    emitted by the server when the client sends a `text` or `binary` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: One difference between `binary` and `text` messages in WebSockets is that the
    `text` messages are terminated with the `0xFF` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textMessageReceived` signal sends a `QString`, while the `binaryMessageReceived`
    sends a `QByteArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: They also work on the frame level, but we are simply handling the entire message.
    If you have continuous streaming data of some kind, you might choose the `textFrameReceived`
    or `binaryFrameReceived` signals.
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A WebSocket client would simply use `QWebSocket` and connect to a server that
    supports WebSockets. One use case would be a web page (client) that shows sensor
    data sent though a `QWebSocketServer`.
  prefs: []
  type: TYPE_NORMAL
- en: QtQuick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, the `QWebSockets` API provides QML components – WebSocket and `WebSocketServer`
    to be exact. As usual, it is quicker than using C++.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocketServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following import line for your `qml` file to use WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter07-4` directory,
    in the `cp7` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To start listening with `WebSocketServer`, set the `listen` property to `true`.
    The `url` property, which takes a string, can be set to the address that clients
    will connect to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When a client connects, the `onClientConnected` signal gets emitted, and its
    `webSocket` property represents the incoming WebSocket client. You also want to
    be able to do error checking so `WebSocketServer` has the `onErrorStringChanged`
    signal, with the `errorString` property. To do so, in the `WebSocketServer` component,
    implement it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how to handle the WebSocket for both server and client.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the client and server use WebSocket element. In the server, as I outlined
    in the *WebSocketServer* section, the client's `WebSocket` object can be obtained
    via the `onClientConnect` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out how this works in the `WebSocketServer` component, as compared to
    the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The client requires the `url` property to be populated so it knows which server
    it will connect to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The incoming message appears in the `onTextMessageReceived` signal with the
    `message` property.
  prefs: []
  type: TYPE_NORMAL
- en: To send a message to the server or client, `WebSocket` has the `sendMessage`
    function. If this is the server, the `webSocket` would be used to send a message
    of text like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: WebSockets for Qt Quick does not handle binary messages in the true sense of
    the word. It does happen to have an `onBinaryMessageReceived` signal, but the
    `message` object that gets received is a `String`. I would suggest that if your
    binary message will get messed up by being converted to UTF16-encoded `QString`,
    you might consider using the C++ API.
  prefs: []
  type: TYPE_NORMAL
- en: QMqtt – Brokers of machine talk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MQTT is a publish-and-subscribe messaging transport. There was a similar framework
    in the Qt Mobility stack called Publish and Subscribe, which is now part of the
    officially unsupported `QSystems` API framework, which also includes `QSystemInfo`
    and `QSystemFramework`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QMqtt` is a framework for writing MQTT clients. You will need to install and
    run an MQTT broker, such as Mosquitto or HiveMQ, or use an internet-based service.
    For my development and testing purposes, I chose HiveMQ. You can download it from [https://www.hivemq.com/](https://www.hivemq.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: They also have a public broker at [http://www.mqtt-dashboard.com/index.html](http://www.mqtt-dashboard.com/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: MQTT has a broker, or server that one or more clients connect to. The clients
    can then publish and/or subscribe to different topics.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `QWebSockets` to access a broker, and there is an example in Qt,
    which uses the `WebSocketIODevice` class in the `examples/mqtt/websocketsubscription`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: QMqttClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start developing a `QMqttClient`, you will have to build it yourself, as
    it does not get distributed with Qt itself, unless you get the commercial Qt for
    Automation.
  prefs: []
  type: TYPE_NORMAL
- en: You download the open source licensed version from `git://code.qt.io/qt/qtmqtt.git`.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily it is a straightforward and easy build. Once you run `qmake; make &&
    make install;`, you are ready to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In your `pro` file, we need to add the `mqtt` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The header file is named `QtMqtt/QMqttClient`, so let''s include that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter07-5` directory,
    in the `cp7` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main class we use to access the broker is named `QMqttClient`. It can be
    thought of as the manager. It has a simple construction. You need to specify the
    host and port with the `setHostname` and `setPort` functions. We will use the `hivemq` public
    broker and port `1883`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a good idea connect to any error signals to help debugging when things
    go wrong; let''s do that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to the `mqtt` broker, call `connectToHost();`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we connected to the `stateChanged` signal, we can wait until we are connected
    to the broker to subscribe to any topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `QMqttClient::subscribe` function takes a topic in the form of `QMqttTopicFilter`.
    Here, I assign it the `"Qt"` string.
  prefs: []
  type: TYPE_NORMAL
- en: It returns a `QMqttSubscription` pointer, which we can use to connect to the
    `stateChanged` signal. We will then simply subscribe to the topic we just published.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `subscribe` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We simply call our function that will then publish something to that topic.
  prefs: []
  type: TYPE_NORMAL
- en: '`QMqttClient::publish` takes a topic name in the form of a `QMqttTopicName`,
    and the message is just a standard `QByteArray`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `publish` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You should then see the message we published in the `messageReceived` slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b5ad8cf-4496-41a9-a675-caa991a0bc0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have a Raspberry Pi and a Sense HAT board that I can use to collect sensor
    data. Luckily, I previously wrote a Qt Sensors plugin for the Sense HAT. It happens
    to be in a standalone Git repository and not in any Qt Sensors version, unlike
    the TI SensorTag backend plugin.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to write your own Sense HAT sensor plugin you can get my standalone
    Sense HAT plugin from [https://github.com/lpotter/qsensors-sensehatplugin.git](https://github.com/lpotter/qsensors-sensehatplugin.git).
  prefs: []
  type: TYPE_NORMAL
- en: The version of Qt Sensors on the Raspbian distribution is 5.7 and does not have
    the pressure and humidity sensors that the Sense HAT has. They were added in later
    Qt Sensors versions.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling on a desktop is so much faster than compiling on the device—days
    on the **Raspberry Pi** (**rpi**) as opposed to a few minutes on a good development
    machine. I had some trouble getting the cross-compiling `toolchain` to work, so
    I had to opt for the on-board native compile, which of course takes a very long
    time on a Raspberry Pi. The easiest way is to get Qt's commercial `Boot2Qt` and
    `Automation` packages, as they package it up nicely, and provide binaries and
    support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this book uses Qt 5.12, we need to get the explicit version of the following
    Qt module repositories, by using the following Git commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Base: `git clone http://code.qt.io/qt/qtbase.git -b 5.12`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt WebSockets: `git clone http://code.qt.io/qt/qtwebsockets.git -b 5.12`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt MQTT: `git clone http://code.qt.io/qt/qtmqtt -b 5.12`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Sensors: `git clone http://code.qt.io/qt/qtsensors -b 5.12`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to create an app for Raspberry Pi that grabs the Sense HAT's temperature
    and pressure data and distributes them via `QMqtt` and `QWebSockets` to a broker
    running on HiveMQ.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter07-6` directory,
    in the `cp7` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Start by implementing a `SensorServer` class, which is typically a `QObject`
    derived class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We then implement the `QWebSockeIODevice` that we declared as `mDevice` and
    connect to its `socketConnected` signal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Next we call the `connectToBackend()` function of the sensors we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The call to `initSensors()` connects to the sensor's backend and sets up `readingChanged`
    signal connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `QWebSockets` for the `QMqtt` client, we need to create a `QIODevice`
    that uses `QWebSockets`. Luckily, there is one already written in the `QMqtt`
    `examples/mqtt/websocketssubscription` directory, named `websocketsiodevice`,
    so we will import that into the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In our header file, we include `websocketdevice.h`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the class declaration, we instantiate the `WebSocketIODevice` as a class
    member.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: To actually use `WebSocketIODevice`, we need to set it as the `QMqttClient`
    transport.
  prefs: []
  type: TYPE_NORMAL
- en: We first set up our `WebSocketIODevice` and connect to its `socketConnected`
    signal to set up `QMqtt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mqtt` broker at `hivemq` uses a different port number, so we set it in
    the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set up `QMqtt` and set its transport to use `WebSocketIODevice`. We
    are using a transport with its own connection, so we do not set the URL for the
    `QMqtt` object, but rely on the `websocket` for connection. We then set up `mqttClient`
    as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We monitor the changing state and act when it becomes `Connected`. We will
    start the `humidity` and `temperature` sensor, and then call subscribe so we can
    monitor when the `mqtt` broker is publishing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In our sensor''s `readingChanged` slots, we will publish the data to the `mqtt`
    broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see any subscribed messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at the different ways of using `QSensors` to read
    a device''s sensor data. There are many supported platforms for Qt Sensors: Android,
    iOS, WinRT , SensorTag, Sensorfw, Linux generic, and Linux iio-sensor-proxy. Sensorfw
    also has support for Linux''s IIO sensors.'
  prefs: []
  type: TYPE_NORMAL
- en: I described how to implement custom `QSensor` and `QSensorBackend` to add support
    for sensors not currently supported in Qt Sensors.
  prefs: []
  type: TYPE_NORMAL
- en: We went through the steps involved in using `QtMqtt` to talk to an `mqtt` broker,
    and we looked at how to use `QWebsockets` to communicate to a web server web page.
  prefs: []
  type: TYPE_NORMAL
- en: Then I threw them all together to grab sensor data from a Sense HAT, and publish
    them to `mqtt` broker by way of WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss using GPS data comprising of location and
    position and mapping.
  prefs: []
  type: TYPE_NORMAL
