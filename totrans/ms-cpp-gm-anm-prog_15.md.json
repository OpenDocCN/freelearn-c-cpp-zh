["```cpp\nstruct LevelSettings {\n  std::string lsLevelFilenamePath;\n  std::string lsLevelFilename;\n  glm::vec3 lsWorldPosition = glm::vec3(0.0f);\n  glm::vec3 lsWorldRotation = glm::vec3(0.0f);\n  float lsScale = 1.0f;\n  bool lsSwapYZAxis = false;\n}; \n```", "```cpp\n std::vector<std::shared_ptr<AssimpLevel>> micLevels{};\n  int micSelectedLevel = 0; \n```", "```cpp\nusing levelCheckCallback = std::function<bool(std::string)>;\nusing levelAddCallback = std::function<bool(std::string)>;\nusing levelDeleteCallback =\n  std::function<void(std::string)>; \n```", "```cpp\n levelCheckCallback micLevelCheckCallbackFunction;\n  levelAddCallback micLevelAddCallbackFunction;\n  levelDeleteCallback micLevelDeleteCallbackFunction; \n```", "```cpp\n bool hasLevel(std::string levelFileName);\n    std::shared_ptr<AssimpLevel> getLevel(std::string\n      levelFileName);\n    bool addLevel(std::string levelFileName);\n    void deleteLevel(std::string levelFileName); \n```", "```cpp\nvoid OGLRenderer::addNullLevel() {\n  std::shared_ptr<AssimpLevel> nullLevel =\n    std::make_shared<AssimpLevel>();\n  mModelInstCamData.micLevels.emplace_back(nullLevel);\n} \n```", "```cpp\n std::vector<LevelSettings> getLevelConfigs();\n    int getSelectedLevelNum(); \n```", "```cpp\n float mOctreeZoomFactor = 1.0f;\n    glm::vec3 mOctreeRotation = glm::vec3(0.0f);\n    glm::vec3 mOctreeTranslation = glm::vec3(0.0f); \n```", "```cpp\n if (ImGui::IsWindowHovered(\n      ImGuiHoveredFlags_RootAndChildWindows)) { \n```", "```cpp\n ImGuiIO& io = ImGui::GetIO();\n    mOctreeZoomFactor += 0.025f * io.MouseWheel;\n    mOctreeZoomFactor = std::clamp(mOctreeZoomFactor,\n      0.1f, 5.0f); \n```", "```cpp\n if (ImGui::IsMouseDown(ImGuiMouseButton_Right)) {\n      mOctreeRotation.y += io.MouseDelta.x;\n      mOctreeRotation.x += io.MouseDelta.y;\n    } \n```", "```cpp\n if (ImGui::IsMouseDown(ImGuiMouseButton_Middle)) {\n      mOctreeTranslation.x += io.MouseDelta.x;\n      mOctreeTranslation.y += io.MouseDelta.y;\n    }\n  } \n```", "```cpp\n OGLLineMesh mOctreeLines{}; \n```", "```cpp\n mOctreeLines.vertices.clear();\n  const auto treeBoxes =\n    modInstCamData.micOctreeGetBoxesCallback(); \n```", "```cpp\n AABB boxAABB{};\n    boxAABB.create(box.getFrontTopLeft());\n    boxAABB.addPoint(box.getFrontTopLeft() +\n      box.getSize()); \n```", "```cpp\n std::shared_ptr<OGLLineMesh> instanceLines =\n      boxAABB.getAABBLines(white);\n    mOctreeLines.vertices.insert(\n      mOctreeLines.vertices.end(),\n      instanceLines->vertices.begin(),\n      instanceLines->vertices.end()); \n```", "```cpp\n glm::mat3 mOctreeViewMat = glm::mat3(1.0f);\n    glm::mat4 mRotationMat = glm::mat4(1.0f);\n    glm::mat4 mScaleMat = glm::mat4(1.0f); \n```", "```cpp\n mScaleMat = glm::scale(glm::mat4(1.0f),\n    glm::vec3(mOctreeZoomFactor));\n  mRotationMat = glm::rotate(mScaleMat,\n    glm::radians(mOctreeRotation.x),\n    glm::vec3(1.0f, 0.0f, 0.0f));\n  mOctreeViewMat = glm::rotate(mRotationMat,\n    glm::radians(mOctreeRotation.y),\n    glm::vec3(0.0f, 1.0f, 0.0f)); \n```", "```cpp\nfor (int i = 0; i < mOctreeLines.vertices.size(); i += 2) { \n```", "```cpp\n OGLLineVertex startVert = mOctreeLines.vertices.at(i);\n    OGLLineVertex endVert = mOctreeLines.vertices.at(i+1);\n    glm::vec3 startPos = mOctreeViewMat *\n      startVert.position;\n    glm::vec3 endPos = mOctreeViewMat * endVert.position; \n```", "```cpp\n ImVec2 pointStart =\n     ImVec2(drawAreaCenter.x + startPos.x +\n       mOctreeTranslation.x,\n       drawAreaCenter.y + startPos.z +\n       mOctreeTranslation.y);\n    ImVec2 pointEnd =\n      ImVec2(drawAreaCenter.x + endPos.x +\n        mOctreeTranslation.x,\n        drawAreaCenter.y + endPos.z +\n        mOctreeTranslation.y) \n```", "```cpp\n drawList->AddLine(pointStart, pointEnd,\n    ImColor(startVert.color.r, startVert.color.g,\n      startVert.color.b, 0.6f)); \n```", "```cpp\n AABB mLevelAABB{}; \n```", "```cpp\n void generateAABB();\n    AABB getAABB(); \n```", "```cpp\n updateLevelRootMatrix();\n  mLevelAABB.clear();\n  for (const auto& mesh : mLevelMeshes) {\n    for (const auto& vertex : mesh.vertices) {\n      mLevelAABB.addPoint(mLevelRootMatrix *\n        glm::vec4(glm::vec3(vertex.position), 1.0f));\n    }\n  } \n```", "```cpp\nusing levelGenerateAABBCallback = std::function<void(void)>; \n```", "```cpp\n levelGenerateAABBCallback\n    micLevelGenerateAABBCallbackFunction; \n```", "```cpp\nAABB AssimpModel::getAABB(InstanceSettings instSettings) {\n  if (mNumAnimatedMeshes > 0) {\n    return getAnimatedAABB(instSettings);\n  } else {\n    return getNonAnimatedAABB(instSettings);\n  }\n} \n```", "```cpp\n glm::mat4 localScaleMatrix = glm::scale(glm::mat4(1.0f),\n    glm::vec3(instSettings.isScale));\n  glm::mat4 localSwapAxisMatrix;\n  if (instSettings.isSwapYZAxis) {\n    glm::mat4 flipMatrix = glm::rotate(glm::mat4(1.0f),\n      glm::radians(-90.0f), glm::vec3(0.0f, 0.0f, 1.0f));\n    localSwapAxisMatrix = glm::rotate(flipMatrix,\n      glm::radians(-90.0f), glm::vec3(0.0f, 1.0f, 0.0f));\n  } else {\n    localSwapAxisMatrix = glm::mat4(1.0f);\n  }\n  glm::mat4 localRotationMatrix = glm::mat4_cast(\n    glm::quat(glm::radians(instSettings.isWorldRotation)));\n  glm::mat4 localTranslationMatrix =\n    glm::translate(glm::mat4(1.0f),\n    instSettings.isWorldPosition); \n```", "```cpp\n glm::mat4 localTransformMatrix =\n    localTranslationMatrix * localRotationMatrix *\n    localSwapAxisMatrix * localScaleMatrix *\n    mRootTransformMatrix; \n```", "```cpp\n AABB modelAABB{};\n  for (const auto& mesh : mModelMeshes) {\n    for (const auto& vertex : mesh.vertices) {\n      modelAABB.addPoint(localTransformMatrix *\n        glm::vec4(glm::vec3(vertex.position), 1.0f));\n    }\n  } \n```", "```cpp\n Shader mAssimpLevelShader{}; \n```", "```cpp\n if (!mAssimpLevelShader.loadShaders(\n      \"shader/assimp_level.vert\",\n      \"shader/assimp_level.frag\")) {\n    return false;\n  } \n```", "```cpp\nlayout (std430, binding = 1) readonly restrict\n    buffer WorldTransformMatrix {\n  mat4 worldTransformMat;\n}; \n```", "```cpp\nvoid main() {\n  gl_Position = projection * view * worldTransformMat *\n    vec4(aPos.x, aPos.y, aPos.z, 1.0);\n  color = aColor;\n  normal = transpose(inverse(worldTransformMat)) *\n    vec4(aNormal.x, aNormal.y, aNormal.z, 1.0);\n  texCoord = vec2(aPos.w, aNormal.w);\n} \n```", "```cpp\n for (const auto& level : mModelInstCamData.micLevels) {\n    if (level->getTriangleCount() == 0) {\n      continue;\n    } \n```", "```cpp\n mAssimpLevelShader.use();\n    mShaderModelRootMatrixBuffer.uploadSsboData(\n      level->getWorldTransformMatrix(), 1);\n    level->draw();\n  } \n```", "```cpp\n AABB mAllLevelAABB{}; \n```", "```cpp\n void generateLevelAABB();\n    void drawLevelAABB(glm::vec4 aabbColor); \n```", "```cpp\n mAllLevelAABB.clear();\n  for (const auto& level : mModelInstCamData.micLevels) {\n    if (level->getTriangleCount() == 0) {\n      continue;\n    } \n```", "```cpp\n level->generateAABB();\n    mAllLevelAABB.addPoint(level->getAABB().getMinPos());\n    mAllLevelAABB.addPoint(level->getAABB().getMaxPos());\n  } \n```", "```cpp\n mAABBMesh = mAllLevelAABB.getAABBLines(aabbColor);\n  mLineVertexBuffer.uploadData(*mAABBMesh);\n  mLineShader.use();\n  mLineVertexBuffer.bindAndDraw(GL_LINES, 0,\n    mAABBMesh->vertices.size()); \n```", "```cpp\n if (mRenderData.rdDrawLevelAABB) {\n    glm::vec4 levelAABBColor =\n      glm::vec4(0.0f, 1.0f, 0.5, 0.5f);\n    drawLevelAABB(levelAABBColor);\n  } \n```", "```cpp\n bool rdDrawLevelAABB = false; \n```"]