<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor134"/>6</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor135"/>Setting Up Collision Objects</h1>
<p>In the previous chapter, we covered some of the basic concepts of collision, namely Line Traces and Sweep Traces. We learned how to execute different types of Line Traces, how to create custom Trace Channels, and how to change how an object responds to a specific channel. Many of the things you learned in the previous chapter will be used in this chapter, where we’ll learn about object collision.</p>
<p>Throughout this chapter, we will continue to build upon our top-down Dodgeball game by adding game mechanics that revolve around object collision. We will create the Dodgeball actor, which will act as a dodgeball that bounces off of the floor and walls; the Wall actor, which will block all objects; the Ghost Wall actor, which will only block the player, not the enemies’ lines of sight or the dodgeball; and the Victory Box actor, which will end the game when the player enters the Victory Box, representing the end of the level.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Understanding object collision in UE5</li>
<li>Understanding collision components</li>
<li>Understanding collision events</li>
<li>Understanding collision channels</li>
<li>Creating physical materials</li>
<li>Introducing timers</li>
<li>Understanding how to spawn actors</li>
</ul>
<p>Before we start creating our <code>Dodgeball</code> class, we will go over the basic concepts of object collision.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor136"/>Technical requirements</h1>
<p>The project for this chapter can be found in the Chapter06 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor137"/>Understanding object collision in UE5</h1>
<p>Every game<a id="_idIndexMarker425"/> development tool must have a physics engine that simulates collision between multiple objects, as explained in the previous chapter. Collision is the backbone of most games released nowadays, whether 2D or 3D. In many games, it’s the main way in which the player acts upon the environment, be it running, jumping, or shooting, and the environment acts accordingly by making the player land, get hit, and so on. It is no understatement to say that, without simulated collision, it wouldn’t be possible to <a id="_idIndexMarker426"/>make many games at all.</p>
<p>So, let’s understand how object collision works in UE5 and how we can use it, starting with collision components.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor138"/>Understanding collision components</h1>
<p>In UE5, two types of components can <a id="_idIndexMarker427"/>affect and be affected by collision; they are as follows:</p>
<ul>
<li>Meshes</li>
<li>Shape objects</li>
</ul>
<p><strong class="bold">Meshes</strong> can be as simple as a <a id="_idIndexMarker428"/>cube, or as complex as a high-resolution character <a id="_idIndexMarker429"/>with tens of thousands of vertices. A mesh’s collision can be specified with a custom file imported alongside the mesh into UE5 (which is outside the scope of this book), or it can be calculated automatically by UE5 and customized by you. </p>
<p>It is generally a good practice to keep the collision mesh as simple (for example, a few triangles) as possible so that the physics engine can efficiently calculate collision at runtime. The types of meshes that can have collision are as follows:</p>
<ul>
<li><strong class="bold">Static Meshes</strong>: Meshes that are <a id="_idIndexMarker430"/>defined as static and do not <a id="_idIndexMarker431"/>change.</li>
<li><strong class="bold">Skeletal Meshes</strong>: Meshes that <a id="_idIndexMarker432"/>can have a skeleton and change their poses, which <a id="_idIndexMarker433"/>allows them to be animated. Character meshes, for instance, are skeletal meshes.</li>
<li><strong class="bold">Procedural Meshes</strong>: Meshes that can be generated automatically according to <a id="_idIndexMarker434"/>certain <a id="_idIndexMarker435"/>parameters.</li>
</ul>
<p><strong class="bold">Shape objects</strong>, which are simple <a id="_idIndexMarker436"/>meshes represented in wireframe <a id="_idIndexMarker437"/>mode, are used to behave as collision objects by causing and receiving collision events. </p>
<p class="callout-heading">Note</p>
<p class="callout">Wireframe mode is a commonly used <a id="_idIndexMarker438"/>visualization mode in game development, usually for debugging purposes, which allows you to see meshes without any faces or textures – they can only be seen through their edges, which are connected by their vertices. You will see what wireframe mode is when we add a <strong class="bold">Shape</strong> component to an actor.</p>
<p>Please note that <code>Shape</code> objects are essentially invisible meshes and that their three types are as follows:</p>
<ul>
<li>Box Collision (Box Component in C++)</li>
<li>Sphere <a id="_idIndexMarker439"/>Collision (Sphere Component in C++)</li>
<li>Capsule Collider (Capsule Component in C++)</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">There’s a class that all the components that provide geometry and collision inherit from, which is the <code>Primitive</code> component. This component is the basis for all components that contain any sort of geometry, which is the case for mesh components and shape components.</p>
<p>So, how can these components collide, and what happens when they do? We shall have a look at this in the next section.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor139"/>Understanding collision events</h1>
<p>Let’s say that two objects are colliding <a id="_idIndexMarker440"/>with one another. Two things can <a id="_idIndexMarker441"/>happen:</p>
<ul>
<li>They overlap each other, as if the other object weren’t there, in which case the <code>Overlap</code> event is called.</li>
<li>They collide and prevent each other from continuing their course, in which case the <code>Block</code> event is called.</li>
</ul>
<p>In the previous chapter, we learned how to change an object’s response to a specific <code>Trace</code> channel. During this process, we learned that an object’s response can be either <code>Block</code>, <code>Overlap</code>, or <code>Ignore</code>. </p>
<p>Now, let’s see what happens in each of these responses during a collision:</p>
<ul>
<li><code>Block</code>:<ul><li>Both objects will have their <code>OnHit</code> events called. This event is called whenever two objects block each other’s path at the moment they collide. If one of the objects is simulating physics, that object must have its <code>SimulationGeneratesHitEvents</code> property set to <code>true</code>.</li><li>Both objects will physically stop each other from continuing with their course.</li></ul></li>
</ul>
<p>The following diagram shows an example of when two objects are thrown and bounce off each other:</p>
<div><div><img alt="Figure 6.1 – Object A and object B blocking each other " height="164" src="img/Figure_6.01_B18531.jpg" width="569"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Object A and object B blocking each other</p>
<ul>
<li><code>GenerateOverlapEvents</code> property set to <code>true</code>, they will have their <code>OnBeginOverlap</code> and <code>OnEndOverlap</code> events called. These overlap events are called when an object starts and stops overlapping another object, respectively. If at least one of them doesn’t have this property set to <code>true</code>, neither of them will call these events.</li><li>The objects act as if the other object doesn’t exist and will overlap each other.</li></ul></li>
</ul>
<p>As an example, suppose the player’s character walks into a trigger box that marks the end of the level, which only reacts to the player’s character.</p>
<p>The following diagram shows an example of two objects overlapping each other:</p>
<div><div><img alt="Figure 6.2 – Object A and object B overlapping each other " height="156" src="img/Figure_6.02_B18531.jpg" width="652"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Object A and object B overlapping each other</p>
<ul>
<li><code>Overlap</code> response, the objects will act as if the other object doesn’t exist and will overlap each other.</li></ul></li>
</ul>
<p>An example of two objects ignoring each other would be when an object other than the player’s character goes into a trigger box that marks the end of the level, which only reacts to the player’s <a id="_idIndexMarker445"/>character.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can look at the previous diagram, where two objects overlap each other, to understand <strong class="bold">Ignore</strong>.</p>
<p>The following table will help you understand the necessary responses that two objects must have to trigger the previously described situations:</p>
<div><div><img alt="Figure 6.3 – Resulting responses on objects based on Block, Overlap, and Ignore " height="339" src="img/Figure_6.03_B18531.jpg" width="965"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Resulting responses on objects based on Block, Overlap, and Ignore</p>
<p>Following this table, consider that you have two objects – object A and object B:</p>
<ul>
<li>If object A has set its response to object B to <strong class="bold">Block</strong> and object B has set its response to object A to <strong class="bold">Block</strong>, they will <strong class="bold">Block</strong> each other.</li>
<li>If object A has set its response to object B to <strong class="bold">Block</strong> and object B has set its response to object A to <strong class="bold">Overlap</strong>, they will <strong class="bold">Overlap</strong> each other.</li>
<li>If object A has set its response to object B to <strong class="bold">Ignore</strong> and object B has set its response to object A to <strong class="bold">Overlap</strong>, they will <strong class="bold">Ignore</strong> each other.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">You can find a full reference to <a id="_idIndexMarker446"/>UE5’s collision interactions at <a href="https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview">https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview</a>.</p>
<p>A collision between objects has two aspects to it:</p>
<ul>
<li><strong class="bold">Physics</strong>: All collisions <a id="_idIndexMarker447"/>related to physics simulation, such as a ball being affected by gravity and bouncing off the floors and walls.</li>
</ul>
<p>The physically simulated response of the collision within the game can be either of the following: </p>
<ul>
<li>Both objects continue their trajectories as if the other object wasn’t there (no physical collision).</li>
<li>Both objects collide and change their trajectories, usually with at least one of them continuing its movement – that is, they are blocking each other’s paths.</li>
</ul>
<ul>
<li><code>OnHit</code> event</li><li>The <code>OnBeginOverlap</code> event</li><li>The <code>OnEndOverlap</code> event</li><li>The physical response to the collision within the game, which can be either of the following: <ul><li>Both objects continued their movement as if the other object wasn’t there (no physical collision)</li><li>Both objects collide and block each other’s path</li></ul></li></ul></li>
</ul>
<p>The physical response from the physics aspect may sound similar to the physical response from the query aspect; however, although <a id="_idIndexMarker449"/>they are both physical responses, they will cause objects to behave differently.</p>
<p>The physical response from the physics aspect (physics simulation) only applies when an object is simulating physics (for example, being affected by gravity, bouncing off the walls and ground, and so on). Such an object, when hitting a wall, for instance, will bounce back and continue moving in another direction.</p>
<p>On the other hand, the physical response from the query aspect applies to all objects that don’t simulate physics. An object can move without simulating physics when being controlled by code (for example, by using the <code>SetActorLocation</code> function or by using the <strong class="bold">Character Movement</strong> component). In this case, depending on which method you use to move the object and its properties, when an object hits a wall, it will simply stop moving instead of bouncing back. This is because you’re simply telling the object to move in a certain direction and something is blocking its path, so the physics engine doesn’t allow that object to continue moving.</p>
<p>Now that we’ve learned about collision events, let’s move on to the next section, where we will be looking at collision channels.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor140"/>Understanding collision channels</h1>
<p>In the previous chapter, a looked at the <a id="_idIndexMarker450"/>existing Trace Channels (<em class="italic">Visibility</em> and<em class="italic"> Camera</em>) and learned how to make a custom channel. Now that you know about Trace Channels, it’s time to talk about Object Channels, also known as Object <a id="_idIndexMarker451"/>Types.</p>
<p>While Trace Channels are only used for Line Traces, Object Channels are used for object collision. You can specify a “purpose” for each <code>Object</code> channel, much like with Trace Channels, such as <strong class="bold">Pawn</strong>, <strong class="bold">Static Object</strong>, <strong class="bold">Physics Object</strong>, <strong class="bold">Projectile</strong>, and so on. Then, you can specify how you want each Object Type to respond to all the other Object Types by blocking, overlapping, or ignoring objects of that type.</p>
<p>Now that we’ve taken a look at how collision works, let’s go back to the collision settings of the cube we selected in the previous chapter, where we changed its response to the Visibility Channel.</p>
<p>Follow these steps to learn more about collision channels:</p>
<ol>
<li>The cube can be seen in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 6.4 – Cube blocking the SightSource of the enemy " height="518" src="img/Figure_6.04_B18531.jpg" width="522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Cube blocking the SightSource of the enemy</p>
<ol>
<li value="2">With the level open in the <a id="_idIndexMarker452"/>editor, select the cube and go to the <strong class="bold">Collision</strong> section of its <strong class="bold">Details</strong> panel:</li>
</ol>
<div><div><img alt="Figure 6.5 – The changes in the level editor " height="300" src="img/Figure_6.05_B18531.jpg" width="365"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The changes in the level editor</p>
<p>Here, we can see some options that are important to us:</p>
<ul>
<li><code>OnHit</code> events to be called when an<a id="_idIndexMarker453"/> object is simulating physics (we’ll talk about this later in this chapter).</li>
<li><code>OnBeginOverlap</code> and <code>OnEndOverlap</code> events to be called.</li>
<li><strong class="bold">Can Character Step Up On</strong>, which allows a character to easily step onto this object.</li>
<li><strong class="bold">Collision Presets</strong>, which allows us to specify how this object responds to each Collision Channel.</li>
</ul>
<ol>
<li value="3">Let’s change the <code>Default</code> to <code>Custom</code> and take a look at the new options that show up:</li>
</ol>
<div><div><img alt="Figure 6.6 – Changes in Collision Presets " height="427" src="img/Figure_6.06_B18531.jpg" width="366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Changes in Collision Presets</p>
<p>The first of these options is the <strong class="bold">Collision Enabled</strong> property. It allows you to specify which aspects of collision you want this object to be considered for: <strong class="bold">Query</strong>, <strong class="bold">Physics</strong>, <strong class="bold">Both</strong>, or <strong class="bold">None</strong>. Again, physics collision is related to physics simulation (whether this <a id="_idIndexMarker454"/>object will be considered by other objects that simulate physics), while query collision is related to collision events and whether objects will block each other’s movement:</p>
<div><div><img alt="Figure 6.7 – Collision Enabled for Query and Physics " height="105" src="img/Figure_6.07_B18531.jpg" width="342"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Collision Enabled for Query and Physics</p>
<p>The second option is the <strong class="bold">Object Type</strong> property. This is very similar to the Trace Channel concept but<a id="_idIndexMarker455"/> is specifically for object collision and, most importantly, dictates what type of collision object this is. The Object Type values that come with UE5 are as follows:</p>
<ul>
<li><code>WorldStatic</code>: An object that doesn’t move (structures, buildings, and so on)</li>
<li><code>WorldDynamic</code>: An object that may move (objects whose movement is triggered by code, objects the player can pick up and move, and so on)</li>
<li><code>Pawn</code>: Used for Pawns that can be controlled and moved around the level</li>
<li><code>PhysicsBody</code>: Used for objects that simulate physics</li>
<li><code>Vehicle</code>: Used for Vehicle objects</li>
<li><code>Destructible</code>: Used for destructible meshes</li>
</ul>
<p>As mentioned previously, you can create custom object types (which will be mentioned later in this chapter) as well, similar to how you can create Trace Channels (<em class="italic">which was covered in the previous chapter</em>).</p>
<p>The last option we have is related to <code>Cube</code> object has the default collision options, all the responses are set to <code>Block</code>, which means that this object will block all the Line Traces and all objects that block <code>WorldStatic</code> objects, given that that is this object’s type.</p>
<p>Because there are so many different combinations of collision properties, UE5 allows you to group collision property values in the form of Collision Presets.</p>
<p>Let’s go back to the <strong class="bold">Collision Presets</strong> property, which is currently set to <strong class="bold">Custom</strong>, and <em class="italic">click it</em> so that we can see all the<a id="_idIndexMarker456"/> possible options. Some of the existing <strong class="bold">Collision Presets</strong> are <a id="_idIndexMarker457"/>as follows:</p>
<ul>
<li><code>NoCollision</code></li><li><code>WorldStatic</code></li><li>Responses: Irrelevant</li><li>Example: Objects that are purely visual and distant, such as an object that the player will never reach</li></ul></li>
<li><code>Query</code> and <code>Physics</code></li><li><code>WorldStatic</code></li><li>Responses: <code>Block</code> all channels</li><li>Example: Objects that are close to the player character and block their movement, such as the floor and walls, which will always be stationary</li></ul></li>
<li><code>Query</code> only</li><li><code>WorldStatic</code></li><li>Responses: <code>Overlap</code> all channels</li><li>Example: Trigger boxes placed in the level, which will always be stationary</li></ul></li>
<li><code>Block All</code> preset, but for dynamic objects that may change their transform during gameplay (<code>Object Type</code>: <code>WorldDynamic</code>)</li>
<li><code>Overlap All</code> preset, but for dynamic objects that may change their transform during gameplay (<code>Object Type</code>: <code>WorldDynamic</code>)</li>
<li><code>Query</code> and <code>Physics</code></li><li><code>Pawn</code></li><li>Responses: <code>Block</code> all channels, <code>Ignore</code> Visibility Channel</li><li>Example: Player character <a id="_idIndexMarker458"/>and non-playable characters</li></ul></li>
<li><code>Query</code> and <code>Physics</code></li><li><code>PhysicsBody</code></li><li>Responses: <code>Block</code> all channels</li><li>Example: Objects that are affected by physics, such as a ball that bounces off the floor and walls</li></ul></li>
</ul>
<p>Just like the other collision properties, you can also create your own collision presets.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find a full reference to <a id="_idIndexMarker460"/>UE5’s collision responses here: <a href="https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference">https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference</a>.</p>
<p>Now that we know about the basic concepts of collision, let’s go ahead and start creating the <code>Dodgeball</code> class. The next exercise will guide you toward doing just that. </p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor141"/>Exercise 6.01 – creating the Dodgeball class</h2>
<p>In this exercise, we’ll be creating our <code>Dodgeball</code> class, which will be thrown by our enemies and bounce off the<a id="_idIndexMarker461"/> floor and walls, just like an actual dodgeball.</p>
<p>Before we start creating the <code>Dodgeball</code> C++ class and its logic, we should set up all the necessary collision settings for it. </p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Open <strong class="bold">Project Settings</strong> and go to the <strong class="bold">Collision</strong> subsection within the <strong class="bold">Engine</strong> section. Currently, there are no Object Channels, so you need to create a new one. </li>
<li>Press the <code>Dodgeball</code>, and set its <strong class="bold">Default Response</strong> to <strong class="bold">Block</strong>.</li>
<li>Once you’ve done this, expand the <strong class="bold">Preset</strong> section. Here, you’ll find all the default presets available in UE5. If you select one of them and press the <strong class="bold">Edit</strong> option, you can change that <strong class="bold">Preset Collision</strong> settings. </li>
<li>Create your own <code>Dodgeball</code></li><li><code>Collision Enabled (Query and Physics)</code> (we want this to be considered for physics simulation as well as collision events)</li><li><code>Dodgeball</code></li><li><code>EnemySight</code> (we don’t want the dodgeball to block the camera or the enemy’s line of sight)</li></ul></li>
<li>Once you’ve selected the correct options, press <strong class="bold">Accept</strong>.</li>
</ol>
<p>Now that the <code>Dodgeball</code> class’s collision settings have been set up, let’s create the <code>Dodgeball</code> C++ class.</p>
<ol>
<li value="6">Inside the <strong class="bold">Content Browser</strong> area, <em class="italic">right-click</em> and select <strong class="bold">New C++ Class</strong>.</li>
<li>Choose <strong class="bold">Actor</strong> as the parent class.</li>
<li>Choose <code>Dodgeball</code>, so we can’t name this new class that too).</li>
<li>Open the <code>DodgeballProjectile</code> class files in Visual Studio. The first thing we’ll want to do is add the <a id="_idIndexMarker462"/>collision component of the dodgeball, so we’ll add a <code>SphereComponent</code> to our class header (<em class="italic">actor component properties are usually private</em>):<pre>UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = 
  Dodgeball, meta = (AllowPrivateAccess = "true"))
class USphereComponent* SphereComponent;</pre></li>
<li>Next, include the <code>SphereComponent</code> class at the top of our source file:<pre>#include "Components/SphereComponent.h"</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Keep in mind that all header file includes must be before the <code>.generated.h</code> include.</p>
<p>Now, head to the <code>DodgeballProjectile</code> class’s constructor, within its source file, and perform the following steps:</p>
<ol>
<li value="11">Create the <code>SphereComponent</code> object:<pre>SphereComponent = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("Sphere 
  Collision"));</pre></li>
<li>Set its <code>radius</code> to <code>35</code> units:<pre>SphereComponent-&gt;SetSphereRadius(35.f);</pre></li>
<li>Set its <code>Dodgeball</code> preset we created:<pre>SphereComponent-&gt;SetCollisionProfileName(FName("Dodgeball"));</pre></li>
<li>We want <code>Dodgeball</code> to simulate physics, so notify the component of this, as shown in the following code snippet:<pre>SphereComponent-&gt;SetSimulatePhysics(true);</pre></li>
<li>We want <code>Dodgeball</code> to call the <code>OnHit</code> event while simulating physics, so call the <code>SetNotifyRigidBodyCollision</code> function to set that to <code>true</code> (this is the same as the <code>SimulationGeneratesHitEvents</code> property that we saw in the <code>Collision</code> section of an object’s properties):<pre>//Simulation generates Hit events
SphereComponent-&gt;SetNotifyRigidBodyCollision(true);</pre></li>
</ol>
<p>We will also want to listen to the <code>OnHit</code> event of <code>SphereComponent</code>. </p>
<ol>
<li value="16">Create a declaration for the function that will be called when the <code>OnHit</code> event is triggered, in the <code>DodgeballProjectile</code> class’s header file. This function should be called <code>OnHit</code>. It should <a id="_idIndexMarker463"/>be <code>public</code>, return nothing (<code>void</code>), have the <code>UFUNCTION</code> macro, and receive some parameters, in this order:<ol><li><code>UPrimitiveComponent* HitComp</code>: The component that was hit and belongs to this actor. A primitive component is an actor component that has a <code>Transform</code> property and some sort of geometry (for example, a <code>Mesh</code> or <code>Shape</code> component).</li><li><code>AActor* OtherActor</code>: The other actor involved in the collision.</li><li><code>UPrimitiveComponent* OtherComp</code>: The component that was hit and belongs to the other actor.</li><li><code>FVector NormalImpulse</code>: The direction in which the object will be moving after it has been hit, and with how much force (by checking the size of the vector). This parameter will only be non-zero for objects that are simulating physics.</li><li><code>FHitResult&amp; Hit</code>: The data of the hit resulting from the collision between this object and the other object. As we saw in the previous chapter, it contains properties such whether as the location of the hit is normal, which component and actor it hit, and so on. Most of the relevant information is already <a id="_idIndexMarker464"/>available to us through the other parameters, but if you need more detailed information, you can access this parameter:</li></ol><pre>UFUNCTION()
void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, 
  UPrimitiveComponent* OtherComp, FVector 
  NormalImpulse, const 
  FHitResult&amp; Hit);</pre></li>
</ol>
<p>Add the <code>OnHit</code> function’s implementation to the class’s source file and within that function, at least for now, destroy the dodgeball when it hits the player. </p>
<ol>
<li value="17">Cast the <code>OtherActor</code> parameter to our <code>DodgeballCharacter</code> class and check if the value is not a <code>nullptr</code>. If it’s not, which means that the other actor we hit is a <code>DodgeballCharacter</code>, we’ll destroy this <code>DodgeballProjectile</code> actor:<pre>void ADodgeballProjectile::OnHit(UPrimitiveComponent * 
  HitComp, AActor * OtherActor, UPrimitiveComponent * 
  OtherComp, FVector NormalImpulse, const FHitResult &amp; 
  Hit)
{
  if (Cast&lt;ADodgeballCharacter&gt;(OtherActor) != 
  nullptr)
  {
    Destroy();
  }
}</pre></li>
</ol>
<p>Given that we’re referencing the <code>DodgebalCharacter</code> class, we’ll need to include it at the top<a id="_idIndexMarker465"/> of this class’s source file:</p>
<pre>#include "DodgeballCharacter.h"</pre>
<p class="callout-heading">Note</p>
<p class="callout">In the next chapter, we’ll change this function so that we have the dodgeball damage the player before destroying itself. We’ll do this when we talk about <code>Actor</code> components.</p>
<ol>
<li value="18">Head back to the <code>DodgeballProjectile</code> class’s constructor and add the following line at the end to listen to the <code>OnHit</code> event of <code>SphereComponent</code>:<pre>// Listen to the OnComponentHit event by binding it to 
// our function
SphereComponent-&gt;OnComponentHit.AddDynamic(this, 
  &amp;ADodgeballProjectile::OnHit);</pre></li>
</ol>
<p>This will bind the <code>OnHit</code> function we created to this <code>SphereComponent</code> <code>OnHit</code> event (because this is an actor component, this event is called <code>OnComponentHit</code>), which means our function will be called alongside that event.</p>
<ol>
<li value="19">Lastly, make <code>SphereComponent</code> this actor’s <code>RootComponent</code>, as shown in the following code snippet:<pre>// Set this Sphere Component as the root component,
// otherwise collision won't behave properly
RootComponent = SphereComponent;</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">For a moving actor to behave correctly on collision, whether it’s simulating physics or not, it is usually necessary for the main collision component of the actor to be its <code>RootComponent</code>.</p>
<p class="callout">For example, the <code>RootComponent</code> component of the <code>Character</code> class is a Capsule Collider component, because that actor will be moving around and that component is the main way the character collides with the environment.</p>
<p>Now that we’ve added the <code>DodgeballProjectile</code> C++ class’s logic, let’s go ahead and create our Blueprint class.</p>
<ol>
<li value="20">Compile your changes <a id="_idIndexMarker466"/>and open the editor.</li>
<li>Go to <strong class="bold">Content</strong> | <strong class="bold">ThirdPersonCPP</strong> | <strong class="bold">Blueprints</strong> in the <strong class="bold">Content Browser</strong> area, right-click, and create a new Blueprint class.</li>
<li>Expand the <code>DodgeballProjectile</code> class. Then, set it as the parent class.</li>
<li>Name the new Blueprint class <code>BP_DodgeballProjectile</code>.</li>
<li>Open this new Blueprint class.</li>
<li>Notice the wireframe representation of the <code>HiddenInGame</code> property):</li>
</ol>
<div><div><img alt="Figure 6.8 – Visual wireframe representation of the SphereCollision component" height="216" src="img/Figure_6.08_B18531.jpg" width="266"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Visual wireframe representation of the SphereCollision component</p>
<ol>
<li value="26">Now, add a new <strong class="bold">Sphere</strong> mesh as a<a id="_idIndexMarker467"/> child of the existing <strong class="bold">Sphere Collision</strong> component:</li>
</ol>
<div><div><img alt="Figure 6.9 – Adding a Sphere mesh " height="187" src="img/Figure_6.09_B18531.jpg" width="245"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Adding a Sphere mesh</p>
<ol>
<li value="27">Change its scale to <code>0.65</code>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 6.10 – Updating the scale " height="127" src="img/Figure_6.10_B18531.jpg" width="433"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Updating the scale</p>
<ol>
<li value="28">Set its <code>NoCollision</code>:</li>
</ol>
<div><div><img alt="Figure 6.11 – Updating Collision Presets to NoCollision " height="135" src="img/Figure_6.11_B18531.jpg" width="463"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Updating Collision Presets to NoCollision</p>
<ol>
<li value="29">Finally, open our level and <a id="_idIndexMarker468"/>place an instance of the <code>BP_DodgeballProjectile</code> class near the player (this one was placed at a height of 600 units):</li>
</ol>
<div><div><img alt="Figure 6.12 – Dodgeball bouncing on the ground " height="553" src="img/Figure_6.12_B18531.jpg" width="707"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Dodgeball bouncing on the ground</p>
<p>After you’ve done this, play the level. You’ll notice that the dodgeball will be affected by gravity and bounce off the ground a couple of times before coming to a standstill.</p>
<p>By completing this exercise, you’ve<a id="_idIndexMarker469"/> created an object that behaves like a physics object. </p>
<p>You now know how to create collision object types, use the <code>OnHit</code> event, and change an object’s collision properties.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the previous chapter, we briefly mentioned <code>LineTraceSingleByObjectType</code>. Now that we know how object collision works, we can briefly mention its use: when executing a Line Trace that checks for a Trace Channel, you should use the <code>LineTraceSingleByChannel</code> function; when executing a Line Trace that checks for an Object Channel (Object Type), you should use the <code>LineTraceSingleByObjectType</code> function. It should be made clear that this function, unlike the <code>LineTraceSingleByChannel</code> function, will not check for objects that block a specific Object Type, but those that are of a specific Object Type. Both those functions have the same parameters and both the Trace Channels and Object Channels are available through the <code>ECollisionChannel</code> enum.</p>
<p>But what if you wanted the<a id="_idIndexMarker470"/> ball to bounce off the floor more times? What if you wanted to make it bouncier? Well, that’s where Physical Materials come in.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor142"/>Creating Physical Materials</h1>
<p>In UE5, you can customize how an <a id="_idIndexMarker471"/>object behaves while simulating physics using Physical Materials. To get into this new type of asset, let’s create our own:</p>
<ol>
<li value="1">Create a new folder inside the <code>Content</code> folder called <code>Physics</code>.</li>
<li><em class="italic">Right-click</em> on the <strong class="bold">Content Browser</strong> area while inside that folder and, under the <strong class="bold">Create Advanced Asset</strong> section, go to the <strong class="bold">Physics</strong> subsection and select <strong class="bold">Physical Material</strong>.</li>
<li>Name this new Physical Material <strong class="bold">PM_Dodgeball</strong>.</li>
<li>Open the asset and take a look at the available options:</li>
</ol>
<div><div><img alt="Figure 6.13 – Asset options " height="485" src="img/Figure_6.13_B18531.jpg" width="426"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Asset options</p>
<p>The main options we<a id="_idIndexMarker472"/> should note are as follows:</p>
<ul>
<li><code>0</code> to <code>1</code> and specifies how much friction will affect this object (<code>0</code> means this object will slide as if it was on ice, while <code>1</code> means this object will stick like a piece of gum).</li>
<li><code>0</code> to <code>1</code> and specifies how much velocity will be kept after colliding with another object (<code>0</code> means this object will never bounce off of the ground, while <code>1</code> means this object will bounce for a long time).</li>
<li><strong class="bold">Density</strong>: This property specifies how dense this object is (that is, how heavy it is relative to its mesh). Two objects can be of the same size, but if one is twice as dense as the other, that means it will be twice as heavy.</li>
</ul>
<p>To have our <code>DodgeballProjectile</code> object behave closer to an actual dodgeball, it’ll have to suffer quite a bit of friction (the default value is <code>0.7</code>, which is high enough) and be quite bouncy. Let’s increase<a id="_idIndexMarker473"/> the <code>Restitution</code> property of this Physical Material to <code>0.95</code>.</p>
<p>After you’ve done this, open the <strong class="bold">BP_DodgeballProjectile</strong> Blueprint class and change the <strong class="bold">Sphere Collision</strong> component’s Physical Material, inside its <strong class="bold">Collision</strong> section, to the one we just created, <strong class="bold">PM_Dodgeball</strong>:</p>
<div><div><img alt="Figure 6.14 – Updating the BP_DodgeballProjectile Blueprint class " height="191" src="img/Figure_6.14_B18531.jpg" width="462"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Updating the BP_DodgeballProjectile Blueprint class</p>
<p class="callout-heading">Note</p>
<p class="callout">Make sure the instance of the <code>Dodgeball</code> actor you added to your level also has this physical material.</p>
<p>If you play the level that we created in <em class="italic">Exercise 6.01 – creating the Dodgeball class</em>, again, you’ll notice that our <code>BP_DodgeballProjectile</code> will now bounce off the ground several times before coming to a standstill, behaving much more like an actual dodgeball.</p>
<p>With all that done, we’re just missing one thing to make our <code>Dodgeball</code> actor behave like an actual dodgeball. Right now, there is no way for us to be able to throw it. So, let’s address that by creating a Projectile Movement Component, which is what we’ll be doing in the next exercise.</p>
<p>In the previous chapters, when we replicated the Third Person template project, we learned that the <code>Character</code> class that comes with UE5 has a <code>CharacterMovementComponent</code>. This actor component is what allows an actor to move around in the level in various ways, and has many properties that allow you to customize that to your preference. However, there is another movement component that is also frequently used: <code>ProjectileMovementComponent</code>. </p>
<p>The <code>ProjectileMovementComponent</code> actor component is used to attribute the behavior of a projectile to <a id="_idIndexMarker474"/>an actor. It allows you to set an initial speed, gravity force, and even some physics simulation parameters such as <code>Bounciness</code> and <code>Friction</code>. However, given that our <code>Dodgeball Projectile</code> is already simulating physics, the only property that we’ll be using is <code>InitialSpeed</code>.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor143"/>Exercise 6.02 – adding a ProjectileMovementComponent to DodgeballProjectile</h2>
<p>In this <a id="_idIndexMarker475"/>exercise, we will be adding a <code>ProjectileMovementComponent</code> to our <code>DodgeballProjectile</code> so that it has an initial horizontal speed. We’re doing this so that it can be thrown by our enemies and doesn’t just fall vertically.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Add a <code>ProjectileMovementComponent</code> property to the <code>DodgeballProjectile</code> class’s header file:<pre>UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = 
  Dodgeball, meta = (AllowPrivateAccess = "true"))
class UProjectileMovementComponent* ProjectileMovement;</pre></li>
<li>Include the <code>ProjectileMovementComponent</code> class at the top of the class’s source file:<pre>#include "GameFramework/ProjectileMovementComponent.h"</pre></li>
<li>At the end of the class’s constructor, create the <code>ProjectileMovementComponent</code> object:<pre>ProjectileMovement = CreateDefaultSubobject&lt;UProjectileMovementComponent&gt;(TEXT("Pro
  jectile Movement"));</pre></li>
<li>Then, set its <code>InitialSpeed</code> to <code>1500</code> units:<pre>ProjectileMovement-&gt;InitialSpeed = 1500.f;</pre></li>
</ol>
<p>Once<a id="_idIndexMarker476"/> you’ve done this, compile your project and open the editor. To demonstrate the dodgeball’s initial speed, lower its position on the <em class="italic">Z</em>-axis and place it behind the player (<em class="italic">this one was placed at a height of 200 units</em>):</p>
<div><div><img alt="Figure 6.15 – Dodgeball moving along the X-axis " height="601" src="img/Figure_6.15_B18531.jpg" width="583"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Dodgeball moving along the X-axis</p>
<p>When you play the level, you’ll notice that the dodgeball starts moving toward its <em class="italic">X</em>-axis (<em class="italic">red arrow</em>) </p>
<p>And with that, we <a id="_idIndexMarker477"/>can conclude our exercise. Our <code>DodgeballProjectile</code> now behaves like an actual dodgeball. It falls, bounces, and gets thrown.</p>
<p>The next step in our project is going to be adding logic to our <code>EnemyCharacter</code> so that it throws these dodgeballs at the player. However, before we address that, we must address the concept of timers.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor144"/>Introducing timers</h1>
<p>Given the nature of video games and the fact that they’re strongly event-based, every game development tool <a id="_idIndexMarker478"/>must have a way for you to cause a delay, or a wait time, before something happens. For instance, when you’re playing an online deathmatch game, where your character can die and then respawn, usually, the respawn event doesn’t happen the instant your character dies but a few seconds later. There is a multitude of scenarios where you want something to happen, but only after a certain amount of time. This will be the case for our <code>EnemyCharacter</code>, which will be throwing dodgeballs every few seconds. This delay, or wait time, can be achieved through timers.</p>
<p>A <strong class="bold">timer</strong> allows you to call a function after a certain amount of time. You can choose to loop that function call with an interval and also set a delay before the loop starts. If you want the timer to stop, you can also do that.</p>
<p>We will be using timers so that our enemy throws a dodgeball every <code>X</code> amount of time, indefinitely, so long as it can see the player character, and then stop that timer when the enemy can no longer see its target.</p>
<p>Before we start adding logic to our <code>EnemyCharacter</code> class that will make it throw dodgeballs at the player, we should take a look at another topic, which is how to spawn actors.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor145"/>Understanding how to spawn actors</h1>
<p>In <a href="B18531_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Unreal Engine</em>, you learned how to place an actor that you created in the level through<a id="_idIndexMarker479"/> the editor, but what if you wanted to place that actor in the level as the game is being played? That’s what we’re going to be taking a look at now.</p>
<p>UE5, much like most other game development tools, allows you to place an actor in the game while the game itself is running. This <a id="_idIndexMarker480"/>process is called <code>SpawnActor</code> function, available from the <code>World</code> object (which we can access using the <code>GetWorld</code> function, as mentioned previously). However, the <code>SpawnActor</code> function has a few parameters that need to be passed, as follows:</p>
<ul>
<li>A <code>UClass*</code> property, which lets the function know the class of the object that will be spawned. This property can be a C++ class, available through the <code>NameOfC++Class::StaticClass()</code> function, or a Blueprint class, available through the <code>TSubclassOf</code> property. It is generally a good practice not to spawn actors from a<a id="_idIndexMarker481"/> C++ class directly, but to create a Blueprint class and spawn an instance of that instead.</li>
<li>The <code>TSubclassOf</code> property is a way for you to reference a Blueprint class in C++. It’s used for referencing a class in C++ code, which might be a Blueprint class. You must declare a <code>TSubclassOf</code> property with a template parameter, which is the C++ class that the class must inherit from. We will be taking a look at how to use this property in practice in the next exercise.</li>
<li>Either an <code>FTransform</code> property or the <code>FVector</code> and <code>FRotator</code> properties, which will indicate the location, rotation, and scale of the object we want to spawn.</li>
<li>An optional <code>FActorSpawnParameters</code> property, which allows you to specify more properties specific to the spawning process, such as who caused the actor to spawn (that is, <code>Instigator</code>), how to handle the object spawning if the location that it spawns at is being occupied by other objects, which may cause an overlap or a block event, and so on.</li>
</ul>
<p>The <code>SpawnActor</code> function will return an instance to the actor that was spawned from this function. Given that it is also a template function, you can call it in such a way that you receive a reference to the type of actor you spawned directly using a template parameter:</p>
<pre>GetWorld()-&gt;SpawnActor&lt;NameOfC++Class&gt;(ClassReference, 
  SpawnLocation, SpawnRotation);</pre>
<p>In this case, the <code>SpawnActor</code> function is being called, where we’re spawning an instance of the <code>NameOfC++Class</code> class. Here, we have provided a reference to the class with the <code>ClassReference</code> property and the location and rotation of the actor to be spawned using the <code>SpawnLocation</code> and <code>SpawnRotation</code> properties, respectively.</p>
<p>You will learn how to apply these properties in <em class="italic">Exercise 6.03 – adding projectile-throwing logic to the EnemyCharacter class</em>.</p>
<p>Before we continue with the exercise, though, I’d like to briefly mention a variation of the <code>SpawnActor</code> function that may also come in handy: the <code>SpawnActorDeferred</code> function. While the <code>SpawnActor</code> function will create an instance of the object you specify and then place it in the <a id="_idIndexMarker482"/>world, this new <code>SpawnActorDeferred</code> function will create an instance of the object you want, and only place it in the world when you call the actor’s <code>FinishSpawning</code> function.</p>
<p>For instance, let’s say we want to change the <code>InitialSpeed</code> of our dodgeball at the moment we spawn it. If we use the <code>SpawnActor</code> function, there’s a chance that the dodgeball will start moving before we set its <code>InitialSpeed</code> property. However, by using the <code>SpawnActorDeferred</code> function, we can create an instance of the dodgeball, then set its <code>InitialSpeed</code> to whatever we want, and only then place it in the world by calling the newly created dodgeball’s <code>FinishSpawning</code> function, whose instance is returned to us by the <code>SpawnActorDeferred</code> function.</p>
<p>Now that we know how to spawn an actor in the world, and also about the concept of timers, we can add the logic that’s responsible for throwing dodgeballs to our <code>EnemyCharacter</code> class, which is what we’ll be doing in the next exercise. </p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor146"/>Exercise 6.03 – adding projectile-throwing logic to the EnemyCharacter class</h2>
<p>In this exercise, we<a id="_idIndexMarker483"/> will be adding the logic that’s responsible for throwing the <code>EnemyCharacter</code> class.</p>
<p>Open the class’s files in Visual Studio to get started. We will begin by modifying our <code>LookAtActor</code> function so that we can save the value that tells us whether we can see the player and use it to manage our timer.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">In the <code>EnemyCharacter</code> class’s header file, change the <code>LookAtActor</code> function’s return type from <code>void</code> to <code>bool</code>:<pre>// Change the rotation of the character to face the 
// given actor
// Returns whether the given actor can be seen
bool LookAtActor(AActor* TargetActor);</pre></li>
<li>Do the same in<a id="_idIndexMarker484"/> the function’s implementation, inside the class’s source file, while also returning <code>true</code> at the end of the <code>if</code> statement where we call the <code>CanSeeActor</code> function. Also, return <code>false</code> in the first <code>if</code> statement, where we check if <code>TargetActor</code> is a <code>nullptr</code>, and also at the end of the function:<pre>bool AEnemyCharacter::LookAtActor(AActor * TargetActor)
{
  if (TargetActor == nullptr) return false;
  if (CanSeeActor(TargetActor))
  {
    FVector Start = GetActorLocation();
    FVector End = TargetActor-&gt;GetActorLocation();
    // Calculate the necessary rotation for the Start 
    // point to face the End point
    FRotator LookAtRotation = 
    UKismetMathLibrary::FindLookAtRotation(
    Start, End);
    //Set the enemy's rotation to that rotation
    SetActorRotation(LookAtRotation);
    return true;
  }
  return false;
}</pre></li>
<li>Next, add two <code>bool</code> properties, <code>bCanSeePlayer</code> and <code>bPreviousCanSeePlayer</code>, set to <code>protected</code> in your class’s header file, which will represent<a id="_idIndexMarker485"/> whether the player can be seen in this frame from the enemy character’s perspective and whether the player could be seen in the last frame, respectively:<pre>//Whether the enemy can see the player this frame
bool bCanSeePlayer = false;
//Whether the enemy could see the player last frame
bool bPreviousCanSeePlayer = false;</pre></li>
<li>Then, go to your class’s <code>Tick</code> function implementation and set the value of <code>bCanSeePlayer</code> to the return value of the <code>LookAtActor</code> function. This will replace the previous call to the <code>LookAtActor</code> function:<pre>// Look at the player character every frame
bCanSeePlayer = LookAtActor(PlayerCharacter);</pre></li>
<li>After that, set the value of <code>bPreviousCanSeePlayer</code> to the value of <code>bCanSeePlayer</code>:<pre>bPreviousCanSeePlayer = bCanSeePlayer;</pre></li>
<li>In-between the previous two lines, add an <code>if</code> statement that checks whether the values of <code>bCanSeePlayer</code> and <code>bPreviousCanSeePlayer</code> are different. This will mean that either we couldn’t see the player in the last frame and now we can, or that we could see the player in the last frame and now we can’t:<pre>bCanSeePlayer = LookAtActor(PlayerCharacter);
if (bCanSeePlayer != bPreviousCanSeePlayer)
{
}
bPreviousCanSeePlayer = bCanSeePlayer;</pre></li>
<li>Inside this <code>if</code> statement, we<a id="_idIndexMarker486"/> want to start a timer if we can see the player and stop that timer if we can no longer see the player:<pre>if (bCanSeePlayer != bPreviousCanSeePlayer)
{
  if (bCanSeePlayer)
  {
    //Start throwing dodgeballs
  }
  else
  {
    //Stop throwing dodgeballs
  }
}</pre></li>
<li>To start a timer, we’ll need to add the following properties to our class’s header file, which can all be <code>protected</code>:<ul><li>An <code>FTimerHandle</code> property, which is responsible for identifying which timer we want to start. It works as the identifier of a specific timer:<pre>FTimerHandle ThrowTimerHandle;</pre></li><li>A <code>float</code> property, which represents the amount of time to wait between throwing dodgeballs (the interval) so that we can loop the timer. We give this a default value of <code>2</code> seconds:<pre>float ThrowingInterval = 2.f;</pre></li><li>Another <code>float</code> property, which represents the initial delay before the timer starts looping. Let’s give it a default value of <code>0.5</code> seconds:<pre>float ThrowingDelay = 0.5f;</pre></li><li>A function to be called every time the timer ends, which we will create and call <code>ThrowDodgeball</code>. This function doesn’t return anything and doesn’t receive any parameters:<pre>void ThrowDodgeball();</pre></li></ul></li>
</ol>
<p>Before we can call the <a id="_idIndexMarker487"/>appropriate function to start the timer, we will need to add an <code>#include</code> to the object responsible for that, <code>FTimerManager</code>, in our source file. </p>
<p>Each <code>World</code> has one Timer Manager, which can start and stop timers and access relevant functions related to them, such as whether they’re still active, how long they will be running for, and so on:</p>
<pre>#include "TimerManager.h"</pre>
<ol>
<li value="9">Now, access the current <code>World</code> Timer Manager by using the <code>GetWorldTimerManager</code> function:<pre>GetWorldTimerManager()</pre></li>
<li>Next, call the <code>SetTimer</code> function of the Timer Manager, if you can see the player character, to start the timer responsible for throwing dodgeballs. The <code>SetTimer</code> function receives the following parameters:<ul><li>An <code>FTimerHandle</code> that represents the desired timer: <code>ThrowTimerHandle</code>.</li><li>The object that the function to be called belongs to: <code>this</code>.</li><li>The function to be called, which must be specified by prefixing its name with <code>&amp;ClassName::</code>, resulting in <code>&amp;AEnemyCharacter::ThrowDodgeball</code>.</li><li>The timer’s rate, or interval: <code>ThrowingInterval</code>.</li><li>Whether this<a id="_idIndexMarker488"/> timer will loop: <code>true</code>.</li><li>The delay before this timer starts looping: <code>ThrowingDelay</code>.</li></ul></li>
</ol>
<p>The following code snippet comprises these parameters:</p>
<pre>if (bCanSeePlayer)
{
  //Start throwing dodgeballs
  GetWorldTimerManager().SetTimer(ThrowTimerHandle,
  this,
  &amp;AEnemyCharacter::ThrowDodgeball,ThrowingInterval,
  true,
  ThrowingDelay);
}</pre>
<ol>
<li value="11">If we can no longer see the player and we want to stop the timer, we can do so using the <code>ClearTimer</code> function. This function only needs to receive an <code>FTimerHandle</code> property as a parameter:<pre>else
{
  //Stop throwing dodgeballs
  GetWorldTimerManager().ClearTimer(ThrowTimerHandle);
}</pre></li>
</ol>
<p>The only thing left is to implement the <code>ThrowDodgeball</code> function. This function will be<a id="_idIndexMarker489"/> responsible for spawning a new <code>DodgeballProjectile</code> actor. To do this, we’ll need a reference to the class we want to spawn, which must inherit from <code>DodgeballProjectile</code>. So, the next thing we need to do is create the appropriate property using the <code>TSubclassOf</code> object.</p>
<ol>
<li value="12">Create the <code>TSubclassOf</code> property in the <code>EnemyCharacter</code> header file, which can be <code>public</code>:<pre>//The class used to spawn a dodgeball object
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = 
  Dodgeball)
TSubclassOf&lt;class ADodgeballProjectile&gt; DodgeballClass;</pre></li>
<li>Because we’ll be using the <code>DodgeballProjectile</code> class, we also need to include it in the <code>EnemyCharacter</code> source file:<pre>#include "DodgeballProjectile.h"</pre></li>
<li>Then, within the <code>ThrowDodgeball</code> function’s implementation in the source file, start by checking if this property is a <code>nullptr</code>. If it is, we <code>return</code> immediately:<pre>void AEnemyCharacter::ThrowDodgeball()
{
  if (DodgeballClass == nullptr)
  {
    return;
  }
}</pre></li>
<li>Next, we will be spawning a new actor from that class. Its location will be <code>40</code> units in front of the enemy and its rotation will be the same as the enemy. To spawn the dodgeball in front of<a id="_idIndexMarker490"/> the enemy character, we’ll need to access the enemy’s <code>ForwardVector</code> property, which is a unitary <code>FVector</code> (<em class="italic">meaning that its length is 1</em>) that indicates the direction an actor is facing, and multiply it by the distance at which we want to spawn our dodgeball, which is <code>40</code> units:<pre>FVector ForwardVector = GetActorForwardVector();
float SpawnDistance = 40.f;
FVector SpawnLocation = GetActorLocation() + (ForwardVector * 
  SpawnDistance);
//Spawn new dodgeball
GetWorld()-&gt;SpawnActor&lt;ADodgeballProjectile&gt;(DodgeballClass, 
  SpawnLocation, GetActorRotation());</pre></li>
</ol>
<p>This concludes the modifications we need to make to the <code>EnemyCharacter</code> class. Before we finish setting up the Blueprint of this logic, let’s make a quick modification to our <code>DodgeballProjectile</code> class.</p>
<ol>
<li value="16">Open the <code>DodgeballProjectile</code> class’s source file in Visual Studio. </li>
<li>Within its <code>LifeSpan</code> to <code>5</code> seconds. This property, which belongs to all actors, dictates how much longer they will remain in the game before being destroyed. By setting our dodgeball’s <code>LifeSpan</code> to <code>5</code> seconds on its <code>BeginPlay</code> event, we are telling UE5 to destroy that object 5 seconds after it’s spawned (<em class="italic">or if it’s already been placed in the level, 5 seconds after the game starts</em>). We will do this so that the floor isn’t filled with dodgeballs after a certain amount of time, which would make the game unintentionally difficult for the player:<pre>void ADodgeballProjectile::BeginPlay()
{
  Super::BeginPlay();
  
  SetLifeSpan(5.f);
}</pre></li>
</ol>
<p>Now that we’ve finished <a id="_idIndexMarker491"/>our C++ logic related to the <code>EnemyCharacter</code> class’s dodgeball-throwing logic, let’s compile our changes, open the editor, and then open our <code>BP_EnemyCharacter</code> Blueprint. There, head to the <code>Dodgeball</code> <code>Class</code> property’s value to <code>BP_DodgeballProjectile</code>:</p>
<div><div><img alt="Figure 6.16 – Updating Dodgeball Class " height="50" src="img/Figure_6.16_B18531.jpg" width="434"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Updating Dodgeball Class</p>
<p>After you’ve done this, you can remove the existing instance of the <code>BP_DodgeballProjectile</code> class we placed in our level if it’s still there.</p>
<p>Now, we can play our level. You’ll notice that the enemy will almost immediately start throwing dodgeballs at the player and will continue to do so, so long as the player character is in view:</p>
<div><div><img alt="Figure 6.17 – Enemy character throwing dodgeballs if the player is in sight " height="467" src="img/Figure_6.17_B18531.jpg" width="493"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Enemy character throwing dodgeballs if the player is in sight</p>
<p>With that, we have<a id="_idIndexMarker492"/> concluded our dodgeball-throwing logic for <code>EnemyCharacter</code>. You now know how to use timers, an essential tool for any game programmer.</p>
<p>Now, let’s jump into the next section, where we’ll be creating walls that handle collision differently.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor147"/>Creating the Wall classes</h1>
<p>The next step in<a id="_idIndexMarker493"/> our project is going to be creating the <code>Wall</code> classes. We will have two types of walls:</p>
<ul>
<li>A normal wall, which will block the enemy’s line of sight, the player character, and the dodgeball.</li>
<li>A ghost wall, which will only block the player character, and ignore the enemy’s line of sight and the dodgeball. You may find this type of collision setup in specific types of puzzle games.</li>
</ul>
<p>We’ll create both these Wall classes in the next exercise.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor148"/>Exercise 6.04 – creating Wall classes</h2>
<p>In this exercise, we will be<a id="_idIndexMarker494"/> creating the <code>Wall</code> classes that represent both a normal <code>Wall</code> and a <code>GhostWall</code>, which will only block the player character’s movement, but not the enemies’ lines of sight or the dodgeballs they throw.</p>
<p>Let’s start with the normal <code>Wall</code> class. This C++ class will be empty because the only thing that it’ll need is a mesh to reflect the projectiles and block the enemies’ lines of sight, which will be added through its Blueprint class.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Open the editor.</li>
<li>In the top-left corner of the <strong class="bold">Content Browser</strong> area, press the green <strong class="bold">Add New</strong> button.</li>
<li>Select the first option at the top; that is, <strong class="bold">Add Feature or Content Pack</strong>.</li>
<li>A new window will appear. Select the <strong class="bold">Content Packs</strong> tab, select the <strong class="bold">Starter Content</strong> pack, and then press the <strong class="bold">Add To Project</strong> button. This will add some basic assets to the project, which we’ll use in this chapter and some of the following chapters.</li>
<li>Create a new C++ class, called <code>Wall</code>, with the <code>Actor</code> class as its parent.</li>
<li>Next, open the class’s files in Visual Studio and add a <code>SceneComponent</code> as our Wall’s <code>RootComponent</code>:<ul><li>The <code>Header</code> file will be as follows:<pre>private:
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Wall, 
  meta = (AllowPrivateAccess = "true"))
class USceneComponent* RootScene;</pre></li><li>The <code>Source</code> file will be as follows:<pre>AWall::AWall()
{
  // Set this actor to call Tick() every frame.  You 
  // can turn this off to improve performance if you 
  // don't need it.
  PrimaryActorTick.bCanEverTick = true;
  RootScene = CreateDefaultSubobject&lt;USceneComponent&gt;(
  TEXT("Root"));
  RootComponent = RootScene;
}</pre></li></ul></li>
<li>Compile your code<a id="_idIndexMarker495"/> and open the editor.</li>
</ol>
<p>Next, go to <code>Wall</code> class, name it <code>BP_Wall</code>, and open that asse:.</p>
<ol>
<li value="1">Add a <code>Wall_400x400</code>.</li>
<li>Set its <code>M_Metal_Steel</code>.</li>
<li>Set the <code>–200</code> units (<em class="italic">so that the mesh is centered relative to our actor’s origin</em>):</li>
</ol>
<div><div><img alt="Figure 6.18 – Updating the Static Mesh component’s location " height="124" src="img/Figure_6.18_B18531.jpg" width="436"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Updating the Static Mesh component’s location</p>
<p>This is what your <a id="_idIndexMarker496"/>Blueprint class’s Viewport should look like:</p>
<div><div><img alt="Figure 6.19 – The Blueprint class’s Viewport Wall " height="501" src="img/Figure_6.19_B18531.jpg" width="668"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – The Blueprint class’s Viewport Wall</p>
<p class="callout-heading">Note</p>
<p class="callout">It is generally good practice to add a <code>SceneComponent</code> as an object’s <code>RootComponent</code>, when a collision component isn’t necessary, to allow for more flexibility with its child components.</p>
<p class="callout">An actor’s <code>RootComponent</code> cannot have its location or rotation modified, which is why, in our case, if we had created a <code>Wall</code> C++ class and set that as its root component, instead of using a scene component, we’d have a hard time offsetting it.</p>
<p>Now that we’ve set <a id="_idIndexMarker497"/>up the regular <code>Wall</code> class, let’s create our <code>GhostWall</code> class. Because these classes don’t have any logic set up, we’re just going to create the <code>GhostWall</code> class as a child of the <code>BP_Wall</code> Blueprint class and not our C++ class:</p>
<ol>
<li value="1"><em class="italic">Right-click</em> the <strong class="bold">BP_Wall</strong> asset and select <strong class="bold">Create Child Blueprint Class</strong>.</li>
<li>Name the new Blueprint <code>BP_GhostWall</code>.</li>
<li>Open it.</li>
<li>Change the <code>CollisionPreset</code> to <code>Custom</code>.</li><li>Change its response to both the <code>EnemySight</code> and <code>Dodgeball</code> channels to <code>Overlap</code>.</li></ul></li>
<li>Change the <code>Material</code> property to <code>M_Metal_Copper</code>.</li>
</ol>
<p>The <code>BP_GhostWall</code> Viewport should now look like this:</p>
<div><div><img alt="Figure 6.20 – Creating the GhostWall class " height="385" src="img/Figure_6.20_B18531.jpg" width="480"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Creating the GhostWall class</p>
<p>Now that you’ve created both these <code>Wall</code> actors, place each in the level to test them. Set their<a id="_idIndexMarker498"/> transforms to the following transform values:</p>
<ul>
<li><code>Location</code>: <code>(710, -1710, 0)</code></li>
<li><code>Location</code>: <code>(720, 1720, 0)</code>; <code>Rotation</code>: <code>(0, 0, 90)</code>:</li>
</ul>
<div><div><img alt="Figure 6.21 – Updating the GhostWall class’s locations and rotation  " height="748" src="img/Figure_6.21_B18531.jpg" width="1137"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Updating the GhostWall class’s locations and rotation </p>
<p>The outcome should look like this:</p>
<div><div><img alt="Figure 6.22 – Outcome of the GhostWall and Wall classes " height="428" src="img/Figure_6.22_B18531.jpg" width="490"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Outcome of the GhostWall and Wall classes</p>
<p>You’ll notice that when <a id="_idIndexMarker499"/>you hide your character behind the normal <code>Wall</code> (the one on the right), the enemy won’t throw dodgeballs at the player; however, when you try to hide your character behind <code>GhostWall</code> (the one on the left), even though the enemy can’t go through it, the enemy will throw dodgeballs at the character and they will pass through the wall as if it wasn’t there!</p>
<p>And that concludes our exercise. We have made our <code>Wall</code> actors, which will either behave normally or ignore the enemies’ lines of sight and dodgeballs!</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor149"/>Creating the VictoryBox actor</h1>
<p>The next step in our project is <a id="_idIndexMarker500"/>going to be creating the <code>VictoryBox</code> actor. This actor will be responsible for ending the game when the player character enters it, given that the player has beaten the level. To do this, we’ll be using the <code>Overlap</code> event. The following exercise will help us understand <code>VictoryBox</code>.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor150"/>Exercise 6.05 – creating the VictoryBox class</h2>
<p>In this exercise, we will be<a id="_idIndexMarker501"/> creating the <code>VictoryBox</code> class, which, when entered by the player character, will end the game.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Create a new C++ class that inherits from the actor and call it <code>VictoryBox</code>.</li>
<li>Open that class’s files in Visual Studio.</li>
<li>Create a new <code>SceneComponent</code> property, which will be used as a <code>RootComponent</code>, just like we did with our <code>Wall</code> C++ class:<ul><li><code>Header</code> file:<pre>private:
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = 
  VictoryBox, meta = (AllowPrivateAccess = "true"))
class USceneComponent* RootScene;</pre></li><li><code>Source</code> file:<pre>AVictoryBox::AVictoryBox()
{
  // Set this actor to call Tick() every frame.  You 
  // can turn this off to improve performance if you 
  // don't need it.
  PrimaryActorTick.bCanEverTick = true;
  RootScene = 
  CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("Root"));
  RootComponent = RootScene;
}</pre></li></ul></li>
<li>Declare a <code>BoxComponent</code> in the header file that will check for overlap events with the player character, which <a id="_idIndexMarker502"/>should also be <code>private</code>:<pre>UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = 
  VictoryBox, meta = (AllowPrivateAccess = "true"))
class UBoxComponent* CollisionBox;</pre></li>
<li>Include the <code>BoxComponent</code> file in the class’s source file:<pre>#include "Components/BoxComponent.h"</pre></li>
<li>After creating the <code>RootScene</code> component, create <code>BoxComponent</code>, which should also be <code>private</code>:<pre>RootScene = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("Root"));
RootComponent = RootScene;
CollisionBox = 
  CreateDefaultSubobject&lt;UBoxComponent&gt;(
  TEXT("Collision Box"));</pre></li>
<li>Attach it to <code>RootComponent</code> using the <code>SetupAttachment</code> function:<pre>CollisionBox-&gt;SetupAttachment(RootComponent);</pre></li>
<li>Set its <code>BoxExtent</code> property to <code>60</code> units on all axes. This will cause <code>BoxComponent</code> to be double that size – that is, <code>(120 x 120 x 120)</code>:<pre>CollisionBox-&gt;SetBoxExtent(FVector(60.0f, 60.0f, 60.0f));</pre></li>
<li>Offset its relative position on the <em class="italic">Z</em>-axis by <code>120</code> units using the <code>SetRelativeLocation</code> function:<pre>CollisionBox-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 
  120.0f));</pre></li>
<li>Now, you will require a function that will listen to the BoxComponent’s <code>OnBeginOverlap</code> event. This event will be called whenever an object enters <code>BoxComponent</code>. This <a id="_idIndexMarker503"/>function must be preceded by the <code>UFUNCTION</code> macro, be <code>public</code>, return nothing, and have the following parameters:<pre>UFUNCTION()
void OnBeginOverlap(UPrimitiveComponent* OverlappedComp, 
  AActor* OtherActor, UPrimitiveComponent* OtherComp, 
  int32 
  OtherBodyIndex, bool bFromSweep, const FHitResult&amp; 
  SweepResult);</pre></li>
</ol>
<p>These parameters are as follows:</p>
<ul>
<li><code>UPrimitiveComponent* OverlappedComp</code>: The component that was overlapped and belongs to this actor.</li>
<li><code>AActor* OtherActor</code>: The other actor involved in the overlap.</li>
<li><code>UPrimitiveComponent* OtherComp</code>: The component that was overlapped and belongs to the other actor.</li>
<li><code>int32 OtherBodyIndex</code>: The index of the item in the primitive that was hit (usually useful for Instanced Static Mesh components).</li>
<li><code>bool bFromSweep</code>: Whether the overlap originated from a Sweep Trace.</li>
<li><code>FHitResult&amp; SweepResult</code>: The data of the Sweep Trace resulting from the collision between this object and the other object.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Although we won’t be using the <code>OnEndOverlap</code> event in this project, you will most likely need to use it sooner or later, so here’s the required function signature for that event, which looks very similar to the one we just learned about:</p>
<p class="callout"><code>UFUNCTION()</code></p>
<p class="callout"><code>void OnEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);</code></p>
<ol>
<li value="11">Next, we need to<a id="_idIndexMarker504"/> bind this function to the BoxComponent’s <code>OnComponentBeginOverlap</code> event:<pre>CollisionBox-&gt;OnComponentBeginOverlap.AddDynamic(this, 
  &amp;AVictoryBox::OnBeginOverlap);</pre></li>
<li>Within our <code>OnBeginOverlap</code> function implementation, we’re going to check whether the actor we overlapped is a <code>DodgeballCharacter</code>. Because we’ll be referencing this class, we also need to include it:<pre>#include "DodgeballCharacter.h" 
void AVictoryBox::OnBeginOverlap(UPrimitiveComponent * 
  OverlappedComp, AActor * OtherActor, 
  UPrimitiveComponent * 
  OtherComp, int32 OtherBodyIndex, bool bFromSweep, 
  const 
  FHitResult &amp; SweepResult)
{
  if (Cast&lt;ADodgeballCharacter&gt;(OtherActor))
  {
  }
}</pre></li>
</ol>
<p>If the actor we overlapped is a <code>DodgeballCharacter</code>, we want to quit the game.</p>
<ol>
<li value="13">We will use <code>KismetSystemLibrary</code> for this purpose. The <code>KismetSystemLibrary</code> class contains <a id="_idIndexMarker505"/>useful functions for general use in your project:<pre>#include "Kismet/KismetSystemLibrary.h"</pre></li>
<li>To quit the game, we will call the <code>QuitGame</code> function of <code>KismetSystemLibrary</code>. This function receives the following:<pre>UKismetSystemLibrary::QuitGame(GetWorld(),
  nullptr,
  EQuitPreference::Quit,
  true);</pre></li>
</ol>
<p>The important parameters from the preceding code snippet are as follows:</p>
<ul>
<li>A <code>World</code> object, which we can access with the <code>GetWorld</code> function.</li>
<li>A <code>PlayerController</code> object, which we will set to <code>nullptr</code>. We’re doing this because this function will automatically find one this way.</li>
<li>An <code>EQuitPreference</code> object, which means how we want to end the game, by either quitting or just putting it as a background process. We will want to quit the game, and not just put it as a background process.</li>
<li>A <code>bool</code>, which indicates whether we want to ignore the platform’s restrictions when it comes to quitting the game, which we will set to <code>true</code>.</li>
</ul>
<p>Next, we’re going to create our Blueprint class.</p>
<ol>
<li value="15">Compile your changes, open the editor, go to <code>VictoryBox</code>, and name it <code>BP_VictoryBox</code>. Open that asset and make the following modifications:<ul><li>Add a new <code>Floor_400x400</code></li><li>Set its <code>M_Metal_Gold</code></li><li>Set its scale to <code>0.75</code> units on all three axes</li><li>Set its location to <code>(-150, -150, 20)</code>, on the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> axes, respectively.</li></ul></li>
</ol>
<p>Once you’ve made<a id="_idIndexMarker506"/> those changes, your Blueprint’s <strong class="bold">Viewport</strong> tab should look something like this:</p>
<div><div><img alt="Figure 6.23 – VictoryBox placed in the Blueprint’s Viewport tab " height="522" src="img/Figure_6.23_B18531.jpg" width="724"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – VictoryBox placed in the Blueprint’s Viewport tab</p>
<p>Place that Blueprint inside your level to test its functionality:</p>
<div><div><img alt="Figure 6.24 – VictoryBox Blueprint in the level for testing " height="467" src="img/Figure_6.24_B18531.jpg" width="606"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – VictoryBox Blueprint in the level for testing</p>
<p>If you play the level and step <a id="_idIndexMarker507"/>onto the golden plate (and overlap the collision box), you’ll notice that the game abruptly ends, as intended.</p>
<p>And with that, we conclude our <code>VictoryBox</code> class! You now know how to use the overlap events in your projects. There’s a multitude of game mechanics that you can create using these events, so congratulations on completing this exercise.</p>
<p>We are now very close to reaching the end of this chapter, where we’ll be completing a new activity, but first, we’ll need to make some modifications to our <code>DodgeballProjectile</code> class, namely adding a getter function to its <code>ProjectileMovementComponent</code>. We’ll do this in the next exercise.</p>
<p>A getter function is a function that only returns a specific property and does nothing else. These functions are usually marked as inline, which means that when the code compiles, a call to that function will simply be replaced with its content. They are also usually marked as <code>const</code>, given that they don’t modify any of the class’s properties.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor151"/>Exercise 6.06 – adding the ProjectileMovementComponent getter function to DodgeballProjectile</h2>
<p>In this exercise, we will be adding a <a id="_idIndexMarker508"/>getter function to the <code>DodgeballProjectile</code> class’s <code>ProjectileMovement</code> property so that other classes can access it and modify its properties. We will be doing the same in this chapter’s activity. </p>
<p>To do this, you’ll need to follow these steps:</p>
<ol>
<li value="1">Open the <code>DodgeballProjectile</code> class’s header file in Visual Studio.</li>
<li>Add a new <code>public</code> function called <code>GetProjectileMovementComponent</code>. This function will be an inline function, which in UE5’s version of C++ is replaced with the <code>FORCEINLINE</code> macro. The function should also return a <code>UProjectileMovementComponent*</code> and be a <code>const</code> function:<pre>FORCEINLINE class UProjectileMovementComponent* 
  GetProjectileMovementComponent() const
{
  return ProjectileMovement;
}</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">When using the <code>FORCEINLINE</code> macro for a specific function, you can’t add the declaration of that function to the header file and its implementation to the source file. Both must be done simultaneously in the header file, as shown previously.</p>
<p>With that, we have concluded this quick exercise. Here, we have added a simple <code>getter</code> function to our <code>DodgeballProjectile</code> class, which we will be using in this chapter’s activity, where we’ll replace the <code>SpawnActor</code> function within the <code>EnemyCharacter</code> class with the <code>SpawnActorDeferred</code> function. This will allow us to safely edit our <code>DodgeballProjectile</code> class’s properties before we spawn an instance of it.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor152"/>Activity 6.01 – replacing the SpawnActor function with SpawnActorDeferred in EnemyCharacter</h2>
<p>In this activity, you will be <a id="_idIndexMarker509"/>changing the EnemyCharacter’s <code>ThrowDodgeball</code> function to use the <code>SpawnActorDeferred</code> function instead of the <code>SpawnActor</code> function so<a id="_idIndexMarker510"/> that we can change the <a id="_idIndexMarker511"/>DodgeballProjectile’s <code>InitialSpeed</code> before spawning it. </p>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Open the <code>EnemyCharacter</code> class’s source file in Visual Studio.</li>
<li>Go to the <code>ThrowDodgeball</code> function’s implementation.</li>
<li>Because the <code>SpawnActorDeferred</code> function can’t just receive a spawn location and rotation properties and must receive an <code>FTransform</code> property instead, we’ll need to create one of those before we call that function. Let’s call it <code>SpawnTransform</code> and send the spawn rotation and location, in that order, as inputs for its constructor, which will be this enemy’s rotation and the <code>SpawnLocation</code> property, respectively.</li>
<li>Then, update the <code>SpawnActor</code> function call in the <code>SpawnActorDeferred</code> function call. Instead of sending the spawn location and spawn rotation as its second and third parameters, replace those with the <code>SpawnTransform</code> properties we just created, as the second parameter.</li>
<li>Make sure you save the return value of this function call inside an <code>ADodgeballProjectile*</code> property called <code>Projectile</code>.</li>
</ol>
<p>Once you’ve done this, you will have successfully created a new <code>DodgeballProjectile</code> object. However, we still need to change its <code>InitialSpeed</code> property and spawn it.</p>
<ol>
<li value="6">Once you’ve called the <code>SpawnActorDeferred</code> function, call the <code>Projectile</code> property’s <code>GetProjectileMovementComponent</code> function, which returns its <code>ProjectileMovementComponent</code>, and change its <code>InitialSpeed</code> property to <code>2200</code> units.</li>
<li>Because we’ll be accessing properties that belong to <code>ProjectileMovementComponent</code> inside the <code>EnemyCharacter</code> class, we’ll need to include that <a id="_idIndexMarker512"/>component, just like we did in <em class="italic">Exercise 6.02 – adding a ProjectileMovementComponent to DodgeballProjectile</em>.</li>
<li>Once you’ve changed the <a id="_idIndexMarker513"/>value of the <code>InitialSpeed</code> property, the only thing left to do is call the <code>Projectile</code> property’s <code>FinishSpawning</code> function, which will receive the <code>SpawnTransform</code> property we created as a parameter.</li>
<li>Once you’ve done<a id="_idIndexMarker514"/> this, compile your changes and open the editor.</li>
</ol>
<p><strong class="bold">Expected output</strong>:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div><div><img alt="Figure 6.25 – Dodgeball thrown at the player " height="554" src="img/Figure_6.25_B18531.jpg" width="542"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25 – Dodgeball thrown at the player</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this<a id="_idIndexMarker515"/> activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>By completing this activity, you’ve<a id="_idIndexMarker516"/> consolidated the <a id="_idIndexMarker517"/>use of the <code>SpawnActorDeferred</code> function and know how to use it in your future projects.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor153"/>Summary</h1>
<p>In this chapter, you learned how to affect an object with physics simulations, create Object Types and Collision Presets, use the <code>OnHit</code>, <code>OnBeginOverlap</code>, and <code>OnEndOverlap</code> events, update an object’s Physical Material, and use timers.</p>
<p>Now that you’ve learned about these fundamental collision topics, you’ll be able to come up with new and creative ways to use them when creating projects.</p>
<p>In the next chapter, we’ll be taking a look at actor components, interfaces, and Blueprint Function Libraries, which are very useful for keeping your project’s complexity manageable and highly modular, thereby allowing you to easily take parts of one project and add them to another.</p>
</div>
</div></body></html>