<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer194">
<h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor134"/>6</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor135"/>Setting Up Collision Objects</h1>
<p>In the previous chapter, we covered some of the basic concepts of collision, namely Line Traces and Sweep Traces. We learned how to execute different types of Line Traces, how to create custom Trace Channels, and how to change how an object responds to a specific channel. Many of the things you learned in the previous chapter will be used in this chapter, where we’ll learn about object collision.</p>
<p>Throughout this chapter, we will continue to build upon our top-down Dodgeball game by adding game mechanics that revolve around object collision. We will create the Dodgeball actor, which will act as a dodgeball that bounces off of the floor and walls; the Wall actor, which will block all objects; the Ghost Wall actor, which will only block the player, not the enemies’ lines of sight or the dodgeball; and the Victory Box actor, which will end the game when the player enters the Victory Box, representing the end of the level.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Understanding object collision in UE5</li>
<li>Understanding collision components</li>
<li>Understanding collision events</li>
<li>Understanding collision channels</li>
<li>Creating physical materials</li>
<li>Introducing timers</li>
<li>Understanding how to spawn actors</li>
</ul>
<p>Before we start creating our <strong class="source-inline">Dodgeball</strong> class, we will go over the basic concepts of object collision.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor136"/>Technical requirements</h1>
<p>The project for this chapter can be found in the Chapter06 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor137"/>Understanding object collision in UE5</h1>
<p>Every game<a id="_idIndexMarker425"/> development tool must have a physics engine that simulates collision between multiple objects, as explained in the previous chapter. Collision is the backbone of most games released nowadays, whether 2D or 3D. In many games, it’s the main way in which the player acts upon the environment, be it running, jumping, or shooting, and the environment acts accordingly by making the player land, get hit, and so on. It is no understatement to say that, without simulated collision, it wouldn’t be possible to <a id="_idIndexMarker426"/>make many games at all.</p>
<p>So, let’s understand how object collision works in UE5 and how we can use it, starting with collision components.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor138"/>Understanding collision components</h1>
<p>In UE5, two types of components can <a id="_idIndexMarker427"/>affect and be affected by collision; they are as follows:</p>
<ul>
<li>Meshes</li>
<li>Shape objects</li>
</ul>
<p><strong class="bold">Meshes</strong> can be as simple as a <a id="_idIndexMarker428"/>cube, or as complex as a high-resolution character <a id="_idIndexMarker429"/>with tens of thousands of vertices. A mesh’s collision can be specified with a custom file imported alongside the mesh into UE5 (which is outside the scope of this book), or it can be calculated automatically by UE5 and customized by you. </p>
<p>It is generally a good practice to keep the collision mesh as simple (for example, a few triangles) as possible so that the physics engine can efficiently calculate collision at runtime. The types of meshes that can have collision are as follows:</p>
<ul>
<li><strong class="bold">Static Meshes</strong>: Meshes that are <a id="_idIndexMarker430"/>defined as static and do not <a id="_idIndexMarker431"/>change.</li>
<li><strong class="bold">Skeletal Meshes</strong>: Meshes that <a id="_idIndexMarker432"/>can have a skeleton and change their poses, which <a id="_idIndexMarker433"/>allows them to be animated. Character meshes, for instance, are skeletal meshes.</li>
<li><strong class="bold">Procedural Meshes</strong>: Meshes that can be generated automatically according to <a id="_idIndexMarker434"/>certain <a id="_idIndexMarker435"/>parameters.</li>
</ul>
<p><strong class="bold">Shape objects</strong>, which are simple <a id="_idIndexMarker436"/>meshes represented in wireframe <a id="_idIndexMarker437"/>mode, are used to behave as collision objects by causing and receiving collision events. </p>
<p class="callout-heading">Note</p>
<p class="callout">Wireframe mode is a commonly used <a id="_idIndexMarker438"/>visualization mode in game development, usually for debugging purposes, which allows you to see meshes without any faces or textures – they can only be seen through their edges, which are connected by their vertices. You will see what wireframe mode is when we add a <strong class="bold">Shape</strong> component to an actor.</p>
<p>Please note that <strong class="source-inline">Shape</strong> objects are essentially invisible meshes and that their three types are as follows:</p>
<ul>
<li>Box Collision (Box Component in C++)</li>
<li>Sphere <a id="_idIndexMarker439"/>Collision (Sphere Component in C++)</li>
<li>Capsule Collider (Capsule Component in C++)</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">There’s a class that all the components that provide geometry and collision inherit from, which is the <strong class="source-inline">Primitive</strong> component. This component is the basis for all components that contain any sort of geometry, which is the case for mesh components and shape components.</p>
<p>So, how can these components collide, and what happens when they do? We shall have a look at this in the next section.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor139"/>Understanding collision events</h1>
<p>Let’s say that two objects are colliding <a id="_idIndexMarker440"/>with one another. Two things can <a id="_idIndexMarker441"/>happen:</p>
<ul>
<li>They overlap each other, as if the other object weren’t there, in which case the <strong class="source-inline">Overlap</strong> event is called.</li>
<li>They collide and prevent each other from continuing their course, in which case the <strong class="source-inline">Block</strong> event is called.</li>
</ul>
<p>In the previous chapter, we learned how to change an object’s response to a specific <strong class="source-inline">Trace</strong> channel. During this process, we learned that an object’s response can be either <strong class="source-inline">Block</strong>, <strong class="source-inline">Overlap</strong>, or <strong class="source-inline">Ignore</strong>. </p>
<p>Now, let’s see what happens in each of these responses during a collision:</p>
<ul>
<li><strong class="bold">Block</strong>: Two objects will <a id="_idIndexMarker442"/>only block each other if both of them have their response to the other object set to <strong class="source-inline">Block</strong>:<ul><li>Both objects will have their <strong class="source-inline">OnHit</strong> events called. This event is called whenever two objects block each other’s path at the moment they collide. If one of the objects is simulating physics, that object must have its <strong class="source-inline">SimulationGeneratesHitEvents</strong> property set to <strong class="source-inline">true</strong>.</li><li>Both objects will physically stop each other from continuing with their course.</li></ul></li>
</ul>
<p>The following diagram shows an example of when two objects are thrown and bounce off each other:</p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<img alt="Figure 6.1 – Object A and object B blocking each other " height="164" src="image/Figure_6.01_B18531.jpg" width="569"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Object A and object B blocking each other</p>
<ul>
<li><strong class="bold">Overlap</strong>: Two objects will overlap each other if they don’t block each other and neither of them is ignoring the <a id="_idIndexMarker443"/>other:<ul><li>If both objects have the <strong class="source-inline">GenerateOverlapEvents</strong> property set to <strong class="source-inline">true</strong>, they will have their <strong class="source-inline">OnBeginOverlap</strong> and <strong class="source-inline">OnEndOverlap</strong> events called. These overlap events are called when an object starts and stops overlapping another object, respectively. If at least one of them doesn’t have this property set to <strong class="source-inline">true</strong>, neither of them will call these events.</li><li>The objects act as if the other object doesn’t exist and will overlap each other.</li></ul></li>
</ul>
<p>As an example, suppose the player’s character walks into a trigger box that marks the end of the level, which only reacts to the player’s character.</p>
<p>The following diagram shows an example of two objects overlapping each other:</p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<img alt="Figure 6.2 – Object A and object B overlapping each other " height="156" src="image/Figure_6.02_B18531.jpg" width="652"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Object A and object B overlapping each other</p>
<ul>
<li><strong class="bold">Ignore</strong>: Two objects will ignore <a id="_idIndexMarker444"/>each other if at least one of them is ignoring the other:<ul><li>No events will be called on either object.</li><li>Similar to the <strong class="source-inline">Overlap</strong> response, the objects will act as if the other object doesn’t exist and will overlap each other.</li></ul></li>
</ul>
<p>An example of two objects ignoring each other would be when an object other than the player’s character goes into a trigger box that marks the end of the level, which only reacts to the player’s <a id="_idIndexMarker445"/>character.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can look at the previous diagram, where two objects overlap each other, to understand <strong class="bold">Ignore</strong>.</p>
<p>The following table will help you understand the necessary responses that two objects must have to trigger the previously described situations:</p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<img alt="Figure 6.3 – Resulting responses on objects based on Block, Overlap, and Ignore " height="339" src="image/Figure_6.03_B18531.jpg" width="965"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Resulting responses on objects based on Block, Overlap, and Ignore</p>
<p>Following this table, consider that you have two objects – object A and object B:</p>
<ul>
<li>If object A has set its response to object B to <strong class="bold">Block</strong> and object B has set its response to object A to <strong class="bold">Block</strong>, they will <strong class="bold">Block</strong> each other.</li>
<li>If object A has set its response to object B to <strong class="bold">Block</strong> and object B has set its response to object A to <strong class="bold">Overlap</strong>, they will <strong class="bold">Overlap</strong> each other.</li>
<li>If object A has set its response to object B to <strong class="bold">Ignore</strong> and object B has set its response to object A to <strong class="bold">Overlap</strong>, they will <strong class="bold">Ignore</strong> each other.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">You can find a full reference to <a id="_idIndexMarker446"/>UE5’s collision interactions at <a href="https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview">https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview</a>.</p>
<p>A collision between objects has two aspects to it:</p>
<ul>
<li><strong class="bold">Physics</strong>: All collisions <a id="_idIndexMarker447"/>related to physics simulation, such as a ball being affected by gravity and bouncing off the floors and walls.</li>
</ul>
<p>The physically simulated response of the collision within the game can be either of the following: </p>
<ul>
<li>Both objects continue their trajectories as if the other object wasn’t there (no physical collision).</li>
<li>Both objects collide and change their trajectories, usually with at least one of them continuing its movement – that is, they are blocking each other’s paths.</li>
</ul>
<ul>
<li><strong class="bold">Query</strong>: A query can be divided into two <a id="_idIndexMarker448"/>aspects of collision, as follows:<ul><li>The events related to the collision of the objects that are called by the game and that you can use to create additional logic. These events are the same ones we mentioned previously:</li><li>The <strong class="source-inline">OnHit</strong> event</li><li>The <strong class="source-inline">OnBeginOverlap</strong> event</li><li>The <strong class="source-inline">OnEndOverlap</strong> event</li><li>The physical response to the collision within the game, which can be either of the following: <ul><li>Both objects continued their movement as if the other object wasn’t there (no physical collision)</li><li>Both objects collide and block each other’s path</li></ul></li></ul></li>
</ul>
<p>The physical response from the physics aspect may sound similar to the physical response from the query aspect; however, although <a id="_idIndexMarker449"/>they are both physical responses, they will cause objects to behave differently.</p>
<p>The physical response from the physics aspect (physics simulation) only applies when an object is simulating physics (for example, being affected by gravity, bouncing off the walls and ground, and so on). Such an object, when hitting a wall, for instance, will bounce back and continue moving in another direction.</p>
<p>On the other hand, the physical response from the query aspect applies to all objects that don’t simulate physics. An object can move without simulating physics when being controlled by code (for example, by using the <strong class="source-inline">SetActorLocation</strong> function or by using the <strong class="bold">Character Movement</strong> component). In this case, depending on which method you use to move the object and its properties, when an object hits a wall, it will simply stop moving instead of bouncing back. This is because you’re simply telling the object to move in a certain direction and something is blocking its path, so the physics engine doesn’t allow that object to continue moving.</p>
<p>Now that we’ve learned about collision events, let’s move on to the next section, where we will be looking at collision channels.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor140"/>Understanding collision channels</h1>
<p>In the previous chapter, a looked at the <a id="_idIndexMarker450"/>existing Trace Channels (<em class="italic">Visibility</em> and<em class="italic"> Camera</em>) and learned how to make a custom channel. Now that you know about Trace Channels, it’s time to talk about Object Channels, also known as Object <a id="_idIndexMarker451"/>Types.</p>
<p>While Trace Channels are only used for Line Traces, Object Channels are used for object collision. You can specify a “purpose” for each <strong class="source-inline">Object</strong> channel, much like with Trace Channels, such as <strong class="bold">Pawn</strong>, <strong class="bold">Static Object</strong>, <strong class="bold">Physics Object</strong>, <strong class="bold">Projectile</strong>, and so on. Then, you can specify how you want each Object Type to respond to all the other Object Types by blocking, overlapping, or ignoring objects of that type.</p>
<p>Now that we’ve taken a look at how collision works, let’s go back to the collision settings of the cube we selected in the previous chapter, where we changed its response to the Visibility Channel.</p>
<p>Follow these steps to learn more about collision channels:</p>
<ol>
<li>The cube can be seen in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer172">
<img alt="Figure 6.4 – Cube blocking the SightSource of the enemy " height="518" src="image/Figure_6.04_B18531.jpg" width="522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Cube blocking the SightSource of the enemy</p>
<ol>
<li value="2">With the level open in the <a id="_idIndexMarker452"/>editor, select the cube and go to the <strong class="bold">Collision</strong> section of its <strong class="bold">Details</strong> panel:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer173">
<img alt="Figure 6.5 – The changes in the level editor " height="300" src="image/Figure_6.05_B18531.jpg" width="365"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The changes in the level editor</p>
<p>Here, we can see some options that are important to us:</p>
<ul>
<li><strong class="bold">Simulation Generates Hit Events</strong>, which allows the <strong class="source-inline">OnHit</strong> events to be called when an<a id="_idIndexMarker453"/> object is simulating physics (we’ll talk about this later in this chapter).</li>
<li><strong class="bold">Generate Overlap Events</strong>, which allows the <strong class="source-inline">OnBeginOverlap</strong> and <strong class="source-inline">OnEndOverlap</strong> events to be called.</li>
<li><strong class="bold">Can Character Step Up On</strong>, which allows a character to easily step onto this object.</li>
<li><strong class="bold">Collision Presets</strong>, which allows us to specify how this object responds to each Collision Channel.</li>
</ul>
<ol>
<li value="3">Let’s change the <strong class="bold">Collision Presets</strong> value from <strong class="source-inline">Default</strong> to <strong class="source-inline">Custom</strong> and take a look at the new options that show up:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer174">
<img alt="Figure 6.6 – Changes in Collision Presets " height="427" src="image/Figure_6.06_B18531.jpg" width="366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Changes in Collision Presets</p>
<p>The first of these options is the <strong class="bold">Collision Enabled</strong> property. It allows you to specify which aspects of collision you want this object to be considered for: <strong class="bold">Query</strong>, <strong class="bold">Physics</strong>, <strong class="bold">Both</strong>, or <strong class="bold">None</strong>. Again, physics collision is related to physics simulation (whether this <a id="_idIndexMarker454"/>object will be considered by other objects that simulate physics), while query collision is related to collision events and whether objects will block each other’s movement:</p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<img alt="Figure 6.7 – Collision Enabled for Query and Physics " height="105" src="image/Figure_6.07_B18531.jpg" width="342"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Collision Enabled for Query and Physics</p>
<p>The second option is the <strong class="bold">Object Type</strong> property. This is very similar to the Trace Channel concept but<a id="_idIndexMarker455"/> is specifically for object collision and, most importantly, dictates what type of collision object this is. The Object Type values that come with UE5 are as follows:</p>
<ul>
<li><strong class="source-inline">WorldStatic</strong>: An object that doesn’t move (structures, buildings, and so on)</li>
<li><strong class="source-inline">WorldDynamic</strong>: An object that may move (objects whose movement is triggered by code, objects the player can pick up and move, and so on)</li>
<li><strong class="source-inline">Pawn</strong>: Used for Pawns that can be controlled and moved around the level</li>
<li><strong class="source-inline">PhysicsBody</strong>: Used for objects that simulate physics</li>
<li><strong class="source-inline">Vehicle</strong>: Used for Vehicle objects</li>
<li><strong class="source-inline">Destructible</strong>: Used for destructible meshes</li>
</ul>
<p>As mentioned previously, you can create custom object types (which will be mentioned later in this chapter) as well, similar to how you can create Trace Channels (<em class="italic">which was covered in the previous chapter</em>).</p>
<p>The last option we have is related to <strong class="bold">Collision Responses</strong>. Given that this <strong class="source-inline">Cube</strong> object has the default collision options, all the responses are set to <strong class="source-inline">Block</strong>, which means that this object will block all the Line Traces and all objects that block <strong class="source-inline">WorldStatic</strong> objects, given that that is this object’s type.</p>
<p>Because there are so many different combinations of collision properties, UE5 allows you to group collision property values in the form of Collision Presets.</p>
<p>Let’s go back to the <strong class="bold">Collision Presets</strong> property, which is currently set to <strong class="bold">Custom</strong>, and <em class="italic">click it</em> so that we can see all the<a id="_idIndexMarker456"/> possible options. Some of the existing <strong class="bold">Collision Presets</strong> are <a id="_idIndexMarker457"/>as follows:</p>
<ul>
<li><strong class="bold">No Collision</strong>: Used for objects that aren’t affected by collision whatsoever:<ul><li><strong class="bold">Collision Enabled</strong>: <strong class="source-inline">NoCollision</strong></li><li><strong class="bold">Object Type</strong>: <strong class="source-inline">WorldStatic</strong></li><li>Responses: Irrelevant</li><li>Example: Objects that are purely visual and distant, such as an object that the player will never reach</li></ul></li>
<li><strong class="bold">Block All</strong>: Used for objects that are static and block all other objects:<ul><li><strong class="bold">Collision Enabled</strong>: <strong class="source-inline">Query</strong> and <strong class="source-inline">Physics</strong></li><li><strong class="bold">Object Type</strong>: <strong class="source-inline">WorldStatic</strong></li><li>Responses: <strong class="source-inline">Block</strong> all channels</li><li>Example: Objects that are close to the player character and block their movement, such as the floor and walls, which will always be stationary</li></ul></li>
<li><strong class="bold">Overlap All</strong>: Used for objects that are static and overlap all other objects:<ul><li><strong class="bold">Collision Enabled</strong>: <strong class="source-inline">Query</strong> only</li><li><strong class="bold">Object Type</strong>: <strong class="source-inline">WorldStatic</strong></li><li>Responses: <strong class="source-inline">Overlap</strong> all channels</li><li>Example: Trigger boxes placed in the level, which will always be stationary</li></ul></li>
<li><strong class="bold">Block All Dynamic</strong>: Similar to the <strong class="source-inline">Block All</strong> preset, but for dynamic objects that may change their transform during gameplay (<strong class="source-inline">Object Type</strong>: <strong class="source-inline">WorldDynamic</strong>)</li>
<li><strong class="bold">Overlap All Dynamic</strong>: Similar to the <strong class="source-inline">Overlap All</strong> preset, but for dynamic objects that may change their transform during gameplay (<strong class="source-inline">Object Type</strong>: <strong class="source-inline">WorldDynamic</strong>)</li>
<li><strong class="bold">Pawn</strong>: Used for pawns and characters:<ul><li><strong class="bold">Collision Enabled</strong>: <strong class="source-inline">Query</strong> and <strong class="source-inline">Physics</strong></li><li><strong class="bold">Object Type</strong>: <strong class="source-inline">Pawn</strong></li><li>Responses: <strong class="source-inline">Block</strong> all channels, <strong class="source-inline">Ignore</strong> Visibility Channel</li><li>Example: Player character <a id="_idIndexMarker458"/>and non-playable characters</li></ul></li>
<li><strong class="bold">Physics Actor</strong>: Used for objects<a id="_idIndexMarker459"/> that simulate physics:<ul><li><strong class="bold">Collision Enabled</strong>: <strong class="source-inline">Query</strong> and <strong class="source-inline">Physics</strong></li><li><strong class="bold">Object Type</strong>: <strong class="source-inline">PhysicsBody</strong></li><li>Responses: <strong class="source-inline">Block</strong> all channels</li><li>Example: Objects that are affected by physics, such as a ball that bounces off the floor and walls</li></ul></li>
</ul>
<p>Just like the other collision properties, you can also create your own collision presets.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find a full reference to <a id="_idIndexMarker460"/>UE5’s collision responses here: <a href="https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference">https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference</a>.</p>
<p>Now that we know about the basic concepts of collision, let’s go ahead and start creating the <strong class="source-inline">Dodgeball</strong> class. The next exercise will guide you toward doing just that. </p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor141"/>Exercise 6.01 – creating the Dodgeball class</h2>
<p>In this exercise, we’ll be creating our <strong class="source-inline">Dodgeball</strong> class, which will be thrown by our enemies and bounce off the<a id="_idIndexMarker461"/> floor and walls, just like an actual dodgeball.</p>
<p>Before we start creating the <strong class="source-inline">Dodgeball</strong> C++ class and its logic, we should set up all the necessary collision settings for it. </p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Open <strong class="bold">Project Settings</strong> and go to the <strong class="bold">Collision</strong> subsection within the <strong class="bold">Engine</strong> section. Currently, there are no Object Channels, so you need to create a new one. </li>
<li>Press the <strong class="bold">New Object Channel</strong> button, name it <strong class="source-inline">Dodgeball</strong>, and set its <strong class="bold">Default Response</strong> to <strong class="bold">Block</strong>.</li>
<li>Once you’ve done this, expand the <strong class="bold">Preset</strong> section. Here, you’ll find all the default presets available in UE5. If you select one of them and press the <strong class="bold">Edit</strong> option, you can change that <strong class="bold">Preset Collision</strong> settings. </li>
<li>Create your own <strong class="bold">Preset</strong> by pressing the <strong class="bold">New</strong> button. We want our <strong class="bold">Dodgeball</strong> preset settings to be as follows:<ul><li><strong class="bold">Name</strong>: <strong class="source-inline">Dodgeball</strong></li><li><strong class="bold">Collision Enabled</strong>: <strong class="source-inline">Collision Enabled (Query and Physics)</strong> (we want this to be considered for physics simulation as well as collision events)</li><li><strong class="bold">Object Type</strong>: <strong class="source-inline">Dodgeball</strong></li><li><strong class="bold">Collision Responses</strong>: Select <em class="italic">Block</em> for most of the options, but <em class="italic">Ignore</em> the Camera and <strong class="source-inline">EnemySight</strong> (we don’t want the dodgeball to block the camera or the enemy’s line of sight)</li></ul></li>
<li>Once you’ve selected the correct options, press <strong class="bold">Accept</strong>.</li>
</ol>
<p>Now that the <strong class="source-inline">Dodgeball</strong> class’s collision settings have been set up, let’s create the <strong class="source-inline">Dodgeball</strong> C++ class.</p>
<ol>
<li value="6">Inside the <strong class="bold">Content Browser</strong> area, <em class="italic">right-click</em> and select <strong class="bold">New C++ Class</strong>.</li>
<li>Choose <strong class="bold">Actor</strong> as the parent class.</li>
<li>Choose <strong class="bold">DodgeballProjectile</strong> as the name of the class (our project is already named <strong class="source-inline">Dodgeball</strong>, so we can’t name this new class that too).</li>
<li>Open the <strong class="source-inline">DodgeballProjectile</strong> class files in Visual Studio. The first thing we’ll want to do is add the <a id="_idIndexMarker462"/>collision component of the dodgeball, so we’ll add a <strong class="source-inline">SphereComponent</strong> to our class header (<em class="italic">actor component properties are usually private</em>):<p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  Dodgeball, meta = (AllowPrivateAccess = "true"))</p><p class="source-code">class USphereComponent* SphereComponent;</p></li>
<li>Next, include the <strong class="source-inline">SphereComponent</strong> class at the top of our source file:<p class="source-code">#include "Components/SphereComponent.h"</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Keep in mind that all header file includes must be before the <strong class="source-inline">.generated.h</strong> include.</p>
<p>Now, head to the <strong class="source-inline">DodgeballProjectile</strong> class’s constructor, within its source file, and perform the following steps:</p>
<ol>
<li value="11">Create the <strong class="source-inline">SphereComponent</strong> object:<p class="source-code">SphereComponent = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("Sphere </p><p class="source-code">  Collision"));</p></li>
<li>Set its <strong class="source-inline">radius</strong> to <strong class="source-inline">35</strong> units:<p class="source-code">SphereComponent-&gt;SetSphereRadius(35.f);</p></li>
<li>Set its <strong class="bold">Collision Preset</strong> to the <strong class="source-inline">Dodgeball</strong> preset we created:<p class="source-code">SphereComponent-&gt;SetCollisionProfileName(FName("Dodgeball"));</p></li>
<li>We want <strong class="source-inline">Dodgeball</strong> to simulate physics, so notify the component of this, as shown in the following code snippet:<p class="source-code">SphereComponent-&gt;SetSimulatePhysics(true);</p></li>
<li>We want <strong class="source-inline">Dodgeball</strong> to call the <strong class="source-inline">OnHit</strong> event while simulating physics, so call the <strong class="source-inline">SetNotifyRigidBodyCollision</strong> function to set that to <strong class="source-inline">true</strong> (this is the same as the <strong class="source-inline">SimulationGeneratesHitEvents</strong> property that we saw in the <strong class="source-inline">Collision</strong> section of an object’s properties):<p class="source-code">//Simulation generates Hit events</p><p class="source-code">SphereComponent-&gt;SetNotifyRigidBodyCollision(true);</p></li>
</ol>
<p>We will also want to listen to the <strong class="source-inline">OnHit</strong> event of <strong class="source-inline">SphereComponent</strong>. </p>
<ol>
<li value="16">Create a declaration for the function that will be called when the <strong class="source-inline">OnHit</strong> event is triggered, in the <strong class="source-inline">DodgeballProjectile</strong> class’s header file. This function should be called <strong class="source-inline">OnHit</strong>. It should <a id="_idIndexMarker463"/>be <strong class="source-inline">public</strong>, return nothing (<strong class="source-inline">void</strong>), have the <strong class="source-inline">UFUNCTION</strong> macro, and receive some parameters, in this order:<ol><li><strong class="source-inline">UPrimitiveComponent* HitComp</strong>: The component that was hit and belongs to this actor. A primitive component is an actor component that has a <strong class="source-inline">Transform</strong> property and some sort of geometry (for example, a <strong class="source-inline">Mesh</strong> or <strong class="source-inline">Shape</strong> component).</li><li><strong class="source-inline">AActor* OtherActor</strong>: The other actor involved in the collision.</li><li><strong class="source-inline">UPrimitiveComponent* OtherComp</strong>: The component that was hit and belongs to the other actor.</li><li><strong class="source-inline">FVector NormalImpulse</strong>: The direction in which the object will be moving after it has been hit, and with how much force (by checking the size of the vector). This parameter will only be non-zero for objects that are simulating physics.</li><li><strong class="source-inline">FHitResult&amp; Hit</strong>: The data of the hit resulting from the collision between this object and the other object. As we saw in the previous chapter, it contains properties such whether as the location of the hit is normal, which component and actor it hit, and so on. Most of the relevant information is already <a id="_idIndexMarker464"/>available to us through the other parameters, but if you need more detailed information, you can access this parameter:</li></ol><p class="source-code">UFUNCTION()</p><p class="source-code">void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, </p><p class="source-code">  UPrimitiveComponent* OtherComp, FVector </p><p class="source-code">  NormalImpulse, const </p><p class="source-code">  FHitResult&amp; Hit);</p></li>
</ol>
<p>Add the <strong class="source-inline">OnHit</strong> function’s implementation to the class’s source file and within that function, at least for now, destroy the dodgeball when it hits the player. </p>
<ol>
<li value="17">Cast the <strong class="source-inline">OtherActor</strong> parameter to our <strong class="source-inline">DodgeballCharacter</strong> class and check if the value is not a <strong class="source-inline">nullptr</strong>. If it’s not, which means that the other actor we hit is a <strong class="source-inline">DodgeballCharacter</strong>, we’ll destroy this <strong class="source-inline">DodgeballProjectile</strong> actor:<p class="source-code">void ADodgeballProjectile::OnHit(UPrimitiveComponent * </p><p class="source-code">  HitComp, AActor * OtherActor, UPrimitiveComponent * </p><p class="source-code">  OtherComp, FVector NormalImpulse, const FHitResult &amp; </p><p class="source-code">  Hit)</p><p class="source-code">{</p><p class="source-code">  if (Cast&lt;ADodgeballCharacter&gt;(OtherActor) != </p><p class="source-code">  nullptr)</p><p class="source-code">  {</p><p class="source-code">    Destroy();</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>Given that we’re referencing the <strong class="source-inline">DodgebalCharacter</strong> class, we’ll need to include it at the top<a id="_idIndexMarker465"/> of this class’s source file:</p>
<p class="source-code">#include "DodgeballCharacter.h"</p>
<p class="callout-heading">Note</p>
<p class="callout">In the next chapter, we’ll change this function so that we have the dodgeball damage the player before destroying itself. We’ll do this when we talk about <strong class="source-inline">Actor</strong> components.</p>
<ol>
<li value="18">Head back to the <strong class="source-inline">DodgeballProjectile</strong> class’s constructor and add the following line at the end to listen to the <strong class="source-inline">OnHit</strong> event of <strong class="source-inline">SphereComponent</strong>:<p class="source-code">// Listen to the OnComponentHit event by binding it to </p><p class="source-code">// our function</p><p class="source-code">SphereComponent-&gt;OnComponentHit.AddDynamic(this, </p><p class="source-code">  &amp;ADodgeballProjectile::OnHit);</p></li>
</ol>
<p>This will bind the <strong class="source-inline">OnHit</strong> function we created to this <strong class="source-inline">SphereComponent</strong> <strong class="source-inline">OnHit</strong> event (because this is an actor component, this event is called <strong class="source-inline">OnComponentHit</strong>), which means our function will be called alongside that event.</p>
<ol>
<li value="19">Lastly, make <strong class="source-inline">SphereComponent</strong> this actor’s <strong class="source-inline">RootComponent</strong>, as shown in the following code snippet:<p class="source-code">// Set this Sphere Component as the root component,</p><p class="source-code">// otherwise collision won't behave properly</p><p class="source-code">RootComponent = SphereComponent;</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">For a moving actor to behave correctly on collision, whether it’s simulating physics or not, it is usually necessary for the main collision component of the actor to be its <strong class="source-inline">RootComponent</strong>.</p>
<p class="callout">For example, the <strong class="source-inline">RootComponent</strong> component of the <strong class="source-inline">Character</strong> class is a Capsule Collider component, because that actor will be moving around and that component is the main way the character collides with the environment.</p>
<p>Now that we’ve added the <strong class="source-inline">DodgeballProjectile</strong> C++ class’s logic, let’s go ahead and create our Blueprint class.</p>
<ol>
<li value="20">Compile your changes <a id="_idIndexMarker466"/>and open the editor.</li>
<li>Go to <strong class="bold">Content</strong> | <strong class="bold">ThirdPersonCPP</strong> | <strong class="bold">Blueprints</strong> in the <strong class="bold">Content Browser</strong> area, right-click, and create a new Blueprint class.</li>
<li>Expand the <strong class="bold">All Classes</strong> section and search for the <strong class="source-inline">DodgeballProjectile</strong> class. Then, set it as the parent class.</li>
<li>Name the new Blueprint class <strong class="source-inline">BP_DodgeballProjectile</strong>.</li>
<li>Open this new Blueprint class.</li>
<li>Notice the wireframe representation of the <strong class="bold">SphereCollision</strong> component in the actor’s <strong class="bold">Viewport</strong> window (this is hidden by default during the game, but you can change that property in this component’s <strong class="bold">Rendering</strong> section by changing its <strong class="source-inline">HiddenInGame</strong> property):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer176">
<img alt="Figure 6.8 – Visual wireframe representation of the SphereCollision component" height="216" src="image/Figure_6.08_B18531.jpg" width="266"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Visual wireframe representation of the SphereCollision component</p>
<ol>
<li value="26">Now, add a new <strong class="bold">Sphere</strong> mesh as a<a id="_idIndexMarker467"/> child of the existing <strong class="bold">Sphere Collision</strong> component:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer177">
<img alt="Figure 6.9 – Adding a Sphere mesh " height="187" src="image/Figure_6.09_B18531.jpg" width="245"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Adding a Sphere mesh</p>
<ol>
<li value="27">Change its scale to <strong class="source-inline">0.65</strong>, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer178">
<img alt="Figure 6.10 – Updating the scale " height="127" src="image/Figure_6.10_B18531.jpg" width="433"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Updating the scale</p>
<ol>
<li value="28">Set its <strong class="bold">Collision Presets</strong> to <strong class="source-inline">NoCollision</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer179">
<img alt="Figure 6.11 – Updating Collision Presets to NoCollision " height="135" src="image/Figure_6.11_B18531.jpg" width="463"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Updating Collision Presets to NoCollision</p>
<ol>
<li value="29">Finally, open our level and <a id="_idIndexMarker468"/>place an instance of the <strong class="source-inline">BP_DodgeballProjectile</strong> class near the player (this one was placed at a height of 600 units):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer180">
<img alt="Figure 6.12 – Dodgeball bouncing on the ground " height="553" src="image/Figure_6.12_B18531.jpg" width="707"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Dodgeball bouncing on the ground</p>
<p>After you’ve done this, play the level. You’ll notice that the dodgeball will be affected by gravity and bounce off the ground a couple of times before coming to a standstill.</p>
<p>By completing this exercise, you’ve<a id="_idIndexMarker469"/> created an object that behaves like a physics object. </p>
<p>You now know how to create collision object types, use the <strong class="source-inline">OnHit</strong> event, and change an object’s collision properties.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the previous chapter, we briefly mentioned <strong class="source-inline">LineTraceSingleByObjectType</strong>. Now that we know how object collision works, we can briefly mention its use: when executing a Line Trace that checks for a Trace Channel, you should use the <strong class="source-inline">LineTraceSingleByChannel</strong> function; when executing a Line Trace that checks for an Object Channel (Object Type), you should use the <strong class="source-inline">LineTraceSingleByObjectType</strong> function. It should be made clear that this function, unlike the <strong class="source-inline">LineTraceSingleByChannel</strong> function, will not check for objects that block a specific Object Type, but those that are of a specific Object Type. Both those functions have the same parameters and both the Trace Channels and Object Channels are available through the <strong class="source-inline">ECollisionChannel</strong> enum.</p>
<p>But what if you wanted the<a id="_idIndexMarker470"/> ball to bounce off the floor more times? What if you wanted to make it bouncier? Well, that’s where Physical Materials come in.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor142"/>Creating Physical Materials</h1>
<p>In UE5, you can customize how an <a id="_idIndexMarker471"/>object behaves while simulating physics using Physical Materials. To get into this new type of asset, let’s create our own:</p>
<ol>
<li value="1">Create a new folder inside the <strong class="source-inline">Content</strong> folder called <strong class="source-inline">Physics</strong>.</li>
<li><em class="italic">Right-click</em> on the <strong class="bold">Content Browser</strong> area while inside that folder and, under the <strong class="bold">Create Advanced Asset</strong> section, go to the <strong class="bold">Physics</strong> subsection and select <strong class="bold">Physical Material</strong>.</li>
<li>Name this new Physical Material <strong class="bold">PM_Dodgeball</strong>.</li>
<li>Open the asset and take a look at the available options:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer181">
<img alt="Figure 6.13 – Asset options " height="485" src="image/Figure_6.13_B18531.jpg" width="426"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Asset options</p>
<p>The main options we<a id="_idIndexMarker472"/> should note are as follows:</p>
<ul>
<li><strong class="bold">Friction</strong>: This property goes from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> and specifies how much friction will affect this object (<strong class="source-inline">0</strong> means this object will slide as if it was on ice, while <strong class="source-inline">1</strong> means this object will stick like a piece of gum).</li>
<li><strong class="bold">Restitution</strong> (also known as <strong class="bold">Bounciness</strong>): This property goes from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> and specifies how much velocity will be kept after colliding with another object (<strong class="source-inline">0</strong> means this object will never bounce off of the ground, while <strong class="source-inline">1</strong> means this object will bounce for a long time).</li>
<li><strong class="bold">Density</strong>: This property specifies how dense this object is (that is, how heavy it is relative to its mesh). Two objects can be of the same size, but if one is twice as dense as the other, that means it will be twice as heavy.</li>
</ul>
<p>To have our <strong class="source-inline">DodgeballProjectile</strong> object behave closer to an actual dodgeball, it’ll have to suffer quite a bit of friction (the default value is <strong class="source-inline">0.7</strong>, which is high enough) and be quite bouncy. Let’s increase<a id="_idIndexMarker473"/> the <strong class="source-inline">Restitution</strong> property of this Physical Material to <strong class="source-inline">0.95</strong>.</p>
<p>After you’ve done this, open the <strong class="bold">BP_DodgeballProjectile</strong> Blueprint class and change the <strong class="bold">Sphere Collision</strong> component’s Physical Material, inside its <strong class="bold">Collision</strong> section, to the one we just created, <strong class="bold">PM_Dodgeball</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer182">
<img alt="Figure 6.14 – Updating the BP_DodgeballProjectile Blueprint class " height="191" src="image/Figure_6.14_B18531.jpg" width="462"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Updating the BP_DodgeballProjectile Blueprint class</p>
<p class="callout-heading">Note</p>
<p class="callout">Make sure the instance of the <strong class="source-inline">Dodgeball</strong> actor you added to your level also has this physical material.</p>
<p>If you play the level that we created in <em class="italic">Exercise 6.01 – creating the Dodgeball class</em>, again, you’ll notice that our <strong class="source-inline">BP_DodgeballProjectile</strong> will now bounce off the ground several times before coming to a standstill, behaving much more like an actual dodgeball.</p>
<p>With all that done, we’re just missing one thing to make our <strong class="source-inline">Dodgeball</strong> actor behave like an actual dodgeball. Right now, there is no way for us to be able to throw it. So, let’s address that by creating a Projectile Movement Component, which is what we’ll be doing in the next exercise.</p>
<p>In the previous chapters, when we replicated the Third Person template project, we learned that the <strong class="source-inline">Character</strong> class that comes with UE5 has a <strong class="source-inline">CharacterMovementComponent</strong>. This actor component is what allows an actor to move around in the level in various ways, and has many properties that allow you to customize that to your preference. However, there is another movement component that is also frequently used: <strong class="source-inline">ProjectileMovementComponent</strong>. </p>
<p>The <strong class="source-inline">ProjectileMovementComponent</strong> actor component is used to attribute the behavior of a projectile to <a id="_idIndexMarker474"/>an actor. It allows you to set an initial speed, gravity force, and even some physics simulation parameters such as <strong class="source-inline">Bounciness</strong> and <strong class="source-inline">Friction</strong>. However, given that our <strong class="source-inline">Dodgeball Projectile</strong> is already simulating physics, the only property that we’ll be using is <strong class="source-inline">InitialSpeed</strong>.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor143"/>Exercise 6.02 – adding a ProjectileMovementComponent to DodgeballProjectile</h2>
<p>In this <a id="_idIndexMarker475"/>exercise, we will be adding a <strong class="source-inline">ProjectileMovementComponent</strong> to our <strong class="source-inline">DodgeballProjectile</strong> so that it has an initial horizontal speed. We’re doing this so that it can be thrown by our enemies and doesn’t just fall vertically.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Add a <strong class="source-inline">ProjectileMovementComponent</strong> property to the <strong class="source-inline">DodgeballProjectile</strong> class’s header file:<p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  Dodgeball, meta = (AllowPrivateAccess = "true"))</p><p class="source-code">class UProjectileMovementComponent* ProjectileMovement;</p></li>
<li>Include the <strong class="source-inline">ProjectileMovementComponent</strong> class at the top of the class’s source file:<p class="source-code">#include "GameFramework/ProjectileMovementComponent.h"</p></li>
<li>At the end of the class’s constructor, create the <strong class="source-inline">ProjectileMovementComponent</strong> object:<p class="source-code">ProjectileMovement = CreateDefaultSubobject&lt;UProjectileMovementComponent&gt;(TEXT("Pro</p><p class="source-code">  jectile Movement"));</p></li>
<li>Then, set its <strong class="source-inline">InitialSpeed</strong> to <strong class="source-inline">1500</strong> units:<p class="source-code">ProjectileMovement-&gt;InitialSpeed = 1500.f;</p></li>
</ol>
<p>Once<a id="_idIndexMarker476"/> you’ve done this, compile your project and open the editor. To demonstrate the dodgeball’s initial speed, lower its position on the <em class="italic">Z</em>-axis and place it behind the player (<em class="italic">this one was placed at a height of 200 units</em>):</p>
<div>
<div class="IMG---Figure" id="_idContainer183">
<img alt="Figure 6.15 – Dodgeball moving along the X-axis " height="601" src="image/Figure_6.15_B18531.jpg" width="583"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Dodgeball moving along the X-axis</p>
<p>When you play the level, you’ll notice that the dodgeball starts moving toward its <em class="italic">X</em>-axis (<em class="italic">red arrow</em>) </p>
<p>And with that, we <a id="_idIndexMarker477"/>can conclude our exercise. Our <strong class="source-inline">DodgeballProjectile</strong> now behaves like an actual dodgeball. It falls, bounces, and gets thrown.</p>
<p>The next step in our project is going to be adding logic to our <strong class="source-inline">EnemyCharacter</strong> so that it throws these dodgeballs at the player. However, before we address that, we must address the concept of timers.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor144"/>Introducing timers</h1>
<p>Given the nature of video games and the fact that they’re strongly event-based, every game development tool <a id="_idIndexMarker478"/>must have a way for you to cause a delay, or a wait time, before something happens. For instance, when you’re playing an online deathmatch game, where your character can die and then respawn, usually, the respawn event doesn’t happen the instant your character dies but a few seconds later. There is a multitude of scenarios where you want something to happen, but only after a certain amount of time. This will be the case for our <strong class="source-inline">EnemyCharacter</strong>, which will be throwing dodgeballs every few seconds. This delay, or wait time, can be achieved through timers.</p>
<p>A <strong class="bold">timer</strong> allows you to call a function after a certain amount of time. You can choose to loop that function call with an interval and also set a delay before the loop starts. If you want the timer to stop, you can also do that.</p>
<p>We will be using timers so that our enemy throws a dodgeball every <strong class="source-inline">X</strong> amount of time, indefinitely, so long as it can see the player character, and then stop that timer when the enemy can no longer see its target.</p>
<p>Before we start adding logic to our <strong class="source-inline">EnemyCharacter</strong> class that will make it throw dodgeballs at the player, we should take a look at another topic, which is how to spawn actors.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor145"/>Understanding how to spawn actors</h1>
<p>In <a href="B18531_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Unreal Engine</em>, you learned how to place an actor that you created in the level through<a id="_idIndexMarker479"/> the editor, but what if you wanted to place that actor in the level as the game is being played? That’s what we’re going to be taking a look at now.</p>
<p>UE5, much like most other game development tools, allows you to place an actor in the game while the game itself is running. This <a id="_idIndexMarker480"/>process is called <strong class="bold">spawning</strong>. To spawn an actor in UE5, we need to call the <strong class="source-inline">SpawnActor</strong> function, available from the <strong class="source-inline">World</strong> object (which we can access using the <strong class="source-inline">GetWorld</strong> function, as mentioned previously). However, the <strong class="source-inline">SpawnActor</strong> function has a few parameters that need to be passed, as follows:</p>
<ul>
<li>A <strong class="source-inline">UClass*</strong> property, which lets the function know the class of the object that will be spawned. This property can be a C++ class, available through the <strong class="source-inline">NameOfC++Class::StaticClass()</strong> function, or a Blueprint class, available through the <strong class="source-inline">TSubclassOf</strong> property. It is generally a good practice not to spawn actors from a<a id="_idIndexMarker481"/> C++ class directly, but to create a Blueprint class and spawn an instance of that instead.</li>
<li>The <strong class="source-inline">TSubclassOf</strong> property is a way for you to reference a Blueprint class in C++. It’s used for referencing a class in C++ code, which might be a Blueprint class. You must declare a <strong class="source-inline">TSubclassOf</strong> property with a template parameter, which is the C++ class that the class must inherit from. We will be taking a look at how to use this property in practice in the next exercise.</li>
<li>Either an <strong class="source-inline">FTransform</strong> property or the <strong class="source-inline">FVector</strong> and <strong class="source-inline">FRotator</strong> properties, which will indicate the location, rotation, and scale of the object we want to spawn.</li>
<li>An optional <strong class="source-inline">FActorSpawnParameters</strong> property, which allows you to specify more properties specific to the spawning process, such as who caused the actor to spawn (that is, <strong class="source-inline">Instigator</strong>), how to handle the object spawning if the location that it spawns at is being occupied by other objects, which may cause an overlap or a block event, and so on.</li>
</ul>
<p>The <strong class="source-inline">SpawnActor</strong> function will return an instance to the actor that was spawned from this function. Given that it is also a template function, you can call it in such a way that you receive a reference to the type of actor you spawned directly using a template parameter:</p>
<p class="source-code">GetWorld()-&gt;SpawnActor&lt;NameOfC++Class&gt;(ClassReference, </p>
<p class="source-code">  SpawnLocation, SpawnRotation);</p>
<p>In this case, the <strong class="source-inline">SpawnActor</strong> function is being called, where we’re spawning an instance of the <strong class="source-inline">NameOfC++Class</strong> class. Here, we have provided a reference to the class with the <strong class="source-inline">ClassReference</strong> property and the location and rotation of the actor to be spawned using the <strong class="source-inline">SpawnLocation</strong> and <strong class="source-inline">SpawnRotation</strong> properties, respectively.</p>
<p>You will learn how to apply these properties in <em class="italic">Exercise 6.03 – adding projectile-throwing logic to the EnemyCharacter class</em>.</p>
<p>Before we continue with the exercise, though, I’d like to briefly mention a variation of the <strong class="source-inline">SpawnActor</strong> function that may also come in handy: the <strong class="source-inline">SpawnActorDeferred</strong> function. While the <strong class="source-inline">SpawnActor</strong> function will create an instance of the object you specify and then place it in the <a id="_idIndexMarker482"/>world, this new <strong class="source-inline">SpawnActorDeferred</strong> function will create an instance of the object you want, and only place it in the world when you call the actor’s <strong class="source-inline">FinishSpawning</strong> function.</p>
<p>For instance, let’s say we want to change the <strong class="source-inline">InitialSpeed</strong> of our dodgeball at the moment we spawn it. If we use the <strong class="source-inline">SpawnActor</strong> function, there’s a chance that the dodgeball will start moving before we set its <strong class="source-inline">InitialSpeed</strong> property. However, by using the <strong class="source-inline">SpawnActorDeferred</strong> function, we can create an instance of the dodgeball, then set its <strong class="source-inline">InitialSpeed</strong> to whatever we want, and only then place it in the world by calling the newly created dodgeball’s <strong class="source-inline">FinishSpawning</strong> function, whose instance is returned to us by the <strong class="source-inline">SpawnActorDeferred</strong> function.</p>
<p>Now that we know how to spawn an actor in the world, and also about the concept of timers, we can add the logic that’s responsible for throwing dodgeballs to our <strong class="source-inline">EnemyCharacter</strong> class, which is what we’ll be doing in the next exercise. </p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor146"/>Exercise 6.03 – adding projectile-throwing logic to the EnemyCharacter class</h2>
<p>In this exercise, we<a id="_idIndexMarker483"/> will be adding the logic that’s responsible for throwing the <strong class="bold">Dodgeball</strong> actor that we just created to our <strong class="source-inline">EnemyCharacter</strong> class.</p>
<p>Open the class’s files in Visual Studio to get started. We will begin by modifying our <strong class="source-inline">LookAtActor</strong> function so that we can save the value that tells us whether we can see the player and use it to manage our timer.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">In the <strong class="source-inline">EnemyCharacter</strong> class’s header file, change the <strong class="source-inline">LookAtActor</strong> function’s return type from <strong class="source-inline">void</strong> to <strong class="source-inline">bool</strong>:<p class="source-code">// Change the rotation of the character to face the </p><p class="source-code">// given actor</p><p class="source-code">// Returns whether the given actor can be seen</p><p class="source-code">bool LookAtActor(AActor* TargetActor);</p></li>
<li>Do the same in<a id="_idIndexMarker484"/> the function’s implementation, inside the class’s source file, while also returning <strong class="source-inline">true</strong> at the end of the <strong class="source-inline">if</strong> statement where we call the <strong class="source-inline">CanSeeActor</strong> function. Also, return <strong class="source-inline">false</strong> in the first <strong class="source-inline">if</strong> statement, where we check if <strong class="source-inline">TargetActor</strong> is a <strong class="source-inline">nullptr</strong>, and also at the end of the function:<p class="source-code">bool AEnemyCharacter::LookAtActor(AActor * TargetActor)</p><p class="source-code">{</p><p class="source-code">  if (TargetActor == nullptr) return false;</p><p class="source-code">  if (CanSeeActor(TargetActor))</p><p class="source-code">  {</p><p class="source-code">    FVector Start = GetActorLocation();</p><p class="source-code">    FVector End = TargetActor-&gt;GetActorLocation();</p><p class="source-code">    // Calculate the necessary rotation for the Start </p><p class="source-code">    // point to face the End point</p><p class="source-code">    FRotator LookAtRotation = </p><p class="source-code">    UKismetMathLibrary::FindLookAtRotation(</p><p class="source-code">    Start, End);</p><p class="source-code">    //Set the enemy's rotation to that rotation</p><p class="source-code">    SetActorRotation(LookAtRotation);</p><p class="source-code">    return true;</p><p class="source-code">  }</p><p class="source-code">  return false;</p><p class="source-code">}</p></li>
<li>Next, add two <strong class="source-inline">bool</strong> properties, <strong class="source-inline">bCanSeePlayer</strong> and <strong class="source-inline">bPreviousCanSeePlayer</strong>, set to <strong class="source-inline">protected</strong> in your class’s header file, which will represent<a id="_idIndexMarker485"/> whether the player can be seen in this frame from the enemy character’s perspective and whether the player could be seen in the last frame, respectively:<p class="source-code">//Whether the enemy can see the player this frame</p><p class="source-code">bool bCanSeePlayer = false;</p><p class="source-code">//Whether the enemy could see the player last frame</p><p class="source-code">bool bPreviousCanSeePlayer = false;</p></li>
<li>Then, go to your class’s <strong class="source-inline">Tick</strong> function implementation and set the value of <strong class="source-inline">bCanSeePlayer</strong> to the return value of the <strong class="source-inline">LookAtActor</strong> function. This will replace the previous call to the <strong class="source-inline">LookAtActor</strong> function:<p class="source-code">// Look at the player character every frame</p><p class="source-code">bCanSeePlayer = LookAtActor(PlayerCharacter);</p></li>
<li>After that, set the value of <strong class="source-inline">bPreviousCanSeePlayer</strong> to the value of <strong class="source-inline">bCanSeePlayer</strong>:<p class="source-code">bPreviousCanSeePlayer = bCanSeePlayer;</p></li>
<li>In-between the previous two lines, add an <strong class="source-inline">if</strong> statement that checks whether the values of <strong class="source-inline">bCanSeePlayer</strong> and <strong class="source-inline">bPreviousCanSeePlayer</strong> are different. This will mean that either we couldn’t see the player in the last frame and now we can, or that we could see the player in the last frame and now we can’t:<p class="source-code">bCanSeePlayer = LookAtActor(PlayerCharacter);</p><p class="source-code">if (bCanSeePlayer != bPreviousCanSeePlayer)</p><p class="source-code">{</p><p class="source-code">}</p><p class="source-code">bPreviousCanSeePlayer = bCanSeePlayer;</p></li>
<li>Inside this <strong class="source-inline">if</strong> statement, we<a id="_idIndexMarker486"/> want to start a timer if we can see the player and stop that timer if we can no longer see the player:<p class="source-code">if (bCanSeePlayer != bPreviousCanSeePlayer)</p><p class="source-code">{</p><p class="source-code">  if (bCanSeePlayer)</p><p class="source-code">  {</p><p class="source-code">    //Start throwing dodgeballs</p><p class="source-code">  }</p><p class="source-code">  else</p><p class="source-code">  {</p><p class="source-code">    //Stop throwing dodgeballs</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>To start a timer, we’ll need to add the following properties to our class’s header file, which can all be <strong class="source-inline">protected</strong>:<ul><li>An <strong class="source-inline">FTimerHandle</strong> property, which is responsible for identifying which timer we want to start. It works as the identifier of a specific timer:<p class="source-code">FTimerHandle ThrowTimerHandle;</p></li><li>A <strong class="source-inline">float</strong> property, which represents the amount of time to wait between throwing dodgeballs (the interval) so that we can loop the timer. We give this a default value of <strong class="source-inline">2</strong> seconds:<p class="source-code">float ThrowingInterval = 2.f;</p></li><li>Another <strong class="source-inline">float</strong> property, which represents the initial delay before the timer starts looping. Let’s give it a default value of <strong class="source-inline">0.5</strong> seconds:<p class="source-code">float ThrowingDelay = 0.5f;</p></li><li>A function to be called every time the timer ends, which we will create and call <strong class="source-inline">ThrowDodgeball</strong>. This function doesn’t return anything and doesn’t receive any parameters:<p class="source-code">void ThrowDodgeball();</p></li></ul></li>
</ol>
<p>Before we can call the <a id="_idIndexMarker487"/>appropriate function to start the timer, we will need to add an <strong class="source-inline">#include</strong> to the object responsible for that, <strong class="source-inline">FTimerManager</strong>, in our source file. </p>
<p>Each <strong class="source-inline">World</strong> has one Timer Manager, which can start and stop timers and access relevant functions related to them, such as whether they’re still active, how long they will be running for, and so on:</p>
<p class="source-code">#include "TimerManager.h"</p>
<ol>
<li value="9">Now, access the current <strong class="source-inline">World</strong> Timer Manager by using the <strong class="source-inline">GetWorldTimerManager</strong> function:<p class="source-code">GetWorldTimerManager()</p></li>
<li>Next, call the <strong class="source-inline">SetTimer</strong> function of the Timer Manager, if you can see the player character, to start the timer responsible for throwing dodgeballs. The <strong class="source-inline">SetTimer</strong> function receives the following parameters:<ul><li>An <strong class="source-inline">FTimerHandle</strong> that represents the desired timer: <strong class="source-inline">ThrowTimerHandle</strong>.</li><li>The object that the function to be called belongs to: <strong class="source-inline">this</strong>.</li><li>The function to be called, which must be specified by prefixing its name with <strong class="source-inline">&amp;ClassName::</strong>, resulting in <strong class="source-inline">&amp;AEnemyCharacter::ThrowDodgeball</strong>.</li><li>The timer’s rate, or interval: <strong class="source-inline">ThrowingInterval</strong>.</li><li>Whether this<a id="_idIndexMarker488"/> timer will loop: <strong class="source-inline">true</strong>.</li><li>The delay before this timer starts looping: <strong class="source-inline">ThrowingDelay</strong>.</li></ul></li>
</ol>
<p>The following code snippet comprises these parameters:</p>
<p class="source-code">if (bCanSeePlayer)</p>
<p class="source-code">{</p>
<p class="source-code">  //Start throwing dodgeballs</p>
<p class="source-code">  GetWorldTimerManager().SetTimer(ThrowTimerHandle,</p>
<p class="source-code">  this,</p>
<p class="source-code">  &amp;AEnemyCharacter::ThrowDodgeball,ThrowingInterval,</p>
<p class="source-code">  true,</p>
<p class="source-code">  ThrowingDelay);</p>
<p class="source-code">}</p>
<ol>
<li value="11">If we can no longer see the player and we want to stop the timer, we can do so using the <strong class="source-inline">ClearTimer</strong> function. This function only needs to receive an <strong class="source-inline">FTimerHandle</strong> property as a parameter:<p class="source-code">else</p><p class="source-code">{</p><p class="source-code">  //Stop throwing dodgeballs</p><p class="source-code">  GetWorldTimerManager().ClearTimer(ThrowTimerHandle);</p><p class="source-code">}</p></li>
</ol>
<p>The only thing left is to implement the <strong class="source-inline">ThrowDodgeball</strong> function. This function will be<a id="_idIndexMarker489"/> responsible for spawning a new <strong class="source-inline">DodgeballProjectile</strong> actor. To do this, we’ll need a reference to the class we want to spawn, which must inherit from <strong class="source-inline">DodgeballProjectile</strong>. So, the next thing we need to do is create the appropriate property using the <strong class="source-inline">TSubclassOf</strong> object.</p>
<ol>
<li value="12">Create the <strong class="source-inline">TSubclassOf</strong> property in the <strong class="source-inline">EnemyCharacter</strong> header file, which can be <strong class="source-inline">public</strong>:<p class="source-code">//The class used to spawn a dodgeball object</p><p class="source-code">UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = </p><p class="source-code">  Dodgeball)</p><p class="source-code">TSubclassOf&lt;class ADodgeballProjectile&gt; DodgeballClass;</p></li>
<li>Because we’ll be using the <strong class="source-inline">DodgeballProjectile</strong> class, we also need to include it in the <strong class="source-inline">EnemyCharacter</strong> source file:<p class="source-code">#include "DodgeballProjectile.h"</p></li>
<li>Then, within the <strong class="source-inline">ThrowDodgeball</strong> function’s implementation in the source file, start by checking if this property is a <strong class="source-inline">nullptr</strong>. If it is, we <strong class="source-inline">return</strong> immediately:<p class="source-code">void AEnemyCharacter::ThrowDodgeball()</p><p class="source-code">{</p><p class="source-code">  if (DodgeballClass == nullptr)</p><p class="source-code">  {</p><p class="source-code">    return;</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Next, we will be spawning a new actor from that class. Its location will be <strong class="source-inline">40</strong> units in front of the enemy and its rotation will be the same as the enemy. To spawn the dodgeball in front of<a id="_idIndexMarker490"/> the enemy character, we’ll need to access the enemy’s <strong class="source-inline">ForwardVector</strong> property, which is a unitary <strong class="source-inline">FVector</strong> (<em class="italic">meaning that its length is 1</em>) that indicates the direction an actor is facing, and multiply it by the distance at which we want to spawn our dodgeball, which is <strong class="source-inline">40</strong> units:<p class="source-code">FVector ForwardVector = GetActorForwardVector();</p><p class="source-code">float SpawnDistance = 40.f;</p><p class="source-code">FVector SpawnLocation = GetActorLocation() + (ForwardVector * </p><p class="source-code">  SpawnDistance);</p><p class="source-code">//Spawn new dodgeball</p><p class="source-code">GetWorld()-&gt;SpawnActor&lt;ADodgeballProjectile&gt;(DodgeballClass, </p><p class="source-code">  SpawnLocation, GetActorRotation());</p></li>
</ol>
<p>This concludes the modifications we need to make to the <strong class="source-inline">EnemyCharacter</strong> class. Before we finish setting up the Blueprint of this logic, let’s make a quick modification to our <strong class="source-inline">DodgeballProjectile</strong> class.</p>
<ol>
<li value="16">Open the <strong class="source-inline">DodgeballProjectile</strong> class’s source file in Visual Studio. </li>
<li>Within its <strong class="bold">BeginPlay</strong> event, set its <strong class="source-inline">LifeSpan</strong> to <strong class="source-inline">5</strong> seconds. This property, which belongs to all actors, dictates how much longer they will remain in the game before being destroyed. By setting our dodgeball’s <strong class="source-inline">LifeSpan</strong> to <strong class="source-inline">5</strong> seconds on its <strong class="source-inline">BeginPlay</strong> event, we are telling UE5 to destroy that object 5 seconds after it’s spawned (<em class="italic">or if it’s already been placed in the level, 5 seconds after the game starts</em>). We will do this so that the floor isn’t filled with dodgeballs after a certain amount of time, which would make the game unintentionally difficult for the player:<p class="source-code">void ADodgeballProjectile::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">  </p><p class="source-code">  SetLifeSpan(5.f);</p><p class="source-code">}</p></li>
</ol>
<p>Now that we’ve finished <a id="_idIndexMarker491"/>our C++ logic related to the <strong class="source-inline">EnemyCharacter</strong> class’s dodgeball-throwing logic, let’s compile our changes, open the editor, and then open our <strong class="source-inline">BP_EnemyCharacter</strong> Blueprint. There, head to the <strong class="bold">Class Defaults</strong> panel and change the <strong class="source-inline">Dodgeball</strong> <strong class="source-inline">Class</strong> property’s value to <strong class="source-inline">BP_DodgeballProjectile</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer184">
<img alt="Figure 6.16 – Updating Dodgeball Class " height="50" src="image/Figure_6.16_B18531.jpg" width="434"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Updating Dodgeball Class</p>
<p>After you’ve done this, you can remove the existing instance of the <strong class="source-inline">BP_DodgeballProjectile</strong> class we placed in our level if it’s still there.</p>
<p>Now, we can play our level. You’ll notice that the enemy will almost immediately start throwing dodgeballs at the player and will continue to do so, so long as the player character is in view:</p>
<div>
<div class="IMG---Figure" id="_idContainer185">
<img alt="Figure 6.17 – Enemy character throwing dodgeballs if the player is in sight " height="467" src="image/Figure_6.17_B18531.jpg" width="493"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Enemy character throwing dodgeballs if the player is in sight</p>
<p>With that, we have<a id="_idIndexMarker492"/> concluded our dodgeball-throwing logic for <strong class="source-inline">EnemyCharacter</strong>. You now know how to use timers, an essential tool for any game programmer.</p>
<p>Now, let’s jump into the next section, where we’ll be creating walls that handle collision differently.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor147"/>Creating the Wall classes</h1>
<p>The next step in<a id="_idIndexMarker493"/> our project is going to be creating the <strong class="source-inline">Wall</strong> classes. We will have two types of walls:</p>
<ul>
<li>A normal wall, which will block the enemy’s line of sight, the player character, and the dodgeball.</li>
<li>A ghost wall, which will only block the player character, and ignore the enemy’s line of sight and the dodgeball. You may find this type of collision setup in specific types of puzzle games.</li>
</ul>
<p>We’ll create both these Wall classes in the next exercise.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor148"/>Exercise 6.04 – creating Wall classes</h2>
<p>In this exercise, we will be<a id="_idIndexMarker494"/> creating the <strong class="source-inline">Wall</strong> classes that represent both a normal <strong class="source-inline">Wall</strong> and a <strong class="source-inline">GhostWall</strong>, which will only block the player character’s movement, but not the enemies’ lines of sight or the dodgeballs they throw.</p>
<p>Let’s start with the normal <strong class="source-inline">Wall</strong> class. This C++ class will be empty because the only thing that it’ll need is a mesh to reflect the projectiles and block the enemies’ lines of sight, which will be added through its Blueprint class.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Open the editor.</li>
<li>In the top-left corner of the <strong class="bold">Content Browser</strong> area, press the green <strong class="bold">Add New</strong> button.</li>
<li>Select the first option at the top; that is, <strong class="bold">Add Feature or Content Pack</strong>.</li>
<li>A new window will appear. Select the <strong class="bold">Content Packs</strong> tab, select the <strong class="bold">Starter Content</strong> pack, and then press the <strong class="bold">Add To Project</strong> button. This will add some basic assets to the project, which we’ll use in this chapter and some of the following chapters.</li>
<li>Create a new C++ class, called <strong class="source-inline">Wall</strong>, with the <strong class="source-inline">Actor</strong> class as its parent.</li>
<li>Next, open the class’s files in Visual Studio and add a <strong class="source-inline">SceneComponent</strong> as our Wall’s <strong class="source-inline">RootComponent</strong>:<ul><li>The <strong class="source-inline">Header</strong> file will be as follows:<p class="source-code">private:</p><p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Wall, </p><p class="source-code">  meta = (AllowPrivateAccess = "true"))</p><p class="source-code">class USceneComponent* RootScene;</p></li><li>The <strong class="source-inline">Source</strong> file will be as follows:<p class="source-code">AWall::AWall()</p><p class="source-code">{</p><p class="source-code">  // Set this actor to call Tick() every frame.  You </p><p class="source-code">  // can turn this off to improve performance if you </p><p class="source-code">  // don't need it.</p><p class="source-code">  PrimaryActorTick.bCanEverTick = true;</p><p class="source-code">  RootScene = CreateDefaultSubobject&lt;USceneComponent&gt;(</p><p class="source-code">  TEXT("Root"));</p><p class="source-code">  RootComponent = RootScene;</p><p class="source-code">}</p></li></ul></li>
<li>Compile your code<a id="_idIndexMarker495"/> and open the editor.</li>
</ol>
<p>Next, go to <strong class="bold">Content</strong> | <strong class="bold">ThirdPersonCPP</strong> | <strong class="bold">Blueprints</strong> inside the <strong class="bold">Content Browser</strong> area, create a new Blueprint class that inherits from the <strong class="source-inline">Wall</strong> class, name it <strong class="source-inline">BP_Wall</strong>, and open that asse:.</p>
<ol>
<li value="1">Add a <strong class="bold">Static Mesh </strong>component and set its <strong class="bold">StaticMesh</strong> property to <strong class="source-inline">Wall_400x400</strong>.</li>
<li>Set its <strong class="bold">Material</strong> property to <strong class="source-inline">M_Metal_Steel</strong>.</li>
<li>Set the <strong class="bold">Static Mesh</strong> component’s location on the <em class="italic">X</em>-axis to <strong class="source-inline">–200</strong> units (<em class="italic">so that the mesh is centered relative to our actor’s origin</em>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer186">
<img alt="Figure 6.18 – Updating the Static Mesh component’s location " height="124" src="image/Figure_6.18_B18531.jpg" width="436"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Updating the Static Mesh component’s location</p>
<p>This is what your <a id="_idIndexMarker496"/>Blueprint class’s Viewport should look like:</p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<img alt="Figure 6.19 – The Blueprint class’s Viewport Wall " height="501" src="image/Figure_6.19_B18531.jpg" width="668"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – The Blueprint class’s Viewport Wall</p>
<p class="callout-heading">Note</p>
<p class="callout">It is generally good practice to add a <strong class="source-inline">SceneComponent</strong> as an object’s <strong class="source-inline">RootComponent</strong>, when a collision component isn’t necessary, to allow for more flexibility with its child components.</p>
<p class="callout">An actor’s <strong class="source-inline">RootComponent</strong> cannot have its location or rotation modified, which is why, in our case, if we had created a <strong class="bold">Static Mesh</strong> component in the <strong class="source-inline">Wall</strong> C++ class and set that as its root component, instead of using a scene component, we’d have a hard time offsetting it.</p>
<p>Now that we’ve set <a id="_idIndexMarker497"/>up the regular <strong class="source-inline">Wall</strong> class, let’s create our <strong class="source-inline">GhostWall</strong> class. Because these classes don’t have any logic set up, we’re just going to create the <strong class="source-inline">GhostWall</strong> class as a child of the <strong class="source-inline">BP_Wall</strong> Blueprint class and not our C++ class:</p>
<ol>
<li value="1"><em class="italic">Right-click</em> the <strong class="bold">BP_Wall</strong> asset and select <strong class="bold">Create Child Blueprint Class</strong>.</li>
<li>Name the new Blueprint <strong class="source-inline">BP_GhostWall</strong>.</li>
<li>Open it.</li>
<li>Change the <strong class="bold">Static Mesh</strong> component’s collision properties:<ul><li>Set its <strong class="source-inline">CollisionPreset</strong> to <strong class="source-inline">Custom</strong>.</li><li>Change its response to both the <strong class="source-inline">EnemySight</strong> and <strong class="source-inline">Dodgeball</strong> channels to <strong class="source-inline">Overlap</strong>.</li></ul></li>
<li>Change the <strong class="bold">Static Mesh</strong> component’s <strong class="source-inline">Material</strong> property to <strong class="source-inline">M_Metal_Copper</strong>.</li>
</ol>
<p>The <strong class="source-inline">BP_GhostWall</strong> Viewport should now look like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<img alt="Figure 6.20 – Creating the GhostWall class " height="385" src="image/Figure_6.20_B18531.jpg" width="480"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Creating the GhostWall class</p>
<p>Now that you’ve created both these <strong class="source-inline">Wall</strong> actors, place each in the level to test them. Set their<a id="_idIndexMarker498"/> transforms to the following transform values:</p>
<ul>
<li><strong class="bold">Wall</strong>: <strong class="source-inline">Location</strong>: <strong class="source-inline">(710, -1710, 0)</strong></li>
<li><strong class="bold">Ghost Wall</strong>: <strong class="source-inline">Location</strong>: <strong class="source-inline">(720, 1720, 0)</strong>; <strong class="source-inline">Rotation</strong>: <strong class="source-inline">(0, 0, 90)</strong>:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer189">
<img alt="Figure 6.21 – Updating the GhostWall class’s locations and rotation  " height="748" src="image/Figure_6.21_B18531.jpg" width="1137"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Updating the GhostWall class’s locations and rotation </p>
<p>The outcome should look like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<img alt="Figure 6.22 – Outcome of the GhostWall and Wall classes " height="428" src="image/Figure_6.22_B18531.jpg" width="490"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Outcome of the GhostWall and Wall classes</p>
<p>You’ll notice that when <a id="_idIndexMarker499"/>you hide your character behind the normal <strong class="source-inline">Wall</strong> (the one on the right), the enemy won’t throw dodgeballs at the player; however, when you try to hide your character behind <strong class="source-inline">GhostWall</strong> (the one on the left), even though the enemy can’t go through it, the enemy will throw dodgeballs at the character and they will pass through the wall as if it wasn’t there!</p>
<p>And that concludes our exercise. We have made our <strong class="source-inline">Wall</strong> actors, which will either behave normally or ignore the enemies’ lines of sight and dodgeballs!</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor149"/>Creating the VictoryBox actor</h1>
<p>The next step in our project is <a id="_idIndexMarker500"/>going to be creating the <strong class="source-inline">VictoryBox</strong> actor. This actor will be responsible for ending the game when the player character enters it, given that the player has beaten the level. To do this, we’ll be using the <strong class="source-inline">Overlap</strong> event. The following exercise will help us understand <strong class="source-inline">VictoryBox</strong>.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor150"/>Exercise 6.05 – creating the VictoryBox class</h2>
<p>In this exercise, we will be<a id="_idIndexMarker501"/> creating the <strong class="source-inline">VictoryBox</strong> class, which, when entered by the player character, will end the game.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Create a new C++ class that inherits from the actor and call it <strong class="source-inline">VictoryBox</strong>.</li>
<li>Open that class’s files in Visual Studio.</li>
<li>Create a new <strong class="source-inline">SceneComponent</strong> property, which will be used as a <strong class="source-inline">RootComponent</strong>, just like we did with our <strong class="source-inline">Wall</strong> C++ class:<ul><li><strong class="source-inline">Header</strong> file:<p class="source-code">private:</p><p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  VictoryBox, meta = (AllowPrivateAccess = "true"))</p><p class="source-code">class USceneComponent* RootScene;</p></li><li><strong class="source-inline">Source</strong> file:<p class="source-code">AVictoryBox::AVictoryBox()</p><p class="source-code">{</p><p class="source-code">  // Set this actor to call Tick() every frame.  You </p><p class="source-code">  // can turn this off to improve performance if you </p><p class="source-code">  // don't need it.</p><p class="source-code">  PrimaryActorTick.bCanEverTick = true;</p><p class="source-code">  RootScene = </p><p class="source-code">  CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("Root"));</p><p class="source-code">  RootComponent = RootScene;</p><p class="source-code">}</p></li></ul></li>
<li>Declare a <strong class="source-inline">BoxComponent</strong> in the header file that will check for overlap events with the player character, which <a id="_idIndexMarker502"/>should also be <strong class="source-inline">private</strong>:<p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  VictoryBox, meta = (AllowPrivateAccess = "true"))</p><p class="source-code">class UBoxComponent* CollisionBox;</p></li>
<li>Include the <strong class="source-inline">BoxComponent</strong> file in the class’s source file:<p class="source-code">#include "Components/BoxComponent.h"</p></li>
<li>After creating the <strong class="source-inline">RootScene</strong> component, create <strong class="source-inline">BoxComponent</strong>, which should also be <strong class="source-inline">private</strong>:<p class="source-code">RootScene = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("Root"));</p><p class="source-code">RootComponent = RootScene;</p><p class="source-code">CollisionBox = </p><p class="source-code">  CreateDefaultSubobject&lt;UBoxComponent&gt;(</p><p class="source-code">  TEXT("Collision Box"));</p></li>
<li>Attach it to <strong class="source-inline">RootComponent</strong> using the <strong class="source-inline">SetupAttachment</strong> function:<p class="source-code">CollisionBox-&gt;SetupAttachment(RootComponent);</p></li>
<li>Set its <strong class="source-inline">BoxExtent</strong> property to <strong class="source-inline">60</strong> units on all axes. This will cause <strong class="source-inline">BoxComponent</strong> to be double that size – that is, <strong class="source-inline">(120 x 120 x 120)</strong>:<p class="source-code">CollisionBox-&gt;SetBoxExtent(FVector(60.0f, 60.0f, 60.0f));</p></li>
<li>Offset its relative position on the <em class="italic">Z</em>-axis by <strong class="source-inline">120</strong> units using the <strong class="source-inline">SetRelativeLocation</strong> function:<p class="source-code">CollisionBox-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, </p><p class="source-code">  120.0f));</p></li>
<li>Now, you will require a function that will listen to the BoxComponent’s <strong class="source-inline">OnBeginOverlap</strong> event. This event will be called whenever an object enters <strong class="source-inline">BoxComponent</strong>. This <a id="_idIndexMarker503"/>function must be preceded by the <strong class="source-inline">UFUNCTION</strong> macro, be <strong class="source-inline">public</strong>, return nothing, and have the following parameters:<p class="source-code">UFUNCTION()</p><p class="source-code">void OnBeginOverlap(UPrimitiveComponent* OverlappedComp, </p><p class="source-code">  AActor* OtherActor, UPrimitiveComponent* OtherComp, </p><p class="source-code">  int32 </p><p class="source-code">  OtherBodyIndex, bool bFromSweep, const FHitResult&amp; </p><p class="source-code">  SweepResult);</p></li>
</ol>
<p>These parameters are as follows:</p>
<ul>
<li><strong class="source-inline">UPrimitiveComponent* OverlappedComp</strong>: The component that was overlapped and belongs to this actor.</li>
<li><strong class="source-inline">AActor* OtherActor</strong>: The other actor involved in the overlap.</li>
<li><strong class="source-inline">UPrimitiveComponent* OtherComp</strong>: The component that was overlapped and belongs to the other actor.</li>
<li><strong class="source-inline">int32 OtherBodyIndex</strong>: The index of the item in the primitive that was hit (usually useful for Instanced Static Mesh components).</li>
<li><strong class="source-inline">bool bFromSweep</strong>: Whether the overlap originated from a Sweep Trace.</li>
<li><strong class="source-inline">FHitResult&amp; SweepResult</strong>: The data of the Sweep Trace resulting from the collision between this object and the other object.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Although we won’t be using the <strong class="source-inline">OnEndOverlap</strong> event in this project, you will most likely need to use it sooner or later, so here’s the required function signature for that event, which looks very similar to the one we just learned about:</p>
<p class="callout"><strong class="source-inline">UFUNCTION()</strong></p>
<p class="callout"><strong class="source-inline">void OnEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);</strong></p>
<ol>
<li value="11">Next, we need to<a id="_idIndexMarker504"/> bind this function to the BoxComponent’s <strong class="source-inline">OnComponentBeginOverlap</strong> event:<p class="source-code">CollisionBox-&gt;OnComponentBeginOverlap.AddDynamic(this, </p><p class="source-code">  &amp;AVictoryBox::OnBeginOverlap);</p></li>
<li>Within our <strong class="source-inline">OnBeginOverlap</strong> function implementation, we’re going to check whether the actor we overlapped is a <strong class="source-inline">DodgeballCharacter</strong>. Because we’ll be referencing this class, we also need to include it:<p class="source-code">#include "DodgeballCharacter.h" </p><p class="source-code">void AVictoryBox::OnBeginOverlap(UPrimitiveComponent * </p><p class="source-code">  OverlappedComp, AActor * OtherActor, </p><p class="source-code">  UPrimitiveComponent * </p><p class="source-code">  OtherComp, int32 OtherBodyIndex, bool bFromSweep, </p><p class="source-code">  const </p><p class="source-code">  FHitResult &amp; SweepResult)</p><p class="source-code">{</p><p class="source-code">  if (Cast&lt;ADodgeballCharacter&gt;(OtherActor))</p><p class="source-code">  {</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>If the actor we overlapped is a <strong class="source-inline">DodgeballCharacter</strong>, we want to quit the game.</p>
<ol>
<li value="13">We will use <strong class="source-inline">KismetSystemLibrary</strong> for this purpose. The <strong class="source-inline">KismetSystemLibrary</strong> class contains <a id="_idIndexMarker505"/>useful functions for general use in your project:<p class="source-code">#include "Kismet/KismetSystemLibrary.h"</p></li>
<li>To quit the game, we will call the <strong class="source-inline">QuitGame</strong> function of <strong class="source-inline">KismetSystemLibrary</strong>. This function receives the following:<p class="source-code">UKismetSystemLibrary::QuitGame(GetWorld(),</p><p class="source-code">  nullptr,</p><p class="source-code">  EQuitPreference::Quit,</p><p class="source-code">  true);</p></li>
</ol>
<p>The important parameters from the preceding code snippet are as follows:</p>
<ul>
<li>A <strong class="source-inline">World</strong> object, which we can access with the <strong class="source-inline">GetWorld</strong> function.</li>
<li>A <strong class="source-inline">PlayerController</strong> object, which we will set to <strong class="source-inline">nullptr</strong>. We’re doing this because this function will automatically find one this way.</li>
<li>An <strong class="source-inline">EQuitPreference</strong> object, which means how we want to end the game, by either quitting or just putting it as a background process. We will want to quit the game, and not just put it as a background process.</li>
<li>A <strong class="source-inline">bool</strong>, which indicates whether we want to ignore the platform’s restrictions when it comes to quitting the game, which we will set to <strong class="source-inline">true</strong>.</li>
</ul>
<p>Next, we’re going to create our Blueprint class.</p>
<ol>
<li value="15">Compile your changes, open the editor, go to <strong class="bold">Content</strong> | <strong class="bold">ThirdPersonCPP</strong> | <strong class="bold">Blueprint</strong> inside the <strong class="bold">Content Browser</strong> area, create a new Blueprint class that inherits from <strong class="source-inline">VictoryBox</strong>, and name it <strong class="source-inline">BP_VictoryBox</strong>. Open that asset and make the following modifications:<ul><li>Add a new <strong class="bold">Static Mesh</strong> component</li><li>Set its <strong class="bold">StaticMesh</strong> property to <strong class="source-inline">Floor_400x400</strong></li><li>Set its <strong class="bold">Material</strong> property to <strong class="source-inline">M_Metal_Gold</strong></li><li>Set its scale to <strong class="source-inline">0.75</strong> units on all three axes</li><li>Set its location to <strong class="source-inline">(-150, -150, 20)</strong>, on the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> axes, respectively.</li></ul></li>
</ol>
<p>Once you’ve made<a id="_idIndexMarker506"/> those changes, your Blueprint’s <strong class="bold">Viewport</strong> tab should look something like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<img alt="Figure 6.23 – VictoryBox placed in the Blueprint’s Viewport tab " height="522" src="image/Figure_6.23_B18531.jpg" width="724"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – VictoryBox placed in the Blueprint’s Viewport tab</p>
<p>Place that Blueprint inside your level to test its functionality:</p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<img alt="Figure 6.24 – VictoryBox Blueprint in the level for testing " height="467" src="image/Figure_6.24_B18531.jpg" width="606"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – VictoryBox Blueprint in the level for testing</p>
<p>If you play the level and step <a id="_idIndexMarker507"/>onto the golden plate (and overlap the collision box), you’ll notice that the game abruptly ends, as intended.</p>
<p>And with that, we conclude our <strong class="source-inline">VictoryBox</strong> class! You now know how to use the overlap events in your projects. There’s a multitude of game mechanics that you can create using these events, so congratulations on completing this exercise.</p>
<p>We are now very close to reaching the end of this chapter, where we’ll be completing a new activity, but first, we’ll need to make some modifications to our <strong class="source-inline">DodgeballProjectile</strong> class, namely adding a getter function to its <strong class="source-inline">ProjectileMovementComponent</strong>. We’ll do this in the next exercise.</p>
<p>A getter function is a function that only returns a specific property and does nothing else. These functions are usually marked as inline, which means that when the code compiles, a call to that function will simply be replaced with its content. They are also usually marked as <strong class="source-inline">const</strong>, given that they don’t modify any of the class’s properties.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor151"/>Exercise 6.06 – adding the ProjectileMovementComponent getter function to DodgeballProjectile</h2>
<p>In this exercise, we will be adding a <a id="_idIndexMarker508"/>getter function to the <strong class="source-inline">DodgeballProjectile</strong> class’s <strong class="source-inline">ProjectileMovement</strong> property so that other classes can access it and modify its properties. We will be doing the same in this chapter’s activity. </p>
<p>To do this, you’ll need to follow these steps:</p>
<ol>
<li value="1">Open the <strong class="source-inline">DodgeballProjectile</strong> class’s header file in Visual Studio.</li>
<li>Add a new <strong class="source-inline">public</strong> function called <strong class="source-inline">GetProjectileMovementComponent</strong>. This function will be an inline function, which in UE5’s version of C++ is replaced with the <strong class="source-inline">FORCEINLINE</strong> macro. The function should also return a <strong class="source-inline">UProjectileMovementComponent*</strong> and be a <strong class="source-inline">const</strong> function:<p class="source-code">FORCEINLINE class UProjectileMovementComponent* </p><p class="source-code">  GetProjectileMovementComponent() const</p><p class="source-code">{</p><p class="source-code">  return ProjectileMovement;</p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">When using the <strong class="source-inline">FORCEINLINE</strong> macro for a specific function, you can’t add the declaration of that function to the header file and its implementation to the source file. Both must be done simultaneously in the header file, as shown previously.</p>
<p>With that, we have concluded this quick exercise. Here, we have added a simple <strong class="source-inline">getter</strong> function to our <strong class="source-inline">DodgeballProjectile</strong> class, which we will be using in this chapter’s activity, where we’ll replace the <strong class="source-inline">SpawnActor</strong> function within the <strong class="source-inline">EnemyCharacter</strong> class with the <strong class="source-inline">SpawnActorDeferred</strong> function. This will allow us to safely edit our <strong class="source-inline">DodgeballProjectile</strong> class’s properties before we spawn an instance of it.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor152"/>Activity 6.01 – replacing the SpawnActor function with SpawnActorDeferred in EnemyCharacter</h2>
<p>In this activity, you will be <a id="_idIndexMarker509"/>changing the EnemyCharacter’s <strong class="source-inline">ThrowDodgeball</strong> function to use the <strong class="source-inline">SpawnActorDeferred</strong> function instead of the <strong class="source-inline">SpawnActor</strong> function so<a id="_idIndexMarker510"/> that we can change the <a id="_idIndexMarker511"/>DodgeballProjectile’s <strong class="source-inline">InitialSpeed</strong> before spawning it. </p>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Open the <strong class="source-inline">EnemyCharacter</strong> class’s source file in Visual Studio.</li>
<li>Go to the <strong class="source-inline">ThrowDodgeball</strong> function’s implementation.</li>
<li>Because the <strong class="source-inline">SpawnActorDeferred</strong> function can’t just receive a spawn location and rotation properties and must receive an <strong class="source-inline">FTransform</strong> property instead, we’ll need to create one of those before we call that function. Let’s call it <strong class="source-inline">SpawnTransform</strong> and send the spawn rotation and location, in that order, as inputs for its constructor, which will be this enemy’s rotation and the <strong class="source-inline">SpawnLocation</strong> property, respectively.</li>
<li>Then, update the <strong class="source-inline">SpawnActor</strong> function call in the <strong class="source-inline">SpawnActorDeferred</strong> function call. Instead of sending the spawn location and spawn rotation as its second and third parameters, replace those with the <strong class="source-inline">SpawnTransform</strong> properties we just created, as the second parameter.</li>
<li>Make sure you save the return value of this function call inside an <strong class="source-inline">ADodgeballProjectile*</strong> property called <strong class="source-inline">Projectile</strong>.</li>
</ol>
<p>Once you’ve done this, you will have successfully created a new <strong class="source-inline">DodgeballProjectile</strong> object. However, we still need to change its <strong class="source-inline">InitialSpeed</strong> property and spawn it.</p>
<ol>
<li value="6">Once you’ve called the <strong class="source-inline">SpawnActorDeferred</strong> function, call the <strong class="source-inline">Projectile</strong> property’s <strong class="source-inline">GetProjectileMovementComponent</strong> function, which returns its <strong class="source-inline">ProjectileMovementComponent</strong>, and change its <strong class="source-inline">InitialSpeed</strong> property to <strong class="source-inline">2200</strong> units.</li>
<li>Because we’ll be accessing properties that belong to <strong class="source-inline">ProjectileMovementComponent</strong> inside the <strong class="source-inline">EnemyCharacter</strong> class, we’ll need to include that <a id="_idIndexMarker512"/>component, just like we did in <em class="italic">Exercise 6.02 – adding a ProjectileMovementComponent to DodgeballProjectile</em>.</li>
<li>Once you’ve changed the <a id="_idIndexMarker513"/>value of the <strong class="source-inline">InitialSpeed</strong> property, the only thing left to do is call the <strong class="source-inline">Projectile</strong> property’s <strong class="source-inline">FinishSpawning</strong> function, which will receive the <strong class="source-inline">SpawnTransform</strong> property we created as a parameter.</li>
<li>Once you’ve done<a id="_idIndexMarker514"/> this, compile your changes and open the editor.</li>
</ol>
<p><strong class="bold">Expected output</strong>:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<img alt="Figure 6.25 – Dodgeball thrown at the player " height="554" src="image/Figure_6.25_B18531.jpg" width="542"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25 – Dodgeball thrown at the player</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this<a id="_idIndexMarker515"/> activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>By completing this activity, you’ve<a id="_idIndexMarker516"/> consolidated the <a id="_idIndexMarker517"/>use of the <strong class="source-inline">SpawnActorDeferred</strong> function and know how to use it in your future projects.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor153"/>Summary</h1>
<p>In this chapter, you learned how to affect an object with physics simulations, create Object Types and Collision Presets, use the <strong class="source-inline">OnHit</strong>, <strong class="source-inline">OnBeginOverlap</strong>, and <strong class="source-inline">OnEndOverlap</strong> events, update an object’s Physical Material, and use timers.</p>
<p>Now that you’ve learned about these fundamental collision topics, you’ll be able to come up with new and creative ways to use them when creating projects.</p>
<p>In the next chapter, we’ll be taking a look at actor components, interfaces, and Blueprint Function Libraries, which are very useful for keeping your project’s complexity manageable and highly modular, thereby allowing you to easily take parts of one project and add them to another.</p>
</div>
</div></body></html>