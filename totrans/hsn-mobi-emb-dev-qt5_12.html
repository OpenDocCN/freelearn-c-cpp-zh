<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Sounds and Visions - Qt Multimedia</h1>
                </header>
            
            <article>
                
<p class="mce-root">Applications that need to play sounds or show videos are usually games, while others are full-blown multimedia apps. Qt Multimedia can handle both.</p>
<p>Qt Multimedia can be used with both Qt Widgets and Qt Quick, or even without a GUI interface. It has both C++ and QML APIs, but the QML API has a few special treats and tricks. A little-known fact is that Qt can also play 3D positional audio in Qt Quick. You can control the gain and pitch with three dimensions.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Sonic vibrations – audio</li>
<li>Image sensors – camera</li>
<li>Visual media – playing video</li>
<li>Tuning it in – FM radio tuner</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sonic vibrations – audio</h1>
                </header>
            
            <article>
                
<p>I have a relationship with audio that goes way back—before computers were household things, when Mylar tape and magnets ruled the sonic realms. Things have progressed since then. Now, mobile phones fit into our pockets and light bulbs can play music.</p>
<p>3D audio in Qt is supported through the OpenAL API. If you are using Linux, the default Qt binaries from Qt Company do not ship with the needed Qt Audio Engine API. You will have to install the OpenAL development package and then compile Qt Multimedia for yourself. OpenAL is not supported on Android, so no joy there. Luckily, it is supported by default on Apple Mac and iOS. So, that is where I am going to develop this next section. Let's grab the nearest MacBook and head over there.</p>
<p>3D audio is audio in three dimensions, just like 3D graphics—not just left and right, but also up, down, front, and back placement of audio. The term <em>positional audio</em> might explain this better. </p>
<p>With Qt, 3D audio is only supported using Qt Quick. </p>
<div class="packt_infobox"><span>The source code for this chapter can be found in the Git repository under the </span><kbd>Chapter09-3dAudio</kbd><span> directory, in the</span><span> </span><kbd>cp9</kbd><span> </span><span>branch.</span></div>
<p>To use Qt Multimedia, you need to edit the project <kbd>.pro</kbd> file and add the following line:</p>
<pre><span>QT += multimedia</span></pre>
<p>Edit the <kbd>qml</kbd> file that you want to use the 3D audio in, and add the <kbd>import</kbd> line:</p>
<pre><span>import QtAudioEngine 1.0</span></pre>
<p>3D space is made up of three axes named x, y, and z, which correspond to horizontal/vertical and up/down in 3-dimensional space.</p>
<p><kbd>AudioEngine</kbd> and other associated classes use the <kbd>Qt.vector3d</kbd> value type. It is essential to understand this element to use 3D audio.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt.vector3d</h1>
                </header>
            
            <article>
                
<p><kbd>Qt.vector3d</kbd> <span>is an array of values that represents the x, y, and z axes—</span>x being horizontal, y being vertical, and z being up or down. Each value is a single-precision <kbd>qreal</kbd>.</p>
<p><span>It can be used like </span><kbd><span>Qt.vector3d(15,</span><span> </span><span>-5,</span><span> </span><span>0)</span></kbd><span> or <kbd>"15, -5, 0"</kbd> as a</span> <kbd>String</kbd><span>. </span></p>
<p><span>The positioning of the audio is controlled through the use of the <kbd>vector3d</kbd> property value.</span></p>
<p><span><kbd>Qt.vector3d</kbd> is used to position the audio in 3 dimensional space.</span></p>
<p>The main component for using 3D audio in QML is called <kbd>AudioEngine</kbd>. The other components we will use can be children of this component.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AudioEngine</h1>
                </header>
            
            <article>
                
<p><kbd>AudioEngine</kbd> is the central container for the other 3D audio items that you will use.</p>
<p>We can set up the component easily enough:</p>
<pre><span>    </span><span>AudioEngine</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>audioEngine<br/></span><span>        </span><span>dopplerFactor</span>:<span> </span>1<br/><span>        </span><span>speedOfSound</span>:<span> </span>343.33<br/>}</pre>
<p>The <kbd>dopplerFactor</kbd> property creates a Doppler shift effect. The <kbd>speedOfSound</kbd> value reflects the speed of sound in which the Doppler effect is calculated.</p>
<p>You assign a <kbd>listener</kbd> through the <kbd>listener</kbd> property. We will get to that later in the <em>AudioListener</em> section.</p>
<p>We have an audio sample we want to load and use, so we declare at least one <kbd>AudioSample</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AudioSample</h1>
                </header>
            
            <article>
                
<p><kbd>AudioSample</kbd> can be defined as a child of an <kbd>AudioEngine</kbd> component:</p>
<pre><span> </span><span>AudioEngine</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>audioEngine<br/></span><span>        </span><span>dopplerFactor</span>:<span> </span>1<br/><span>        </span><span>speedOfSound</span>:<span> </span>343.33<br/>        <span>AudioSample</span><span> </span><span>{<br/></span><span>            </span><span>name</span>:<span>"plink"<br/></span><span>            </span><span>source</span>:<span> </span><span>"thunder.wav"<br/></span><span>            </span><span>preloaded</span>:<span> </span>true<br/><span>        </span>}<br/>}</pre>
<p><span>It can also be added using the </span><kbd>AudioEngine.addAudioSample()</kbd><span> method:</span></p>
<pre><span> </span><span>AudioEngine</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>audioEngine<br/></span><span>        </span><span>dopplerFactor</span>:<span> </span>1<br/><span>        </span><span>speedOfSound</span>:<span> </span>343.33<br/>        addAudioSample(<span>plinkSound)<br/></span>}<br/><span>AudioSample</span><span> </span><span>{<br/>    id: plinkSound<br/></span><span>    </span><span>name</span>:<span>"plink"<br/></span><span>    </span><span>source</span>:<span> </span><span>"thunder.wav"<br/></span><span>    </span><span>preloaded</span>:<span> </span>true<br/>}</pre>
<p><span>The </span><kbd>source</kbd><span> property holds the sample's filename and a name to refer to it with.</span></p>
<p>Now, we are ready to play the sound using the <kbd>Sound</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sound</h1>
                </header>
            
            <article>
                
<p>The <kbd>Sound</kbd> element is a container for one or more samples that will play with different parameters and variances. In other words, you can define a <kbd>PlayVariation</kbd> item, which defines how a <kbd>Sound</kbd> plays an <kbd>AudioSample</kbd>, with maximum or minimum values in pitch and gain. You can also declare the sample to be <kbd>looping</kbd>, which means it plays over and over:</p>
<pre><span>Sound</span><span> </span>{<br/><span>    </span><span>name</span>:<span> </span><span>"thunderengine"<br/></span><span>    </span><span>attenuationModel</span>:<span> </span><span>"thunderModel"<br/></span>    <span>PlayVariation</span><span> </span><span>{<br/></span><span>        </span><span>looping</span>:<span> </span>true<br/><span>        </span><span>sample</span>:<span> </span><span>"plink"<br/></span><span>        </span><span>maxGain</span>:<span> </span>0.5<br/><span>        </span><span>minGain</span>:<span> </span>0.3<br/><span>     </span>}<br/>}</pre>
<p>The <kbd>attenuationModel</kbd> <span>property controls the way the sound volume level falls off, or fades over time. It can be one of these values:</span></p>
<ul>
<li><span>Linear is a straight falloff</span></li>
<li>Inverse <span>is a more natural, non-linear curve </span></li>
</ul>
<p><span>You can control this using the</span> <kbd>start</kbd>, <kbd>end</kbd>, and <kbd>rolloff</kbd> <span>properties.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AudioListener</h1>
                </header>
            
            <article>
                
<p>The <kbd>AudioListener</kbd> component represents the <kbd>listener</kbd> and its position in the 3D realm. There is only one <kbd>listener</kbd>. It can either be constructed as the <kbd>listener</kbd> property of the <kbd>AudioEngine</kbd> component, or as a definable element:</p>
<pre><span>    </span><span>AudioListener</span><span> </span>{<br/><span>        </span><span>engine</span>:<span> </span><span>audioEngine<br/></span><span>        </span><span>position</span>:<span> </span><span>Qt</span>.vector3d(0,<span> </span>0,<span> </span>0)<br/><span>    </span>}</pre>
<p>A <kbd>SoundInstance</kbd> is the component that a <kbd>Sound</kbd> uses to play the sample.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SoundInstance</h1>
                </header>
            
            <article>
                
<p><kbd>SoundInstance</kbd> has a few properties that you can use to adjust the sound:</p>
<ul>
<li><kbd>direction</kbd></li>
<li><kbd>gain</kbd></li>
<li><kbd>pitch</kbd></li>
<li><kbd>position</kbd></li>
</ul>
<p>These properties take a <kbd>vector3d</kbd> value.</p>
<p>The <kbd>sound</kbd> property of the <kbd>SoundInstance</kbd> element takes a string that represents the name of a <kbd>Sound</kbd> component:</p>
<pre><span>    </span><span>SoundInstance</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>plinkSound<br/></span><span>        </span><span>engine</span>:<span> </span><span>audioEngine<br/></span><span>        </span><span>sound</span>:<span> </span><span>"thunderengine"<br/></span><span>        </span><span>position</span>:<span> </span><span>Qt</span>.vector3d(<span>leftRightValue</span>,<span> </span><span>forwardBacktValue</span>,<br/><span>upDownValue</span>)<span><br/></span>        <span>Component.onCompleted</span><span>:</span><span> </span><span>plinkSound</span><span>.play()<br/></span><span>    </span>}<br/><br/></pre>
<p>Here, I start playing the sound when the component is completed.</p>
<p>Now, we just need some mechanism to move the sound position around. We can use the <kbd>Accelerometer</kbd> values if we have an accelerometer on the device. I'm just going to use the mouse. Remember that on a touchscreen, a <kbd>MouseArea</kbd> also includes touch input.</p>
<p>We must enable <kbd>hover</kbd> in order to track the mouse without clicking:</p>
<pre><span>    </span><span>MouseArea</span><span> </span>{<br/><span>        </span><span>anchors.fill</span>:<span> </span><span>parent<br/></span><span>        </span><span>hoverEnabled</span>:<span> </span>true<br/><span>        </span><span>propagateComposedEvents</span>:<span> </span>true<br/><span>        </span><span>onPositionChanged</span>:<span> </span>{<br/><span>            </span><span>leftRightValue</span><span> </span>=<span> </span>-((<span>window</span>.width<span> </span>/<span> </span>2)<span> </span>-<span> </span><span>mouse</span>.x)<br/><span>            </span><span>forwardBacktValue</span><span> </span>=<span> </span>(<span>window</span>.height<span> </span>/<span> </span>2)<span> </span>-<span> </span><span>mouse</span>.y<br/><span>        </span>}</pre>
<div class="packt_tip">To propagate the mouse clicks to buttons or other items when using <kbd>MouseArea</kbd>, put the <kbd>MouseArea</kbd> at the top of the file, as Qt Quick will set the z order in the order of the components from the top of the file, down to the bottom. You could also set the <kbd>z</kbd> property of the buttons and set the <kbd>z</kbd> property of the <kbd>MouseArea</kbd> to the lowest value.</div>
<p>I previously declared three values in my <kbd>Window</kbd> component to use in the positioning of the audio:</p>
<pre><span>property</span><span> </span><span>real</span><span> </span><span>leftRightValue</span>:<span> </span>0;<br/><span>property</span><span> </span><span>real</span><span> </span><span>forwardBacktValue</span>:<span> </span>0;<br/><span>property</span><span> </span><span>real</span><span> </span><span>upDownValue</span>:<span> </span>0;</pre>
<p>Now, when you move the mouse around, the audio will appear to move around.</p>
<p>But there is no mouse on a phone. There is a touch point, but no scrolling. I could use an <kbd>Accelerometer</kbd> as it has the z axis, or use <kbd>PinchArea</kbd> to control the up and down position.</p>
<p>Let's look at a few other ways to deal with audio.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Audio</h1>
                </header>
            
            <article>
                
<p>The <kbd>Audio</kbd> element is probably the easiest way to play audio. It only takes a few lines. It would be good for playing sound effects.</p>
<div class="packt_infobox"><span>The source code can be found in this book's Git repository under the </span><kbd>Chapter09-1</kbd><span> directory, in the</span><span> </span><kbd>cp9</kbd><span> </span><span>branch.</span></div>
<p>We will use the following <kbd>import</kbd> statement:</p>
<pre><span>import QtMultimedia 5.12</span></pre>
<p>Here's a simple stanza that will play the <kbd>.mp3</kbd> file named <kbd>sample.mp3</kbd>:</p>
<pre class="qml prettyprint prettyprinted"><span class="type"><span class="typ">Audio</span></span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="name"><span class="pln">id</span></span><span class="pun">:</span><span class="pln"> </span><span class="name"><span class="pln">audioPlayer</span></span><span class="pln">
    </span><span class="name"><span class="pln">source</span></span><span class="pun">:</span><span class="pln"> </span><span class="string"><span class="str">"sample.mp3"</span></span><span class="pln">
</span><span class="pun">}</span></pre>
<p>The <kbd>source</kbd> property is where you declare which file to play. Now, you just have to call the <kbd>play()</kbd> method to have this <kbd>sample.wav</kbd> file play:</p>
<pre><span>Component.onCompleted</span>: audioPlayer.play()</pre>
<p>You can also set the <kbd>autoPlay</kbd> property to <kbd>true</kbd> instead of calling <kbd>play</kbd>, and that would play the file once the component is completed.</p>
<p>Setting the volume is as easy as declaring the <kbd>volume</kbd> property and setting a decimal value between 0 and 1—1 being full volume and 0 being muted:</p>
<pre>volume: .75</pre>
<div class="packt_tip">Getting the metadata or ID tags from the file is not obvious, as they only become available after the <kbd>metaDataChanged</kbd> signal gets emitted. This is only emitted by the <kbd>Audio</kbd> element's <kbd>metaData</kbd> object.</div>
<p><span>Sometimes, you might need to display a file's metadata, or the extra data that can be within the audio file's headers. The </span><kbd>Audio</kbd> <span>component has a <kbd>metaData</kbd> property that can be used like this:</span></p>
<pre><span>metaData</span><span> </span>{<br/><span>    </span><span>onMetaDataChanged</span>:<span> </span>{<br/><span>        </span><span>titleLabel</span>.text<span> </span>=<span> </span><span>"Title:</span><span> </span><span>"</span><span> </span>+<span> </span>metaData.title<br/><span>        </span><span>artistLabel</span>.text<span> </span>=<span> </span><span>"Artist:</span><span> </span><span>"</span><span> </span>+ metaData.contributingArtist<br/><span>        </span><span>albumLabel</span>.text<span> </span>=<span> </span><span>"Album:</span><span> </span><span>"</span><span> </span>+<span> </span>metaData.albumTitle<span><br/></span><span>    </span>}<br/>}</pre>
<p>If you need to access the microphone and record audio, you will need to dive into C++, so let's take a look at <kbd>QAudioRecorder</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QAudioRecorder</h1>
                </header>
            
            <article>
                
<p>Recording audio is one of my passions. Recording audio, or more specifically using the microphone, may require user permissions<span> on some platforms</span>.</p>
<p>The recording of audio, called taping back in my day, can be implemented by using the <kbd>QAudioRecorder</kbd> class. Recording properties are controlled by the <kbd>QAudioEncoderSettings</kbd> class, from which you can control the codec that's used, the channel count, the bit rate, and the sample rate. You can either explicitly set the bit rate and sample rate, or use the more generic <kbd>setQuality</kbd> function.</p>
<div class="packt_infobox"><span>The source code can be found in this book's Git repository under the </span><kbd><span>Chapter09</span>-2</kbd><span> directory, in the <kbd>cp9</kbd> branch.</span></div>
<p><span>You might want to query the input devices and see which settings are available. To do that, you would query using </span><kbd>QAudioDeviceInfo</kbd>, iterating through <span><kbd><span>QAudioDeviceInfo::availableDevices(QAudio::AudioInput)</span></kbd></span>:</p>
<pre><span><br/>void MainWindow::listAudioDevices() <br/>{ <br/>    for (const QAudioDeviceInfo &amp;deviceInfo : <br/>         QAudioDeviceInfo::availableDevices(QAudio::AudioInput)) { <br/>        ui-&gt;textEdit-&gt;insertPlainText( <br/>                    QString("Device name: %1\n") <br/>                    .arg(deviceInfo.deviceName())); <br/> <br/>        ui-&gt;textEdit-&gt;insertPlainText( <br/>                    "    Supported Codecs: " <br/>                    + deviceInfo.supportedCodecs() <br/>                    .join(", ") + "\n"); <br/>        ui-&gt;textEdit-&gt;insertPlainText( <br/>                    QString("    Supported channel count: %1\n") <br/>                    .arg(stringifyIntList(deviceInfo.supportedChannelCounts()))); <br/>        ui-&gt;textEdit-&gt;insertPlainText( <br/>                    QString("    Supported bit depth b/s: %1\n") <br/>                    .arg(stringifyIntList(deviceInfo.supportedSampleSizes()))); <br/>        ui-&gt;textEdit-&gt;insertPlainText( <br/>                    QString("    Supported sample rates Hz: %1\n") <br/>                    .arg(stringifyIntList(deviceInfo.supportedSampleRates()))); <br/>    }    <br/>} <br/></span></pre>
<div class="packt_tip">Qt Multimedia uses the term sample sizes for the more common term bit depth.</div>
<p>As you can see from my laptop, I have a few different audio input devices. The laptop's built-in audio chip got fried from an electrical spike, which is why it isn't seen here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5acaf2c-000a-4c42-9ccb-ada79d0bf846.png" style="width:36.25em;height:36.17em;"/></p>
<p>For iPhone, it is different. It has only one audio device, named <kbd>default</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4ef5a2e6-b9df-4ad1-ab1a-60cc43d0dd76.png" style="width:16.42em;height:29.25em;"/></p>
<p>My Linux desktop reports a lot of audio input devices because of the ALSA Driver, which I won't include here.</p>
<p>We need to set up the recording encoder settings with the type of audio file we want to record. This includes the number of channels, the code, sample rate, and bit rate:</p>
<pre>QAudioEncoderSettings audioSettings;<br/>audioSettings.setCodec("audio/pcm");<br/>audioSettings.setChannelCount(2);<br/>audioSettings.setBitRate(16);<br/>audioSettings.setSampleRate(44100);</pre>
<p>If you want to let the system decide on the various settings, it is quicker and takes less code to use the <kbd>setQuality</kbd> <span><span>function, which can take one of the following values:</span></span></p>
<ul>
<li><kbd><span>QMultimedia::VeryLowQuality</span></kbd></li>
<li><kbd>QMultimedia::LowQuality</kbd></li>
<li><kbd>QMultimedia::NormalQuality</kbd></li>
<li><kbd>QMultimedia::HighQuality</kbd></li>
<li><kbd>QMultimedia::VeryHighQuality</kbd></li>
</ul>
<p>Let's choose <kbd>NormalQuality</kbd>, which will give the same results:</p>
<pre>audioSettings.setQuality(QMultimedia::NormalQuality);</pre>
<p>The <kbd>QAudioRecorder</kbd> class is used to record the audio, so let's construct a <kbd>QAudioRecorder</kbd> and set the encoding settings:</p>
<pre>QAudioRecorder *audioRecorder = new QAudioRecorder(this);<br/>audioRecorder-&gt;setEncodingSettings(audioSettings);</pre>
<p>You can also specify which audio input to use, but first you will need to get a list of available audio input:</p>
<pre>QStringList inputs = audioRecorder-&gt;audioInputs();</pre>
<p>If you don't want to bother about which audio device to use, you can specify it using the default device with the<span> </span><kbd>defaultAudioInput()</kbd><span> </span>function:</p>
<pre><span>   </span>audioRecorder-&gt;<span>setAudioInput</span>(audioRecorder-&gt;<span>defaultAudioInput</span>());</pre>
<p>We can save it to a file, or even a network location, as the <kbd>setOutputLocation</kbd> function takes a <kbd>QUrl</kbd>. We will just specify a local file to save it to:</p>
<pre>audioRecorder-&gt;<span>setOutputLocation</span>(<span>QUrl</span>::<span>fromLocalFile</span>(<span>"record1.wav"</span>));</pre>
<p>If the file is relative, like it is here, you can get the actual output location using <kbd>outputLocation()</kbd> once the recording has started.</p>
<p>Finally, we can start the recording process:</p>
<pre>audioRecorder-&gt;<span>record</span>();</pre>
<p>There are also the <kbd>stop()</kbd> and <kbd>pause()</kbd> methods to control the recording operation.</p>
<p>Of course, you will want to connect to the error signal, because errors can and will happen from time to time. Again, note the use of the <kbd>QOverload</kbd> syntax that's used in error-reporting signals:</p>
<pre><span>connect</span>(<span>audioRecorder</span>,<span> </span><span>QOverload</span>&lt;<span>QMediaRecorder</span>::<span>Error</span>&gt;::<span>of</span>(<span>&amp;</span><span>QMediaRecorder</span>::<span>error</span>),<br/><span>           </span>[=](<span>QMediaRecorder</span>::<span>Error</span><span> </span>error){<span> <br/></span><span>                ui-&gt;textEdit-&gt;insertPlainText("QAudioRecorder Error: " + audioRecorder-&gt;errorString()); <br/>               on_stopButton_clicked();</span><span> <br/></span>            });<span> </span></pre>
<p>So, now that we have recorded some audio, we might want to listen to it. This is where <kbd>QMediaPlayer</kbd> comes in.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QMediaPlayer</h1>
                </header>
            
            <article>
                
<p><kbd>QMediaPlayer</kbd> is fairly straightforward. It can play both audio and video, but here we will only be playing audio. First, we need to set up the media to play by calling <kbd>setMedia</kbd>. </p>
<p><span>We can use </span><kbd>QAudioRecorder</kbd><span> to get the output file and use it to play:</span></p>
<pre><span>player</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>QMediaPlayer</span>(<span>this</span>);<br/>player-&gt;setMedia(<span>audioRecorder</span>-&gt;<span>outputLocation</span>());</pre>
<p>We will have to monitor the current playing position, so we will connect the <kbd>positionChanged</kbd> signal to a progress bar:</p>
<pre><span>connect</span>(<span>player</span>,<span> </span><span>&amp;</span><span>QMediaPlayer</span>::<span>positionChanged</span>,<br/><span>         </span><span>this</span>,<span> </span><span>&amp;</span><span>MainWindow</span>::<span>positionChanged</span>);</pre>
<p>Connect the error signal and its <kbd>QOverload</kbd> syntax:</p>
<pre><span>connect</span>(<span>player</span>,<span> </span><span>QOverload</span>&lt;<span>QMediaPlayer</span>::<span>Error</span>&gt;::<span>of</span>(<span>&amp;</span><span>QMediaPlayer</span>::<span>error</span>),<br/><span>            </span>[=](<span>QMediaPlayer</span>::<span>Error</span><span> </span>error){<span> <br/></span><span>            </span><span>ui</span>-&gt;<span>textEdit</span>-&gt;insertPlainText(<span>"QMediaPlayer</span><span> </span><span>Error:</span><span> </span><span>"</span><span> </span>+<span> </span><span>player</span>-&gt;errorString());<br/><span>           </span>on_stopButton_clicked();<br/>   });</pre>
<p>Then, just call <kbd>play()</kbd> on the <kbd>QMediaPlayer</kbd> object:</p>
<pre><span>player</span>-&gt;<span>play</span>();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can even set the playback volume:</p>
<pre>player-&gt;setVolume(75);</pre>
<p>If you need access to the media data, let's say for getting the volume level of the data as it plays, you will want to use something other than <kbd>QMediaPlayer</kbd> to play your file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QAudioOutput</h1>
                </header>
            
            <article>
                
<p><kbd>QAudioOutput</kbd> <span>provides a way to send audio to an audio output device:</span></p>
<pre><span>QAudioOutput</span><span> </span>*audio;</pre>
<p>Using <kbd>QAudioOutput</kbd>, you will need to set up the exact format of your file. To get the format of your file, you could use <kbd>QMediaResource</kbd>.</p>
<p>Scratch that—<kbd>QMediaResource</kbd> <span>is being depreciated in Qt 6.0, and does not do what the docs say it is supposed to do, and doesn't work like it should. We need to hardcode the data format, so we will use the basic good-quality stereo format. </span><kbd>QAudioFormat</kbd> <span>is the way to do this:</span></p>
<p> </p>
<pre><span>    </span><span>QAudioFormat</span><span> </span>format;<br/><span>    </span>format.<span>setSampleRate</span>(<span>44100</span>);<br/><span>    </span>format<span>.</span><span>setChannelCount</span>(<span>2</span>);<br/><span>    </span>format<span>.</span><span>setSampleSize</span>(<span>16</span>);<br/><span>    </span>format.<span>setCodec</span>(<span>"audio/pcm"</span>);<br/><span>    </span>format.<span>setByteOrder</span>(<span>QAudioFormat</span>::<span>LittleEndian</span>);<br/><span>    </span>format.<span>setSampleType</span>(<span>QAudioFormat</span>::<span>UnSignedInt</span>);</pre>
<p>We will iterate through the audio devices and check that <kbd>QAudioDeviceInfo</kbd> supports this format:</p>
<p> </p>
<pre><span>    </span><span>for</span><span> </span>(<span>const</span><span> </span><span>QAudioDeviceInfo</span><span> </span>&amp;deviceInfo<span> </span>:<span> </span><span>QAudioDeviceInfo</span>::<span>availableDevices</span>(<span>QAudio</span>::<span>AudioOutput</span>))<span> </span>{<br/><span>        </span><span>if</span><span> </span>(deviceInfo.<span>isFormatSupported</span>(format))<span> </span>{<br/>            audio<span> </span><span>=</span><span> </span><span>new</span><span> </span><span>QAudioOutput</span>(deviceInfo,<span> </span>format,<span> </span><span>this</span>);<br/><span>            </span><span>connect</span>(audio,<span> </span><span>&amp;</span><span>QAudioOutput</span>::<span>stateChanged</span>,<span> </span>[=]<span> </span>(<span>QAudio</span>::<span>State<br/></span>state)<span> </span>{<br/><span>            </span><span>qDebug</span>()<span> </span><span>&lt;&lt;</span><span> </span><span>Q_FUNC_INFO</span><span> </span><span>&lt;&lt;</span><span> </span><span>"state"</span><span> </span><span>&lt;&lt;</span><span> </span>state;<br/><span>            </span><span>if</span><span> </span>(state<span> </span><span>==</span><span> </span><span>QAudio</span>::<span>StoppedState</span>)<span> </span>{<br/><span>                </span><span>if</span><span> </span>(audio-&gt;<span>error</span>()<span> </span><span>!=</span><span> </span><span>QAudio</span>::<span>NoError</span>)<span> </span>{<br/><span>                    </span><span>qDebug</span>()<span> </span><span>&lt;&lt;</span><span> </span><span>Q_FUNC_INFO</span><span> </span><span>&lt;&lt;</span><span> </span>audio-&gt;<span>error</span>();<br/><span>                </span>}<br/><span>            </span>}<span><br/></span><span>        </span>});<br/> }</pre>
<p>Here, I connected to the <kbd>stateChanged</kbd> signal and tested whether the state is <kbd>StoppedState</kbd>; we know there might be an error, so we check the <kbd>error()</kbd> of the <kbd>QAudioOutput</kbd> object. Otherwise, we can play the file:</p>
<pre><span>QFile</span><span> </span>sourceFile;<br/>sourceFile.<span>setFileName</span>(file);<br/>sourceFile.<span>open</span>(<span>QIODevice</span>::<span>ReadOnly</span>);<br/>audio-&gt;<span>start</span>(<span>&amp;</span>sourceFile);</pre>
<p>We see now that Qt Multimedia has various ways of playing audio. Now, let's take a look at the camera and recording video.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Image sensors – camera</h1>
                </header>
            
            <article>
                
<p>First, we should establish whether the device has any cameras. This helps us determine specifics about the use of the camera and other camera specifications, such as the orientation or position on the device.</p>
<p>For this, we will use <kbd>QCameraInfo</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QCameraInfo</h1>
                </header>
            
            <article>
                
<p>We can get a list of cameras using the <kbd>QCameraInfo::availableCameras()</kbd> function:</p>
<div class="packt_infobox"><span>The source code can be found in this book's Git repository under the </span><kbd><span>Chapter09</span>-4</kbd><span> directory, in the <kbd>cp9</kbd> branch.</span></div>
<pre><span>    </span><span>QList</span>&lt;<span>QCameraInfo</span>&gt;<span> </span>cameras<span> </span>=<span> </span><span>QCameraInfo</span>::<span>availableCameras</span>();<br/><span>    </span><span>foreach</span><span> </span>(<span>const</span><span> </span>QCameraInfo<span> </span>&amp;cameraInfo,<span> </span>cameras)<br/><span>        </span><span>ui</span>-&gt;<span>textEdit</span>-&gt;<span>insertPlainText</span>(cameraInfo.<span>deviceName</span>()<span> </span><span>+</span><span> </span><span>"\n"</span>);</pre>
<p class="mce-root"/>
<p>On my Android device, I see two cameras, named <kbd>back</kbd> and <kbd>front</kbd>. You can also check for <kbd>front</kbd> and <kbd>back</kbd> cameras using <kbd>QCameraInfo::position()</kbd>, which will return one of the following:</p>
<ul>
<li><kbd><span>QCamera::UnspecifiedPosition</span></kbd></li>
<li><kbd><span>QCamera::BackFace</span></kbd></li>
<li><kbd><span>QCamera::FrontFace</span></kbd></li>
</ul>
<p><kbd>FrontFace</kbd> means that the camera lens is on the same side as the screen. You can then use <kbd>QCameraInfo</kbd> to construct a <kbd>QCamera</kbd> object:</p>
<pre><span>QCamera *camera;<br/></span><span>if</span><span> </span>(cameraInfo.<span>position</span>()<span> </span><span>==</span><span> </span><span>QCamera</span>::<span>BackFace</span>)<span> </span>{<br/>    camera<span> </span><span>=</span><span> </span><span>new</span><span> </span><span>QCamera</span>(cameraInfo);<br/>}</pre>
<p>Now, check for the capture modes the camera supports, which can be one of the following:</p>
<ul>
<li><span><kbd>QCamera::CaptureViewfinder</kbd></span></li>
<li><kbd><span>QCamera::CaptureStillImage</span></kbd></li>
<li><kbd><span>QCamera::CaptureVideo</span></kbd></li>
</ul>
<p>Let's do a quick still image shot first. We need to tell the camera to use the <kbd>QCamera::CaptureStillImage</kbd> mode:</p>
<pre>camera-&gt;<span>setCaptureMode</span>(<span>QCamera</span>::<span>CaptureStillImage</span>);</pre>
<p>The <kbd>statusChanged</kbd> signal is used to monitor the status, which can be one of the following values:</p>
<ul>
<li><span><kbd>QCamera::UnavailableStatus</kbd></span></li>
<li><kbd><span>QCamera::UnloadedStatus</span></kbd></li>
<li><kbd><span>QCamera::UnloadingStatus</span></kbd></li>
<li><kbd><span>QCamera::LoadingStatus</span></kbd></li>
<li><kbd><span>QCamera::LoadedStatus</span></kbd></li>
<li><kbd><span>QCamera::StandbyStatus</span></kbd></li>
<li><kbd><span>QCamera::StartingStatus</span></kbd></li>
<li><kbd><span>QCamera::StoppingStatus</span></kbd></li>
<li><kbd><span>QCamera::ActiveStatus</span></kbd></li>
</ul>
<p><span>Let's connect to the </span><kbd>statusChanged</kbd><span> signal so that we can see status changes:</span></p>
<pre><span>connect</span>(camera,<span> </span><span>&amp;</span><span>QCamera</span>::<span>statusChanged</span>,<span> </span>[=]<span> </span>(<span>QCamera</span>::<span>Status</span><span> </span>status)<span> </span>{<br/><span>    ui</span><span>-&gt;</span><span>textEdit</span><span>-&gt;</span><span>insertPlainText</span>(<span>QString</span>(<span>"Status</span><span> </span><span>changed</span><span> </span><span>%1"</span>)<span>.</span><span>arg</span>(status)<span> </span><span>+</span><span> </span><span>"\n"</span>);<br/>});</pre>
<p>If you need to fiddle with any of the camera settings, you will have to <kbd>load()</kbd> it before you can get access to the <kbd>QCameraImageProcessing</kbd> object:</p>
<pre>camera-&gt;load();<br/><span>Q</span><span>CameraImageProcessing *imageProcessor = camera-&gt;</span><span>imageProcessing();<br/></span></pre>
<p>With the <kbd>QCameraImageProcessing</kbd> class, you can set configurations, such as brightness, contrast, saturation, and sharpening.</p>
<p>Before we call start on the camera, we need to set up a <kbd>QMediaRecorder</kbd> object for the camera. Since <kbd>QCamera</kbd> is inherited from <kbd>QMediaObject</kbd><span>, we can feed it to the</span> <kbd>QMediaRecorder</kbd> <span>object.</span></p>
<div class="packt_tip">Qt Multimedia Widgets are not supported on Android.</div>
<p>I tried <kbd>QCamera</kbd> version 5.12 on both Mac and iOS, but it kept crashing when I tried to <kbd>start()</kbd> the camera. I was successful on Linux desktop. On Android, since multimedia widgets are not supported, the camera viewfinder widget did not work, but I could still capture images from the image sensor.</p>
<p>Maybe you'll have better luck with the QML side of things. QML APIs are usually optimized for easy use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Camera</h1>
                </header>
            
            <article>
                
<p>Yes, the QML <kbd>Camera</kbd> is so much easier to implement. Really, there are only two components you need to take a photo: <kbd>Camera</kbd> and <kbd>VideoOutput</kbd>. </p>
<p><kbd>VideoOutput</kbd> is the element to use for the viewfinder. It is also used when you are recording video:</p>
<pre><span>    </span><span>Camera</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>camera<br/></span><span>        </span><span>position</span>:<span> </span><span>Camera</span>.BackFace<br/><span>        </span><span>onCameraStateChanged</span>:<span> </span><span>console</span>.log(<span>cameraState</span>)<br/><span>        </span><span>imageCapture</span><span> </span>{<br/><span>            </span><span>onImageCaptured</span>:<span> </span>{<br/><span>                </span><span>console</span>.log(<span>"Image</span><span> </span><span>captured"</span>)<br/><span>            </span>}<br/><span>        </span>}<br/><span>    </span>}</pre>
<p>The <kbd>position</kbd> property controls which camera to use, especially on a mobile device that may have a front-facing and rear-facing camera. Here, I am not only using the rear camera. You would use the <kbd>FrontFace</kbd> position to take a selfie.</p>
<p><kbd>imageCaptured</kbd> pertains to the <kbd>CameraCapture</kbd> sub-element. We can handle the <kbd>onImageCaptured</kbd> signal to preview the image or to alert the user that a photo has been taken.</p>
<p>The other properties of the <kbd>Camera</kbd> object can be controlled by their corresponding components:</p>
<ul>
<li><kbd>focus : CameraFocus</kbd></li>
<li><kbd>flash : CameraFlash</kbd></li>
<li><kbd>exposure : CameraExposure</kbd></li>
<li><kbd>imageProcessing : CameraImageProcessing</kbd></li>
<li><kbd>imageCapture : CameraCapture</kbd></li>
<li><kbd>videoRecorder: CameraRecorder</kbd></li>
</ul>
<p class="title"><kbd>CameraRecorder</kbd> is what you would use to controls saturation, brightness, color filters, contrast, and other settings.</p>
<p><kbd>CameraExposure</kbd> controls things such as aperture, exposure compensation, and shutter speed.</p>
<p><kbd>CameraFlash</kbd> can turn the flash on, off, or use auto mode. It can also set red-eye compensation and video (constant) mode.</p>
<p class="mce-root"/>
<p>We need a view finder to see what the heck we are trying to capture, so let's take a look at the <kbd>VideoOutput</kbd> element. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VideoOutput</h1>
                </header>
            
            <article>
                
<p><kbd>VideoOutput</kbd> is the component we use to view what the camera is sensing.</p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter09-5</kbd><span> directory, in the</span><span> </span><kbd>cp9</kbd><span> </span><span>branch.</span></div>
<p>To implement the <kbd>VideoOutput</kbd> component, you need to define the <kbd>source</kbd> property. Here, we are using the camera:</p>
<pre><span>    </span><span>VideoOutput</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>viewfinder<br/></span><span>        </span><span>source</span>:<span> </span><span>camera<br/></span><span>        </span><span>autoOrientation</span>:<span> </span>true<br/>}</pre>
<p>The <kbd>autoOrientation</kbd> property is used to allow the <kbd>VideoOutput</kbd> component to compensate for the device orientation of the image sensor. Without this being true, the image might show up in the view finder with the wrong orientation and confuse the user, making it harder to take a good photo or video.</p>
<p>Let's make this <kbd>VideoOutput</kbd> clickable by adding a <kbd>MouseArea</kbd>, where I will use the <kbd>onClicked</kbd> and <kbd>onPressAndHold</kbd> signals to focus and actually capture an image:</p>
<pre><span>MouseArea</span><span> </span>{<br/><span>    anchors.fill</span>:<span> </span><span>parent<br/></span><span>    </span><span>onPressAndHold</span>:<span> </span>{<br/><span>        </span>captureMode:<span> </span><span>captureSwitch</span>.position<span> </span>===<span> </span>0<span> </span>?<span>Camera</span>.CaptureStillImage : C<span>amera</span>.CaptureVideo<br/><span>        </span><span>camera</span>.imageCapture.capture()<br/><span>    </span>}<br/>    <span>onClicked</span><span>:</span><span> </span><span>{<br/></span><span>        </span><span>if</span><span> </span>(<span>camera</span>.lockStatus<span> </span>==<span> </span><span>Camera</span>.Unlocked)<br/><span>            </span><span>camera</span>.unlock();<br/><span>            camera</span>.searchAndLock();<span><br/></span><span>    </span>}<br/><span> </span>}</pre>
<p>I also added a <kbd>Switch</kbd> component from Qt Quick Controls to control whether the user wants a still photo or video recorded.</p>
<p>To focus the camera, call the <kbd>searchAndLock()</kbd> method, which starts focus, white balance, and exposure computations.</p>
<p class="mce-root">Let's add support for recording videos. We will add a <kbd>CameraRecorder</kbd> container to the <kbd>Camera</kbd> component:</p>
<pre><span>VideoRecorder</span><span> </span>{<br/><span>    audioEncodingMode</span>:<span> </span><span>CameraRecorder</span>.ConstantBitrateEncoding;<br/><span>    </span><span>audioBitRate</span>:<span> </span>128000<br/><span>    </span><span>mediaContainer</span>:<span> </span><span>"mp4"<br/></span>}</pre>
<p>We can set certain aspects for the video, such as bit rate, frame rate, number of audio channels, and what container to use.</p>
<p>We need to also change the way our <kbd>onPressAndHold</kbd> signal works to make sure we record video when the user has specified it, by the use of the switch:</p>
<pre><span>onPressAndHold</span>:<span> </span>{<br/>    captureMode:<span> </span><span>captureSwitch</span>.position<span> </span>===<span> </span>0<span> </span>? <span>Camera</span>.CaptureStillImage : <span>Camera</span>.CaptureVideo<br/><span>    </span><span>if</span><span> </span>(<span>captureSwitch</span>.position<span> </span>===<span> </span>0)<br/><span>        </span><span>camera</span>.imageCapture.capture()<br/><span>    </span><span>else<br/></span><span>        </span><span>camera</span>.videoRecorder.record()<br/>}</pre>
<p>We need some way to stop recording, so let's modify the <kbd>onClicked</kbd> signal handler to stop the recording when it is in <kbd>RecordingState</kbd>:</p>
<pre><span>onClicked</span>:<span> </span>{<br/><span>    if</span><span> </span>(<span>camera</span>.videoRecorder.recorderState<span> </span>===<span> </span><span>CameraRecorder</span>.RecordingState)<span> </span>{<br/><span>        </span><span>camera</span>.videoRecorder.stop()<br/><span>     </span>}<span> </span><span>else</span><span> </span>{<br/><span>         </span><span>if</span><span> </span>(<span>camera</span>.lockStatus<span> </span>==<span> </span><span>Camera</span>.Unlocked)<br/><span>             </span><span>camera</span>.unlock();<br/>         <span>camera</span><span>.searchAndLock();<br/></span><span>     </span>}<br/>}</pre>
<p>Now, we need to actually see the video we just recorded. Let's move on and look at how to play a video.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual media – playing video</h1>
                </header>
            
            <article>
                
<p>Playing a video with QML is much like playing audio using <kbd>MediaPlayer</kbd>, only using a <kbd>VideoOutput</kbd> instead of an <kbd>AudioOutput</kbd> component.</p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter09-6</kbd><span> directory, in the</span><span> </span><kbd>cp9</kbd><span> </span><span>branch.</span></div>
<p>We begin by implementing a <kbd>MediaPlayer</kbd> component:</p>
<div>
<pre><span>MediaPlayer</span><span> </span>{<br/><span>    </span><span>id</span>:<span> </span><span>player</span></pre></div>
<p>The property named <kbd>autoPlay</kbd> will control the automatic starting of the video once the component is completed. </p>
<p>Here, the <kbd>source</kbd> property is set to the filename of our video:</p>
<div>
<pre><span><br/></span><span>    </span><span>autoPlay</span>:<span> </span>true<br/>    source: "hellowindow.m4v"<br/><span>    </span><span>onStatusChanged</span>:<span> console.log("Status " + </span><span>status</span>)<br/><span>    onError</span>:<span> </span><span>console</span>.log(<span>"Error:</span><span> </span><span>"</span><span> </span>+<span> </span><span>errorString</span>)<br/>}</pre></div>
<p>We then create a <kbd>VideoOutput</kbd> component, with the source being our <kbd>MediaPlayer</kbd>:</p>
<pre><br/><span>VideoOutput</span><span> </span><span>{<br/></span><span>    </span><span>source</span>:<span> </span><span>player<br/></span><span>    </span><span>anchors.fill</span><span> </span>:<span> </span><span>parent<br/></span><span> </span>}<br/><span><br/>MouseArea</span><span> </span>{<br/><span>    </span><span>id</span>:<span> </span><span>playArea<br/></span><span>    </span><span>anchors.fill</span>:<span> </span><span>parent<br/></span><span>    </span><span>onPressed</span>:<span> </span><span>player</span>.play();<br/>}</pre>
<p>The <kbd>MouseArea</kbd>, which is the entire application, is used here to start playing the video when you click anywhere on the application.</p>
<p>With C++, you would use the <kbd>QMediaPlayer</kbd> class with a <kbd>QGraphicsVideoItem</kbd>, <kbd>QVideoWidget</kbd><span>, or something else.</span></p>
<p>Since <kbd>QMultimediaWidgets</kbd> have limited support on mobile devices, I will leave this as an exercise for the reader.</p>
<p>Qt Multimedia also supports FM, AM, and some other radios, providing your device has a radio in it as well. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuning it in – FM radio tuner</h1>
                </header>
            
            <article>
                
<p>Some Android phones have an FM radio receiver. Mine does! It requires the wired headphones to be inserted to work as the antenna.<span> </span></p>
<p>We start by implementing a <kbd>Radio</kbd> component:</p>
<pre>Radio {<br/>    id: radio</pre>
<p><span>The</span><span> </span><kbd><span>Radio</span></kbd><span> </span><span>element has a <kbd>band</kbd> property that you can use to configure the radio's frequency band use. They are one of the following:</span></p>
<ul>
<li><kbd>Radio.AM</kbd> : 520 - 1610 kHz</li>
<li><kbd><span>Radio.</span>FM</kbd> : 87.5 - 108 MHz, Japan 76 - 90 MHz</li>
<li><kbd><span>Radio.</span>SW</kbd> : 1.711 to 30 MHz</li>
<li><kbd><span>Radio.</span>LW</kbd> : 148.5 to 283.5 kHz</li>
<li><kbd><span>Radio.</span>FM2</kbd> : Range not defined</li>
</ul>
<pre><br/>    band: Radio.FM<br/>    Component.onCompleted {<br/>        if (radio.availability == Radio.Available)<br/>            console.log("Good to go!")<br/>        else <br/>           console.log("Sad face. No radio found. :(")<br/>    }<br/>}</pre>
<p>The <kbd>availability</kbd> property can return the following different values:</p>
<ul>
<li><kbd><span>Radio.</span>Available</kbd></li>
<li><kbd><span>Radio.</span>Busy</kbd></li>
<li><kbd><span>Radio.</span>Unavailable</kbd></li>
<li><kbd><span>Radio.</span>ResourceMissing</kbd></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first thing the user will do with a radio is scan for stations, which can be accomplished by using the <kbd>searchAllStations</kbd><span> </span>method, which takes one of the following values:</p>
<ul>
<li><kbd><span>Radio.</span>SearchFast</kbd></li>
<li><kbd><span>Radio.</span>SearchGetStationId</kbd>: Like <kbd>SearchFast</kbd>, it emits the <kbd>stationFound</kbd> signal</li>
</ul>
<p>The <kbd>stationsFound</kbd> signal returns an <kbd>int</kbd> <kbd>frequency</kbd> and <kbd>stationId</kbd> string for each station that's tuned in. You could collect these in a model-based component, such as <kbd>ListView</kbd>, using a <kbd>ListModel</kbd>. The <kbd>ListView</kbd> would use the <kbd>ListModel</kbd> as its model.</p>
<p>You can cancel the scan by calling the <kbd>cancelScan()</kbd> method. The <kbd>scanUp()</kbd> and <kbd>scanDown()</kbd> methods are similar to <kbd>searchAllStations</kbd>, except it does not remember the stations it found. The <kbd>tuneUp</kbd> and <kbd>tuneDown</kbd> methods will tune the frequency up or down one step, according to the <kbd>frequencyStep</kbd>.</p>
<p>Here are some other interesting properties:</p>
<ul>
<li><kbd>antennaConnected</kbd>: True if an antenna is connected</li>
<li><kbd>signalStrength</kbd>: Strength of the signal in %</li>
<li><kbd>frequency</kbd>: Holds and sets the frequency that the radio is tuned to</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the different aspects of the big API of Qt Multimedia. You should now be able to position sound in a 3-dimensional way for 3D games. We learned how to record and play audio and video, and control and use the camera to take a selfie. We also touched on using QML to listen to radio stations.</p>
<p>In the next chapter, we will dig into using <kbd>QSqlDatabase</kbd> to access databases.</p>


            </article>

            
        </section>
    </body></html>