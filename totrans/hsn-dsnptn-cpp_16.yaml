- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adapters and Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter takes on two classic patterns in **object-oriented programming**
    (**OOP**) - the Adapter pattern and the decorator pattern. These patterns are
    just two of the original twenty-three design patterns that were introduced in
    the *Design Patterns – Elements of Reusable Object-Oriented Software* book by
    Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. As an object-oriented
    language, C++ can take advantage of these patterns as well as any other language.
    But, as is often the case, generic programming brings some advantages, variations,
    and, with it, new challenges to the classic patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the adapter and decorator patterns?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between the two?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What design problems can be solved by these patterns?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are these patterns used in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does generic programming help to design adapters and decorators?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other, different, patterns offer alternative solutions to similar problems?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code for this chapter can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16).'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will begin this study with the definitions of the two classic patterns. As
    we will see, on paper, the patterns, as well as the differences between them,
    are quite clear. Then, C++ comes in and blurs the lines by allowing design solutions
    that fall somewhere in-between the two. Still, the clarity of these simple cases
    is helpful, even if it gets muddled as we pile on the complexity. Let’s start
    with what is clear, then.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern is also a structural pattern; it allows a behavior to
    be added to an object. The classic decorator pattern extends the behavior of an
    existing operation that’s performed by a class. It *decorates* the class with
    the new behavior and creates an object of the new, decorated type. The decorator
    implements the interface of the original class and forwards the requests from
    its own interface to that class, but it also performs additional actions before
    and after these forwarded requests - these are the *decorations.* Such decorators
    are sometimes called “class wrappers”.
  prefs: []
  type: TYPE_NORMAL
- en: Basic decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will begin with a C++ example of the decorator pattern that follows the
    classic definition as closely as possible. For this example, we will imagine designing
    a fantasy game that’s set in medieval times (true to life, only with dragons and
    elves and so on). Of course, what are medieval times without fighting? And so,
    in our game, the player has a choice of units appropriate for his/her side, and
    they can do battle when called on. Here is the basic `Unit` class - at least the
    combat-related part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The unit has `strength`, which determines its attack, and `armor`, which provides
    defense. The actual values of the attack and the defense are computed by the derived
    classes - the concrete units - but the combat mechanism itself is right here -
    if the attack is stronger than the defense, the unit successfully hits the target
    (this is a very simplistic approach to gaming, of course, but we want to make
    the examples as concise as possible).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what are the actual units in the game? The pillar of the human armies
    is the valorous `Knight`. This unit has strong armor and a sharp sword, giving
    it bonuses to both attack and defend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Fighting against the knights are the brutish ogres. The ogres swing simple
    wooden clubs and wear ragged leather, neither of which are great implements of
    war, giving them some combat penalties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, ogres are remarkably strong, to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the knight, aided by his attack bonus and the enemy’s weak armor, will
    successfully hit the ogre. But the game is far from over. As the units fight,
    the surviving ones gain experience and eventually become veterans. A veteran unit
    is still the same kind of unit, but it gains attack and defense bonuses, reflecting
    its combat experience. Here, we do not want to change any of the class interfaces,
    but we want to modify the behavior of the `attack()` and `defense()` functions.
    This is the job of the decorator pattern, and what follows is the classic implementation
    of the `VeteranUnit` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this class inherits directly from the `Unit` class, so in the class
    hierarchy, it is *to the side* of concrete unit classes such as `Knight` or `Ogre`.
    We still have the original unit that is decorated and becomes the veteran - the
    `VeteranUnit` decorator contains a reference to it. The way it is used, then,
    is to decorate a unit and use the decorated unit from then on, but it does not
    delete the original unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, both our old enemies reached their first veterancy levels, and the victory
    again goes to the knight. But experience is the best teacher, and our ogre gains
    another level, and, with it, enchanted runic armor with a massive defense bonus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can decorate a decorated object in this design! This is intentional,
    and the bonuses stack up as the unit gains levels. This time, the experienced
    fighter’s defense proves to be too much for the knight.
  prefs: []
  type: TYPE_NORMAL
- en: As we already mentioned, this is the classic decorator pattern, straight out
    of the textbook. It works in C++ but with some limitations. The first one is rather
    evident even though we want to use the decorated unit once we have it, the original
    unit must be kept around, and the lifetimes of these objects must be carefully
    managed. There are practical solutions to such practical problems, but the focus
    of this book is on combining design patterns with generic programming, and the
    new design possibilities that pairing creates. Therefore, our creative path takes
    us elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second problem is more endemic to C++. It is best illustrated by an example.
    The game’s designers have added a special ability to the `Knight` unit - it can
    charge forward at its enemy, gaining a short-term attack bonus. This bonus is
    valid only for the next attack, but in the thick of the battle, it may be just
    enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The charge bonus is activated by calling the `charge()` member function and
    lasts for one attack, and then it is reset. When the player activates the charge,
    the game executes the code, which looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we would expect the veteran knight to be able to charge forward
    as well, but here we run into a problem - our code does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The root of the problem is that `charge()` is a part of the interface of the
    `Knight` class, while the `VeteranUnit` decorator is derived from the `Unit` class.
    We could move the `charge()` function into the base class, `Unit`, but this is
    a bad design - `Ogre` is also derived from `Unit`, and ogres cannot charge, so
    they should not have such an interface (it violates the *is-a* principle of public
    inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: This is a problem that’s inherent in the way we implemented the decorator object
    - both `Knight` and `VeteranUnit` are derived from the same base class, `Unit`,
    but they don’t know anything about each other. There are some ugly workarounds,
    but it is a fundamental C++ limitation; it does not handle *cross-casting* well
    (casting to a type in another branch of the same hierarchy). But what the language
    takes with one hand, it gives with the other - we have much better tools to deal
    with this problem, and we are going to learn about these tools next.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators the C++ way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have encountered two problems while implementing a classic decorator in
    C++ - first of all, the decorated object did not take ownership of the original
    object, so both must be kept around (this may not be so much a problem as a feature
    if the decoration needs to be removed later, which is one of the reasons the decorator
    pattern is implemented this way). The other problem is that a decorated `Knight`
    is not really a `Knight` at all, but a `Unit`. We can solve the second problem
    if the decorator is itself derived from the class that is being decorated. This
    would imply that the `VeteranUnit` class does not have a fixed base class - the
    base class should be whatever class is being decorated. This description matches
    the **Curiously Recurring Template Pattern** (**CRTP**) to a tee (this C++ idiom
    was described earlier in this book in [*Chapter 8*](B19262_08.xhtml#_idTextAnchor360)*,
    The Curiously Recurring Template Pattern*). To apply CRTP, we need to make the
    decorator into a template and inherit from the template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to promote a unit to the veteran status, we must convert it to the decorated
    version of the concrete `unit` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same scenario that we saw at the end of the previous section, but
    it now uses the template decorator. Notice the differences. First of all, a `VeteranUnit`
    is a class that’s derived from a concrete unit such as `Knight` or `Ogre`. As
    such, it has access to the interface of the base class: for example, a veteran
    knight, `VeteranUnit<Knight>`, is a `Knight` too and has the member function `charge()`
    inherited from `Knight`. Second, the decorated unit explicitly takes ownership
    of the original unit - to create a veteran unit, we have to move the original
    unit into it (the base class of the veteran unit is move-constructed from the
    original unit). The original object is left in the unspecified moved-from state,
    and the only safe action that can be done on this object is a call to the destructor.
    Note that, at least for the simple implementation of unit classes, the `move`
    operation is just a copy, so the original object is usable, but you should not
    rely on it - making assumptions about the moved-from state is a bug waiting to
    happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth pointing out that our declaration of the `VeteranUnit` constructor
    enforces and requires this ownership transfer. If we try to construct a veteran
    unit without moving from the original unit, it will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By providing only one constructor that accepts an r-value reference, that is,
    `Unit&&`, we require that the caller agrees to the transfer of ownership.
  prefs: []
  type: TYPE_NORMAL
- en: So far, for demonstration purposes, we have created all unit objects on the
    stack as local variables. In any non-trivial program, this is not going to work
    - we need these objects to stay around, long after the function that created them
    is done. We can integrate decorator objects and the memory ownership mechanism
    and ensure that the moved-from original units are deleted after a decorated version
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that ownership is managed throughout the program by unique pointers
    (each object has a clear owner at any given time). Here is how this can be accomplished.
    First of all, it is convenient to declare aliases for the pointers we need to
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'While any unit can be owned by the `Unit_ptr` pointer, we cannot call unit-specific
    member functions such as `charge()` through it, so we may need pointers to the
    concrete classes as well. As we will see next, we need to move the object between
    these pointers. Moving from a pointer to the derived class to the pointer to the
    base class is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Going in the other direction is a little harder; `std::move` will not work
    implicitly, just like we cannot convert from `Unit*` to `Knight*` without an explicit
    cast. We need a *moving cast*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `static_cast` to cast to the derived class, which works if the
    assumed relation (that the base object really is the expected derived object)
    is correct, otherwise, the results are undefined. We can test this assumption
    at runtime if we want to, using `dynamic_cast` instead. Here is a version that
    does the test, but only if asserts are enabled (we could throw an exception instead
    of the assert):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If all objects will be owned by instances of a unique pointer, then the `VeteranUnit`
    decorator has to accept a pointer in its constructor and move the object out of
    this pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The tricky part here is in the initialization of the base class `U` of `VeteranUnit<U>`
    - we have to move the unit from a unique pointer to the base class into a move-constructor
    of the derived class (there is no way to simply move the object from one unique
    pointer to another; we need to wrap it into the derived class). We have to do
    this without leaking any memory, too. The original, unique pointer, is released,
    so its destructor will do nothing, but our `move_cast` returns a new unique pointer
    that now owns the same object. This unique pointer is a temporary variable and
    will be deleted at the end of the initialization of the new object, but not before
    we use its object to construct a new derived object that is a `VeteranUnit` (the
    move-initialization of the unit object itself does not save any time versus copy
    in our case, but it is a good practice in the event a more heavyweight unit object
    provides an optimized move constructor).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how this new decorator is used in a program that manages resources
    (units, in our case) by unique pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we did not redefine the `hit()` function - it still accepts a unit
    object by reference. This is correct because this function does not take ownership
    of the object - it merely operates on it. There is no need to pass an owning pointer
    into it - that would suggest a transfer of ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, strictly speaking, there is very little difference between this example
    and the last one - the moved-from unit should not be accessed either way. Practically
    speaking, there is a significant difference - the moved-from pointer no longer
    owns the object. Its value is null, so any attempt to operate on the original
    unit after it was promoted will become evident in very short order (the program
    will dereference a null pointer and crash).
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, we can decorate an already decorated class, as the effects
    of the decorators stack up. Similarly, we can apply two different decorators to
    the same class. Each decorator adds a particular new behavior to the class. In
    our game engine, we can print the results of each attack, whether or not there
    was a hit. But if the result does not match the expectations, we don’t know why.
    For debugging, it might be useful to print the attack and defense values. We would
    not want to do this all the time for all units, but for the part of the code we
    are interested in, we could use a debugging decorator that adds new behavior to
    the units to print the intermediate results of the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DebugDecorator` uses the same design idea as the previous decorator -
    it’s a class template that generates a class that’s derived from the object to
    be decorated. Its `attack()` and `defense()` virtual functions forward the calls
    to the base class and print the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we left out the dynamic memory allocations and relied on moving
    the objects themselves for ownership transfer. There is no reason we cannot have
    both stackable decorators and unique pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When implementing decorators, you should be careful to not inadvertently change
    the behavior of the base class in unexpected ways. For example, consider this
    possible implementation of `DebugDecorator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There is a subtle bug here - the decorated object, in addition to the expected
    new behavior - the printout - hides a change in the original behavior - it calls
    `attack()` twice on the base class. Not only might the printed value be incorrect
    if two calls to `attack()` return different values, but also any one-time attack
    bonuses such as the knight’s charge will be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: '`DebugDecorator` adds very similar behavior to each member function it decorates.
    C++ has a rich set of tools that are aimed specifically at improving code reuse
    and reducing duplication. Let’s see if we can do better and come up with a more
    reusable, universal decorator.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic decorators and their limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some decorators are very specific to the classes they modify, and their behavior
    is narrowly targeted. Others are very general, at least in principle. For example,
    a debugging decorator that logs function calls and prints return values could
    be used with any function if we could only implement it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such an implementation is pretty straightforward in C++14 or above using `variadic`
    templates, parameter packs, and perfect forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator can be wrapped around any callable object or function (anything
    that can be called with the `()` syntax) with any number of arguments. It prints
    the custom string and the result of the call. However, writing out the callable
    type is often tricky - it is much better to get the compiler to do it for us using
    template argument deduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This template function deduces the type of the `Callable` and decorates it
    with the debugging wrapper. We can now apply it to any function or object. Here
    is a decorated function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also decorate a callable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that our decorator does not take ownership of the callable object (we could
    write it in such a way that it does so if we wanted to).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even decorate a lambda expression, which is really just an implicitly
    typed callable object. The one in this example defines a callable object with
    two integer arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we decided to forward the callables both in the decorator class
    constructor and in the helper function. Often, the callables are passed by value
    instead and are assumed to be cheap to copy. In all cases, it is important that
    the decorator stores a copy of the callable in its data member. If you capture
    it by reference instead, there is a subtle error waiting to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Decorating a function is likely to work fine, but decorating a lambda will
    fail (although not necessarily in an immediately visible way). The `const Callable&
    c_` member is going to be bound to a temporary lambda object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The lifetime of this object ends at the semicolon at the end of this statement,
    and any subsequent use of `f2` accesses a dangling reference (address sanitizer
    tools can help detect such errors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our decorator has some limitations. First, it falls short when we try to decorate
    a function that does not return anything, such as the following lambda expression,
    which increments its argument but returns nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem lies with the `void res` expression that is coming from the `auto
    res = ...` line inside the `DebugDecorator`. This makes sense since we cannot
    declare variables of the `void` type. This problem can be solved using `if constexpr`
    in C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Before C++17, the most common alternative to if constexpr uses function overloading
    (the first argument is `std::true_type` or `std::false_type` depending on the
    branch of if constexpr provided by the corresponding function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The second limitation is that the `auto` return type of our decorator is deduced
    only *mostly* accurately - for example, if a function returns `double&`, the decorated
    function will return just `double`. Lastly, wrapping member function calls is
    possible, but requires a somewhat different syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the template mechanism in C++ is powerful, and there are ways to make our
    generic decorator even more generic. These ways also make it more complex. Code
    like this belongs in a library, such as the standard library, but in most practical
    applications a debugging decorator is not worth such effort.
  prefs: []
  type: TYPE_NORMAL
- en: The other limitation is that the more generic a decorator becomes, the less
    it can do. As it is, there are very few actions we could take that make sense
    for calling any function or member function (even to produce a good debug message
    in our decorator we might need to use compiler extensions, see *Example 09*).
    We could add some debug printouts, and print the result as long as it has the
    stream output operator defined. We could lock a mutex to protect a non-thread-safe
    function call in a multi-threaded program. Maybe there are a few more general
    actions. But, in general, do not get seduced by the pursuit of the most generic
    code for its own sake.
  prefs: []
  type: TYPE_NORMAL
- en: Whether we have somewhat generic or very specific decorators, we often have
    the need to add multiple behaviors to an object. We have seen one such example
    already. Now, let’s review the problem of applying multiple decorators more systematically.
  prefs: []
  type: TYPE_NORMAL
- en: Composable decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The decorator property that we would like to have here has a name composability.
    Behaviors are composable if they can be applied to the same object separately:
    in our case, if we have two decorators, `A` and `B`. Therefore, `A(B(object))`
    should have both behaviors applied. The alternative to composability is the explicit
    creation of the combined behaviors: to have both behaviors without composability,
    we would need to write a new decorator, `AB`. Since writing new code for any combination
    of several decorators would be impossible even for a relatively small number of
    decorators, composability is a very important property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, composability is not hard to achieve with our approach to decorators.
    The CRTP decorators we used in our game design earlier are naturally composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Each decorator inherits from the object it decorates and, thus, preserves its
    interface, except for the added behavior. Note that the order of the decorators
    matters since the new behavior is added before or after the decorated call. `DebugDecorator`
    applies to the object it decorates and provides debugging for it, so a `VeteranUnit<DebugDecorator<Ogre>>`
    object would debug the base portion of the object (`Ogre`), which can be useful
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our (somewhat) universal decorators can be composed as well. We already have
    a debugging decorator that can work with many different callable objects, and
    we mentioned a possible need to protect these calls with a mutex. We can now implement
    such a locking decorator in a similar manner (and with similar limitations) to
    the polymorphic debugging decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will use the `decorate_lock()` helper function to delegate to the
    compiler the tedious work of figuring out the right type of the callable object.
    We can now use a mutex to protect a function call that is not thread-safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to protect a function by a mutex and have a debug printout when
    it’s called, we do not need to write a new *locking debugging decorator,* but
    instead can apply both decorators in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the benefits of composability - we do not have to
    write a special decorator for every combination of behaviors (think how many decorators
    you would have to write for any combination of five different primary decorators
    if they were not composable!).
  prefs: []
  type: TYPE_NORMAL
- en: This composability is achieved easily in our decorators because they preserve
    the interface of the original object, at least the part we are interested in -
    the behavior changes, but the interface does not. When a decorator is used as
    an original object for another decorator, the preserved interface is once again
    preserved, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This preservation of the interface is a fundamental feature of the Decorator
    pattern. It is also one of its most serious limitations. Our locking decorator
    is not nearly as useful as it may seem at first glance (so do not go around your
    code bolting a lock onto every call when you need to make the code thread-safe).
    As we will see next, not every interface can be made thread-safe, no matter how
    good the implementation is. That’s when we have to change the interface in addition
    to modifying the behavior. This is the job for the Adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We ended the last section with the notion that the decorator pattern has particular
    advantages that come from preserving the decorated interface and that these advantages
    can sometimes turn into limitations. The Adapter pattern is a more general pattern
    that can be used in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern is defined very generally - it is a structural pattern that
    allows an interface of a class to be used as another, different interface. It
    allows an existing class to be used in code that expects a different interface,
    without modifying the original class. Such adapters are sometimes called **class
    wrappers** since they *wrap* around a class and present a different interface.
    You may recall that decorators are also sometimes called **class wrappers**, much
    for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: However, Adapter is a very general, broad pattern. It can be used to implement
    several other, more narrowly defined patterns - in particular, the decorator.
    The decorator pattern is easier to follow, so we dealt with that first. Now, we
    will move on to the general case.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s follow on from the final example from the last section - the locking decorator.
    It calls any function under a lock, so no other function protected by the same
    mutex can be called on any other thread at the same time. In some cases, this
    could be enough to make the entire code thread-safe. Often, it is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we are going to implement a thread-safe queue object.
    A queue is a moderately complex data structure, even without thread safety, but,
    fortunately, we do not need to start from scratch - we have `std::queue` in the
    C++ standard library. We can push objects onto the queue and take them from the
    queue in first-in-first-out order, but only on one thread - it is not safe to
    push two objects onto the same queue from two different threads at the same time,
    for example. But we have a solution for that - we can implement a locking queue
    as a decorator for the basic one. Since we are not concerned about the empty base
    optimization here (`std::queue` is not an empty class) and we have to forward
    every member function call, we do not need the inheritance and can use composition
    instead. Our decorator will contain the queue and the lock. Wrapping the `push()`
    method is easy. There are two versions of `push()` in `std::queue` - one moves
    the object and one copies it. We should protect both with the lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s turn our attention to getting elements off the queue. The standard
    queue has three relevant member functions - first, there is `front()`, which lets
    us access the front element of the queue, but does not remove it from the queue.
    Then, there is `pop()`, which removes the front element but returns nothing (it
    gives no access to the front element - it just removes it). Both of these functions
    should not be called if the queue is empty - there is no error checking, but the
    result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is the third function, `empty()`; it returns false if the queue
    is not empty, and then we can call `front()` and `pop()`. If we decorate them
    with locking, we will be able to write code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Each function is thread-safe by itself. The entire combination of them is not.
    It is important to understand why. First, we call `q.empty()`. Let’s assume that
    it returns `false`, so we know there is at least one element on the queue. We
    go on to access it on the next line by calling `q.front()`, which returns `5`.
    But this is just one of many threads in the program. Another thread is going through
    the same code at the same time (enabling this behavior is the point of the exercise).
    That thread, too, calls `q.empty()` and also gets `false` - as we just said, there
    is an element in the queue, and we have done nothing to remove it yet. The second
    thread also calls `q.front()` and gets `5` as well. That is already a problem
    - two threads each tried to take an element from the queue, but got the same one
    instead. But it gets worse - our first thread now calls `q.pop()` and removes
    `5` from the queue. The queue is now empty, but the second thread does not know
    about this - it called `q.empty()` earlier. Therefore, the second thread now calls
    `q.pop()` as well, this time on an empty queue. The best-case scenario here is
    that the program will crash right away.
  prefs: []
  type: TYPE_NORMAL
- en: We have just seen a specific case of a general problem - a sequence of actions,
    each of which is thread-safe, but is not thread-safe as a whole. In fact, this
    *locking queue* is entirely useless, and there is no way to write thread-safe
    code with it. What we need is a single thread-safe function that performs the
    entire transaction under one lock, as a single uninterruptible action (such transactions
    are called `std::queue` interface does not provide such a transactional API.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, we need a new pattern - one that transforms the existing interface
    of a class to our needs for a different interface. This cannot be done with the
    decorator pattern, but this is exactly the problem that the Adapter pattern solves.
    Now that we have agreed that we need a different interface, we just have to decide
    what it should be. Our single new `pop()` member function should do all of this
    - if the queue is not empty, it should remove the first element from the queue
    and return it, by copy or move, to the caller. If the queue is empty, it should
    not alter the state of the queue at all, but should somehow notify the caller
    that the queue was empty. One way to do this is to return two values - the element
    itself (if there is one) and a Boolean value that tells us whether the queue was
    empty or not. Here is the `pop()` part of the locking queue, which is now an adapter,
    not a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that we do not need to change `push()` - the single function call already
    does everything we need, so that part of the interface is just forwarded one-to-one
    by our adapter. This version of `pop()` returns `true` if it removed an element
    from the queue, and `false` otherwise. If `true` is returned, the element is saved
    into the provided argument, but if `false` is returned, the argument is unchanged.
    If the element type `T` is move-assignable, a move will be used instead of copy.
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, not the only possible interface for such an atomic `pop()`.
    Another way would be to return both the element and the Boolean value as a pair.
    One significant difference is that there is now no way to leave the element unchanged
    - it’s the return value and it always has to be something. The natural way is
    to default-construct the element if there isn’t one on the queue (which implies
    a restriction on the element type `T` - it has to be default-constructible).
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++17, the better alternative is to return a `std::optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the application code that needs this queue, one of the interfaces
    may be preferable, and so there are other ways to design it as well. In all cases,
    we end up with two member functions, `push()` and `pop()`, that are protected
    by the same mutex. Now, any number of threads can execute any combination of these
    operations at the same time, and the behavior is well-defined. This means that
    the `locking_queue` object is thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an object from its current interface to the interface needed by a
    particular application, without rewriting the object itself, is the purpose and
    use of the Adapter pattern. All kinds of interfaces may have to be converted,
    and so there are many different types of adapters. We will learn about some of
    them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Function adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just seen a class adapter that changes the interface of a class. Another
    kind of interface is a function (a member or a non-member function). A function
    has certain arguments, but we may want to call it with a different set of arguments.
    This would need an adapter. One common application of such adapters is known as
    currying one (or more) of the function’s arguments. All it means is that we have
    a function of several arguments, and we fix the value of one of these arguments,
    so we don’t have to specify it on every call. One example would be if we have
    `f(int i, int j)`, but we want `g(i)`, which is the same as `f(i, 5)`, only without
    typing the `5` every time.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more interesting example that we are actually going to work our way
    through and implement an adapter. The `std::sort` function takes an iterator range
    (the sequence to sort), but it can also be called with three arguments - the third
    one is the comparison object (by default, `std::less` is used, which, in turn,
    calls `operator<()` on the objects being sorted).
  prefs: []
  type: TYPE_NORMAL
- en: We want something else now - we want to compare floating-point numbers *fuzzily*,
    with tolerance - if the two numbers `x` and `y` are close enough to each other,
    then we don’t consider one to be less than the other. Only when `x` is much less
    than `y` do we want to enforce the sorted order where `x` comes before `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our comparison functor (a callable object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This comparison object can be used with a standard sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we need this kind of sort often, we may want to curry the last
    argument and make ourselves an adapter that has just two arguments, the iterators,
    and the sorting function implied. Here is such an adapter - it is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call a sort function with two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we often call sort in this manner to sort the entire container, we
    may want to change the interface once again and make another adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++20, `std::sort` and other STL functions have variants that accept ranges;
    they are a generalization of our container adapter. Now, the code in our program
    looks even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to point out that C++14 provides an alternative for writing
    such simple adapters that should, in general, be preferred; we can use a lambda
    expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the comparison function much_less() is itself a callable, so it
    could be a lambda too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The container adapter is just as easy to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that you cannot have both of these in the same program under the same name
    - lambda expressions cannot be *overloaded* in this manner; they are actually
    not functions at all, but rather objects (you can create an overload set from
    lambdas, as was shown in [*Chapter 2*](B19262_02.xhtml#_idTextAnchor043)*, Class
    and* *Function Templates*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to the matter of calling a function with some arguments fixed,
    or bound, to constant values, we should say that this is such a common need that
    the C++ standard library provides a standard customizable adapter for this purpose,
    `std::bind`. Here is an example that shows us how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This standard adapter has its own *mini-language* - the first argument to `std::bind`
    is the function to be bound, while the rest are its arguments, in order. The arguments
    that should be bound are replaced by the specified values. The arguments that
    should remain free are replaced by the placeholders `_1`, `_2`, and so on (not
    necessarily in that order; that is, we can also change the order of the arguments).
    The returned value is of an unspecified type and has to be captured using `auto`.
    The only thing we know about the return value is that it can be called as a function
    with as many arguments as there are placeholders. It can also be used as a function
    in any context that expects a callable, for example, in another `std::bind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, these objects are callables, not functions, and you will discover
    that if you try to assign one of them to a function pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, lambdas can be converted to function pointers if they have no
    captures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As useful as `std::bind` is, it does not free us from the need to learn how
    to write our own function adapters - its greatest limitation is that `std::bind`
    cannot bind template functions. We cannot write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This does not compile. Inside a template, we can bind the specific instantiation
    of it, but, at least in our sorting example, this really does not buy us anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned at the beginning of this section, decorators can be seen as
    a special case of the Adapter pattern. Sometimes, the distinction is not so much
    in a particular application of the pattern but in how we choose to view it.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter or Decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we described the Decorator as a pattern we use to augment an existing
    interface, while the Adapter is used to convert (adapt) an interface for integration
    with code that expects a different interface. The distinction is not always clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let us consider a simple class that adapts the result of the system
    call `std::time` to a printable date format (`std::chrono` provides this functionality,
    but it makes for an easy-to-follow example). The function `std::time` returns
    a value of the type `std::time_t` which is an integer containing the time in seconds
    since some standard moment in the past that is called the “start of the epoch.”
    Another system function, `localtime`, converts this value to a struct that contains
    the date elements: year, month, and day (also hours, minutes, etc). The calendar
    calculations, in general, are rather non-trivial (which is why `std::chrono` is
    not as simple as we might wish) but for now, let us assume that the system library
    does the right thing and all we have to do is print the date in the right format.
    For example, here is how to print the current date in the US format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We want to create an adapter that converts a time in seconds to the date in
    a particular format and lets us print it; we will need separate adapters for the
    US format (month first), European format (day first), and ISO format (year first).
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the adapter is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The other two date formats are similar except for the order in which we print
    the fields. In fact, they are so similar that we may want to refactor the code
    to avoid typing three almost identical classes. The easiest way to do this is
    to use a template and encode the field order in a “format code” which specifies
    the order in which we print the day (field 0), month (field 1), and year (field
    2). For example, “format” 210 means year, then month, then day – the ISO date
    format. The format code can be an integer template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Our little wrapper adapts a type (an integer) to be used in the code that expects
    dates in a particular format. Or does it decorate the integer with the `operator<<()`?
    The best answer is … whichever one is more helpful to you to think about your
    particular problem. It is important to remember the purpose of speaking in the
    language of the patterns in the first place: we do it to have a compact and commonly
    understood way to describe our software problems and the solutions we choose.
    When multiple patterns appear to yield similar results, the description you choose
    lets you focus on the aspect that is most important to you.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have considered only adapters that convert runtime interfaces, which
    are the interfaces we call when the program is executed. However, C++ has compile-time
    interfaces as well - one of the prime examples that we considered in the last
    chapter was policy-based design. These interfaces are not always exactly what
    we need them to be, so we have to learn to write compile-time adapters next.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 16*](B19262_16.xhtml#_idTextAnchor739), *Adapters and Decorators*,
    we learned about policies, which are building blocks for classes - they let the
    programmer customize the implementation for a particular behavior. As an example,
    we can implement this policy-based smart pointer that automatically deletes the
    object it owns. The policy is the particular implementation of the deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the deletion policy is itself a template - this is a *template* parameter.
    The default deletion policy is to use `operator delete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for objects allocated on a user-given heap, we need a different deletion
    policy that returns the memory to that heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have to create a policy object to use with the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This policy is not very flexible, however - it can handle heaps of only one
    type - `MyHeap`. We can make the policy more general if we make the heap type
    the second template parameter. As long as the heap has the `deallocate()` member
    function to return memory to it, we can use any heap class with this policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if we have a heap class that uses another name for this member function,
    we can use a class adapter to make that class work with our policy, too. But we
    have a larger problem - our policy does not work with our smart pointer. The following
    code does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is again the interface mismatch, only now it is a different kind
    of interface – the `template <typename T, template <typename> class DeletionPolicy>
    class SmartPtr {};` template expects the second argument to be a template with
    one type parameter. Instead, we have the `DeleteHeap` template with two type parameters.
    This is just like trying to call a function that has one parameter but uses two
    arguments - it won’t work. We need an adapter to convert our two-parameter template
    into a one-parameter one, and we have to fix the second argument to a particular
    heap type (but we do not need to rewrite the policy if we have multiple heap types,
    we just need to write several adapters). We can create this adapter, `DeleteMyHeap`,
    using inheritance (and remembering to bring the constructors of the base class
    into the derived adapter class scope):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We could do the same using the template alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This first version is, obviously, much longer. However, we have to learn both
    ways of writing template adapters because the template alias has one major limitation.
    To illustrate it, let’s consider another example where an adapter is needed. We
    will begin by implementing a stream insertion operator for any STL-compliant sequence
    container whose elements have such an operator defined. It is a simple function
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This `template` function has two type parameters, the container type and the
    element type. The container is itself a template with one type parameter. The
    compiler deduces both the container type and the element type from the second
    function argument (the first argument in any `operator<<()` is always the stream).
    We can test our insertion operator on a simple container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is just a toy container and is not very useful. What we really want
    is to print elements of a real container, such as `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this code does not compile. The reason is that `std::vector`
    is not really a template with one type parameter, even though we used it as such.
    It has two parameters - the second is the allocator type. There is a default for
    this allocator, which is why we can write `std::vector<int>` and it compiles.
    But, even with this default argument, this is still a template with two parameters,
    while our stream insertion operator is declared to accept container templates
    with only one parameter. Again, we can solve the problem by writing an adapter
    (most STL containers are used with the default allocator anyway). The easiest
    way to write this adapter is with an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this does not compile either, and now we can show the template
    alias limitation that we alluded to earlier - template aliases are not used in
    template argument type deduction. When the compiler attempts to figure out the
    template argument types for the call of `operator<<()` with the arguments `cout`
    and `v`, the template alias `vector1` is *invisible*. In this case, we have to
    use a derived class adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, if you paid attention to the previous chapter, you may realize
    that we already encountered the problem of extra parameters to the template template
    parameters, and solved it by declaring these parameters as variadic templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our `operator<<()` can print any container, so we no longer need to worry
    about adapters, right? Not quite: one of the containers we still cannot print
    is `std::array` which is a class template with one type and one non-type parameter.
    We could declare an overload just to handle this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: But we may have yet another kind of container that does not fit either of these
    templates (whether because it has to or simply because it is part of legacy code
    that was written differently). Then, we have to use an adapter again.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how we can implement decorators to augment class and function
    interfaces with the desired behavior, and how to create adapters when the existing
    interface is not suitable for a particular application. Decorator, and, even more
    so, Adapter, are very general and versatile patterns that can be used to solve
    many problems. It should come as no surprise that, often, a problem can be solved
    in more than one way, so there is a choice of patterns to use. In the next section,
    we will see one such case.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter versus policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter and the policy (or strategy) patterns are some of the more general
    patterns, and C++ adds generic programming capabilities to these patterns. This
    tends to extend their usability and sometimes blurs the lines between the patterns.
    The patterns themselves are defined very distinctly - policies provide custom
    implementations while adapters change the interface and add functionality to the
    existing interface (the latter is a decorator aspect, but, as we have seen, most
    decorators are implemented as adapters). We also saw in the last chapter that
    C++ broadens the capabilities of policy-based design; in particular, policies
    in C++ can add or remove parts of the interface as well as control the implementation.
    So, while patterns are different, there is significant overlap in the types of
    problems they can be used for. It is instructive to compare the two approaches
    when a problem is, broadly speaking, amenable to both. For this exercise, we will
    consider the problem of designing a custom value type.
  prefs: []
  type: TYPE_NORMAL
- en: A value type, to put it simply, is a type that behaves mostly like an `int`.
    Often, these types are numbers. While we have a set of built-in types for that,
    we may want to operate on rational numbers, complex numbers, tensors, matrices,
    or numbers that have units associated with them (meters, grams, and so on). These
    value types support a set of operations such as arithmetic operations, comparisons,
    assignments, and copying. Depending on what the value represents, we may need
    only a limited subset of these operations - for example, we may need to support
    addition and multiplication for matrices, but no division, and comparing matrices
    for anything other than equality probably doesn’t make sense in most cases. Similarly,
    we probably don’t want to allow the addition of meters to grams.
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, there is often a desire to have a numeric type with a limited
    interface - we would like it if the operations that we do not wish to allow for
    the quantity represented by such numbers did not compile. This way, a program
    with an invalid operation simply cannot be written. To be general, our design
    has to allow us to build the interface piece by piece. For example, we may want
    a value that is comparable for equality, ordered (has the less-than operation
    defined), and addable, but without multiplication or division. This seems like
    a problem that is tailor-made for the Decorator (or, more generally, Adapter)
    pattern: decorators can add behaviors like comparison operator or addition operator.
    On the other hand, creating a type with a set of capabilities configured by plugging
    in the right policies is exactly what the Policy pattern is for.'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us examine the Adapter solution first. We will start with a basic value
    type that supports almost nothing in its interface, and then we can add the desired
    capabilities, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our initial `Value` class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `Value` is copyable and assignable, both from the underlying type such as
    `int` and from another `Value`. We could have moved some of those capabilities
    into adapters as well if we wanted to have non-copyable values, but you will find
    this an easy change after making your way through the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, we will also make our Value printable (in any real situation
    you would likely want this to be a separate and configurable capability, but it
    makes the examples simpler without taking anything important away).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the *friend factory*, which was described in [*Chapter 12*](B19262_12.xhtml#_idTextAnchor562),
    *Friend Factory*, to generate these functions. So far, all we can do with our
    Value is to initialize it, maybe assign it to another value, and print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing else we can do with this class - no comparisons for equality
    or inequality, no arithmetic operations. However, we can create an adapter that
    adds the comparison interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This is a class adapter - it is derived from the class it is augmenting with
    new capabilities, so it inherits all of its interface and adds some more - the
    complete set of comparison operators. Note that it is common to use pass-by-value
    instead of reference when dealing with value types (passing by reference to `const`
    isn’t wrong either, and some compilers may optimize either version to the same
    end result).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are familiar with the way these adapters are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'That is one capability. What about some more? No problem - the `Ordered` adapter
    can be written very similarly, only it provides the operators `<`, `<=`, `>`,
    and `>=` (or, in C++20, operator `<=>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine the two adapters - as we say, they are composable, and they
    work in any order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Some operations, or capabilities, require more work. If our value type is numeric,
    such as `Value<int>`, we will want some arithmetic operations like addition and
    multiplication. Here is a decorator that enables addition and subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator is trivial to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also combine `Addable` with other decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'But we have a problem that so far has been hidden only by good luck. We could
    have just as easily written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no difference whatsoever between this example and the previous
    one. Instead, we get a compilation error: there is no valid `operator<` to be
    used in the last line. The problem here is that the `i + j` expression uses the
    `operator+()` that comes from the `Addable` adapter, and this operator returns
    an object of type `Addable<Value<int>>`. The comparison operator expects the type
    `Ordered<Addable<Value<int>>>`, and will not accept the “partial” type (there
    is no implicit conversion from a base class to the derived one). The unsatisfactory
    solution is to require that `Addable` is always the top decorator. Not only it
    just feels wrong, but it also doesn’t get us very far: the next decorator we will
    want is `Multipliable` and it is going to have the same problem. When something
    is both `Addable` and `Multipliable` we can’t have both be on top.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we had no problems with comparison operators returning `bool`, but
    once we have to return the decorated type itself, which is what `operator+()`
    does, the composability breaks down. To solve this problem, every operator that
    returns the decorated type has to return the original (outermost) type. For example,
    if our value type is `Ordered<Addable<Value<int>>>`, the result of adding two
    values should have the same type. The problem, of course, is that `operator+()`
    is provided by the `Addable` decorator which knows only about `Addable` and its
    base classes. We need an intermediate class in the hierarchy (`Addable<...>`)
    to return objects of its derived type (`Ordered<Addable<...>>`). This is a very
    common design problem, and there is a pattern for it: the Curiously Recurring
    Template Pattern, or CRTP (see the eponymous [*Chapter 8*](B19262_08.xhtml#_idTextAnchor360)*,
    The Curiously Recurring Template Pattern*). Applying this pattern to our decorators
    takes some recursive thinking. We will introduce the two main ideas, then we just
    have to wade through a fairly large coding example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, every decorator is going to have two template parameters. The
    first one is the same as before: it is the next decorator in the chain, or `Value<int>`
    at the end of the chain (of course, the pattern is not limited to `int`, but we’re
    simplifying our examples by staying with the same base type throughout). The second
    parameter is going to be the outermost type; we will call it the “final value
    type.” Thus, all of our decorators are going to be declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: But in our code, we still want to write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we need a default value for the second template parameter. This
    value can be any type that we’re not going to use elsewhere in our decorators;
    `void` will do nicely. We will also need a partial template specialization for
    this default type since, if the final value type is not specified explicitly,
    we have to somehow figure out what it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re going to walk through our “nested” type `Ordered<Addable<Value< int>>>`
    step by step. At the outer layer, we can think of it as `Ordered<T>` where `T`
    is `Addable<Value<int>>`. Since we did not specify the second type parameter `FV`
    to the `Ordered` template, we are going to get the default value `void` and the
    template instantiation `Ordered<T>` is going to use the partial specialization
    of the `Ordered` template. Even thought we don’t have the “final value type” `FV`
    specified, we know what that is: it’s `Ordered<T>` itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to figure out the base class to inherit from. Since every decorator
    inherits from the type it decorates, it should be `T` which is `Addable<U>` (where
    `U` is `Value<int>`). But that’s not going to work: we need to pass the correct
    final value type into `Addable`. So we should inherit from `Addable<U, FV>` where
    `FV` is the final value type `Ordered<T>`. Unfortunately, we do not have `Addable<U,
    FV>` written in the code: we have `Addable<U>`. What we need is to somehow figure
    out the type that would have been generated by the same template `Addable` but
    with a different second type argument (`Ordered<T>` instead of the default `void`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very common problem in C++ templates, and it has an equally common
    solution: template rebinding. Every one of our decorator templates needs to define
    the following template alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, given the type `T`, which is an instantiation of one of the decorator
    templates, we can find out the type that would have been produced by the same
    template but with a different second template argument `FV`: it’s `T::template
    rebind<FV>`. That is what our `Ordered<V>` needs to inherit from to pass the correct
    final value type to the next decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This class template says that given a type `Ordered<T, FV>` we are going to
    inherit from the type `T` rebound to the same final value type `FV` and ignore
    the second template argument of `T`. The exception from this is the outermost
    type, where the template parameter `FV` is void but we know what the final value
    type should be, so we can rebind to that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the syntax, with the keyword `template`: some compilers will accept `V::
    rebind<Ordered<V>>` but this is wrong, the standard requires this exact syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can put everything together. In the general case where our decorator
    is somewhere in the middle of the decorator chain, we must pass the final value
    type to the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The type alias `base_t` is introduced for convenience, it makes writing using
    statements easier. Note that we need the `typename` keyword before any type that
    depends on the template parameters; we did not need this keyword to specify the
    base class because the base class is always a type, so writing `typename` would
    be redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The special case of the outermost type where the final value type is not specified
    and defaults to `void` is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The specialization differs from the general case in two ways. In addition to
    the base class, the parameters of the operators cannot be of the type `FV` since
    it is `void`. Instead, we must use the type of the class generated by the template,
    which inside the template definition can be referred to simply as `Ordered` (the
    name of the template, when used inside the class, refers to the specific instantiation
    – you do not need to repeat the template arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'For decorators whose operators return a value, we need to make sure to always
    use the correct final value type for the return type. In the general case, this
    is the second template parameter `FV`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'In the specialization for the outermost decorator, the final value type is
    the decorator itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We must apply this technique to every decorator template. Now we can compose
    the decorators in any order and define value types with any subset of available
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, all of our decorators added member or non-member operators to the class.
    We can also add member functions and even constructors. The latter is useful if
    we want to add a conversion. For example, we can add an implicit conversion from
    the underlying type (as written, `Value<T>` is not implicitly constructible from
    `T`). The conversion decorator follows the same pattern as all the other decorators
    but adds an implicit converting constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use implicit conversions to our value type, for example, when calling
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want an implicit conversion to the underlying type, you can use a very
    similar adapter but instead of the constructor, it adds the conversion operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to do the conversion in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This design gets the job done, there aren’t any particular problems with it,
    other than the complexity of writing the adapters themselves: the recursive application
    of CRTP tends to send your brain into infinite recursion until you get used to
    thinking about this kind of template adapters. The other alternative is a policy-based
    value type.'
  prefs: []
  type: TYPE_NORMAL
- en: Policy solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to look at a somewhat different form of the policy-based design
    compared to what we saw in [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689)*,
    Policy-Based Design*. It is not as general, but when it works, it can provide
    all the advantages of the policies, in particular, the composability, without
    some of the problems. The problem remains the same: create a custom value type
    with a set of operations we can control. This problem can be tackled with the
    standard policy-based approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This implementation runs into the entire set of drawbacks of policy-based design
    - the policy list is long, all policies must be spelled out, and there aren’t
    any good defaults; the policies are positional, so the type declaration requires
    careful counting of commas, and, as the new policies are added, any semblance
    of a meaningful order of policies disappears. Note that we did not mention the
    problem of different sets of policies creating different types - in this case,
    this is not a drawback, but the design intent. If we want a type with support
    for addition and a similar type but without addition, these have to be different
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we would like to just list the policies for the properties we want
    our value to have - I want a value type based on integers that support addition,
    multiplication, and assignment, but nothing else. After all, we did this with
    the Adapter pattern, so we would not settle for anything less now. As it turns
    out, there is a way to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s think of what such a policy might look like. For example, the
    policy that enables addition should inject `operator+()` into the public interface
    of the class (and maybe also `operator+=()`). The policy that makes the value
    assignable should inject `operator=()`. We have seen enough of such policies to
    know how they are implemented - they have to be base classes, publicly inherited,
    and they need to know what the derived class is and cast it to its type, so they
    have to use CRTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to give some thought to the use of these policies in the primary
    template. First of all, we want to support the unknown number of policies, in
    any order. This brings `variadic` templates to mind. However, to use CRTP, the
    template parameters have to be templates themselves. Then, we want to inherit
    from an instantiation of each of these templates, however many there are. What
    we need is a `variadic` template with a template template parameter pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The preceding declaration introduces a class template called `Value`, with at
    least one parameter that is a type, plus zero or more template policies, which
    themselves have two type parameters (in C++17, we can also write `typename ...
    Policies` instead of `class ... Policies`). The `Value` class instantiates these
    templates with the type `T` and itself and inherits publicly from all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Value` class template should contain the interface that we want to be
    common for all our value types. The rest will have to come from policies. Let’s
    make the values copyable, assignable, and printable by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use the *friend factor*y from [*Chapter 12*](B19262_12.xhtml#_idTextAnchor562)*,
    Friend Factory,* to generate the stream operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can indulge ourselves in implementing all of the policies, there
    is one more hurdle to overcome. The `val_` value is private in the `Value` class,
    and we like it this way. However, the policies need to access and modify it. In
    the past, we solved this problem by making each policy that needed such access
    into a friend. This time, we don’t even know the names of the policies we may
    have. After working through the preceding declaration of the parameter pack expansion
    as a set of base classes, the reader may reasonably expect us to pull a rabbit
    out of the hat and somehow declare friendship to the entire parameter pack. Unfortunately,
    the standard offers no such way. The best solution we can suggest is to provide
    a set of accessor functions that should be called only by the policies, but there
    is no good way to enforce that (a name, such as `policy_accessor_do_not_call()`,
    might go some way to suggest that the user code should stay away from it, but
    the ingenuity of the programmer knows no bounds, and such hints are not universally
    respected):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a value type with a restricted set of operations, we have to instantiate
    this template with a list of policies we want, and nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The number and the type of policies we can implement are limited mostly by the
    need at hand (or imagination), but here are some examples that demonstrate adding
    different kinds of operations to the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we can implement the aforementioned `Incrementable` policy that
    provides the two `++` operators, postfix and prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make a separate `Decrementable` policy for the `--` operators, or have
    one policy for both if it makes sense for our type. Also, if want to increment
    by some value other than one, then we need the `+=` operators as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The preceding policy provides two versions of `operator+=()` - one accepts the
    increment of the same `Value` type, and the other of the foundation type `T`.
    This is not a requirement, and we could implement an increment by values of some
    other types as needed. We can even have several versions of the increment policy,
    as long as only one is used (the compiler would let us know if we were introducing
    incompatible overloads of the same operator).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the operators `*=` and `/=` in a similar manner. Adding binary operators
    such as comparison operators or addition and multiplication is a little different
    - these operators have to be non-member functions to allow for type conversions
    on the first argument. Again, the friend factory pattern comes in handy. Let’s
    start with the comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'When instantiated, this template generates two non-member non-template functions,
    that is, the comparison operators for variables of the type of the specific `Value`
    class, the one that is instantiated. We may also want to allow comparisons with
    the foundation type (such as `int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'More often than not, we will likely want both types of comparison at the same
    time. We could simply put them both into the same policy and not worry about separating
    them, or we could create a combined policy from the two we already have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous section, we combined all comparisons in a single adapter from
    the beginning. Here, we use a slightly different approach just to illustrate different
    options for controlling class interfaces with policies or adapters (both solutions
    offer the same options). The addition and multiplication operators are created
    by similar policies. They are also friend non-template non-member functions. The
    only difference is the return value type - they return the object itself, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the problem of returning the “final value type” that we struggled
    with while writing adapters does not exist here: the derived class that is passed
    into each policy is the value type itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit or implicit conversion operators for conversions to the base type
    can be added just as easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This approach, at first glance, seems to solve most of the drawbacks of the
    traditional policy-based types. The order of the policies does not matter - we
    can specify only the ones we want and not worry about the other ones - what’s
    not to like? There are, however, two fundamental limitations. First of all, the
    policy-based class cannot refer to any policy by name. There is no longer a slot
    for `DeletionPolicy` or `AdditionPolicy`. There are no convention-enforced policy
    interfaces, such as the deletion policy having to be callable. The entire process
    of binding the policies into a single type is implicit; it’s just a superposition
    of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we are limited in what we can do using these policies - we can inject
    public member functions and non-member functions - even add private data members
    - but we cannot provide an implementation for an aspect of behavior that’s determined
    and limited by the primary policy-based class. As such, this is not an implementation
    of the Strategy pattern - we are composing the interface, and, perforce, the implementation,
    at will, not customizing a specific algorithm (which is why we deferred the demonstration
    of this alternative policy-based design pattern until this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The second, closely related, limitation is that there are no default policies.
    The missing policies are just that, missing. There is nothing in their place.
    The default behavior is always the absence of any behavior. In the traditional
    policy-based design, each policy slot has to be filled. If there is a reasonable
    default, it can be specified, and then that is the policy unless the user overrides
    it (for example, the default deletion policy uses `operator delete`). If there
    is no default, the compiler won’t let us omit the policy - we have to give an
    argument to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The consequences of these limitations reach farther than you may think at first
    glance. For example, it may be tempting to use the `enable_if` technique we saw
    in [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689)*, Policy-Based Design,* instead
    of injecting public member functions through the base class. Then, we could have
    a default behavior that is enabled if none of the other options are. But it won’t
    work here. We can certainly create a policy that is targeted for use with `enable_if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: But there is no way to use it - we can’t use `AdditionPolicy::adding_enabled`
    because there is no `AdditionPolicy` - all policy slots are unnamed. The other
    option would be to use `Value::adding_enabled` - the addition policy is a base
    class of `Value`, and, therefore, all of its data members are visible in the `Value`
    class. The only problem is that it does not work - at the point where this expression
    is evaluated by the compiler (in the definition of the `Value` type as the template
    parameter for the CRTP policies), `Value` is an incomplete type and we cannot
    access its data members yet. We could evaluate `policy_name::adding_enabled` if
    we knew what the policy name was. But that knowledge is exactly what we gave up
    in trade for not having to specify the entire list of policies.
  prefs: []
  type: TYPE_NORMAL
- en: While not, strictly speaking, an application of the Strategy pattern, the alternative
    to the policy-based design that we have just learned about can be attractive when
    the policies are primarily used to control a set of supported operations. While
    discussing the guidelines for policy-based design, we have mentioned that it is
    rarely worth it to use a policy slot just to provide the additional safety of
    the restricted interface. For such situations, this alternative approach should
    be kept in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, we can see that both patterns have their advantages and drawbacks:
    adapters rely on a more complex form of CRTP while the “slot-less” policies we
    just saw require us to compromise the encapsulation (we have to expose the value
    to the policies using something like our `get()` methods).'
  prefs: []
  type: TYPE_NORMAL
- en: Such is the nature of the problems we have to solve as software engineers -
    once a problem becomes complex enough, it can be solved, frequently using more
    than one design, and each approach has its own advantages and limitations. There
    is no way we can compare every two patterns that can be used to create two very
    different designs that address the same need, at least not in a book of any finite
    size. By presenting and analyzing these examples, we hope to equip the reader
    with the understanding and insight that will be helpful in evaluating similarly
    complex and varied design options for real-life problems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have studied two of the most commonly used patterns - not just in C++, but
    in software design in general. The Adapter pattern offers an approach to solving
    a wide class of design challenges. These challenges have only the most general
    property in common - given a class, a function, or a software component that provides
    certain functionality, we must solve a particular problem, and build a solution
    for a different, related problem. The decorator pattern is, in many ways, a subset
    of the Adapter pattern, which is restricted to augmenting the existing interface
    of the class of a function with new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that the interface conversion and modification done by the adapters
    and decorators can be applied to interfaces at every stage of the program’s life
    - while the most common use is to modify runtime interfaces so that a class can
    be used in a different context, there are also compile-time adapters for generic
    code that allow us to use a class as a building block or a component of a larger,
    more complex, class.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern can be applied to many very different design challenges.
    The varied nature of these challenges and the generality of the pattern itself
    often mean that an alternative solution is possible. Such alternatives often use
    a completely different approach - an entirely different design pattern - but end
    up providing similar behavior. The difference lies in trade-offs, additional conditions,
    and limitations imposed by the chosen approach to the design, and the possibilities
    of extending the solution in different ways. To this end, this chapter offers
    a comparison of two very different design approaches to the same problem, complete
    with an evaluation of the strengths and drawbacks of both options.
  prefs: []
  type: TYPE_NORMAL
- en: The next, penultimate, chapter introduces a pattern that is large, complex,
    and has several interacting components - an appropriate pattern to be left for
    our grand finale - the Visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the Adapter pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the decorator pattern and how does it differ from the Adapter pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The classic OOP implementation of the decorator pattern is usually not recommended
    in C++. Why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should the C++ class decorator use inheritance or composition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should the C++ class adapter use inheritance or composition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C++ provides a general function adapter for currying function arguments, `std::bind`.
    What are its limitations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C++11 provides template aliases that can be used as adapters. What are their
    limitations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the adapter and policy patterns can be used to add or modify the public
    interface of a class. Give some reasons for preferring one over the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
