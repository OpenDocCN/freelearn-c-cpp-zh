- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Adapters and Decorators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器和装饰者
- en: This chapter takes on two classic patterns in **object-oriented programming**
    (**OOP**) - the Adapter pattern and the decorator pattern. These patterns are
    just two of the original twenty-three design patterns that were introduced in
    the *Design Patterns – Elements of Reusable Object-Oriented Software* book by
    Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. As an object-oriented
    language, C++ can take advantage of these patterns as well as any other language.
    But, as is often the case, generic programming brings some advantages, variations,
    and, with it, new challenges to the classic patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了面向对象编程（**OOP**）中的两个经典模式——适配器模式和装饰者模式。这些模式只是Erich Gamma、Richard Helm、Ralph
    Johnson和John Vlissides在《设计模式——可重用面向对象软件元素》一书中介绍的二十三个原始设计模式中的两个。作为一个面向对象的语言，C++可以利用这些模式，就像任何其他语言一样。但是，正如通常情况那样，泛型编程为经典模式带来了某些优势、变化，以及随之而来的新挑战。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了以下主题：
- en: What are the adapter and decorator patterns?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器和装饰者模式是什么？
- en: What is the difference between the two?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者之间的区别是什么？
- en: What design problems can be solved by these patterns?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些模式可以解决哪些设计问题？
- en: How are these patterns used in C++?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些模式如何在C++中使用？
- en: How does generic programming help to design adapters and decorators?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型编程如何帮助设计适配器和装饰者？
- en: What other, different, patterns offer alternative solutions to similar problems?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他不同模式如何提供类似问题的替代解决方案？
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example code for this chapter can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在以下GitHub链接中找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16)。
- en: The decorator pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: We will begin this study with the definitions of the two classic patterns. As
    we will see, on paper, the patterns, as well as the differences between them,
    are quite clear. Then, C++ comes in and blurs the lines by allowing design solutions
    that fall somewhere in-between the two. Still, the clarity of these simple cases
    is helpful, even if it gets muddled as we pile on the complexity. Let’s start
    with what is clear, then.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个研究开始，先定义这两个经典模式。正如我们将看到的，在纸上，模式以及它们之间的区别非常清晰。然后，C++介入，通过允许介于两者之间的设计解决方案来模糊界限。尽管如此，这些简单案例的清晰性仍然是有帮助的，即使在我们增加复杂性时它可能会变得混乱。让我们从清晰的地方开始。
- en: The decorator pattern is also a structural pattern; it allows a behavior to
    be added to an object. The classic decorator pattern extends the behavior of an
    existing operation that’s performed by a class. It *decorates* the class with
    the new behavior and creates an object of the new, decorated type. The decorator
    implements the interface of the original class and forwards the requests from
    its own interface to that class, but it also performs additional actions before
    and after these forwarded requests - these are the *decorations.* Such decorators
    are sometimes called “class wrappers”.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式也是一种结构型模式；它允许向对象添加行为。经典的装饰者模式扩展了由一个类执行的操作的行为。它通过添加新的行为来**装饰**这个类，并创建了一个新装饰类型的对象。装饰者实现了原始类的接口，并将请求从其接口转发到那个类，但它还执行了在转发请求之前和之后的一些额外操作——这些就是**装饰**。这种装饰者有时被称为“类包装器”。
- en: Basic decorator pattern
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本装饰者模式
- en: 'We will begin with a C++ example of the decorator pattern that follows the
    classic definition as closely as possible. For this example, we will imagine designing
    a fantasy game that’s set in medieval times (true to life, only with dragons and
    elves and so on). Of course, what are medieval times without fighting? And so,
    in our game, the player has a choice of units appropriate for his/her side, and
    they can do battle when called on. Here is the basic `Unit` class - at least the
    combat-related part:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个尽可能接近经典定义的C++装饰者模式示例开始。为此示例，我们将设想设计一个设定在中世纪时期的幻想游戏（真实生活，只是有龙和精灵等等）。当然，没有战斗的中世纪时代是什么样的？因此，在我们的游戏中，玩家可以选择适合他/她的单位，并在被召唤时进行战斗。以下是基本的`Unit`类——至少是战斗相关的部分：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The unit has `strength`, which determines its attack, and `armor`, which provides
    defense. The actual values of the attack and the defense are computed by the derived
    classes - the concrete units - but the combat mechanism itself is right here -
    if the attack is stronger than the defense, the unit successfully hits the target
    (this is a very simplistic approach to gaming, of course, but we want to make
    the examples as concise as possible).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单位有`strength`属性，它决定了其攻击力，以及`armor`属性，它提供防御。攻击和防御的实际值由派生类——具体的单位——计算，但战斗机制本身就在这里——如果攻击力强于防御力，单位就成功地击中了目标（当然，这是一个非常简化的游戏方法，但我们想使示例尽可能简洁）。
- en: 'Now, what are the actual units in the game? The pillar of the human armies
    is the valorous `Knight`. This unit has strong armor and a sharp sword, giving
    it bonuses to both attack and defend:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，游戏中实际有哪些单位？人类军队的支柱是英勇的`Knight`。这个单位拥有坚固的盔甲和锋利的剑，使它在攻击和防御上都获得加成：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Fighting against the knights are the brutish ogres. The ogres swing simple
    wooden clubs and wear ragged leather, neither of which are great implements of
    war, giving them some combat penalties:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与骑士战斗的是粗鲁的巨魔。巨魔挥舞着简单的木棍，穿着破旧的皮革，这两者都不是很好的战争工具，给它们带来了一些战斗上的惩罚：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the other hand, ogres are remarkably strong, to begin with:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，巨魔一开始就非常强壮：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here the knight, aided by his attack bonus and the enemy’s weak armor, will
    successfully hit the ogre. But the game is far from over. As the units fight,
    the surviving ones gain experience and eventually become veterans. A veteran unit
    is still the same kind of unit, but it gains attack and defense bonuses, reflecting
    its combat experience. Here, we do not want to change any of the class interfaces,
    but we want to modify the behavior of the `attack()` and `defense()` functions.
    This is the job of the decorator pattern, and what follows is the classic implementation
    of the `VeteranUnit` decorator:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，骑士凭借他的攻击加成和敌人的薄弱盔甲，成功地击中了巨魔。但游戏远未结束。随着单位的战斗，幸存者获得经验，最终成为老兵。老兵单位仍然是同一种单位，但它获得了攻击和防御加成，反映了它的战斗经验。在这里，我们不想改变任何类接口，但想修改`attack()`和`defense()`函数的行为。这就是装饰者模式的工作，以下是对`VeteranUnit`装饰者的经典实现：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that this class inherits directly from the `Unit` class, so in the class
    hierarchy, it is *to the side* of concrete unit classes such as `Knight` or `Ogre`.
    We still have the original unit that is decorated and becomes the veteran - the
    `VeteranUnit` decorator contains a reference to it. The way it is used, then,
    is to decorate a unit and use the decorated unit from then on, but it does not
    delete the original unit:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类直接从`Unit`类继承，所以在类层次结构中，它位于具体单位类（如`Knight`或`Ogre`）的旁边。我们仍然有原始单位，它被装饰并成为老兵——`VeteranUnit`装饰者包含对其的引用。它的使用方式是装饰一个单位，然后继续使用装饰过的单位，但它不会删除原始单位：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, both our old enemies reached their first veterancy levels, and the victory
    again goes to the knight. But experience is the best teacher, and our ogre gains
    another level, and, with it, enchanted runic armor with a massive defense bonus:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们两个老对手都达到了他们的第一个军衔等级，胜利再次属于骑士。但经验是最好的老师，我们的巨魔又提升了一个等级，并且，随着它，附有巨大防御加成的魔法符文盔甲：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we can decorate a decorated object in this design! This is intentional,
    and the bonuses stack up as the unit gains levels. This time, the experienced
    fighter’s defense proves to be too much for the knight.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个设计中，我们可以装饰一个装饰过的对象！这是故意的，并且随着单位等级的提升，加成会叠加。这次，经验丰富的战士的防御力证明对骑士来说太过强大。
- en: As we already mentioned, this is the classic decorator pattern, straight out
    of the textbook. It works in C++ but with some limitations. The first one is rather
    evident even though we want to use the decorated unit once we have it, the original
    unit must be kept around, and the lifetimes of these objects must be carefully
    managed. There are practical solutions to such practical problems, but the focus
    of this book is on combining design patterns with generic programming, and the
    new design possibilities that pairing creates. Therefore, our creative path takes
    us elsewhere.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这是一个经典的装饰者模式，直接来自教科书。它在C++中工作，但有一些限制。第一个限制相当明显，即使我们一旦拥有装饰过的单位，原始单位也必须保留，并且这些对象的生命周期必须仔细管理。对于这样的实际问题，有实际的解决方案，但本书的重点是结合设计模式和泛型编程，以及这种配对创造的新设计可能性。因此，我们的创新之路将带我们走向其他地方。
- en: 'The second problem is more endemic to C++. It is best illustrated by an example.
    The game’s designers have added a special ability to the `Knight` unit - it can
    charge forward at its enemy, gaining a short-term attack bonus. This bonus is
    valid only for the next attack, but in the thick of the battle, it may be just
    enough:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题在C++中更为普遍。最好通过一个例子来说明。游戏的设计师为`Knight`单位添加了特殊能力——它可以向前冲锋攻击敌人，获得短期的攻击加成。这个加成只对下一次攻击有效，但在激烈的战斗中，这也许正是所需要的：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The charge bonus is activated by calling the `charge()` member function and
    lasts for one attack, and then it is reset. When the player activates the charge,
    the game executes the code, which looks something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 充能加成是通过调用`charge()`成员函数激活的，持续一次攻击，然后重置。当玩家激活充能时，游戏执行以下代码：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Of course, we would expect the veteran knight to be able to charge forward
    as well, but here we run into a problem - our code does not compile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们期望老兵骑士也能向前冲锋，但在这里我们遇到了问题——我们的代码无法编译：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The root of the problem is that `charge()` is a part of the interface of the
    `Knight` class, while the `VeteranUnit` decorator is derived from the `Unit` class.
    We could move the `charge()` function into the base class, `Unit`, but this is
    a bad design - `Ogre` is also derived from `Unit`, and ogres cannot charge, so
    they should not have such an interface (it violates the *is-a* principle of public
    inheritance).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的根源在于`charge()`方法是`Knight`类接口的一部分，而`VeteranUnit`装饰器是从`Unit`类派生出来的。我们可以将`charge()`函数移动到基类`Unit`中，但这是一种糟糕的设计——`Ogre`也是从`Unit`派生出来的，而哥布林不能冲锋，因此它们不应该有这样的接口（这违反了公共继承的*is-a*原则）。
- en: This is a problem that’s inherent in the way we implemented the decorator object
    - both `Knight` and `VeteranUnit` are derived from the same base class, `Unit`,
    but they don’t know anything about each other. There are some ugly workarounds,
    but it is a fundamental C++ limitation; it does not handle *cross-casting* well
    (casting to a type in another branch of the same hierarchy). But what the language
    takes with one hand, it gives with the other - we have much better tools to deal
    with this problem, and we are going to learn about these tools next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个固存在于我们实现装饰器对象的方式中的问题——`Knight`和`VeteranUnit`都从同一个基类`Unit`派生，但它们对彼此一无所知。有一些丑陋的解决方案，但这是一种基本的C++限制；它处理*交叉转换*（在相同层次结构的另一分支中转换类型）不佳。但语言一手拿走，另一手又给予——我们有许多更好的工具来处理这个问题，我们将在下一章学习这些工具。
- en: Decorators the C++ way
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++风格的装饰器
- en: 'We have encountered two problems while implementing a classic decorator in
    C++ - first of all, the decorated object did not take ownership of the original
    object, so both must be kept around (this may not be so much a problem as a feature
    if the decoration needs to be removed later, which is one of the reasons the decorator
    pattern is implemented this way). The other problem is that a decorated `Knight`
    is not really a `Knight` at all, but a `Unit`. We can solve the second problem
    if the decorator is itself derived from the class that is being decorated. This
    would imply that the `VeteranUnit` class does not have a fixed base class - the
    base class should be whatever class is being decorated. This description matches
    the **Curiously Recurring Template Pattern** (**CRTP**) to a tee (this C++ idiom
    was described earlier in this book in [*Chapter 8*](B19262_08.xhtml#_idTextAnchor360)*,
    The Curiously Recurring Template Pattern*). To apply CRTP, we need to make the
    decorator into a template and inherit from the template parameter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现C++中的经典装饰器时，我们遇到了两个问题——首先，装饰对象没有接管原始对象的所有权，因此两者都必须保留（如果装饰需要稍后移除，这可能不是问题，而是特性之一，这也是装饰器模式以这种方式实现的原因之一）。另一个问题是，装饰后的`Knight`根本不是`Knight`，而是`Unit`。如果装饰器本身是从被装饰的类派生出来的，我们就可以解决第二个问题。这意味着`VeteranUnit`类没有固定的基类——基类应该是被装饰的任何类。这种描述与**Curiously
    Recurring Template Pattern**（**CRTP**）完全吻合（这种C++习语在本书的[*第8章*](B19262_08.xhtml#_idTextAnchor360)中已有描述，即《Curiously
    Recurring Template Pattern》）。要应用CRTP，我们需要将装饰器做成模板，并从模板参数继承：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, to promote a unit to the veteran status, we must convert it to the decorated
    version of the concrete `unit` class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将一个单位提升为老兵状态，我们必须将其转换为混凝土`unit`类的装饰版本：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the same scenario that we saw at the end of the previous section, but
    it now uses the template decorator. Notice the differences. First of all, a `VeteranUnit`
    is a class that’s derived from a concrete unit such as `Knight` or `Ogre`. As
    such, it has access to the interface of the base class: for example, a veteran
    knight, `VeteranUnit<Knight>`, is a `Knight` too and has the member function `charge()`
    inherited from `Knight`. Second, the decorated unit explicitly takes ownership
    of the original unit - to create a veteran unit, we have to move the original
    unit into it (the base class of the veteran unit is move-constructed from the
    original unit). The original object is left in the unspecified moved-from state,
    and the only safe action that can be done on this object is a call to the destructor.
    Note that, at least for the simple implementation of unit classes, the `move`
    operation is just a copy, so the original object is usable, but you should not
    rely on it - making assumptions about the moved-from state is a bug waiting to
    happen.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前章节结尾处看到的相同场景，但现在它使用了模板装饰器。注意其中的差异。首先，`VeteranUnit`是一个从像`Knight`或`Ogre`这样的具体单位派生出来的类。因此，它能够访问基类的接口：例如，一个老兵骑士`VeteranUnit<Knight>`也是一个`Knight`，并且拥有从`Knight`继承来的成员函数`charge()`。其次，装饰过的单位明确地接管了原始单位的所有权——为了创建一个老兵单位，我们必须将原始单位移动到其中（老兵单位的基类是通过原始单位移动构造的）。原始对象被留在未指定的移动后状态，对这个对象唯一安全的操作是调用析构函数。请注意，至少对于单位类的简单实现，`move`操作只是一个复制，所以原始对象仍然是可用的，但你不应依赖于它——对移动后状态做出假设是一个即将发生的错误。
- en: 'It is worth pointing out that our declaration of the `VeteranUnit` constructor
    enforces and requires this ownership transfer. If we try to construct a veteran
    unit without moving from the original unit, it will not compile:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，我们对于`VeteranUnit`构造函数的声明强制并要求这种所有权的转移。如果我们试图在不从原始单位移动的情况下构建一个老兵单位，它将无法编译：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By providing only one constructor that accepts an r-value reference, that is,
    `Unit&&`, we require that the caller agrees to the transfer of ownership.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过只提供一个接受右值引用的构造函数，即`Unit&&`，我们要求调用者同意所有权的转移。
- en: So far, for demonstration purposes, we have created all unit objects on the
    stack as local variables. In any non-trivial program, this is not going to work
    - we need these objects to stay around, long after the function that created them
    is done. We can integrate decorator objects and the memory ownership mechanism
    and ensure that the moved-from original units are deleted after a decorated version
    is created.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，为了演示目的，我们已经在栈上作为局部变量创建了所有单位对象。在任何非平凡程序中，这都不会起作用——我们需要这些对象在创建它们的函数完成之后还能存在。我们可以集成装饰器对象和内存所有权机制，并确保在创建装饰版本之后删除移动后的原始单位。
- en: 'Let’s say that ownership is managed throughout the program by unique pointers
    (each object has a clear owner at any given time). Here is how this can be accomplished.
    First of all, it is convenient to declare aliases for the pointers we need to
    use:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在整个程序中通过唯一指针（在任何给定时间每个对象都有一个明确的拥有者）来管理所有权。以下是实现方法。首先，为我们需要使用的指针声明别名是方便的：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While any unit can be owned by the `Unit_ptr` pointer, we cannot call unit-specific
    member functions such as `charge()` through it, so we may need pointers to the
    concrete classes as well. As we will see next, we need to move the object between
    these pointers. Moving from a pointer to the derived class to the pointer to the
    base class is easy:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何单位都可以被`Unit_ptr`指针拥有，但我们不能通过它调用特定的单位成员函数，例如`charge()`，因此我们可能还需要指向具体类的指针。正如我们接下来将要看到的，我们需要在这些指针之间移动对象。从派生类指针移动到基类指针是很容易的：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Going in the other direction is a little harder; `std::move` will not work
    implicitly, just like we cannot convert from `Unit*` to `Knight*` without an explicit
    cast. We need a *moving cast*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 反方向的操作要困难一些；`std::move`不会隐式地工作，就像我们不能在没有显式转换的情况下从`Unit*`转换为`Knight*`一样。我们需要一个*移动转换*：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we use `static_cast` to cast to the derived class, which works if the
    assumed relation (that the base object really is the expected derived object)
    is correct, otherwise, the results are undefined. We can test this assumption
    at runtime if we want to, using `dynamic_cast` instead. Here is a version that
    does the test, but only if asserts are enabled (we could throw an exception instead
    of the assert):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`static_cast`将类型转换为派生类，如果假设的关系（即基对象确实是预期的派生对象）是正确的，那么这将是有效的，否则结果是不确定的。如果我们想，我们可以在运行时测试这个假设，使用`dynamic_cast`代替。这里是一个进行测试的版本，但仅当断言被启用时（我们可以抛出一个异常而不是断言）：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If all objects will be owned by instances of a unique pointer, then the `VeteranUnit`
    decorator has to accept a pointer in its constructor and move the object out of
    this pointer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有对象都将由唯一指针的实例拥有，那么`VeteranUnit`装饰器必须在构造函数中接受一个指针并将对象从这个指针中移动出来：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The tricky part here is in the initialization of the base class `U` of `VeteranUnit<U>`
    - we have to move the unit from a unique pointer to the base class into a move-constructor
    of the derived class (there is no way to simply move the object from one unique
    pointer to another; we need to wrap it into the derived class). We have to do
    this without leaking any memory, too. The original, unique pointer, is released,
    so its destructor will do nothing, but our `move_cast` returns a new unique pointer
    that now owns the same object. This unique pointer is a temporary variable and
    will be deleted at the end of the initialization of the new object, but not before
    we use its object to construct a new derived object that is a `VeteranUnit` (the
    move-initialization of the unit object itself does not save any time versus copy
    in our case, but it is a good practice in the event a more heavyweight unit object
    provides an optimized move constructor).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里棘手的部分在于`VeteranUnit<U>`的基类`U`的初始化——我们必须将单元从唯一指针移动到基类，然后将其移动到派生类的移动构造函数中（没有简单地将对象从一个唯一指针移动到另一个唯一指针的方法；我们需要将其包装到派生类中）。我们还要确保不泄漏任何内存。原始的唯一指针被释放，因此它的析构函数将不会做任何事情，但我们的`move_cast`返回一个新的唯一指针，现在它拥有相同的对象。这个唯一指针是一个临时变量，将在新对象初始化结束时被删除，但在我们使用它的对象来构造一个新的派生对象（即`VeteranUnit`）之前不会删除。单元对象的移动初始化本身在我们的情况下与复制相比没有节省任何时间，但这是一个良好的实践，以防更重的单元对象提供了一个优化的移动构造函数。
- en: 'Here is how this new decorator is used in a program that manages resources
    (units, in our case) by unique pointers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在管理资源（在我们的例子中是单元）的程序中使用这个新装饰器的示例：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we did not redefine the `hit()` function - it still accepts a unit
    object by reference. This is correct because this function does not take ownership
    of the object - it merely operates on it. There is no need to pass an owning pointer
    into it - that would suggest a transfer of ownership.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有重新定义`hit()`函数——它仍然通过引用接受一个单元对象。这是正确的，因为这个函数不拥有对象——它只是对其操作。没有必要向其中传递拥有指针——这会暗示所有权的转移。
- en: Note that, strictly speaking, there is very little difference between this example
    and the last one - the moved-from unit should not be accessed either way. Practically
    speaking, there is a significant difference - the moved-from pointer no longer
    owns the object. Its value is null, so any attempt to operate on the original
    unit after it was promoted will become evident in very short order (the program
    will dereference a null pointer and crash).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，严格来说，这个例子和上一个例子之间几乎没有区别——被移动的单元无论如何都不应该被访问。从实际的角度来看，存在显著的差异——被移动的指针不再拥有对象。它的值是空值，因此，在对象被提升之后尝试对其原始单元进行操作将很快变得明显（程序将解引用空指针并崩溃）。
- en: As we have seen, we can decorate an already decorated class, as the effects
    of the decorators stack up. Similarly, we can apply two different decorators to
    the same class. Each decorator adds a particular new behavior to the class. In
    our game engine, we can print the results of each attack, whether or not there
    was a hit. But if the result does not match the expectations, we don’t know why.
    For debugging, it might be useful to print the attack and defense values. We would
    not want to do this all the time for all units, but for the part of the code we
    are interested in, we could use a debugging decorator that adds new behavior to
    the units to print the intermediate results of the calculations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们可以装饰已经装饰过的类，因为装饰器的作用是累积的。同样，我们可以将两个不同的装饰器应用于同一个类。每个装饰器都为该类添加了特定的新行为。在我们的游戏引擎中，我们可以打印每次攻击的结果，无论是否命中。但如果结果不符合预期，我们不知道原因。为了调试，打印攻击和防御值可能很有用。我们不想对所有单位都这样做，但对我们感兴趣的代码部分，我们可以使用一个调试装饰器，该装饰器为单位添加新行为以打印计算的中间结果。
- en: 'The `DebugDecorator` uses the same design idea as the previous decorator -
    it’s a class template that generates a class that’s derived from the object to
    be decorated. Its `attack()` and `defense()` virtual functions forward the calls
    to the base class and print the results:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebugDecorator`使用与之前装饰器相同的设计理念——它是一个类模板，生成一个从要装饰的对象派生的类。它的`attack()`和`defense()`虚拟函数将调用转发到基类并打印结果：'
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we left out the dynamic memory allocations and relied on moving
    the objects themselves for ownership transfer. There is no reason we cannot have
    both stackable decorators and unique pointers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们省略了动态内存分配，并依赖于移动对象本身来实现所有权的转移。我们没有理由不能同时拥有可堆叠的装饰器和唯一指针：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When implementing decorators, you should be careful to not inadvertently change
    the behavior of the base class in unexpected ways. For example, consider this
    possible implementation of `DebugDecorator`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现装饰器时，你应该小心不要意外地以意想不到的方式改变基类的行为。例如，考虑`DebugDecorator`的这种可能实现：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is a subtle bug here - the decorated object, in addition to the expected
    new behavior - the printout - hides a change in the original behavior - it calls
    `attack()` twice on the base class. Not only might the printed value be incorrect
    if two calls to `attack()` return different values, but also any one-time attack
    bonuses such as the knight’s charge will be canceled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个微妙的错误——装饰后的对象，除了预期的打印输出之外，还隐藏了对原始行为的一个变化——它在基类上调用`attack()`两次。如果两次调用`attack()`返回不同的值，打印的值可能是不正确的，而且任何一次性攻击加成，如骑士冲锋，也将被取消。
- en: '`DebugDecorator` adds very similar behavior to each member function it decorates.
    C++ has a rich set of tools that are aimed specifically at improving code reuse
    and reducing duplication. Let’s see if we can do better and come up with a more
    reusable, universal decorator.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebugDecorator`为它装饰的每个成员函数添加了非常相似的行为。C++有一套丰富的工具，旨在专门提高代码重用和减少重复。让我们看看我们是否能做得更好，并提出一个更可重用、更通用的装饰器。'
- en: Polymorphic decorators and their limitations
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态装饰器和它们的局限性
- en: Some decorators are very specific to the classes they modify, and their behavior
    is narrowly targeted. Others are very general, at least in principle. For example,
    a debugging decorator that logs function calls and prints return values could
    be used with any function if we could only implement it correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些装饰器非常特定于它们所修改的类，其行为是精确针对的。而另一些则非常通用，至少在原则上如此。例如，一个记录函数调用并打印返回值的调试装饰器，如果能够正确实现，可以与任何函数一起使用。
- en: 'Such an implementation is pretty straightforward in C++14 or above using `variadic`
    templates, parameter packs, and perfect forwarding:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++14或更高版本的`variadic`模板、参数包和完美前向，这样的实现相当直接：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This decorator can be wrapped around any callable object or function (anything
    that can be called with the `()` syntax) with any number of arguments. It prints
    the custom string and the result of the call. However, writing out the callable
    type is often tricky - it is much better to get the compiler to do it for us using
    template argument deduction:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器可以围绕任何可调用对象或函数（任何可以用`()`语法调用的东西）包装，无论有多少个参数。它打印自定义字符串和调用结果。然而，写出可调用类型通常是棘手的——最好让编译器为我们完成这项工作，使用模板参数推导：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This template function deduces the type of the `Callable` and decorates it
    with the debugging wrapper. We can now apply it to any function or object. Here
    is a decorated function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板函数推断出`Callable`的类型，并用调试包装器对其进行装饰。现在我们可以将其应用于任何函数或对象。下面是一个装饰后的函数示例：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also decorate a callable object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以装饰一个可调用对象：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that our decorator does not take ownership of the callable object (we could
    write it in such a way that it does so if we wanted to).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的装饰器不会接管可调用对象的所有权（如果我们想这样做，可以写成那样）。
- en: 'We can even decorate a lambda expression, which is really just an implicitly
    typed callable object. The one in this example defines a callable object with
    two integer arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以装饰一个lambda表达式，这实际上只是一个隐式类型的可调用对象。这个例子中的lambda定义了一个具有两个整数参数的可调用对象：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our example, we decided to forward the callables both in the decorator class
    constructor and in the helper function. Often, the callables are passed by value
    instead and are assumed to be cheap to copy. In all cases, it is important that
    the decorator stores a copy of the callable in its data member. If you capture
    it by reference instead, there is a subtle error waiting to happen:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们决定在装饰器类构造函数和辅助函数中都将可调用对象进行转发。通常，可调用对象是通过值传递的，并且假设它们易于复制。在所有情况下，装饰器存储其数据成员中的可调用对象的副本都很重要。如果你通过引用捕获它，那么一个微妙的错误正在等待发生：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Decorating a function is likely to work fine, but decorating a lambda will
    fail (although not necessarily in an immediately visible way). The `const Callable&
    c_` member is going to be bound to a temporary lambda object:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰一个函数很可能会正常工作，但装饰一个lambda表达式可能会失败（尽管不一定立即显现）。`const Callable& c_` 成员将被绑定到一个临时的lambda对象上：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The lifetime of this object ends at the semicolon at the end of this statement,
    and any subsequent use of `f2` accesses a dangling reference (address sanitizer
    tools can help detect such errors).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的生存期在语句末尾的分号处结束，任何随后的`f2`使用都会访问一个悬垂引用（地址检查工具可以帮助检测此类错误）。
- en: 'Our decorator has some limitations. First, it falls short when we try to decorate
    a function that does not return anything, such as the following lambda expression,
    which increments its argument but returns nothing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的装饰器有一些局限性。首先，当我们尝试装饰一个不返回任何内容的功能时，它就不够用了，比如下面的lambda表达式，它增加其参数但不返回任何内容：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The problem lies with the `void res` expression that is coming from the `auto
    res = ...` line inside the `DebugDecorator`. This makes sense since we cannot
    declare variables of the `void` type. This problem can be solved using `if constexpr`
    in C++17:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在`DebugDecorator`内部`auto res = ...`行的`void res`表达式。这是有道理的，因为我们不能声明`void`类型的变量。这个问题可以使用C++17中的`if
    constexpr`来解决：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before C++17, the most common alternative to if constexpr uses function overloading
    (the first argument is `std::true_type` or `std::false_type` depending on the
    branch of if constexpr provided by the corresponding function):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，if constexpr最常用的替代方法是函数重载（第一个参数是`std::true_type`或`std::false_type`，这取决于由相应函数提供的if
    constexpr的分支）：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second limitation is that the `auto` return type of our decorator is deduced
    only *mostly* accurately - for example, if a function returns `double&`, the decorated
    function will return just `double`. Lastly, wrapping member function calls is
    possible, but requires a somewhat different syntax.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个局限性是，我们的装饰器的`auto`返回类型推断得并不完全准确——例如，如果一个函数返回`double&`，则装饰后的函数将只返回`double`。最后，包装成员函数调用是可能的，但需要稍微不同的语法。
- en: Now, the template mechanism in C++ is powerful, and there are ways to make our
    generic decorator even more generic. These ways also make it more complex. Code
    like this belongs in a library, such as the standard library, but in most practical
    applications a debugging decorator is not worth such effort.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，C++的模板机制非常强大，有方法可以使我们的泛型装饰器更加通用。这些方法也使其更加复杂。这样的代码应该放在库中，比如标准库，但在大多数实际应用中，调试装饰器不值得付出这样的努力。
- en: The other limitation is that the more generic a decorator becomes, the less
    it can do. As it is, there are very few actions we could take that make sense
    for calling any function or member function (even to produce a good debug message
    in our decorator we might need to use compiler extensions, see *Example 09*).
    We could add some debug printouts, and print the result as long as it has the
    stream output operator defined. We could lock a mutex to protect a non-thread-safe
    function call in a multi-threaded program. Maybe there are a few more general
    actions. But, in general, do not get seduced by the pursuit of the most generic
    code for its own sake.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是，装饰器越通用，它能做的就越少。就目前而言，我们能够采取的、对任何函数或成员函数（甚至在我们的装饰器中产生一个良好的调试信息可能需要使用编译器扩展，见*示例
    09*）有意义的操作非常有限。我们可以添加一些调试打印，只要它定义了流输出操作符，就可以打印结果。我们可以在多线程程序中锁定互斥锁来保护非线程安全的函数调用。可能还有一些更通用的操作。但总的来说，不要被追求最通用代码本身所迷惑。
- en: Whether we have somewhat generic or very specific decorators, we often have
    the need to add multiple behaviors to an object. We have seen one such example
    already. Now, let’s review the problem of applying multiple decorators more systematically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否有某种通用的还是非常具体的装饰器，我们通常都需要向对象添加多个行为。我们已经看到了一个这样的例子。现在，让我们更系统地回顾一下应用多个装饰器的问题。
- en: Composable decorators
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可组合的装饰器
- en: 'The decorator property that we would like to have here has a name composability.
    Behaviors are composable if they can be applied to the same object separately:
    in our case, if we have two decorators, `A` and `B`. Therefore, `A(B(object))`
    should have both behaviors applied. The alternative to composability is the explicit
    creation of the combined behaviors: to have both behaviors without composability,
    we would need to write a new decorator, `AB`. Since writing new code for any combination
    of several decorators would be impossible even for a relatively small number of
    decorators, composability is a very important property.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在这里拥有的装饰器属性有一个名字，叫做可组合性。如果行为可以被分别应用于同一个对象，则它们是可组合的：在我们的情况下，如果我们有两个装饰器，`A`和`B`。因此，`A(B(object))`应该应用两种行为。可组合性的替代方案是显式创建组合行为：如果没有可组合性，我们需要编写一个新的装饰器，`AB`。由于为几个装饰器的任何组合编写新代码都是不可能的，即使装饰器的数量相对较少，可组合性是一个非常重要的属性。
- en: 'Fortunately, composability is not hard to achieve with our approach to decorators.
    The CRTP decorators we used in our game design earlier are naturally composable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用我们的装饰器方法，可组合性并不难实现。我们在早期的游戏设计中使用的CRTP装饰器自然是可以组合的：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each decorator inherits from the object it decorates and, thus, preserves its
    interface, except for the added behavior. Note that the order of the decorators
    matters since the new behavior is added before or after the decorated call. `DebugDecorator`
    applies to the object it decorates and provides debugging for it, so a `VeteranUnit<DebugDecorator<Ogre>>`
    object would debug the base portion of the object (`Ogre`), which can be useful
    as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个装饰器都继承自它装饰的对象，因此保留了其接口，除了添加的行为。请注意，装饰器的顺序很重要，因为新的行为是在装饰调用之前或之后添加的。`DebugDecorator`应用于它装饰的对象，并为其提供调试功能，因此`VeteranUnit<DebugDecorator<Ogre>>`对象会调试对象的基础部分（`Ogre`），这同样很有用。
- en: 'Our (somewhat) universal decorators can be composed as well. We already have
    a debugging decorator that can work with many different callable objects, and
    we mentioned a possible need to protect these calls with a mutex. We can now implement
    such a locking decorator in a similar manner (and with similar limitations) to
    the polymorphic debugging decorator:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的（某种程度上）通用装饰器也可以组合使用。我们已经有了一个可以与许多不同的可调用对象一起工作的调试装饰器，并且我们提到了可能需要使用互斥锁来保护这些调用。现在我们可以以类似的方式（以及类似的限制）实现这样的锁定装饰器，就像多态调试装饰器一样：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Again, we will use the `decorate_lock()` helper function to delegate to the
    compiler the tedious work of figuring out the right type of the callable object.
    We can now use a mutex to protect a function call that is not thread-safe:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将使用`decorate_lock()`辅助函数来委托给编译器解决可调用对象的正确类型这一繁琐的工作。现在我们可以使用互斥锁来保护一个非线程安全的函数调用：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we want to protect a function by a mutex and have a debug printout when
    it’s called, we do not need to write a new *locking debugging decorator,* but
    instead can apply both decorators in sequence:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要通过互斥锁来保护一个函数，并在调用时进行调试打印，我们不需要编写一个新的*锁定调试装饰器*，而是可以按顺序应用这两个装饰器：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example demonstrates the benefits of composability - we do not have to
    write a special decorator for every combination of behaviors (think how many decorators
    you would have to write for any combination of five different primary decorators
    if they were not composable!).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了可组合性的好处——我们不需要为每种行为组合编写特殊的装饰器（想想如果它们不可组合，你将需要为五种不同主要装饰器的任何组合编写多少装饰器！）。
- en: This composability is achieved easily in our decorators because they preserve
    the interface of the original object, at least the part we are interested in -
    the behavior changes, but the interface does not. When a decorator is used as
    an original object for another decorator, the preserved interface is once again
    preserved, and so on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可组合性在我们的装饰器中很容易实现，因为它们保留了原始对象（至少是我们感兴趣的部分）的接口——行为改变了，但接口没有改变。当一个装饰器被用作另一个装饰器的原始对象时，保留的接口再次被保留，依此类推。
- en: This preservation of the interface is a fundamental feature of the Decorator
    pattern. It is also one of its most serious limitations. Our locking decorator
    is not nearly as useful as it may seem at first glance (so do not go around your
    code bolting a lock onto every call when you need to make the code thread-safe).
    As we will see next, not every interface can be made thread-safe, no matter how
    good the implementation is. That’s when we have to change the interface in addition
    to modifying the behavior. This is the job for the Adapter pattern.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保留接口是装饰器模式的一个基本特征。它也是其最严重的限制之一。我们的锁定装饰器并不像乍看之下那么有用（所以当你需要使代码线程安全时，不要在代码中到处强行添加锁）。正如我们接下来将看到的，无论实现多么好，并不是每个接口都可以被做成线程安全的。这就是我们不仅要修改行为，还要改变接口的时候。这是适配器模式的工作。
- en: The Adapter pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: We ended the last section with the notion that the decorator pattern has particular
    advantages that come from preserving the decorated interface and that these advantages
    can sometimes turn into limitations. The Adapter pattern is a more general pattern
    that can be used in such cases.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个部分结束时提出了装饰器模式具有来自保留装饰后接口的特定优势，并且这些优势有时会变成限制。适配器模式是一个更通用的模式，可以在这种情况下使用。
- en: The Adapter pattern is defined very generally - it is a structural pattern that
    allows an interface of a class to be used as another, different interface. It
    allows an existing class to be used in code that expects a different interface,
    without modifying the original class. Such adapters are sometimes called **class
    wrappers** since they *wrap* around a class and present a different interface.
    You may recall that decorators are also sometimes called **class wrappers**, much
    for the same reason.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式被定义得非常广泛——它是一种结构型模式，允许一个类的接口被用作另一个不同的接口。它允许一个现有的类在期望不同接口的代码中使用，而不需要修改原始类。这样的适配器有时被称为**类包装器**，因为它们**包装**在类周围并呈现不同的接口。你可能还记得，装饰器有时也被称为**类包装器**，原因大致相同。
- en: However, Adapter is a very general, broad pattern. It can be used to implement
    several other, more narrowly defined patterns - in particular, the decorator.
    The decorator pattern is easier to follow, so we dealt with that first. Now, we
    will move on to the general case.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，适配器模式是一个非常通用、广泛的模式。它可以用来实现几个其他更具体定义的模式——特别是装饰器模式。装饰器模式更容易理解，所以我们首先处理了它。现在，我们将转向一般情况。
- en: Basic Adapter pattern
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本适配器模式
- en: Let’s follow on from the final example from the last section - the locking decorator.
    It calls any function under a lock, so no other function protected by the same
    mutex can be called on any other thread at the same time. In some cases, this
    could be enough to make the entire code thread-safe. Often, it is not.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续上一个部分的最后一个例子——锁定装饰器。它在一个锁下调用任何函数，因此没有其他由相同互斥锁保护的函数可以在任何其他线程上同时被调用。在某些情况下，这足以使整个代码线程安全。通常，这并不够。
- en: 'To demonstrate this, we are going to implement a thread-safe queue object.
    A queue is a moderately complex data structure, even without thread safety, but,
    fortunately, we do not need to start from scratch - we have `std::queue` in the
    C++ standard library. We can push objects onto the queue and take them from the
    queue in first-in-first-out order, but only on one thread - it is not safe to
    push two objects onto the same queue from two different threads at the same time,
    for example. But we have a solution for that - we can implement a locking queue
    as a decorator for the basic one. Since we are not concerned about the empty base
    optimization here (`std::queue` is not an empty class) and we have to forward
    every member function call, we do not need the inheritance and can use composition
    instead. Our decorator will contain the queue and the lock. Wrapping the `push()`
    method is easy. There are two versions of `push()` in `std::queue` - one moves
    the object and one copies it. We should protect both with the lock:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将实现一个线程安全的队列对象。队列是一个中等复杂的数据结构，即使没有线程安全，但幸运的是，我们不需要从头开始——C++标准库中有`std::queue`。我们可以按照先进先出的顺序将对象推入队列并从队列中取出对象，但只能在一个线程上——例如，同时从两个不同的线程向同一个队列推送两个对象是不安全的。但我们有一个解决方案——我们可以将锁定队列作为基本队列的装饰器来实现。由于我们这里不关心空基优化（`std::queue`不是一个空类）并且我们必须转发每个成员函数调用，所以我们不需要继承，而可以使用组合。我们的装饰器将包含队列和锁。包装`push()`方法很容易。`std::queue`中有两个版本的`push()`方法——一个移动对象，一个复制对象。我们应该用锁保护这两个版本：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let’s turn our attention to getting elements off the queue. The standard
    queue has three relevant member functions - first, there is `front()`, which lets
    us access the front element of the queue, but does not remove it from the queue.
    Then, there is `pop()`, which removes the front element but returns nothing (it
    gives no access to the front element - it just removes it). Both of these functions
    should not be called if the queue is empty - there is no error checking, but the
    result is undefined.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把注意力转向从队列中获取元素。标准队列有三个相关的成员函数——首先，是`front()`，它允许我们访问队列的前端元素，但不从队列中移除它。然后是`pop()`，它移除前端元素但不返回任何内容（它不提供对前端元素的访问——它只是移除它）。这两个函数在队列为空时不应该被调用——没有错误检查，但结果是不确定的。
- en: 'Finally, there is the third function, `empty()`; it returns false if the queue
    is not empty, and then we can call `front()` and `pop()`. If we decorate them
    with locking, we will be able to write code like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是第三个函数`empty()`；如果队列不为空，它返回`false`，然后我们可以调用`front()`和`pop()`。如果我们用锁定来装饰它们，我们就能写出如下代码：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each function is thread-safe by itself. The entire combination of them is not.
    It is important to understand why. First, we call `q.empty()`. Let’s assume that
    it returns `false`, so we know there is at least one element on the queue. We
    go on to access it on the next line by calling `q.front()`, which returns `5`.
    But this is just one of many threads in the program. Another thread is going through
    the same code at the same time (enabling this behavior is the point of the exercise).
    That thread, too, calls `q.empty()` and also gets `false` - as we just said, there
    is an element in the queue, and we have done nothing to remove it yet. The second
    thread also calls `q.front()` and gets `5` as well. That is already a problem
    - two threads each tried to take an element from the queue, but got the same one
    instead. But it gets worse - our first thread now calls `q.pop()` and removes
    `5` from the queue. The queue is now empty, but the second thread does not know
    about this - it called `q.empty()` earlier. Therefore, the second thread now calls
    `q.pop()` as well, this time on an empty queue. The best-case scenario here is
    that the program will crash right away.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数本身都是线程安全的。但它们的整体组合并不是。理解这一点非常重要。首先，我们调用`q.empty()`。假设它返回`false`，这意味着我们知道队列中至少有一个元素。接下来，我们在下一行通过调用`q.front()`来访问它，它返回`5`。但这只是程序中许多线程中的一个。另一个线程同时正在执行相同的代码（这正是练习的目的）。那个线程也调用了`q.empty()`，并且也得到了`false`——正如我们刚才说的，队列中有一个元素，而我们还没有做任何删除操作。第二个线程也调用了`q.front()`，并且也得到了`5`。这已经是一个问题——两个线程都试图从队列中取出一个元素，但取到的却是同一个。但问题更严重——我们的第一个线程现在调用了`q.pop()`并从队列中移除了`5`。现在队列是空的，但第二个线程并不知道这一点——它之前调用了`q.empty()`。因此，第二个线程现在也调用了`q.pop()`，这次是在一个空队列上。在这种情况下，最好的情况是程序会立即崩溃。
- en: We have just seen a specific case of a general problem - a sequence of actions,
    each of which is thread-safe, but is not thread-safe as a whole. In fact, this
    *locking queue* is entirely useless, and there is no way to write thread-safe
    code with it. What we need is a single thread-safe function that performs the
    entire transaction under one lock, as a single uninterruptible action (such transactions
    are called `std::queue` interface does not provide such a transactional API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了一个一般问题的具体案例——一系列操作，每个操作都是线程安全的，但作为一个整体不是线程安全的。实际上，这个*锁定队列*完全无用，无法用它来编写线程安全的代码。我们需要的是一个单一的线程安全函数，它在一个锁下执行整个事务，作为一个不可中断的操作（这种事务被称为`std::queue`接口不提供这样的事务性API）。
- en: 'So, now, we need a new pattern - one that transforms the existing interface
    of a class to our needs for a different interface. This cannot be done with the
    decorator pattern, but this is exactly the problem that the Adapter pattern solves.
    Now that we have agreed that we need a different interface, we just have to decide
    what it should be. Our single new `pop()` member function should do all of this
    - if the queue is not empty, it should remove the first element from the queue
    and return it, by copy or move, to the caller. If the queue is empty, it should
    not alter the state of the queue at all, but should somehow notify the caller
    that the queue was empty. One way to do this is to return two values - the element
    itself (if there is one) and a Boolean value that tells us whether the queue was
    empty or not. Here is the `pop()` part of the locking queue, which is now an adapter,
    not a decorator:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们需要一个新的模式——一个将类的现有接口转换为不同接口所需的新模式。这不能通过装饰器模式来完成，但这正是适配器模式解决的问题。既然我们已经同意需要一个不同的接口，我们只需决定它应该是什么。我们新的单个`pop()`成员函数应该完成所有这些——如果队列不为空，它应该从队列中移除第一个元素并返回它，通过复制或移动，给调用者。如果队列为空，它应该根本不改变队列的状态，但以某种方式通知调用者队列是空的。一种方法是通过返回两个值来实现——元素本身（如果有的话）和一个布尔值，告诉我们队列是否为空。以下是锁定队列的`pop()`部分，现在它是一个适配器，而不是装饰器：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we do not need to change `push()` - the single function call already
    does everything we need, so that part of the interface is just forwarded one-to-one
    by our adapter. This version of `pop()` returns `true` if it removed an element
    from the queue, and `false` otherwise. If `true` is returned, the element is saved
    into the provided argument, but if `false` is returned, the argument is unchanged.
    If the element type `T` is move-assignable, a move will be used instead of copy.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要改变`push()`——单个函数调用已经完成了我们需要的所有操作，因此这部分接口只是通过我们的适配器一对一地转发。这个版本的`pop()`在从队列中移除元素时返回`true`，否则返回`false`。如果返回`true`，则将元素保存到提供的参数中，但如果返回`false`，则参数保持不变。如果元素类型`T`是可移动赋值的，则使用移动而不是复制。
- en: This is, of course, not the only possible interface for such an atomic `pop()`.
    Another way would be to return both the element and the Boolean value as a pair.
    One significant difference is that there is now no way to leave the element unchanged
    - it’s the return value and it always has to be something. The natural way is
    to default-construct the element if there isn’t one on the queue (which implies
    a restriction on the element type `T` - it has to be default-constructible).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是这种原子`pop()`的唯一可能接口。另一种方式是返回一个包含元素和布尔值的对。一个显著的区别是，现在没有方法可以保留元素不变——它是返回值，它总是必须有一些东西。自然的方式是，如果队列中没有元素，就默认构造该元素（这暗示了对元素类型`T`的限制——它必须是可以默认构造的）。
- en: 'In C++17, the better alternative is to return a `std::optional`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，更好的选择是返回一个`std::optional`：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Depending on the application code that needs this queue, one of the interfaces
    may be preferable, and so there are other ways to design it as well. In all cases,
    we end up with two member functions, `push()` and `pop()`, that are protected
    by the same mutex. Now, any number of threads can execute any combination of these
    operations at the same time, and the behavior is well-defined. This means that
    the `locking_queue` object is thread-safe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要此队列的应用代码，可能有一种接口更可取，因此也有其他设计它的方法。在所有情况下，我们最终都会有两个成员函数，`push()`和`pop()`，它们都受到相同的互斥锁的保护。现在，任何数量的线程可以同时执行这些操作的任何组合，并且行为是明确的。这意味着`locking_queue`对象是线程安全的。
- en: Converting an object from its current interface to the interface needed by a
    particular application, without rewriting the object itself, is the purpose and
    use of the Adapter pattern. All kinds of interfaces may have to be converted,
    and so there are many different types of adapters. We will learn about some of
    them in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '将对象从其当前接口转换为特定应用所需的接口，而不需要重写对象本身，这就是适配器模式的目的和用途。可能需要转换各种接口，因此存在许多不同类型的适配器。我们将在下一节中了解其中的一些。 '
- en: Function adapters
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数适配器
- en: We have just seen a class adapter that changes the interface of a class. Another
    kind of interface is a function (a member or a non-member function). A function
    has certain arguments, but we may want to call it with a different set of arguments.
    This would need an adapter. One common application of such adapters is known as
    currying one (or more) of the function’s arguments. All it means is that we have
    a function of several arguments, and we fix the value of one of these arguments,
    so we don’t have to specify it on every call. One example would be if we have
    `f(int i, int j)`, but we want `g(i)`, which is the same as `f(i, 5)`, only without
    typing the `5` every time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了一个类适配器，它改变了类的接口。另一种接口是函数（成员函数或非成员函数）。一个函数有一定的参数，但我们可能想要用不同的参数集调用它。这需要一个适配器。这种适配器的一个常见应用被称为
    currying（或 currying 多个）函数的参数。这意味着我们有一个多个参数的函数，我们固定其中一个参数的值，因此我们不必在每次调用时指定它。一个例子是，如果我们有
    `f(int i, int j)`，但我们需要 `g(i)`，这相当于 `f(i, 5)`，只是不需要每次都输入 `5`。
- en: Here is a more interesting example that we are actually going to work our way
    through and implement an adapter. The `std::sort` function takes an iterator range
    (the sequence to sort), but it can also be called with three arguments - the third
    one is the comparison object (by default, `std::less` is used, which, in turn,
    calls `operator<()` on the objects being sorted).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更有趣的例子，我们将实际逐步实现一个适配器。`std::sort` 函数接受一个迭代器范围（要排序的序列），但它也可以用三个参数调用——第三个是比较对象（默认情况下使用
    `std::less`，它反过来会在排序的对象上调用 `operator<()`）。
- en: We want something else now - we want to compare floating-point numbers *fuzzily*,
    with tolerance - if the two numbers `x` and `y` are close enough to each other,
    then we don’t consider one to be less than the other. Only when `x` is much less
    than `y` do we want to enforce the sorted order where `x` comes before `y`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要做的是其他事情——我们想要模糊地比较浮点数，带有容差——如果两个数 `x` 和 `y` 足够接近，那么我们不认为一个比另一个小。只有当 `x`
    远远小于 `y` 时，我们才想要强制执行排序顺序，即 `x` 在 `y` 之前。
- en: 'Here is our comparison functor (a callable object):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的比较函数对象（一个可调用对象）：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This comparison object can be used with a standard sort:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较对象可以与标准排序一起使用：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, if we need this kind of sort often, we may want to curry the last
    argument and make ourselves an adapter that has just two arguments, the iterators,
    and the sorting function implied. Here is such an adapter - it is very simple:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们经常需要这种排序，我们可能想要 curry 最后一个参数，并为自己创建一个只有两个参数的适配器，即迭代器和隐含的排序函数。下面是一个这样的适配器——它非常简单：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we can call a sort function with two arguments:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用两个参数调用排序函数：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, if we often call sort in this manner to sort the entire container, we
    may want to change the interface once again and make another adapter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们经常以这种方式调用排序来对整个容器进行排序，我们可能想要再次更改接口并创建另一个适配器：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In C++20, `std::sort` and other STL functions have variants that accept ranges;
    they are a generalization of our container adapter. Now, the code in our program
    looks even simpler:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，`std::sort` 和其他 STL 函数有接受范围的变体；它们是容器适配器的一般化。现在，我们程序中的代码看起来更加简单：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is important to point out that C++14 provides an alternative for writing
    such simple adapters that should, in general, be preferred; we can use a lambda
    expression, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，C++14 提供了编写这种简单适配器的替代方案，通常应优先选择；我们可以使用 lambda 表达式，如下所示：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Of course, the comparison function much_less() is itself a callable, so it
    could be a lambda too:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，比较函数 much_less() 本身就是一个可调用对象，因此它也可以是一个 lambda 表达式：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The container adapter is just as easy to write:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 容器适配器的编写同样简单：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that you cannot have both of these in the same program under the same name
    - lambda expressions cannot be *overloaded* in this manner; they are actually
    not functions at all, but rather objects (you can create an overload set from
    lambdas, as was shown in [*Chapter 2*](B19262_02.xhtml#_idTextAnchor043)*, Class
    and* *Function Templates*).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你无法在同一个程序中以相同的名称同时拥有这两个（lambda表达式不能以这种方式*重载*；实际上，它们根本不是函数，而是对象（你可以从lambda中创建一个重载集，如[*第2章*](B19262_02.xhtml#_idTextAnchor043)*，类和函数模板*所示）。
- en: 'Coming back to the matter of calling a function with some arguments fixed,
    or bound, to constant values, we should say that this is such a common need that
    the C++ standard library provides a standard customizable adapter for this purpose,
    `std::bind`. Here is an example that shows us how it is used:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 回到用一些固定或绑定的常量值调用函数的问题，我们应该说这是一个如此常见的需求，以至于C++标准库提供了一个用于此目的的标准可定制适配器，即`std::bind`。以下是一个示例，展示了它的用法：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This standard adapter has its own *mini-language* - the first argument to `std::bind`
    is the function to be bound, while the rest are its arguments, in order. The arguments
    that should be bound are replaced by the specified values. The arguments that
    should remain free are replaced by the placeholders `_1`, `_2`, and so on (not
    necessarily in that order; that is, we can also change the order of the arguments).
    The returned value is of an unspecified type and has to be captured using `auto`.
    The only thing we know about the return value is that it can be called as a function
    with as many arguments as there are placeholders. It can also be used as a function
    in any context that expects a callable, for example, in another `std::bind`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种标准适配器有其自己的*迷你语言* - `std::bind`的第一个参数是要绑定的函数，其余的是它的参数，按顺序排列。应该绑定的参数被指定的值替换。应该保持自由的参数被占位符`_1`、`_2`等替换（不一定按此顺序；也就是说，我们也可以改变参数的顺序）。返回值是不指定的类型，必须使用`auto`捕获。我们唯一知道的是返回值可以像函数一样调用，具有与占位符一样多的参数。它也可以在任何期望可调用的上下文中用作函数，例如，在另一个`std::bind`中：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, these objects are callables, not functions, and you will discover
    that if you try to assign one of them to a function pointer:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些对象是可调用的，而不是函数，你会发现如果你尝试将它们中的一个分配给函数指针：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In contrast, lambdas can be converted to function pointers if they have no
    captures:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果lambda没有捕获，则可以将其转换为函数指针：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As useful as `std::bind` is, it does not free us from the need to learn how
    to write our own function adapters - its greatest limitation is that `std::bind`
    cannot bind template functions. We cannot write the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`std::bind`很有用，但它并没有使我们摆脱学习如何编写自己的函数适配器的需求 - 它最大的局限性是`std::bind`不能绑定模板函数。我们无法编写以下内容：
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This does not compile. Inside a template, we can bind the specific instantiation
    of it, but, at least in our sorting example, this really does not buy us anything:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译。在模板内部，我们可以绑定它的特定实例化，但至少在我们的排序示例中，这实际上并没有给我们带来任何好处：
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we mentioned at the beginning of this section, decorators can be seen as
    a special case of the Adapter pattern. Sometimes, the distinction is not so much
    in a particular application of the pattern but in how we choose to view it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本节开头提到的，装饰器可以被视为适配器模式的一个特例。有时，这种区别并不在于模式的具体应用，而在于我们选择如何看待它。
- en: Adapter or Decorator
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器或装饰器
- en: Until now, we described the Decorator as a pattern we use to augment an existing
    interface, while the Adapter is used to convert (adapt) an interface for integration
    with code that expects a different interface. The distinction is not always clear.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们描述装饰器为一种我们用来增强现有接口的模式，而适配器则是用来转换（适配）接口，以便与期望不同接口的代码集成。这种区别并不总是清晰的。
- en: 'For example, let us consider a simple class that adapts the result of the system
    call `std::time` to a printable date format (`std::chrono` provides this functionality,
    but it makes for an easy-to-follow example). The function `std::time` returns
    a value of the type `std::time_t` which is an integer containing the time in seconds
    since some standard moment in the past that is called the “start of the epoch.”
    Another system function, `localtime`, converts this value to a struct that contains
    the date elements: year, month, and day (also hours, minutes, etc). The calendar
    calculations, in general, are rather non-trivial (which is why `std::chrono` is
    not as simple as we might wish) but for now, let us assume that the system library
    does the right thing and all we have to do is print the date in the right format.
    For example, here is how to print the current date in the US format:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个简单的类，它将系统调用`std::time`的结果适配为可打印的日期格式（`std::chrono`提供了这种功能，但它是一个易于理解的例子）。函数`std::time`返回一个`std::time_t`类型的值，它是一个整数，包含自过去某个标准时刻以来的秒数，这个时刻被称为“纪元开始”。另一个系统函数`localtime`将这个值转换为包含日期元素的struct：年、月和日（以及小时、分钟等）。通常的日历计算相当复杂（这也是为什么`std::chrono`不像我们希望的那样简单），但就目前而言，让我们假设系统库做了正确的事情，我们只需要以正确的格式打印日期。例如，以下是如何以美国格式打印当前日期的方法：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We want to create an adapter that converts a time in seconds to the date in
    a particular format and lets us print it; we will need separate adapters for the
    US format (month first), European format (day first), and ISO format (year first).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个适配器，将秒数转换为特定格式的日期，并允许我们打印它；我们需要为美国格式（月份在前）、欧洲格式（日期在前）和ISO格式（年份在前）分别创建适配器。
- en: 'The implementation of the adapter is pretty straightforward:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器的实现相当直接：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The other two date formats are similar except for the order in which we print
    the fields. In fact, they are so similar that we may want to refactor the code
    to avoid typing three almost identical classes. The easiest way to do this is
    to use a template and encode the field order in a “format code” which specifies
    the order in which we print the day (field 0), month (field 1), and year (field
    2). For example, “format” 210 means year, then month, then day – the ISO date
    format. The format code can be an integer template parameter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两种日期格式在打印字段顺序上相似，除了我们打印字段的顺序。事实上，它们如此相似，我们可能想要重构代码以避免编写三个几乎相同的类。最简单的方法是使用模板，并将字段顺序编码在“格式代码”中，该代码指定我们打印日期（字段0）、月份（字段1）和年份（字段2）的顺序。例如，“格式”210表示年份，然后是月份，然后是日期——ISO日期格式。格式代码可以是一个整数模板参数：
- en: '[PRE57]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our little wrapper adapts a type (an integer) to be used in the code that expects
    dates in a particular format. Or does it decorate the integer with the `operator<<()`?
    The best answer is … whichever one is more helpful to you to think about your
    particular problem. It is important to remember the purpose of speaking in the
    language of the patterns in the first place: we do it to have a compact and commonly
    understood way to describe our software problems and the solutions we choose.
    When multiple patterns appear to yield similar results, the description you choose
    lets you focus on the aspect that is most important to you.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小包装器将一个类型（一个整数）适配为在代码中使用，该代码期望以特定格式提供日期。或者它是否用`operator<<()`装饰了整数？最好的答案是……无论哪个对你思考特定问题更有帮助。重要的是要记住，最初用模式语言说话的目的：我们这样做是为了有一个紧凑且普遍理解的方式来描述我们的软件问题和我们选择的解决方案。当多个模式似乎产生类似的结果时，你选择描述让你能够关注对你最重要的方面。
- en: So far, we have considered only adapters that convert runtime interfaces, which
    are the interfaces we call when the program is executed. However, C++ has compile-time
    interfaces as well - one of the prime examples that we considered in the last
    chapter was policy-based design. These interfaces are not always exactly what
    we need them to be, so we have to learn to write compile-time adapters next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了转换运行时接口的适配器，这些接口是我们程序执行时调用的接口。然而，C++也有编译时接口——我们在上一章考虑的一个主要例子是基于策略的设计。这些接口并不总是恰好符合我们的需求，因此我们必须学会编写编译时适配器。
- en: Compile-time adapters
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时适配器
- en: 'In [*Chapter 16*](B19262_16.xhtml#_idTextAnchor739), *Adapters and Decorators*,
    we learned about policies, which are building blocks for classes - they let the
    programmer customize the implementation for a particular behavior. As an example,
    we can implement this policy-based smart pointer that automatically deletes the
    object it owns. The policy is the particular implementation of the deletion:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第16章*](B19262_16.xhtml#_idTextAnchor739)，“适配器和装饰器”中，我们学习了政策，它们是类的构建块——它们让程序员可以为特定的行为定制实现。作为一个例子，我们可以实现这个基于政策的智能指针，它可以自动删除它拥有的对象。政策是删除的特定实现：
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Note that the deletion policy is itself a template - this is a *template* parameter.
    The default deletion policy is to use `operator delete`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，删除策略本身也是一个模板——这是一个*模板*参数。默认的删除策略是使用`operator delete`：
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, for objects allocated on a user-given heap, we need a different deletion
    policy that returns the memory to that heap:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于在用户指定的堆上分配的对象，我们需要一个不同的删除策略，该策略将内存返回到那个堆：
- en: '[PRE60]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then we have to create a policy object to use with the pointer:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建一个政策对象来与指针一起使用：
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This policy is not very flexible, however - it can handle heaps of only one
    type - `MyHeap`. We can make the policy more general if we make the heap type
    the second template parameter. As long as the heap has the `deallocate()` member
    function to return memory to it, we can use any heap class with this policy:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这项政策并不非常灵活，然而——它只能处理一种类型的堆——`MyHeap`。如果我们把堆类型设为第二个模板参数，就可以使政策更通用。只要堆有`deallocate()`成员函数来返回内存给它，我们就可以使用任何与这个政策兼容的堆类：
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Of course, if we have a heap class that uses another name for this member function,
    we can use a class adapter to make that class work with our policy, too. But we
    have a larger problem - our policy does not work with our smart pointer. The following
    code does not compile:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们有一个使用不同名称的成员函数的堆类，我们可以使用类适配器使该类也能与我们的政策一起工作。但我们有一个更大的问题——我们的政策与我们的智能指针不兼容。以下代码无法编译：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The reason is again the interface mismatch, only now it is a different kind
    of interface – the `template <typename T, template <typename> class DeletionPolicy>
    class SmartPtr {};` template expects the second argument to be a template with
    one type parameter. Instead, we have the `DeleteHeap` template with two type parameters.
    This is just like trying to call a function that has one parameter but uses two
    arguments - it won’t work. We need an adapter to convert our two-parameter template
    into a one-parameter one, and we have to fix the second argument to a particular
    heap type (but we do not need to rewrite the policy if we have multiple heap types,
    we just need to write several adapters). We can create this adapter, `DeleteMyHeap`,
    using inheritance (and remembering to bring the constructors of the base class
    into the derived adapter class scope):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 原因再次是接口不匹配，但现在它是一种不同类型的接口——`template <typename T, template <typename> class
    DeletionPolicy> class SmartPtr {};` 模板期望第二个参数是一个只有一个类型参数的模板。相反，我们有`DeleteHeap`模板，它有两个类型参数。这就像尝试调用一个只有一个参数但使用两个参数的函数——这是行不通的。我们需要一个适配器来将我们的双参数模板转换为单参数模板，并且我们必须将第二个参数固定为特定的堆类型（如果我们有多个堆类型，我们不需要重写策略，我们只需要编写几个适配器）。我们可以使用继承来创建这个适配器，`DeleteMyHeap`（并记得将基类的构造函数带入派生适配器类的范围）：
- en: '[PRE64]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We could do the same using the template alias:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用模板别名来做同样的事情：
- en: '[PRE65]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This first version is, obviously, much longer. However, we have to learn both
    ways of writing template adapters because the template alias has one major limitation.
    To illustrate it, let’s consider another example where an adapter is needed. We
    will begin by implementing a stream insertion operator for any STL-compliant sequence
    container whose elements have such an operator defined. It is a simple function
    template:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个版本显然要长得多。然而，我们必须学习两种编写模板适配器的方法，因为模板别名有一个主要限制。为了说明这一点，让我们考虑另一个需要适配器的例子。我们将从实现任何STL兼容序列容器的流插入操作符开始，这些容器的元素定义了这样的操作符。它是一个简单的函数模板：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This `template` function has two type parameters, the container type and the
    element type. The container is itself a template with one type parameter. The
    compiler deduces both the container type and the element type from the second
    function argument (the first argument in any `operator<<()` is always the stream).
    We can test our insertion operator on a simple container:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`template`函数有两个类型参数，容器类型和元素类型。容器本身是一个带有单个类型参数的模板。编译器从第二个函数参数（在任何`operator<<()`中的第一个参数总是流）推导出容器类型和元素类型。我们可以在一个简单的容器上测试我们的插入操作符：
- en: '[PRE67]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'But this is just a toy container and is not very useful. What we really want
    is to print elements of a real container, such as `std::vector`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是一个玩具容器，并不很有用。我们真正想要的是打印真实容器的元素，例如`std::vector`：
- en: '[PRE68]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Unfortunately, this code does not compile. The reason is that `std::vector`
    is not really a template with one type parameter, even though we used it as such.
    It has two parameters - the second is the allocator type. There is a default for
    this allocator, which is why we can write `std::vector<int>` and it compiles.
    But, even with this default argument, this is still a template with two parameters,
    while our stream insertion operator is declared to accept container templates
    with only one parameter. Again, we can solve the problem by writing an adapter
    (most STL containers are used with the default allocator anyway). The easiest
    way to write this adapter is with an alias:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码无法编译。原因是`std::vector`实际上不是一个只有一个类型参数的模板，尽管我们这样使用它。它有两个参数 - 第二个是分配器类型。这个分配器有一个默认值，这就是为什么我们可以写`std::vector<int>`并且它能编译。但是，即使有这个默认参数，这仍然是一个有两个参数的模板，而我们的流插入操作符被声明为只接受只有一个参数的容器模板。我们可以通过编写适配器来解决这个问题（大多数STL容器实际上都是与默认分配器一起使用的）。编写这个适配器最简单的方法是使用别名：
- en: '[PRE69]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Unfortunately, this does not compile either, and now we can show the template
    alias limitation that we alluded to earlier - template aliases are not used in
    template argument type deduction. When the compiler attempts to figure out the
    template argument types for the call of `operator<<()` with the arguments `cout`
    and `v`, the template alias `vector1` is *invisible*. In this case, we have to
    use a derived class adapter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这同样无法编译，现在我们可以展示我们之前提到的模板别名限制 - 模板别名不用于模板参数类型推导。当编译器试图确定使用`cout`和`v`作为参数调用`operator<<()`的模板参数类型时，模板别名`vector1`是“不可见”的。在这种情况下，我们必须使用一个派生类适配器：
- en: '[PRE70]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'By the way, if you paid attention to the previous chapter, you may realize
    that we already encountered the problem of extra parameters to the template template
    parameters, and solved it by declaring these parameters as variadic templates:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你注意到了前面的章节，你可能已经意识到我们已经遇到了模板模板参数额外参数的问题，并且通过将这些参数声明为变长模板参数来解决它：
- en: '[PRE71]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now our `operator<<()` can print any container, so we no longer need to worry
    about adapters, right? Not quite: one of the containers we still cannot print
    is `std::array` which is a class template with one type and one non-type parameter.
    We could declare an overload just to handle this case:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让`operator<<()`打印任何容器，所以我们不再需要担心适配器，对吧？并不完全是这样：我们仍然无法打印的容器之一是`std::array`，它是一个只有一个类型和一个非类型参数的类模板。我们可以声明一个重载来处理这种情况：
- en: '[PRE72]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: But we may have yet another kind of container that does not fit either of these
    templates (whether because it has to or simply because it is part of legacy code
    that was written differently). Then, we have to use an adapter again.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可能还有另一种类型的容器，它不适合这两种模板（无论是必须这样做还是因为它只是旧代码的一部分，该代码以不同的方式编写）。然后，我们再次必须使用适配器。
- en: We have now seen how we can implement decorators to augment class and function
    interfaces with the desired behavior, and how to create adapters when the existing
    interface is not suitable for a particular application. Decorator, and, even more
    so, Adapter, are very general and versatile patterns that can be used to solve
    many problems. It should come as no surprise that, often, a problem can be solved
    in more than one way, so there is a choice of patterns to use. In the next section,
    we will see one such case.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何实现装饰器来增强类和函数接口以实现所需的行为，以及当现有接口不适合特定应用时如何创建适配器。装饰器，甚至更不用说适配器，都是非常通用和灵活的模式，可以用来解决许多问题。毫不奇怪，通常一个问题可以用多种方式解决，因此有选择使用模式的余地。在下一节中，我们将看到这样一个案例。
- en: Adapter versus policy
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器与策略
- en: The adapter and the policy (or strategy) patterns are some of the more general
    patterns, and C++ adds generic programming capabilities to these patterns. This
    tends to extend their usability and sometimes blurs the lines between the patterns.
    The patterns themselves are defined very distinctly - policies provide custom
    implementations while adapters change the interface and add functionality to the
    existing interface (the latter is a decorator aspect, but, as we have seen, most
    decorators are implemented as adapters). We also saw in the last chapter that
    C++ broadens the capabilities of policy-based design; in particular, policies
    in C++ can add or remove parts of the interface as well as control the implementation.
    So, while patterns are different, there is significant overlap in the types of
    problems they can be used for. It is instructive to compare the two approaches
    when a problem is, broadly speaking, amenable to both. For this exercise, we will
    consider the problem of designing a custom value type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器和策略（或策略）模式是一些更通用的模式，C++ 为这些模式增加了泛型编程能力。这往往扩展了它们的可用性，有时也模糊了模式之间的界限。模式本身定义得非常明确
    - 策略提供自定义实现，而适配器则改变接口并向现有接口添加功能（后者是装饰器方面，但正如我们所见，大多数装饰器都是作为适配器实现的）。我们还在上一章中看到，C++
    扩展了基于策略的设计能力；特别是，C++ 中的策略可以添加或删除接口的部分，以及控制实现。因此，虽然模式不同，但它们在可以用于的问题类型上存在显著的重叠。当问题在广义上可以适用于两种方法时，比较这两种方法是有教育意义的。对于这个练习，我们将考虑设计自定义值类型的问题。
- en: A value type, to put it simply, is a type that behaves mostly like an `int`.
    Often, these types are numbers. While we have a set of built-in types for that,
    we may want to operate on rational numbers, complex numbers, tensors, matrices,
    or numbers that have units associated with them (meters, grams, and so on). These
    value types support a set of operations such as arithmetic operations, comparisons,
    assignments, and copying. Depending on what the value represents, we may need
    only a limited subset of these operations - for example, we may need to support
    addition and multiplication for matrices, but no division, and comparing matrices
    for anything other than equality probably doesn’t make sense in most cases. Similarly,
    we probably don’t want to allow the addition of meters to grams.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，值类型是一种主要像 `int` 那样行为的类型。通常，这些类型是数字。虽然我们有一组内置类型用于这些，但我们可能想要操作有理数、复数、张量、矩阵或与它们关联有单位的数字（米、克等等）。这些值类型支持一系列操作，如算术运算、比较、赋值和复制。根据值所代表的内容，我们可能只需要这些操作的一小部分
    - 例如，我们可能需要支持矩阵的加法和乘法，但不允许除法，并且在大多数情况下，比较矩阵以任何非等性可能都没有意义。同样，我们可能不希望允许米和克的相加。
- en: 'More generally, there is often a desire to have a numeric type with a limited
    interface - we would like it if the operations that we do not wish to allow for
    the quantity represented by such numbers did not compile. This way, a program
    with an invalid operation simply cannot be written. To be general, our design
    has to allow us to build the interface piece by piece. For example, we may want
    a value that is comparable for equality, ordered (has the less-than operation
    defined), and addable, but without multiplication or division. This seems like
    a problem that is tailor-made for the Decorator (or, more generally, Adapter)
    pattern: decorators can add behaviors like comparison operator or addition operator.
    On the other hand, creating a type with a set of capabilities configured by plugging
    in the right policies is exactly what the Policy pattern is for.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，人们通常希望有一个具有有限接口的数值类型 - 如果我们不希望允许表示此类数值的操作编译，我们会希望这样。这样，一个包含无效操作的程序就根本无法编写。为了通用，我们的设计必须允许我们逐步构建接口。例如，我们可能希望一个可以用于等性比较、有序（定义了小于操作）和可加的值，但没有乘法或除法。这似乎是一个非常适合装饰器（或更普遍地，适配器）模式的问题：装饰器可以添加比较运算符或加法运算符等行为。另一方面，创建一个通过插入正确的策略来配置功能集的类型正是策略模式的目的。
- en: Adapter solution
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器解决方案
- en: Let us examine the Adapter solution first. We will start with a basic value
    type that supports almost nothing in its interface, and then we can add the desired
    capabilities, one by one.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来考察适配器解决方案。我们将从一个基本的价值类型开始，它在接口中几乎不支持任何功能，然后我们可以逐一添加所需的功能。
- en: 'Here is our initial `Value` class template:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的初始 `Value` 类模板：
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `Value` is copyable and assignable, both from the underlying type such as
    `int` and from another `Value`. We could have moved some of those capabilities
    into adapters as well if we wanted to have non-copyable values, but you will find
    this an easy change after making your way through the rest of the chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value` 的值是可复制和可赋值的，无论是从底层类型如 `int` 还是另一个 `Value`。如果我们想拥有不可复制的值，我们也可以将这些功能移动到适配器中，但你会发现，在阅读完本章的其余部分后，这个改动很容易实现。'
- en: For convenience, we will also make our Value printable (in any real situation
    you would likely want this to be a separate and configurable capability, but it
    makes the examples simpler without taking anything important away).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们还将使我们的 `Value` 可打印（在任何真实情况下，你可能会希望这是一个单独且可配置的功能，但这使得示例更简单，而没有去掉任何重要内容）。
- en: '[PRE74]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We use the *friend factory*, which was described in [*Chapter 12*](B19262_12.xhtml#_idTextAnchor562),
    *Friend Factory*, to generate these functions. So far, all we can do with our
    Value is to initialize it, maybe assign it to another value, and print it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 *友元工厂*，这在 [*第12章*](B19262_12.xhtml#_idTextAnchor562)，*友元工厂* 中有描述，来生成这些函数。到目前为止，我们能够对
    `Value` 做的只是初始化它，也许将它赋值给另一个值，或者打印它：
- en: '[PRE75]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'There is nothing else we can do with this class - no comparisons for equality
    or inequality, no arithmetic operations. However, we can create an adapter that
    adds the comparison interface:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，我们别无他法——没有用于相等或不等的比较，也没有算术运算。然而，我们可以创建一个适配器来添加比较接口：
- en: '[PRE76]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is a class adapter - it is derived from the class it is augmenting with
    new capabilities, so it inherits all of its interface and adds some more - the
    complete set of comparison operators. Note that it is common to use pass-by-value
    instead of reference when dealing with value types (passing by reference to `const`
    isn’t wrong either, and some compilers may optimize either version to the same
    end result).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类适配器——它从它增强的类中继承而来，因此继承了所有接口并添加了一些更多——完整的比较运算符集。请注意，在处理值类型时，通常使用值传递而不是引用传递（将引用传递给
    `const` 也没有错，一些编译器可能会将两种版本都优化到相同的结果）。
- en: 'We are familiar with the way these adapters are used:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉这些适配器的使用方式：
- en: '[PRE77]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'That is one capability. What about some more? No problem - the `Ordered` adapter
    can be written very similarly, only it provides the operators `<`, `<=`, `>`,
    and `>=` (or, in C++20, operator `<=>`):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 那是其中一个功能。关于更多功能呢？没问题——`Ordered` 适配器可以非常相似地编写，只是它提供了 `<`、`<=`、`>` 和 `>=` 运算符（或者在
    C++20 中，是 `<=>` 运算符）：
- en: '[PRE78]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can combine the two adapters - as we say, they are composable, and they
    work in any order:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个适配器结合起来——正如我们所说的，它们是可组合的，并且可以在任何顺序下工作：
- en: '[PRE79]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Some operations, or capabilities, require more work. If our value type is numeric,
    such as `Value<int>`, we will want some arithmetic operations like addition and
    multiplication. Here is a decorator that enables addition and subtraction:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作或功能需要更多的工作。如果我们的值类型是数值类型，例如 `Value<int>`，我们可能希望有一些算术运算，比如加法和乘法。这里有一个允许加法和减法的装饰器：
- en: '[PRE80]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The decorator is trivial to use:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器使用起来非常简单：
- en: '[PRE81]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can also combine `Addable` with other decorators:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 `Addable` 与其他装饰器结合使用：
- en: '[PRE82]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'But we have a problem that so far has been hidden only by good luck. We could
    have just as easily written:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们有一个问题，到目前为止，这个问题只是因为好运才被隐藏起来。我们本来也可以这样写：
- en: '[PRE83]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'There should be no difference whatsoever between this example and the previous
    one. Instead, we get a compilation error: there is no valid `operator<` to be
    used in the last line. The problem here is that the `i + j` expression uses the
    `operator+()` that comes from the `Addable` adapter, and this operator returns
    an object of type `Addable<Value<int>>`. The comparison operator expects the type
    `Ordered<Addable<Value<int>>>`, and will not accept the “partial” type (there
    is no implicit conversion from a base class to the derived one). The unsatisfactory
    solution is to require that `Addable` is always the top decorator. Not only it
    just feels wrong, but it also doesn’t get us very far: the next decorator we will
    want is `Multipliable` and it is going to have the same problem. When something
    is both `Addable` and `Multipliable` we can’t have both be on top.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子之间不应该有任何区别。相反，我们得到了一个编译错误：最后一行没有有效的`operator<`可以使用。这里的问题是`i + j`表达式使用了来自`Addable`适配器的`operator+()`，而这个操作符返回的是类型为`Addable<Value<int>>`的对象。比较操作符期望的是类型`Ordered<Addable<Value<int>>>`，并且不会接受“部分”类型（从基类到派生类的隐式转换不存在）。令人不满意的解决方案是要求`Addable`始终是顶层装饰器。这不仅感觉不正确，而且也没有带我们走得很远：我们接下来想要的装饰器是`Multipliable`，它也会遇到同样的问题。当某物既是`Addable`又是`Multipliable`时，我们不能让两者都位于顶层。
- en: 'Note that we had no problems with comparison operators returning `bool`, but
    once we have to return the decorated type itself, which is what `operator+()`
    does, the composability breaks down. To solve this problem, every operator that
    returns the decorated type has to return the original (outermost) type. For example,
    if our value type is `Ordered<Addable<Value<int>>>`, the result of adding two
    values should have the same type. The problem, of course, is that `operator+()`
    is provided by the `Addable` decorator which knows only about `Addable` and its
    base classes. We need an intermediate class in the hierarchy (`Addable<...>`)
    to return objects of its derived type (`Ordered<Addable<...>>`). This is a very
    common design problem, and there is a pattern for it: the Curiously Recurring
    Template Pattern, or CRTP (see the eponymous [*Chapter 8*](B19262_08.xhtml#_idTextAnchor360)*,
    The Curiously Recurring Template Pattern*). Applying this pattern to our decorators
    takes some recursive thinking. We will introduce the two main ideas, then we just
    have to wade through a fairly large coding example.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们比较操作符返回`bool`时没有遇到任何问题，但一旦我们必须返回装饰后的类型本身，这正是`operator+()`所做的，组合性就会崩溃。为了解决这个问题，每个返回装饰后类型的操作符都必须返回原始（最外层）类型。例如，如果我们的值类型是`Ordered<Addable<Value<int>>>`，两个值相加的结果应该具有相同的类型。当然，问题是`operator+()`是由`Addable`装饰器提供的，它只知道`Addable`及其基类。我们需要在层次结构中添加一个中间类（`Addable<...>`），以返回其派生类型（`Ordered<Addable<...>>`）的对象。这是一个非常常见的设计问题，并且有一个模式：Curiously
    Recurring Template Pattern，或CRTP（参见同名的[*第8章*](B19262_08.xhtml#_idTextAnchor360)*，Curiously
    Recurring Template Pattern*）。将此模式应用于我们的装饰器需要一些递归思考。我们将介绍两个主要思想，然后我们只需通过一个相当大的代码示例。
- en: 'First of all, every decorator is going to have two template parameters. The
    first one is the same as before: it is the next decorator in the chain, or `Value<int>`
    at the end of the chain (of course, the pattern is not limited to `int`, but we’re
    simplifying our examples by staying with the same base type throughout). The second
    parameter is going to be the outermost type; we will call it the “final value
    type.” Thus, all of our decorators are going to be declared like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个装饰器都将有两个模板参数。第一个与之前相同：它是链中的下一个装饰器，或者在链的末尾是`Value<int>`（当然，这个模式不仅限于`int`，但我们通过在整个示例中保持相同的基类型来简化示例）。第二个参数将是最外层类型；我们将称之为“最终值类型”。因此，我们所有的装饰器都将这样声明：
- en: '[PRE84]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: But in our code, we still want to write
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们的代码中，我们仍然想要写
- en: '[PRE85]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This means we need a default value for the second template parameter. This
    value can be any type that we’re not going to use elsewhere in our decorators;
    `void` will do nicely. We will also need a partial template specialization for
    this default type since, if the final value type is not specified explicitly,
    we have to somehow figure out what it is:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要为第二个模板参数提供一个默认值。这个值可以是我们在装饰器中其他地方不会使用的任何类型；`void`将非常合适。我们还需要为这个默认类型提供一个部分模板特化，因为如果最终值类型没有明确指定，我们必须以某种方式确定它：
- en: '[PRE86]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we’re going to walk through our “nested” type `Ordered<Addable<Value< int>>>`
    step by step. At the outer layer, we can think of it as `Ordered<T>` where `T`
    is `Addable<Value<int>>`. Since we did not specify the second type parameter `FV`
    to the `Ordered` template, we are going to get the default value `void` and the
    template instantiation `Ordered<T>` is going to use the partial specialization
    of the `Ordered` template. Even thought we don’t have the “final value type” `FV`
    specified, we know what that is: it’s `Ordered<T>` itself.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步分析我们的“嵌套”类型 `Ordered<Addable<Value< int>>>`。在最外层，我们可以将其视为 `Ordered<T>`，其中
    `T` 是 `Addable<Value<int>>`。由于我们没有指定 `Ordered` 模板的第二个类型参数 `FV`，我们将得到默认值 `void`，并且模板实例化
    `Ordered<T>` 将使用 `Ordered` 模板的局部特化。即使我们没有指定“最终值类型” `FV`，我们也知道那是什么：它就是 `Ordered<T>`
    本身。
- en: 'Now we need to figure out the base class to inherit from. Since every decorator
    inherits from the type it decorates, it should be `T` which is `Addable<U>` (where
    `U` is `Value<int>`). But that’s not going to work: we need to pass the correct
    final value type into `Addable`. So we should inherit from `Addable<U, FV>` where
    `FV` is the final value type `Ordered<T>`. Unfortunately, we do not have `Addable<U,
    FV>` written in the code: we have `Addable<U>`. What we need is to somehow figure
    out the type that would have been generated by the same template `Addable` but
    with a different second type argument (`Ordered<T>` instead of the default `void`).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确定要继承的基类。由于每个装饰器都从它装饰的类型继承，它应该是 `T`，即 `Addable<U>`（其中 `U` 是 `Value<int>`）。但这不会起作用：我们需要将正确的最终值类型传递给
    `Addable`。因此，我们应该从 `Addable<U, FV>` 继承，其中 `FV` 是最终值类型 `Ordered<T>`。不幸的是，我们没有在代码中写出
    `Addable<U, FV>`：我们有 `Addable<U>`。我们需要做的是以某种方式找出由相同的模板 `Addable` 但具有不同的第二个类型参数（`Ordered<T>`
    而不是默认的 `void`）生成的类型。
- en: 'This is a very common problem in C++ templates, and it has an equally common
    solution: template rebinding. Every one of our decorator templates needs to define
    the following template alias:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 C++ 模板中非常常见的问题，并且有一个同样常见的解决方案：模板重新绑定。我们所有的装饰器模板都需要定义以下模板别名：
- en: '[PRE87]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, given the type `T`, which is an instantiation of one of the decorator
    templates, we can find out the type that would have been produced by the same
    template but with a different second template argument `FV`: it’s `T::template
    rebind<FV>`. That is what our `Ordered<V>` needs to inherit from to pass the correct
    final value type to the next decorator:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，给定类型 `T`，它是装饰器模板之一的一个实例化，我们可以找出由相同的模板但具有不同的第二个模板参数 `FV` 产生的类型：它是 `T::template
    rebind<FV>`。这就是我们的 `Ordered<V>` 需要继承以传递正确的最终值类型给下一个装饰器的：
- en: '[PRE88]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This class template says that given a type `Ordered<T, FV>` we are going to
    inherit from the type `T` rebound to the same final value type `FV` and ignore
    the second template argument of `T`. The exception from this is the outermost
    type, where the template parameter `FV` is void but we know what the final value
    type should be, so we can rebind to that type:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类模板表明，给定类型 `Ordered<T, FV>`，我们将从重新绑定到相同最终值类型 `FV` 的类型 `T` 继承，并忽略 `T` 的第二个模板参数。这个例外是最外层的类型，其中模板参数
    `FV` 是 `void`，但我们知道最终的值类型应该是什么，因此我们可以重新绑定到那个类型：
- en: '[PRE89]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Note the syntax, with the keyword `template`: some compilers will accept `V::
    rebind<Ordered<V>>` but this is wrong, the standard requires this exact syntax.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '注意语法，使用关键字 `template`：一些编译器将接受 `V:: rebind<Ordered<V>>`，但这是不正确的，标准要求这种确切的语法。'
- en: 'Now we can put everything together. In the general case where our decorator
    is somewhere in the middle of the decorator chain, we must pass the final value
    type to the base class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把所有东西放在一起。在装饰器链中间的通用情况下，我们必须将最终值类型传递给基类：
- en: '[PRE90]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The type alias `base_t` is introduced for convenience, it makes writing using
    statements easier. Note that we need the `typename` keyword before any type that
    depends on the template parameters; we did not need this keyword to specify the
    base class because the base class is always a type, so writing `typename` would
    be redundant.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，引入了类型别名 `base_t`，这使得编写使用语句变得更容易。请注意，在依赖于模板参数的任何类型之前，我们需要使用 `typename`
    关键字；我们不需要这个关键字来指定基类，因为基类始终是一个类型，所以编写 `typename` 将是多余的。
- en: 'The special case of the outermost type where the final value type is not specified
    and defaults to `void` is very similar:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层类型的特殊情况，其中最终值类型未指定并默认为 `void`，非常相似：
- en: '[PRE91]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The specialization differs from the general case in two ways. In addition to
    the base class, the parameters of the operators cannot be of the type `FV` since
    it is `void`. Instead, we must use the type of the class generated by the template,
    which inside the template definition can be referred to simply as `Ordered` (the
    name of the template, when used inside the class, refers to the specific instantiation
    – you do not need to repeat the template arguments).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 特化与一般情况有两种不同之处。除了基类之外，操作符的参数不能是 `FV` 类型，因为它代表 `void`。相反，我们必须使用由模板生成的类的类型，在模板定义内部可以简单地称为
    `Ordered`（当在类中使用时，模板的名称指的是特定的实例化 - 你不需要重复模板参数）。
- en: 'For decorators whose operators return a value, we need to make sure to always
    use the correct final value type for the return type. In the general case, this
    is the second template parameter `FV`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些操作符返回值的装饰器，我们需要确保始终使用正确的最终值类型来指定返回类型。在一般情况下，这是第二个模板参数 `FV`：
- en: '[PRE92]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In the specialization for the outermost decorator, the final value type is
    the decorator itself:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在最外层装饰器的特化中，最终值类型是装饰器本身：
- en: '[PRE93]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We must apply this technique to every decorator template. Now we can compose
    the decorators in any order and define value types with any subset of available
    operations:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将此技术应用于每个装饰器模板。现在我们可以以任何顺序组合装饰器，并使用任何可用操作的子集定义值类型：
- en: '[PRE94]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'So far, all of our decorators added member or non-member operators to the class.
    We can also add member functions and even constructors. The latter is useful if
    we want to add a conversion. For example, we can add an implicit conversion from
    the underlying type (as written, `Value<T>` is not implicitly constructible from
    `T`). The conversion decorator follows the same pattern as all the other decorators
    but adds an implicit converting constructor:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的装饰器都向类中添加了成员或非成员操作符。我们也可以添加成员函数甚至构造函数。后者在需要添加转换时很有用。例如，我们可以添加一个从底层类型（如所写，`Value<T>`
    不能隐式地从 `T` 构造）的隐式转换。转换装饰器遵循所有其他装饰器的相同模式，但添加了一个隐式转换构造函数：
- en: '[PRE95]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now we can use implicit conversions to our value type, for example, when calling
    functions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用隐式转换到我们的值类型，例如，在调用函数时：
- en: '[PRE96]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If you want an implicit conversion to the underlying type, you can use a very
    similar adapter but instead of the constructor, it adds the conversion operator:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个到底层类型的隐式转换，你可以使用一个非常相似的适配器，但不是构造函数，而是添加了转换操作符：
- en: '[PRE97]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This allows us to do the conversion in the opposite direction:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们进行相反方向的转换：
- en: '[PRE98]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This design gets the job done, there aren’t any particular problems with it,
    other than the complexity of writing the adapters themselves: the recursive application
    of CRTP tends to send your brain into infinite recursion until you get used to
    thinking about this kind of template adapters. The other alternative is a policy-based
    value type.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计完成了工作，没有特别的问题，除了编写适配器的复杂性：CRTP的递归应用往往会让你陷入无限递归，直到你习惯了这种类型的模板适配器的思考方式。另一种选择是策略基于的值类型。
- en: Policy solution
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略解决方案
- en: 'We are now going to look at a somewhat different form of the policy-based design
    compared to what we saw in [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689)*,
    Policy-Based Design*. It is not as general, but when it works, it can provide
    all the advantages of the policies, in particular, the composability, without
    some of the problems. The problem remains the same: create a custom value type
    with a set of operations we can control. This problem can be tackled with the
    standard policy-based approach:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将研究一种与我们在[*第15章*](B19262_15.xhtml#_idTextAnchor689)*，基于策略的设计*相比略有不同的形式。它并不像后者那样通用，但当它起作用时，它可以提供策略的所有优势，特别是可组合性，而没有一些问题。问题仍然是相同的：创建一个具有我们可以控制的操作集的自定义值类型。这个问题可以通过标准的基于策略的方法来解决：
- en: '[PRE99]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This implementation runs into the entire set of drawbacks of policy-based design
    - the policy list is long, all policies must be spelled out, and there aren’t
    any good defaults; the policies are positional, so the type declaration requires
    careful counting of commas, and, as the new policies are added, any semblance
    of a meaningful order of policies disappears. Note that we did not mention the
    problem of different sets of policies creating different types - in this case,
    this is not a drawback, but the design intent. If we want a type with support
    for addition and a similar type but without addition, these have to be different
    types.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现遇到了基于策略设计的所有缺点——策略列表很长，所有策略都必须明确列出，而且没有好的默认值；策略是位置相关的，因此类型声明需要仔细计算逗号的数量，并且随着新策略的添加，策略的任何有意义顺序都消失了。请注意，我们没有提到不同策略集创建不同类型的问题——在这种情况下，这并不是一个缺点，而是设计意图。如果我们想要一个支持加法且类似但不支持加法的类型，这些必须是不相同的类型。
- en: Ideally, we would like to just list the policies for the properties we want
    our value to have - I want a value type based on integers that support addition,
    multiplication, and assignment, but nothing else. After all, we did this with
    the Adapter pattern, so we would not settle for anything less now. As it turns
    out, there is a way to accomplish this.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们只想列出我们想要我们的值拥有的策略——我想有一个基于整数的值类型，支持加法、乘法和赋值，但没有其他功能。毕竟，我们使用适配器模式做到了这一点，所以我们不会满足于任何更少的东西。实际上，有一种方法可以实现这一点。
- en: 'First, let’s think of what such a policy might look like. For example, the
    policy that enables addition should inject `operator+()` into the public interface
    of the class (and maybe also `operator+=()`). The policy that makes the value
    assignable should inject `operator=()`. We have seen enough of such policies to
    know how they are implemented - they have to be base classes, publicly inherited,
    and they need to know what the derived class is and cast it to its type, so they
    have to use CRTP:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下这样的策略可能是什么样子。例如，允许加法的策略应该将 `operator+()` 注入类的公共接口（也许还可以注入 `operator+=()`）。使值可赋值的策略应该注入
    `operator=()`。我们已经看到了足够多的此类策略，知道它们是如何实现的——它们必须是基类，公开继承，并且需要知道派生类的类型并将其转换为该类型，因此它们必须使用CRTP：
- en: '[PRE100]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we need to give some thought to the use of these policies in the primary
    template. First of all, we want to support the unknown number of policies, in
    any order. This brings `variadic` templates to mind. However, to use CRTP, the
    template parameters have to be templates themselves. Then, we want to inherit
    from an instantiation of each of these templates, however many there are. What
    we need is a `variadic` template with a template template parameter pack:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要考虑这些策略在主模板中的使用。首先，我们希望支持任何顺序的未知数量策略。这让我想起了变长模板。然而，为了使用CRTP，模板参数必须是模板本身。然后，我们希望从每个这些模板的实例化中继承，无论有多少个。我们需要的是一个具有模板模板参数包的变长模板：
- en: '[PRE101]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The preceding declaration introduces a class template called `Value`, with at
    least one parameter that is a type, plus zero or more template policies, which
    themselves have two type parameters (in C++17, we can also write `typename ...
    Policies` instead of `class ... Policies`). The `Value` class instantiates these
    templates with the type `T` and itself and inherits publicly from all of them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明引入了一个名为 `Value` 的类模板，它至少有一个参数是类型，加上零个或多个模板策略，这些策略本身有两个类型参数（在C++17中，我们也可以用
    `typename ... Policies` 代替 `class ... Policies`）。`Value` 类使用类型 `T` 和自身实例化这些模板，并从它们中公开继承。
- en: 'The `Value` class template should contain the interface that we want to be
    common for all our value types. The rest will have to come from policies. Let’s
    make the values copyable, assignable, and printable by default:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value` 类模板应该包含我们希望所有值类型共有的接口。其余的将来自策略。让我们使值默认可复制、可赋值和可打印：'
- en: '[PRE102]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Again, we use the *friend factor*y from [*Chapter 12*](B19262_12.xhtml#_idTextAnchor562)*,
    Friend Factory,* to generate the stream operators.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用来自[*第12章*](B19262_12.xhtml#_idTextAnchor562)*，友元工厂*的*友元因子*来生成流操作符。
- en: 'Before we can indulge ourselves in implementing all of the policies, there
    is one more hurdle to overcome. The `val_` value is private in the `Value` class,
    and we like it this way. However, the policies need to access and modify it. In
    the past, we solved this problem by making each policy that needed such access
    into a friend. This time, we don’t even know the names of the policies we may
    have. After working through the preceding declaration of the parameter pack expansion
    as a set of base classes, the reader may reasonably expect us to pull a rabbit
    out of the hat and somehow declare friendship to the entire parameter pack. Unfortunately,
    the standard offers no such way. The best solution we can suggest is to provide
    a set of accessor functions that should be called only by the policies, but there
    is no good way to enforce that (a name, such as `policy_accessor_do_not_call()`,
    might go some way to suggest that the user code should stay away from it, but
    the ingenuity of the programmer knows no bounds, and such hints are not universally
    respected):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够尽情实现所有策略之前，还有一个障碍需要克服。`val_`值在`Value`类中是私有的，我们喜欢这种方式。然而，策略需要访问和修改它。在过去，我们通过将需要此类访问的每个策略都变成友元来解决此问题。这次，我们甚至不知道可能存在的策略名称。在处理完参数包扩展的声明作为一组基类之后，读者可能会合理地期望我们变魔术般地宣布与整个参数包的友谊。不幸的是，标准并没有提供这样的方法。我们能提出的最佳解决方案是提供一组只有策略可以调用的访问器函数，但没有好的方法来强制执行这一点（例如，一个名为`policy_accessor_do_not_call()`的名称可能有助于暗示用户代码应远离它，但程序员的创造力是无限的，这样的提示并不总是得到普遍尊重）：
- en: '[PRE103]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To create a value type with a restricted set of operations, we have to instantiate
    this template with a list of policies we want, and nothing else:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有受限操作集的值类型，我们必须使用我们想要的策略列表实例化此模板，没有其他内容：
- en: '[PRE104]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The number and the type of policies we can implement are limited mostly by the
    need at hand (or imagination), but here are some examples that demonstrate adding
    different kinds of operations to the class.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现的策略的数量和类型主要受当前需求（或想象力）的限制，但以下是一些示例，展示了如何向类添加不同类型的操作。
- en: 'First of all, we can implement the aforementioned `Incrementable` policy that
    provides the two `++` operators, postfix and prefix:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以实现前面提到的`Incrementable`策略，它提供了两个`++`运算符，后缀和前缀：
- en: '[PRE105]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can make a separate `Decrementable` policy for the `--` operators, or have
    one policy for both if it makes sense for our type. Also, if want to increment
    by some value other than one, then we need the `+=` operators as well:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`--`运算符创建一个单独的`Decrementable`策略，或者如果对我们的类型有意义，可以有一个策略同时处理两者。此外，如果我们想以除了1以外的值进行增量，那么我们还需要`+=`运算符：
- en: '[PRE106]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The preceding policy provides two versions of `operator+=()` - one accepts the
    increment of the same `Value` type, and the other of the foundation type `T`.
    This is not a requirement, and we could implement an increment by values of some
    other types as needed. We can even have several versions of the increment policy,
    as long as only one is used (the compiler would let us know if we were introducing
    incompatible overloads of the same operator).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 上述策略提供了`operator+=()`的两个版本 - 一个接受相同`Value`类型的增量，另一个接受基础类型`T`。这并不是一个要求，我们可以根据需要实现其他类型的值增量。我们甚至可以有多种增量策略版本，只要只使用其中一种（编译器会告诉我们是否引入了不兼容的重载）。
- en: 'We can add the operators `*=` and `/=` in a similar manner. Adding binary operators
    such as comparison operators or addition and multiplication is a little different
    - these operators have to be non-member functions to allow for type conversions
    on the first argument. Again, the friend factory pattern comes in handy. Let’s
    start with the comparison operators:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式添加`*=`和`/=`运算符。添加如比较运算符或加法和乘法这样的二元运算符略有不同 - 这些运算符必须是非成员函数，以便允许对第一个参数进行类型转换。同样，友元工厂模式在这里很有用。让我们从比较运算符开始：
- en: '[PRE107]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When instantiated, this template generates two non-member non-template functions,
    that is, the comparison operators for variables of the type of the specific `Value`
    class, the one that is instantiated. We may also want to allow comparisons with
    the foundation type (such as `int`):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化时，此模板生成两个非成员非模板函数，即特定`Value`类变量的比较运算符，即实例化的那个。我们可能还希望允许与基础类型（如`int`）进行比较：
- en: '[PRE108]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'More often than not, we will likely want both types of comparison at the same
    time. We could simply put them both into the same policy and not worry about separating
    them, or we could create a combined policy from the two we already have:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们可能同时想要这两种类型的比较。我们可以简单地将它们都放入同一个策略中，不必担心分离它们，或者我们可以从已有的两个策略中创建一个组合策略：
- en: '[PRE109]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In the previous section, we combined all comparisons in a single adapter from
    the beginning. Here, we use a slightly different approach just to illustrate different
    options for controlling class interfaces with policies or adapters (both solutions
    offer the same options). The addition and multiplication operators are created
    by similar policies. They are also friend non-template non-member functions. The
    only difference is the return value type - they return the object itself, for
    example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们从一开始就将所有比较组合在一个适配器中。这里，我们使用一种稍微不同的方法，只是为了说明使用策略或适配器（两种解决方案都提供相同的选项）控制类接口的不同选项。加法和乘法运算符是通过类似策略创建的。它们也是非模板非成员函数的朋友。唯一的区别是返回值类型——它们返回对象本身，例如：
- en: '[PRE110]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'As you can see, the problem of returning the “final value type” that we struggled
    with while writing adapters does not exist here: the derived class that is passed
    into each policy is the value type itself.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在编写适配器时遇到的返回“最终值类型”的问题在这里不存在：传递给每个策略的派生类本身就是值类型。
- en: 'Explicit or implicit conversion operators for conversions to the base type
    can be added just as easily:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 向基本类型转换的显式或隐式转换运算符可以同样轻松地添加：
- en: '[PRE111]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This approach, at first glance, seems to solve most of the drawbacks of the
    traditional policy-based types. The order of the policies does not matter - we
    can specify only the ones we want and not worry about the other ones - what’s
    not to like? There are, however, two fundamental limitations. First of all, the
    policy-based class cannot refer to any policy by name. There is no longer a slot
    for `DeletionPolicy` or `AdditionPolicy`. There are no convention-enforced policy
    interfaces, such as the deletion policy having to be callable. The entire process
    of binding the policies into a single type is implicit; it’s just a superposition
    of interfaces.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法乍一看似乎解决了传统基于策略的类型的大部分缺点。策略的顺序并不重要——我们只需指定我们想要的策略，不必担心其他的——有什么不喜欢的呢？然而，有两个基本限制。首先，基于策略的类不能通过名称引用任何策略。不再有`DeletionPolicy`或`AdditionPolicy`的位置。没有约定强制的策略接口，例如删除策略必须是可调用的。将策略绑定到单个类型的整个过程是隐式的；它只是接口的叠加。
- en: Therefore, we are limited in what we can do using these policies - we can inject
    public member functions and non-member functions - even add private data members
    - but we cannot provide an implementation for an aspect of behavior that’s determined
    and limited by the primary policy-based class. As such, this is not an implementation
    of the Strategy pattern - we are composing the interface, and, perforce, the implementation,
    at will, not customizing a specific algorithm (which is why we deferred the demonstration
    of this alternative policy-based design pattern until this chapter).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用这些策略所能做的事情有限——我们可以注入公共成员函数和非成员函数——甚至可以添加私有数据成员——但我们不能为由主要基于策略的类确定和限制的行为方面提供实现。因此，这不是策略模式的实现——我们随意组合接口，以及实现，而不是定制特定的算法（这就是为什么我们将这种替代基于策略的设计模式的演示推迟到本章）。
- en: The second, closely related, limitation is that there are no default policies.
    The missing policies are just that, missing. There is nothing in their place.
    The default behavior is always the absence of any behavior. In the traditional
    policy-based design, each policy slot has to be filled. If there is a reasonable
    default, it can be specified, and then that is the policy unless the user overrides
    it (for example, the default deletion policy uses `operator delete`). If there
    is no default, the compiler won’t let us omit the policy - we have to give an
    argument to the template.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，与之紧密相关的限制是，没有默认策略。缺失的策略就是缺失。它们的位置上什么也没有。默认行为总是没有任何行为。在传统的基于策略的设计中，每个策略槽都必须被填充。如果有合理的默认值，可以指定它，然后除非用户覆盖它（例如，默认删除策略使用`operator
    delete`），否则这就是策略。如果没有默认值，编译器不会让我们省略策略——我们必须为模板提供一个参数。
- en: 'The consequences of these limitations reach farther than you may think at first
    glance. For example, it may be tempting to use the `enable_if` technique we saw
    in [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689)*, Policy-Based Design,* instead
    of injecting public member functions through the base class. Then, we could have
    a default behavior that is enabled if none of the other options are. But it won’t
    work here. We can certainly create a policy that is targeted for use with `enable_if`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制的后果比你最初想象的要深远。例如，可能会诱使你使用我们在[*第15章*](B19262_15.xhtml#_idTextAnchor689)*，基于策略的设计*中看到的`enable_if`技术，而不是通过基类注入公共成员函数。然后，我们可以有一个默认行为，如果没有其他选项，则启用。但在这里行不通。我们当然可以创建一个针对`enable_if`使用的策略：
- en: '[PRE112]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: But there is no way to use it - we can’t use `AdditionPolicy::adding_enabled`
    because there is no `AdditionPolicy` - all policy slots are unnamed. The other
    option would be to use `Value::adding_enabled` - the addition policy is a base
    class of `Value`, and, therefore, all of its data members are visible in the `Value`
    class. The only problem is that it does not work - at the point where this expression
    is evaluated by the compiler (in the definition of the `Value` type as the template
    parameter for the CRTP policies), `Value` is an incomplete type and we cannot
    access its data members yet. We could evaluate `policy_name::adding_enabled` if
    we knew what the policy name was. But that knowledge is exactly what we gave up
    in trade for not having to specify the entire list of policies.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用它是没有可能的——我们无法使用`AdditionPolicy::adding_enabled`，因为没有`AdditionPolicy`——所有策略槽位都是未命名的。另一种选择是使用`Value::adding_enabled`——加法策略是`Value`的基类，因此，其所有数据成员在`Value`类中都是可见的。唯一的问题是这不起作用——在编译器评估此表达式（在定义`Value`类型作为CRTP策略的模板参数）时，`Value`是一个不完整类型，我们无法访问其数据成员。如果我们知道策略名称，我们可以评估`policy_name::adding_enabled`。但正是这种知识，我们为了不指定策略的完整列表而放弃了。
- en: While not, strictly speaking, an application of the Strategy pattern, the alternative
    to the policy-based design that we have just learned about can be attractive when
    the policies are primarily used to control a set of supported operations. While
    discussing the guidelines for policy-based design, we have mentioned that it is
    rarely worth it to use a policy slot just to provide the additional safety of
    the restricted interface. For such situations, this alternative approach should
    be kept in mind.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然严格来说，这不是策略模式的应用，但当策略主要用于控制一组支持的运算时，我们刚刚学到的基于策略的设计的替代方案可能很有吸引力。在讨论基于策略的设计指南时，我们提到，仅仅为了提供受限接口的额外安全性而使用策略槽位通常是不值得的。对于这种情况，这种替代方法应该被记住。
- en: 'Overall, we can see that both patterns have their advantages and drawbacks:
    adapters rely on a more complex form of CRTP while the “slot-less” policies we
    just saw require us to compromise the encapsulation (we have to expose the value
    to the policies using something like our `get()` methods).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来看，我们可以看到这两种模式都有其优点和缺点：适配器依赖于更复杂的CRTP形式，而我们刚刚看到的“无槽位”策略要求我们做出妥协（我们必须使用类似我们的`get()`方法之类的机制将值暴露给策略）。
- en: Such is the nature of the problems we have to solve as software engineers -
    once a problem becomes complex enough, it can be solved, frequently using more
    than one design, and each approach has its own advantages and limitations. There
    is no way we can compare every two patterns that can be used to create two very
    different designs that address the same need, at least not in a book of any finite
    size. By presenting and analyzing these examples, we hope to equip the reader
    with the understanding and insight that will be helpful in evaluating similarly
    complex and varied design options for real-life problems.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们作为软件工程师必须解决的问题的本质——一旦问题变得足够复杂，它就可以被解决，通常需要使用多种设计，每种方法都有其自身的优点和局限性。我们无法比较用于创建两种非常不同的设计以解决相同需求的每种模式，至少在有限大小的书中是不可能的。通过展示和分析这些示例，我们希望为读者提供理解和洞察，这将有助于评估类似复杂和多样的设计选项，以解决现实生活中的问题。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have studied two of the most commonly used patterns - not just in C++, but
    in software design in general. The Adapter pattern offers an approach to solving
    a wide class of design challenges. These challenges have only the most general
    property in common - given a class, a function, or a software component that provides
    certain functionality, we must solve a particular problem, and build a solution
    for a different, related problem. The decorator pattern is, in many ways, a subset
    of the Adapter pattern, which is restricted to augmenting the existing interface
    of the class of a function with new behavior.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了两种最常用的模式——不仅限于 C++，而且在软件设计的一般领域。适配器模式提供了一种解决广泛设计挑战的方法。这些挑战只有一个最一般的共同属性——给定一个类、一个函数或一个提供特定功能的软件组件，我们必须解决一个特定问题，并为一个不同、相关的问题构建解决方案。在许多方面，装饰器模式是适配器模式的一个子集，它限制于通过添加新行为来增强类或函数的现有接口。
- en: We have seen that the interface conversion and modification done by the adapters
    and decorators can be applied to interfaces at every stage of the program’s life
    - while the most common use is to modify runtime interfaces so that a class can
    be used in a different context, there are also compile-time adapters for generic
    code that allow us to use a class as a building block or a component of a larger,
    more complex, class.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，适配器和装饰器执行的接口转换和修改可以应用于程序生命周期的每个阶段的接口——尽管最常见的用途是修改运行时接口，以便类可以在不同的上下文中使用，但也有编译时适配器用于泛型代码，允许我们将类用作构建块或更大、更复杂类的组件。
- en: The Adapter pattern can be applied to many very different design challenges.
    The varied nature of these challenges and the generality of the pattern itself
    often mean that an alternative solution is possible. Such alternatives often use
    a completely different approach - an entirely different design pattern - but end
    up providing similar behavior. The difference lies in trade-offs, additional conditions,
    and limitations imposed by the chosen approach to the design, and the possibilities
    of extending the solution in different ways. To this end, this chapter offers
    a comparison of two very different design approaches to the same problem, complete
    with an evaluation of the strengths and drawbacks of both options.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式可以应用于许多非常不同的设计挑战。这些挑战的多样性和模式的普遍性通常意味着可能存在另一种解决方案。这些替代方案通常采用完全不同的方法——一个完全不同的设计模式——但最终提供类似的行为。区别在于设计选择带来的权衡、附加条件和限制，以及以不同方式扩展解决方案的可能性。为此，本章提供了对两种非常不同的设计方法进行比较，包括对两种选项的优缺点评估。
- en: The next, penultimate, chapter introduces a pattern that is large, complex,
    and has several interacting components - an appropriate pattern to be left for
    our grand finale - the Visitor pattern.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的，倒数第二个章节，介绍了一个庞大、复杂且具有多个相互作用的组件的模式——这是一个适合作为我们的压轴大戏——访问者模式。
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the Adapter pattern?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是适配器模式？
- en: What is the decorator pattern and how does it differ from the Adapter pattern?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器模式是什么，它与适配器模式有何不同？
- en: The classic OOP implementation of the decorator pattern is usually not recommended
    in C++. Why not?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C++ 中，经典的面向对象（OOP）装饰器模式通常不推荐使用。为什么？
- en: When should the C++ class decorator use inheritance or composition?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下，C++ 类装饰器应该使用继承或组合？
- en: When should the C++ class adapter use inheritance or composition?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下，C++ 类适配器应该使用继承或组合？
- en: C++ provides a general function adapter for currying function arguments, `std::bind`.
    What are its limitations?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ 提供了一个通用的函数适配器用于柯里化函数参数，`std::bind`。它的局限性是什么？
- en: C++11 provides template aliases that can be used as adapters. What are their
    limitations?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++11 提供了模板别名，可以用作适配器。它们的局限性是什么？
- en: Both the adapter and policy patterns can be used to add or modify the public
    interface of a class. Give some reasons for preferring one over the other.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器和策略模式都可以用来添加或修改类的公共接口。给出一些选择其中一个而不是另一个的理由。
