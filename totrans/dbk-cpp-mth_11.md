# 11

# C++向后兼容...甚至与 C

*当然，还有 C，B...甚至 A...和@* *也许吧？*

起初，有语言，语言在 BCPL 中使用。发音为 Basic Combined Programming Language，而不是巴尔的摩县公共图书馆。它是第一种以铁的语法统治编译器王国的语言，经过几轮迭代。然而，时间的考验并不善待它。新特性、教义和语法通过，不久一个新的继承人从比特中崛起：*B*。不是很多人考虑*B*的无类型性质和优势，不久*B*就消失了，因为一个新的编程语言竞争者取代了*B*：*C* 1。

1 [`www.bell-labs.com/usr/dmr/www/chist.html`](https://www.bell-labs.com/usr/dmr/www/chist.html)

其余的都是历史。*C*成为了底层系统编程的事实上的语言，其语法渗透到上个世纪和这个世纪的几乎所有流行编程语言中（你好，花括号）。*C*就像胶水，将各种编程语言粘合在一起，在计算机王国中执行神圣的仪式。

程序员们看了看，觉得它很好。

除了一个普罗米修斯 2 ，一个将类引入*C*的人，很快就会给人们带来*C with classes*和*Cfront*，这是第一个能够消化 C++代码并吐出 C 代码的编译器，遗憾的是它已经从我们的领域消失，但它的遗产仍然存在。这种语言，数十个 C++标准兼容的编译器（每个在其时代都是标准兼容的...或多或少），数百个未定义行为案例，以及过去三十年中标准的各种迭代（最后一个有效的是 C++23，而委员会正在努力最新的 C++26）都在这里，构成了我们所有人都爱的编程语言：C++。

2 是的，Bjarne，我们在谈论你

本章将让你坐得如痴如醉——就像高峰时段的交通——以下是一些主题：

+   C++真的与 C 向后兼容吗？

+   C++真的与 C++向后兼容吗？

# C 真的与 C++向前兼容吗？

本章将进行一些探索，涵盖大多数关于 C++是否真的与 C 向后兼容的陈词滥调。正如我们几十年来被导师、教师和培训师灌输的那样，C++主要与 C 向后兼容。这意味着大部分 C 代码可以在 C++中经过少量修改后编译和运行，因为它们具有相似的语法和标准库。

```cpp
<banalities reason="these were discussed somewhere else">
```

C 和 C++ 虽然可能关系密切，就像一个功能失调的家庭中的两个兄弟姐妹，但仍然存在许多差异，导致在兼容性方面产生爱恨交加的关系。然而，随着时间的推移，这两种语言已经显著分化。根据核心规则，C 在类型规则上更为宽松，特别是关于指针的部分，允许像隐式指针转换这样的结构，而 C++ 则严格禁止。例如，在 C 中，你可以将 **void*** 赋值给任何其他指针类型而不需要类型转换，而 C++ 则会要求显式转换以保持类型安全。

同样，C++（尤其是语言的新版本）在枚举方面有更严格的规则，使它们成为不同的类型，而在 C 中，枚举只是被简单地视为 **int** 。这种差异扩展到许多其他领域：变量初始化、类型限定符，甚至内存分配（***alloc()**）在两种语言中工作方式也不同。这尤其适用于像 **malloc**、**calloc** 等函数。在 C 中，它们只是普通的函数，就像你早晨的一杯咖啡一样平凡，但如果它们出现在任何 C++ 代码中，突然就像打开了一个通往开发者地狱七圈的传送门。这在代码审查期间尤其如此，当时年轻的 C++ 程序员们紧张地抓着键盘，指出你不应该在有完全有效的 **new** 和 **delete** 的情况下使用 C 函数。他们还可能问为什么你需要分配内存。现在是 2024 年。我们有智能指针。或者至少，如果你能控制自己，我们恳求你不要使用 C 风格的类型转换。那是因为 C++ 标准在十多年前就引入了完全功能的类型转换运算符。

根据刚才讨论的内容（但不仅限于此），虽然年轻的 C++ 强调更严格的类型规则和更可预测、更安全的编程实践，但老牌的 C 仍然是一个实用且灵活的选项，尽管风险更大。

让 C++ 程序员感到恐惧的是，这两种语言经常一起使用，尤其是在需要使用用 C 编写的库的 C++ 项目中，但确保两种语言之间的代码兼容性。哦，软件开发的噩梦。

为了帮助上述情况，开发者通常必须使用 **extern "C"** 声明，这防止了 C++ 的名称修饰，并允许在不同方言编写的库之间平滑地链接函数。这是因为，尽管它们有相似之处，但 C 和 C++ 编译器生成的目标文件的处理方式不同（是的，我们谈论的是名称修饰）。

在之前的平实事实之上，此外，还有许多 C99 特定的关键字，如**_Alignas**、**_Alignof**、**_Atomic**、**_Bool**、**_Complex**、**_Generic**、**_Imaginary**、**_Noreturn**和**_Static_assert**，它们不是标准 C++的一部分，尽管一些可能有 C++等价项或可以通过编译器扩展获得。为了使生活更有趣，这些关键字实际上从 C23 开始就被废弃了，这是为了使 C 语言更接近 C++。

我们甚至还没有提到指定初始化器。对他们来说太晚了。

```cpp
</banalities>
```

然而，C 语言的设计肯定不是基于这样的想法：将来会有一种名为 C++的编程语言。这就是为什么下面的 C 代码完全有效，而所有遵纪守法的 C++编译器（以及纯 C++开发者）都会对它感到难以忍受：

```cpp
int template(int this) {
    int class = 0, using = 1, delete;
    if (this == 0) return class;
    if (this == 1) return using;
    for (int friend = 2; friend <= this; friend++) {
        delete = class + using;
        class = using;
        using = delete;
    }
    return delete;
}
```

虽然看起来像是 C 语言深坑中的噩梦，但不管怎样，这段纯 C 代码是完全有效的，而且令人惊讶的是，它甚至可以计算斐波那契数列。但让我们不要对你这个亲爱的读者太过苛刻（尽管考虑到你在这本书中不得不忍受的其他神话般的代码片段，直到你到达这一章，我几乎怀疑这段代码可能会给你带来震惊……不用担心，这是倒数第二章，所以痛苦几乎结束了……然而：你还记得在*第九章*中我们定义 main 为 return，并将 return 定义为 main 吗？），让我们再介绍 C 语言的一个有趣特性，这个特性没有被移植到 C++中。

不，我们不是在谈论变长数组，尽管仅仅由于**void funny_fun(int n, int array[][*])**这种特殊的语法，它们也值得有一系列自己的规则（这种语法是说明如何在函数原型声明中传递二维变长数组的例子）。变长数组在上一个十年中已经被权威人士详细讨论过 3，他们比我们这个谦逊的人更有资格讨论这个问题。不管那些讨论如何，它们（变长数组）仍然没有进入 C++标准，所以这个决定背后肯定有合理的理由（不仅仅是潜在的与栈相关的問題，假设理论上无限的栈，以及非编译时类型推导与变长数组可能引起的类型混乱，还有在 C++中存在处理这种特定用例的更好机制）。

3 [`www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf)

4 [`nullprogram.com/blog/2019/10/27/`](https://nullprogram.com/blog/2019/10/27/)

对于本书的这一章节，我们将讨论一些作者认为非常有用的 C 特定特性，但遗憾的是，这些特性在其原始形式中仍未纳入 C++标准。

## 参数列表的魔法

让我们从最简单的函数开始，那就是**int foo()**。这不是一个非常复杂的函数，但它按照预期完成了工作，无论那是什么。

当以 C 语言编译时，空参数列表的函数意味着该函数可以接受一个未指定的参数数量，如果传递参数给函数，可能会导致歧义和潜在的错误。这是因为编译器不会强制参数约束。

在 C 语言中，要明确指定一个函数不接受任何参数，我们必须在参数列表中使用**void**，例如**int foo(void)**，这清楚地表明该函数不接受任何参数，传递任何参数都会导致编译时错误。

相比之下，C++通过将空参数列表视为指定**void**的等效方式来简化这一点，这意味着 C++中的**int foo()**表示一个不接受任何参数的函数，就像**int foo(void)**一样，这使得在 C++中使用**void**变得可选。

这使得 C++的语法更简洁，其中无参数的函数可以简单地通过空括号声明。虽然 C 仍然需要**void**以保持清晰和正确性，但 C++允许两种形式，尽管典型做法是省略**void**并使用更简单的**int foo()**。这不是很整洁吗？

然而，如果我们想给我们的函数添加一些参数呢？让我们以**int foo(int array[static 10])**的形式修改它。

**int foo(int array[static 10])**的声明是 C99 引入的特性，它向编译器提供了有关传递给函数的参数的额外信息，特别是在处理数组时。

在这种情况下，数组参数中的**static**关键字向编译器表明，**fun**函数预期将使用至少包含 10 个元素的数组进行调用。数字 10 指定了将传递给函数的数组的最低大小，这可以帮助编译器做出某些假设，例如基于数组的保证大小启用优化。

此外，当以这种方式在数组参数中使用**static**时，编译器假定数组指针不能是**NULL**。这是因为空指针意味着没有有效的元素，这违反了数组必须至少包含 10 个元素的条件。这提供了一层额外的安全性和清晰性，因为它消除了函数在继续之前检查数组是否为**NULL**的需要，这可以减少运行时开销。

近期版本的**clang**（基本上是 3.1.0 以上的版本）甚至会在你调用具有这种非常特定声明的函数时发出警告，使用臭名昭著的**NULL**指针：

```cpp
warning: null passed to a callee which requires a non-null argument
```

很遗憾，这个非常实用的特性并没有被任何 C++标准所采纳，而且并非所有的现代 C 编译器都能消化它（我们无法说服 MSVC 成功编译这段代码，无论请求的 C 标准是什么）。无论如何，对于不针对这些平台的程序员来说，在需要的时候这确实可能是一种巨大的帮助。

另一个仅限于 C 程序员圈子中的实用特性是 C99 中引入的**restrict**关键字，它是一个类型限定符，为编译器提供有关优化涉及指针的内存访问的提示。它告诉编译器，应用了**restrict**的指针是当前作用域中访问引用对象（内存）的唯一方式。这允许编译器进行积极的优化，因为它可以假设没有其他指针会别名或引用相同的内存。

当你在指针上使用**restrict**限定符时，你是在向编译器承诺，在指针的生命周期内，它所指向的对象不会被任何其他指针访问。这使编译器能够通过避免不必要的内存重新加载或重新检索来生成更高效的代码，否则这些操作可能由于潜在的别名（多个指针指向同一内存）而需要。

没有使用**restrict**，编译器必须假设任何两个指针都可能引用相同的内存，这限制了它优化代码的能力。

例如，让我们考虑以下代码：

```cpp
void update1(int *a, int *b) {
    *a = *a + *b;
    *b = *b + *a;
}
```

在这种情况下，编译器必须假设***a**和***b**可能会相互别名，因此它可能需要从内存中重新加载***a**或***b**。

这是它的**restrict**对应版本：

```cpp
void update2(int *restrict a, int *restrict b) {
    *a = *a + *b;
    *b = *b + *a;
}
```

在这种情况下，我们告诉编译器***a**和***b**不会别名，因此它可以优化而不必担心内存别名。

以下列表（由**GCC** 14.2 生成，使用**–O3**优化）是两个不同函数生成的汇编代码，其中包含一些解释：

```cpp
update1:
  mov eax, DWORD PTR [rsi]; Load b from [rsi] into eax
  add eax, DWORD PTR [rdi]; Add a from [rdi] to eax
  mov DWORD PTR [rdi], eax; Store eax into [rdi] (a)
  add DWORD PTR [rsi], eax; Add eax to [rsi] (b)
  ret                     ; Return
```

这是另一个例子：

```cpp
update2:
  mov eax, DWORD PTR [rsi]; Load b from [rsi] into eax
  mov edx, DWORD PTR [rdi]; Load a from [rdi] into edx
  add edx, eax            ; eax + edx (result in edx) - a
  add eax, edx            ; edx + eax (result in eax) - b
  mov DWORD PTR [rdi], edx; Store edx into [rdi] - a
  mov DWORD PTR [rsi], eax; Store eax into [rsi] - b
  ret                     ; Return
```

令人惊讶的是，带有**restrict**的那个版本有更多的指令，但一旦我们查看生成的代码，我们就可以轻松地发现**restrict**关键字的效果。据称，函数的参数位于由**[rsi]**和**[rdi]**指向的内存位置。第一个（没有**restrict**）必须在内存中完成所有加法工作，这导致代码略微变慢，而第二个可以将这些昂贵的操作委托给两个基于寄存器的超快速加法操作。

此外，这两个标准之间的一大区别是，第二个（**update2**，带有**restrict**）可以假设第二个参数的值在第一次操作后不会改变，因此精心设计的寄存器初始化和加法可以发挥至关重要的作用。第一个需要考虑**a = *a + *b;**操作可能会改变**b**的值（见**[rsi]**）。因此，它需要在内存中执行操作，始终使当前值对即将进行的操作可用。

对于像这些简单的加法这样的简单操作，效果和结果可能不如更大示例那样引人注目，这个更大示例在这个书中没有足够的空间，但我们仍然有足够的证据表明**restrict**关键字对生成的代码有实际的影响。遗憾的是，这个特性也没有被纳入 C++。

然而，对 C++及其与 C 的不兼容性的批评已经足够了。它们从未打算相互竞争，而是相互补充。让我们转向更有趣的领域。C++真的与自身兼容吗？

# 空白字符很重要——直到它们不重要

以下代码片段并不特别复杂：

```cpp
#include <cstdio>
#define STR_I(x) #x
#define STR(x) STR_I(x)
#define JOIN(x,y) (x y)
#define Hello(x) HELLO
int main(void){
    printf("%s\n", STR(JOIN(Hello, World)));
    printf("%s\n", STR(JOIN(Hello,World )));
}
```

这段不太复杂的代码定义了一系列宏来操作字符串和连接标记符。**STR_I(x)**将它的参数字符串化，**STR(x)**确保在字符串化之前进行完整的宏展开，**JOIN(x,y)**通过空格连接两个参数，而**Hello(x)**被定义了，但奇怪的是，没有被使用。

在这个简短程序的生命周期中，最关键的两次**printf**调用出现了。在第一次**printf**调用中，**JOIN(Hello, World)**展开为**(Hello World)**，然后被字符串化为**"(Hello World)"**。这并不复杂。

然而，有趣的部分现在来了：在第二个**printf**调用中，**JOIN(Hello,World)**（在逗号和**World**之间没有空格）的行为取决于 GCC 版本。

在 GCC 9.4（及以下版本）中，这会导致**(HelloWorld)**没有空格，而在 GCC 9.5（及以上版本）中，预处理程序在标记符之间添加空格，使得两个**printf**调用都产生**"(** **Hello World)"**。

GCC 9.4 和 9.5 之间的这种差异源于每个版本处理标记符连接和宏参数之间的空白字符的方式，GCC 9.4 在没有明确给出空白字符的地方不会插入空格，而 GCC 9.5 通过在宏调用中省略空格时也添加空格，使其处理更加一致。

虽然 C 和 C++标准没有明确说明“宏参数和逗号之间的空白字符被忽略”，但这是通过预处理程序处理标记化和宏展开的方式暗示的。无论如何，规则规定参数通过逗号分隔，空白字符不影响这种分隔。似乎 GCC（在 9.4 之前）对缺乏规定的解释比较宽松，这在 GCC 9.5 及以后版本中被重新解释。

整个误解是由一个名为**Hello**的宏的存在引起的，它被定义为一个函数式宏，但被用作一个普通的替换宏。高度可能的是，主要问题（或者更确切地说，曾经是）是较旧 GCC 的一个错误，因为我们确实不再使用它了，因为我们都清楚，新的编译器更符合标准，而且我们当然都编写符合标准的代码，不是吗？

这是一段有趣的历史性向前兼容性。

## 第 11 位客人

C++11 带来了一系列新特性，同时保持了与 C++98 的向后兼容性，确保开发人员可以增量地采用现代功能，而不会破坏现有代码。其中最具变革性的新增功能之一是**移动语义**，它引入了一些 C++98 编译器无法处理的语法。这得益于右值引用的语法，这种语法同样不被旧编译器支持。

同样，**auto**关键字通过自动推断类型简化了类型声明，但开发人员仍然可以继续使用它来显式指定变量具有自动存储，就像他们在 C++98 中从未这样做过一样。这个选择是因为，让我们承认吧，没有人真正使用过 auto，就像它在 C 语言中（它从中继承而来，即使在 C 语言中它也毫无用处，除非在它起源的 B 语言中，它正确地表示变量的存储：栈）。

新的语法，如**基于范围的 for 循环**，允许对容器进行更简洁的迭代，但幸运的是，C++98 的经典**for**循环仍然完全有效，因为很多人还在使用它们。**nullptr**的引入用类型安全的替代品替换了旧的**NULL**宏，尽管为了向后兼容，**NULL**仍然被支持，尽管它与 0 并没有太大的不同。

除了这些核心语言改进之外，C++11 引入了现代函数式编程特性，如**lambda 表达式**，这使得匿名函数可以内联编写，从而简化了代码，使其更加简洁。

新的**constexpr**特性允许某些函数在编译时进行评估，从而提供性能改进，但开发人员仍然可以通过使用过于复杂的模板递归来依赖 C++98 的运行时函数评估方法，因为，嗯，**constexpr**也不被旧编译器支持。

然而，对于 C++ 的老用户来说，没有一个突破性的变化比 C++ 模板的双右尖括号解析变化更令人困惑。在 C++98 中，当使用嵌套模板参数时，解析器需要在连续的右尖括号（**>>**）之间要求空格，以区分它们与位移运算符（**>>**）。这是必要的，因为在 C++98 中，解析器会将两个连续的**>**符号解释为位右移运算符，而不是两个嵌套模板的结束。

在 C++11 及以后的版本中，编译器足够智能，能够识别在这个上下文中，**>>** 指的是关闭两个嵌套模板括号，而不是执行右移操作。这使得语法更简洁，更不容易出错，因为开发者不再需要在嵌套模板表达式中手动添加空格。然而，这也不幸地意味着以下程序将根据它是否是用支持 C++11 标准的编译器还是只支持 C++98 的编译器编译而显示不同的值：

```cpp
#include <iostream>
const int value = 1;
template <class T>
struct D {
    operator bool() {return true;}
    static const int value = 2;
};
template<int t> struct C {
    typedef int value ;
};
int main() {
    const int x = 1;
    if(D<C< ::value>>::value>::value>::value) {
        std::cout << "C++98 compiler";
    } else {
        std::cout << "C++11 compiler";
    }
}
```

当我们深入挖掘程序的复杂性时，它为什么会有这种奇怪的行为是非常清晰的。如果还不清楚，让我们来分解一下。

好吧，我们就不分解整个程序了。那会太长了。相反，我们将专注于 **D<C< ::value>>::value>::value>::value** ，这是所有功能识别的关键。

使用 C++98 语法，这将按以下方式解析：

```cpp
if(static_cast<bool>(D<int>::value)) { ... }
```

因此，这一切都归结为 **D<int>::value** 的值，因为 **::value>>::value** 将被解析为 **1 >> 1** ，结果为 **0** 。这进入 **C<0>::value** ，它是一个简单的 **typedef** 到 **int** 。从那里，我们到达 **D<int>::value** 。

由于我们将其定义为 **2** ，**if** 当然是 **true** ，并且我们已经执行了 C++98 识别分支。

然而，当用符合 C++11 标准的编译器解析代码时，表达式将被解析为以下稍微复杂一些的表达式：

```cpp
if((static_cast<int>(D<C<1> >::value > ::value)) > ::value) { ... }
```

由于长而复杂的右尖括号集合可能不明显，最终，这将被解析为两个比较。这是因为接下来的 **D<C<1>>::value** 结果为 **2**（因为 **C<1>** 也是一个类型，所以我们最终进入了一个具有 **C<1>** 的 **D** 类的特化）。然后，它与 **::value** 进行比较，结果为真 **(2>1)** 。从这个结果出发，经过一系列有趣的转换，最终结果看起来像 **1>1** 。这结果是 **false**；因此，我们进入 C++11 分支。

在这种情况下，我们有一种既简洁又短，尽管过于复杂且无用的方法来识别我们的代码是否是用符合 C++11 标准的编译器编译的。然而，检查 **__cplusplus** 的值比这要简单得多，并且应该在任何生产就绪的代码中使用。

# 自动惊喜

如果你，亲爱的读者，还记得在 *第九章* 中，我们有一个有趣的章节叫做 *零的定义* ，那么一切都很顺利。那是因为我们的下一个话题将再次涉及这个极具影响力的数字。如果你不记得那章，那么生活仍然很好，因为希望你已经购买了一本包含所有章节的全书，你可以翻到那一页再读一遍（再次）。

让我们考虑以下程序：

```cpp
#include <iostream>
#include <typeinfo>
#include <string>
template<typename T> std::string typeof(T t) {
    std::string res = typeid(t).name();
    return res;
}
int main() {
    auto a1 = 0;
    auto a2(0);
    auto a3 {0};
    auto a4 = {0};
    std::cout << typeof(a1) << std::endl
            << typeof(a2) << std::endl
            << typeof(a3) << std::endl
            << typeof(a4) << std::endl;
}
```

程序并不是特别复杂。它只是使用了花哨的 **auto** 关键字，并使用各种机制将变量初始化为 **0**，这些机制主要在前面提到的章节中介绍。如果你不知道 **auto** 关键字的作用，这里有一个简短的回顾：C++11 中的 **auto** 关键字是从 C 中劫持的，它的新角色是允许自动类型推断，使编译器能够根据初始化器推导出变量的类型。这通过消除显式类型声明的需要来简化代码，并缩短处理复杂或冗长的类型（如迭代器或模板类型）的处理。

总之，回到我们的代码。经过仔细考虑，我们可以得出以下结论：

+   **auto a1 = 0;** : 对于这个简单的情况，**a1** 被推导为 **int** 类型，因为 0 是一个整型字面量。这是一个直接的复制初始化。

+   **auto a2(0);** : 再次，这是一个简单的例子，**a2** 也被推导为 **int** 类型，因为 0 是直接初始化为一个整型字面量。

+   **auto a3 {0};** : 然后，**a3** 被推导为 **int** 类型，因为 **{0}** 列表初始化将其初始化为一个整数。

+   **auto a4 = {0};** : 然而，这个例子有点棘手。在这种情况下，**a4** 被推导为 **std::initializer_list<int>** 类型，因为使用花括号初始化的 **auto** 会推导出一个 **initializer_list**。这是 **auto** 与花括号包围的初始化器一起使用时的一个特殊规则。

使用 MSVC 编译的程序输出如下：

```cpp
int
int
int
class std::initializer_list<int>
```

使用 GCC（较新/较好的版本），输出将稍微简洁一些，但你的想法应该是这样的：

```cpp
i
i
i
St16initializer_listIiE
```

然而，有一个陷阱。如果我们用版本低于 5.0 的 GCC 编译这段代码，我们会得到一个令人不快的惊喜。输出如下：

```cpp
i
i
St16initializer_listIiE
St16initializer_listIiE
```

多么意外的向后兼容性惊喜。真正的帮助来自 clang（3.7）。如果我们用它编译程序，我们会得到以下相当有用的消息：

```cpp
<source>:19:13: warning: direct list initialization of a variable with a deduced type will change meaning in a future version of Clang; insert an '=' to avoid a change in behavior [-Wfuture-compat]
    auto a3 {0};
```

因此，似乎在其演变过程中，**{x}** 与 **auto** 结合但不是 **=** 的意义在特定场景下发生了变化（大约在 C++17 诞生之时）。然而，幸运的是，早期的编译器已经考虑了这种特殊场景，并给出了非常具体且直接的警告。这不是非常向后兼容，对吧？

所以，考虑到所有这些，以下代码甚至无法编译（考虑到我们仍然在我们之前的简短程序的限制内）并不令人惊讶：

```cpp
std::cout << typeof( {0} );
```

它为什么会这样？考虑到前面的语法混乱和混乱，**{0}** 会推导为哪种类型？会是 **int** 类型吗？或者可能是 **initializer_list** 类型？它会是空指针（**nullptr**）吗？或者是一个可以从数字构建的对象，如下所示：

```cpp
struct D { D(int i) {} };
void fun(D d) { }
fun({0});
```

或者，这不再那么有趣了吗？

# 总结

在本章中，我们了解到 C++ 已经与其谦逊的 C（以及 B 和 BCPL）起源发生了显著的发展和分歧。我们了解到 C++ 引入了现代特性和更严格的规则，以增强安全性和效率，并支持现代编程范式。尽管它保持了 C 的大部分语法，但随着时间的推移，这两种语言已经严重分叉，导致兼容性挑战，尤其是在将较老的 C 代码与需要较新 C++ 标准的功能混合时。我们在这章中对此进行了广泛讨论。

在现代 C++ 本身中，引入了诸如移动语义、更严格的模板解析以及诸如 **auto** 等关键字行为的变化，这些都增加了复杂性（尽管之前并不缺乏）。我们也在本章中学到了这一点。

尽管面临这些挑战，我们探讨了这样一个事实：C++ 仍然在构建其丰富的遗产之上，为开发者提供强大的工具，同时需要仔细关注不断发展的标准和向后兼容性，而不会与其先前的自我产生太多矛盾。它仍然是一种传统与创新交汇的语言，常常以意想不到且令人着迷的方式相遇。

但这会持续多久呢？它能否经受住新来者的威胁？Rust 会取代 C++ 吗？这取决于您，亲爱的读者，而 Alex 将在下一章中详细讨论这一点。
