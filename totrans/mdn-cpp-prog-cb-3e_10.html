<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer149">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 class="chapterTitle" id="_idParaDest-632"><span class="koboSpan" id="kobo.2.1">Implementing Patterns and Idioms</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Design patterns are general reusable solutions that can be applied to common problems that appear in software development. </span><span class="koboSpan" id="kobo.3.2">Idioms are patterns, algorithms, or ways to structure the code in one or more programming languages. </span><span class="koboSpan" id="kobo.3.3">A great number of books has been written on design patterns. </span><span class="koboSpan" id="kobo.3.4">This chapter is not intended to reiterate them, but rather to show how to implement several useful patterns and idioms, with a focus on readability, performance, and robustness, in terms of modern C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">The recipes included in this chapter are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5.1">Avoiding repetitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.6.1">if-else</span></code><span class="koboSpan" id="kobo.7.1"> statements in factory patterns</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Implementing the pimpl idiom</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Implementing the named parameter idiom</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Separating interfaces and implementations with the non-virtual interface idiom</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Handling friendship with the attorney-client idiom</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Static polymorphism with the curiously recurring template pattern</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Adding functionality to classes with mixins</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Handling unrelated types generically with the type erasure idiom</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Implementing a thread-safe singleton</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.16.1">The first recipe of this chapter presents a simple mechanism for avoiding repetitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">if-else</span></code><span class="koboSpan" id="kobo.18.1"> statements. </span><span class="koboSpan" id="kobo.18.2">Let’s explore how this mechanism works.</span></p>
<h1 class="heading-1" id="_idParaDest-633"><span class="koboSpan" id="kobo.19.1">Avoiding repetitive if-else statements in factory patterns</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.20.1">It is often</span><a id="_idIndexMarker1237"/><span class="koboSpan" id="kobo.21.1"> the case that we end up writing repetitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">if...else</span></code><span class="koboSpan" id="kobo.23.1"> statements (or an equivalent </span><code class="inlineCode"><span class="koboSpan" id="kobo.24.1">switch</span></code><span class="koboSpan" id="kobo.25.1"> statement) that do similar things, often with little variation and often done by copying and pasting with </span><a id="_idIndexMarker1238"/><span class="koboSpan" id="kobo.26.1">small changes. </span><span class="koboSpan" id="kobo.26.2">As the number of alternative conditions increases, the code becomes both hard to read and hard to maintain. </span><span class="koboSpan" id="kobo.26.3">Repetitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.27.1">if...else</span></code><span class="koboSpan" id="kobo.28.1"> statements can be replaced with various techniques, such as polymorphism. </span><span class="koboSpan" id="kobo.28.2">In this recipe, we will see how to avoid </span><code class="inlineCode"><span class="koboSpan" id="kobo.29.1">if...else</span></code><span class="koboSpan" id="kobo.30.1"> statements in factory patterns (a factory is a function or object that is used to create other objects) using a map of functions.</span></p>
<h2 class="heading-2" id="_idParaDest-634"><span class="koboSpan" id="kobo.31.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.32.1">In this recipe, we will consider the following problem: building a system that can handle image files in various formats, such as bitmap, PNG, JPG, and so on. </span><span class="koboSpan" id="kobo.32.2">Obviously, the details are beyond the scope of this recipe; the part we are concerned with is creating objects that handle various image formats. </span><span class="koboSpan" id="kobo.32.3">For this, we will consider the following hierarchy of classes:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.33.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.34.1">Image</span></span><span class="koboSpan" id="kobo.35.1"> {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.36.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.37.1">BitmapImage</span></span><span class="koboSpan" id="kobo.38.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.39.1">public</span></span><span class="koboSpan" id="kobo.40.1"> Image {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.41.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.42.1">PngImage</span></span><span class="koboSpan" id="kobo.43.1">    : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.44.1">public</span></span><span class="koboSpan" id="kobo.45.1"> Image {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.46.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.47.1">JpgImage</span></span><span class="koboSpan" id="kobo.48.1">    : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.49.1">public</span></span><span class="koboSpan" id="kobo.50.1"> Image {};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.51.1">On the other hand, we’ll define an interface for a factory class that can create instances of the aforementioned classes, as well as a typical implementation using </span><code class="inlineCode"><span class="koboSpan" id="kobo.52.1">if...else</span></code><span class="koboSpan" id="kobo.53.1"> statements:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.54.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.55.1">IImageFactory</span></span><span class="koboSpan" id="kobo.56.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.57.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.58.1"> std::unique_ptr&lt;Image&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.59.1">Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.60.1">(std::string_view type)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.61.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.62.1">0</span></span><span class="koboSpan" id="kobo.63.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.64.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.65.1">ImageFactory</span></span><span class="koboSpan" id="kobo.66.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.67.1">public</span></span><span class="koboSpan" id="kobo.68.1"> IImageFactory
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.69.1">std::unique_ptr&lt;Image&gt; </span></span>
<span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.70.1">Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.71.1">(std::string_view type)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.72.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.73.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.74.1">if</span></span><span class="koboSpan" id="kobo.75.1"> (type == </span><span class="hljs-string"><span class="koboSpan" id="kobo.76.1">"bmp"</span></span><span class="koboSpan" id="kobo.77.1">)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.78.1">return</span></span><span class="koboSpan" id="kobo.79.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.80.1">make_unique</span></span><span class="koboSpan" id="kobo.81.1">&lt;BitmapImage&gt;();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.82.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.83.1">if</span></span><span class="koboSpan" id="kobo.84.1"> (type == </span><span class="hljs-string"><span class="koboSpan" id="kobo.85.1">"png"</span></span><span class="koboSpan" id="kobo.86.1">)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.87.1">return</span></span><span class="koboSpan" id="kobo.88.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.89.1">make_unique</span></span><span class="koboSpan" id="kobo.90.1">&lt;PngImage&gt;();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.91.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.92.1">if</span></span><span class="koboSpan" id="kobo.93.1"> (type == </span><span class="hljs-string"><span class="koboSpan" id="kobo.94.1">"jpg"</span></span><span class="koboSpan" id="kobo.95.1">)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.96.1">return</span></span><span class="koboSpan" id="kobo.97.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.98.1">make_unique</span></span><span class="koboSpan" id="kobo.99.1">&lt;JpgImage&gt;();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.100.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.101.1">nullptr</span></span><span class="koboSpan" id="kobo.102.1">;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.103.1">The goal </span><a id="_idIndexMarker1239"/><span class="koboSpan" id="kobo.104.1">of this recipe is to see how this implementation can be refactored to avoid repetitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">if...else</span></code><span class="koboSpan" id="kobo.106.1"> statements.</span></p>
<h2 class="heading-2" id="_idParaDest-635"><span class="koboSpan" id="kobo.107.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.108.1">Perform the</span><a id="_idIndexMarker1240"/><span class="koboSpan" id="kobo.109.1"> following steps to refactor the factory shown earlier to avoid using </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">if...else</span></code><span class="koboSpan" id="kobo.111.1"> statements:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.112.1">Implement the factory interface:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.113.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.114.1">ImageFactory</span></span><span class="koboSpan" id="kobo.115.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.116.1">public</span></span><span class="koboSpan" id="kobo.117.1"> IImageFactory
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.118.1">std::unique_ptr&lt;Image&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.119.1">Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.120.1">(std::string_view type)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.121.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.122.1">{ 
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.123.1">// continued with 2. </span><span class="koboSpan" id="kobo.123.2">and 3.</span></span><span class="koboSpan" id="kobo.124.1">
  }
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.125.1">Define a map where the key is the type of objects to create and the value is a function that creates objects:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.126.1">static</span></span><span class="koboSpan" id="kobo.127.1"> std::map&lt;
  std::string,
  std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;&gt; mapping
{
  { </span><span class="hljs-string"><span class="koboSpan" id="kobo.128.1">"bmp"</span></span><span class="koboSpan" id="kobo.129.1">, []() {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.130.1">return</span></span><span class="koboSpan" id="kobo.131.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.132.1">make_unique</span></span><span class="koboSpan" id="kobo.133.1">&lt;BitmapImage&gt;(); } },
  { </span><span class="hljs-string"><span class="koboSpan" id="kobo.134.1">"png"</span></span><span class="koboSpan" id="kobo.135.1">, []() {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">return</span></span><span class="koboSpan" id="kobo.137.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.138.1">make_unique</span></span><span class="koboSpan" id="kobo.139.1">&lt;PngImage&gt;(); } },
  { </span><span class="hljs-string"><span class="koboSpan" id="kobo.140.1">"jpg"</span></span><span class="koboSpan" id="kobo.141.1">, []() {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.142.1">return</span></span><span class="koboSpan" id="kobo.143.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.144.1">make_unique</span></span><span class="koboSpan" id="kobo.145.1">&lt;JpgImage&gt;(); } }
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.146.1">To create an object, look up the object type in the map and, if it is found, use the associated function to create a new instance of the type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">auto</span></span><span class="koboSpan" id="kobo.148.1"> it = mapping.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.149.1">find</span></span><span class="koboSpan" id="kobo.150.1">(type.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.151.1">data</span></span><span class="koboSpan" id="kobo.152.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.153.1">if</span></span><span class="koboSpan" id="kobo.154.1"> (it != mapping.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.155.1">end</span></span><span class="koboSpan" id="kobo.156.1">())
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.157.1">return</span></span><span class="koboSpan" id="kobo.158.1"> it-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.159.1">second</span></span><span class="koboSpan" id="kobo.160.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.161.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.162.1">nullptr</span></span><span class="koboSpan" id="kobo.163.1">;
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-636"><span class="koboSpan" id="kobo.164.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.165.1">The </span><a id="_idIndexMarker1241"/><span class="koboSpan" id="kobo.166.1">repetitive </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">if...else</span></code><span class="koboSpan" id="kobo.168.1"> statements</span><a id="_idIndexMarker1242"/><span class="koboSpan" id="kobo.169.1"> in the first implementation are very similar – they check the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">type</span></code><span class="koboSpan" id="kobo.171.1"> parameter and create an instance of the appropriate </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">Image</span></code><span class="koboSpan" id="kobo.173.1"> class. </span><span class="koboSpan" id="kobo.173.2">If the argument to check was an integral type (for instance, an enumeration type), the sequence of </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">if...else</span></code><span class="koboSpan" id="kobo.175.1"> statements could have also been written in the form of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.176.1">switch</span></code><span class="koboSpan" id="kobo.177.1"> statement. </span><span class="koboSpan" id="kobo.177.2">That code can be used like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.178.1">auto</span></span><span class="koboSpan" id="kobo.179.1"> factory = ImageFactory{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.180.1">auto</span></span><span class="koboSpan" id="kobo.181.1"> image = factory.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.182.1">Create</span></span><span class="koboSpan" id="kobo.183.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.184.1">"png"</span></span><span class="koboSpan" id="kobo.185.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.186.1">Regardless of whether the implementation was using </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">if...else</span></code><span class="koboSpan" id="kobo.188.1"> statements or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">switch</span></code><span class="koboSpan" id="kobo.190.1">, refactoring to avoid repetitive checks is relatively simple. </span><span class="koboSpan" id="kobo.190.2">In the refactored code, we used a map that has the key type </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">std::string</span></code><span class="koboSpan" id="kobo.192.1"> representing the type, that is, the name of the image format. </span><span class="koboSpan" id="kobo.192.2">The value is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;</span></code><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">This is a wrapper for a function that takes no arguments and returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">std::unique_ptr&lt;Image&gt;</span></code><span class="koboSpan" id="kobo.196.1"> (a </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">unique_ptr</span></code><span class="koboSpan" id="kobo.198.1"> of a derived class is implicitly converted to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">unique_ptr</span></code><span class="koboSpan" id="kobo.200.1"> of a base class).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">Now that we have this map of functions that create objects, the actual implementation of the factory is much simpler; check the type of the object to be created in the map and, if present, use the associated value from the map as the actual function to create the object, or return </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">nullptr</span></code><span class="koboSpan" id="kobo.203.1"> if the object type is not present in the map.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.204.1">This refactoring is transparent for the client code, as there are no changes in the way clients use the factory. </span><span class="koboSpan" id="kobo.204.2">On the other hand, this approach does require more memory to handle the static map, which, for some classes of applications, such as IoT, might be an important aspect. </span><span class="koboSpan" id="kobo.204.3">The example presented here is relatively simple because the purpose is to demonstrate the concept. </span><span class="koboSpan" id="kobo.204.4">In real-world code, it might be necessary to create objects differently, such as using a different number of arguments and different types of arguments. </span><span class="koboSpan" id="kobo.204.5">However, this is not specific to the refactored implementation, and the solution with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">if...else</span></code><span class="koboSpan" id="kobo.206.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">switch</span></code><span class="koboSpan" id="kobo.208.1"> statement needs to account for that too. </span><span class="koboSpan" id="kobo.208.2">Therefore, in practice, the </span><a id="_idIndexMarker1243"/><span class="koboSpan" id="kobo.209.1">solution to this problem that worked with </span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">if...else</span></code><span class="koboSpan" id="kobo.211.1"> statements should also work with the map.</span></p>
<h2 class="heading-2" id="_idParaDest-637"><span class="koboSpan" id="kobo.212.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.213.1">In the preceding</span><a id="_idIndexMarker1244"/><span class="koboSpan" id="kobo.214.1"> implementation, the map is a local static to the virtual function, but it can also be a member of the class or even a global. </span><span class="koboSpan" id="kobo.214.2">The following implementation has the map defined as a static member of the class. </span><span class="koboSpan" id="kobo.214.3">The objects are not created based on the format name, but on the type information, as returned by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">typeid</span></code><span class="koboSpan" id="kobo.216.1"> operator:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.217.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.218.1">IImageFactoryByType</span></span><span class="koboSpan" id="kobo.219.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.220.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.221.1"> std::unique_ptr&lt;Image&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.222.1">Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.223.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.224.1">    std::type_info </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.225.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.226.1"> &amp; type)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.227.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.228.1">0</span></span><span class="koboSpan" id="kobo.229.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.230.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.231.1">ImageFactoryByType</span></span><span class="koboSpan" id="kobo.232.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.233.1">public</span></span><span class="koboSpan" id="kobo.234.1"> IImageFactoryByType
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.235.1">std::unique_ptr&lt;Image&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.236.1">Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.237.1">(std::type_info </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.238.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.239.1"> &amp; type)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.240.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.241.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.242.1">auto</span></span><span class="koboSpan" id="kobo.243.1"> it = mapping.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.244.1">find</span></span><span class="koboSpan" id="kobo.245.1">(&amp;type);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.246.1">if</span></span><span class="koboSpan" id="kobo.247.1"> (it != mapping.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.248.1">end</span></span><span class="koboSpan" id="kobo.249.1">())
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">return</span></span><span class="koboSpan" id="kobo.251.1"> it-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.252.1">second</span></span><span class="koboSpan" id="kobo.253.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.254.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.255.1">nullptr</span></span><span class="koboSpan" id="kobo.256.1">;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.257.1">private</span></span><span class="koboSpan" id="kobo.258.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.259.1">static</span></span><span class="koboSpan" id="kobo.260.1"> std::map&lt;
    std::type_info </span><span class="hljs-type"><span class="koboSpan" id="kobo.261.1">const</span></span><span class="koboSpan" id="kobo.262.1"> *,
    std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;&gt; mapping;
};
std::map&lt;
  std::type_info </span><span class="hljs-type"><span class="koboSpan" id="kobo.263.1">const</span></span><span class="koboSpan" id="kobo.264.1"> *,
  std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;&gt; ImageFactoryByType::mapping
{
  {&amp;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.265.1">typeid</span></span><span class="koboSpan" id="kobo.266.1">(BitmapImage),[](){
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.267.1">return</span></span><span class="koboSpan" id="kobo.268.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.269.1">make_unique</span></span><span class="koboSpan" id="kobo.270.1">&lt;BitmapImage&gt;();}},
  {&amp;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.271.1">typeid</span></span><span class="koboSpan" id="kobo.272.1">(PngImage),   [](){
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.273.1">return</span></span><span class="koboSpan" id="kobo.274.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.275.1">make_unique</span></span><span class="koboSpan" id="kobo.276.1">&lt;PngImage&gt;();}},
  {&amp;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.277.1">typeid</span></span><span class="koboSpan" id="kobo.278.1">(JpgImage),   [](){
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.279.1">return</span></span><span class="koboSpan" id="kobo.280.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.281.1">make_unique</span></span><span class="koboSpan" id="kobo.282.1">&lt;JpgImage&gt;();}}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.283.1">In this case, the client code is slightly different, because instead of passing a name representing the type to create, such as PNG, we pass the value returned by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">typeid</span></code><span class="koboSpan" id="kobo.285.1"> operator, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">typeid(PngImage)</span></code><span class="koboSpan" id="kobo.287.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.288.1">auto</span></span><span class="koboSpan" id="kobo.289.1"> factory = ImageFactoryByType{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.290.1">auto</span></span><span class="koboSpan" id="kobo.291.1"> movie = factory.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.292.1">Create</span></span><span class="koboSpan" id="kobo.293.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.294.1">typeid</span></span><span class="koboSpan" id="kobo.295.1">(PngImage));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.296.1">This </span><a id="_idIndexMarker1245"/><span class="koboSpan" id="kobo.297.1">alternative is arguably more robust because the map keys are not strings, which could be more prone to errors. </span><span class="koboSpan" id="kobo.297.2">This</span><a id="_idIndexMarker1246"/><span class="koboSpan" id="kobo.298.1"> recipe proposes a pattern as the solution to a common problem, and not an actual implementation. </span><span class="koboSpan" id="kobo.298.2">As in the case of most patterns, there are different ways they can be implemented, and it is up to you to pick the one that is the most suitable for each context.</span></p>
<h2 class="heading-2" id="_idParaDest-638"><span class="koboSpan" id="kobo.299.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.300.1">Implementing the pimpl idiom,</span></em><span class="koboSpan" id="kobo.301.1"> to learn a technique that enables the separation of the implementation details from an interface</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.302.1">Chapter 9</span></em><em class="italic"><span class="koboSpan" id="kobo.303.1">, Using unique_ptr to uniquely own a memory resource</span></em><span class="koboSpan" id="kobo.304.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.306.1"> class, which represents a smart pointer that owns and manages another object or array of objects allocated on the heap</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-639"><span class="koboSpan" id="kobo.307.1">Implementing the pimpl idiom</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.308.1">pimpl</span></strong><span class="koboSpan" id="kobo.309.1"> stands for </span><strong class="keyWord"><span class="koboSpan" id="kobo.310.1">pointer to implementation</span></strong><span class="koboSpan" id="kobo.311.1"> (also known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.312.1">Cheshire cat idiom</span></strong><span class="koboSpan" id="kobo.313.1"> or the </span><strong class="keyWord"><span class="koboSpan" id="kobo.314.1">compiler firewall idiom</span></strong><span class="koboSpan" id="kobo.315.1">) and is an </span><a id="_idIndexMarker1247"/><span class="koboSpan" id="kobo.316.1">opaque pointer technique that enables the separation of the implementation details from an interface. </span><span class="koboSpan" id="kobo.316.2">This has the advantage that it enables changing the implementation without modifying the interface and, therefore, avoiding the need to recompile the code that is using the interface. </span><span class="koboSpan" id="kobo.316.3">This has the potential of making libraries using the pimpl idiom on their ABIs backward-compatible with older versions when only implementation details change. </span><span class="koboSpan" id="kobo.316.4">In this recipe, we will see how to implement the pimpl idiom using modern C++ features.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.317.1">The term </span><strong class="keyWord"><span class="koboSpan" id="kobo.318.1">ABI</span></strong><span class="koboSpan" id="kobo.319.1"> stands for </span><strong class="keyWord"><span class="koboSpan" id="kobo.320.1">Application Binary Interface</span></strong><span class="koboSpan" id="kobo.321.1">, and refers to the interface between two binary modules. </span><span class="koboSpan" id="kobo.321.2">Typically, one such module is a library or operating system, and the other is a program executed by a user.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-640"><span class="koboSpan" id="kobo.322.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.323.1">The reader</span><a id="_idIndexMarker1248"/><span class="koboSpan" id="kobo.324.1"> is expected to be familiar with smart pointers and </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">std::string_view</span></code><span class="koboSpan" id="kobo.326.1">, both of which were discussed in previous chapters of this book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.327.1">To demonstrate the pimpl idiom in a practical manner, we will consider the following class, which we will then refactor following the pimpl pattern:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.328.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.329.1">control</span></span><span class="koboSpan" id="kobo.330.1">
{
  std::string text;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.331.1">int</span></span><span class="koboSpan" id="kobo.332.1"> width = </span><span class="hljs-number"><span class="koboSpan" id="kobo.333.1">0</span></span><span class="koboSpan" id="kobo.334.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.335.1">int</span></span><span class="koboSpan" id="kobo.336.1"> height = </span><span class="hljs-number"><span class="koboSpan" id="kobo.337.1">0</span></span><span class="koboSpan" id="kobo.338.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.339.1">bool</span></span><span class="koboSpan" id="kobo.340.1"> visible = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.341.1">true</span></span><span class="koboSpan" id="kobo.342.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.343.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.344.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.345.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.346.1">{
    std::cout 
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.347.1">"control "</span></span><span class="koboSpan" id="kobo.348.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.349.1">'\n'</span></span><span class="koboSpan" id="kobo.350.1">
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.351.1">" visible: "</span></span><span class="koboSpan" id="kobo.352.1"> &lt;&lt; std::boolalpha &lt;&lt; visible &lt;&lt; 
         std::noboolalpha &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.353.1">'\n'</span></span><span class="koboSpan" id="kobo.354.1">
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.355.1">" size: "</span></span><span class="koboSpan" id="kobo.356.1"> &lt;&lt; width &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.357.1">", "</span></span><span class="koboSpan" id="kobo.358.1"> &lt;&lt; height &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.359.1">'\n'</span></span><span class="koboSpan" id="kobo.360.1">
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.361.1">" text: "</span></span><span class="koboSpan" id="kobo.362.1"> &lt;&lt; text &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.363.1">'\n'</span></span><span class="koboSpan" id="kobo.364.1">;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.365.1">public</span></span><span class="koboSpan" id="kobo.366.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.367.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.368.1">set_text</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.369.1">(std::string_view t)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.370.1">{
    text = t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.371.1">data</span></span><span class="koboSpan" id="kobo.372.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.373.1">draw</span></span><span class="koboSpan" id="kobo.374.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.375.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.376.1">resize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.377.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.378.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.379.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.380.1"> w, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.381.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.382.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.383.1"> h)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.384.1">{
    width = w;
    height = h;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.385.1">draw</span></span><span class="koboSpan" id="kobo.386.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.387.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.388.1">show</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.389.1">()</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.390.1">{ 
    visible = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.391.1">true</span></span><span class="koboSpan" id="kobo.392.1">; 
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.393.1">draw</span></span><span class="koboSpan" id="kobo.394.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.395.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.396.1">hide</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.397.1">()</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.398.1">{ 
    visible = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.399.1">false</span></span><span class="koboSpan" id="kobo.400.1">; 
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.401.1">draw</span></span><span class="koboSpan" id="kobo.402.1">();
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.403.1">This class</span><a id="_idIndexMarker1249"/><span class="koboSpan" id="kobo.404.1"> represents a control that has properties such as text, size, and visibility. </span><span class="koboSpan" id="kobo.404.2">Every time these properties are changed, the control is redrawn. </span><span class="koboSpan" id="kobo.404.3">In this mocked implementation, drawing means printing the value of the properties to the console.</span></p>
<h2 class="heading-2" id="_idParaDest-641"><span class="koboSpan" id="kobo.405.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.406.1">Take the following steps to implement the pimpl idiom, exemplified here by refactoring the </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">control</span></code><span class="koboSpan" id="kobo.408.1"> class shown earlier:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.409.1">Put all private members, both data and functions, into a separate class. </span><span class="koboSpan" id="kobo.409.2">We will call this the </span><strong class="keyWord"><span class="koboSpan" id="kobo.410.1">pimpl class</span></strong><span class="koboSpan" id="kobo.411.1"> and the original class the </span><strong class="keyWord"><span class="koboSpan" id="kobo.412.1">public class</span></strong><span class="koboSpan" id="kobo.413.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.414.1">In the header file of the public class, put a forward declaration to the pimpl class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.415.1">// in control.h</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.416.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.417.1">control_pimpl</span></span><span class="koboSpan" id="kobo.418.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.419.1">In the public class definition, declare a pointer to the pimpl class using </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">unique_ptr</span></code><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">This should be the only private data member of the class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.422.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.423.1">control</span></span><span class="koboSpan" id="kobo.424.1">
{
  std::unique_ptr&lt;control_pimpl, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.425.1">void</span></span><span class="koboSpan" id="kobo.426.1">(*)(control_pimpl*)&gt; pimpl;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">public</span></span><span class="koboSpan" id="kobo.428.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.429.1">control</span></span><span class="koboSpan" id="kobo.430.1">();
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.431.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.432.1">set_text</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.433.1">(std::string_view text)</span></span><span class="koboSpan" id="kobo.434.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.435.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.436.1">resize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.437.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.438.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.439.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.440.1"> w, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.441.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.442.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.443.1"> h)</span></span><span class="koboSpan" id="kobo.444.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.445.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.446.1">show</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.447.1">()</span></span><span class="koboSpan" id="kobo.448.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.449.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.450.1">hide</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.451.1">()</span></span><span class="koboSpan" id="kobo.452.1">;
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.453.1">Put the</span><a id="_idIndexMarker1250"/><span class="koboSpan" id="kobo.454.1"> pimpl class definition in the source file of the public class. </span><span class="koboSpan" id="kobo.454.2">The pimpl class mirrors the public interface of the public class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.455.1">// in control.cpp</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.456.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.457.1">control_pimpl</span></span><span class="koboSpan" id="kobo.458.1">
{
  std::string text;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.459.1">int</span></span><span class="koboSpan" id="kobo.460.1"> width = </span><span class="hljs-number"><span class="koboSpan" id="kobo.461.1">0</span></span><span class="koboSpan" id="kobo.462.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.463.1">int</span></span><span class="koboSpan" id="kobo.464.1"> height = </span><span class="hljs-number"><span class="koboSpan" id="kobo.465.1">0</span></span><span class="koboSpan" id="kobo.466.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.467.1">bool</span></span><span class="koboSpan" id="kobo.468.1"> visible = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.469.1">true</span></span><span class="koboSpan" id="kobo.470.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.471.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.472.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.473.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.474.1">{
    std::cout
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.475.1">"control "</span></span><span class="koboSpan" id="kobo.476.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.477.1">'\n'</span></span><span class="koboSpan" id="kobo.478.1">
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.479.1">" visible: "</span></span><span class="koboSpan" id="kobo.480.1"> &lt;&lt; std::boolalpha &lt;&lt; visible 
      &lt;&lt; std::noboolalpha &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.481.1">'\n'</span></span><span class="koboSpan" id="kobo.482.1">
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.483.1">" size: "</span></span><span class="koboSpan" id="kobo.484.1"> &lt;&lt; width &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.485.1">", "</span></span><span class="koboSpan" id="kobo.486.1"> &lt;&lt; height &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.487.1">'\n'</span></span><span class="koboSpan" id="kobo.488.1">
      &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.489.1">" text: "</span></span><span class="koboSpan" id="kobo.490.1"> &lt;&lt; text &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.491.1">'\n'</span></span><span class="koboSpan" id="kobo.492.1">;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.493.1">public</span></span><span class="koboSpan" id="kobo.494.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.495.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.496.1">set_text</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.497.1">(std::string_view t)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.498.1">{
    text = t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.499.1">data</span></span><span class="koboSpan" id="kobo.500.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.501.1">draw</span></span><span class="koboSpan" id="kobo.502.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.503.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.504.1">resize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.505.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.506.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.507.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.508.1"> w, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.509.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.510.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.511.1"> h)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.512.1">{
    width = w;
    height = h;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.513.1">draw</span></span><span class="koboSpan" id="kobo.514.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.515.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.516.1">show</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.517.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.518.1">{
    visible = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.519.1">true</span></span><span class="koboSpan" id="kobo.520.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.521.1">draw</span></span><span class="koboSpan" id="kobo.522.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.523.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.524.1">hide</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.525.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.526.1">{
    visible = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.527.1">false</span></span><span class="koboSpan" id="kobo.528.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.529.1">draw</span></span><span class="koboSpan" id="kobo.530.1">();
  }
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.531.1">The pimpl class is instantiated in the constructor of the public class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.532.1">control::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.533.1">control</span></span><span class="koboSpan" id="kobo.534.1">() :
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.535.1">pimpl</span></span><span class="koboSpan" id="kobo.536.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.537.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.538.1">control_pimpl</span></span><span class="koboSpan" id="kobo.539.1">(),
        [](control_pimpl* pimpl) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.540.1">delete</span></span><span class="koboSpan" id="kobo.541.1"> pimpl; })
{}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.542.1">Public class </span><a id="_idIndexMarker1251"/><span class="koboSpan" id="kobo.543.1">member functions call the corresponding member functions of the pimpl class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.544.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.545.1">control::set_text</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.546.1">(std::string_view text)</span></span><span class="koboSpan" id="kobo.547.1">
{
  pimpl-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.548.1">set_text</span></span><span class="koboSpan" id="kobo.549.1">(text);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.550.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.551.1">control::resize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.552.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.553.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.554.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.555.1"> w, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.556.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.557.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.558.1"> h)</span></span><span class="koboSpan" id="kobo.559.1">
{
  pimpl-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.560.1">resize</span></span><span class="koboSpan" id="kobo.561.1">(w, h);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.562.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.563.1">control::show</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.564.1">()</span></span><span class="koboSpan" id="kobo.565.1">
{
  pimpl-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.566.1">show</span></span><span class="koboSpan" id="kobo.567.1">();
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.568.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.569.1">control::hide</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.570.1">()</span></span><span class="koboSpan" id="kobo.571.1">
{
  pimpl-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.572.1">hide</span></span><span class="koboSpan" id="kobo.573.1">();
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-642"><span class="koboSpan" id="kobo.574.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.575.1">The pimpl idiom enables hiding the internal implementation of a class from the clients of the library or module the class is part of. </span><span class="koboSpan" id="kobo.575.2">This provides several benefits:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.576.1">A clean interface for a class that its clients see.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.577.1">Changes</span><a id="_idIndexMarker1252"/><span class="koboSpan" id="kobo.578.1"> in the internal implementation do not affect the public interface, which enables binary backward-compatibility for newer versions of a library (when the public interface remains unchanged).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.579.1">Clients of a class that use this idiom do not need to be recompiled when changes to the internal implementation occur. </span><span class="koboSpan" id="kobo.579.2">This leads to shorter build times.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.580.1">The header file does not need to include the headers for the types and functions used in the private implementation. </span><span class="koboSpan" id="kobo.580.2">This, again, leads to shorter build times.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.581.1">The benefits mentioned above do </span><a id="_idIndexMarker1253"/><span class="koboSpan" id="kobo.582.1">not come for free; there are also several drawbacks that need to be mentioned:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.583.1">There is more code to write and maintain.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.584.1">The code can arguably be less readable, as there is a level of indirection and all the implementation details need to be looked up in the other files. </span><span class="koboSpan" id="kobo.584.2">In this recipe, the pimpl class definition was provided in the source file of the public class, but in practice, it could be in separate files.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.585.1">There is a slight runtime overhead because of the level of indirection from the public class to the pimpl class, but in practice, this is rarely significant.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.586.1">This approach does not work with private and protected members because these have to be available to the derived classes.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.587.1">This approach does not work with the private virtual functions, which have to appear in the class, either because they override functions from a base class or have to be available for overriding in a derived class.</span></li>
</ul>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.588.1">As a rule of thumb, when implementing the pimpl idiom, always put all the private member data and functions, except for the virtual ones, in the pimpl class and leave the protected data members and functions and all the private virtual functions in the public class.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.589.1">In the example in this recipe, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">control_pimpl</span></code><span class="koboSpan" id="kobo.591.1"> class is basically identical to the original </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">control</span></code><span class="koboSpan" id="kobo.593.1"> class. </span><span class="koboSpan" id="kobo.593.2">In practice, where classes are larger and have virtual functions and protected members and both functions and data, the pimpl class is not a complete equivalent of how the class would have looked like if it was not pimpled. </span><span class="koboSpan" id="kobo.593.3">Also, in practice, the pimpl class may require a pointer to the public class in order to call members that were not moved into the pimpl class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.594.1">Concerning the implementation of the refactored </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">control</span></code><span class="koboSpan" id="kobo.596.1"> class, the pointer to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">control_pimpl</span></code><span class="koboSpan" id="kobo.598.1"> object is managed by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">unique_ptr</span></code><span class="koboSpan" id="kobo.600.1">. </span><span class="koboSpan" id="kobo.600.2">In the declaration of this pointer, we have used a custom deleter:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.601.1">std::unique_ptr&lt;control_pimpl, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.602.1">void</span></span><span class="koboSpan" id="kobo.603.1">(*)(control_pimpl*)&gt; pimpl;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.604.1">The reason for this is that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.605.1">control</span></code><span class="koboSpan" id="kobo.606.1"> class has a destructor implicitly defined by the compiler, at a point where the </span><code class="inlineCode"><span class="koboSpan" id="kobo.607.1">control_pimpl</span></code><span class="koboSpan" id="kobo.608.1"> type is still incomplete (that is, in the header). </span><span class="koboSpan" id="kobo.608.2">This would result in an error with </span><code class="inlineCode"><span class="koboSpan" id="kobo.609.1">unique_ptr</span></code><span class="koboSpan" id="kobo.610.1">, which cannot delete an incomplete type. </span><span class="koboSpan" id="kobo.610.2">This problem can be solved in two ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.611.1">Provide a user-defined destructor for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">control</span></code><span class="koboSpan" id="kobo.613.1"> class that is explicitly implemented (even if declared as </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">default</span></code><span class="koboSpan" id="kobo.615.1">) after the complete definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">control_pimpl</span></code><span class="koboSpan" id="kobo.617.1"> class is available.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.618.1">Provide a custom deleter for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.619.1">unique_ptr</span></code><span class="koboSpan" id="kobo.620.1">, as we did in this example.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-643"><span class="koboSpan" id="kobo.621.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.622.1">The original </span><code class="inlineCode"><span class="koboSpan" id="kobo.623.1">control</span></code><span class="koboSpan" id="kobo.624.1"> class was both copyable and movable:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.625.1">control c;
c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.626.1">resize</span></span><span class="koboSpan" id="kobo.627.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.628.1">100</span></span><span class="koboSpan" id="kobo.629.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.630.1">20</span></span><span class="koboSpan" id="kobo.631.1">);
c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.632.1">set_text</span></span><span class="koboSpan" id="kobo.633.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.634.1">"sample"</span></span><span class="koboSpan" id="kobo.635.1">);
c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.636.1">hide</span></span><span class="koboSpan" id="kobo.637.1">();
control c2 = c;             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.638.1">// copy</span></span><span class="koboSpan" id="kobo.639.1">
c2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.640.1">show</span></span><span class="koboSpan" id="kobo.641.1">();
control c3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.642.1">move</span></span><span class="koboSpan" id="kobo.643.1">(c2); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.644.1">// move</span></span><span class="koboSpan" id="kobo.645.1">
c3.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.646.1">hide</span></span><span class="koboSpan" id="kobo.647.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.648.1">The refactored </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">control</span></code><span class="koboSpan" id="kobo.650.1"> class is only movable, not copyable. </span><span class="koboSpan" id="kobo.650.2">The following code shows an implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">control</span></code><span class="koboSpan" id="kobo.652.1"> class that is both copyable and movable:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.653.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.654.1">control_copyable</span></span><span class="koboSpan" id="kobo.655.1">
{
  std::unique_ptr&lt;control_pimpl, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.656.1">void</span></span><span class="koboSpan" id="kobo.657.1">(*)(control_pimpl*)&gt; pimpl;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.658.1">public</span></span><span class="koboSpan" id="kobo.659.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.660.1">control_copyable</span></span><span class="koboSpan" id="kobo.661.1">();
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.662.1">control_copyable</span></span><span class="koboSpan" id="kobo.663.1">(control_copyable &amp;&amp; op) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.664.1">noexcept</span></span><span class="koboSpan" id="kobo.665.1">;
  control_copyable&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.666.1">operator</span></span><span class="koboSpan" id="kobo.667.1">=(control_copyable &amp;&amp; op) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.668.1">noexcept</span></span><span class="koboSpan" id="kobo.669.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.670.1">control_copyable</span></span><span class="koboSpan" id="kobo.671.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.672.1">const</span></span><span class="koboSpan" id="kobo.673.1"> control_copyable&amp; op);
  control_copyable&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.674.1">operator</span></span><span class="koboSpan" id="kobo.675.1">=(</span><span class="hljs-type"><span class="koboSpan" id="kobo.676.1">const</span></span><span class="koboSpan" id="kobo.677.1"> control_copyable&amp; op);
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.678.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.679.1">set_text</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.680.1">(std::string_view text)</span></span><span class="koboSpan" id="kobo.681.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.682.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.683.1">resize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.684.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.685.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.686.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.687.1"> w, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.688.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.689.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.690.1"> h)</span></span><span class="koboSpan" id="kobo.691.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.692.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.693.1">show</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.694.1">()</span></span><span class="koboSpan" id="kobo.695.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.696.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.697.1">hide</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.698.1">()</span></span><span class="koboSpan" id="kobo.699.1">;
};
control_copyable::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.700.1">control_copyable</span></span><span class="koboSpan" id="kobo.701.1">() :
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.702.1">pimpl</span></span><span class="koboSpan" id="kobo.703.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.704.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.705.1">control_pimpl</span></span><span class="koboSpan" id="kobo.706.1">(),
        [](control_pimpl* pimpl) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.707.1">delete</span></span><span class="koboSpan" id="kobo.708.1"> pimpl; })
{}
control_copyable::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.709.1">control_copyable</span></span><span class="koboSpan" id="kobo.710.1">(control_copyable &amp;&amp;) 
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.711.1">noexcept</span></span><span class="koboSpan" id="kobo.712.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.713.1">default</span></span><span class="koboSpan" id="kobo.714.1">;
control_copyable&amp; control_copyable::</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.715.1">operator</span></span><span class="koboSpan" id="kobo.716.1">=(control_copyable &amp;&amp;) 
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.717.1">noexcept</span></span><span class="koboSpan" id="kobo.718.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.719.1">default</span></span><span class="koboSpan" id="kobo.720.1">;
control_copyable::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.721.1">control_copyable</span></span><span class="koboSpan" id="kobo.722.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.723.1">const</span></span><span class="koboSpan" id="kobo.724.1"> control_copyable&amp; op)
   : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.725.1">pimpl</span></span><span class="koboSpan" id="kobo.726.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.727.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.728.1">control_pimpl</span></span><span class="koboSpan" id="kobo.729.1">(*op.pimpl),
           [](control_pimpl* pimpl) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.730.1">delete</span></span><span class="koboSpan" id="kobo.731.1"> pimpl; })
{}
control_copyable&amp; control_copyable::</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.732.1">operator</span></span><span class="koboSpan" id="kobo.733.1">=(
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.734.1">const</span></span><span class="koboSpan" id="kobo.735.1"> control_copyable&amp; op) 
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.736.1">if</span></span><span class="koboSpan" id="kobo.737.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.738.1">this</span></span><span class="koboSpan" id="kobo.739.1"> != &amp;op) 
  {
    pimpl = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.740.1">unique_ptr</span></span><span class="koboSpan" id="kobo.741.1">&lt;control_pimpl,</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.742.1">void</span></span><span class="koboSpan" id="kobo.743.1">(*)(control_pimpl*)&gt;(
               </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.744.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.745.1">control_pimpl</span></span><span class="koboSpan" id="kobo.746.1">(*op.pimpl),
               [](control_pimpl* pimpl) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.747.1">delete</span></span><span class="koboSpan" id="kobo.748.1"> pimpl; });
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.749.1">return</span></span><span class="koboSpan" id="kobo.750.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.751.1">this</span></span><span class="koboSpan" id="kobo.752.1">;
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.753.1">// the other member functions</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.754.1">The class </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">control_copyable</span></code><span class="koboSpan" id="kobo.756.1"> is both copyable and movable, but to make it so, we provided the copy constructor and copy assignment operator and both the move constructor and move assignment operator. </span><span class="koboSpan" id="kobo.756.2">The latter ones can be defaulted, but the former ones were explicitly implemented to create a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">control_pimpl</span></code><span class="koboSpan" id="kobo.758.1"> object from the object that it is copied from.</span></p>
<h2 class="heading-2" id="_idParaDest-644"><span class="koboSpan" id="kobo.759.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.760.1">Chapter 9, </span></em><em class="italic"><span class="koboSpan" id="kobo.761.1">Using unique_ptr to uniquely own a memory resource</span></em><span class="koboSpan" id="kobo.762.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.764.1"> class, which represents a smart pointer that owns and manages another object or array of objects allocated on the heap</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-645"><span class="koboSpan" id="kobo.765.1">Implementing the named parameter idiom</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.766.1">C++ supports </span><a id="_idIndexMarker1254"/><span class="koboSpan" id="kobo.767.1">only positional parameters, which means arguments are passed to a function based on the parameter’s position. </span><span class="koboSpan" id="kobo.767.2">Other languages also support named parameters – that is, they specify parameter names when making a call and invoking arguments. </span><span class="koboSpan" id="kobo.767.3">This is particularly useful with parameters that have default values. </span><span class="koboSpan" id="kobo.767.4">A function may have parameters with default values, although they always appear after all the non-defaulted parameters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.768.1">However, if you want to provide values for only some of the defaulted parameters, there is no way to do this without providing arguments for the parameters that are positioned before them in the function parameters list.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.769.1">A technique called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.770.1">named parameter idiom </span></strong><span class="koboSpan" id="kobo.771.1">provides a method to emulate named parameters and help solve this problem. </span><span class="koboSpan" id="kobo.771.2">We will explore this technique in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-646"><span class="koboSpan" id="kobo.772.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.773.1">To exemplify the named parameter idiom, we will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">control</span></code><span class="koboSpan" id="kobo.775.1"> class shown in the following code snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.777.1">control</span></span><span class="koboSpan" id="kobo.778.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.779.1">int</span></span><span class="koboSpan" id="kobo.780.1"> id_;
  std::string text_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.781.1">int</span></span><span class="koboSpan" id="kobo.782.1"> width_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.783.1">int</span></span><span class="koboSpan" id="kobo.784.1"> height_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.785.1">bool</span></span><span class="koboSpan" id="kobo.786.1"> visible_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.787.1">public</span></span><span class="koboSpan" id="kobo.788.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.789.1">control</span></span><span class="koboSpan" id="kobo.790.1">(
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.791.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.792.1">const</span></span><span class="koboSpan" id="kobo.793.1"> id,
    std::string_view text = </span><span class="hljs-string"><span class="koboSpan" id="kobo.794.1">""</span></span><span class="koboSpan" id="kobo.795.1">,
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.796.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.797.1">const</span></span><span class="koboSpan" id="kobo.798.1"> width = </span><span class="hljs-number"><span class="koboSpan" id="kobo.799.1">0</span></span><span class="koboSpan" id="kobo.800.1">,
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.801.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.802.1">const</span></span><span class="koboSpan" id="kobo.803.1"> height = </span><span class="hljs-number"><span class="koboSpan" id="kobo.804.1">0</span></span><span class="koboSpan" id="kobo.805.1">,
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.806.1">bool</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.807.1">const</span></span><span class="koboSpan" id="kobo.808.1"> visible = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.809.1">false</span></span><span class="koboSpan" id="kobo.810.1">):
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.811.1">id_</span></span><span class="koboSpan" id="kobo.812.1">(id), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.813.1">text_</span></span><span class="koboSpan" id="kobo.814.1">(text), 
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.815.1">width_</span></span><span class="koboSpan" id="kobo.816.1">(width), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.817.1">height_</span></span><span class="koboSpan" id="kobo.818.1">(height), 
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.819.1">visible_</span></span><span class="koboSpan" id="kobo.820.1">(visible)
  {}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.821.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.822.1">control</span></code><span class="koboSpan" id="kobo.823.1"> class represents a visual control, such as a button or an input, and has properties such as numerical identifier, text, size, and visibility. </span><span class="koboSpan" id="kobo.823.2">These are provided to the constructor and, except for the ID, all the others have default values. </span><span class="koboSpan" id="kobo.823.3">In practice, such a class would </span><a id="_idIndexMarker1255"/><span class="koboSpan" id="kobo.824.1">have many more properties, such as text brush, background brush, border style, font size, font family, and many others.</span></p>
<h2 class="heading-2" id="_idParaDest-647"><span class="koboSpan" id="kobo.825.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.826.1">To implement the named parameter idiom for a function (usually with many default parameters), do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.827.1">Create a class to wrap the parameters of the function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.828.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.829.1">control_properties</span></span><span class="koboSpan" id="kobo.830.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.831.1">int</span></span><span class="koboSpan" id="kobo.832.1"> id_;
  std::string text_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.833.1">int</span></span><span class="koboSpan" id="kobo.834.1"> width_ = </span><span class="hljs-number"><span class="koboSpan" id="kobo.835.1">0</span></span><span class="koboSpan" id="kobo.836.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.837.1">int</span></span><span class="koboSpan" id="kobo.838.1"> height_ = </span><span class="hljs-number"><span class="koboSpan" id="kobo.839.1">0</span></span><span class="koboSpan" id="kobo.840.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.841.1">bool</span></span><span class="koboSpan" id="kobo.842.1"> visible_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.843.1">false</span></span><span class="koboSpan" id="kobo.844.1">;
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.845.1">The class or function that needs to access these properties could be declared as </span><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">friend</span></code><span class="koboSpan" id="kobo.847.1"> to avoid writing getters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.848.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.849.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.850.1">control</span></span><span class="koboSpan" id="kobo.851.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.852.1">Every positional parameter of the original function that does not have a default value should become a positional parameter, without a default value in the constructor of the class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.853.1">public</span></span><span class="koboSpan" id="kobo.854.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.855.1">control_properties</span></span><span class="koboSpan" id="kobo.856.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.857.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.858.1">const</span></span><span class="koboSpan" id="kobo.859.1"> id) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.860.1">id_</span></span><span class="koboSpan" id="kobo.861.1">(id)
  {}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.862.1">For every positional parameter of the original function that has a default value, there should be a function (with the same name) that sets the value internally and returns a reference to the class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.863.1">public</span></span><span class="koboSpan" id="kobo.864.1">:
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.865.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.866.1">text</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.867.1">(std::string_view t)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.868.1">{ text_ = t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.869.1">data</span></span><span class="koboSpan" id="kobo.870.1">(); </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.871.1">return</span></span><span class="koboSpan" id="kobo.872.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.873.1">this</span></span><span class="koboSpan" id="kobo.874.1">; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.875.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.876.1">width</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.877.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.878.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.879.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.880.1"> w)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.881.1">{ width_ = w; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.882.1">return</span></span><span class="koboSpan" id="kobo.883.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.884.1">this</span></span><span class="koboSpan" id="kobo.885.1">; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.886.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.887.1">height</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.888.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.889.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.890.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.891.1"> h)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.892.1">{ height_ = h; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.893.1">return</span></span><span class="koboSpan" id="kobo.894.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.895.1">this</span></span><span class="koboSpan" id="kobo.896.1">; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.897.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.898.1">visible</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.899.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.900.1">bool</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.901.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.902.1"> v)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.903.1">{ visible_ = v; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.904.1">return</span></span><span class="koboSpan" id="kobo.905.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.906.1">this</span></span><span class="koboSpan" id="kobo.907.1">; }
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.908.1">The </span><a id="_idIndexMarker1256"/><span class="koboSpan" id="kobo.909.1">original function should be modified, or an overload should be provided, to take an argument of the new class from which the property values will be read:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.910.1">control</span></span><span class="koboSpan" id="kobo.911.1">(control_properties </span><span class="hljs-type"><span class="koboSpan" id="kobo.912.1">const</span></span><span class="koboSpan" id="kobo.913.1"> &amp; cp):
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.914.1">id_</span></span><span class="koboSpan" id="kobo.915.1">(cp.id_), 
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.916.1">text_</span></span><span class="koboSpan" id="kobo.917.1">(cp.text_),
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.918.1">width_</span></span><span class="koboSpan" id="kobo.919.1">(cp.width_), 
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.920.1">height_</span></span><span class="koboSpan" id="kobo.921.1">(cp.height_),
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.922.1">visible_</span></span><span class="koboSpan" id="kobo.923.1">(cp.visible_)
{}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.924.1">If we put all that together, the result is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.925.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.926.1">control</span></span><span class="koboSpan" id="kobo.927.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.928.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.929.1">control_properties</span></span><span class="koboSpan" id="kobo.930.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.931.1">int</span></span><span class="koboSpan" id="kobo.932.1"> id_;
  std::string text_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.933.1">int</span></span><span class="koboSpan" id="kobo.934.1"> width_ = </span><span class="hljs-number"><span class="koboSpan" id="kobo.935.1">0</span></span><span class="koboSpan" id="kobo.936.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.937.1">int</span></span><span class="koboSpan" id="kobo.938.1"> height_ = </span><span class="hljs-number"><span class="koboSpan" id="kobo.939.1">0</span></span><span class="koboSpan" id="kobo.940.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.941.1">bool</span></span><span class="koboSpan" id="kobo.942.1"> visible_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.943.1">false</span></span><span class="koboSpan" id="kobo.944.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.945.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.946.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.947.1">control</span></span><span class="koboSpan" id="kobo.948.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.949.1">public</span></span><span class="koboSpan" id="kobo.950.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.951.1">control_properties</span></span><span class="koboSpan" id="kobo.952.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.953.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.954.1">const</span></span><span class="koboSpan" id="kobo.955.1"> id) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.956.1">id_</span></span><span class="koboSpan" id="kobo.957.1">(id)
  {}
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.958.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.959.1">text</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.960.1">(std::string_view t)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.961.1">{ text_ = t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.962.1">data</span></span><span class="koboSpan" id="kobo.963.1">(); </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.964.1">return</span></span><span class="koboSpan" id="kobo.965.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.966.1">this</span></span><span class="koboSpan" id="kobo.967.1">; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.968.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.969.1">width</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.970.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.971.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.972.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.973.1"> w)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.974.1">{ width_ = w; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.975.1">return</span></span><span class="koboSpan" id="kobo.976.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.977.1">this</span></span><span class="koboSpan" id="kobo.978.1">; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.979.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.980.1">height</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.981.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.982.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.983.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.984.1"> h)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.985.1">{ height_ = h; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.986.1">return</span></span><span class="koboSpan" id="kobo.987.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.988.1">this</span></span><span class="koboSpan" id="kobo.989.1">; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.990.1">control_properties&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.991.1">visible</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.992.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.993.1">bool</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.994.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.995.1"> v)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.996.1">{ visible_ = v; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.997.1">return</span></span><span class="koboSpan" id="kobo.998.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.999.1">this</span></span><span class="koboSpan" id="kobo.1000.1">; }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1001.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1002.1">control</span></span><span class="koboSpan" id="kobo.1003.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1004.1">int</span></span><span class="koboSpan" id="kobo.1005.1">         id_;
  std::string text_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1006.1">int</span></span><span class="koboSpan" id="kobo.1007.1">         width_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1008.1">int</span></span><span class="koboSpan" id="kobo.1009.1">         height_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1010.1">bool</span></span><span class="koboSpan" id="kobo.1011.1">        visible_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1012.1">public</span></span><span class="koboSpan" id="kobo.1013.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1014.1">control</span></span><span class="koboSpan" id="kobo.1015.1">(control_properties </span><span class="hljs-type"><span class="koboSpan" id="kobo.1016.1">const</span></span><span class="koboSpan" id="kobo.1017.1"> &amp; cp):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1018.1">id_</span></span><span class="koboSpan" id="kobo.1019.1">(cp.id_), 
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1020.1">text_</span></span><span class="koboSpan" id="kobo.1021.1">(cp.text_),
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1022.1">width_</span></span><span class="koboSpan" id="kobo.1023.1">(cp.width_), 
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1024.1">height_</span></span><span class="koboSpan" id="kobo.1025.1">(cp.height_),
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1026.1">visible_</span></span><span class="koboSpan" id="kobo.1027.1">(cp.visible_)
  {}
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-648"><span class="koboSpan" id="kobo.1028.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1029.1">The</span><a id="_idIndexMarker1257"/><span class="koboSpan" id="kobo.1030.1"> initial </span><code class="inlineCode"><span class="koboSpan" id="kobo.1031.1">control</span></code><span class="koboSpan" id="kobo.1032.1"> class had a constructor with many parameters. </span><span class="koboSpan" id="kobo.1032.2">In real-world code, you can find examples like this where the number of parameters is much higher. </span><span class="koboSpan" id="kobo.1032.3">A possible solution, often found in practice, is to group common Boolean type properties in bit flags, which could be passed together as a single integral argument (an example could be the border style for a control that defines the position where the border should be visible: top, bottom, left, right, or any combination of these four). </span><span class="koboSpan" id="kobo.1032.4">Creating a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">control</span></code><span class="koboSpan" id="kobo.1034.1"> object with the initial implementation is done like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1035.1">control </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1036.1">c</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1037.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1038.1">1044</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1039.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1040.1">"sample"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1041.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1042.1">100</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1043.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1044.1">20</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1045.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1046.1">true</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1047.1">)</span></span><span class="koboSpan" id="kobo.1048.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1049.1">The named parameter idiom has the advantage that it allows you to specify values only for the parameters that you want, in any order, using a name, which is much more intuitive than a fixed, positional order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1050.1">Although </span><a id="_idIndexMarker1258"/><span class="koboSpan" id="kobo.1051.1">there isn’t a single strategy for implementing the idiom, the example in this recipe is rather typical. </span><span class="koboSpan" id="kobo.1051.2">The properties of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">control</span></code><span class="koboSpan" id="kobo.1053.1"> class, provided as parameters in the constructor, have been put into a separate class, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1054.1">control_properties</span></code><span class="koboSpan" id="kobo.1055.1">, that declares the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1056.1">control</span></code><span class="koboSpan" id="kobo.1057.1"> class as a friend class to allow it to access its private data members without providing getters. </span><span class="koboSpan" id="kobo.1057.2">This has the side effect that it limits the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1058.1">control_properties</span></code><span class="koboSpan" id="kobo.1059.1"> outside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">control</span></code><span class="koboSpan" id="kobo.1061.1"> class. </span><span class="koboSpan" id="kobo.1061.2">The non-optional parameters of the constructor of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">control</span></code><span class="koboSpan" id="kobo.1063.1"> class are also non-optional parameters of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1064.1">control_properties</span></code><span class="koboSpan" id="kobo.1065.1"> constructor. </span><span class="koboSpan" id="kobo.1065.2">For all the other parameters with default values, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1066.1">control_properties</span></code><span class="koboSpan" id="kobo.1067.1"> class defines a function with a relevant name that simply sets the data member to the provided argument, and then returns a reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1068.1">control_properties</span></code><span class="koboSpan" id="kobo.1069.1">. </span><span class="koboSpan" id="kobo.1069.2">This enables the client to chain calls to these functions in any order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1070.1">The constructor of the control class has been replaced with a new one that has a single parameter, a constant reference to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">control_properties</span></code><span class="koboSpan" id="kobo.1072.1"> object, whose data members are copied into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">control</span></code><span class="koboSpan" id="kobo.1074.1"> object’s data members.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1075.1">Creating a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1076.1">control</span></code><span class="koboSpan" id="kobo.1077.1"> object with the named parameter idiom implemented in this manner is done as in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1078.1">control </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1079.1">c</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1080.1">(control_properties(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1081.1">1044</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1082.1">)</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1083.1">          .visible(</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1084.1">true</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1085.1">)</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1086.1">          .height(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1087.1">20</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1088.1">)</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1089.1">          .width(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1090.1">100</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1091.1">))</span></span><span class="koboSpan" id="kobo.1092.1">;
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-649"><span class="koboSpan" id="kobo.1093.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1094.1">Separating interfaces and implementations with the non-virtual interface idiom</span></em><span class="koboSpan" id="kobo.1095.1">, to explore an idiom that promotes the separation of concerns of interfaces and implementations by making (public) interfaces non-virtual and virtual functions private</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1096.1">Handling friendship with the attorney-client idiom</span></em><span class="koboSpan" id="kobo.1097.1">, to learn about a simple mechanism to restrict friends’ access to only designated, private members of a class</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-650"><span class="koboSpan" id="kobo.1098.1">Separating interfaces and implementations with the non-virtual interface idiom</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1099.1">Virtual functions</span><a id="_idIndexMarker1259"/><span class="koboSpan" id="kobo.1100.1"> provide specialization points for a class by allowing derived classes to modify implementations from a base class. </span><span class="koboSpan" id="kobo.1100.2">When a derived </span><a id="_idIndexMarker1260"/><span class="koboSpan" id="kobo.1101.1">class object is handled through a pointer or a reference to a base class, calls to overridden virtual functions end up invoking the overridden implementation from the derived class. </span><span class="koboSpan" id="kobo.1101.2">On the other hand, customization is an implementation detail, and a good design separates interfaces from implementation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1102.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.1103.1">non-virtual interface idiom</span></strong><span class="koboSpan" id="kobo.1104.1">, proposed by Herb Sutter in an article about virtuality in the </span><em class="italic"><span class="koboSpan" id="kobo.1105.1">C/C++ Users Journal</span></em><span class="koboSpan" id="kobo.1106.1">, promotes the separation of concerns of interfaces and implementations by making (public) interfaces non-virtual and virtual functions private.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1107.1">Public virtual interfaces prevent a class from enforcing pre- and post-conditions on its interface. </span><span class="koboSpan" id="kobo.1107.2">Users expecting an instance of a base class do not have the guarantee that the expected behavior of a public virtual method is delivered, since it can be overridden in a derived class. </span><span class="koboSpan" id="kobo.1107.3">This idiom helps enforce the promised contract of an interface.</span></p>
<h2 class="heading-2" id="_idParaDest-651"><span class="koboSpan" id="kobo.1108.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1109.1">The reader should be familiar with aspects related to virtual functions, such as defining and overriding virtual functions, abstract classes, and pure specifiers.</span></p>
<h2 class="heading-2" id="_idParaDest-652"><span class="koboSpan" id="kobo.1110.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1111.1">Implementing this idiom requires following several simple design guidelines, formulated by Herb Sutter in the </span><em class="italic"><span class="koboSpan" id="kobo.1112.1">C/C++ Users Journal</span></em><span class="koboSpan" id="kobo.1113.1">, 19(9), September 2001:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1114.1">Make (public) interfaces non-virtual.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1115.1">Make virtual functions private.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1116.1">Make virtual functions protected only if the base implementation has to be called from a derived class.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1117.1">Make the base class destructor either public and virtual or protected and nonvirtual.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1118.1">The following example of a simple hierarchy of controls abides by all these four guidelines:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1119.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1120.1">control</span></span><span class="koboSpan" id="kobo.1121.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1122.1">private</span></span><span class="koboSpan" id="kobo.1123.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1124.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1125.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1126.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1127.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1128.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1129.1">0</span></span><span class="koboSpan" id="kobo.1130.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1131.1">protected</span></span><span class="koboSpan" id="kobo.1132.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1133.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1134.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1135.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1136.1">()</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1137.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1138.1">"erasing control background..."</span></span><span class="koboSpan" id="kobo.1139.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1140.1">'\n'</span></span><span class="koboSpan" id="kobo.1141.1">;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1142.1">public</span></span><span class="koboSpan" id="kobo.1143.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1144.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1145.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1146.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1147.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1148.1">erase_background</span></span><span class="koboSpan" id="kobo.1149.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1150.1">paint</span></span><span class="koboSpan" id="kobo.1151.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1152.1">virtual</span></span><span class="koboSpan" id="kobo.1153.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1154.1">control</span></span><span class="koboSpan" id="kobo.1155.1">() {}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1156.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1157.1">button</span></span><span class="koboSpan" id="kobo.1158.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1159.1">public</span></span><span class="koboSpan" id="kobo.1160.1"> control
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1161.1">private</span></span><span class="koboSpan" id="kobo.1162.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1163.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1164.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1165.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1166.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1167.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1168.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1169.1">"painting button..."</span></span><span class="koboSpan" id="kobo.1170.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1171.1">'\n'</span></span><span class="koboSpan" id="kobo.1172.1">;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1173.1">protected</span></span><span class="koboSpan" id="kobo.1174.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1175.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1176.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1177.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1178.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1179.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1180.1">{
    control::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1181.1">erase_background</span></span><span class="koboSpan" id="kobo.1182.1">();
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1183.1">"erasing button background..."</span></span><span class="koboSpan" id="kobo.1184.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1185.1">'\n'</span></span><span class="koboSpan" id="kobo.1186.1">;
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1187.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1188.1">checkbox</span></span><span class="koboSpan" id="kobo.1189.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1190.1">public</span></span><span class="koboSpan" id="kobo.1191.1"> button
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1192.1">private</span></span><span class="koboSpan" id="kobo.1193.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1194.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1195.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1196.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1197.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1198.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1199.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1200.1">"painting checkbox..."</span></span><span class="koboSpan" id="kobo.1201.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1202.1">'\n'</span></span><span class="koboSpan" id="kobo.1203.1">;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1204.1">protected</span></span><span class="koboSpan" id="kobo.1205.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1206.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1207.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1208.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1209.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1210.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1211.1">{
    button::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1212.1">erase_background</span></span><span class="koboSpan" id="kobo.1213.1">();
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1214.1">"erasing checkbox background..."</span></span><span class="koboSpan" id="kobo.1215.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1216.1">'\n'</span></span><span class="koboSpan" id="kobo.1217.1">;
  }
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-653"><span class="koboSpan" id="kobo.1218.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1219.1">The NVI idiom</span><a id="_idIndexMarker1261"/><span class="koboSpan" id="kobo.1220.1"> uses the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1221.1">template method</span></strong><span class="koboSpan" id="kobo.1222.1"> design pattern, which allows derived classes to customize parts (that is, steps) of a base class functionality (that is, an algorithm). </span><span class="koboSpan" id="kobo.1222.2">This is done by splitting the overall algorithm into smaller parts, each of them implemented by a virtual function. </span><span class="koboSpan" id="kobo.1222.3">The base class may provide, or not, a default implementation, and the derived classes could override them while maintaining the overall structure and meaning of the algorithm.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1223.1">The core principle of the NVI idiom is that virtual functions should not be public; they should be either private or protected, in case the base class implementation could be called from a derived class. </span><span class="koboSpan" id="kobo.1223.2">The interface of a class, the public part accessible to its clients, should be comprised exclusively of nonvirtual functions. </span><span class="koboSpan" id="kobo.1223.3">This provides several advantages:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1224.1">It separates the interface from the details of implementation that are no longer exposed to the client.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1225.1">It enables changing the details of the implementation without altering the public interface and without requiring changes to the client code, therefore making base classes more robust.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1226.1">It allows a class to have sole control of its interface. </span><span class="koboSpan" id="kobo.1226.2">If the public interface contains virtual methods, a derived class can alter the promised functionality, and therefore, the class cannot ensure its preconditions and postconditions. </span><span class="koboSpan" id="kobo.1226.3">When none of the virtual methods (except for the destructor) are accessible to its clients, the class can enforce pre- and post-conditions on its interface.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1227.1">A special mention of the destructor of a class is required for this idiom. </span><span class="koboSpan" id="kobo.1227.2">It is often stressed that base class destructors should be virtual so that objects can be deleted polymorphically (through a pointer or references to a base class). </span><span class="koboSpan" id="kobo.1227.3">Destructing objects polymorphically when the destructor is not virtual incurs undefined behavior. </span><span class="koboSpan" id="kobo.1227.4">However, not all base classes are intended to be deleted polymorphically. </span><span class="koboSpan" id="kobo.1227.5">For those particular cases, the base class destructor should not be virtual. </span><span class="koboSpan" id="kobo.1227.6">However, it should also not be public, but protected.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1228.1">The example</span><a id="_idIndexMarker1262"/><span class="koboSpan" id="kobo.1229.1"> from the previous section defines a hierarchy of classes representing visual controls:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1230.1">control</span></code><span class="koboSpan" id="kobo.1231.1"> is the base class, but there are derived classes, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1232.1">button</span></code><span class="koboSpan" id="kobo.1233.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1234.1">checkbox</span></code><span class="koboSpan" id="kobo.1235.1">, which are a type of button and, therefore, are derived from this class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1236.1">The only functionality defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1237.1">control</span></code><span class="koboSpan" id="kobo.1238.1"> class is drawing the controls. </span><span class="koboSpan" id="kobo.1238.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">draw()</span></code><span class="koboSpan" id="kobo.1240.1"> method is nonvirtual, but it calls two virtual methods, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">erase_background()</span></code><span class="koboSpan" id="kobo.1242.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1243.1">paint()</span></code><span class="koboSpan" id="kobo.1244.1">, to implement the two phases of drawing the control.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1245.1">erase_background()</span></code><span class="koboSpan" id="kobo.1246.1"> is a protected virtual method because derived classes need to call it in their own implementation.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1247.1">paint()</span></code><span class="koboSpan" id="kobo.1248.1"> is a private pure virtual method. </span><span class="koboSpan" id="kobo.1248.2">Derived classes must implement it, but are not supposed to call a base implementation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1249.1">The destructor of the control class is public and virtual because objects are expected to be deleted polymorphically.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1250.1">An example of using these classes is shown as follows. </span><span class="koboSpan" id="kobo.1250.2">Instances of these classes are managed by smart pointers to the base class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1251.1">std::vector&lt;std::unique_ptr&lt;control&gt;&gt; controls;
controls.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1252.1">emplace_back</span></span><span class="koboSpan" id="kobo.1253.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1254.1">make_unique</span></span><span class="koboSpan" id="kobo.1255.1">&lt;button&gt;());
controls.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1256.1">emplace_back</span></span><span class="koboSpan" id="kobo.1257.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1258.1">make_unique</span></span><span class="koboSpan" id="kobo.1259.1">&lt;checkbox&gt;());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1260.1">for</span></span><span class="koboSpan" id="kobo.1261.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1262.1">auto</span></span><span class="koboSpan" id="kobo.1263.1">&amp; c : controls)
  c-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1264.1">draw</span></span><span class="koboSpan" id="kobo.1265.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1266.1">The output of this program is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1267.1">erasing control background...
</span><span class="koboSpan" id="kobo.1267.2">erasing button background...
</span><span class="koboSpan" id="kobo.1267.3">painting button...
</span><span class="koboSpan" id="kobo.1267.4">erasing control background...
</span><span class="koboSpan" id="kobo.1267.5">erasing button background...
</span><span class="koboSpan" id="kobo.1267.6">erasing checkbox background...
</span><span class="koboSpan" id="kobo.1267.7">painting checkbox...
</span><span class="koboSpan" id="kobo.1267.8">destroying button...
</span><span class="koboSpan" id="kobo.1267.9">destroying control...
</span><span class="koboSpan" id="kobo.1267.10">destroying checkbox...
</span><span class="koboSpan" id="kobo.1267.11">destroying button...
</span><span class="koboSpan" id="kobo.1267.12">destroying control...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1268.1">The NVI idiom</span><a id="_idIndexMarker1263"/><span class="koboSpan" id="kobo.1269.1"> introduces a level of indirection when a public function calls a non-public virtual function that does the actual implementation. </span><span class="koboSpan" id="kobo.1269.2">In the previous example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1270.1">draw()</span></code><span class="koboSpan" id="kobo.1271.1"> method called several other functions, but in many cases, it could be only one call:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1272.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1273.1">control</span></span><span class="koboSpan" id="kobo.1274.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1275.1">protected</span></span><span class="koboSpan" id="kobo.1276.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1277.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1278.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1279.1">initialize_impl</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1280.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1281.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1282.1">"initializing control..."</span></span><span class="koboSpan" id="kobo.1283.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1284.1">'\n'</span></span><span class="koboSpan" id="kobo.1285.1">;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1286.1">public</span></span><span class="koboSpan" id="kobo.1287.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1288.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1289.1">initialize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1290.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1291.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1292.1">initialize_impl</span></span><span class="koboSpan" id="kobo.1293.1">();
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1294.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1295.1">button</span></span><span class="koboSpan" id="kobo.1296.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1297.1">public</span></span><span class="koboSpan" id="kobo.1298.1"> control
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1299.1">protected</span></span><span class="koboSpan" id="kobo.1300.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1301.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1302.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1303.1">initialize_impl</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1304.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1305.1">{
    control::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1306.1">initialize_impl</span></span><span class="koboSpan" id="kobo.1307.1">();
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1308.1">"initializing button..."</span></span><span class="koboSpan" id="kobo.1309.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1310.1">'\n'</span></span><span class="koboSpan" id="kobo.1311.1">;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1312.1">In this example, the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.1313.1">control</span></code><span class="koboSpan" id="kobo.1314.1"> has an additional method called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1315.1">initialize()</span></code><span class="koboSpan" id="kobo.1316.1"> (the previous content of the class was not shown to keep it simple) that calls a single non-public virtual method called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1317.1">initialize_impl()</span></code><span class="koboSpan" id="kobo.1318.1">, implemented differently in each derived class. </span><span class="koboSpan" id="kobo.1318.2">This does not incur much overhead – if any at all – since simple functions like this are most likely inlined by the compiler anyway.</span></p>
<h2 class="heading-2" id="_idParaDest-654"><span class="koboSpan" id="kobo.1319.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1320.1">Chapter 1, </span></em><em class="italic"><span class="koboSpan" id="kobo.1321.1">Use override and final for virtual methods</span></em><span class="koboSpan" id="kobo.1322.1">, to learn how to specify that a virtual function overrides another virtual function, as well as how to specify that a virtual function cannot be overridden in a derived class</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-655"><span class="koboSpan" id="kobo.1323.1">Handling friendship with the attorney-client idiom</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1324.1">Granting functions and classes access to the non-public parts of a class with a friend declaration is usually seen as a sign of bad design, as friendship breaks encapsulation and ties classes and functions. </span><span class="koboSpan" id="kobo.1324.2">Friends, whether they are classes or functions, get access to all the private members of a class, although they may only need to access parts of it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1325.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.1326.1">attorney-client idiom</span></strong><span class="koboSpan" id="kobo.1327.1"> provides</span><a id="_idIndexMarker1264"/><span class="koboSpan" id="kobo.1328.1"> a simple mechanism to restrict friends access to only designated private members of a class.</span></p>
<h2 class="heading-2" id="_idParaDest-656"><span class="koboSpan" id="kobo.1329.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1330.1">To demonstrate how to </span><a id="_idIndexMarker1265"/><span class="koboSpan" id="kobo.1331.1">implement this idiom, we will consider the following classes: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">Client</span></code><span class="koboSpan" id="kobo.1333.1">, which has some private member data and functions (the public interface is not important here), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">Friend</span></code><span class="koboSpan" id="kobo.1335.1">, which is supposed to access only parts of the private details, for instance, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1336.1">data1</span></code><span class="koboSpan" id="kobo.1337.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1338.1">action1()</span></code><span class="koboSpan" id="kobo.1339.1">, but has access to everything:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1340.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1341.1">Client</span></span><span class="koboSpan" id="kobo.1342.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1343.1">int</span></span><span class="koboSpan" id="kobo.1344.1"> data_1;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1345.1">int</span></span><span class="koboSpan" id="kobo.1346.1"> data_2;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1347.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1348.1">action1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1349.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1350.1">{}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1351.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1352.1">action2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1353.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1354.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1355.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1356.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1357.1">Friend</span></span><span class="koboSpan" id="kobo.1358.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1359.1">public</span></span><span class="koboSpan" id="kobo.1360.1">:
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1361.1">// public interface</span></span><span class="koboSpan" id="kobo.1362.1">
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1363.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1364.1">Friend</span></span><span class="koboSpan" id="kobo.1365.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1366.1">public</span></span><span class="koboSpan" id="kobo.1367.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1368.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1369.1">access_client_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1370.1">(Client&amp; c)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1371.1">{
    c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1372.1">action1</span></span><span class="koboSpan" id="kobo.1373.1">();
    c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1374.1">action2</span></span><span class="koboSpan" id="kobo.1375.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1376.1">auto</span></span><span class="koboSpan" id="kobo.1377.1"> d1 = c.data_1;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1378.1">auto</span></span><span class="koboSpan" id="kobo.1379.1"> d2 = c.data_1;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1380.1">To understand</span><a id="_idIndexMarker1266"/><span class="koboSpan" id="kobo.1381.1"> this idiom, you must be familiar with how friendship is declared in the C++ language and how it works.</span></p>
<h2 class="heading-2" id="_idParaDest-657"><span class="koboSpan" id="kobo.1382.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1383.1">Take the following steps to restrict a friend’s access to only the private members of a class that you need access to:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1384.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1385.1">Client</span></code><span class="koboSpan" id="kobo.1386.1"> class, which provides access to all its private members to a friend, declare the friendships to an intermediate class, called the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1387.1">Attorney</span></code><span class="koboSpan" id="kobo.1388.1"> class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1389.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1390.1">Client</span></span><span class="koboSpan" id="kobo.1391.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1392.1">int</span></span><span class="koboSpan" id="kobo.1393.1"> data_1;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1394.1">int</span></span><span class="koboSpan" id="kobo.1395.1"> data_2;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1396.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1397.1">action1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1398.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1399.1">{}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1400.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1401.1">action2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1402.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1403.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1404.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1405.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1406.1">Attorney</span></span><span class="koboSpan" id="kobo.1407.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1408.1">public</span></span><span class="koboSpan" id="kobo.1409.1">:
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1410.1">// public interface</span></span><span class="koboSpan" id="kobo.1411.1">
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1412.1">Create a class that contains only private (inline) functions that access the private members of the client. </span><span class="koboSpan" id="kobo.1412.2">This intermediate class allows the actual friend to access its private members:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1413.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1414.1">Attorney</span></span><span class="koboSpan" id="kobo.1415.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1416.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1417.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1418.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1419.1">run_action1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1420.1">(Client&amp; c)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1421.1">{
    c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1422.1">action1</span></span><span class="koboSpan" id="kobo.1423.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1424.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1425.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1426.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1427.1">get_data1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1428.1">(Client&amp; c)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1429.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1430.1">return</span></span><span class="koboSpan" id="kobo.1431.1"> c.data_1;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1432.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1433.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1434.1">Friend</span></span><span class="koboSpan" id="kobo.1435.1">;
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1436.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1437.1">Friend</span></code><span class="koboSpan" id="kobo.1438.1"> class, access the private members of only the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1439.1">Client</span></code><span class="koboSpan" id="kobo.1440.1"> class indirectly through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1441.1">Attorney</span></code><span class="koboSpan" id="kobo.1442.1"> class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1443.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1444.1">Friend</span></span><span class="koboSpan" id="kobo.1445.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1446.1">public</span></span><span class="koboSpan" id="kobo.1447.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1448.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1449.1">access_client_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1450.1">(Client&amp; c)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1451.1">{
    Attorney::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1452.1">run_action1</span></span><span class="koboSpan" id="kobo.1453.1">(c);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1454.1">auto</span></span><span class="koboSpan" id="kobo.1455.1"> d1 = Attorney::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1456.1">get_data1</span></span><span class="koboSpan" id="kobo.1457.1">(c);
  }
};
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-658"><span class="koboSpan" id="kobo.1458.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1459.1">The </span><a id="_idIndexMarker1267"/><span class="koboSpan" id="kobo.1460.1">attorney-client idiom lays out a simple mechanism to restrict access to the private members of the client by introducing a middleman, the attorney. </span><span class="koboSpan" id="kobo.1460.2">Instead of providing friendship directly to those using its internal state, the client class offers friendship to an attorney, which, in turn, provides access to a restricted set of private data or functions of the client. </span><span class="koboSpan" id="kobo.1460.3">It does so by defining private static functions. </span><span class="koboSpan" id="kobo.1460.4">Usually, these are also inline functions, which avoids any runtime overhead due to the level of indirection the attorney class introduces. </span><span class="koboSpan" id="kobo.1460.5">The client’s friend gets access to its private members by actually using the private members of the attorney. </span><span class="koboSpan" id="kobo.1460.6">This idiom is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1461.1">attorney-client</span></strong><span class="koboSpan" id="kobo.1462.1"> because it is similar to the way an attorney-client relationship works, with the attorney knowing all the secrets of the client, but exposing only some of them to other parties.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1463.1">In practice, it might be necessary to create more than one attorney for a client class if different friend classes or functions must access different private members.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1464.1">On the other hand, friendship is not inheritable, which means that a class or function that is friend to class </span><code class="inlineCode"><span class="koboSpan" id="kobo.1465.1">B</span></code><span class="koboSpan" id="kobo.1466.1"> is not friend with class </span><code class="inlineCode"><span class="koboSpan" id="kobo.1467.1">D</span></code><span class="koboSpan" id="kobo.1468.1">, which is derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1469.1">B</span></code><span class="koboSpan" id="kobo.1470.1">. </span><span class="koboSpan" id="kobo.1470.2">However, virtual </span><a id="_idIndexMarker1268"/><span class="koboSpan" id="kobo.1471.1">functions overridden in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1472.1">D</span></code><span class="koboSpan" id="kobo.1473.1"> are still accessible polymorphically through a pointer or reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1474.1">B</span></code><span class="koboSpan" id="kobo.1475.1"> from a friend class. </span><span class="koboSpan" id="kobo.1475.2">Such an example is shown as follows, where calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1476.1">run()</span></code><span class="koboSpan" id="kobo.1477.1"> method from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1478.1">F</span></code><span class="koboSpan" id="kobo.1479.1"> prints </span><code class="inlineCode"><span class="koboSpan" id="kobo.1480.1">base</span></code><span class="koboSpan" id="kobo.1481.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1482.1">derived</span></code><span class="koboSpan" id="kobo.1483.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1484.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1485.1">B</span></span><span class="koboSpan" id="kobo.1486.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1487.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1488.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1489.1">execute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1490.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1491.1">{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1492.1">"base"</span></span><span class="koboSpan" id="kobo.1493.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1494.1">'\n'</span></span><span class="koboSpan" id="kobo.1495.1">; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1496.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1497.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1498.1">BAttorney</span></span><span class="koboSpan" id="kobo.1499.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1500.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1501.1">D</span></span><span class="koboSpan" id="kobo.1502.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1503.1">public</span></span><span class="koboSpan" id="kobo.1504.1"> B
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1505.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1506.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1507.1">execute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1508.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1509.1">override</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1510.1">{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1511.1">"derived"</span></span><span class="koboSpan" id="kobo.1512.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1513.1">'\n'</span></span><span class="koboSpan" id="kobo.1514.1">; }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1515.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1516.1">BAttorney</span></span><span class="koboSpan" id="kobo.1517.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1518.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1519.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1520.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1521.1">execute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1522.1">(B&amp; b)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1523.1">{
    b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1524.1">execute</span></span><span class="koboSpan" id="kobo.1525.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1526.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1527.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1528.1">F</span></span><span class="koboSpan" id="kobo.1529.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1530.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1531.1">F</span></span><span class="koboSpan" id="kobo.1532.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1533.1">public</span></span><span class="koboSpan" id="kobo.1534.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1535.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1536.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1537.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1538.1">{
    B b;
    BAttorney::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1539.1">execute</span></span><span class="koboSpan" id="kobo.1540.1">(b); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1541.1">// prints 'base'</span></span><span class="koboSpan" id="kobo.1542.1">
    D d;
    BAttorney::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1543.1">execute</span></span><span class="koboSpan" id="kobo.1544.1">(d); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1545.1">// prints 'derived'</span></span><span class="koboSpan" id="kobo.1546.1">
  }
};
F;
f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1547.1">run</span></span><span class="koboSpan" id="kobo.1548.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1549.1">There are </span><a id="_idIndexMarker1269"/><span class="koboSpan" id="kobo.1550.1">always trade-offs to using a design pattern, and this one is no exception. </span><span class="koboSpan" id="kobo.1550.2">There are situations when using this pattern may lead to too much overhead on development, testing, and maintenance. </span><span class="koboSpan" id="kobo.1550.3">However, the pattern could prove extremely valuable for some types of applications, such as extensible frameworks.</span></p>
<h2 class="heading-2" id="_idParaDest-659"><span class="koboSpan" id="kobo.1551.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1552.1">Implementing the pimpl idiom,</span></em><span class="koboSpan" id="kobo.1553.1"> to learn a technique that enables the separation of the implementation details from an interface</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-660"><span class="koboSpan" id="kobo.1554.1">Static polymorphism with the curiously recurring template pattern</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1555.1">Polymorphism provides </span><a id="_idIndexMarker1270"/><span class="koboSpan" id="kobo.1556.1">us with the ability to have multiple forms for the same interface. </span><span class="koboSpan" id="kobo.1556.2">Virtual functions allow derived classes to override implementations from a base</span><a id="_idIndexMarker1271"/><span class="koboSpan" id="kobo.1557.1"> class. </span><span class="koboSpan" id="kobo.1557.2">They represent the most common elements of a form of polymorphism, called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1558.1">runtime polymorphism</span></strong><span class="koboSpan" id="kobo.1559.1">, because</span><a id="_idIndexMarker1272"/><span class="koboSpan" id="kobo.1560.1"> the decision to call a particular virtual function from the class hierarchy happens at runtime. </span><span class="koboSpan" id="kobo.1560.2">It is also </span><a id="_idIndexMarker1273"/><span class="koboSpan" id="kobo.1561.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1562.1">late binding</span></strong><span class="koboSpan" id="kobo.1563.1">, because the binding between a function call and the invocation of the function happens late, during the</span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.1564.1"> execution of the program. </span><span class="koboSpan" id="kobo.1564.2">The </span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.1565.1">opposite </span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.1566.1">of this is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1567.1">early binding</span></strong><span class="koboSpan" id="kobo.1568.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.1569.1">static polymorphism</span></strong><span class="koboSpan" id="kobo.1570.1">, or </span><strong class="keyWord"><span class="koboSpan" id="kobo.1571.1">compile-time polymorphism</span></strong><span class="koboSpan" id="kobo.1572.1"> because it </span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.1573.1">occurs at </span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.1574.1">compile time through functions and operators overloading.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1575.1">On the other hand, a technique </span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.1576.1">called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1577.1">curiously recurring template pattern</span></strong><span class="koboSpan" id="kobo.1578.1"> (or </span><strong class="keyWord"><span class="koboSpan" id="kobo.1579.1">CRTP</span></strong><span class="koboSpan" id="kobo.1580.1">) allows simulating the virtual functions-based runtime polymorphism at compile time, by deriving classes from a base class template parameterized with the derived class. </span><span class="koboSpan" id="kobo.1580.2">This technique is used extensively in some libraries, including</span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.1581.1"> Microsoft’s </span><strong class="keyWord"><span class="koboSpan" id="kobo.1582.1">Active Template Library</span></strong><span class="koboSpan" id="kobo.1583.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1584.1">ATL</span></strong><span class="koboSpan" id="kobo.1585.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.1586.1">Windows Template Library</span></strong><span class="koboSpan" id="kobo.1587.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1588.1">WTL</span></strong><span class="koboSpan" id="kobo.1589.1">). </span><span class="koboSpan" id="kobo.1589.2">In </span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.1590.1">this recipe, we will explore CRTP and learn how to implement it and how it works.</span></p>
<h2 class="heading-2" id="_idParaDest-661"><span class="koboSpan" id="kobo.1591.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1592.1">To demonstrate how CRTP works, we will revisit the example with the hierarchy of control classes we implemented in the </span><em class="italic"><span class="koboSpan" id="kobo.1593.1">Separating interfaces and implementations with the non-virtual interface idiom</span></em><span class="koboSpan" id="kobo.1594.1"> recipe. </span><span class="koboSpan" id="kobo.1594.2">We will define a set of control classes that have functionalities such as drawing the control, which is (in our example) an operation done in two phases: erasing the background and then painting the control. </span><span class="koboSpan" id="kobo.1594.3">For simplicity, in our implementation, these will be operations that will only print text to the console.</span></p>
<h2 class="heading-2" id="_idParaDest-662"><span class="koboSpan" id="kobo.1595.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1596.1">To implement</span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.1597.1"> the curiously recurring template pattern in order to achieve static polymorphism, do the</span><a id="_idIndexMarker1283"/><span class="koboSpan" id="kobo.1598.1"> following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1599.1">Provide a class template that will represent the base class for other classes that should be treated polymorphically at compile time. </span><span class="koboSpan" id="kobo.1599.2">Polymorphic functions are invoked from this class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1600.1">template</span></span><span class="koboSpan" id="kobo.1601.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1602.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1603.1">T</span></span><span class="koboSpan" id="kobo.1604.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1605.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1606.1">control</span></span><span class="koboSpan" id="kobo.1607.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1608.1">public</span></span><span class="koboSpan" id="kobo.1609.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1610.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1611.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1612.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1613.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1614.1">static_cast</span></span><span class="koboSpan" id="kobo.1615.1">&lt;T*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1616.1">this</span></span><span class="koboSpan" id="kobo.1617.1">)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1618.1">erase_background</span></span><span class="koboSpan" id="kobo.1619.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1620.1">static_cast</span></span><span class="koboSpan" id="kobo.1621.1">&lt;T*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1622.1">this</span></span><span class="koboSpan" id="kobo.1623.1">)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1624.1">paint</span></span><span class="koboSpan" id="kobo.1625.1">();
  }
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1626.1">Derived classes use the class template as their base class; the derived class is also the template argument for the base class. </span><span class="koboSpan" id="kobo.1626.2">The derived class implements the functions that are invoked from the base class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1627.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1628.1">button</span></span><span class="koboSpan" id="kobo.1629.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1630.1">public</span></span><span class="koboSpan" id="kobo.1631.1"> control&lt;button&gt;
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1632.1">public</span></span><span class="koboSpan" id="kobo.1633.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1634.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1635.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1636.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1637.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1638.1">"erasing button background..."</span></span><span class="koboSpan" id="kobo.1639.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1640.1">'\n'</span></span><span class="koboSpan" id="kobo.1641.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1642.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1643.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1644.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1645.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1646.1">"painting button..."</span></span><span class="koboSpan" id="kobo.1647.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1648.1">'\n'</span></span><span class="koboSpan" id="kobo.1649.1">;
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1650.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1651.1">checkbox</span></span><span class="koboSpan" id="kobo.1652.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1653.1">public</span></span><span class="koboSpan" id="kobo.1654.1"> control&lt;checkbox&gt;
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1655.1">public</span></span><span class="koboSpan" id="kobo.1656.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1657.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1658.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1659.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1660.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1661.1">"erasing checkbox background..."</span></span><span class="koboSpan" id="kobo.1662.1"> 
              &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1663.1">'\n'</span></span><span class="koboSpan" id="kobo.1664.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1665.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1666.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1667.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1668.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1669.1">"painting checkbox..."</span></span><span class="koboSpan" id="kobo.1670.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1671.1">'\n'</span></span><span class="koboSpan" id="kobo.1672.1">;
  }
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1673.1">Function </span><a id="_idIndexMarker1284"/><span class="koboSpan" id="kobo.1674.1">templates can handle derived classes polymorphically</span><a id="_idIndexMarker1285"/><span class="koboSpan" id="kobo.1675.1"> through a pointer or reference to the base class template:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1676.1">template</span></span><span class="koboSpan" id="kobo.1677.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1678.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1679.1">T</span></span><span class="koboSpan" id="kobo.1680.1">&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1681.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1682.1">draw_control</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1683.1">(control&lt;T&gt;&amp; c)</span></span><span class="koboSpan" id="kobo.1684.1">
{
  c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1685.1">draw</span></span><span class="koboSpan" id="kobo.1686.1">();
}
button b;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1687.1">draw_control</span></span><span class="koboSpan" id="kobo.1688.1">(b);
checkbox c;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1689.1">draw_control</span></span><span class="koboSpan" id="kobo.1690.1">(c);
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-663"><span class="koboSpan" id="kobo.1691.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1692.1">Virtual functions can represent a performance issue, especially when they are small and called multiple times in a loop. </span><span class="koboSpan" id="kobo.1692.2">Modern hardware has made most of these situations rather irrelevant, but there are still some categories of applications where performance is critical and any performance gains are important. </span><span class="koboSpan" id="kobo.1692.3">The curiously recurring template pattern enables the simulation of virtual calls at compile time using metaprogramming, which eventually translates to functions overloading.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1693.1">This </span><a id="_idIndexMarker1286"/><span class="koboSpan" id="kobo.1694.1">pattern may look rather strange at first glance, but it is perfectly legal. </span><span class="koboSpan" id="kobo.1694.2">The idea is to derive a class from a base class that is a template class, and then pass the derived class itself for the type template parameter of the base class. </span><span class="koboSpan" id="kobo.1694.3">The base class then makes calls to the derived class functions. </span><span class="koboSpan" id="kobo.1694.4">In our example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1695.1">control&lt;button&gt;::draw()</span></code><span class="koboSpan" id="kobo.1696.1"> is declared before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1697.1">button</span></code><span class="koboSpan" id="kobo.1698.1"> class is known to the compiler. </span><span class="koboSpan" id="kobo.1698.2">However, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1699.1">control</span></code><span class="koboSpan" id="kobo.1700.1"> class is a class template, which means it is instantiated only when the compiler encounters code that uses it. </span><span class="koboSpan" id="kobo.1700.2">At that point, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1701.1">button</span></code><span class="koboSpan" id="kobo.1702.1"> class, in this example, is already defined and known to the compiler, so calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1703.1">button::erase_background()</span></code><span class="koboSpan" id="kobo.1704.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1705.1">button::paint()</span></code><span class="koboSpan" id="kobo.1706.1"> can be made.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1707.1">To invoke the functions from the derived class, we must first obtain a pointer to the derived class. </span><span class="koboSpan" id="kobo.1707.2">That is done with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1708.1">static_cast</span></code><span class="koboSpan" id="kobo.1709.1"> conversion, as seen in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1710.1">static_cast&lt;T*&gt;(this)-&gt;erase_background()</span></code><span class="koboSpan" id="kobo.1711.1">. </span><span class="koboSpan" id="kobo.1711.2">If this has to be done many times, the code can be simplified by providing a private function to do that:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1712.1">template</span></span><span class="koboSpan" id="kobo.1713.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1714.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1715.1">T</span></span><span class="koboSpan" id="kobo.1716.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1717.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1718.1">control</span></span><span class="koboSpan" id="kobo.1719.1">
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.1720.1">T* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1721.1">derived</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1722.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1723.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1724.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1725.1">static_cast</span></span><span class="koboSpan" id="kobo.1726.1">&lt;T*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1727.1">this</span></span><span class="koboSpan" id="kobo.1728.1">); }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1729.1">public</span></span><span class="koboSpan" id="kobo.1730.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1731.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1732.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1733.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1734.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1735.1">derived</span></span><span class="koboSpan" id="kobo.1736.1">()-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1737.1">erase_background</span></span><span class="koboSpan" id="kobo.1738.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1739.1">derived</span></span><span class="koboSpan" id="kobo.1740.1">()-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1741.1">paint</span></span><span class="koboSpan" id="kobo.1742.1">();
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1743.1">There are some pitfalls when using CRTP that you must be aware of:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1744.1">All the functions in the derived classes that are called from the base class template must be public; otherwise, the base class specialization must be declared a friend of the derived class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1745.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1746.1">button</span></span><span class="koboSpan" id="kobo.1747.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1748.1">public</span></span><span class="koboSpan" id="kobo.1749.1"> control&lt;button&gt;
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1750.1">private</span></span><span class="koboSpan" id="kobo.1751.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1752.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1753.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1754.1">control</span></span><span class="koboSpan" id="kobo.1755.1">&lt;button&gt;;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1756.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1757.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1758.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1759.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1760.1">"erasing button background..."</span></span><span class="koboSpan" id="kobo.1761.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1762.1">'\n'</span></span><span class="koboSpan" id="kobo.1763.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1764.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1765.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1766.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1767.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1768.1">"painting button..."</span></span><span class="koboSpan" id="kobo.1769.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1770.1">'\n'</span></span><span class="koboSpan" id="kobo.1771.1">;
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1772.1">It is not possible to store, in a homogeneous container, such as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1773.1">vector</span></code><span class="koboSpan" id="kobo.1774.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1775.1">list</span></code><span class="koboSpan" id="kobo.1776.1">, objects of CRTP types because each base class is a unique type (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1777.1">control&lt;button&gt;</span></code><span class="koboSpan" id="kobo.1778.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1779.1">control&lt;checkbox&gt;</span></code><span class="koboSpan" id="kobo.1780.1">). </span><span class="koboSpan" id="kobo.1780.2">If this is actually necessary, then a workaround can be used to implement it. </span><span class="koboSpan" id="kobo.1780.3">This will be discussed and exemplified in the next section.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1781.1">When using this technique, the size of a program may increase, because of the way templates are instantiated.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-664"><span class="koboSpan" id="kobo.1782.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1783.1">When </span><a id="_idIndexMarker1287"/><span class="koboSpan" id="kobo.1784.1">objects of types implementing CRTP need to be stored homogeneously in a container, an additional idiom must be used. </span><span class="koboSpan" id="kobo.1784.2">The base class template must itself be derived from another class with pure virtual functions (and a virtual public destructor). </span><span class="koboSpan" id="kobo.1784.3">To exemplify this on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1785.1">control</span></code><span class="koboSpan" id="kobo.1786.1"> class, the following changes are necessary:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1787.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1788.1">controlbase</span></span><span class="koboSpan" id="kobo.1789.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1790.1">public</span></span><span class="koboSpan" id="kobo.1791.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1792.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1793.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1794.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1795.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1796.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1797.1">0</span></span><span class="koboSpan" id="kobo.1798.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1799.1">virtual</span></span><span class="koboSpan" id="kobo.1800.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1801.1">controlbase</span></span><span class="koboSpan" id="kobo.1802.1">() {}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1803.1">template</span></span><span class="koboSpan" id="kobo.1804.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1805.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1806.1">T</span></span><span class="koboSpan" id="kobo.1807.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1808.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1809.1">control</span></span><span class="koboSpan" id="kobo.1810.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1811.1">public</span></span><span class="koboSpan" id="kobo.1812.1"> controlbase
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1813.1">public</span></span><span class="koboSpan" id="kobo.1814.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1815.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1816.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1817.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1818.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1819.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1820.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1821.1">static_cast</span></span><span class="koboSpan" id="kobo.1822.1">&lt;T*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1823.1">this</span></span><span class="koboSpan" id="kobo.1824.1">)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1825.1">erase_background</span></span><span class="koboSpan" id="kobo.1826.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1827.1">static_cast</span></span><span class="koboSpan" id="kobo.1828.1">&lt;T*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1829.1">this</span></span><span class="koboSpan" id="kobo.1830.1">)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1831.1">paint</span></span><span class="koboSpan" id="kobo.1832.1">();
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1833.1">No changes need to be made to the derived classes, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1834.1">button</span></code><span class="koboSpan" id="kobo.1835.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1836.1">checkbox</span></code><span class="koboSpan" id="kobo.1837.1">. </span><span class="koboSpan" id="kobo.1837.2">Then, we can store</span><a id="_idIndexMarker1288"/><span class="koboSpan" id="kobo.1838.1"> pointers to the abstract class in a container, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1839.1">std::vector</span></code><span class="koboSpan" id="kobo.1840.1">, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1841.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1842.1">draw_controls</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1843.1">(std::vector&lt;std::unique_ptr&lt;controlbase&gt;&gt;&amp; v)</span></span><span class="koboSpan" id="kobo.1844.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1845.1">for</span></span><span class="koboSpan" id="kobo.1846.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1847.1">auto</span></span><span class="koboSpan" id="kobo.1848.1"> &amp; c : v)
  {
    c-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1849.1">draw</span></span><span class="koboSpan" id="kobo.1850.1">();
  }
}
std::vector&lt;std::unique_ptr&lt;controlbase&gt;&gt; v;
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1851.1">emplace_back</span></span><span class="koboSpan" id="kobo.1852.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1853.1">make_unique</span></span><span class="koboSpan" id="kobo.1854.1">&lt;button&gt;());
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1855.1">emplace_back</span></span><span class="koboSpan" id="kobo.1856.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1857.1">make_unique</span></span><span class="koboSpan" id="kobo.1858.1">&lt;checkbox&gt;());
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1859.1">draw_controls</span></span><span class="koboSpan" id="kobo.1860.1">(v);
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-665"><span class="koboSpan" id="kobo.1861.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1862.1">Implementing the pimpl idiom</span></em><span class="koboSpan" id="kobo.1863.1">, to learn a technique that enables the separation of the implementation details from an interface</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1864.1">Separating interfaces and implementations with the non-virtual interface idiom</span></em><span class="koboSpan" id="kobo.1865.1">, to explore an idiom that promotes the separation of concerns of interfaces and implementations by making (public) interfaces non-virtual and virtual functions private</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-666"><span class="koboSpan" id="kobo.1866.1">Adding functionality to classes with mixins</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1867.1">In the previous recipe, we learned about a pattern called the curiously recurring template pattern, or CRTP for short, and how it can be used to add common functionality to classes. </span><span class="koboSpan" id="kobo.1867.2">This is not its only use; other use cases include limiting the number of times that a type can be instantiated and implementing the composite pattern. </span><span class="koboSpan" id="kobo.1867.3">Related to this pattern, there is another one</span><a id="_idIndexMarker1289"/><span class="koboSpan" id="kobo.1868.1"> called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1869.1">mixins</span></strong><span class="koboSpan" id="kobo.1870.1">. </span><span class="koboSpan" id="kobo.1870.2">Mixins are small classes that are designed to add functionality to other existing classes. </span><span class="koboSpan" id="kobo.1870.3">You can probably find articles about this pattern claiming that it’s implemented using CRTP. </span><span class="koboSpan" id="kobo.1870.4">That is not correct. </span><span class="koboSpan" id="kobo.1870.5">Indeed, CRTP and mixins are similar patterns and both are used to add functionality to classes, but they don’t have the same structure. </span><span class="koboSpan" id="kobo.1870.6">With CRTP, the base class adds functionality to the classes that derive from it. </span><span class="koboSpan" id="kobo.1870.7">A mixin class adds functionality to a class that it derives from. </span><span class="koboSpan" id="kobo.1870.8">Therefore, in a way, it is an upside-down CRTP. </span><span class="koboSpan" id="kobo.1870.9">In this recipe, you will learn how to use mixins to add common functionality to classes. </span><span class="koboSpan" id="kobo.1870.10">For this purpose, we will examine the same example of drawing controls (such as buttons and checkboxes). </span><span class="koboSpan" id="kobo.1870.11">This will enable a good comparison with CRTP, which will allow you to better understand the differences (and similarities) between the two.</span></p>
<h2 class="heading-2" id="_idParaDest-667"><span class="koboSpan" id="kobo.1871.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1872.1">To </span><a id="_idIndexMarker1290"/><span class="koboSpan" id="kobo.1873.1">implement the mixins pattern to add common functionality to existing classes, do the following (in the following example the common functionality in question is painting the background and content of controls):</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1874.1">Consider (possibly unrelated) classes that exhibit common functionality:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1875.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1876.1">button</span></span><span class="koboSpan" id="kobo.1877.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1878.1">public</span></span><span class="koboSpan" id="kobo.1879.1">:
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1880.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1881.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1882.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1883.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1884.1">"erasing button background..."</span></span><span class="koboSpan" id="kobo.1885.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1886.1">'\n'</span></span><span class="koboSpan" id="kobo.1887.1">;
   }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1888.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1889.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1890.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1891.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1892.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1893.1">painting button..."</span></span><span class="koboSpan" id="kobo.1894.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1895.1">'\n'</span></span><span class="koboSpan" id="kobo.1896.1">;
   }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1897.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1898.1">checkbox</span></span><span class="koboSpan" id="kobo.1899.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1900.1">public</span></span><span class="koboSpan" id="kobo.1901.1">:
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1902.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1903.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1904.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1905.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1906.1">"erasing checkbox background..."</span></span><span class="koboSpan" id="kobo.1907.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1908.1">'\n'</span></span><span class="koboSpan" id="kobo.1909.1">;
   }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1910.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1911.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1912.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1913.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1914.1">"painting checkbox..."</span></span><span class="koboSpan" id="kobo.1915.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1916.1">'\n'</span></span><span class="koboSpan" id="kobo.1917.1">;
   }
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1918.1">Create</span><a id="_idIndexMarker1291"/><span class="koboSpan" id="kobo.1919.1"> a class template that derives from its type template parameter. </span><span class="koboSpan" id="kobo.1919.2">This mixin class defines some new functionality that is implemented in terms of existing functionality from the base class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1920.1">template</span></span><span class="koboSpan" id="kobo.1921.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1922.1">typename</span></span><span class="koboSpan" id="kobo.1923.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1924.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1925.1">control</span></span><span class="koboSpan" id="kobo.1926.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1927.1">public</span></span><span class="koboSpan" id="kobo.1928.1"> T
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1929.1">public</span></span><span class="koboSpan" id="kobo.1930.1">:
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1931.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1932.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1933.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1934.1">{
      T::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1935.1">erase_background</span></span><span class="koboSpan" id="kobo.1936.1">();
      T::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1937.1">paint</span></span><span class="koboSpan" id="kobo.1938.1">();
   }
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1939.1">Instantiate and use objects of the mixin class to utilize the added functionality:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1940.1">control&lt;button&gt; b;
b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1941.1">draw</span></span><span class="koboSpan" id="kobo.1942.1">();
control&lt;checkbox&gt; c;
c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1943.1">draw</span></span><span class="koboSpan" id="kobo.1944.1">();
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-668"><span class="koboSpan" id="kobo.1945.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1946.1">A mixin is a concept that allows us to add new functionality to existing classes. </span><span class="koboSpan" id="kobo.1946.2">The pattern is implemented differently in many programming languages. </span><span class="koboSpan" id="kobo.1946.3">In C++, a mixin is a small class that adds functionality to an existing one (without having to make any changes to the existing class). </span><span class="koboSpan" id="kobo.1946.4">For this, you need to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1947.1">Make the mixin class a template. </span><span class="koboSpan" id="kobo.1947.2">In our example, this was the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1948.1">control</span></code><span class="koboSpan" id="kobo.1949.1"> class. </span><span class="koboSpan" id="kobo.1949.2">If there is only one type that is supposed to be extended, then there is no need to use a template, since there would be no code duplication. </span><span class="koboSpan" id="kobo.1949.3">However, in practice, this is usually intended to add common functionality for multiple similar classes.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1950.1">Derive it from its type template parameter, which is supposed to be instantiated with the types to be extended. </span><span class="koboSpan" id="kobo.1950.2">Implement the added functionality by reusing functionality from the type template parameter class. </span><span class="koboSpan" id="kobo.1950.3">In our example, the new functionality was </span><code class="inlineCode"><span class="koboSpan" id="kobo.1951.1">draw()</span></code><span class="koboSpan" id="kobo.1952.1">, which used </span><code class="inlineCode"><span class="koboSpan" id="kobo.1953.1">T::erase_background()</span></code><span class="koboSpan" id="kobo.1954.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1955.1">T::paint()</span></code><span class="koboSpan" id="kobo.1956.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1957.1">Since </span><a id="_idIndexMarker1292"/><span class="koboSpan" id="kobo.1958.1">the mixin class is a template, it cannot be handled polymorphically. </span><span class="koboSpan" id="kobo.1958.2">For instance, perhaps you want to have a function that should be able to draw both buttons and checkboxes and any other drawable controls. </span><span class="koboSpan" id="kobo.1958.3">This function could look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1959.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1960.1">draw_all</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1961.1">(std::vector&lt;???*&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1962.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1963.1"> &amp; controls)</span></span><span class="koboSpan" id="kobo.1964.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1965.1">for</span></span><span class="koboSpan" id="kobo.1966.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1967.1">auto</span></span><span class="koboSpan" id="kobo.1968.1">&amp; c : controls)
   {
      c-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1969.1">draw</span></span><span class="koboSpan" id="kobo.1970.1">();
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1971.1">But what does </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">???</span></code><span class="koboSpan" id="kobo.1973.1"> stand for in this snippet? </span><span class="koboSpan" id="kobo.1973.2">We need a non-template base class for this to work polymorphically. </span><span class="koboSpan" id="kobo.1973.3">Such a base class can look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1974.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1975.1">control_base</span></span><span class="koboSpan" id="kobo.1976.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1977.1">public</span></span><span class="koboSpan" id="kobo.1978.1">:
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1979.1">virtual</span></span><span class="koboSpan" id="kobo.1980.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1981.1">control_base</span></span><span class="koboSpan" id="kobo.1982.1">() {}
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1983.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1984.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1985.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1986.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1987.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1988.1">0</span></span><span class="koboSpan" id="kobo.1989.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1990.1">The mixin class (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1991.1">control</span></code><span class="koboSpan" id="kobo.1992.1">) needs to also derive from this base class (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1993.1">control_base</span></code><span class="koboSpan" id="kobo.1994.1">) and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1995.1">draw()</span></code><span class="koboSpan" id="kobo.1996.1"> function becomes an overridden virtual function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1997.1">template</span></span><span class="koboSpan" id="kobo.1998.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1999.1">typename</span></span><span class="koboSpan" id="kobo.2000.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2001.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2002.1">control</span></span><span class="koboSpan" id="kobo.2003.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2004.1">public</span></span><span class="koboSpan" id="kobo.2005.1"> control_base, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2006.1">public</span></span><span class="koboSpan" id="kobo.2007.1"> T 
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2008.1">public</span></span><span class="koboSpan" id="kobo.2009.1">:
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2010.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2011.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2012.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2013.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2014.1">{
      T::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2015.1">erase_background</span></span><span class="koboSpan" id="kobo.2016.1">();
      T::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2017.1">paint</span></span><span class="koboSpan" id="kobo.2018.1">();
   }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2019.1">This allows us to treat control objects polymorphically, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2020.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2021.1">draw_all</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2022.1">(std::vector&lt;control_base*&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2023.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2024.1"> &amp; controls)</span></span><span class="koboSpan" id="kobo.2025.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2026.1">for</span></span><span class="koboSpan" id="kobo.2027.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2028.1">auto</span></span><span class="koboSpan" id="kobo.2029.1">&amp; c : controls)
   {
      c-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2030.1">draw</span></span><span class="koboSpan" id="kobo.2031.1">();
   }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2032.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2033.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2034.1">()</span></span><span class="koboSpan" id="kobo.2035.1">
{
   std::vector&lt;control_base*&gt; controls;
   control&lt;button&gt; b;
   control&lt;checkbox&gt; c;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2036.1">draw_all</span></span><span class="koboSpan" id="kobo.2037.1">({&amp;b, &amp;c});
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2038.1">As you </span><a id="_idIndexMarker1293"/><span class="koboSpan" id="kobo.2039.1">can see from this recipe and the previous one, mixins and CRTP are both used for the same purpose of adding functionality to classes. </span><span class="koboSpan" id="kobo.2039.2">Moreover, they look similar, although the actual pattern structure is different.</span></p>
<h2 class="heading-2" id="_idParaDest-669"><span class="koboSpan" id="kobo.2040.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2041.1">Static polymorphism with the curiously recurring template pattern</span></em><span class="koboSpan" id="kobo.2042.1">, to learn about CRTP, which allows the simulation of runtime polymorphism at compile time by deriving classes from a base class template parameterized with the derived class</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-670"><span class="koboSpan" id="kobo.2043.1">Handling unrelated types generically with the type erasure idiom</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2044.1">Polymorphism (and more specifically runtime polymorphism in C++) allows us to treat hierarchies of classes in a generic way. </span><span class="koboSpan" id="kobo.2044.2">However, there are cases when we want to do the same</span><a id="_idIndexMarker1294"/><span class="koboSpan" id="kobo.2045.1"> but with classes that do not inherit from a common base class. </span><span class="koboSpan" id="kobo.2045.2">This can happen when we do not own the code or, for various reasons, cannot change the code to create a hierarchy. </span><span class="koboSpan" id="kobo.2045.3">This process of utilizing unrelated types that have some certain members (functions or variables) for given tasks (and only use those common members) is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2046.1">duck typing</span></strong><span class="koboSpan" id="kobo.2047.1">. </span><span class="koboSpan" id="kobo.2047.2">A </span><a id="_idIndexMarker1295"/><span class="koboSpan" id="kobo.2048.1">simple solution to this problem is to build a hierarchy of wrapper classes, one for each class that we want to handle generically. </span><span class="koboSpan" id="kobo.2048.2">This has drawbacks because there is a lot of boilerplate code and every time a new class needs to be handled in the same manner, a new wrapper must be created. </span><span class="koboSpan" id="kobo.2048.3">The alternative to this approach is an idiom </span><a id="_idIndexMarker1296"/><span class="koboSpan" id="kobo.2049.1">known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.2050.1">type erasure</span></strong><span class="koboSpan" id="kobo.2051.1">. </span><span class="koboSpan" id="kobo.2051.2">The term refers to the fact that information about concrete types is erased, allowing different and even unrelated types to be handled generically. </span><span class="koboSpan" id="kobo.2051.3">In this recipe, we will learn how this idiom works.</span></p>
<h2 class="heading-2" id="_idParaDest-671"><span class="koboSpan" id="kobo.2052.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2053.1">To showcase the type erasure idiom, we will use the following two classes, representing a button and a checkbox control:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2054.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2055.1">button</span></span><span class="koboSpan" id="kobo.2056.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2057.1">public</span></span><span class="koboSpan" id="kobo.2058.1">:
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2059.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2060.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2061.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2062.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2063.1">"erasing button background..."</span></span><span class="koboSpan" id="kobo.2064.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2065.1">'\n'</span></span><span class="koboSpan" id="kobo.2066.1">;
   }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2067.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2068.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2069.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2070.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2071.1">"painting button..."</span></span><span class="koboSpan" id="kobo.2072.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2073.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2074.1">\n'</span></span><span class="koboSpan" id="kobo.2075.1">;
   }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2076.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2077.1">checkbox</span></span><span class="koboSpan" id="kobo.2078.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2079.1">public</span></span><span class="koboSpan" id="kobo.2080.1">:
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2081.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2082.1">erase_background</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2083.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2084.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2085.1">"erasing checkbox background..."</span></span><span class="koboSpan" id="kobo.2086.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2087.1">'\n'</span></span><span class="koboSpan" id="kobo.2088.1">;
   }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2089.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2090.1">paint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2091.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2092.1">{
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2093.1">"painting checkbox..."</span></span><span class="koboSpan" id="kobo.2094.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2095.1">'\n'</span></span><span class="koboSpan" id="kobo.2096.1">;
   }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2097.1">These </span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.2098.1">are the same classes we have seen in various forms in the previous recipes. </span><span class="koboSpan" id="kobo.2098.2">They both have </span><code class="inlineCode"><span class="koboSpan" id="kobo.2099.1">erase_background()</span></code><span class="koboSpan" id="kobo.2100.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2101.1">paint()</span></code><span class="koboSpan" id="kobo.2102.1"> member functions but they do not have a common base class; therefore, they are not part of a hierarchy that would allow us to treat them polymorphically.</span></p>
<h2 class="heading-2" id="_idParaDest-672"><span class="koboSpan" id="kobo.2103.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2104.1">To implement the type erasure idiom, you need to follow these steps:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2105.1">Define a class that will provide the mechanism for erasing type information. </span><span class="koboSpan" id="kobo.2105.2">For the example that we showcase in this recipe that deals with controls, we will simply call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.2106.1">control</span></code><span class="koboSpan" id="kobo.2107.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2108.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2109.1">control</span></span><span class="koboSpan" id="kobo.2110.1">
{
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2111.1">Create an inner class (of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2112.1">control</span></code><span class="koboSpan" id="kobo.2113.1"> class) that defines the common interface for the types that need to be handled generically. </span><span class="koboSpan" id="kobo.2113.2">This interface is called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.2114.1">concept</span></strong><span class="koboSpan" id="kobo.2115.1">; therefore, we will call this class </span><code class="inlineCode"><span class="koboSpan" id="kobo.2116.1">control_concept</span></code><span class="koboSpan" id="kobo.2117.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2118.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2119.1">control_concept</span></span><span class="koboSpan" id="kobo.2120.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2121.1">virtual</span></span><span class="koboSpan" id="kobo.2122.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2123.1">control_concept</span></span><span class="koboSpan" id="kobo.2124.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2125.1">default</span></span><span class="koboSpan" id="kobo.2126.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2127.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2128.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2129.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2130.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2131.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2132.1">0</span></span><span class="koboSpan" id="kobo.2133.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2134.1">Create another inner class (of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2135.1">control</span></code><span class="koboSpan" id="kobo.2136.1"> class) that derives from the concept class. </span><span class="koboSpan" id="kobo.2136.2">However, this will be a class template, and its type template parameter represents a type that needs to be handled generically. </span><span class="koboSpan" id="kobo.2136.3">In our example, it will be substituted with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2137.1">button</span></code><span class="koboSpan" id="kobo.2138.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2139.1">checkbox</span></code><span class="koboSpan" id="kobo.2140.1">. </span><span class="koboSpan" id="kobo.2140.2">This implementation is called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.2141.1">model</span></strong><span class="koboSpan" id="kobo.2142.1">, and, therefore, we will call this class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2143.1">control_model</span></code><span class="koboSpan" id="kobo.2144.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2145.1">template</span></span><span class="koboSpan" id="kobo.2146.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2147.1">typename</span></span><span class="koboSpan" id="kobo.2148.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2149.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2150.1">control_model</span></span><span class="koboSpan" id="kobo.2151.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2152.1">public</span></span><span class="koboSpan" id="kobo.2153.1"> control_concept
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2154.1">control_model</span></span><span class="koboSpan" id="kobo.2155.1">(T &amp; unit) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2156.1">t</span></span><span class="koboSpan" id="kobo.2157.1">(unit) {}
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2158.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2159.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2160.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2161.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2162.1">{
      t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2163.1">erase_background</span></span><span class="koboSpan" id="kobo.2164.1">();
      t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2165.1">paint</span></span><span class="koboSpan" id="kobo.2166.1">();
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2167.1">private</span></span><span class="koboSpan" id="kobo.2168.1">:
   T&amp; t;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2169.1">Add a </span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.2170.1">data member to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2171.1">control</span></code><span class="koboSpan" id="kobo.2172.1"> class, representing a pointer to an instance of the concept. </span><span class="koboSpan" id="kobo.2172.2">In this recipe, we will use a smart pointer for this purpose:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2173.1">private</span></span><span class="koboSpan" id="kobo.2174.1">:
   std::shared_ptr&lt;control_concept&gt; ctrl;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2175.1">Define a constructor for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2176.1">control</span></code><span class="koboSpan" id="kobo.2177.1"> class. </span><span class="koboSpan" id="kobo.2177.2">This must be a function template, and it must set the concept pointer to an instance of a model:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2178.1">template</span></span><span class="koboSpan" id="kobo.2179.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2180.1">typename</span></span><span class="koboSpan" id="kobo.2181.1"> T&gt;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2182.1">control</span></span><span class="koboSpan" id="kobo.2183.1">(T&amp;&amp; obj) : 
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2184.1">ctrl</span></span><span class="koboSpan" id="kobo.2185.1">(std::make_shared&lt;control_model&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj)))
{
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2186.1">Define the public interface that clients of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2187.1">control</span></code><span class="koboSpan" id="kobo.2188.1"> class should be able to invoke. </span><span class="koboSpan" id="kobo.2188.2">In our example, this is a function to draw the control. </span><span class="koboSpan" id="kobo.2188.3">We will call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.2189.1">draw()</span></code><span class="koboSpan" id="kobo.2190.1"> (although it does not have to have the same name as the virtual method in the concept):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2191.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2192.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2193.1">()</span></span><span class="koboSpan" id="kobo.2194.1">
{
   ctrl-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2195.1">draw</span></span><span class="koboSpan" id="kobo.2196.1">();
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2197.1">Putting all this together, the type erasure idiom that handles unrelated control classes together </span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.2198.1">looks as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2199.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2200.1">control</span></span><span class="koboSpan" id="kobo.2201.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2202.1">template</span></span><span class="koboSpan" id="kobo.2203.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2204.1">typename</span></span><span class="koboSpan" id="kobo.2205.1"> T&gt;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2206.1">control</span></span><span class="koboSpan" id="kobo.2207.1">(T&amp;&amp; obj) : 
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2208.1">ctrl</span></span><span class="koboSpan" id="kobo.2209.1">(std::make_shared&lt;control_model&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj)))
   {
   }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2210.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2211.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2212.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2213.1">{
      ctrl-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2214.1">draw</span></span><span class="koboSpan" id="kobo.2215.1">();
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2216.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2217.1">control_concept</span></span><span class="koboSpan" id="kobo.2218.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2219.1">virtual</span></span><span class="koboSpan" id="kobo.2220.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2221.1">control_concept</span></span><span class="koboSpan" id="kobo.2222.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2223.1">default</span></span><span class="koboSpan" id="kobo.2224.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2225.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2226.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2227.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2228.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2229.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2230.1">0</span></span><span class="koboSpan" id="kobo.2231.1">;
   };
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2232.1">template</span></span><span class="koboSpan" id="kobo.2233.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2234.1">typename</span></span><span class="koboSpan" id="kobo.2235.1"> T&gt;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2236.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2237.1">control_model</span></span><span class="koboSpan" id="kobo.2238.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2239.1">public</span></span><span class="koboSpan" id="kobo.2240.1"> control_concept
   {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2241.1">control_model</span></span><span class="koboSpan" id="kobo.2242.1">(T&amp; unit) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2243.1">t</span></span><span class="koboSpan" id="kobo.2244.1">(unit) {}
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.2245.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2246.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2247.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2248.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2249.1">{
         t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2250.1">erase_background</span></span><span class="koboSpan" id="kobo.2251.1">();
         t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2252.1">paint</span></span><span class="koboSpan" id="kobo.2253.1">();
      }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2254.1">private</span></span><span class="koboSpan" id="kobo.2255.1">:
      T&amp; t;
   };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2256.1">private</span></span><span class="koboSpan" id="kobo.2257.1">:
   std::shared_ptr&lt;control_concept&gt; ctrl;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2258.1">We can use this wrapper class to handle buttons and checkboxes (and similar other classes) polymorphically, such as in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2259.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2260.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2261.1">(std::vector&lt;control&gt;&amp; controls)</span></span><span class="koboSpan" id="kobo.2262.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2263.1">for</span></span><span class="koboSpan" id="kobo.2264.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2265.1">auto</span></span><span class="koboSpan" id="kobo.2266.1">&amp; c : controls)
   {
      c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2267.1">draw</span></span><span class="koboSpan" id="kobo.2268.1">();
   }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2269.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2270.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2271.1">()</span></span><span class="koboSpan" id="kobo.2272.1">
{
   checkbox cb;
   button btn;
   std::vector&lt;control&gt; v{</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2273.1">control</span></span><span class="koboSpan" id="kobo.2274.1">(cb), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2275.1">control</span></span><span class="koboSpan" id="kobo.2276.1">(btn)};
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2277.1">draw</span></span><span class="koboSpan" id="kobo.2278.1">(v);
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-673"><span class="koboSpan" id="kobo.2279.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2280.1">The most</span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.2281.1"> rudimentary form of type erasure (and arguably the ultimate one) is to employ </span><code class="inlineCode"><span class="koboSpan" id="kobo.2282.1">void</span></code><span class="koboSpan" id="kobo.2283.1"> pointers. </span><span class="koboSpan" id="kobo.2283.2">Although this provides the mechanism for implementing the idiom in C, it should be avoided in C++ because it’s not type safe. </span><span class="koboSpan" id="kobo.2283.3">It requires casting from a pointer to a type to a pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2284.1">void</span></code><span class="koboSpan" id="kobo.2285.1"> and then the other way around, which is error prone, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2286.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2287.1">draw_button</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2288.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2289.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2290.1">* ptr)</span></span><span class="koboSpan" id="kobo.2291.1">
{
   button* b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2292.1">static_cast</span></span><span class="koboSpan" id="kobo.2293.1">&lt;button*&gt;(ptr);
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2294.1">if</span></span><span class="koboSpan" id="kobo.2295.1"> (b)
   {
      b-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2296.1">erase_background</span></span><span class="koboSpan" id="kobo.2297.1">();
      b-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2298.1">paint</span></span><span class="koboSpan" id="kobo.2299.1">();
   }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2300.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2301.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2302.1">()</span></span><span class="koboSpan" id="kobo.2303.1">
{
   button btn;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2304.1">draw_button</span></span><span class="koboSpan" id="kobo.2305.1">(&amp;btn);
   checkbox cb;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2306.1">draw_button</span></span><span class="koboSpan" id="kobo.2307.1">(&amp;cb); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2308.1">// runtime error</span></span><span class="koboSpan" id="kobo.2309.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2310.1">In this snippet, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2311.1">draw_button()</span></code><span class="koboSpan" id="kobo.2312.1"> is a function that knows how to draw a button. </span><span class="koboSpan" id="kobo.2312.2">But we can pass a pointer to anything – there will be no compile-time error or warning. </span><span class="koboSpan" id="kobo.2312.3">However, the program will likely crash at runtime.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2313.1">In C++, the </span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.2314.1">approach to this problem is to define a hierarchy of wrappers to handle the individual classes. </span><span class="koboSpan" id="kobo.2314.2">For this, we can start with a base class that defines the interface for the wrapper classes. </span><span class="koboSpan" id="kobo.2314.3">In our case, we are interested in drawing a control, so the only virtual method is one called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2315.1">draw()</span></code><span class="koboSpan" id="kobo.2316.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2317.1">We will call this class </span><code class="inlineCode"><span class="koboSpan" id="kobo.2318.1">control_concept</span></code><span class="koboSpan" id="kobo.2319.1">. </span><span class="koboSpan" id="kobo.2319.2">Its definition is shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2320.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2321.1">control_concept</span></span><span class="koboSpan" id="kobo.2322.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2323.1">virtual</span></span><span class="koboSpan" id="kobo.2324.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2325.1">control_concept</span></span><span class="koboSpan" id="kobo.2326.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2327.1">default</span></span><span class="koboSpan" id="kobo.2328.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2329.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2330.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2331.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2332.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2333.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2334.1">0</span></span><span class="koboSpan" id="kobo.2335.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2336.1">The next step is to derive it for each type of control that can be drawn (using the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.2337.1">erase_background()</span></code><span class="koboSpan" id="kobo.2338.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2339.1">paint()</span></code><span class="koboSpan" id="kobo.2340.1"> functions). </span><span class="koboSpan" id="kobo.2340.2">The wrappers for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2341.1">button</span></code><span class="koboSpan" id="kobo.2342.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2343.1">checkbox</span></code><span class="koboSpan" id="kobo.2344.1"> are as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2345.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2346.1">button_wrapper</span></span><span class="koboSpan" id="kobo.2347.1"> : control_concept
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2348.1">button_wrapper</span></span><span class="koboSpan" id="kobo.2349.1">(button&amp; b):</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2350.1">btn</span></span><span class="koboSpan" id="kobo.2351.1">(b)
   {}
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2352.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2353.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2354.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2355.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2356.1">{
      btn.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2357.1">erase_background</span></span><span class="koboSpan" id="kobo.2358.1">();
      btn.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2359.1">paint</span></span><span class="koboSpan" id="kobo.2360.1">();
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2361.1">private</span></span><span class="koboSpan" id="kobo.2362.1">:
   button&amp; btn;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2363.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2364.1">checkbox_wrapper</span></span><span class="koboSpan" id="kobo.2365.1"> : control_concept
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2366.1">checkbox_wrapper</span></span><span class="koboSpan" id="kobo.2367.1">(checkbox&amp; cb) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2368.1">cbox</span></span><span class="koboSpan" id="kobo.2369.1">(cb)
   {}
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2370.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2371.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2372.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2373.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2374.1">{
      cbox.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2375.1">erase_background</span></span><span class="koboSpan" id="kobo.2376.1">();
      cbox.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2377.1">paint</span></span><span class="koboSpan" id="kobo.2378.1">();
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2379.1">private</span></span><span class="koboSpan" id="kobo.2380.1">:
   checkbox&amp; cbox;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2381.1">Having this</span><a id="_idIndexMarker1302"/><span class="koboSpan" id="kobo.2382.1"> hierarchy of wrappers, we can write a function that draws controls polymorphically, by using pointers to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2383.1">control_concept</span></code><span class="koboSpan" id="kobo.2384.1"> (the base class of the wrapper hierarchy):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2385.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2386.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2387.1">(std::vector&lt;control_concept*&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2388.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2389.1"> &amp; controls)</span></span><span class="koboSpan" id="kobo.2390.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2391.1">for</span></span><span class="koboSpan" id="kobo.2392.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2393.1">auto</span></span><span class="koboSpan" id="kobo.2394.1">&amp; c : controls)
      c-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2395.1">draw</span></span><span class="koboSpan" id="kobo.2396.1">();
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2397.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2398.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2399.1">()</span></span><span class="koboSpan" id="kobo.2400.1">
{
   checkbox cb;
   button btn;
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.2401.1">checkbox_wrapper </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2402.1">cbw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2403.1">(cb)</span></span><span class="koboSpan" id="kobo.2404.1">;
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.2405.1">button_wrapper </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2406.1">btnw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2407.1">(btn)</span></span><span class="koboSpan" id="kobo.2408.1">;
   std::vector&lt;control_concept*&gt; v{ &amp;cbw, &amp;btnw };
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2409.1">draw</span></span><span class="koboSpan" id="kobo.2410.1">(v);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2411.1">Although this works, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2412.1">button_wrapper</span></code><span class="koboSpan" id="kobo.2413.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2414.1">control_wrapper</span></code><span class="koboSpan" id="kobo.2415.1"> are almost identical. </span><span class="koboSpan" id="kobo.2415.2">Therefore, they are good candidates for templating. </span><span class="koboSpan" id="kobo.2415.3">A class template that encapsulates the functionality seen in these two classes is shown next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2416.1">template</span></span><span class="koboSpan" id="kobo.2417.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2418.1">typename</span></span><span class="koboSpan" id="kobo.2419.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2420.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2421.1">control_wrapper</span></span><span class="koboSpan" id="kobo.2422.1"> : control_concept
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2423.1">control_wrapper</span></span><span class="koboSpan" id="kobo.2424.1">(T&amp; b) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2425.1">ctrl</span></span><span class="koboSpan" id="kobo.2426.1">(b)
   {}
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2427.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2428.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2429.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2430.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2431.1">{
      ctrl.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2432.1">erase_background</span></span><span class="koboSpan" id="kobo.2433.1">();
      ctrl.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2434.1">paint</span></span><span class="koboSpan" id="kobo.2435.1">();
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2436.1">private</span></span><span class="koboSpan" id="kobo.2437.1">:
   T&amp; ctrl;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2438.1">The client code needs only a small change: replacing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2439.1">button_wrapper</span></code><span class="koboSpan" id="kobo.2440.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2441.1">checkbox_wrapper</span></code><span class="koboSpan" id="kobo.2442.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2443.1">control_wrapper&lt;button&gt;</span></code><span class="koboSpan" id="kobo.2444.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2445.1">control_wrapper&lt;checkbox&gt;</span></code><span class="koboSpan" id="kobo.2446.1">, as in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2447.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2448.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2449.1">()</span></span><span class="koboSpan" id="kobo.2450.1">
{
   checkbox cb;
   button btn;
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.2451.1">control_wrapper&lt;checkbox&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2452.1">cbw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2453.1">(cb)</span></span><span class="koboSpan" id="kobo.2454.1">;
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.2455.1">control_wrapper&lt;button&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2456.1">btnw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2457.1">(btn)</span></span><span class="koboSpan" id="kobo.2458.1">;
   std::vector&lt;control_concept*&gt; v{ &amp;cbw, &amp;btnw };
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2459.1">draw</span></span><span class="koboSpan" id="kobo.2460.1">(v);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2461.1">At this point, you </span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.2462.1">have probably noticed how this approach leads to the type erasure idiom described in the </span><em class="italic"><span class="koboSpan" id="kobo.2463.1">How to do it…</span></em><span class="koboSpan" id="kobo.2464.1"> section. </span><span class="koboSpan" id="kobo.2464.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2465.1">control_concept</span></code><span class="koboSpan" id="kobo.2466.1"> class is the same as we saw in the pattern, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2467.1">control_wrapper&lt;T&gt;</span></code><span class="koboSpan" id="kobo.2468.1"> is the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2469.1">control_model&lt;T&gt;</span></code><span class="koboSpan" id="kobo.2470.1">. </span><span class="koboSpan" id="kobo.2470.2">In addition, however, the pattern defines a way to encapsulate the model.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2471.1">We can also move the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2472.1">draw()</span></code><span class="koboSpan" id="kobo.2473.1"> free function that handles these control types inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2474.1">control</span></code><span class="koboSpan" id="kobo.2475.1"> class. </span><span class="koboSpan" id="kobo.2475.2">The resulting implementation is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2476.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2477.1">control_collection</span></span><span class="koboSpan" id="kobo.2478.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2479.1">template</span></span><span class="koboSpan" id="kobo.2480.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2481.1">typename</span></span><span class="koboSpan" id="kobo.2482.1"> T&gt;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2483.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2484.1">add_control</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2485.1">(T&amp;&amp; obj)</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2486.1">{      
      ctrls.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2487.1">push_back</span></span><span class="koboSpan" id="kobo.2488.1">(
         std::make_shared&lt;control_model&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj)));
   }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2489.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2490.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2491.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2492.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2493.1">for</span></span><span class="koboSpan" id="kobo.2494.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2495.1">auto</span></span><span class="koboSpan" id="kobo.2496.1">&amp; c : ctrls)
      {
         c-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2497.1">draw</span></span><span class="koboSpan" id="kobo.2498.1">();
      }
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2499.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2500.1">control_concept</span></span><span class="koboSpan" id="kobo.2501.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2502.1">virtual</span></span><span class="koboSpan" id="kobo.2503.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2504.1">control_concept</span></span><span class="koboSpan" id="kobo.2505.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2506.1">default</span></span><span class="koboSpan" id="kobo.2507.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2508.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2509.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2510.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2511.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2512.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2513.1">0</span></span><span class="koboSpan" id="kobo.2514.1">;
   };
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2515.1">template</span></span><span class="koboSpan" id="kobo.2516.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2517.1">typename</span></span><span class="koboSpan" id="kobo.2518.1"> T&gt;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2519.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2520.1">control_model</span></span><span class="koboSpan" id="kobo.2521.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2522.1">public</span></span><span class="koboSpan" id="kobo.2523.1"> control_concept
   {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2524.1">control_model</span></span><span class="koboSpan" id="kobo.2525.1">(T&amp; unit) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2526.1">t</span></span><span class="koboSpan" id="kobo.2527.1">(unit) {}
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.2528.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2529.1">draw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2530.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2531.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2532.1">{
         t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2533.1">erase_background</span></span><span class="koboSpan" id="kobo.2534.1">();
         t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2535.1">paint</span></span><span class="koboSpan" id="kobo.2536.1">();
      }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2537.1">private</span></span><span class="koboSpan" id="kobo.2538.1">:
      T&amp; t;
   };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2539.1">private</span></span><span class="koboSpan" id="kobo.2540.1">:
   std::vector&lt;std::shared_ptr&lt;control_concept&gt;&gt; ctrls;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2541.1">This</span><a id="_idIndexMarker1304"/><span class="koboSpan" id="kobo.2542.1"> requires small changes to the client code (seen in the </span><em class="italic"><span class="koboSpan" id="kobo.2543.1">How to do it…</span></em><span class="koboSpan" id="kobo.2544.1"> section), which will look like the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2545.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2546.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2547.1">()</span></span><span class="koboSpan" id="kobo.2548.1">
{
   checkbox cb;
   button btn;
   control_collection cc;
   
   cc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2549.1">add_control</span></span><span class="koboSpan" id="kobo.2550.1">(cb);
   cc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2551.1">add_control</span></span><span class="koboSpan" id="kobo.2552.1">(btn);
   cc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2553.1">draw</span></span><span class="koboSpan" id="kobo.2554.1">();
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2555.1">Although </span><a id="_idIndexMarker1305"/><span class="koboSpan" id="kobo.2556.1">we have seen a simple example in this recipe, this idiom is used in real-world scenarios, including the C++ standard library, where it is employed for the implementation of:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2557.1">std::function</span></code><span class="koboSpan" id="kobo.2558.1">, which is a polymorphic function wrapper that allows us to store, copy, and invoke callables: functions, function objects, pointers to member functions, pointers to member data, lambda expressions, and bind expressions.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2559.1">std::any</span></code><span class="koboSpan" id="kobo.2560.1">, which is a type that represents a container to a value of any type that is copy-constructible.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-674"><span class="koboSpan" id="kobo.2561.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2562.1">Static polymorphism with the curiously recurring template pattern,</span></em><span class="koboSpan" id="kobo.2563.1"> to learn about CRTP, which allows simulating runtime polymorphism at compile time by deriving classes from a base class template parameterized with the derived class</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2564.1">Adding functionality to classes with mixins,</span></em><span class="koboSpan" id="kobo.2565.1"> to learn how you can add common functionality to existing classes without changing them</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2566.1">Chapter 6</span></em><span class="koboSpan" id="kobo.2567.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2568.1">Using std::any to Store Any Value</span></em><span class="koboSpan" id="kobo.2569.1">, to learn how to use the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.2570.1">std::any</span></code><span class="koboSpan" id="kobo.2571.1"> class, which represents a type-safe container for single values of any type</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-675"><span class="koboSpan" id="kobo.2572.1">Implementing a thread-safe singleton</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2573.1">Singleton is</span><a id="_idIndexMarker1306"/><span class="koboSpan" id="kobo.2574.1"> probably one of the most well-known design patterns. </span><span class="koboSpan" id="kobo.2574.2">It restricts the instantiation of a single object of a class, something that is necessary in some cases, although many times the use of a singleton is rather an anti-pattern that can be avoided with other design choices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2575.1">Since a singleton means a single instance of a class is available to an entire program, it is likely that such a unique instance might be accessible from different threads. </span><span class="koboSpan" id="kobo.2575.2">Therefore, when you implement a singleton, you should also make it thread-safe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2576.1">Before C++11, doing</span><a id="_idIndexMarker1307"/><span class="koboSpan" id="kobo.2577.1"> that was not an easy job, and a double-checked locking technique was the typical approach. </span><span class="koboSpan" id="kobo.2577.2">However, Scott Meyers and Andrei Alexandrescu showed, in a paper called </span><em class="italic"><span class="koboSpan" id="kobo.2578.1">C++ and the Perils of Double-Checked Locking</span></em><span class="koboSpan" id="kobo.2579.1">, that using this pattern did not guarantee a thread-safe singleton implementation in portable C++. </span><span class="koboSpan" id="kobo.2579.2">Fortunately, this changed in C++11, and this recipe shows how to write a thread-safe singleton in modern C++.</span></p>
<h2 class="heading-2" id="_idParaDest-676"><span class="koboSpan" id="kobo.2580.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2581.1">For this recipe, you need to know how static storage duration, internal linkage, and deleted and defaulted functions work. </span><span class="koboSpan" id="kobo.2581.2">You should also read the previous recipe </span><em class="italic"><span class="koboSpan" id="kobo.2582.1">Static polymorphism with the curiously recurring template pattern</span></em><span class="koboSpan" id="kobo.2583.1"> first if you have not done that yet and are not familiar with that pattern, as we will use it later in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-677"><span class="koboSpan" id="kobo.2584.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2585.1">To implement a thread-safe singleton, you should do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2586.1">Define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2587.1">Singleton</span></code><span class="koboSpan" id="kobo.2588.1"> class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2589.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2590.1">Singleton</span></span><span class="koboSpan" id="kobo.2591.1">
{
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2592.1">Make the default constructor private:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2593.1">private</span></span><span class="koboSpan" id="kobo.2594.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2595.1">Singleton</span></span><span class="koboSpan" id="kobo.2596.1">() = default;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2597.1">Make the copy constructor and copy assignment operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.2598.1">public</span></code><span class="koboSpan" id="kobo.2599.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2600.1">delete</span></code><span class="koboSpan" id="kobo.2601.1">, respectively:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2602.1">public</span></span><span class="koboSpan" id="kobo.2603.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2604.1">Singleton</span></span><span class="koboSpan" id="kobo.2605.1">(Singleton </span><span class="hljs-type"><span class="koboSpan" id="kobo.2606.1">const</span></span><span class="koboSpan" id="kobo.2607.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2608.1">delete</span></span><span class="koboSpan" id="kobo.2609.1">;
  Singleton&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2610.1">operator</span></span><span class="koboSpan" id="kobo.2611.1">=(Singleton </span><span class="hljs-type"><span class="koboSpan" id="kobo.2612.1">const</span></span><span class="koboSpan" id="kobo.2613.1">&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2614.1">delete</span></span><span class="koboSpan" id="kobo.2615.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2616.1">The function that creates and returns the single instance should be static and should return a reference to the class type. </span><span class="koboSpan" id="kobo.2616.2">It should declare a static object of the class type and return a reference to it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2617.1">public</span></span><span class="koboSpan" id="kobo.2618.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2619.1">static</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2620.1"> Singleton&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2621.1">instance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2622.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2623.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.2624.1">static</span></span><span class="koboSpan" id="kobo.2625.1"> Singleton single;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2626.1">return</span></span><span class="koboSpan" id="kobo.2627.1"> single;
  }
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-678"><span class="koboSpan" id="kobo.2628.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2629.1">Since singleton objects </span><a id="_idIndexMarker1308"/><span class="koboSpan" id="kobo.2630.1">are not supposed to be created by the user directly, all constructors are either private or public and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2631.1">deleted</span></code><span class="koboSpan" id="kobo.2632.1">. </span><span class="koboSpan" id="kobo.2632.2">The default constructor is private and not deleted because an instance of the class must actually be created in the class code. </span><span class="koboSpan" id="kobo.2632.3">A static function, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2633.1">instance()</span></code><span class="koboSpan" id="kobo.2634.1">, in this implementation, returns the single instance of the class.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.2635.1">Though most implementations return a pointer, it actually makes more sense to return a reference, as there is no circumstance under which this function would return a null pointer (no object).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2636.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2637.1">instance()</span></code><span class="koboSpan" id="kobo.2638.1"> method may look simplistic and not thread-safe at first glance, especially if you are familiar with the </span><strong class="keyWord"><span class="koboSpan" id="kobo.2639.1">double-checked locking pattern</span></strong><span class="koboSpan" id="kobo.2640.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.2641.1">DCLP</span></strong><span class="koboSpan" id="kobo.2642.1">). </span><span class="koboSpan" id="kobo.2642.2">In C++11, this is actually no longer necessary due to a key detail of how objects with static storage durations are initialized. </span><span class="koboSpan" id="kobo.2642.3">Initialization happens only once, even if several threads attempt to initialize the same static object at the same time. </span><span class="koboSpan" id="kobo.2642.4">The responsibility of DCLP has been moved from the user to the compiler, although the compiler may use another technique to guarantee the result.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2643.1">The following quote from the C++ standard document, version N4917, paragraph 8.8.3, defines the rules for static object initialization (the highlight is the part related to concurrent initialization):</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.2644.1">Dynamic initialization of a block variable with static storage duration (6.7.5.2) or thread storage duration (6.7.5.3) is performed the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. </span><span class="koboSpan" id="kobo.2644.2">If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. </span><strong class="keyWord"><span class="koboSpan" id="kobo.2645.1">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</span></strong></p>
<p class="quote"><span class="koboSpan" id="kobo.2646.1">[Note 2: A conforming implementation cannot introduce any deadlock around execution of the initializer. </span><span class="koboSpan" id="kobo.2646.2">Deadlocks might still be caused by the program logic; the implementation need only avoid deadlocks due to its own synchronization operations. </span><span class="koboSpan" id="kobo.2646.3">—end note]</span></p>
<p class="quote"><span class="koboSpan" id="kobo.2647.1">If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined. </span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.2648.1">The </span><a id="_idIndexMarker1309"/><span class="koboSpan" id="kobo.2649.1">static local object has static storage duration, but it is instantiated only when it is first used (at the first call to the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.2650.1">instance()</span></code><span class="koboSpan" id="kobo.2651.1">). </span><span class="koboSpan" id="kobo.2651.2">The object is deallocated when the program exits. </span><span class="koboSpan" id="kobo.2651.3">As a side note, the only possible advantage of returning a pointer and not a reference is the ability to delete this single instance at some point, before the program exists, and then maybe recreate it. </span><span class="koboSpan" id="kobo.2651.4">This, again, does not make too much sense, as it conflicts with the idea of a single, global instance of a class, accessible at any point from any place in the program.</span></p>
<h2 class="heading-2" id="_idParaDest-679"><span class="koboSpan" id="kobo.2652.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2653.1">There might be situations in larger code bases where you need more than one singleton type. </span><span class="koboSpan" id="kobo.2653.2">In order to avoid writing the same pattern several times, you can implement it in a generic way. </span><span class="koboSpan" id="kobo.2653.3">For this, we need to employ the </span><strong class="keyWord"><span class="koboSpan" id="kobo.2654.1">curiously recurring template pattern</span></strong><span class="koboSpan" id="kobo.2655.1"> (or </span><strong class="keyWord"><span class="koboSpan" id="kobo.2656.1">CRTP</span></strong><span class="koboSpan" id="kobo.2657.1">) seen earlier in the chapter. </span><span class="koboSpan" id="kobo.2657.2">The actual singleton is implemented as a class template. </span><span class="koboSpan" id="kobo.2657.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2658.1">instance()</span></code><span class="koboSpan" id="kobo.2659.1"> method creates and returns an object of the type template parameter, which will be the derived class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2660.1">template</span></span><span class="koboSpan" id="kobo.2661.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2662.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2663.1">T</span></span><span class="koboSpan" id="kobo.2664.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2665.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2666.1">SingletonBase</span></span><span class="koboSpan" id="kobo.2667.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2668.1">protected</span></span><span class="koboSpan" id="kobo.2669.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2670.1">SingletonBase</span></span><span class="koboSpan" id="kobo.2671.1">() {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2672.1">public</span></span><span class="koboSpan" id="kobo.2673.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2674.1">SingletonBase</span></span><span class="koboSpan" id="kobo.2675.1">(SingletonBase </span><span class="hljs-type"><span class="koboSpan" id="kobo.2676.1">const</span></span><span class="koboSpan" id="kobo.2677.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2678.1">delete</span></span><span class="koboSpan" id="kobo.2679.1">;
  SingletonBase&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2680.1">operator</span></span><span class="koboSpan" id="kobo.2681.1">=(SingletonBase </span><span class="hljs-type"><span class="koboSpan" id="kobo.2682.1">const</span></span><span class="koboSpan" id="kobo.2683.1">&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2684.1">delete</span></span><span class="koboSpan" id="kobo.2685.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2686.1">static</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2687.1"> T&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2688.1">instance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2689.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2690.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.2691.1">static</span></span><span class="koboSpan" id="kobo.2692.1"> T single;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2693.1">return</span></span><span class="koboSpan" id="kobo.2694.1"> single;
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2695.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2696.1">Single</span></span><span class="koboSpan" id="kobo.2697.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2698.1">public</span></span><span class="koboSpan" id="kobo.2699.1"> SingletonBase&lt;Single&gt;
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2700.1">Single</span></span><span class="koboSpan" id="kobo.2701.1">() {}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2702.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2703.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2704.1">SingletonBase</span></span><span class="koboSpan" id="kobo.2705.1">&lt;Single&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2706.1">public</span></span><span class="koboSpan" id="kobo.2707.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2708.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2709.1">demo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2710.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2711.1">{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2712.1">"demo"</span></span><span class="koboSpan" id="kobo.2713.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2714.1">'\n'</span></span><span class="koboSpan" id="kobo.2715.1">; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2716.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2717.1">Singleton</span></code><span class="koboSpan" id="kobo.2718.1"> class</span><a id="_idIndexMarker1310"/><span class="koboSpan" id="kobo.2719.1"> from the previous section has become the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2720.1">SingletonBase</span></code><span class="koboSpan" id="kobo.2721.1"> class template. </span><span class="koboSpan" id="kobo.2721.2">The default constructor is no longer private but protected because it must be accessible from the derived class. </span><span class="koboSpan" id="kobo.2721.3">In this example, the class that needs to have a single object instantiated is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2722.1">Single</span></code><span class="koboSpan" id="kobo.2723.1">. </span><span class="koboSpan" id="kobo.2723.2">Its constructors must be private, but the default constructor must also be available to the base class template; therefore, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2724.1">SingletonBase&lt;Single&gt;</span></code><span class="koboSpan" id="kobo.2725.1"> is a friend of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2726.1">Single</span></code><span class="koboSpan" id="kobo.2727.1"> class.</span></p>
<h2 class="heading-2" id="_idParaDest-680"><span class="koboSpan" id="kobo.2728.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2729.1">Static polymorphism with the curiously recurring template pattern,</span></em><span class="koboSpan" id="kobo.2730.1"> to learn about CRTP, which allows simulating runtime polymorphism at compile time by deriving classes from a base class template parameterized with the derived class</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2731.1">Chapter 3</span></em><span class="koboSpan" id="kobo.2732.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2733.1">Defaulted and deleted functions</span></em><span class="koboSpan" id="kobo.2734.1">, to learn about the use of the default specifier on special member functions and how to define functions as deleted with the delete specifier</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.2735.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2736.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_10.xhtml"><span class="url"><span class="koboSpan" id="kobo.2737.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.2738.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>