<html><head></head><body>
<div><h1 class="chapterNumber">10</h1>
<h1 class="chapterTitle" id="_idParaDest-632">Implementing Patterns and Idioms</h1>
<p class="normal">Design patterns are general reusable solutions that can be applied to common problems that appear in software development. Idioms are patterns, algorithms, or ways to structure the code in one or more programming languages. A great number of books has been written on design patterns. This chapter is not intended to reiterate them, but rather to show how to implement several useful patterns and idioms, with a focus on readability, performance, and robustness, in terms of modern C++.</p>
<p class="normal">The recipes included in this chapter are as follows:</p>
<ul>
<li class="bulletList">Avoiding repetitive <code class="inlineCode">if-else</code> statements in factory patterns</li>
<li class="bulletList">Implementing the pimpl idiom</li>
<li class="bulletList">Implementing the named parameter idiom</li>
<li class="bulletList">Separating interfaces and implementations with the non-virtual interface idiom</li>
<li class="bulletList">Handling friendship with the attorney-client idiom</li>
<li class="bulletList">Static polymorphism with the curiously recurring template pattern</li>
<li class="bulletList">Adding functionality to classes with mixins</li>
<li class="bulletList">Handling unrelated types generically with the type erasure idiom</li>
<li class="bulletList">Implementing a thread-safe singleton</li>
</ul>
<p class="normal">The first recipe of this chapter presents a simple mechanism for avoiding repetitive <code class="inlineCode">if-else</code> statements. Let’s explore how this mechanism works.</p>
<h1 class="heading-1" id="_idParaDest-633">Avoiding repetitive if-else statements in factory patterns</h1>
<p class="normal">It is often<a id="_idIndexMarker1237"/> the case that we end up writing repetitive <code class="inlineCode">if...else</code> statements (or an equivalent <code class="inlineCode">switch</code> statement) that do similar things, often with little variation and often done by copying and pasting with <a id="_idIndexMarker1238"/>small changes. As the number of alternative conditions increases, the code becomes both hard to read and hard to maintain. Repetitive <code class="inlineCode">if...else</code> statements can be replaced with various techniques, such as polymorphism. In this recipe, we will see how to avoid <code class="inlineCode">if...else</code> statements in factory patterns (a factory is a function or object that is used to create other objects) using a map of functions.</p>
<h2 class="heading-2" id="_idParaDest-634">Getting ready</h2>
<p class="normal">In this recipe, we will consider the following problem: building a system that can handle image files in various formats, such as bitmap, PNG, JPG, and so on. Obviously, the details are beyond the scope of this recipe; the part we are concerned with is creating objects that handle various image formats. For this, we will consider the following hierarchy of classes:</p>
<pre class="programlisting code"><code class="hljs-code">class Image {};
class BitmapImage : public Image {};
class PngImage    : public Image {};
class JpgImage    : public Image {};
</code></pre>
<p class="normal">On the other hand, we’ll define an interface for a factory class that can create instances of the aforementioned classes, as well as a typical implementation using <code class="inlineCode">if...else</code> statements:</p>
<pre class="programlisting code"><code class="hljs-code">struct IImageFactory
{
  virtual std::unique_ptr&lt;Image&gt; Create(std::string_view type) = 0;
};
struct ImageFactory : public IImageFactory
{
  std::unique_ptr&lt;Image&gt; 
 Create(std::string_view type) override
 {
    if (type == "bmp")
      return std::make_unique&lt;BitmapImage&gt;();
    else if (type == "png")
      return std::make_unique&lt;PngImage&gt;();
    else if (type == "jpg")
      return std::make_unique&lt;JpgImage&gt;();
    return nullptr;
  }
};
</code></pre>
<p class="normal">The goal <a id="_idIndexMarker1239"/>of this recipe is to see how this implementation can be refactored to avoid repetitive <code class="inlineCode">if...else</code> statements.</p>
<h2 class="heading-2" id="_idParaDest-635">How to do it...</h2>
<p class="normal">Perform the<a id="_idIndexMarker1240"/> following steps to refactor the factory shown earlier to avoid using <code class="inlineCode">if...else</code> statements:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Implement the factory interface:
        <pre class="programlisting code"><code class="hljs-code">struct ImageFactory : public IImageFactory
{
  std::unique_ptr&lt;Image&gt; Create(std::string_view type) override
 { 
    // continued with 2. and 3.
  }
};
</code></pre>
</li>
<li class="numberedList">Define a map where the key is the type of objects to create and the value is a function that creates objects:
        <pre class="programlisting code"><code class="hljs-code">static std::map&lt;
  std::string,
  std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;&gt; mapping
{
  { "bmp", []() {return std::make_unique&lt;BitmapImage&gt;(); } },
  { "png", []() {return std::make_unique&lt;PngImage&gt;(); } },
  { "jpg", []() {return std::make_unique&lt;JpgImage&gt;(); } }
};
</code></pre>
</li>
<li class="numberedList">To create an object, look up the object type in the map and, if it is found, use the associated function to create a new instance of the type:
        <pre class="programlisting code"><code class="hljs-code">auto it = mapping.find(type.data());
if (it != mapping.end())
  return it-&gt;second();
return nullptr;
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-636">How it works...</h2>
<p class="normal">The <a id="_idIndexMarker1241"/>repetitive <code class="inlineCode">if...else</code> statements<a id="_idIndexMarker1242"/> in the first implementation are very similar – they check the value of the <code class="inlineCode">type</code> parameter and create an instance of the appropriate <code class="inlineCode">Image</code> class. If the argument to check was an integral type (for instance, an enumeration type), the sequence of <code class="inlineCode">if...else</code> statements could have also been written in the form of a <code class="inlineCode">switch</code> statement. That code can be used like this:</p>
<pre class="programlisting code"><code class="hljs-code">auto factory = ImageFactory{};
auto image = factory.Create("png");
</code></pre>
<p class="normal">Regardless of whether the implementation was using <code class="inlineCode">if...else</code> statements or a <code class="inlineCode">switch</code>, refactoring to avoid repetitive checks is relatively simple. In the refactored code, we used a map that has the key type <code class="inlineCode">std::string</code> representing the type, that is, the name of the image format. The value is an <code class="inlineCode">std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;</code>. This is a wrapper for a function that takes no arguments and returns an <code class="inlineCode">std::unique_ptr&lt;Image&gt;</code> (a <code class="inlineCode">unique_ptr</code> of a derived class is implicitly converted to a <code class="inlineCode">unique_ptr</code> of a base class).</p>
<p class="normal">Now that we have this map of functions that create objects, the actual implementation of the factory is much simpler; check the type of the object to be created in the map and, if present, use the associated value from the map as the actual function to create the object, or return <code class="inlineCode">nullptr</code> if the object type is not present in the map.</p>
<p class="normal">This refactoring is transparent for the client code, as there are no changes in the way clients use the factory. On the other hand, this approach does require more memory to handle the static map, which, for some classes of applications, such as IoT, might be an important aspect. The example presented here is relatively simple because the purpose is to demonstrate the concept. In real-world code, it might be necessary to create objects differently, such as using a different number of arguments and different types of arguments. However, this is not specific to the refactored implementation, and the solution with the <code class="inlineCode">if...else</code>/<code class="inlineCode">switch</code> statement needs to account for that too. Therefore, in practice, the <a id="_idIndexMarker1243"/>solution to this problem that worked with <code class="inlineCode">if...else</code> statements should also work with the map.</p>
<h2 class="heading-2" id="_idParaDest-637">There’s more...</h2>
<p class="normal">In the preceding<a id="_idIndexMarker1244"/> implementation, the map is a local static to the virtual function, but it can also be a member of the class or even a global. The following implementation has the map defined as a static member of the class. The objects are not created based on the format name, but on the type information, as returned by the <code class="inlineCode">typeid</code> operator:</p>
<pre class="programlisting code"><code class="hljs-code">struct IImageFactoryByType
{
  virtual std::unique_ptr&lt;Image&gt; Create(
    std::type_info const &amp; type) = 0;
};
struct ImageFactoryByType : public IImageFactoryByType
{
  std::unique_ptr&lt;Image&gt; Create(std::type_info const &amp; type) 
 override
 {
    auto it = mapping.find(&amp;type);
    if (it != mapping.end())
      return it-&gt;second();
    return nullptr;
  }
private:
  static std::map&lt;
    std::type_info const *,
    std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;&gt; mapping;
};
std::map&lt;
  std::type_info const *,
  std::function&lt;std::unique_ptr&lt;Image&gt;()&gt;&gt; ImageFactoryByType::mapping
{
  {&amp;typeid(BitmapImage),[](){
      return std::make_unique&lt;BitmapImage&gt;();}},
  {&amp;typeid(PngImage),   [](){
      return std::make_unique&lt;PngImage&gt;();}},
  {&amp;typeid(JpgImage),   [](){
      return std::make_unique&lt;JpgImage&gt;();}}
};
</code></pre>
<p class="normal">In this case, the client code is slightly different, because instead of passing a name representing the type to create, such as PNG, we pass the value returned by the <code class="inlineCode">typeid</code> operator, such as <code class="inlineCode">typeid(PngImage)</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto factory = ImageFactoryByType{};
auto movie = factory.Create(typeid(PngImage));
</code></pre>
<p class="normal">This <a id="_idIndexMarker1245"/>alternative is arguably more robust because the map keys are not strings, which could be more prone to errors. This<a id="_idIndexMarker1246"/> recipe proposes a pattern as the solution to a common problem, and not an actual implementation. As in the case of most patterns, there are different ways they can be implemented, and it is up to you to pick the one that is the most suitable for each context.</p>
<h2 class="heading-2" id="_idParaDest-638">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Implementing the pimpl idiom,</em> to learn a technique that enables the separation of the implementation details from an interface</li>
<li class="bulletList"><em class="chapterRef">Chapter 9</em><em class="italic">, Using unique_ptr to uniquely own a memory resource</em>, to learn about the <code class="inlineCode">std::unique_ptr</code> class, which represents a smart pointer that owns and manages another object or array of objects allocated on the heap</li>
</ul>
<h1 class="heading-1" id="_idParaDest-639">Implementing the pimpl idiom</h1>
<p class="normal"><strong class="keyWord">pimpl</strong> stands for <strong class="keyWord">pointer to implementation</strong> (also known as the <strong class="keyWord">Cheshire cat idiom</strong> or the <strong class="keyWord">compiler firewall idiom</strong>) and is an <a id="_idIndexMarker1247"/>opaque pointer technique that enables the separation of the implementation details from an interface. This has the advantage that it enables changing the implementation without modifying the interface and, therefore, avoiding the need to recompile the code that is using the interface. This has the potential of making libraries using the pimpl idiom on their ABIs backward-compatible with older versions when only implementation details change. In this recipe, we will see how to implement the pimpl idiom using modern C++ features.</p>
<div><p class="normal">The term <strong class="keyWord">ABI</strong> stands for <strong class="keyWord">Application Binary Interface</strong>, and refers to the interface between two binary modules. Typically, one such module is a library or operating system, and the other is a program executed by a user.</p>
</div>
<h2 class="heading-2" id="_idParaDest-640">Getting ready</h2>
<p class="normal">The reader<a id="_idIndexMarker1248"/> is expected to be familiar with smart pointers and <code class="inlineCode">std::string_view</code>, both of which were discussed in previous chapters of this book.</p>
<p class="normal">To demonstrate the pimpl idiom in a practical manner, we will consider the following class, which we will then refactor following the pimpl pattern:</p>
<pre class="programlisting code"><code class="hljs-code">class control
{
  std::string text;
  int width = 0;
  int height = 0;
  bool visible = true;
  void draw()
 {
    std::cout 
      &lt;&lt; "control " &lt;&lt; '\n'
      &lt;&lt; " visible: " &lt;&lt; std::boolalpha &lt;&lt; visible &lt;&lt; 
         std::noboolalpha &lt;&lt; '\n'
      &lt;&lt; " size: " &lt;&lt; width &lt;&lt; ", " &lt;&lt; height &lt;&lt; '\n'
      &lt;&lt; " text: " &lt;&lt; text &lt;&lt; '\n';
  }
public:
  void set_text(std::string_view t)
 {
    text = t.data();
    draw();
  }
  void resize(int const w, int const h)
 {
    width = w;
    height = h;
    draw();
  }
  void show() 
 { 
    visible = true; 
    draw();
  }
  void hide() 
 { 
    visible = false; 
    draw();
  }
};
</code></pre>
<p class="normal">This class<a id="_idIndexMarker1249"/> represents a control that has properties such as text, size, and visibility. Every time these properties are changed, the control is redrawn. In this mocked implementation, drawing means printing the value of the properties to the console.</p>
<h2 class="heading-2" id="_idParaDest-641">How to do it...</h2>
<p class="normal">Take the following steps to implement the pimpl idiom, exemplified here by refactoring the <code class="inlineCode">control</code> class shown earlier:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Put all private members, both data and functions, into a separate class. We will call this the <strong class="keyWord">pimpl class</strong> and the original class the <strong class="keyWord">public class</strong>.</li>
<li class="numberedList">In the header file of the public class, put a forward declaration to the pimpl class:
        <pre class="programlisting code"><code class="hljs-code">// in control.h
class control_pimpl;
</code></pre>
</li>
<li class="numberedList">In the public class definition, declare a pointer to the pimpl class using <code class="inlineCode">unique_ptr</code>. This should be the only private data member of the class:
        <pre class="programlisting code"><code class="hljs-code">class control
{
  std::unique_ptr&lt;control_pimpl, void(*)(control_pimpl*)&gt; pimpl;
  public:
    control();
    void set_text(std::string_view text);
    void resize(int const w, int const h);
    void show();
    void hide();
};
</code></pre>
</li>
<li class="numberedList">Put the<a id="_idIndexMarker1250"/> pimpl class definition in the source file of the public class. The pimpl class mirrors the public interface of the public class:
        <pre class="programlisting code"><code class="hljs-code">// in control.cpp
class control_pimpl
{
  std::string text;
  int width = 0;
  int height = 0;
  bool visible = true;
  void draw()
 {
    std::cout
      &lt;&lt; "control " &lt;&lt; '\n'
      &lt;&lt; " visible: " &lt;&lt; std::boolalpha &lt;&lt; visible 
      &lt;&lt; std::noboolalpha &lt;&lt; '\n'
      &lt;&lt; " size: " &lt;&lt; width &lt;&lt; ", " &lt;&lt; height &lt;&lt; '\n'
      &lt;&lt; " text: " &lt;&lt; text &lt;&lt; '\n';
  }
public:
  void set_text(std::string_view t)
 {
    text = t.data();
    draw();
  }
  void resize(int const w, int const h)
 {
    width = w;
    height = h;
    draw();
  }
  void show()
 {
    visible = true;
    draw();
  }
  void hide()
 {
    visible = false;
    draw();
  }
};
</code></pre>
</li>
<li class="numberedList">The pimpl class is instantiated in the constructor of the public class:
        <pre class="programlisting code"><code class="hljs-code">control::control() :
  pimpl(new control_pimpl(),
        [](control_pimpl* pimpl) {delete pimpl; })
{}
</code></pre>
</li>
<li class="numberedList">Public class <a id="_idIndexMarker1251"/>member functions call the corresponding member functions of the pimpl class:
        <pre class="programlisting code"><code class="hljs-code">void control::set_text(std::string_view text)
{
  pimpl-&gt;set_text(text);
}
void control::resize(int const w, int const h)
{
  pimpl-&gt;resize(w, h);
}
void control::show()
{
  pimpl-&gt;show();
}
void control::hide()
{
  pimpl-&gt;hide();
}
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-642">How it works...</h2>
<p class="normal">The pimpl idiom enables hiding the internal implementation of a class from the clients of the library or module the class is part of. This provides several benefits:</p>
<ul>
<li class="bulletList">A clean interface for a class that its clients see.</li>
<li class="bulletList">Changes<a id="_idIndexMarker1252"/> in the internal implementation do not affect the public interface, which enables binary backward-compatibility for newer versions of a library (when the public interface remains unchanged).</li>
<li class="bulletList">Clients of a class that use this idiom do not need to be recompiled when changes to the internal implementation occur. This leads to shorter build times.</li>
<li class="bulletList">The header file does not need to include the headers for the types and functions used in the private implementation. This, again, leads to shorter build times.</li>
</ul>
<p class="normal">The benefits mentioned above do <a id="_idIndexMarker1253"/>not come for free; there are also several drawbacks that need to be mentioned:</p>
<ul>
<li class="bulletList">There is more code to write and maintain.</li>
<li class="bulletList">The code can arguably be less readable, as there is a level of indirection and all the implementation details need to be looked up in the other files. In this recipe, the pimpl class definition was provided in the source file of the public class, but in practice, it could be in separate files.</li>
<li class="bulletList">There is a slight runtime overhead because of the level of indirection from the public class to the pimpl class, but in practice, this is rarely significant.</li>
<li class="bulletList">This approach does not work with private and protected members because these have to be available to the derived classes.</li>
<li class="bulletList">This approach does not work with the private virtual functions, which have to appear in the class, either because they override functions from a base class or have to be available for overriding in a derived class.</li>
</ul>
<div><p class="normal">As a rule of thumb, when implementing the pimpl idiom, always put all the private member data and functions, except for the virtual ones, in the pimpl class and leave the protected data members and functions and all the private virtual functions in the public class.</p>
</div>
<p class="normal">In the example in this recipe, the <code class="inlineCode">control_pimpl</code> class is basically identical to the original <code class="inlineCode">control</code> class. In practice, where classes are larger and have virtual functions and protected members and both functions and data, the pimpl class is not a complete equivalent of how the class would have looked like if it was not pimpled. Also, in practice, the pimpl class may require a pointer to the public class in order to call members that were not moved into the pimpl class.</p>
<p class="normal">Concerning the implementation of the refactored <code class="inlineCode">control</code> class, the pointer to the <code class="inlineCode">control_pimpl</code> object is managed by a <code class="inlineCode">unique_ptr</code>. In the declaration of this pointer, we have used a custom deleter:</p>
<pre class="programlisting code"><code class="hljs-code">std::unique_ptr&lt;control_pimpl, void(*)(control_pimpl*)&gt; pimpl;
</code></pre>
<p class="normal">The reason for this is that the <code class="inlineCode">control</code> class has a destructor implicitly defined by the compiler, at a point where the <code class="inlineCode">control_pimpl</code> type is still incomplete (that is, in the header). This would result in an error with <code class="inlineCode">unique_ptr</code>, which cannot delete an incomplete type. This problem can be solved in two ways:</p>
<ul>
<li class="bulletList">Provide a user-defined destructor for the <code class="inlineCode">control</code> class that is explicitly implemented (even if declared as <code class="inlineCode">default</code>) after the complete definition of the <code class="inlineCode">control_pimpl</code> class is available.</li>
<li class="bulletList">Provide a custom deleter for the <code class="inlineCode">unique_ptr</code>, as we did in this example.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-643">There’s more...</h2>
<p class="normal">The original <code class="inlineCode">control</code> class was both copyable and movable:</p>
<pre class="programlisting code"><code class="hljs-code">control c;
c.resize(100, 20);
c.set_text("sample");
c.hide();
control c2 = c;             // copy
c2.show();
control c3 = std::move(c2); // move
c3.hide();
</code></pre>
<p class="normal">The refactored <code class="inlineCode">control</code> class is only movable, not copyable. The following code shows an implementation of the <code class="inlineCode">control</code> class that is both copyable and movable:</p>
<pre class="programlisting code"><code class="hljs-code">class control_copyable
{
  std::unique_ptr&lt;control_pimpl, void(*)(control_pimpl*)&gt; pimpl;
public:
  control_copyable();
  control_copyable(control_copyable &amp;&amp; op) noexcept;
  control_copyable&amp; operator=(control_copyable &amp;&amp; op) noexcept;
  control_copyable(const control_copyable&amp; op);
  control_copyable&amp; operator=(const control_copyable&amp; op);
  void set_text(std::string_view text);
  void resize(int const w, int const h);
  void show();
  void hide();
};
control_copyable::control_copyable() :
  pimpl(new control_pimpl(),
        [](control_pimpl* pimpl) {delete pimpl; })
{}
control_copyable::control_copyable(control_copyable &amp;&amp;) 
   noexcept = default;
control_copyable&amp; control_copyable::operator=(control_copyable &amp;&amp;) 
   noexcept = default;
control_copyable::control_copyable(const control_copyable&amp; op)
   : pimpl(new control_pimpl(*op.pimpl),
           [](control_pimpl* pimpl) {delete pimpl; })
{}
control_copyable&amp; control_copyable::operator=(
   const control_copyable&amp; op) 
{
  if (this != &amp;op) 
  {
    pimpl = std::unique_ptr&lt;control_pimpl,void(*)(control_pimpl*)&gt;(
               new control_pimpl(*op.pimpl),
               [](control_pimpl* pimpl) {delete pimpl; });
  }
  return *this;
}
// the other member functions
</code></pre>
<p class="normal">The class <code class="inlineCode">control_copyable</code> is both copyable and movable, but to make it so, we provided the copy constructor and copy assignment operator and both the move constructor and move assignment operator. The latter ones can be defaulted, but the former ones were explicitly implemented to create a new <code class="inlineCode">control_pimpl</code> object from the object that it is copied from.</p>
<h2 class="heading-2" id="_idParaDest-644">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 9, </em><em class="italic">Using unique_ptr to uniquely own a memory resource</em>, to learn about the <code class="inlineCode">std::unique_ptr</code> class, which represents a smart pointer that owns and manages another object or array of objects allocated on the heap</li>
</ul>
<h1 class="heading-1" id="_idParaDest-645">Implementing the named parameter idiom</h1>
<p class="normal">C++ supports <a id="_idIndexMarker1254"/>only positional parameters, which means arguments are passed to a function based on the parameter’s position. Other languages also support named parameters – that is, they specify parameter names when making a call and invoking arguments. This is particularly useful with parameters that have default values. A function may have parameters with default values, although they always appear after all the non-defaulted parameters.</p>
<p class="normal">However, if you want to provide values for only some of the defaulted parameters, there is no way to do this without providing arguments for the parameters that are positioned before them in the function parameters list.</p>
<p class="normal">A technique called the <strong class="keyWord">named parameter idiom </strong>provides a method to emulate named parameters and help solve this problem. We will explore this technique in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-646">Getting ready</h2>
<p class="normal">To exemplify the named parameter idiom, we will use the <code class="inlineCode">control</code> class shown in the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code">class control
{
  int id_;
  std::string text_;
  int width_;
  int height_;
  bool visible_;
public:
  control(
    int const id,
    std::string_view text = "",
    int const width = 0,
    int const height = 0,
    bool const visible = false):
      id_(id), text_(text), 
      width_(width), height_(height), 
      visible_(visible)
  {}
};
</code></pre>
<p class="normal">The <code class="inlineCode">control</code> class represents a visual control, such as a button or an input, and has properties such as numerical identifier, text, size, and visibility. These are provided to the constructor and, except for the ID, all the others have default values. In practice, such a class would <a id="_idIndexMarker1255"/>have many more properties, such as text brush, background brush, border style, font size, font family, and many others.</p>
<h2 class="heading-2" id="_idParaDest-647">How to do it...</h2>
<p class="normal">To implement the named parameter idiom for a function (usually with many default parameters), do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a class to wrap the parameters of the function:
        <pre class="programlisting code"><code class="hljs-code">class control_properties
{
  int id_;
  std::string text_;
  int width_ = 0;
  int height_ = 0;
  bool visible_ = false;
};
</code></pre>
</li>
<li class="numberedList">The class or function that needs to access these properties could be declared as <code class="inlineCode">friend</code> to avoid writing getters:
        <pre class="programlisting code"><code class="hljs-code">friend class control;
</code></pre>
</li>
<li class="numberedList">Every positional parameter of the original function that does not have a default value should become a positional parameter, without a default value in the constructor of the class:
        <pre class="programlisting code"><code class="hljs-code">public:
  control_properties(int const id) :id_(id)
  {}
</code></pre>
</li>
<li class="numberedList">For every positional parameter of the original function that has a default value, there should be a function (with the same name) that sets the value internally and returns a reference to the class:
        <pre class="programlisting code"><code class="hljs-code">public:
  control_properties&amp; text(std::string_view t) 
 { text_ = t.data(); return *this; }
  control_properties&amp; width(int const w) 
 { width_ = w; return *this; }
  control_properties&amp; height(int const h) 
 { height_ = h; return *this; }
  control_properties&amp; visible(bool const v) 
 { visible_ = v; return *this; }
</code></pre>
</li>
<li class="numberedList">The <a id="_idIndexMarker1256"/>original function should be modified, or an overload should be provided, to take an argument of the new class from which the property values will be read:
        <pre class="programlisting code"><code class="hljs-code">control(control_properties const &amp; cp):
  id_(cp.id_), 
  text_(cp.text_),
  width_(cp.width_), 
  height_(cp.height_),
  visible_(cp.visible_)
{}
</code></pre>
</li>
</ol>
<p class="normal">If we put all that together, the result is the following:</p>
<pre class="programlisting code"><code class="hljs-code">class control;
class control_properties
{
  int id_;
  std::string text_;
  int width_ = 0;
  int height_ = 0;
  bool visible_ = false;
  friend class control;
public:
  control_properties(int const id) :id_(id)
  {}
  control_properties&amp; text(std::string_view t) 
 { text_ = t.data(); return *this; }
  control_properties&amp; width(int const w) 
 { width_ = w; return *this; }
  control_properties&amp; height(int const h) 
 { height_ = h; return *this; }
  control_properties&amp; visible(bool const v) 
 { visible_ = v; return *this; }
};
class control
{
  int         id_;
  std::string text_;
  int         width_;
  int         height_;
  bool        visible_;
public:
  control(control_properties const &amp; cp):
    id_(cp.id_), 
    text_(cp.text_),
    width_(cp.width_), 
    height_(cp.height_),
    visible_(cp.visible_)
  {}
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-648">How it works...</h2>
<p class="normal">The<a id="_idIndexMarker1257"/> initial <code class="inlineCode">control</code> class had a constructor with many parameters. In real-world code, you can find examples like this where the number of parameters is much higher. A possible solution, often found in practice, is to group common Boolean type properties in bit flags, which could be passed together as a single integral argument (an example could be the border style for a control that defines the position where the border should be visible: top, bottom, left, right, or any combination of these four). Creating a <code class="inlineCode">control</code> object with the initial implementation is done like this:</p>
<pre class="programlisting code"><code class="hljs-code">control c(1044, "sample", 100, 20, true);
</code></pre>
<p class="normal">The named parameter idiom has the advantage that it allows you to specify values only for the parameters that you want, in any order, using a name, which is much more intuitive than a fixed, positional order.</p>
<p class="normal">Although <a id="_idIndexMarker1258"/>there isn’t a single strategy for implementing the idiom, the example in this recipe is rather typical. The properties of the <code class="inlineCode">control</code> class, provided as parameters in the constructor, have been put into a separate class, called <code class="inlineCode">control_properties</code>, that declares the <code class="inlineCode">control</code> class as a friend class to allow it to access its private data members without providing getters. This has the side effect that it limits the use of <code class="inlineCode">control_properties</code> outside the <code class="inlineCode">control</code> class. The non-optional parameters of the constructor of the <code class="inlineCode">control</code> class are also non-optional parameters of the <code class="inlineCode">control_properties</code> constructor. For all the other parameters with default values, the <code class="inlineCode">control_properties</code> class defines a function with a relevant name that simply sets the data member to the provided argument, and then returns a reference to <code class="inlineCode">control_properties</code>. This enables the client to chain calls to these functions in any order.</p>
<p class="normal">The constructor of the control class has been replaced with a new one that has a single parameter, a constant reference to a <code class="inlineCode">control_properties</code> object, whose data members are copied into the <code class="inlineCode">control</code> object’s data members.</p>
<p class="normal">Creating a <code class="inlineCode">control</code> object with the named parameter idiom implemented in this manner is done as in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">control c(control_properties(1044)
          .visible(true)
          .height(20)
          .width(100));
</code></pre>
<h2 class="heading-2" id="_idParaDest-649">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Separating interfaces and implementations with the non-virtual interface idiom</em>, to explore an idiom that promotes the separation of concerns of interfaces and implementations by making (public) interfaces non-virtual and virtual functions private</li>
<li class="bulletList"><em class="italic">Handling friendship with the attorney-client idiom</em>, to learn about a simple mechanism to restrict friends’ access to only designated, private members of a class</li>
</ul>
<h1 class="heading-1" id="_idParaDest-650">Separating interfaces and implementations with the non-virtual interface idiom</h1>
<p class="normal">Virtual functions<a id="_idIndexMarker1259"/> provide specialization points for a class by allowing derived classes to modify implementations from a base class. When a derived <a id="_idIndexMarker1260"/>class object is handled through a pointer or a reference to a base class, calls to overridden virtual functions end up invoking the overridden implementation from the derived class. On the other hand, customization is an implementation detail, and a good design separates interfaces from implementation.</p>
<p class="normal">The <strong class="keyWord">non-virtual interface idiom</strong>, proposed by Herb Sutter in an article about virtuality in the <em class="italic">C/C++ Users Journal</em>, promotes the separation of concerns of interfaces and implementations by making (public) interfaces non-virtual and virtual functions private.</p>
<p class="normal">Public virtual interfaces prevent a class from enforcing pre- and post-conditions on its interface. Users expecting an instance of a base class do not have the guarantee that the expected behavior of a public virtual method is delivered, since it can be overridden in a derived class. This idiom helps enforce the promised contract of an interface.</p>
<h2 class="heading-2" id="_idParaDest-651">Getting ready</h2>
<p class="normal">The reader should be familiar with aspects related to virtual functions, such as defining and overriding virtual functions, abstract classes, and pure specifiers.</p>
<h2 class="heading-2" id="_idParaDest-652">How to do it...</h2>
<p class="normal">Implementing this idiom requires following several simple design guidelines, formulated by Herb Sutter in the <em class="italic">C/C++ Users Journal</em>, 19(9), September 2001:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Make (public) interfaces non-virtual.</li>
<li class="numberedList">Make virtual functions private.</li>
<li class="numberedList">Make virtual functions protected only if the base implementation has to be called from a derived class.</li>
<li class="numberedList">Make the base class destructor either public and virtual or protected and nonvirtual.</li>
</ol>
<p class="normal">The following example of a simple hierarchy of controls abides by all these four guidelines:</p>
<pre class="programlisting code"><code class="hljs-code">class control
{
private:
  virtual void paint() = 0;
protected:
  virtual void erase_background() 
 {
    std::cout &lt;&lt; "erasing control background..." &lt;&lt; '\n';
  }
public:
  void draw()
 {
    erase_background();
    paint();
  }
  virtual ~control() {}
};
class button : public control
{
private:
  virtual void paint() override
 {
    std::cout &lt;&lt; "painting button..." &lt;&lt; '\n';
  }
protected:
  virtual void erase_background() override
 {
    control::erase_background();
    std::cout &lt;&lt; "erasing button background..." &lt;&lt; '\n';
  }
};
class checkbox : public button
{
private:
  virtual void paint() override
 {
    std::cout &lt;&lt; "painting checkbox..." &lt;&lt; '\n';
  }
protected:
  virtual void erase_background() override
 {
    button::erase_background();
    std::cout &lt;&lt; "erasing checkbox background..." &lt;&lt; '\n';
  }
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-653">How it works...</h2>
<p class="normal">The NVI idiom<a id="_idIndexMarker1261"/> uses the <strong class="keyWord">template method</strong> design pattern, which allows derived classes to customize parts (that is, steps) of a base class functionality (that is, an algorithm). This is done by splitting the overall algorithm into smaller parts, each of them implemented by a virtual function. The base class may provide, or not, a default implementation, and the derived classes could override them while maintaining the overall structure and meaning of the algorithm.</p>
<p class="normal">The core principle of the NVI idiom is that virtual functions should not be public; they should be either private or protected, in case the base class implementation could be called from a derived class. The interface of a class, the public part accessible to its clients, should be comprised exclusively of nonvirtual functions. This provides several advantages:</p>
<ul>
<li class="bulletList">It separates the interface from the details of implementation that are no longer exposed to the client.</li>
<li class="bulletList">It enables changing the details of the implementation without altering the public interface and without requiring changes to the client code, therefore making base classes more robust.</li>
<li class="bulletList">It allows a class to have sole control of its interface. If the public interface contains virtual methods, a derived class can alter the promised functionality, and therefore, the class cannot ensure its preconditions and postconditions. When none of the virtual methods (except for the destructor) are accessible to its clients, the class can enforce pre- and post-conditions on its interface.</li>
</ul>
<div><p class="normal">A special mention of the destructor of a class is required for this idiom. It is often stressed that base class destructors should be virtual so that objects can be deleted polymorphically (through a pointer or references to a base class). Destructing objects polymorphically when the destructor is not virtual incurs undefined behavior. However, not all base classes are intended to be deleted polymorphically. For those particular cases, the base class destructor should not be virtual. However, it should also not be public, but protected.</p>
</div>
<p class="normal">The example<a id="_idIndexMarker1262"/> from the previous section defines a hierarchy of classes representing visual controls:</p>
<ul>
<li class="bulletList"><code class="inlineCode">control</code> is the base class, but there are derived classes, such as <code class="inlineCode">button</code> and <code class="inlineCode">checkbox</code>, which are a type of button and, therefore, are derived from this class.</li>
<li class="bulletList">The only functionality defined by the <code class="inlineCode">control</code> class is drawing the controls. The <code class="inlineCode">draw()</code> method is nonvirtual, but it calls two virtual methods, <code class="inlineCode">erase_background()</code> and <code class="inlineCode">paint()</code>, to implement the two phases of drawing the control.</li>
<li class="bulletList"><code class="inlineCode">erase_background()</code> is a protected virtual method because derived classes need to call it in their own implementation.</li>
<li class="bulletList"><code class="inlineCode">paint()</code> is a private pure virtual method. Derived classes must implement it, but are not supposed to call a base implementation.</li>
<li class="bulletList">The destructor of the control class is public and virtual because objects are expected to be deleted polymorphically.</li>
</ul>
<p class="normal">An example of using these classes is shown as follows. Instances of these classes are managed by smart pointers to the base class:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::unique_ptr&lt;control&gt;&gt; controls;
controls.emplace_back(std::make_unique&lt;button&gt;());
controls.emplace_back(std::make_unique&lt;checkbox&gt;());
for (auto&amp; c : controls)
  c-&gt;draw();
</code></pre>
<p class="normal">The output of this program is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">erasing control background...
erasing button background...
painting button...
erasing control background...
erasing button background...
erasing checkbox background...
painting checkbox...
destroying button...
destroying control...
destroying checkbox...
destroying button...
destroying control...
</code></pre>
<p class="normal">The NVI idiom<a id="_idIndexMarker1263"/> introduces a level of indirection when a public function calls a non-public virtual function that does the actual implementation. In the previous example, the <code class="inlineCode">draw()</code> method called several other functions, but in many cases, it could be only one call:</p>
<pre class="programlisting code"><code class="hljs-code">class control
{
protected:
  virtual void initialize_impl()
 {
    std::cout &lt;&lt; "initializing control..." &lt;&lt; '\n';
  }
public:
  void initialize()
 {
    initialize_impl();
  }
};
class button : public control
{
protected:
  virtual void initialize_impl()
 {
    control::initialize_impl();
    std::cout &lt;&lt; "initializing button..." &lt;&lt; '\n';
  }
};
</code></pre>
<p class="normal">In this example, the class <code class="inlineCode">control</code> has an additional method called <code class="inlineCode">initialize()</code> (the previous content of the class was not shown to keep it simple) that calls a single non-public virtual method called <code class="inlineCode">initialize_impl()</code>, implemented differently in each derived class. This does not incur much overhead – if any at all – since simple functions like this are most likely inlined by the compiler anyway.</p>
<h2 class="heading-2" id="_idParaDest-654">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 1, </em><em class="italic">Use override and final for virtual methods</em>, to learn how to specify that a virtual function overrides another virtual function, as well as how to specify that a virtual function cannot be overridden in a derived class</li>
</ul>
<h1 class="heading-1" id="_idParaDest-655">Handling friendship with the attorney-client idiom</h1>
<p class="normal">Granting functions and classes access to the non-public parts of a class with a friend declaration is usually seen as a sign of bad design, as friendship breaks encapsulation and ties classes and functions. Friends, whether they are classes or functions, get access to all the private members of a class, although they may only need to access parts of it.</p>
<p class="normal">The <strong class="keyWord">attorney-client idiom</strong> provides<a id="_idIndexMarker1264"/> a simple mechanism to restrict friends access to only designated private members of a class.</p>
<h2 class="heading-2" id="_idParaDest-656">Getting ready</h2>
<p class="normal">To demonstrate how to <a id="_idIndexMarker1265"/>implement this idiom, we will consider the following classes: <code class="inlineCode">Client</code>, which has some private member data and functions (the public interface is not important here), and <code class="inlineCode">Friend</code>, which is supposed to access only parts of the private details, for instance, <code class="inlineCode">data1</code> and <code class="inlineCode">action1()</code>, but has access to everything:</p>
<pre class="programlisting code"><code class="hljs-code">class Client
{
  int data_1;
  int data_2;
  void action1() {}
  void action2() {}
  friend class Friend;
public:
  // public interface
};
class Friend
{
public:
  void access_client_data(Client&amp; c)
 {
    c.action1();
    c.action2();
    auto d1 = c.data_1;
    auto d2 = c.data_1;
  }
};
</code></pre>
<p class="normal">To understand<a id="_idIndexMarker1266"/> this idiom, you must be familiar with how friendship is declared in the C++ language and how it works.</p>
<h2 class="heading-2" id="_idParaDest-657">How to do it...</h2>
<p class="normal">Take the following steps to restrict a friend’s access to only the private members of a class that you need access to:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">Client</code> class, which provides access to all its private members to a friend, declare the friendships to an intermediate class, called the <code class="inlineCode">Attorney</code> class:
        <pre class="programlisting code"><code class="hljs-code">class Client
{
  int data_1;
  int data_2;
  void action1() {}
  void action2() {}
  friend class Attorney;
public:
  // public interface
};
</code></pre>
</li>
<li class="numberedList">Create a class that contains only private (inline) functions that access the private members of the client. This intermediate class allows the actual friend to access its private members:
        <pre class="programlisting code"><code class="hljs-code">class Attorney
{
  static inline void run_action1(Client&amp; c)
 {
    c.action1();
  }
  static inline int get_data1(Client&amp; c)
 {
    return c.data_1;
  }
  friend class Friend;
};
</code></pre>
</li>
<li class="numberedList">In the <code class="inlineCode">Friend</code> class, access the private members of only the <code class="inlineCode">Client</code> class indirectly through the <code class="inlineCode">Attorney</code> class:
        <pre class="programlisting code"><code class="hljs-code">class Friend
{
public:
  void access_client_data(Client&amp; c)
 {
    Attorney::run_action1(c);
    auto d1 = Attorney::get_data1(c);
  }
};
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-658">How it works...</h2>
<p class="normal">The <a id="_idIndexMarker1267"/>attorney-client idiom lays out a simple mechanism to restrict access to the private members of the client by introducing a middleman, the attorney. Instead of providing friendship directly to those using its internal state, the client class offers friendship to an attorney, which, in turn, provides access to a restricted set of private data or functions of the client. It does so by defining private static functions. Usually, these are also inline functions, which avoids any runtime overhead due to the level of indirection the attorney class introduces. The client’s friend gets access to its private members by actually using the private members of the attorney. This idiom is called <strong class="keyWord">attorney-client</strong> because it is similar to the way an attorney-client relationship works, with the attorney knowing all the secrets of the client, but exposing only some of them to other parties.</p>
<p class="normal">In practice, it might be necessary to create more than one attorney for a client class if different friend classes or functions must access different private members.</p>
<p class="normal">On the other hand, friendship is not inheritable, which means that a class or function that is friend to class <code class="inlineCode">B</code> is not friend with class <code class="inlineCode">D</code>, which is derived from <code class="inlineCode">B</code>. However, virtual <a id="_idIndexMarker1268"/>functions overridden in <code class="inlineCode">D</code> are still accessible polymorphically through a pointer or reference to <code class="inlineCode">B</code> from a friend class. Such an example is shown as follows, where calling the <code class="inlineCode">run()</code> method from <code class="inlineCode">F</code> prints <code class="inlineCode">base</code> and <code class="inlineCode">derived</code>:</p>
<pre class="programlisting code"><code class="hljs-code">class B
{
  virtual void execute() { std::cout &lt;&lt; "base" &lt;&lt; '\n'; }
  friend class BAttorney;
};
class D : public B
{
  virtual void execute() override 
 { std::cout &lt;&lt; "derived" &lt;&lt; '\n'; }
};
class BAttorney
{
  static inline void execute(B&amp; b)
 {
    b.execute();
  }
  friend class F;
};
class F
{
public:
  void run()
 {
    B b;
    BAttorney::execute(b); // prints 'base'
    D d;
    BAttorney::execute(d); // prints 'derived'
  }
};
F;
f.run();
</code></pre>
<p class="normal">There are <a id="_idIndexMarker1269"/>always trade-offs to using a design pattern, and this one is no exception. There are situations when using this pattern may lead to too much overhead on development, testing, and maintenance. However, the pattern could prove extremely valuable for some types of applications, such as extensible frameworks.</p>
<h2 class="heading-2" id="_idParaDest-659">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Implementing the pimpl idiom,</em> to learn a technique that enables the separation of the implementation details from an interface</li>
</ul>
<h1 class="heading-1" id="_idParaDest-660">Static polymorphism with the curiously recurring template pattern</h1>
<p class="normal">Polymorphism provides <a id="_idIndexMarker1270"/>us with the ability to have multiple forms for the same interface. Virtual functions allow derived classes to override implementations from a base<a id="_idIndexMarker1271"/> class. They represent the most common elements of a form of polymorphism, called <strong class="keyWord">runtime polymorphism</strong>, because<a id="_idIndexMarker1272"/> the decision to call a particular virtual function from the class hierarchy happens at runtime. It is also <a id="_idIndexMarker1273"/>called <strong class="keyWord">late binding</strong>, because the binding between a function call and the invocation of the function happens late, during the<a id="_idIndexMarker1274"/> execution of the program. The <a id="_idIndexMarker1275"/>opposite <a id="_idIndexMarker1276"/>of this is called <strong class="keyWord">early binding</strong>, <strong class="keyWord">static polymorphism</strong>, or <strong class="keyWord">compile-time polymorphism</strong> because it <a id="_idIndexMarker1277"/>occurs at <a id="_idIndexMarker1278"/>compile time through functions and operators overloading.</p>
<p class="normal">On the other hand, a technique <a id="_idIndexMarker1279"/>called the <strong class="keyWord">curiously recurring template pattern</strong> (or <strong class="keyWord">CRTP</strong>) allows simulating the virtual functions-based runtime polymorphism at compile time, by deriving classes from a base class template parameterized with the derived class. This technique is used extensively in some libraries, including<a id="_idIndexMarker1280"/> Microsoft’s <strong class="keyWord">Active Template Library</strong> (<strong class="keyWord">ATL</strong>) and <strong class="keyWord">Windows Template Library</strong> (<strong class="keyWord">WTL</strong>). In <a id="_idIndexMarker1281"/>this recipe, we will explore CRTP and learn how to implement it and how it works.</p>
<h2 class="heading-2" id="_idParaDest-661">Getting ready</h2>
<p class="normal">To demonstrate how CRTP works, we will revisit the example with the hierarchy of control classes we implemented in the <em class="italic">Separating interfaces and implementations with the non-virtual interface idiom</em> recipe. We will define a set of control classes that have functionalities such as drawing the control, which is (in our example) an operation done in two phases: erasing the background and then painting the control. For simplicity, in our implementation, these will be operations that will only print text to the console.</p>
<h2 class="heading-2" id="_idParaDest-662">How to do it...</h2>
<p class="normal">To implement<a id="_idIndexMarker1282"/> the curiously recurring template pattern in order to achieve static polymorphism, do the<a id="_idIndexMarker1283"/> following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Provide a class template that will represent the base class for other classes that should be treated polymorphically at compile time. Polymorphic functions are invoked from this class:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
class control
{
public:
  void draw()
 {
    static_cast&lt;T*&gt;(this)-&gt;erase_background();
    static_cast&lt;T*&gt;(this)-&gt;paint();
  }
};
</code></pre>
</li>
<li class="numberedList">Derived classes use the class template as their base class; the derived class is also the template argument for the base class. The derived class implements the functions that are invoked from the base class:
        <pre class="programlisting code"><code class="hljs-code">class button : public control&lt;button&gt;
{
public:
  void erase_background()
 {
    std::cout &lt;&lt; "erasing button background..." &lt;&lt; '\n';
  }
  void paint()
 {
    std::cout &lt;&lt; "painting button..." &lt;&lt; '\n';
  }
};
class checkbox : public control&lt;checkbox&gt;
{
public:
  void erase_background()
 {
    std::cout &lt;&lt; "erasing checkbox background..." 
              &lt;&lt; '\n';
  }
  void paint()
 {
    std::cout &lt;&lt; "painting checkbox..." &lt;&lt; '\n';
  }
};
</code></pre>
</li>
<li class="numberedList">Function <a id="_idIndexMarker1284"/>templates can handle derived classes polymorphically<a id="_idIndexMarker1285"/> through a pointer or reference to the base class template:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
void draw_control(control&lt;T&gt;&amp; c)
{
  c.draw();
}
button b;
draw_control(b);
checkbox c;
draw_control(c);
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-663">How it works...</h2>
<p class="normal">Virtual functions can represent a performance issue, especially when they are small and called multiple times in a loop. Modern hardware has made most of these situations rather irrelevant, but there are still some categories of applications where performance is critical and any performance gains are important. The curiously recurring template pattern enables the simulation of virtual calls at compile time using metaprogramming, which eventually translates to functions overloading.</p>
<p class="normal">This <a id="_idIndexMarker1286"/>pattern may look rather strange at first glance, but it is perfectly legal. The idea is to derive a class from a base class that is a template class, and then pass the derived class itself for the type template parameter of the base class. The base class then makes calls to the derived class functions. In our example, <code class="inlineCode">control&lt;button&gt;::draw()</code> is declared before the <code class="inlineCode">button</code> class is known to the compiler. However, the <code class="inlineCode">control</code> class is a class template, which means it is instantiated only when the compiler encounters code that uses it. At that point, the <code class="inlineCode">button</code> class, in this example, is already defined and known to the compiler, so calls to <code class="inlineCode">button::erase_background()</code> and <code class="inlineCode">button::paint()</code> can be made.</p>
<p class="normal">To invoke the functions from the derived class, we must first obtain a pointer to the derived class. That is done with a <code class="inlineCode">static_cast</code> conversion, as seen in <code class="inlineCode">static_cast&lt;T*&gt;(this)-&gt;erase_background()</code>. If this has to be done many times, the code can be simplified by providing a private function to do that:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
class control
{
  T* derived() { return static_cast&lt;T*&gt;(this); }
public:
  void draw()
 {
    derived()-&gt;erase_background();
    derived()-&gt;paint();
  }
};
</code></pre>
<p class="normal">There are some pitfalls when using CRTP that you must be aware of:</p>
<ul>
<li class="bulletList">All the functions in the derived classes that are called from the base class template must be public; otherwise, the base class specialization must be declared a friend of the derived class:
        <pre class="programlisting code"><code class="hljs-code">class button : public control&lt;button&gt;
{
private:
  friend class control&lt;button&gt;;
  void erase_background()
 {
    std::cout &lt;&lt; "erasing button background..." &lt;&lt; '\n';
  }
  void paint()
 {
    std::cout &lt;&lt; "painting button..." &lt;&lt; '\n';
  }
};
</code></pre>
</li>
<li class="bulletList">It is not possible to store, in a homogeneous container, such as a <code class="inlineCode">vector</code> or <code class="inlineCode">list</code>, objects of CRTP types because each base class is a unique type (such as <code class="inlineCode">control&lt;button&gt;</code> and <code class="inlineCode">control&lt;checkbox&gt;</code>). If this is actually necessary, then a workaround can be used to implement it. This will be discussed and exemplified in the next section.</li>
<li class="bulletList">When using this technique, the size of a program may increase, because of the way templates are instantiated.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-664">There’s more...</h2>
<p class="normal">When <a id="_idIndexMarker1287"/>objects of types implementing CRTP need to be stored homogeneously in a container, an additional idiom must be used. The base class template must itself be derived from another class with pure virtual functions (and a virtual public destructor). To exemplify this on the <code class="inlineCode">control</code> class, the following changes are necessary:</p>
<pre class="programlisting code"><code class="hljs-code">class controlbase
{
public:
  virtual void draw() = 0;
  virtual ~controlbase() {}
};
template &lt;class T&gt;
class control : public controlbase
{
public:
  virtual void draw() override
 {
    static_cast&lt;T*&gt;(this)-&gt;erase_background();
    static_cast&lt;T*&gt;(this)-&gt;paint();
  }
};
</code></pre>
<p class="normal">No changes need to be made to the derived classes, such as <code class="inlineCode">button</code> and <code class="inlineCode">checkbox</code>. Then, we can store<a id="_idIndexMarker1288"/> pointers to the abstract class in a container, such as <code class="inlineCode">std::vector</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">void draw_controls(std::vector&lt;std::unique_ptr&lt;controlbase&gt;&gt;&amp; v)
{
  for (auto &amp; c : v)
  {
    c-&gt;draw();
  }
}
std::vector&lt;std::unique_ptr&lt;controlbase&gt;&gt; v;
v.emplace_back(std::make_unique&lt;button&gt;());
v.emplace_back(std::make_unique&lt;checkbox&gt;());
draw_controls(v);
</code></pre>
<h2 class="heading-2" id="_idParaDest-665">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Implementing the pimpl idiom</em>, to learn a technique that enables the separation of the implementation details from an interface</li>
<li class="bulletList"><em class="italic">Separating interfaces and implementations with the non-virtual interface idiom</em>, to explore an idiom that promotes the separation of concerns of interfaces and implementations by making (public) interfaces non-virtual and virtual functions private</li>
</ul>
<h1 class="heading-1" id="_idParaDest-666">Adding functionality to classes with mixins</h1>
<p class="normal">In the previous recipe, we learned about a pattern called the curiously recurring template pattern, or CRTP for short, and how it can be used to add common functionality to classes. This is not its only use; other use cases include limiting the number of times that a type can be instantiated and implementing the composite pattern. Related to this pattern, there is another one<a id="_idIndexMarker1289"/> called <strong class="keyWord">mixins</strong>. Mixins are small classes that are designed to add functionality to other existing classes. You can probably find articles about this pattern claiming that it’s implemented using CRTP. That is not correct. Indeed, CRTP and mixins are similar patterns and both are used to add functionality to classes, but they don’t have the same structure. With CRTP, the base class adds functionality to the classes that derive from it. A mixin class adds functionality to a class that it derives from. Therefore, in a way, it is an upside-down CRTP. In this recipe, you will learn how to use mixins to add common functionality to classes. For this purpose, we will examine the same example of drawing controls (such as buttons and checkboxes). This will enable a good comparison with CRTP, which will allow you to better understand the differences (and similarities) between the two.</p>
<h2 class="heading-2" id="_idParaDest-667">How to do it…</h2>
<p class="normal">To <a id="_idIndexMarker1290"/>implement the mixins pattern to add common functionality to existing classes, do the following (in the following example the common functionality in question is painting the background and content of controls):</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Consider (possibly unrelated) classes that exhibit common functionality:
        <pre class="programlisting code"><code class="hljs-code">class button
{
public:
   void erase_background()
 {
      std::cout &lt;&lt; "erasing button background..." &lt;&lt; '\n';
   }
   void paint()
 {
      std::cout &lt;&lt; "painting button..." &lt;&lt; '\n';
   }
};
class checkbox
{
public:
   void erase_background()
 {
      std::cout &lt;&lt; "erasing checkbox background..." &lt;&lt; '\n';
   }
   void paint()
 {
      std::cout &lt;&lt; "painting checkbox..." &lt;&lt; '\n';
   }
};
</code></pre>
</li>
<li class="numberedList">Create<a id="_idIndexMarker1291"/> a class template that derives from its type template parameter. This mixin class defines some new functionality that is implemented in terms of existing functionality from the base class:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
class control : public T
{
public:
   void draw()
 {
      T::erase_background();
      T::paint();
   }
};
</code></pre>
</li>
<li class="numberedList">Instantiate and use objects of the mixin class to utilize the added functionality:
        <pre class="programlisting code"><code class="hljs-code">control&lt;button&gt; b;
b.draw();
control&lt;checkbox&gt; c;
c.draw();
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-668">How it works…</h2>
<p class="normal">A mixin is a concept that allows us to add new functionality to existing classes. The pattern is implemented differently in many programming languages. In C++, a mixin is a small class that adds functionality to an existing one (without having to make any changes to the existing class). For this, you need to:</p>
<ul>
<li class="bulletList">Make the mixin class a template. In our example, this was the <code class="inlineCode">control</code> class. If there is only one type that is supposed to be extended, then there is no need to use a template, since there would be no code duplication. However, in practice, this is usually intended to add common functionality for multiple similar classes.</li>
<li class="bulletList">Derive it from its type template parameter, which is supposed to be instantiated with the types to be extended. Implement the added functionality by reusing functionality from the type template parameter class. In our example, the new functionality was <code class="inlineCode">draw()</code>, which used <code class="inlineCode">T::erase_background()</code> and <code class="inlineCode">T::paint()</code>.</li>
</ul>
<p class="normal">Since <a id="_idIndexMarker1292"/>the mixin class is a template, it cannot be handled polymorphically. For instance, perhaps you want to have a function that should be able to draw both buttons and checkboxes and any other drawable controls. This function could look as follows:</p>
<pre class="programlisting code"><code class="hljs-code">void draw_all(std::vector&lt;???*&gt; const &amp; controls)
{
   for (auto&amp; c : controls)
   {
      c-&gt;draw();
   }
}
</code></pre>
<p class="normal">But what does <code class="inlineCode">???</code> stand for in this snippet? We need a non-template base class for this to work polymorphically. Such a base class can look as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class control_base
{
public:
   virtual ~control_base() {}
   virtual void draw() = 0;
};
</code></pre>
<p class="normal">The mixin class (<code class="inlineCode">control</code>) needs to also derive from this base class (<code class="inlineCode">control_base</code>) and the <code class="inlineCode">draw()</code> function becomes an overridden virtual function:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
class control : public control_base, public T 
{
public:
   void draw() override
 {
      T::erase_background();
      T::paint();
   }
};
</code></pre>
<p class="normal">This allows us to treat control objects polymorphically, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">void draw_all(std::vector&lt;control_base*&gt; const &amp; controls)
{
   for (auto&amp; c : controls)
   {
      c-&gt;draw();
   }
}
int main()
{
   std::vector&lt;control_base*&gt; controls;
   control&lt;button&gt; b;
   control&lt;checkbox&gt; c;
   draw_all({&amp;b, &amp;c});
}
</code></pre>
<p class="normal">As you <a id="_idIndexMarker1293"/>can see from this recipe and the previous one, mixins and CRTP are both used for the same purpose of adding functionality to classes. Moreover, they look similar, although the actual pattern structure is different.</p>
<h2 class="heading-2" id="_idParaDest-669">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Static polymorphism with the curiously recurring template pattern</em>, to learn about CRTP, which allows the simulation of runtime polymorphism at compile time by deriving classes from a base class template parameterized with the derived class</li>
</ul>
<h1 class="heading-1" id="_idParaDest-670">Handling unrelated types generically with the type erasure idiom</h1>
<p class="normal">Polymorphism (and more specifically runtime polymorphism in C++) allows us to treat hierarchies of classes in a generic way. However, there are cases when we want to do the same<a id="_idIndexMarker1294"/> but with classes that do not inherit from a common base class. This can happen when we do not own the code or, for various reasons, cannot change the code to create a hierarchy. This process of utilizing unrelated types that have some certain members (functions or variables) for given tasks (and only use those common members) is called <strong class="keyWord">duck typing</strong>. A <a id="_idIndexMarker1295"/>simple solution to this problem is to build a hierarchy of wrapper classes, one for each class that we want to handle generically. This has drawbacks because there is a lot of boilerplate code and every time a new class needs to be handled in the same manner, a new wrapper must be created. The alternative to this approach is an idiom <a id="_idIndexMarker1296"/>known as <strong class="keyWord">type erasure</strong>. The term refers to the fact that information about concrete types is erased, allowing different and even unrelated types to be handled generically. In this recipe, we will learn how this idiom works.</p>
<h2 class="heading-2" id="_idParaDest-671">Getting ready</h2>
<p class="normal">To showcase the type erasure idiom, we will use the following two classes, representing a button and a checkbox control:</p>
<pre class="programlisting code"><code class="hljs-code">class button
{
public:
   void erase_background()
 {
      std::cout &lt;&lt; "erasing button background..." &lt;&lt; '\n';
   }
   void paint()
 {
      std::cout &lt;&lt; "painting button..." &lt;&lt; '\n';
   }
};
class checkbox
{
public:
   void erase_background()
 {
      std::cout &lt;&lt; "erasing checkbox background..." &lt;&lt; '\n';
   }
   void paint()
 {
      std::cout &lt;&lt; "painting checkbox..." &lt;&lt; '\n';
   }
};
</code></pre>
<p class="normal">These <a id="_idIndexMarker1297"/>are the same classes we have seen in various forms in the previous recipes. They both have <code class="inlineCode">erase_background()</code> and <code class="inlineCode">paint()</code> member functions but they do not have a common base class; therefore, they are not part of a hierarchy that would allow us to treat them polymorphically.</p>
<h2 class="heading-2" id="_idParaDest-672">How to do it…</h2>
<p class="normal">To implement the type erasure idiom, you need to follow these steps:</p>
<ul>
<li class="bulletList">Define a class that will provide the mechanism for erasing type information. For the example that we showcase in this recipe that deals with controls, we will simply call it <code class="inlineCode">control</code>:
        <pre class="programlisting code"><code class="hljs-code">struct control
{
};
</code></pre>
</li>
<li class="bulletList">Create an inner class (of the <code class="inlineCode">control</code> class) that defines the common interface for the types that need to be handled generically. This interface is called a <strong class="keyWord">concept</strong>; therefore, we will call this class <code class="inlineCode">control_concept</code>:
        <pre class="programlisting code"><code class="hljs-code">struct control_concept
{
   virtual ~control_concept() = default;
   virtual void draw() = 0;
};
</code></pre>
</li>
<li class="bulletList">Create another inner class (of the <code class="inlineCode">control</code> class) that derives from the concept class. However, this will be a class template, and its type template parameter represents a type that needs to be handled generically. In our example, it will be substituted with <code class="inlineCode">button</code> and <code class="inlineCode">checkbox</code>. This implementation is called a <strong class="keyWord">model</strong>, and, therefore, we will call this class template <code class="inlineCode">control_model</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct control_model : public control_concept
{
   control_model(T &amp; unit) : t(unit) {}
   void draw() override
 {
      t.erase_background();
      t.paint();
   }
private:
   T&amp; t;
};
</code></pre>
</li>
<li class="bulletList">Add a <a id="_idIndexMarker1298"/>data member to the <code class="inlineCode">control</code> class, representing a pointer to an instance of the concept. In this recipe, we will use a smart pointer for this purpose:
        <pre class="programlisting code"><code class="hljs-code">private:
   std::shared_ptr&lt;control_concept&gt; ctrl;
</code></pre>
</li>
<li class="bulletList">Define a constructor for the <code class="inlineCode">control</code> class. This must be a function template, and it must set the concept pointer to an instance of a model:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
control(T&amp;&amp; obj) : 
   ctrl(std::make_shared&lt;control_model&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj)))
{
}
</code></pre>
</li>
<li class="bulletList">Define the public interface that clients of the <code class="inlineCode">control</code> class should be able to invoke. In our example, this is a function to draw the control. We will call it <code class="inlineCode">draw()</code> (although it does not have to have the same name as the virtual method in the concept):
        <pre class="programlisting code"><code class="hljs-code">void draw()
{
   ctrl-&gt;draw();
}
</code></pre>
</li>
</ul>
<p class="normal">Putting all this together, the type erasure idiom that handles unrelated control classes together <a id="_idIndexMarker1299"/>looks as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct control
{
   template &lt;typename T&gt;
   control(T&amp;&amp; obj) : 
      ctrl(std::make_shared&lt;control_model&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj)))
   {
   }
   void draw()
 {
      ctrl-&gt;draw();
   }
   struct control_concept
   {
      virtual ~control_concept() = default;
      virtual void draw() = 0;
   };
   template &lt;typename T&gt;
   struct control_model : public control_concept
   {
      control_model(T&amp; unit) : t(unit) {}
      void draw() override
 {
         t.erase_background();
         t.paint();
      }
   private:
      T&amp; t;
   };
private:
   std::shared_ptr&lt;control_concept&gt; ctrl;
};
</code></pre>
<p class="normal">We can use this wrapper class to handle buttons and checkboxes (and similar other classes) polymorphically, such as in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">void draw(std::vector&lt;control&gt;&amp; controls)
{
   for (auto&amp; c : controls)
   {
      c.draw();
   }
}
int main()
{
   checkbox cb;
   button btn;
   std::vector&lt;control&gt; v{control(cb), control(btn)};
   draw(v);
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-673">How it works…</h2>
<p class="normal">The most<a id="_idIndexMarker1300"/> rudimentary form of type erasure (and arguably the ultimate one) is to employ <code class="inlineCode">void</code> pointers. Although this provides the mechanism for implementing the idiom in C, it should be avoided in C++ because it’s not type safe. It requires casting from a pointer to a type to a pointer to <code class="inlineCode">void</code> and then the other way around, which is error prone, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">void draw_button(void* ptr)
{
   button* b = static_cast&lt;button*&gt;(ptr);
   if (b)
   {
      b-&gt;erase_background();
      b-&gt;paint();
   }
}
int main()
{
   button btn;
   draw_button(&amp;btn);
   checkbox cb;
   draw_button(&amp;cb); // runtime error
}
</code>
draw_button()</code> is a function that knows how to draw a button. But we can pass a pointer to anything – there will be no compile-time error or warning. However, the program will likely crash at runtime.</pre>
<p class="normal">In C++, the <a id="_idIndexMarker1301"/>approach to this problem is to define a hierarchy of wrappers to handle the individual classes. For this, we can start with a base class that defines the interface for the wrapper classes. In our case, we are interested in drawing a control, so the only virtual method is one called <code class="inlineCode">draw()</code>. </p>
<p class="normal">We will call this class <code class="inlineCode">control_concept</code>. Its definition is shown below:</p>
<pre class="programlisting code"><code class="hljs-code">struct control_concept
{
   virtual ~control_concept() = default;
   virtual void draw() = 0;
};
</code></pre>
<p class="normal">The next step is to derive it for each type of control that can be drawn (using the two <code class="inlineCode">erase_background()</code> and <code class="inlineCode">paint()</code> functions). The wrappers for <code class="inlineCode">button</code> and <code class="inlineCode">checkbox</code> are as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct button_wrapper : control_concept
{
   button_wrapper(button&amp; b):btn(b)
   {}
   void draw() override
 {
      btn.erase_background();
      btn.paint();
   }
private:
   button&amp; btn;
};
struct checkbox_wrapper : control_concept
{
   checkbox_wrapper(checkbox&amp; cb) :cbox(cb)
   {}
   void draw() override
 {
      cbox.erase_background();
      cbox.paint();
   }
private:
   checkbox&amp; cbox;
};
</code></pre>
<p class="normal">Having this<a id="_idIndexMarker1302"/> hierarchy of wrappers, we can write a function that draws controls polymorphically, by using pointers to <code class="inlineCode">control_concept</code> (the base class of the wrapper hierarchy):</p>
<pre class="programlisting code"><code class="hljs-code">void draw(std::vector&lt;control_concept*&gt; const &amp; controls)
{
   for (auto&amp; c : controls)
      c-&gt;draw();
}
int main()
{
   checkbox cb;
   button btn;
   checkbox_wrapper cbw(cb);
   button_wrapper btnw(btn);
   std::vector&lt;control_concept*&gt; v{ &amp;cbw, &amp;btnw };
   draw(v);
}
</code></pre>
<p class="normal">Although this works, <code class="inlineCode">button_wrapper</code> and <code class="inlineCode">control_wrapper</code> are almost identical. Therefore, they are good candidates for templating. A class template that encapsulates the functionality seen in these two classes is shown next:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct control_wrapper : control_concept
{
   control_wrapper(T&amp; b) : ctrl(b)
   {}
   void draw() override
 {
      ctrl.erase_background();
      ctrl.paint();
   }
private:
   T&amp; ctrl;
};
</code></pre>
<p class="normal">The client code needs only a small change: replacing <code class="inlineCode">button_wrapper</code> and <code class="inlineCode">checkbox_wrapper</code> with <code class="inlineCode">control_wrapper&lt;button&gt;</code> and <code class="inlineCode">control_wrapper&lt;checkbox&gt;</code>, as in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
   checkbox cb;
   button btn;
   control_wrapper&lt;checkbox&gt; cbw(cb);
   control_wrapper&lt;button&gt; btnw(btn);
   std::vector&lt;control_concept*&gt; v{ &amp;cbw, &amp;btnw };
   draw(v);
}
</code></pre>
<p class="normal">At this point, you <a id="_idIndexMarker1303"/>have probably noticed how this approach leads to the type erasure idiom described in the <em class="italic">How to do it…</em> section. The <code class="inlineCode">control_concept</code> class is the same as we saw in the pattern, and <code class="inlineCode">control_wrapper&lt;T&gt;</code> is the same as <code class="inlineCode">control_model&lt;T&gt;</code>. In addition, however, the pattern defines a way to encapsulate the model.</p>
<p class="normal">We can also move the <code class="inlineCode">draw()</code> free function that handles these control types inside the <code class="inlineCode">control</code> class. The resulting implementation is the following:</p>
<pre class="programlisting code"><code class="hljs-code">struct control_collection
{
   template &lt;typename T&gt;
   void add_control(T&amp;&amp; obj) 
 {      
      ctrls.push_back(
         std::make_shared&lt;control_model&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj)));
   }
   void draw()
 {
      for (auto&amp; c : ctrls)
      {
         c-&gt;draw();
      }
   }
   struct control_concept
   {
      virtual ~control_concept() = default;
      virtual void draw() = 0;
   };
   template &lt;typename T&gt;
   struct control_model : public control_concept
   {
      control_model(T&amp; unit) : t(unit) {}
      void draw() override
 {
         t.erase_background();
         t.paint();
      }
   private:
      T&amp; t;
   };
private:
   std::vector&lt;std::shared_ptr&lt;control_concept&gt;&gt; ctrls;
};
</code></pre>
<p class="normal">This<a id="_idIndexMarker1304"/> requires small changes to the client code (seen in the <em class="italic">How to do it…</em> section), which will look like the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
   checkbox cb;
   button btn;
   control_collection cc;
   
   cc.add_control(cb);
   cc.add_control(btn);
   cc.draw();
}
</code></pre>
<p class="normal">Although <a id="_idIndexMarker1305"/>we have seen a simple example in this recipe, this idiom is used in real-world scenarios, including the C++ standard library, where it is employed for the implementation of:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::function</code>, which is a polymorphic function wrapper that allows us to store, copy, and invoke callables: functions, function objects, pointers to member functions, pointers to member data, lambda expressions, and bind expressions.</li>
<li class="bulletList"><code class="inlineCode">std::any</code>, which is a type that represents a container to a value of any type that is copy-constructible.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-674">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Static polymorphism with the curiously recurring template pattern,</em> to learn about CRTP, which allows simulating runtime polymorphism at compile time by deriving classes from a base class template parameterized with the derived class</li>
<li class="bulletList"><em class="italic">Adding functionality to classes with mixins,</em> to learn how you can add common functionality to existing classes without changing them</li>
<li class="bulletList"><em class="chapterRef">Chapter 6</em>, <em class="italic">Using std::any to Store Any Value</em>, to learn how to use the C++17 <code class="inlineCode">std::any</code> class, which represents a type-safe container for single values of any type</li>
</ul>
<h1 class="heading-1" id="_idParaDest-675">Implementing a thread-safe singleton</h1>
<p class="normal">Singleton is<a id="_idIndexMarker1306"/> probably one of the most well-known design patterns. It restricts the instantiation of a single object of a class, something that is necessary in some cases, although many times the use of a singleton is rather an anti-pattern that can be avoided with other design choices.</p>
<p class="normal">Since a singleton means a single instance of a class is available to an entire program, it is likely that such a unique instance might be accessible from different threads. Therefore, when you implement a singleton, you should also make it thread-safe.</p>
<p class="normal">Before C++11, doing<a id="_idIndexMarker1307"/> that was not an easy job, and a double-checked locking technique was the typical approach. However, Scott Meyers and Andrei Alexandrescu showed, in a paper called <em class="italic">C++ and the Perils of Double-Checked Locking</em>, that using this pattern did not guarantee a thread-safe singleton implementation in portable C++. Fortunately, this changed in C++11, and this recipe shows how to write a thread-safe singleton in modern C++.</p>
<h2 class="heading-2" id="_idParaDest-676">Getting ready</h2>
<p class="normal">For this recipe, you need to know how static storage duration, internal linkage, and deleted and defaulted functions work. You should also read the previous recipe <em class="italic">Static polymorphism with the curiously recurring template pattern</em> first if you have not done that yet and are not familiar with that pattern, as we will use it later in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-677">How to do it...</h2>
<p class="normal">To implement a thread-safe singleton, you should do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Define the <code class="inlineCode">Singleton</code> class:
        <pre class="programlisting code"><code class="hljs-code">class Singleton
{
};
</code></pre>
</li>
<li class="numberedList">Make the default constructor private:
        <pre class="programlisting code"><code class="hljs-code">private:
  Singleton() = default;
</code></pre>
</li>
<li class="numberedList">Make the copy constructor and copy assignment operator <code class="inlineCode">public</code> and <code class="inlineCode">delete</code>, respectively:
        <pre class="programlisting code"><code class="hljs-code">public:
  Singleton(Singleton const &amp;) = delete;
  Singleton&amp; operator=(Singleton const&amp;) = delete;
</code></pre>
</li>
<li class="numberedList">The function that creates and returns the single instance should be static and should return a reference to the class type. It should declare a static object of the class type and return a reference to it:
        <pre class="programlisting code"><code class="hljs-code">public:
  static Singleton&amp; instance()
 {
    static Singleton single;
    return single;
  }
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-678">How it works...</h2>
<p class="normal">Since singleton objects <a id="_idIndexMarker1308"/>are not supposed to be created by the user directly, all constructors are either private or public and <code class="inlineCode">deleted</code>. The default constructor is private and not deleted because an instance of the class must actually be created in the class code. A static function, called <code class="inlineCode">instance()</code>, in this implementation, returns the single instance of the class.</p>
<div><p class="normal">Though most implementations return a pointer, it actually makes more sense to return a reference, as there is no circumstance under which this function would return a null pointer (no object).</p>
</div>
<p class="normal">The implementation of the <code class="inlineCode">instance()</code> method may look simplistic and not thread-safe at first glance, especially if you are familiar with the <strong class="keyWord">double-checked locking pattern</strong> (<strong class="keyWord">DCLP</strong>). In C++11, this is actually no longer necessary due to a key detail of how objects with static storage durations are initialized. Initialization happens only once, even if several threads attempt to initialize the same static object at the same time. The responsibility of DCLP has been moved from the user to the compiler, although the compiler may use another technique to guarantee the result.</p>
<p class="normal">The following quote from the C++ standard document, version N4917, paragraph 8.8.3, defines the rules for static object initialization (the highlight is the part related to concurrent initialization):</p>
<blockquote class="packt_quote">
<p class="quote">Dynamic initialization of a block variable with static storage duration (6.7.5.2) or thread storage duration (6.7.5.3) is performed the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. <strong class="keyWord">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</strong></p>
<p class="quote">[Note 2: A conforming implementation cannot introduce any deadlock around execution of the initializer. Deadlocks might still be caused by the program logic; the implementation need only avoid deadlocks due to its own synchronization operations. —end note]</p>
<p class="quote">If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined. </p>
</blockquote>
<p class="normal">The <a id="_idIndexMarker1309"/>static local object has static storage duration, but it is instantiated only when it is first used (at the first call to the method <code class="inlineCode">instance()</code>). The object is deallocated when the program exits. As a side note, the only possible advantage of returning a pointer and not a reference is the ability to delete this single instance at some point, before the program exists, and then maybe recreate it. This, again, does not make too much sense, as it conflicts with the idea of a single, global instance of a class, accessible at any point from any place in the program.</p>
<h2 class="heading-2" id="_idParaDest-679">There’s more...</h2>
<p class="normal">There might be situations in larger code bases where you need more than one singleton type. In order to avoid writing the same pattern several times, you can implement it in a generic way. For this, we need to employ the <strong class="keyWord">curiously recurring template pattern</strong> (or <strong class="keyWord">CRTP</strong>) seen earlier in the chapter. The actual singleton is implemented as a class template. The <code class="inlineCode">instance()</code> method creates and returns an object of the type template parameter, which will be the derived class:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
class SingletonBase
{
protected:
  SingletonBase() {}
public:
  SingletonBase(SingletonBase const &amp;) = delete;
  SingletonBase&amp; operator=(SingletonBase const&amp;) = delete;
  static T&amp; instance()
 {
    static T single;
    return single;
  }
};
class Single : public SingletonBase&lt;Single&gt;
{
  Single() {}
  friend class SingletonBase&lt;Single&gt;;
public:
  void demo() { std::cout &lt;&lt; "demo" &lt;&lt; '\n'; }
};
</code></pre>
<p class="normal">The <code class="inlineCode">Singleton</code> class<a id="_idIndexMarker1310"/> from the previous section has become the <code class="inlineCode">SingletonBase</code> class template. The default constructor is no longer private but protected because it must be accessible from the derived class. In this example, the class that needs to have a single object instantiated is called <code class="inlineCode">Single</code>. Its constructors must be private, but the default constructor must also be available to the base class template; therefore, <code class="inlineCode">SingletonBase&lt;Single&gt;</code> is a friend of the <code class="inlineCode">Single</code> class.</p>
<h2 class="heading-2" id="_idParaDest-680">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Static polymorphism with the curiously recurring template pattern,</em> to learn about CRTP, which allows simulating runtime polymorphism at compile time by deriving classes from a base class template parameterized with the derived class</li>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Defaulted and deleted functions</em>, to learn about the use of the default specifier on special member functions and how to define functions as deleted with the delete specifier</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_10.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>