<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-214"><a id="_idTextAnchor227"/>9</h1>
<h1 id="_idParaDest-215"><a id="_idTextAnchor228"/>Building the C++ Trading Algorithm’s Building Blocks</h1>
<p>In this chapter, we will build components that make up the intelligence in our trading applications. These are the components that the trading strategies will rely on very heavily to make decisions, send and manage orders, track and manage positions, <strong class="bold">profits and losses</strong> (<strong class="bold">PnLs</strong>), and manage risk. Not only do the trading strategies need to track the trading PnLs since the goal is to make money, but these components also need to track the PnLs to decide when to stop trading if needed. We will learn how to compute complex features from market data updates, track trading performance based on order executions and market updates, send and manage live strategy orders in the market, and manage market risk. In this chapter, we will cover the following topics:</p>
<ul>
<li>Reacting to executions and managing positions, PnLs, and risk</li>
<li>Building the feature engine and computing complex features</li>
<li>Using executions and updating positions and PnLs</li>
<li>Sending and managing orders</li>
<li>Computing and managing risk</li>
</ul>
<h1 id="_idParaDest-216"><a id="_idTextAnchor229"/>Technical requirements</h1>
<p>All the code for this book can be found in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</a>. The source for this chapter is in the <code>Chapter9</code> directory in this repository.</p>
<p>You must have read and understood the design of the electronic trading ecosystem that was presented in <em class="italic">Chapter</em>, <em class="italic">Designing Our Trading Ecosystem</em>, especially the <em class="italic">Designing a framework for low-latency C++ trading algorithms</em> section. As before, we will use the building blocks we built in <em class="italic">Chapter</em>, <em class="italic">Building the C++ Building Blocks for </em><em class="italic">Low-Latency Applications</em>.</p>
<p>The specifications of the environment in which the source code for this book was developed are shown here. We have provided the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes for it to work in your environment:</p>
<ul>
<li><code>Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </code><code>x86_64 GNU/Linux.</code></li>
<li><code>g++ (Ubuntu </code><code>11.3.0-1ubuntu1~22.04.1) 11.3.0.</code></li>
<li><code>cmake </code><code>version 3.23.2.</code></li>
<li><code>1.10.2.</code></li>
</ul>
<h1 id="_idParaDest-217"><a id="_idTextAnchor230"/>Reacting to executions and managing positions, PnLs, and risk</h1>
<p>We need to build a few basic building blocks that will build and support our trading strategies. We discussed the need for these components in <em class="italic">Chapter</em>, <em class="italic">Designing Our Trading Ecosystem</em>, in the <em class="italic">Designing a framework for low-latency C++ trading algorithms</em> section. We have already implemented a major component – the limit order book – but in this section, we will build the remaining components we need, namely the following:</p>
<ul>
<li>A <code>FeatureEngine</code>, which <a id="_idIndexMarker1235"/>will be used to compute simple and complex features/signals that drive the trading strategy decisions</li>
<li>A <code>PositionKeeper</code>, which<a id="_idIndexMarker1236"/> will receive executions and compute important measures such as position, PnLs, traded volumes, and more</li>
<li>An <code>OrderManager</code>, which<a id="_idIndexMarker1237"/> will be used by the strategies to send orders, manage them, and update these orders when there are updates</li>
<li>A <code>RiskManager</code> to compute <a id="_idIndexMarker1238"/>and check the market risk that a trading strategy is attempting to take on, as well as the risk it has realized</li>
</ul>
<p>The following diagram shows the topology of all these components and how they interact with each other. If you need to refresh your memory on why these components exist, what purpose they serve, how they interact with each other, and how they are designed, please revisit <em class="italic">Chapter</em>, <em class="italic">Designing Our Trading Ecosystem</em>, and look at the subsections in the <em class="italic">Designing a framework for low-latency C++ trading </em><em class="italic">algorithms</em> section:</p>
<div><div><img alt="Figure 9.1 – The sub-components inside our trading engine" src="img/Figure_9.1_B19434.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The sub-components inside our trading engine</p>
<p>Now, let’s kick off our effort <a id="_idIndexMarker1239"/>of implementing these components, starting with the feature engine in the next sub-section. But before we do that, we need to add two additional methods for the <code>Side</code> enumeration, which will make a lot of our source code simpler down the road. Both of these can be found in the <code>Chapter9/common/types.h</code> header file.</p>
<p>The first method we will add is the <code>sideToIndex()</code> method, which converts a <code>Side</code> value into an index that can be used to index into an array. This will allow us to maintain arrays of different types of objects that are indexed by a <code>Side</code> value. The implementation is simple – we simply typecast the side to a <code>size_t</code> type and add a <code>1</code> to account for the fact that <code>Side::SELL</code> has a value of -1 and valid that indices start from 0:</p>
<pre class="source-code">
  inline constexpr auto sideToIndex(Side side) noexcept {
    return static_cast&lt;size_t&gt;(side) + 1;
  }</pre>
<p>We will also define a <code>sideToValue()</code> method, which converts a <code>Side</code> value into either a 1 for <code>Side::BUY</code> or a -1 for <code>Side::SELL</code>. This will help us when we compute positions and PnLs, which we will see shortly in this section:</p>
<pre class="source-code">
  inline constexpr auto sideToValue(Side side) noexcept {
    return static_cast&lt;int&gt;(side);
  }</pre>
<p>Now that we have that additional functionality out of the way, we can start computing the feature engine.</p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor231"/>Building the feature and computing complex features</h1>
<p>In this <a id="_idIndexMarker1240"/>section, we will<a id="_idIndexMarker1241"/> build a minimal version of a feature engine. We will only compute two simple features – one (market price) that computes fair market prices based on the top of book prices and quantity and another (aggressive trade qty ratio) that computes how big a trade is compared to the top of book quantities. We will use these feature values to drive our market-making and liquidity-taking trading algorithms later in this chapter. The source code for the <code>FeatureEngine</code> class we will build here can be found in the <code>Chapter9/trading/strategy/feature_engine.h</code> file on GitHub. We discussed the details of this component in <em class="italic">Chapter</em>, <em class="italic">Designing Our Trading Ecosystem</em>, in the <em class="italic">Designing a framework for low-latency C++ trading </em><em class="italic">algorithms</em> section.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor232"/>Defining the data members in the feature engine</h2>
<p>First, we <a id="_idIndexMarker1242"/>need to declare the <code>FeatureEngine</code> class and define the data members inside this class. First, we will include the required header files and define a constant sentinel value to represent invalid or uninitialized feature values. This is called <code>Feature_INVALID</code>, as shown here:</p>
<pre class="source-code">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
using namespace Common;
namespace Trading {
  constexpr auto Feature_INVALID =
    std::numeric_limits&lt;double&gt;::quiet_NaN();</pre>
<p>Our <code>FeatureEngine</code> class is basic and has two important data members of the <code>double</code> type – one<a id="_idIndexMarker1243"/> to compute and store the fair market price value, <code>mkt_price_</code>, and another to compute and store the aggressive trade quantity ratio feature value, <code>agg_trade_qty_ratio_</code>. It also stores a pointer to a <code>Logger</code> object (<code>logger_</code>) for logging purposes:</p>
<pre class="source-code">
  class FeatureEngine {
  private:
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    double mkt_price_ = Feature_INVALID,
      agg_trade_qty_ratio_ = Feature_INVALID;
  };</pre>
<p>Next, we will look at how to initialize this class since we have already initialized the two feature variables with the <code>Feature_INVALID</code> value.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor233"/>Initializing the feature engine</h2>
<p>The<a id="_idIndexMarker1244"/> constructor for this class accepts a <code>Logger</code> object and initializes the <code>logger_</code> data member – that’s all:</p>
<pre class="source-code">
    FeatureEngine(Common::Logger *logger)
        : logger_(logger) {
    }</pre>
<p>Here, we will present two getter methods – <code>getMktPrice()</code> and <code>getAggTradeQtyRatio()</code> – to fetch the value of the two features that the <code>FeatureEngine</code> class is responsible for computing:</p>
<pre class="source-code">
    auto getMktPrice() const noexcept {
      return mkt_price_;
    }
    auto getAggTradeQtyRatio() const noexcept {
      return agg_trade_qty_ratio_;
    }</pre>
<p>In the next two subsections, we will see how this component handles order book updates and trade events and updates the feature values.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor234"/>Computing the feature on order book changes</h2>
<p>The <code>FeatureEngine</code> class expects the <code>onOrderBookUpdate()</code> method to be called when there is an update to the order book. First, it uses <code>MarketOrderBook::getBBO()</code> to extract the BBO. As a<a id="_idIndexMarker1245"/> reminder, <code>mkt_price_</code> value if they are valid. The fair market price is formulated as the book quantity weighted price, <code>(bid_price * ask_qty + ask_price * bid_qty) / (bid_qty + ask_qty)</code>. Note that this is just a single formulation for a fair market price; the important thing to remember with feature engineering is that there is no single correct formulation. You are encouraged to formulate a version of a fair market price or any other feature value you want to use in the future. The formulation we are using here tries to move the fair market price closer to the offer if there are more buy orders than sell orders <a id="_idIndexMarker1247"/>and moves it closer to the bid if there are more sell orders than buy orders:</p>
<pre class="source-code">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, MarketOrderBook* book) noexcept -&gt; void {
      const auto bbo = book-&gt;getBBO();
      if(LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-
        &gt;ask_price_ != Price_INVALID)) {
        mkt_price_ = (bbo-&gt;bid_price_ * bbo-&gt;ask_qty_ +
          bbo-&gt;ask_price_ * bbo-&gt;bid_qty_) /
            static_cast&lt;double&gt;(bbo-&gt;bid_qty_ + bbo-&gt;
              ask_qty_);
      }
      logger_-&gt;log("%:% %() % ticker:% price:% side:% mkt-
        price:% agg-trade-ratio:%\n", __FILE__, __LINE__,
          __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                     ticker_id, Common::priceToString
                       (price).c_str(),
                   Common::sideToString(side).c_str(),
                     mkt_price_, agg_trade_qty_ratio_);
    }</pre>
<p>The next subsection will compute the other feature, which we will refer to as the Aggressive Trade Quantity Ratio, for computing the trade quantity as a fraction of the book price level quantity.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor235"/>Computing the feature on trade events</h2>
<p><code>FeatureEngine</code> expects the <code>onTradeUpdate()</code> method to be called when there is a trade<a id="_idIndexMarker1248"/> event in the market data stream. As we saw previously, it fetches the BBO and checks if the prices are valid and then computes the <code>agg_trade_qty_ratio_</code> feature to be a ratio of the trade quantity and the quantity of the BBO that the trade aggresses on. As we mentioned with the previous feature, there is no single correct formulation of a feature – this is just the formulation we are using for now; hopefully, you will add your own formulations in the future. This formulation tries to measure how big a trade aggressor was compared to how much liquidity was available on the BBO side the aggressor trades against. We are simply <a id="_idIndexMarker1249"/>trying to quantify the trade pressure with this feature that we are computing. As we mentioned previously, there are many other possible formulations:</p>
<pre class="source-code">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook* book) noexcept -&gt; void {
      const auto bbo = book-&gt;getBBO();
      if(LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-&gt;
        ask_price_ != Price_INVALID)) {
        agg_trade_qty_ratio_ = static_cast&lt;double&gt;
          (market_update-&gt;qty_) / (market_update-&gt;side_ ==
            Side::BUY ? bbo-&gt;ask_qty_ : bbo-&gt;bid_qty_);
      }
      logger_-&gt;log("%:% %() % % mkt-price:% agg-trade-ratio
        :%\n", __FILE__, __LINE__, __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                   market_update-&gt;toString().c_str(),
                     mkt_price_, agg_trade_qty_ratio_);
    }</pre>
<p>That is the entire implementation of our <code>FeatureEngine</code> for this book. In the next section, we will learn how to handle executions and use that to update positions and PnLs.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor236"/>Using executions to update positions and PnLs</h1>
<p>Now, we<a id="_idIndexMarker1250"/> will build a <code>PositionKeeper</code> class that will be responsible for processing executions on a strategy’s orders and computing and tracking positions and PnLs. This component is used by the strategy as well as the risk manager to compute positions and PnLs for different purposes. All the source code for the <code>PositionKeeper</code> class is in the <code>Chapter9/trading/strategy/position_keeper.h</code> file on GitHub. Before we build the <code>PositionKeeper</code> class, which manages positions for all trading instruments, we will need to build a <code>PositionInfo</code> struct, which is also present in the same source file. The <code>PositionInfo</code> struct is the lower-level struct for managing the positions and PnLs for a single trading instrument; we will cover it in more detail in the next few subsections. We discussed the details of this component in <em class="italic">Chapter</em>, <em class="italic">Designing Our Trading Ecosystem</em>, in the <em class="italic">Designing a framework for low-latency C++ trading </em><em class="italic">algorithms</em> section.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor237"/>Declaring the data members in PositionInfo</h2>
<p>First, we <a id="_idIndexMarker1251"/>must specify the <code>include</code> files that will be needed for the <code>position_keeper.h</code> file, as shown here:</p>
<pre class="source-code">
#pragma once
#include "common/macros.h"
#include "common/types.h"
#include "common/logging.h"
#include "exchange/order_server/client_response.h"
#include "market_order_book.h"
using namespace Common;</pre>
<p>The data members inside the <code>PositionInfo</code> struct are presented in the source code. The important<a id="_idIndexMarker1252"/> data members are as follows:</p>
<ul>
<li>A <code>position_</code> variable of the <code>int32_t</code> type to represent the current position. This can be positive, negative, or 0.</li>
<li>Three <code>double</code> values – <code>real_pnl_</code>, <code>unreal_pnl_</code>, and <code>total_pnl_</code> – to track the realized or closed PnL for positions that have been closed (<code>real_pnl_</code>), the unrealized or open PnL for the currently open position (<code>unreal_pnl_</code>), and the total PnL, which is a summation of the two values (<code>total_pnl_</code>), respectively. The realized PnL only changes when additional order executions occur; the unrealized PnL can change even without order executions if there is a non-zero position and market prices change.</li>
<li>A <code>std::array</code> of <code>double</code> of a size large enough to accommodate entries for the buy side and sell side. This array will be indexed using the <code>sideToIndex(Side::BUY)</code> and <code>sideToIndex(Side::SELL)</code> values. This <code>open_vwap_</code> <code>std::array</code> variable tracks the product of price and execution quantity on each side when there is an open long (positive) or short (negative) position. We will need this to compute the unrealized PnL by comparing <a id="_idIndexMarker1253"/>the <strong class="bold">volume-weighted average price</strong> (<strong class="bold">VWAP</strong>) of the open long or short position against the current market price.</li>
<li>A <code>volume_</code> variable of the <code>Qty</code> type to track the total quantity that has been executed.</li>
<li>A <code>const</code> pointer variable to a <code>BBO</code> object called <code>bbo_</code>, which will be used on market updates to fetch the updated top-of-book prices:</li>
</ul>
<pre class="source-code">
namespace Trading {
  struct PositionInfo {
    int32_t position_ = 0;
    double real_pnl_ = 0, unreal_pnl_ = 0, total_pnl_ = 0;
    std::array&lt;double, sideToIndex(Side::MAX) + 1&gt;
      open_vwap_;
    Qty volume_ = 0;
    const BBO *bbo_ = nullptr;</pre>
<p>We will also<a id="_idIndexMarker1254"/> add a simple <code>toString()</code> method to this struct to <em class="italic">stringify</em> instances of this structure:</p>
<pre class="source-code">
    auto toString() const {
       std::stringstream ss;
       ss &lt;&lt; "Position{"
          &lt;&lt; "pos:" &lt;&lt; position_
          &lt;&lt; " u-pnl:" &lt;&lt; unreal_pnl_
          &lt;&lt; " r-pnl:" &lt;&lt; real_pnl_
          &lt;&lt; " t-pnl:" &lt;&lt; total_pnl_
          &lt;&lt; " vol:" &lt;&lt; qtyToString(volume_)
          &lt;&lt; " vwaps:[" &lt;&lt; (position_ ? open_vwap_
            .at(sideToIndex(Side::BUY)) / std::abs
              (position_) : 0)
          &lt;&lt; "X" &lt;&lt; (position_ ? open_vwap_
            .at(sideToIndex(Side::SELL)) / std::abs
               (position_) : 0)
         &lt;&lt; "] "
         &lt;&lt; (bbo_ ? bbo_-&gt;toString() : "") &lt;&lt; "}";
       return ss.str();
    }</pre>
<p>Next, we need to process order executions and update the positions and PnLs based on those executions.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor238"/>Handling order executions in PositionInfo</h2>
<p>When a<a id="_idIndexMarker1255"/> trading strategy’s orders are executed, <code>PositionKeeper</code> needs to update the positions and PnLs that have been tracked for the trading instrument of the execution. It does this by providing the <code>MEClientResponse</code> message corresponding to order executions to the <code>PositionInfo::addFIll()</code> method. We will build this in this subsection.</p>
<p>Before we look at the source code for our implementation of the <code>PositionInfo::addFill()</code> method, we will look at an example of how the algorithm to update the realized and unrealized PnLs works. This will help you easily understand the source code for the implementation. We will track the evolution of the different variables as we work our way through a few hypothetical executions for a hypothetical trading instrument. We will display the following variables as columns in our<a id="_idIndexMarker1256"/> tables:</p>
<ul>
<li><strong class="bold">position – old</strong>: This is the position before the current execution message is processed</li>
<li><strong class="bold">position – new</strong>: This will be the new position after processing the current execution message</li>
<li><strong class="bold">open_vwap – BUY</strong>: This is the sum of the products of execution price and execution quantity for buy executions only</li>
<li><strong class="bold">open_vwap – SELL</strong>: This is the sum of the products of execution price and execution quantity for sell executions only</li>
<li><strong class="bold">VWAP – BUY</strong>: This is the actual VWAP of the current long/positive position, represented in units of price and not price x quantity</li>
<li><strong class="bold">VWAP – SELL</strong>: This is the actual VWAP of the current short/negative position, represented in units of price and not price x quantity</li>
<li><strong class="bold">PnL – real</strong>: This is the realized PnL after processing this execution</li>
<li><strong class="bold">PnL – unreal</strong>: This is the unrealized PnL for the open position after processing this execution</li>
</ul>
<p>Assuming we get an execution for buying 10 at 100.0, we must update <code>open_vwap</code>, <code>VWAP</code> on the <code>BUY</code> side, and the new position, as shown here. No changes need to be made to the unreal PnL yet:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">position</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">open_vwap</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">VWAP</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">PnL</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Old</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">new</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">real</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">unreal</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>0</p>
</td>
<td class="No-Table-Style">
<p>10</p>
</td>
<td class="No-Table-Style">
<p>1000.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>100.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
</tr>
</tbody>
</table>
<p>Assuming <a id="_idIndexMarker1257"/>we get another execution for buying 10 at 90.0, our old position was 10 and the new position will be 20. The <code>open_vwap</code> property for <code>BUY</code> now gets 10 * 90 added to the previous 1,000 and becomes 1,900. The <code>VWAP</code> column for the open long/positive position is 95, which can be computed by dividing 1,900 (<code>BUY</code> <code>open_vwap</code>) by 20 (new position). We compute the unreal PnL by using a <code>VWAP</code> of 95 and the latest execution price of 90 and multiplying the difference of -5 by the position of 20 to get -100. We have a negative unrealized PnL because our long/positive position’s <code>VWAP</code> is higher than current market prices (represented by the latest execution price):</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">position</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">open_vwap</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">VWAP</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">PnL</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">old</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">new</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">real</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">unreal</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>10</p>
</td>
<td class="No-Table-Style">
<p>20</p>
</td>
<td class="No-Table-Style">
<p>1900.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>95.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>-100.0</p>
</td>
</tr>
</tbody>
</table>
<p>Now, let’s assume we get a sell execution for selling 10 at 92. Our old position of 20 will be reduced to 10. Our <code>open_vwap</code> and <code>VWAP</code> on the <code>BUY</code> side do not change since this was a sell execution. Since we closed 10 out of our long/positive 20 positions, we will have some realized PnL and the remaining 10 long/positive positions will have some unrealized PnL based on the execution price of this latest execution. The realized PnL is computed using the sell execution price of 92, the <code>VWAP</code> property of the long/positive position, which is 95, and the execution quantity of 10 to yield a realized PnL of (92 - 95) * 10 = -30. In this case, the unrealized PnL is also the same since there is a long/positive 10 position left:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">position</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">open_vwap</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">VWAP</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">PnL</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Old</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">new</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">real</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">unreal</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>20</p>
</td>
<td class="No-Table-Style">
<p>10</p>
</td>
<td class="No-Table-Style">
<p>1900.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>95.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>-30.0</p>
</td>
<td class="No-Table-Style">
<p>-30.0</p>
</td>
</tr>
</tbody>
</table>
<p>Now, let’s<a id="_idIndexMarker1258"/> assume we receive another sell execution for selling 20 at 97. This will cause our position to flip from 10 to –10 (note that we set <code>open_vwap</code> and <code>VWAP</code> for the <code>BUY</code> side to 0). The <code>open_vwap</code> property for the <code>SELL</code> side becomes 970 because of the -10 position and the execution price of 97. We close the previous position of 10, which had a <code>VWAP</code> of 95 with this sell at 97. Since we sold higher than the <code>VWAP</code> property of our long/positive position, we make a profit of (97 - 95) * 10 = 20, which when added to the previous realized PnL of -30, yields the final <code>realized</code> PnL of -10. The unrealized PnL here is 0 since a <code>VWAP</code> of 97 is the same as the current execution price of 97:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table004-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">position</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">open_vwap</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">VWAP</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">PnL</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Old</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">new</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">real</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">unreal</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>10</p>
</td>
<td class="No-Table-Style">
<p>-10</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>970.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>97.0</p>
</td>
<td class="No-Table-Style">
<p>-10.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
</tr>
</tbody>
</table>
<p>Let’s assume that we get another sell execution of selling 20 and 94. Here, the short/negative position increases from -10 to -30. The <code>open_vwap</code> property on the <code>SELL</code> side is updated by adding (20 * 94) to the previous value of 970 to yield 2,850. The <code>VWAP</code> property of our short position is updated to 95 by dividing the <code>open_vwap</code> property of 2,850 by the position of 30 to yield 95. The realized PnL does not change since the position was increased and nothing was reduced or closed. The unreal PnL uses the execution price of 94 on this new execution, compares it to the <code>VWAP</code> property of 95, and uses the new position of -30 to yield (95 - 94) * 30 = 30:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table005-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">position</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">open_vwap</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">VWAP</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">PnL</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Old</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">new</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">real</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">unreal</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>-10</p>
</td>
<td class="No-Table-Style">
<p>-30</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>2850.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>95.0</p>
</td>
<td class="No-Table-Style">
<p>-10.0</p>
</td>
<td class="No-Table-Style">
<p>30.0</p>
</td>
</tr>
</tbody>
</table>
<p>Let’s assume<a id="_idIndexMarker1259"/> that there is yet another sell execution of selling 10 at 90. The short/negative position increases from -30 to -40. We add the new execution’s price and quantity product (10 * 90) to the previous <code>open_vwap</code> property’s <code>SELL</code> of 2,850 to yield 3,750. The actual <code>VWAP</code> of the short position changes from 95 to 93.75 and was obtained by dividing this 3,750 value by the new position of 40. The realized PnL does not change since the position was increased, but the unrealized PnL is updated using (93.75 - 90) * 40 = 150:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table006-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">position</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">open_vwap</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">VWAP</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">PnL</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Old</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">new</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">real</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">unreal</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>-30</p>
</td>
<td class="No-Table-Style">
<p>-40</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>3750.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>93.75</p>
</td>
<td class="No-Table-Style">
<p>-10.0</p>
</td>
<td class="No-Table-Style">
<p>150.0</p>
</td>
</tr>
</tbody>
</table>
<p>Finally, let’s assume that we receive a buy execution for buying 40 at 88. This execution will flatten our short/negative position of -40, so the new position will be 0. The unrealized PnL will be 0 and the <code>open_vwap</code> and <code>VWAP</code> properties will be 0 for both sides since there is no open position anymore. The realized PnL is updated using the previous <code>VWAP</code> property, the execution price, and the position of 40, so (93.75 - 88) * 40 = 230. This is added to the previously realized PnL of –10 to yield the final realized PnL of 220:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table007-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">position</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">open_vwap</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">VWAP</strong></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><strong class="bold">PnL</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Old</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">new</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">BUY</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SELL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">real</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">unreal</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>-40</p>
</td>
<td class="No-Table-Style">
<p>0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
<td class="No-Table-Style">
<p>220.0</p>
</td>
<td class="No-Table-Style">
<p>0.0</p>
</td>
</tr>
</tbody>
</table>
<p>Now, we can <a id="_idIndexMarker1260"/>move on and discuss the implementation details of this algorithm.</p>
<p>The first thing we must do is initialize a few local variables. Here, the <code>old_position</code> variable saves the <code>current position_</code> value before updating it. <code>side_index</code> and <code>opp_side_index</code> use the <code>sideToIndex()</code> method to find the indices in the <code>open_vwap_</code> array that correspond to the side of the execution and the side opposite to the side of execution, respectively. We must also initialize a <code>side_value</code> variable, which will be +1 for a buy execution and -1 for a sell execution:</p>
<pre class="source-code">
    auto addFill(const Exchange::MEClientResponse
      *client_response, Logger *logger) noexcept {
      const auto old_position = position_;
      const auto side_index = sideToIndex(client_response-&gt;
        side_);
      const auto opp_side_index = sideToIndex
        (client_response-&gt;side_ == Side::BUY ? Side::SELL :
          Side::BUY);
      const auto side_value = sideToValue(client_response-&gt;
        side_);</pre>
<p>Now, we must update the <code>position_</code> variable using the quantity executed (<code>exec_qty_</code>) in this response and the <code>side_value</code> variable we initialized. We must also update the <code>volume_</code> member by adding the new execution quantity to it. When we receive an execution on a buy order, our position increases; conversely, when we receive an execution on a sell order, our position decreases. When our position is positive, also known as a <em class="italic">long position</em>, we profit when prices increase and make a loss when prices decrease. When our position is negative, also known as a <em class="italic">short position</em>, we profit when prices decrease and make a loss when prices increase:</p>
<pre class="source-code">
      position_ += client_response-&gt;exec_qty_ * side_value;
      volume_ += client_response-&gt;exec_qty_;</pre>
<p>The next important step for us is to update the <code>open_vwap_</code> entry’s <code>std::array</code> variable. We will check if we were flat (position 0) before this execution and open a new position with this execution or if we already had an open position and we got an execution that increases that position. In this case, we will simply update the <code>open_vwap_</code> variable using <code>side_index</code> to index the correct side. Since <code>open_vwap_</code> tracks the product of execution prices and executed quantities at those prices, we can simply<a id="_idIndexMarker1261"/> multiply <code>price_</code> and <code>exec_qty_</code> on this execution and add it to the existing sum, as shown here:</p>
<pre class="source-code">
      if (old_position * sideToValue(client_response-&gt;
        side_) &gt;= 0) { // opened / increased position.
        open_vwap_[side_index] += (client_response-&gt;price_
          * client_response-&gt;exec_qty_);
      }</pre>
<p>Now, we need to handle the case where we had a pre-existing open position. This most recent execution reduces or flattens the position. In this case, we will need to update the realized PnL (<code>real_pnl_</code>) using the <code>open_vwap_</code> entry for the side opposite to the side of execution. One thing to understand is that the realized PnL is only updated when an open position is reduced or closed because, in this case, we have bought and sold a certain quantity. Another way to think about this is that we can match some of the buy quantity with some of the sell quantity and create a pair of buy and sell trades. In this case, we have closed at least part of our position. In the previous case, where we either opened a new position or increased an already open position, we did not have a pair of buy and sell trades to match up, so we did not need to update the realized PnL.</p>
<p>First, we<a id="_idIndexMarker1262"/> will compute an <code>opp_side_vwap</code> value, which is the average price of all the executions on the other side, using the <code>open_vwap_</code> entry for <code>opp_side_index</code> and normalize it using the absolute value of <code>old_position</code> before this execution. Remember that the <code>open_vwap_</code> variable is named poorly; it tracks the product of execution price and quantity, not just the price, so dividing it by the quantity represented by <code>old_position</code> yields the actual VWAP. Then, we will update the <code>open_vwap_</code> entry for <code>opp_side_index</code> using the product of the VWAP we computed in <code>opp_side_vwap</code> and the absolute value of the new <code>position_</code> value.</p>
<p>We can update the <code>real_pnl_</code> value by finding the minimum quantity value of the execution quantity (<code>exec_qty_</code>) and the absolute value of <code>old_position</code>. We must multiply that by the difference between the current execution message’s price (<code>price_</code>) and <code>opp_side_vwap</code>. Finally, we need to multiply this product by <code>opp_side_value</code> to account for whether a profit was made (bought at a lower price than the sell VWAP or sold at a higher price than the buy VWAP) or a loss was made (bought at a higher price than the sell VWAP or sold at a lower price than the buy VWAP):</p>
<pre class="source-code">
        else { // decreased position.
        const auto opp_side_vwap = open_vwap_
          [opp_side_index] / std::abs(old_position);
        open_vwap_[opp_side_index] = opp_side_vwap * std::
          abs(position_);
        real_pnl_ += std::min
          (static_cast&lt;int32_t&gt;(client_response-&gt;
            exec_qty_), std::abs(old_position)) *
                     (opp_side_vwap - client_response-&gt;
                        price_) * sideToValue
                          (client_response-&gt;side_);</pre>
<p>We need to<a id="_idIndexMarker1263"/> handle an edge case if this execution causes the position to flip, meaning it goes from a long position to a short position or vice versa. This position flip can happen, for instance, when we have a long/positive position of a certain amount and we receive a sell execution of a quantity larger than that position. Conversely, this can happen if we have a short/negative position of a certain amount and we receive a buy execution of a quantity larger than that position. In each of these cases, we go from having a positive/long position to a negative/short position or go from having a negative/short position to a positive/long position. In this case, we can simply reset the <code>open_vwap_</code> value corresponding to the opposite side to 0 and reset the <code>open_vwap_</code> value for the side of execution (and thus the side of the new position) so that it’s the product of the latest execution price and the absolute value of our current <code>position_</code>:</p>
<pre class="source-code">
        if (position_ * old_position &lt; 0) { // flipped
          position to opposite sign.
          open_vwap_[side_index] = (client_response-&gt;price_
            * std::abs(position_));
          open_vwap_[opp_side_index] = 0;
        }
      }</pre>
<p>Finally, we will wrap up the <code>PositionInfo::addFill()</code> method by updating the unrealized PnL (<code>unreal_pnl_</code>) value. The case where we are now flat (<code>position_ == 0</code>) is straightforward – we reset the <code>open_vwap_</code> variable for both sides and set <code>unreal_pnl_</code> to 0 since no open position implies no <code>unreal_pnl_</code>:</p>
<pre class="source-code">
      if (!position_) { // flat
        open_vwap_[sideToIndex(Side::BUY)] = open_vwap_
          [sideToIndex(Side::SELL)] = 0;
        unreal_pnl_ = 0;
      }</pre>
<p>If we still <a id="_idIndexMarker1264"/>have an open <code>position_</code> after this execution, then we can compute the <code>unreal_pnl_</code> value that was obtained by multiplying the absolute value of <code>position_</code> with the difference between the execution price from the current execution and the VWAP computed from the <code>open_vwap_</code> entry for the <code>position_</code> side:</p>
<pre class="source-code">
        else {
        if (position_ &gt; 0)
          unreal_pnl_ =
              (client_response-&gt;price_ - open_vwap_
                [sideToIndex(Side::BUY)] / std::abs
                  (position_)) *
              std::abs(position_);
        else
          unreal_pnl_ =
              (open_vwap_[sideToIndex(Side::SELL)] / std::
                abs(position_) - client_response-&gt;price_) *
              std::abs(position_);
      }</pre>
<p>Finally, <code>total_pnl_</code> is just the summation of <code>real_pnl_</code> and <code>unreal_pnl_</code>, as explained previously:</p>
<pre class="source-code">
      total_pnl_ = unreal_pnl_ + real_pnl_;
      std::string time_str;
      logger-&gt;log("%:% %() % % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str),
                  toString(), client_response-&gt;
                    toString().c_str());
    }</pre>
<p>The final <a id="_idIndexMarker1265"/>piece of functionality we need to add to <code>PositionInfo</code> is for handling changes in market prices and updating the unrealized PnL for any open position. We will investigate this functionality in the next subsection.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor239"/>Handling order book changes in PositionInfo</h2>
<p>When<a id="_idIndexMarker1266"/> there are market updates that cause changes in the order book we build, we need to update the unrealized and total PnL values. The <code>PositionInfo::updateBBO()</code> method is called by the <code>PositionKeeper</code> class for the trading instrument, which receives a market update. This, in turn, leads to an order book change. We provide the <code>BBO</code> object that corresponds to the trading instrument that was updated in the <code>updateBBO()</code> method. We save the <code>bbo</code> argument provided in this method in the <code>bbo_</code> data member in our <code>PositionInfo</code> struct. This method only has anything to do if <code>position_</code> is non-zero and the bid and ask price values on the BBO provided are valid. This is the first thing we will check for:</p>
<pre class="source-code">
    auto updateBBO(const BBO *bbo, Logger *logger) noexcept {
      std::string time_str;
      bbo_ = bbo;
      if (position_ &amp;&amp; bbo-&gt;bid_price_ != Price_INVALID &amp;&amp;
        bbo-&gt;ask_price_ != Price_INVALID) {</pre>
<p>If we need to update the unrealized PnL, we can use the mid-price of the BBO prices, which we can compute and save in the <code>mid_price</code> variable, as shown here:</p>
<pre class="source-code">
        const auto mid_price = (bbo-&gt;bid_price_ + bbo-&gt;
          ask_price_) * 0.5;</pre>
<p>After that, we can update <code>unreal_pnl_</code> using the same logic that we saw in the previous subsection, except that we use the <code>mid_price</code> value instead of an execution price. Let’s explain why we update the unrealized PnL even though we do not have additional executions. Let’s say we have a long position from an execution at a hypothetical price of 100. At this point, the initial unrealized PnL is 0. Let’s also assume that, in the future, the market prices (represented by our <code>mid_price</code> variable) go up to 110. In that case, our realized PnL has not changed because we have not executed any sell orders. However, our unrealized PnL increases because if we decide to liquidate our long position, we would get executions at a price roughly equal to <code>mid_price</code>. This is why we update the unrealized PnL when market prices change, even though no additional orders have been executed. Also, note that the realized PnL captures the PnL of pairs of buy and sell executions, so that does not need to be <a id="_idIndexMarker1267"/>updated here since there were no additional executions:</p>
<pre class="source-code">
        if (position_ &gt; 0)
          unreal_pnl_ =
              (mid_price – open_vwap_
                [sideToIndex(Side::BUY)] / std::
                  abs(position_)) *
              std::abs(position_);
        else
          unreal_pnl_ =
              (open_vwap_[sideToIndex(Side::SELL)] / std::
                 abs(position_) – mid_price) *
              std::abs(position_);</pre>
<p>Finally, we must update the <code>total_pnl_</code> data member and log it if it has changed since the last time:</p>
<pre class="source-code">
        const auto old_total_pnl = total_pnl_;
        total_pnl_ = unreal_pnl_ + real_pnl_;
        if (total_pnl_ != old_total_pnl)
          logger-&gt;log("%:% %() % % %\n", __FILE__, __LINE__
            , __FUNCTION__, Common::
               getCurrentTimeStr(&amp;time_str),
                      toString(), bbo_-&gt;toString());
      }
    }</pre>
<p>This<a id="_idIndexMarker1268"/> concludes all the functionality we need for the <code>PositionInfo</code> struct. We will now shift our discussion to the <code>PositionKeeper</code> class, which we will use to manage the position and PnL for the entire trading engine across all trading instruments.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor240"/>Designing PositionKeeper</h2>
<p>The <code>PositionKeeper</code> class<a id="_idIndexMarker1269"/> manages the position and PnL across all trading instruments in the trading engine. The <code>PositionKeeper</code> class contains a <code>std::array</code> of <code>PositionInfo</code> objects and is large enough to accommodate <code>ME_MAX_TICKERS</code> number of objects:</p>
<pre class="source-code">
  class PositionKeeper {
  private:
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    std::array&lt;PositionInfo, ME_MAX_TICKERS&gt;
      ticker_position_;
  };</pre>
<p>We will add a getter method to fetch and return the <code>PositionInfo</code> instance for a provided <code>TickerId</code> called <code>getPositionInfo()</code>:</p>
<pre class="source-code">
    auto getPositionInfo(TickerId ticker_id) const noexcept {
      return &amp;(ticker_position_.at(ticker_id));
    }</pre>
<p>We will also add a simple <code>toString()</code> method, which we will use for logging purposes later:</p>
<pre class="source-code">
    auto toString() const {
      double total_pnl = 0;
      Qty total_vol = 0;
      std::stringstream ss;
      for(TickerId i = 0; i &lt; ticker_position_.size(); ++i) {
        ss &lt;&lt; "TickerId:" &lt;&lt; tickerIdToString(i) &lt;&lt; " " &lt;&lt;
          ticker_position_.at(i).toString() &lt;&lt; "\n";
        total_pnl += ticker_position_.at(i).total_pnl_;
        total_vol += ticker_position_.at(i).volume_;
      }
      ss &lt;&lt; "Total PnL:" &lt;&lt; total_pnl &lt;&lt; " Vol:" &lt;&lt;
        total_vol &lt;&lt; "\n";
      return ss.str();
    }</pre>
<p>Initializing an <a id="_idIndexMarker1270"/>object of this class is straightforward and something we will discuss next.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor241"/>Initializing PositionKeeper</h2>
<p>The <code>PositionKeeper</code> constructor<a id="_idIndexMarker1271"/> accepts a <code>Logger</code> object and initializes the <code>logger_</code> data member with that argument, as shown here:</p>
<pre class="source-code">
    PositionKeeper(Common::Logger *logger)
        : logger_(logger) {
    }</pre>
<p>Next, we will see how order executions and changes to <code>BBO</code> are handled in the <code>PositionKeeper</code> class and forwarded to the correct <code>PositionInfo</code> object.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor242"/>Handling order executions and market updates in PositionKeeper</h2>
<p>The <code>PositionKeeper::addFill()</code> method handles order executions and its implementation is <a id="_idIndexMarker1272"/>straightforward. It simply calls the <code>PositionInfo::addFill()</code> method on the correct <code>PositionInfo</code> object for that <code>TickerId</code>, as shown here:</p>
<pre class="source-code">
    auto addFill(const Exchange::MEClientResponse
      *client_response) noexcept {
      ticker_position_.at(client_response-&gt;
        ticker_id_).addFill(client_response, logger_);
    }</pre>
<p>The <code>PositionKeeper::updateBBO()</code> method handles changes in <code>BBO</code> due to market updates and corresponding changes in <a id="_idIndexMarker1273"/>the order book. It also simply calls the <code>PositionInfo::updateBBO()</code> method on the correct <code>PositionInfo</code> object for <code>TickerId</code>, as shown here:</p>
<pre class="source-code">
    auto updateBBO(TickerId ticker_id, const BBO *bbo)
      noexcept {
      ticker_position_.at(ticker_id).updateBBO(bbo,
        logger_);
    }</pre>
<p>That concludes the design and implementation of everything we need in our <code>PositionKeeper</code> class. In the next section, we will build an order manager class, which will be used by the trading strategies to manage their orders at a higher level.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor243"/>Sending and managing orders</h1>
<p>In <em class="italic">Chapter</em>, <em class="italic">Designing Our Trading Ecosystem</em>, we discussed the purpose of the trading system’s order manager <a id="_idIndexMarker1274"/>component (the <em class="italic">Designing a framework for low-latency C++ trading algorithms</em> section). In this section, we will implement <a id="_idIndexMarker1275"/>an <code>OrderManager</code> class to<a id="_idIndexMarker1276"/> encapsulate the order management logic inside this class and thus make it easy for trading strategies to manage their orders. Before we build the <code>OrderManager</code> class itself, we will need to define a basic building block called the <code>OMOrder</code> structure.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor244"/>Defining the OMOrder struct and its related types</h2>
<p>In this first subsection, we <a id="_idIndexMarker1277"/>will define some enumerations and types to be used in the <code>OrderManager</code> class and its sub-components. All the source code for this subsection is in the <code>Chapter9/trading/strategy/om_order.h</code> source file on GitHub.</p>
<p>First, we must provide the <code>include</code> files that the <code>om_order.h</code> file needs:</p>
<pre class="source-code">
#pragma once
#include &lt;array&gt;
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Trading {</pre>
<p>Now, we must declare an <code>OMOrderState</code> enumeration, which will be used to track the state of a strategy order (<code>OMOrder</code>) in the order manager. These states represent the state <a id="_idIndexMarker1278"/>of an <code>OMOrder</code>, as described here:</p>
<ul>
<li>The <code>INVALID</code> state represents an invalid order state</li>
<li>The <code>PENDING_NEW</code> state signifies that a new order has been sent out by <code>OrderManager</code> but it has not been accepted by the electronic trading exchange yet</li>
<li>When we receive a response from the exchange to signify acceptance, the order goes from <code>PENDING_NEW</code> to <code>LIVE</code></li>
<li>Like <code>PENDING_NEW</code>, the <code>PENDING_CANCEL</code> state represents the state of an order when a cancellation for an order has been sent to the exchange but has not been processed by the exchange or the response has not been received back</li>
<li>The <code>DEAD</code> state<a id="_idIndexMarker1279"/> represents an order that does not exist – it has either not been sent yet or fully executed or successfully cancelled:</li>
</ul>
<pre class="source-code">
  enum class OMOrderState : int8_t {
    INVALID = 0,
    PENDING_NEW = 1,
    LIVE = 2,
    PENDING_CANCEL = 3,
    DEAD = 4
  };</pre>
<p>We must also add a method for converting <code>OMOrderState</code> enumerations into strings for logging purposes, as shown here:</p>
<pre class="source-code">
  inline auto OMOrderStateToString(OMOrderState side) -&gt;
    std::string {
    switch (side) {
      case OMOrderState::PENDING_NEW:
        return "PENDING_NEW";
      case OMOrderState::LIVE:
        return "LIVE";
      case OMOrderState::PENDING_CANCEL:
        return "PENDING_CANCEL";
      case OMOrderState::DEAD:
        return "DEAD";
      case OMOrderState::INVALID:
        return "INVALID";
    }
    return "UNKNOWN";
  }</pre>
<p>Now, we can <a id="_idIndexMarker1280"/>define the <code>OMOrder</code> structure, which has the following key fields:</p>
<ul>
<li>A <code>ticker_id_</code> variable of the <code>TickerId</code> type to represent which trading instrument this order is for</li>
<li>An <code>order_id_</code> variable of the <code>OrderId</code> type, which is the unique order ID that’s been assigned to this order object</li>
<li>A <code>side_</code> variable to hold the <code>Side</code> property of this order</li>
<li>The order’s <code>Price</code> is held in the <code>price_</code> data member</li>
<li>The live or requested <code>Qty</code> for this order is saved in the <code>qty_</code> variable</li>
<li>An <code>order_state_</code> variable of the <code>OMOrderState</code> type, which we defined previously, to represent the current state of <code>OMOrder</code>:</li>
</ul>
<pre class="source-code">
  struct OMOrder {
    TickerId ticker_id_ = TickerId_INVALID;
    OrderId order_id_ = OrderId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty qty_ = Qty_INVALID;
    OMOrderState order_state_ = OMOrderState::INVALID;</pre>
<p>We must also add a <code>toString()</code> method to stringify <code>OMOrder</code> objects for logging purposes:</p>
<pre class="source-code">
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "OMOrder" &lt;&lt; "["
         &lt;&lt; "tid:" &lt;&lt; tickerIdToString(ticker_id_) &lt;&lt; " "
         &lt;&lt; "oid:" &lt;&lt; orderIdToString(order_id_) &lt;&lt; " "
         &lt;&lt; "side:" &lt;&lt; sideToString(side_) &lt;&lt; " "
         &lt;&lt; "price:" &lt;&lt; priceToString(price_) &lt;&lt; " "
         &lt;&lt; "qty:" &lt;&lt; qtyToString(qty_) &lt;&lt; " "
         &lt;&lt; "state:" &lt;&lt; OMOrderStateToString(order_state_)
         &lt;&lt; "]";
      return ss.str();
    }
  };</pre>
<p>Here, we <a id="_idIndexMarker1281"/>define an <code>OMOrderSideHashMap</code> typedef to represent a <code>std::array</code> of <code>OMOrder</code> objects and indicate that the capacity of this array is large enough to hold an entry for the buy side and another for the sell side. Objects of the <code>OMOrderSideHashMap</code> type will be indexed by the <code>sideToIndex(Side::BUY)</code> and <code>sideToIndex(Side::SELL)</code> indices:</p>
<pre class="source-code">
  typedef std::array&lt;OMOrder, sideToIndex(Side::MAX) + 1&gt;
    OMOrderSideHashMap;</pre>
<p>We must also define an <code>OMOrderTickerSideHashMap</code>, which is just another <code>std::array</code> of this <code>OMOrderSideHashMap</code> object that’s large enough to hold all trading instruments – that is, of <code>ME_MAX_TICKERS</code> size:</p>
<pre class="source-code">
  typedef std::array&lt;OMOrderSideHashMap, ME_MAX_TICKERS&gt;
    OMOrderTickerSideHashMap;</pre>
<p>Now, we can build the order manager class, which is used to manage <code>OMOrder</code> objects for trading strategies.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor245"/>Designing the OrderManager class</h2>
<p>Our<a id="_idIndexMarker1282"/> simplified order manager will manage <code>OMOrder</code> objects on the trading strategy’s behalf. To keep things simple, our <code>OrderManager</code> class will allow, at most, a single order on the buy side and a single order on the sell side. We will look at the details of this implementation in this section. All the code for the <code>OrderManager</code> class can be found in the <code>Chapter9/trading/strategy/order_manager.h</code> and <code>Chapter9/trading/strategy/order_manager.cpp</code> source files.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor246"/>Defining the data members in OrderManager</h2>
<p>We need <a id="_idIndexMarker1283"/>to define the data members that belong within our <code>OrderManager</code> class. But before we do that, in the following code block, we have provided the header files we will need to include in the <code>order_manager.h</code> source file. We must also forward declare the <code>TradeEngine</code> class since we will refer to it in this class but want to avoid circular dependency issues:</p>
<pre class="source-code">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "exchange/order_server/client_response.h"
#include "om_order.h"
#include "risk_manager.h"
using namespace Common;
namespace Trading {
  class TradeEngine;</pre>
<p>Now, we can design the internal data members in the <code>OrderManager</code> class. The key members <a id="_idIndexMarker1284"/>are as follows:</p>
<ul>
<li>A <code>trade_engine_</code> variable. This is a pointer to a <code>TradeEngine</code> object. We will use this to store the parent <code>TradeEngine</code> instance that is using this order manager.</li>
<li>A constant reference to a <code>RiskManager</code> object stored in the <code>risk_manager_</code> member variable. This will be used to perform <em class="italic">pre-trade</em> risk checks – that is, risk checks that are performed before new orders are sent out to the exchange.</li>
<li>A <code>ticker_side_order_</code> variable of the <code>OMOrderTickerSideHashMap</code> type to hold a pair (a buy and a sell) of <code>OMOrder</code> objects for each trading instrument. This will be used as a hash map that’s indexed first by the <code>TickerId</code> value of the instrument we want to send an order for and then indexed by the <code>sideToIndex(Side::BUY)</code> or <code>sideToIndex(Side::SELL)</code> values to manage the buy or sell order.</li>
<li>New and unique order IDs starting from <code>1</code>, which we will generate using a simple <code>next_order_id_</code> variable of the <code>OrderId</code> type:</li>
</ul>
<pre class="source-code">
  class OrderManager {
  private:
    TradeEngine *trade_engine_ = nullptr;
    const RiskManager&amp; risk_manager_;
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    OMOrderTickerSideHashMap ticker_side_order_;
    OrderId next_order_id_ = 1;
  };
}</pre>
<p>That is all the<a id="_idIndexMarker1285"/> data inside the <code>OrderManager</code> class. In the next subsection, we will learn how to initialize these members and the <code>OrderManager</code> class itself.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor247"/>Initializing OrderManager</h2>
<p>Initializing <code>OrderManager</code> is <a id="_idIndexMarker1286"/>straightforward. In addition to what we initialized in the class definition itself, we must initialize the <code>trade_engine_</code>, <code>risk_manager_</code> and <code>logger_</code> data members, which we expect to be passed through the constructor arguments:</p>
<pre class="source-code">
    OrderManager(Common::Logger *logger, TradeEngine
      *trade_engine, RiskManager&amp; risk_manager)
        : trade_engine_(trade_engine),
          risk_manager_(risk_manager), logger_(logger) {
    }</pre>
<p>As shown here, we must add a simple convenience function that we can use in our <code>OrderManager</code> implementation called <code>getOMOrderSideHashMap()</code>. This simply returns the <code>OMOrderSideHashMap</code> instance for the provided <code>TickerId</code>:</p>
<pre class="source-code">
    auto getOMOrderSideHashMap(TickerId ticker_id) const {
      return &amp;(ticker_side_order_.at(ticker_id));
    }</pre>
<p>Next, we can move on to an important task in <code>OrderManager</code> – sending new orders.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor248"/>Sending new orders from OrderManager</h2>
<p>The <code>OrderManager::newOrder()</code> method is the lower-level method in our order manager class. It <a id="_idIndexMarker1287"/>requires a pointer to an <code>OMOrder</code> object for which this new order is being sent. It also needs the <code>TickerId</code>, <code>Price</code>, <code>Side</code>, and <code>Qty</code> attributes to be set on the new order that’s being sent out:</p>
<pre class="source-code">
  auto OrderManager::newOrder(OMOrder *order, TickerId
    ticker_id, Price price, Side side, Qty qty) noexcept -&gt; void {</pre>
<p>It creates a <code>MEClientRequest</code> structure of the <code>ClientRequestType::NEW</code> type and fills in<a id="_idIndexMarker1288"/> the attributes that are passed through the arguments, sets <code>OrderId</code> to be <code>next_order_id_</code> and <code>ClientId</code> to be the client ID of <code>TradeEngine</code>, which can be obtained by calling the <code>clientId()</code> method. It also calls <code>TradeEngine::sendClientRequest()</code> and provides the <code>MEClientRequest</code> object (<code>new_request</code>) it just initialized:</p>
<pre class="source-code">
    const Exchange::MEClientRequest
      new_request{Exchange::ClientRequestType::NEW,
        trade_engine_-&gt;clientId(), ticker_id,
         next_order_id_, side, price, qty};
    trade_engine_-&gt;sendClientRequest(&amp;new_request);</pre>
<p>Finally, it updates the <code>OMOrder</code> object pointer it was provided in the method parameters and assigns it the attributes that were just set on the new order that was sent out. Note that the state of this <code>OMOrder</code> is set to <code>OMOrderState::PENDING_NEW</code> since it will be sent out shortly but will not be active until the exchange accepts it and we receive that response. It also increments the <code>next_order_id_</code> variable to maintain uniqueness on any new orders that might be sent out later:</p>
<pre class="source-code">
    *order = {ticker_id, next_order_id_, side, price, qty,
      OMOrderState::PENDING_NEW};
    ++next_order_id_;
    logger_-&gt;log("%:% %() % Sent new order % for %\n",
      __FILE__, __LINE__, __FUNCTION__,
                 Common::getCurrentTimeStr(&amp;time_str_),
                 new_request.toString().c_str(), order-&gt;
                   toString().c_str());
  }</pre>
<p>We will see where this <code>newOrder()</code> method gets called from shortly, but before that, let’s look at the complementary task of cancelling orders.</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor249"/>Cancelling orders from OrderManager</h2>
<p><code>OrderManager::cancelOrder()</code> is the lower-level method in our order manager class and <a id="_idIndexMarker1289"/>will be used to send a cancel request for live orders being managed by <code>OrderManager</code>. It only accepts a single parameter, which is the <code>OMOrder</code> object for which it is going to send the cancel request:</p>
<pre class="source-code">
  auto OrderManager::cancelOrder(OMOrder *order) noexcept
    -&gt; void {</pre>
<p>Like the <code>newOrder()</code> method, we must initialize an <code>MEClientRequest</code> <code>client_request</code> object of the <code>ClientRequestType::CANCEL</code> type and populate the attributes in it from the <code>OMOrder</code> object that was passed into the method. It calls the <code>TradeEngine::sendClientRequest()</code> method to send the cancel request out. One thing to understand is that the <code>next_order_id_</code> member variable is only used for generating new order IDs for new outgoing order requests. Cancelling an existing order does not change the <code>next_order_id_</code> variable, as shown in the following code block. In our design, <code>next_order_id_</code> keeps incrementing sequentially each time we send an <code>MEClientRequest</code> of the <code>ClientRequestType::NEW</code> type. Theoretically, we could reuse the <code>order_id_</code> value from the order we just cancelled on the next new order request, but that would require us to track the free order IDs, which is not too difficult either. This was just a design choice we made, but feel free to modify this scheme and track free order IDs if you wish:</p>
<pre class="source-code">
    const Exchange::MEClientRequest cancel_request
      {Exchange::ClientRequestType::CANCEL, trade_engine_-&gt;
        clientId(),
     order-&gt;ticker_id_, order-&gt;order_id_, order-&gt;side_,
       order-&gt;price_,
     order-&gt;qty_};
    trade_engine_-&gt;sendClientRequest(&amp;cancel_request);</pre>
<p>Finally, we must update the <code>order_state_</code> value of the <code>OMOrder</code> object to <code>OMOrderState::PENDING_CANCEL</code> to represent the fact that a cancel request has been sent out:</p>
<pre class="source-code">
    order-&gt;order_state_ = OMOrderState::PENDING_CANCEL;
    logger_-&gt;log("%:% %() % Sent cancel % for %\n",
      __FILE__, __LINE__, __FUNCTION__,
                 Common::getCurrentTimeStr(&amp;time_str_),
                 cancel_request.toString().c_str(), order-&gt;
                   toString().c_str());
  }</pre>
<p>Previously, we <a id="_idIndexMarker1290"/>mentioned that <code>newOrder()</code> and <code>cancelOrder()</code> are lower-level methods in the <code>OrderManager</code> class. Trading strategies that use <code>OrderManager</code> will not call these methods directly; instead, they will have <code>OrderManager</code> manage the orders by calling the <code>OrderManager::moveOrders()</code> method. We will build this in the next subsection.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor250"/>Adding methods to simplify order management</h2>
<p>Before we <a id="_idIndexMarker1291"/>build the <code>moveOrders()</code> method, we will build one more lower-level method that’s used by <code>OrderManager</code>. This method, called <code>moveOrder()</code>, manages a single order and either sends a new order or cancels an existing order, depending on the arguments provided to it. The most important parameter for this method is a pointer to an <code>OMOrder</code> object. It also accepts the <code>TickerId</code>, <code>Price</code>, <code>Side</code>, and <code>Qty</code> parameters. The purpose of this method is to make sure that the <code>OMOrder</code> object that’s passed to it is placed or replaced with the provided <code>price</code>, <code>side</code>, and <code>qty</code> arguments. This involves a combination of cancelling an existing order if it is not at the specified price and/or placing a new order with the <code>price</code> and <code>qty</code> parameters specified:</p>
<pre class="source-code">
    auto moveOrder(OMOrder *order, TickerId ticker_id,
      Price price, Side side, Qty qty) noexcept {</pre>
<p>The action this method decides to take depends on the current <code>order_state_</code> of the <code>OMOrder</code> object passed to it. We will go through the different <code>OMOrderState</code> cases one by one, starting with <code>OMOrderState::LIVE</code>. If the <code>OMOrder</code> object is already live/active, it checks to make sure that the <code>price</code> parameter matches the order’s <code>price_</code> attribute. If that is not the case, then it calls the <code>OrderManager::cancelOrder()</code> method to cancel this order and replaces it in the next iteration:</p>
<pre class="source-code">
      switch (order-&gt;order_state_) {
        case OMOrderState::LIVE: {
          if(order-&gt;price_ != price || order-&gt;qty_ != qty)
            cancelOrder(order);
        }
          break;</pre>
<p>For cases <a id="_idIndexMarker1292"/>where the order is in an <code>INVALID</code> or <code>DEAD</code> state, which means not active in the market, we will place the order using the <code>OrderManager::newOrder()</code> method we built previously. But it needs to check with <code>RiskManager</code> whether this action is allowed by calling the <code>RiskManager::checkPreTradeRisk()</code> method and passing it the <code>TickerId</code>, <code>Side</code> and <code>Qty</code> attributes of the order we would like to send. At this point, it should be clear why this is called pre-trade risk – we check if we can perform the action/trade before we do it. We will discuss the design and implementation of <code>RiskManager</code>, as well as the <code>checkPreTradeRisk()</code> method, shortly. For now, all you need to know is that it returns a <code>RiskCheckResult</code> enumeration value of <code>RiskCheckResult::ALLOWED</code> if the risk checks pass and a different value if the risk checks fail – that is, the action/trade is not allowed. In the following code block, we only send the order by calling the <code>newOrder()</code> method if the <code>checkPreTradeRisk()</code> method returns <code>RiskCheckResult::ALLOWED</code>. As a final note, here, we log an error message if the risk check fails using the <code>riskCheckResultToString()</code> method. We will cover this shortly:</p>
<pre class="source-code">
        case OMOrderState::INVALID:
        case OMOrderState::DEAD: {
          if(LIKELY(price != Price_INVALID)) {
            const auto risk_result = risk_manager_
              .checkPreTradeRisk(ticker_id, side, qty);
            if(LIKELY(risk_result == RiskCheckResult
              ::ALLOWED))
              newOrder(order, ticker_id, price, side, qty);
            else
              logger_-&gt;log("%:% %() % Ticker:% Side:% Qty:%
                RiskCheckResult:%\n", __FILE__, __LINE__,
                   __FUNCTION__,
                           Common::getCurrentTimeStr(&amp;time_
                             str_),
                           tickerIdToString(ticker_id),
                             sideToString(side),
                               qtyToString(qty),
                           riskCheckResultToString
                             (risk_result));
          }
        }
          break;</pre>
<p>For the<a id="_idIndexMarker1293"/> cases where the <code>OMOrder</code> object’s <code>order_state_</code> is <code>PENDING_NEW</code> or <code>PENDING_CANCEL</code>, we do nothing since we are waiting for a response from the electronic trading exchange before we can proceed:</p>
<pre class="source-code">
        case OMOrderState::PENDING_NEW:
        case OMOrderState::PENDING_CANCEL:
          break;
      }
    }</pre>
<p>Now, we have all the pieces we need to build our <code>OrderManager::moveOrders()</code> method. This is the primary method that’s used by trading strategies to generate and manage the orders it needs. It accepts a few parameters – the <code>TickerId</code> parameter of the instrument, the <code>Price</code> parameter’s <code>bid_price</code> for the buy order, the <code>Price</code> parameter’s <code>ask_price</code> for the sell order, and a <code>clip</code> parameter of the <code>Qty</code> type, which will be the quantity of the buy and sell orders. We will see where this <code>clip</code> parameter comes from in the <em class="italic">Defining the TradeEngineCfg structure</em> subsection, in the <em class="italic">Computing and managing risk</em> section. For now, note that the term <code>clip</code> comes from the term clip for ammunition for firearms, and in the context of our trading strategies, it means the size of each order that our trading strategy can send. We will see that this parameter gets used to set the size of outgoing new order requests. This is just the name of the variable we chose; it could also be <code>trade_size</code>, <code>order_size</code>, and so on.</p>
<p>One <a id="_idIndexMarker1294"/>thing to note here is that passing a price value of <code>Price_INVALID</code> for <code>bid_price</code> or <code>ask_price</code> will cause the order to be cancelled – that is, it will only have an order on the buy side or the sell side instead of both. This is because the <code>moveOrder()</code> method cancels an order if the price on <code>OMOrder</code> does not match the price passed to the method. And because any <code>OMOrder</code> that is active in the market (<code>OMOrderState::LIVE</code>) will have a valid price other than <code>Price_INVALID</code>, that check evaluates to true and causes the order to be cancelled. One more thing to note here is that, currently, we support a single <code>clip</code> value for both the buy and sell orders, but it is easy to extend this so that we have different quantities for the buy order and the sell order. The implementation of this method is extremely simple – it fetches the buy order (<code>bid_order</code>) by indexing the <code>ticker_side_order_</code> container with the <code>ticker_id</code> value and indexing that with the <code>sideToIndex(Side::BUY)</code> value. It then calls the <code>OrderManager::moveOrder()</code> method on this <code>bid_order</code> and passes it the <code>bid_price</code> parameter for the price and passes it the <code>clip</code> parameter for the quantity. We do the same thing for the sell order (<code>ask_order</code>), except we use <code>sideToIndex(Side::SELL)</code> and <code>ask_price</code> for the sell side:</p>
<pre class="source-code">
    auto moveOrders(TickerId ticker_id, Price bid_price,
      Price ask_price, Qty clip) noexcept {
      auto bid_order =
        &amp;(ticker_side_order_.at(ticker_id)
          .at(sideToIndex(Side::BUY)));
      moveOrder(bid_order, ticker_id, bid_price, Side::BUY,
        clip);
      auto ask_order = &amp;(ticker_side_order_
        .at(ticker_id).at(sideToIndex(Side::SELL)));
      moveOrder(ask_order, ticker_id, ask_price, Side::
        SELL, clip);
    }</pre>
<p>We need <a id="_idIndexMarker1295"/>to add one final functionality to our <code>OrderManager</code> class, which is handling incoming order responses. We will tackle this in the next subsection.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor251"/>Handling order updates and updating orders</h2>
<p>Before we<a id="_idIndexMarker1296"/> can wrap up our discussion on the implementation of <code>OrderManager</code>, we need to add some code to handle incoming<a id="_idIndexMarker1297"/> order responses in the form of <code>MEClientResponse</code> messages. The <code>OrderManager::onOrderUpdate()</code> method we will build here expects to be called and passed a <code>MEClientResponse</code> object:</p>
<pre class="source-code">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   client_response-&gt;toString().c_str());</pre>
<p>First, we must fetch the <code>OMOrder</code> object that this <code>MEClientResponse</code> message is meant for. We can do that by accessing the <code>ticker_side_order_</code> container using the <code>ticker_id_</code> field in <code>client_response</code> and converting the <code>side_</code> field in the <code>client_response</code> message into an index using the <code>sideToIndex()</code> method. This is shown in the following code block:</p>
<pre class="source-code">
      auto order = &amp;(ticker_side_order_.at(client_response
        -&gt;ticker_id_).at(sideToIndex(client_response
          -&gt;side_)));
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   order-&gt;toString().c_str());</pre>
<p>We will update the <code>OMOrder</code> object we fetched previously, but that depends on the type of <code>MEClientResponse</code> we received. In the case of <code>ClientResponseType::ACCEPTED</code>, all we need to do is set the <code>order_state_</code> member <a id="_idIndexMarker1298"/>of this <code>OMOrder</code> object to <code>OMOrderState::LIVE</code> to mark it as accepted and active in the market:</p>
<pre class="source-code">
      switch (client_response-&gt;type_) {
        case Exchange::ClientResponseType::ACCEPTED: {
          order-&gt;order_state_ = OMOrderState::LIVE;
        }
          break;</pre>
<p>If the type<a id="_idIndexMarker1299"/> of the response is <code>ClientResponseType::CANCELED</code>, then we just update the <code>order_state_</code> variable of <code>OMOrder</code> to <code>OMOrderState::DEAD</code> since it is no longer active in the market:</p>
<pre class="source-code">
        case Exchange::ClientResponseType::CANCELED: {
          order-&gt;order_state_ = OMOrderState::DEAD;
        }
          break;</pre>
<p>If <code>MEClientResponse</code> is of the <code>ClientResponseType::FILLED</code> type, which is done to denote an execution, we update the <code>qty_</code> field on <code>OMOrder</code> to be the new <code>leaves_qty_</code>. This reflects the live quantity that still exists in the market. We also need to check that if the <code>qty_</code> field (and thus the <code>leaves_qty_</code> field on <code>client_response</code>) is 0, meaning the order was fully executed, the order is no longer active in the market. If so, we must set <code>order_state_</code> to <code>OMOrderState::DEAD</code>:</p>
<pre class="source-code">
        case Exchange::ClientResponseType::FILLED: {
          order-&gt;qty_ = client_response-&gt;leaves_qty_;
          if(!order-&gt;qty_)
            order-&gt;order_state_ = OMOrderState::DEAD;
        }
          break;</pre>
<p>We ignore the <code>CANCEL_REJECTED</code> and <code>INVALID</code> <code>ClientResponseType</code> enumeration <a id="_idIndexMarker1300"/>values since there is no action that we <a id="_idIndexMarker1301"/>need to take:</p>
<pre class="source-code">
        case Exchange::ClientResponseType::CANCEL_REJECTED:
        case Exchange::ClientResponseType::INVALID: {
        }
          break;
      }
    }</pre>
<p>This concludes the discussion, design, and implementation of our <code>OrderManager</code> component. However, we referenced and used <code>RiskManager</code> in the implementation of the <code>OrderManager</code> class without discussing all its details. We will do this in the next section.</p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor252"/>Computing and managing risk</h1>
<p>The <a id="_idIndexMarker1302"/>final component we still need to <a id="_idIndexMarker1303"/>build before we can build our trading strategies is <code>RiskManager</code>. The <code>RiskManager</code> component tracks the active order quantities that a trading strategy has in the market through the same <code>OrderManager</code> instance that a trading strategy uses. It also tracks the positions and realized and unrealized PnLs using the <code>PositionKeeper</code> instance, which tracks the trading strategy’s positions and PnLs. It checks that the strategy stays<a id="_idIndexMarker1304"/> within its assigned risk limits. If the trading strategy goes past its risk limits, such as if it loses more money than it’s allowed, tries to send an order larger than it’s allowed, or builds a position larger than it’s allowed, it prevents it from trading. To keep our <code>RiskManager</code> simple, we will only implement risk checks on the maximum allowed order size, the maximum allowed position, and the maximum allowed loss for each trading instrument in the client’s trading system. The source code for our <code>RiskManager</code> can be found in the <code>Chapter9/trading/strategy/risk_manager.h</code> and <code>Chapter9/trading/strategy/risk_manager.cpp</code> source files. First, we will declare an enumeration and a <code>RiskInfo</code> struct. We discussed the details of this component in <em class="italic">Chapter</em>, <em class="italic">Designing Our Trading Ecosystem</em>, in the <em class="italic">Designing a framework for low-latency C++ trading </em><em class="italic">algorithms</em> section.</p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor253"/>Defining the RiskCfg structure</h2>
<p>First, we will <a id="_idIndexMarker1305"/>define a structure that holds risk configurations. This is called the <code>RiskCfg</code> struct and is defined in the <code>Chapter9/common/types.h</code> header file. The risk configuration holds the following parameters:</p>
<ul>
<li>A <code>max_order_size_</code> member of the <code>Qty</code> type. It represents the maximum allowed order size that a strategy is allowed to send.</li>
<li>A <code>max_position_</code> member variable of the <code>Qty</code> type. This represents the maximum position that a strategy is allowed to build.</li>
<li>A <code>max_loss_</code> variable of the <code>double</code> type. This is the maximum allowed loss before the trading strategy is shut off from trading further.</li>
</ul>
<p>We must also add a <code>toString()</code> method to the structure for logging purposes:</p>
<pre class="source-code">
  struct RiskCfg {
    Qty max_order_size_ = 0;
    Qty max_position_ = 0;
    double max_loss_ = 0;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "RiskCfg{"
         &lt;&lt; "max-order-size:" &lt;&lt;
           qtyToString(max_order_size_) &lt;&lt; " "
         &lt;&lt; "max-position:" &lt;&lt; qtyToString(max_position_)
         &lt;&lt; " "
         &lt;&lt; "max-loss:" &lt;&lt; max_loss_
         &lt;&lt; "}";
      return ss.str();
    }
  };</pre>
<p>We will <a id="_idIndexMarker1306"/>define another configuration structure in the next section. This structure will be used to configure <code>TradeEngine</code>.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor254"/>Defining the TradeEngineCfg structure</h2>
<p>First, we <a id="_idIndexMarker1307"/>must define a structure to encapsulate <code>TradeEngine</code> configurations. We will call it <code>TradeEngineCfg</code>. This is what we use as the higher-level <code>TradeEngine</code> configuration and is defined in the <code>Chapter9/common/types.h</code> header file. It has the following important data members:</p>
<ul>
<li>A <code>clip_</code> member of the <code>Qty</code> type. This is what the trading strategies will use as the quantity of the orders that they send out.</li>
<li>A <code>threshold_</code> member of the <code>double</code> type. This will be used by the trading strategies and will be used against the feature values to decide if a trading decision needs to be made or not.</li>
<li>The final member is a <code>risk_cfg_</code> variable of the <code>RiskCfg</code> type. We defined this previously so that it can hold the risk configuration.</li>
</ul>
<p>As usual, we must also define a <code>toString()</code> method to convert these objects into strings for logging purposes. All the code described here can be seen in the following code block:</p>
<pre class="source-code">
  struct TradeEngineCfg {
    Qty clip_ = 0;
    double threshold_ = 0;
    RiskCfg risk_cfg_;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "TradeEngineCfg{"
         &lt;&lt; "clip:" &lt;&lt; qtyToString(clip_) &lt;&lt; " "
         &lt;&lt; "thresh:" &lt;&lt; threshold_ &lt;&lt; " "
         &lt;&lt; "risk:" &lt;&lt; risk_cfg_.toString()
         &lt;&lt; "}";
      return ss.str();
    }
  };</pre>
<p>The <code>TradeEngineCfgHashMap</code> type <a id="_idIndexMarker1308"/>we are defining here is a <code>std::array</code> of these <code>TradeEngineCfg</code> objects and is large enough to hold all possible <code>TickerId</code> values (<code>ME_MAX_TICKERS</code>):</p>
<pre class="source-code">
  typedef std::array&lt;TradeEngineCfg, ME_MAX_TICKERS&gt;
    TradeEngineCfgHashMap;</pre>
<p>Now, we need to define a type to represent the outcome of risk checks – the <code>RiskCheckResult</code> enumeration.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor255"/>Declaring the RiskCheckResult enumeration</h2>
<p>First, we<a id="_idIndexMarker1309"/> will formally declare the <code>RiskCheckResult</code> enumeration we encountered before. But before we do that, let’s look at the <code>include</code> files we need in the <code>risk_manager.h</code> header file. We will also need to forward declare the <code>OrderManager</code> class we built before so that we can use it without running into circular header dependency issues:</p>
<pre class="source-code">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "position_keeper.h"
#include "om_order.h"
using namespace Common;
namespace Trading {
  class OrderManager;</pre>
<p>The <code>RiskCheckResult</code> enumeration<a id="_idIndexMarker1310"/> is used to encapsulate information about the outcome of a risk check in <code>RiskManager</code>. Let’s look at these values in more detail:</p>
<ul>
<li><code>INVALID</code> represents an invalid sentinel value.</li>
<li><code>ORDER_TOO_LARGE</code> means that the risk check failed because the order quantity that we are attempting to send would exceed the maximum allowed order quantity limit.</li>
<li><code>POSITION_TOO_LARGE</code> means that the current position, plus the order quantity on the side we are attempting to send, would cause us to potentially exceed the maximum position limit that’s been configured in <code>RiskManager</code>.</li>
<li>The <code>LOSS_TOO_LARGE</code> enumeration represents the fact that the risk check failed because the trading strategy’s total loss (realized plus unrealized loss) is above what is allowed in <code>RiskManager</code>.</li>
<li>The <code>ALLOWED</code> enumeration is a value that represents that all risk checks passed successfully. As mentioned previously, this is the only value that allows the trading strategy to send additional orders to the exchange:</li>
</ul>
<pre class="source-code">
  enum class RiskCheckResult : int8_t {
    INVALID = 0,
    ORDER_TOO_LARGE = 1,
    POSITION_TOO_LARGE = 2,
    LOSS_TOO_LARGE = 3,
    ALLOWED = 4
  };</pre>
<p>We will also<a id="_idIndexMarker1311"/> add a <code>riskCheckResultToString()</code> method to convert these enumerations into strings for logging purposes:</p>
<pre class="source-code">
  inline auto riskCheckResultToString(RiskCheckResult
    result) {
    switch (result) {
      case RiskCheckResult::INVALID:
        return "INVALID";
      case RiskCheckResult::ORDER_TOO_LARGE:
        return "ORDER_TOO_LARGE";
      case RiskCheckResult::POSITION_TOO_LARGE:
        return "POSITION_TOO_LARGE";
      case RiskCheckResult::LOSS_TOO_LARGE:
        return "LOSS_TOO_LARGE";
      case RiskCheckResult::ALLOWED:
        return "ALLOWED";
    }
    return "";
  }</pre>
<p>In the next <a id="_idIndexMarker1312"/>section, we will define the basic <code>RiskInfo</code> struct, which holds the information we need to perform risk checks for a single trading instrument.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor256"/>Defining the RiskInfo structure</h2>
<p>As <a id="_idIndexMarker1313"/>mentioned previously, the <code>RiskInfo</code> struct holds the information needed to perform risk checks for a single trading instrument. The <code>RiskManager</code> class maintains and manages a container of <code>RiskInfo</code> objects. The <code>RiskInfo</code> struct needs the following important data members:</p>
<ul>
<li>A <code>const</code> pointer to <code>PositionInfo</code> called <code>position_info_</code>. This will be used to fetch the position and PnL information for the trading instrument.</li>
<li>An object (<code>risk_cfg_</code>) of the <code>RiskCfg</code> type to hold the configured risk limits for this instrument. These are the limits that will be checked against:</li>
</ul>
<pre class="source-code">
  struct RiskInfo {
    const PositionInfo *position_info_ = nullptr;
    RiskCfg risk_cfg_;</pre>
<p>Let’s add a <code>toString()</code> method to this class for logging purposes:</p>
<pre class="source-code">
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "RiskInfo" &lt;&lt; "["
         &lt;&lt; "pos:" &lt;&lt; position_info_-&gt;toString() &lt;&lt; " "
         &lt;&lt; risk_cfg_.toString()
         &lt;&lt; "]";
      return ss.str();
    }</pre>
<p>Finally, we<a id="_idIndexMarker1314"/> must define a <code>TickerRiskInfoHashMap</code> type, which is a <code>std::array</code> of <code>RiskInfo</code> objects of <code>ME_MAX_TICKERS</code> size. We will use this as a hash map of <code>TickerId</code> to <code>RiskInfo</code> objects:</p>
<pre class="source-code">
  typedef std::array&lt;RiskInfo, ME_MAX_TICKERS&gt;
    TickerRiskInfoHashMap;</pre>
<p>Next, we will look at the implementation of the <code>checkPreTradeRisk()</code> method, which performs the actual risk checks.</p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor257"/>Performing risk checks in RiskInfo</h2>
<p>The <code>checkPreTradeRisk()</code> method accepts a <code>Side</code> argument and a <code>Qty</code> argument <a id="_idIndexMarker1315"/>and returns a <code>RiskCheckResult</code> enumeration value, depending on whether the risk check passes or fails for some reason:</p>
<pre class="source-code">
    auto checkPreTradeRisk(Side side, Qty qty) const
      noexcept {</pre>
<p>First, it checks if the <code>qty</code> argument that’s passed to the method is larger than the <code>max_order_size_</code> member in the <code>RiskCfg</code> object (<code>risk_cfg_</code>). If this is the case, the risk check fails, and it returns the <code>RiskCheckResult::ORDER_TOO_LARGE</code> enumeration:</p>
<pre class="source-code">
      if (UNLIKELY(qty &gt; risk_cfg_.max_order_size_))
        return RiskCheckResult::ORDER_TOO_LARGE;</pre>
<p>Then, it checks if the current <code>position_</code> (which it fetches from the <code>position_info_</code> data member), plus the additional <code>qty</code> we want to send, exceeds the maximum allowed <code>max_position_ limit</code> in the <code>RiskCfg</code> object (<code>risk_cfg_</code>). Note that it uses the <code>sideToValue(side)</code> method here to correctly compute what the position could be if this new <code>qty</code> were to be executed and then uses the <code>std::abs()</code> method to correctly compare against the <code>max_position_</code> parameter. In the case of a failure, it signifies the error by returning the <code>RiskCheckResult::POSITION_TOO_LARGE</code> method:</p>
<pre class="source-code">
      if (UNLIKELY(std::abs(position_info_-&gt;position_ +
        sideToValue(side) * static_cast&lt;int32_t&gt;(qty)) &gt;
          static_cast&lt;int32_t&gt;(risk_cfg_.max_position_)))
        return RiskCheckResult::POSITION_TOO_LARGE;</pre>
<p>Finally, it <a id="_idIndexMarker1316"/>checks the last risk metric in our <code>RiskManager</code>, which is the total loss. It checks <code>total_pnl_</code> from <code>position_info_</code> against the <code>max_loss_</code> parameter in the <code>risk_cfg_</code> configuration. If the loss exceeds the max loss allowed, it returns a <code>RiskCheckResult::LOSS_TOO_LARGE</code> enumeration value:</p>
<pre class="source-code">
      if (UNLIKELY(position_info_-&gt;total_pnl_ &lt;
        risk_cfg_.max_loss_))
        return RiskCheckResult::LOSS_TOO_LARGE;</pre>
<p>Finally, if all the risk checks pass successfully, it returns the <code>RiskCheckResult::ALLOWED</code> value:</p>
<pre class="source-code">
      return RiskCheckResult::ALLOWED;
    }</pre>
<p>This important method concludes the design and implementation of the <code>RiskInfo</code> struct. Now, we can start building the <code>RiskManager</code> class, which is used by the other components we covered.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor258"/>Designing the data members in RiskManager</h2>
<p>Now, we will <a id="_idIndexMarker1317"/>design our <code>RiskManager</code>, starting by defining the data members that make up this class. The key member is a <code>ticker_risk_</code> variable of the <code>TickerRiskInfoHashMap</code> type and holds <code>RiskInfo</code> objects. We defined this previously:</p>
<pre class="source-code">
  class RiskManager {
  private:
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    TickerRiskInfoHashMap ticker_risk_;
  };</pre>
<p>Next, we will<a id="_idIndexMarker1318"/> learn how to initialize the <code>RiskManager</code> class.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor259"/>Initializing our RiskManager class</h2>
<p>The <code>RiskManager</code> constructor<a id="_idIndexMarker1319"/> expects a <code>Logger</code> object, a pointer to a <code>PositionKeeper</code> object, and a reference to an object of the <code>TradeEngineCfgHashMap</code> type (<code>ticker_cfg</code>) that holds the risk configurations. It initializes the <code>logger_</code> member variable and stores the <code>PositionInfo</code> objects from the <code>PositionKeeper</code> (<code>getPositionInfo()</code>) and <code>RiskCfg</code> objects from <code>TradeEngineCfgHashMap</code> (<code>risk_cfg_</code>) in the <code>TickerRiskInfoHashMap</code> data member (<code>ticker_risk_</code>):</p>
<pre class="source-code">
  RiskManager::RiskManager(Common::Logger *logger, const
    PositionKeeper *position_keeper, const
      TradeEngineCfgHashMap &amp;ticker_cfg)
      : logger_(logger) {
    for (TickerId i = 0; i &lt; ME_MAX_TICKERS; ++i) {
      ticker_risk_.at(i).position_info_ = position_keeper
        -&gt;getPositionInfo(i);
      ticker_risk_.at(i).risk_cfg_ =
        ticker_cfg[i].risk_cfg_;
    }
  }</pre>
<p>Next, we will implement the final task that <code>RiskManager</code> needs to perform – performing risk checks.</p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor260"/>Performing risk checks in RiskManager</h2>
<p>Given a <code>TickerId</code> for an<a id="_idIndexMarker1320"/> instrument, as well as a <code>Side</code> and <code>Qty</code> for the order we expect to send, performing risk checks for it in <code>RiskManager</code> is straightforward. It simply fetches the correct <code>RiskInfo</code> object corresponding to the instrument, calls the <code>RiskInfo::checkPreTradeRisk()</code> method, and returns the return value from that method:</p>
<pre class="source-code">
    auto checkPreTradeRisk(TickerId ticker_id, Side side,
      Qty qty) const noexcept {
      return ticker_risk_.at(ticker_id)
        .checkPreTradeRisk(side, qty);
    }</pre>
<p>That concludes our design and implementation of the <code>RiskManager</code> component, as well as all the components we needed before we can start putting them together and building our trading strategies. We will start with that in the next chapter.</p>
<p>One important note is that we will need to build all the components presented in this chapter, as well as <em class="italic">Building the C++ Market-Making and Liquidity-Taking Algorithms</em> chapter before we can build and run a meaningful trading client. Since our ecosystem consists of a server (trading exchange) and client (trading client) infrastructure, we will need to wait until the <em class="italic">Building the C++ Market-Making and Liquidity-Taking Algorithms</em> chapter, the <em class="italic">Building and running the main trading application</em> section, before we can run the full ecosystem.</p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor261"/>Summary</h1>
<p>In this chapter, our primary focus was on adding intelligence and sophistication to the market participants’ trading systems. First, we discussed our market-making and liquidity-taking trading strategies. We discussed the motivation behind these strategies, how they seek to profit in the markets, and the trading dynamics of these algorithms.</p>
<p>We implemented the important components that make up the intelligence around our trading strategies. The first one was the feature engine that’s used to compute trading features/signals from the market data so that they can be used by the trading strategies to make informed trading decisions. The next one was the position keeper, which is in charge of tracking a trading strategy’s positions and PnLs as the strategy’s orders are executed in the market. After, we looked at the order manager component, which sends and manages live orders in the market to simplify the trading strategy’s implementation. The risk manager was the final and possibly the most vital component that we looked at since it is in charge of tracking and regulating the risk that a trading algorithm has currently taken, as well as any additional risk it is trying to take.</p>
<p>Now that we have all the important components in one place, in the next chapter, we will build our market-making strategy to provide passive liquidity in the market. Then, we will build the liquidity-taking trading algorithm to send aggressive orders and initiate and manage positions in the market. Finally, we will build our trade engine framework, which will house all the necessary components and build and drive the trading algorithms we built. By doing this, we will complete our electronic trading ecosystem.</p>
</div>
</body></html>