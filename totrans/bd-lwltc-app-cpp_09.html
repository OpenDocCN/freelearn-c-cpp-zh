<html><head></head><body>
<div id="_idContainer057">
<h1 class="chapter-number" id="_idParaDest-214"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-215"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.2.1">Building the C++ Trading Algorithm’s Building Blocks</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will build components that make up the intelligence in our trading applications. </span><span class="koboSpan" id="kobo.3.2">These are the components that the trading strategies will rely on very heavily to make decisions, send and manage orders, track and manage positions, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">profits and losses</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">PnLs</span></strong><span class="koboSpan" id="kobo.7.1">), and manage risk. </span><span class="koboSpan" id="kobo.7.2">Not only do the trading strategies need to track the trading PnLs since the goal is to make money, but these components also need to track the PnLs to decide when to stop trading if needed. </span><span class="koboSpan" id="kobo.7.3">We will learn how to compute complex features from market data updates, track trading performance based on order executions and market updates, send and manage live strategy orders in the market, and manage market risk. </span><span class="koboSpan" id="kobo.7.4">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Reacting to executions and managing positions, PnLs, </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and risk</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Building the feature engine and computing </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">complex features</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Using executions and updating positions </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and PnLs</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Sending and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">managing orders</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Computing and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">managing risk</span></span></li>
</ul>
<h1 id="_idParaDest-216"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">All the code for this book can be found in this book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">The source for this chapter is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">Chapter9</span></strong><span class="koboSpan" id="kobo.24.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">this repository.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">You must have read and understood the design of the electronic trading ecosystem that was presented in </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter</span></em><span class="koboSpan" id="kobo.28.1">, </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.30.1">, especially the </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Designing a framework for low-latency C++ trading algorithms</span></em><span class="koboSpan" id="kobo.32.1"> section. </span><span class="koboSpan" id="kobo.32.2">As before, we will use the building blocks we built in </span><em class="italic"><span class="koboSpan" id="kobo.33.1">Chapter</span></em><span class="koboSpan" id="kobo.34.1">, </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Building the C++ Building Blocks for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.36.1">Low-Latency Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">The specifications of the environment in which the source code for this book was developed are shown here. </span><span class="koboSpan" id="kobo.38.2">We have provided the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes for it to work in </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">your environment:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.40.1">OS</span></strong><span class="koboSpan" id="kobo.41.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">x86_64 GNU/Linux.</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">GCC</span></strong><span class="koboSpan" id="kobo.45.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">g++ (Ubuntu </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">11.3.0-1ubuntu1~22.04.1) 11.3.0.</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">CMAKE</span></strong><span class="koboSpan" id="kobo.49.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">cmake </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">version 3.23.2.</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.52.1">NINJA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">1.10.2.</span></strong></span></li>
</ul>
<h1 id="_idParaDest-217"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.55.1">Reacting to executions and managing positions, PnLs, and risk</span></h1>
<p><span class="koboSpan" id="kobo.56.1">We need to build a few basic building blocks that will build and support our trading strategies. </span><span class="koboSpan" id="kobo.56.2">We discussed the need for these components in </span><em class="italic"><span class="koboSpan" id="kobo.57.1">Chapter</span></em><span class="koboSpan" id="kobo.58.1">, </span><em class="italic"><span class="koboSpan" id="kobo.59.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.60.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.61.1">Designing a framework for low-latency C++ trading algorithms</span></em><span class="koboSpan" id="kobo.62.1"> section. </span><span class="koboSpan" id="kobo.62.2">We have already implemented a major component – the limit order book – but in this section, we will build the remaining components we need, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.64.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.66.1">, which </span><a id="_idIndexMarker1235"/><span class="koboSpan" id="kobo.67.1">will be used to compute simple and complex features/signals that drive the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">strategy decisions</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.71.1">, which</span><a id="_idIndexMarker1236"/><span class="koboSpan" id="kobo.72.1"> will receive executions and compute important measures such as position, PnLs, traded volumes, </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">and more</span></span></li>
<li><span class="koboSpan" id="kobo.74.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">OrderManager</span></strong><span class="koboSpan" id="kobo.76.1">, which</span><a id="_idIndexMarker1237"/><span class="koboSpan" id="kobo.77.1"> will be used by the strategies to send orders, manage them, and update these orders when there </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">are updates</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">RiskManager</span></strong><span class="koboSpan" id="kobo.81.1"> to compute </span><a id="_idIndexMarker1238"/><span class="koboSpan" id="kobo.82.1">and check the market risk that a trading strategy is attempting to take on, as well as the risk it </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">has realized</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.84.1">The following diagram shows the topology of all these components and how they interact with each other. </span><span class="koboSpan" id="kobo.84.2">If you need to refresh your memory on why these components exist, what purpose they serve, how they interact with each other, and how they are designed, please revisit </span><em class="italic"><span class="koboSpan" id="kobo.85.1">Chapter</span></em><span class="koboSpan" id="kobo.86.1">, </span><em class="italic"><span class="koboSpan" id="kobo.87.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.88.1">, and look at the subsections in the </span><em class="italic"><span class="koboSpan" id="kobo.89.1">Designing a framework for low-latency C++ trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">algorithms</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1"> section:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.92.1"><img alt="Figure 9.1 – The sub-components inside our trading engine" src="image/Figure_9.1_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.93.1">Figure 9.1 – The sub-components inside our trading engine</span></p>
<p><span class="koboSpan" id="kobo.94.1">Now, let’s kick off our effort </span><a id="_idIndexMarker1239"/><span class="koboSpan" id="kobo.95.1">of implementing these components, starting with the feature engine in the next sub-section. </span><span class="koboSpan" id="kobo.95.2">But before we do that, we need to add two additional methods for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">Side</span></strong><span class="koboSpan" id="kobo.97.1"> enumeration, which will make a lot of our source code simpler down the road. </span><span class="koboSpan" id="kobo.97.2">Both of these can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">Chapter9/common/types.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.99.1">header file.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">The first method we will add is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">sideToIndex()</span></strong><span class="koboSpan" id="kobo.102.1"> method, which converts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Side</span></strong><span class="koboSpan" id="kobo.104.1"> value into an index that can be used to index into an array. </span><span class="koboSpan" id="kobo.104.2">This will allow us to maintain arrays of different types of objects that are indexed by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Side</span></strong><span class="koboSpan" id="kobo.106.1"> value. </span><span class="koboSpan" id="kobo.106.2">The implementation is simple – we simply typecast the side to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">size_t</span></strong><span class="koboSpan" id="kobo.108.1"> type and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">1</span></strong><span class="koboSpan" id="kobo.110.1"> to account for the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">Side::SELL</span></strong><span class="koboSpan" id="kobo.112.1"> has a value of -1 and valid that indices start </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">from 0:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
  inline constexpr auto sideToIndex(Side side) noexcept {
    return static_cast&lt;size_t&gt;(side) + 1;
  }</span></pre>
<p><span class="koboSpan" id="kobo.115.1">We will also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">sideToValue()</span></strong><span class="koboSpan" id="kobo.117.1"> method, which converts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Side</span></strong><span class="koboSpan" id="kobo.119.1"> value into either a 1 for </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Side::BUY</span></strong><span class="koboSpan" id="kobo.121.1"> or a -1 for </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Side::SELL</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">This will help us when we compute positions and PnLs, which we will see shortly in </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">this section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
  inline constexpr auto sideToValue(Side side) noexcept {
    return static_cast&lt;int&gt;(side);
  }</span></pre>
<p><span class="koboSpan" id="kobo.126.1">Now that we have that additional functionality out of the way, we can start computing the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">feature engine.</span></span></p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.128.1">Building the feature and computing complex features</span></h1>
<p><span class="koboSpan" id="kobo.129.1">In this </span><a id="_idIndexMarker1240"/><span class="koboSpan" id="kobo.130.1">section, we will</span><a id="_idIndexMarker1241"/><span class="koboSpan" id="kobo.131.1"> build a minimal version of a feature engine. </span><span class="koboSpan" id="kobo.131.2">We will only compute two simple features – one (market price) that computes fair market prices based on the top of book prices and quantity and another (aggressive trade qty ratio) that computes how big a trade is compared to the top of book quantities. </span><span class="koboSpan" id="kobo.131.3">We will use these feature values to drive our market-making and liquidity-taking trading algorithms later in this chapter. </span><span class="koboSpan" id="kobo.131.4">The source code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.133.1"> class we will build here can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Chapter9/trading/strategy/feature_engine.h</span></strong><span class="koboSpan" id="kobo.135.1"> file on GitHub. </span><span class="koboSpan" id="kobo.135.2">We discussed the details of this component in </span><em class="italic"><span class="koboSpan" id="kobo.136.1">Chapter</span></em><span class="koboSpan" id="kobo.137.1">, </span><em class="italic"><span class="koboSpan" id="kobo.138.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.139.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.140.1">Designing a framework for low-latency C++ trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.141.1">algorithms</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.142.1"> section.</span></span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.143.1">Defining the data members in the feature engine</span></h2>
<p><span class="koboSpan" id="kobo.144.1">First, we </span><a id="_idIndexMarker1242"/><span class="koboSpan" id="kobo.145.1">need to declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.147.1"> class and define the data members inside this class. </span><span class="koboSpan" id="kobo.147.2">First, we will include the required header files and define a constant sentinel value to represent invalid or uninitialized feature values. </span><span class="koboSpan" id="kobo.147.3">This is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">Feature_INVALID</span></strong><span class="koboSpan" id="kobo.149.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.151.1">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
using namespace Common;
namespace Trading {
  constexpr auto Feature_INVALID =
    std::numeric_limits&lt;double&gt;::quiet_NaN();</span></pre>
<p><span class="koboSpan" id="kobo.152.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.154.1"> class is basic and has two important data members of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">double</span></strong><span class="koboSpan" id="kobo.156.1"> type – one</span><a id="_idIndexMarker1243"/><span class="koboSpan" id="kobo.157.1"> to compute and store the fair market price value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">mkt_price_</span></strong><span class="koboSpan" id="kobo.159.1">, and another to compute and store the aggressive trade quantity ratio feature value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">agg_trade_qty_ratio_</span></strong><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">It also stores a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Logger</span></strong><span class="koboSpan" id="kobo.163.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">logger_</span></strong><span class="koboSpan" id="kobo.165.1">) for </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">logging purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
  class FeatureEngine {
  private:
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    double mkt_price_ = Feature_INVALID,
      agg_trade_qty_ratio_ = Feature_INVALID;
  };</span></pre>
<p><span class="koboSpan" id="kobo.168.1">Next, we will look at how to initialize this class since we have already initialized the two feature variables with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">Feature_INVALID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1"> value.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.171.1">Initializing the feature engine</span></h2>
<p><span class="koboSpan" id="kobo.172.1">The</span><a id="_idIndexMarker1244"/><span class="koboSpan" id="kobo.173.1"> constructor for this class accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Logger</span></strong><span class="koboSpan" id="kobo.175.1"> object and initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">logger_</span></strong><span class="koboSpan" id="kobo.177.1"> data member – </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">that’s all:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
    FeatureEngine(Common::Logger *logger)
        : logger_(logger) {
    }</span></pre>
<p><span class="koboSpan" id="kobo.180.1">Here, we will present two getter methods – </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">getMktPrice()</span></strong><span class="koboSpan" id="kobo.182.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">getAggTradeQtyRatio()</span></strong><span class="koboSpan" id="kobo.184.1"> – to fetch the value of the two features that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.186.1"> class is responsible </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">for computing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
    auto getMktPrice() const noexcept {
      return mkt_price_;
    }
    auto getAggTradeQtyRatio() const noexcept {
      return agg_trade_qty_ratio_;
    }</span></pre>
<p><span class="koboSpan" id="kobo.189.1">In the next two subsections, we will see how this component handles order book updates and trade events and updates the </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">feature values.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.191.1">Computing the feature on order book changes</span></h2>
<p><span class="koboSpan" id="kobo.192.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.194.1"> class expects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.196.1"> method to be called when there is an update to the order book. </span><span class="koboSpan" id="kobo.196.2">First, it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">MarketOrderBook::getBBO()</span></strong><span class="koboSpan" id="kobo.198.1"> to extract the BBO. </span><span class="koboSpan" id="kobo.198.2">As a</span><a id="_idIndexMarker1245"/><span class="koboSpan" id="kobo.199.1"> reminder, </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">BBO</span></strong><span class="koboSpan" id="kobo.201.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Best Bid Offer</span></strong><span class="koboSpan" id="kobo.203.1"> and</span><a id="_idIndexMarker1246"/><span class="koboSpan" id="kobo.204.1"> is a summary view that represents the best bid and offer prices and quantities. </span><span class="koboSpan" id="kobo.204.2">It proceeds to check that the bid and ask prices are valid and then computes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">mkt_price_</span></strong><span class="koboSpan" id="kobo.206.1"> value if they are valid. </span><span class="koboSpan" id="kobo.206.2">The fair market price is formulated as the book quantity weighted price, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">(bid_price * ask_qty + ask_price * bid_qty) / (bid_qty + ask_qty)</span></strong><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">Note that this is just a single formulation for a fair market price; the important thing to remember with feature engineering is that there is no single correct formulation. </span><span class="koboSpan" id="kobo.208.3">You are encouraged to formulate a version of a fair market price or any other feature value you want to use in the future. </span><span class="koboSpan" id="kobo.208.4">The formulation we are using here tries to move the fair market price closer to the offer if there are more buy orders than sell orders </span><a id="_idIndexMarker1247"/><span class="koboSpan" id="kobo.209.1">and moves it closer to the bid if there are more sell orders than </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">buy orders:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, MarketOrderBook* book) noexcept -&gt; void {
      const auto bbo = book-&gt;getBBO();
      if(LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-
        &gt;ask_price_ != Price_INVALID)) {
        mkt_price_ = (bbo-&gt;bid_price_ * bbo-&gt;ask_qty_ +
          bbo-&gt;ask_price_ * bbo-&gt;bid_qty_) /
            static_cast&lt;double&gt;(bbo-&gt;bid_qty_ + bbo-&gt;
              ask_qty_);
      }
      logger_-&gt;log("%:% %() % ticker:% price:% side:% mkt-
        price:% agg-trade-ratio:%\n", __FILE__, __LINE__,
          __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                     ticker_id, Common::priceToString
                       (price).c_str(),
                   Common::sideToString(side).c_str(),
                     mkt_price_, agg_trade_qty_ratio_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.212.1">The next subsection will compute the other feature, which we will refer to as the Aggressive Trade Quantity Ratio, for computing the trade quantity as a fraction of the book price </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">level quantity.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.214.1">Computing the feature on trade events</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.216.1"> expects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.218.1"> method to be called when there is a trade</span><a id="_idIndexMarker1248"/><span class="koboSpan" id="kobo.219.1"> event in the market data stream. </span><span class="koboSpan" id="kobo.219.2">As we saw previously, it fetches the BBO and checks if the prices are valid and then computes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">agg_trade_qty_ratio_</span></strong><span class="koboSpan" id="kobo.221.1"> feature to be a ratio of the trade quantity and the quantity of the BBO that the trade aggresses on. </span><span class="koboSpan" id="kobo.221.2">As we mentioned with the previous feature, there is no single correct formulation of a feature – this is just the formulation we are using for now; hopefully, you will add your own formulations in the future. </span><span class="koboSpan" id="kobo.221.3">This formulation tries to measure how big a trade aggressor was compared to how much liquidity was available on the BBO side the aggressor trades against. </span><span class="koboSpan" id="kobo.221.4">We are simply </span><a id="_idIndexMarker1249"/><span class="koboSpan" id="kobo.222.1">trying to quantify the trade pressure with this feature that we are computing. </span><span class="koboSpan" id="kobo.222.2">As we mentioned previously, there are many other </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">possible formulations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook* book) noexcept -&gt; void {
      const auto bbo = book-&gt;getBBO();
      if(LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-&gt;
        ask_price_ != Price_INVALID)) {
        agg_trade_qty_ratio_ = static_cast&lt;double&gt;
          (market_update-&gt;qty_) / (market_update-&gt;side_ ==
            Side::BUY ? </span><span class="koboSpan" id="kobo.224.2">bbo-&gt;ask_qty_ : bbo-&gt;bid_qty_);
      }
      logger_-&gt;log("%:% %() % % mkt-price:% agg-trade-ratio
        :%\n", __FILE__, __LINE__, __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                   market_update-&gt;toString().c_str(),
                     mkt_price_, agg_trade_qty_ratio_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.225.1">That is the entire implementation of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.227.1"> for this book. </span><span class="koboSpan" id="kobo.227.2">In the next section, we will learn how to handle executions and use that to update positions </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">and PnLs.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.229.1">Using executions to update positions and PnLs</span></h1>
<p><span class="koboSpan" id="kobo.230.1">Now, we</span><a id="_idIndexMarker1250"/><span class="koboSpan" id="kobo.231.1"> will build a </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.233.1"> class that will be responsible for processing executions on a strategy’s orders and computing and tracking positions and PnLs. </span><span class="koboSpan" id="kobo.233.2">This component is used by the strategy as well as the risk manager to compute positions and PnLs for different purposes. </span><span class="koboSpan" id="kobo.233.3">All the source code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.235.1"> class is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Chapter9/trading/strategy/position_keeper.h</span></strong><span class="koboSpan" id="kobo.237.1"> file on GitHub. </span><span class="koboSpan" id="kobo.237.2">Before we build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.239.1"> class, which manages positions for all trading instruments, we will need to build a </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.241.1"> struct, which is also present in the same source file. </span><span class="koboSpan" id="kobo.241.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.243.1"> struct is the lower-level struct for managing the positions and PnLs for a single trading instrument; we will cover it in more detail in the next few subsections. </span><span class="koboSpan" id="kobo.243.2">We discussed the details of this component in </span><em class="italic"><span class="koboSpan" id="kobo.244.1">Chapter</span></em><span class="koboSpan" id="kobo.245.1">, </span><em class="italic"><span class="koboSpan" id="kobo.246.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.247.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.248.1">Designing a framework for low-latency C++ trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.249.1">algorithms</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1"> section.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.251.1">Declaring the data members in PositionInfo</span></h2>
<p><span class="koboSpan" id="kobo.252.1">First, we </span><a id="_idIndexMarker1251"/><span class="koboSpan" id="kobo.253.1">must specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">include</span></strong><span class="koboSpan" id="kobo.255.1"> files that will be needed for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">position_keeper.h</span></strong><span class="koboSpan" id="kobo.257.1"> file, as </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
#pragma once
#include "common/macros.h"
#include "common/types.h"
#include "common/logging.h"
#include "exchange/order_server/client_response.h"
#include "market_order_book.h"
using namespace Common;</span></pre>
<p><span class="koboSpan" id="kobo.260.1">The data members inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.262.1"> struct are presented in the source code. </span><span class="koboSpan" id="kobo.262.2">The important</span><a id="_idIndexMarker1252"/><span class="koboSpan" id="kobo.263.1"> data members are </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.265.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">position_</span></strong><span class="koboSpan" id="kobo.267.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">int32_t</span></strong><span class="koboSpan" id="kobo.269.1"> type to represent the current position. </span><span class="koboSpan" id="kobo.269.2">This can be positive, negative, </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">or 0.</span></span></li>
<li><span class="koboSpan" id="kobo.271.1">Three </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">double</span></strong><span class="koboSpan" id="kobo.273.1"> values – </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">real_pnl_</span></strong><span class="koboSpan" id="kobo.275.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">unreal_pnl_</span></strong><span class="koboSpan" id="kobo.277.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">total_pnl_</span></strong><span class="koboSpan" id="kobo.279.1"> – to track the realized or closed PnL for positions that have been closed (</span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">real_pnl_</span></strong><span class="koboSpan" id="kobo.281.1">), the unrealized or open PnL for the currently open position (</span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">unreal_pnl_</span></strong><span class="koboSpan" id="kobo.283.1">), and the total PnL, which is a summation of the two values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">total_pnl_</span></strong><span class="koboSpan" id="kobo.285.1">), respectively. </span><span class="koboSpan" id="kobo.285.2">The realized PnL only changes when additional order executions occur; the unrealized PnL can change even without order executions if there is a non-zero position and market </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">prices change.</span></span></li>
<li><span class="koboSpan" id="kobo.287.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">std::array</span></strong><span class="koboSpan" id="kobo.289.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">double</span></strong><span class="koboSpan" id="kobo.291.1"> of a size large enough to accommodate entries for the buy side and sell side. </span><span class="koboSpan" id="kobo.291.2">This array will be indexed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">sideToIndex(Side::BUY)</span></strong><span class="koboSpan" id="kobo.293.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">sideToIndex(Side::SELL)</span></strong><span class="koboSpan" id="kobo.295.1"> values. </span><span class="koboSpan" id="kobo.295.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">open_vwap_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.297.1">std::array</span></strong><span class="koboSpan" id="kobo.298.1"> variable tracks the product of price and execution quantity on each side when there is an open long (positive) or short (negative) position. </span><span class="koboSpan" id="kobo.298.2">We will need this to compute the unrealized PnL by comparing </span><a id="_idIndexMarker1253"/><span class="koboSpan" id="kobo.299.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">volume-weighted average price</span></strong><span class="koboSpan" id="kobo.301.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.302.1">VWAP</span></strong><span class="koboSpan" id="kobo.303.1">) of the open long or short position against the current </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">market price.</span></span></li>
<li><span class="koboSpan" id="kobo.305.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">volume_</span></strong><span class="koboSpan" id="kobo.307.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Qty</span></strong><span class="koboSpan" id="kobo.309.1"> type to track the total quantity that has </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">been executed.</span></span></li>
<li><span class="koboSpan" id="kobo.311.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">const</span></strong><span class="koboSpan" id="kobo.313.1"> pointer variable to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">BBO</span></strong><span class="koboSpan" id="kobo.315.1"> object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">bbo_</span></strong><span class="koboSpan" id="kobo.317.1">, which will be used on market updates to fetch the updated </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">top-of-book prices:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.319.1">
namespace Trading {
  struct PositionInfo {
    int32_t position_ = 0;
    double real_pnl_ = 0, unreal_pnl_ = 0, total_pnl_ = 0;
    std::array&lt;double, sideToIndex(Side::MAX) + 1&gt;
      open_vwap_;
    Qty volume_ = 0;
    const BBO *bbo_ = nullptr;</span></pre>
<p><span class="koboSpan" id="kobo.320.1">We will also</span><a id="_idIndexMarker1254"/><span class="koboSpan" id="kobo.321.1"> add a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">toString()</span></strong><span class="koboSpan" id="kobo.323.1"> method to this struct to </span><em class="italic"><span class="koboSpan" id="kobo.324.1">stringify</span></em><span class="koboSpan" id="kobo.325.1"> instances of </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">this structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
    auto toString() const {
       std::stringstream ss;
       ss &lt;&lt; "Position{"
          &lt;&lt; "pos:" &lt;&lt; position_
          &lt;&lt; " u-pnl:" &lt;&lt; unreal_pnl_
          &lt;&lt; " r-pnl:" &lt;&lt; real_pnl_
          &lt;&lt; " t-pnl:" &lt;&lt; total_pnl_
          &lt;&lt; " vol:" &lt;&lt; qtyToString(volume_)
          &lt;&lt; " vwaps:[" &lt;&lt; (position_ ? </span><span class="koboSpan" id="kobo.327.2">open_vwap_
            .at(sideToIndex(Side::BUY)) / std::abs
              (position_) : 0)
          &lt;&lt; "X" &lt;&lt; (position_ ? </span><span class="koboSpan" id="kobo.327.3">open_vwap_
            .at(sideToIndex(Side::SELL)) / std::abs
               (position_) : 0)
         &lt;&lt; "] "
         &lt;&lt; (bbo_ ? </span><span class="koboSpan" id="kobo.327.4">bbo_-&gt;toString() : "") &lt;&lt; "}";
       return ss.str();
    }</span></pre>
<p><span class="koboSpan" id="kobo.328.1">Next, we need to process order executions and update the positions and PnLs based on </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">those executions.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.330.1">Handling order executions in PositionInfo</span></h2>
<p><span class="koboSpan" id="kobo.331.1">When a</span><a id="_idIndexMarker1255"/><span class="koboSpan" id="kobo.332.1"> trading strategy’s orders are executed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.334.1"> needs to update the positions and PnLs that have been tracked for the trading instrument of the execution. </span><span class="koboSpan" id="kobo.334.2">It does this by providing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.336.1"> message corresponding to order executions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">PositionInfo::addFIll()</span></strong><span class="koboSpan" id="kobo.338.1"> method. </span><span class="koboSpan" id="kobo.338.2">We will build this in </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">this subsection.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">Before we look at the source code for our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">PositionInfo::addFill()</span></strong><span class="koboSpan" id="kobo.342.1"> method, we will look at an example of how the algorithm to update the realized and unrealized PnLs works. </span><span class="koboSpan" id="kobo.342.2">This will help you easily understand the source code for the implementation. </span><span class="koboSpan" id="kobo.342.3">We will track the evolution of the different variables as we work our way through a few hypothetical executions for a hypothetical trading instrument. </span><span class="koboSpan" id="kobo.342.4">We will display the following variables as columns in </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">our</span></span><span class="No-Break"><a id="_idIndexMarker1256"/></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1"> tables:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.345.1">position – old</span></strong><span class="koboSpan" id="kobo.346.1">: This is the position before the current execution message </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">is processed</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.348.1">position – new</span></strong><span class="koboSpan" id="kobo.349.1">: This will be the new position after processing the current </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">execution message</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.351.1">open_vwap – BUY</span></strong><span class="koboSpan" id="kobo.352.1">: This is the sum of the products of execution price and execution quantity for buy </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">executions only</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.354.1">open_vwap – SELL</span></strong><span class="koboSpan" id="kobo.355.1">: This is the sum of the products of execution price and execution quantity for sell </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">executions only</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.357.1">VWAP – BUY</span></strong><span class="koboSpan" id="kobo.358.1">: This is the actual VWAP of the current long/positive position, represented in units of price and not price </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">x quantity</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.360.1">VWAP – SELL</span></strong><span class="koboSpan" id="kobo.361.1">: This is the actual VWAP of the current short/negative position, represented in units of price and not price </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">x quantity</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.363.1">PnL – real</span></strong><span class="koboSpan" id="kobo.364.1">: This is the realized PnL after processing </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">this execution</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.366.1">PnL – unreal</span></strong><span class="koboSpan" id="kobo.367.1">: This is the unrealized PnL for the open position after processing </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">this execution</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.369.1">Assuming we get an execution for buying 10 at 100.0, we must update </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">open_vwap</span></strong><span class="koboSpan" id="kobo.371.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">VWAP</span></strong><span class="koboSpan" id="kobo.373.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">BUY</span></strong><span class="koboSpan" id="kobo.375.1"> side, and the new position, as shown here. </span><span class="koboSpan" id="kobo.375.2">No changes need to be made to the unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">PnL yet:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.377.1">position</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.378.1">open_vwap</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.379.1">VWAP</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.380.1">PnL</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.381.1">Old</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.382.1">new</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.383.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.384.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.385.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.386.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.387.1">real</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.388.1">unreal</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.389.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.390.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.391.1">1000.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.392.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.393.1">100.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.394.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.395.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.396.1">0.0</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.397.1">Assuming </span><a id="_idIndexMarker1257"/><span class="koboSpan" id="kobo.398.1">we get another execution for buying 10 at 90.0, our old position was 10 and the new position will be 20. </span><span class="koboSpan" id="kobo.398.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">open_vwap</span></strong><span class="koboSpan" id="kobo.400.1"> property for </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">BUY</span></strong><span class="koboSpan" id="kobo.402.1"> now gets 10 * 90 added to the previous 1,000 and becomes 1,900. </span><span class="koboSpan" id="kobo.402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">VWAP</span></strong><span class="koboSpan" id="kobo.404.1"> column for the open long/positive position is 95, which can be computed by dividing 1,900 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">BUY</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.406.1">open_vwap</span></strong><span class="koboSpan" id="kobo.407.1">) by 20 (new position). </span><span class="koboSpan" id="kobo.407.2">We compute the unreal PnL by using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">VWAP</span></strong><span class="koboSpan" id="kobo.409.1"> of 95 and the latest execution price of 90 and multiplying the difference of -5 by the position of 20 to get -100. </span><span class="koboSpan" id="kobo.409.2">We have a negative unrealized PnL because our long/positive position’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">VWAP</span></strong><span class="koboSpan" id="kobo.411.1"> is higher than current market prices (represented by the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">execution price):</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.413.1">position</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.414.1">open_vwap</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.415.1">VWAP</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.416.1">PnL</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.417.1">old</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.418.1">new</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.419.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.420.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.421.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.422.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.423.1">real</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.424.1">unreal</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.425.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.426.1">20</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.427.1">1900.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.428.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.429.1">95.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.430.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.431.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.432.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">100.0</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.434.1">Now, let’s assume we get a sell execution for selling 10 at 92. </span><span class="koboSpan" id="kobo.434.2">Our old position of 20 will be reduced to 10. </span><span class="koboSpan" id="kobo.434.3">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">open_vwap</span></strong><span class="koboSpan" id="kobo.436.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">VWAP</span></strong><span class="koboSpan" id="kobo.438.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">BUY</span></strong><span class="koboSpan" id="kobo.440.1"> side do not change since this was a sell execution. </span><span class="koboSpan" id="kobo.440.2">Since we closed 10 out of our long/positive 20 positions, we will have some realized PnL and the remaining 10 long/positive positions will have some unrealized PnL based on the execution price of this latest execution. </span><span class="koboSpan" id="kobo.440.3">The realized PnL is computed using the sell execution price of 92, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">VWAP</span></strong><span class="koboSpan" id="kobo.442.1"> property of the long/positive position, which is 95, and the execution quantity of 10 to yield a realized PnL of (92 - 95) * 10 = -30. </span><span class="koboSpan" id="kobo.442.2">In this case, the unrealized PnL is also the same since there is a long/positive 10 </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">position left:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.444.1">position</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.445.1">open_vwap</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.446.1">VWAP</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.447.1">PnL</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.448.1">Old</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.449.1">new</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.450.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.451.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.452.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.453.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">real</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.455.1">unreal</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.456.1">20</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.457.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.458.1">1900.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.459.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.460.1">95.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.461.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.462.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">30.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.464.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">30.0</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.466.1">Now, let’s</span><a id="_idIndexMarker1258"/><span class="koboSpan" id="kobo.467.1"> assume we receive another sell execution for selling 20 at 97. </span><span class="koboSpan" id="kobo.467.2">This will cause our position to flip from 10 to –10 (note that we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">open_vwap</span></strong><span class="koboSpan" id="kobo.469.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">VWAP</span></strong><span class="koboSpan" id="kobo.471.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">BUY</span></strong><span class="koboSpan" id="kobo.473.1"> side to 0). </span><span class="koboSpan" id="kobo.473.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">open_vwap</span></strong><span class="koboSpan" id="kobo.475.1"> property for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">SELL</span></strong><span class="koboSpan" id="kobo.477.1"> side becomes 970 because of the -10 position and the execution price of 97. </span><span class="koboSpan" id="kobo.477.2">We close the previous position of 10, which had a </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">VWAP</span></strong><span class="koboSpan" id="kobo.479.1"> of 95 with this sell at 97. </span><span class="koboSpan" id="kobo.479.2">Since we sold higher than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">VWAP</span></strong><span class="koboSpan" id="kobo.481.1"> property of our long/positive position, we make a profit of (97 - 95) * 10 = 20, which when added to the previous realized PnL of -30, yields the final </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">realized</span></strong><span class="koboSpan" id="kobo.483.1"> PnL of -10. </span><span class="koboSpan" id="kobo.483.2">The unrealized PnL here is 0 since a </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">VWAP</span></strong><span class="koboSpan" id="kobo.485.1"> of 97 is the same as the current execution price </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">of 97:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table004-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.487.1">position</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.488.1">open_vwap</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.489.1">VWAP</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.490.1">PnL</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.491.1">Old</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.492.1">new</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.493.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.494.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.495.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.496.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.497.1">real</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.498.1">unreal</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.499.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.500.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.502.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.503.1">970.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.504.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.505.1">97.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.506.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">10.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.508.1">0.0</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.509.1">Let’s assume that we get another sell execution of selling 20 and 94. </span><span class="koboSpan" id="kobo.509.2">Here, the short/negative position increases from -10 to -30. </span><span class="koboSpan" id="kobo.509.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">open_vwap</span></strong><span class="koboSpan" id="kobo.511.1"> property on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">SELL</span></strong><span class="koboSpan" id="kobo.513.1"> side is updated by adding (20 * 94) to the previous value of 970 to yield 2,850. </span><span class="koboSpan" id="kobo.513.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">VWAP</span></strong><span class="koboSpan" id="kobo.515.1"> property of our short position is updated to 95 by dividing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">open_vwap</span></strong><span class="koboSpan" id="kobo.517.1"> property of 2,850 by the position of 30 to yield 95. </span><span class="koboSpan" id="kobo.517.2">The realized PnL does not change since the position was increased and nothing was reduced or closed. </span><span class="koboSpan" id="kobo.517.3">The unreal PnL uses the execution price of 94 on this new execution, compares it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">VWAP</span></strong><span class="koboSpan" id="kobo.519.1"> property of 95, and uses the new position of -30 to yield (95 - 94) * 30 = </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">30:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table005-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.521.1">position</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.522.1">open_vwap</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.523.1">VWAP</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.524.1">PnL</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.525.1">Old</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.526.1">new</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.527.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.528.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.529.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.530.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.531.1">real</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.532.1">unreal</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.533.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.535.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">30</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.537.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.538.1">2850.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.539.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.540.1">95.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.541.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">10.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.543.1">30.0</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.544.1">Let’s assume</span><a id="_idIndexMarker1259"/><span class="koboSpan" id="kobo.545.1"> that there is yet another sell execution of selling 10 at 90. </span><span class="koboSpan" id="kobo.545.2">The short/negative position increases from -30 to -40. </span><span class="koboSpan" id="kobo.545.3">We add the new execution’s price and quantity product (10 * 90) to the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">open_vwap</span></strong><span class="koboSpan" id="kobo.547.1"> property’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">SELL</span></strong><span class="koboSpan" id="kobo.549.1"> of 2,850 to yield 3,750. </span><span class="koboSpan" id="kobo.549.2">The actual </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">VWAP</span></strong><span class="koboSpan" id="kobo.551.1"> of the short position changes from 95 to 93.75 and was obtained by dividing this 3,750 value by the new position of 40. </span><span class="koboSpan" id="kobo.551.2">The realized PnL does not change since the position was increased, but the unrealized PnL is updated using (93.75 - 90) * 40 = </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">150:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table006-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.553.1">position</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.554.1">open_vwap</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.555.1">VWAP</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.556.1">PnL</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.557.1">Old</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.558.1">new</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.559.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.560.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.561.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.562.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.563.1">real</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.564.1">unreal</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.565.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">30</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.567.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">40</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.569.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.570.1">3750.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.571.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.572.1">93.75</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.573.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">10.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.575.1">150.0</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.576.1">Finally, let’s assume that we receive a buy execution for buying 40 at 88. </span><span class="koboSpan" id="kobo.576.2">This execution will flatten our short/negative position of -40, so the new position will be 0. </span><span class="koboSpan" id="kobo.576.3">The unrealized PnL will be 0 and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">open_vwap</span></strong><span class="koboSpan" id="kobo.578.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">VWAP</span></strong><span class="koboSpan" id="kobo.580.1"> properties will be 0 for both sides since there is no open position anymore. </span><span class="koboSpan" id="kobo.580.2">The realized PnL is updated using the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">VWAP</span></strong><span class="koboSpan" id="kobo.582.1"> property, the execution price, and the position of 40, so (93.75 - 88) * 40 = 230. </span><span class="koboSpan" id="kobo.582.2">This is added to the previously realized PnL of –10 to yield the final realized PnL </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">of 220:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table007-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.584.1">position</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.585.1">open_vwap</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.586.1">VWAP</span></strong></span></p>
</td>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.587.1">PnL</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.588.1">Old</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.589.1">new</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.590.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.591.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.592.1">BUY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.593.1">SELL</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.594.1">real</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.595.1">unreal</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.596.1">-</span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">40</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.598.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.599.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.600.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.601.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.602.1">0.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.603.1">220.0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.604.1">0.0</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.605.1">Now, we can </span><a id="_idIndexMarker1260"/><span class="koboSpan" id="kobo.606.1">move on and discuss the implementation details of </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">this algorithm.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">The first thing we must do is initialize a few local variables. </span><span class="koboSpan" id="kobo.608.2">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">old_position</span></strong><span class="koboSpan" id="kobo.610.1"> variable saves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">current position_</span></strong><span class="koboSpan" id="kobo.612.1"> value before updating it. </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">side_index</span></strong><span class="koboSpan" id="kobo.614.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">opp_side_index</span></strong><span class="koboSpan" id="kobo.616.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">sideToIndex()</span></strong><span class="koboSpan" id="kobo.618.1"> method to find the indices in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.620.1"> array that correspond to the side of the execution and the side opposite to the side of execution, respectively. </span><span class="koboSpan" id="kobo.620.2">We must also initialize a </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">side_value</span></strong><span class="koboSpan" id="kobo.622.1"> variable, which will be +1 for a buy execution and -1 for a </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">sell execution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
    auto addFill(const Exchange::MEClientResponse
      *client_response, Logger *logger) noexcept {
      const auto old_position = position_;
      const auto side_index = sideToIndex(client_response-&gt;
        side_);
      const auto opp_side_index = sideToIndex
        (client_response-&gt;side_ == Side::BUY ? </span><span class="koboSpan" id="kobo.624.2">Side::SELL :
          Side::BUY);
      const auto side_value = sideToValue(client_response-&gt;
        side_);</span></pre>
<p><span class="koboSpan" id="kobo.625.1">Now, we must update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">position_</span></strong><span class="koboSpan" id="kobo.627.1"> variable using the quantity executed (</span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">exec_qty_</span></strong><span class="koboSpan" id="kobo.629.1">) in this response and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">side_value</span></strong><span class="koboSpan" id="kobo.631.1"> variable we initialized. </span><span class="koboSpan" id="kobo.631.2">We must also update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">volume_</span></strong><span class="koboSpan" id="kobo.633.1"> member by adding the new execution quantity to it. </span><span class="koboSpan" id="kobo.633.2">When we receive an execution on a buy order, our position increases; conversely, when we receive an execution on a sell order, our position decreases. </span><span class="koboSpan" id="kobo.633.3">When our position is positive, also known as a </span><em class="italic"><span class="koboSpan" id="kobo.634.1">long position</span></em><span class="koboSpan" id="kobo.635.1">, we profit when prices increase and make a loss when prices decrease. </span><span class="koboSpan" id="kobo.635.2">When our position is negative, also known as a </span><em class="italic"><span class="koboSpan" id="kobo.636.1">short position</span></em><span class="koboSpan" id="kobo.637.1">, we profit when prices decrease and make a loss when </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">prices increase:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.639.1">
      position_ += client_response-&gt;exec_qty_ * side_value;
      volume_ += client_response-&gt;exec_qty_;</span></pre>
<p><span class="koboSpan" id="kobo.640.1">The next important step for us is to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.642.1"> entry’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">std::array</span></strong><span class="koboSpan" id="kobo.644.1"> variable. </span><span class="koboSpan" id="kobo.644.2">We will check if we were flat (position 0) before this execution and open a new position with this execution or if we already had an open position and we got an execution that increases that position. </span><span class="koboSpan" id="kobo.644.3">In this case, we will simply update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.646.1"> variable using </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">side_index</span></strong><span class="koboSpan" id="kobo.648.1"> to index the correct side. </span><span class="koboSpan" id="kobo.648.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.650.1"> tracks the product of execution prices and executed quantities at those prices, we can simply</span><a id="_idIndexMarker1261"/><span class="koboSpan" id="kobo.651.1"> multiply </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">price_</span></strong><span class="koboSpan" id="kobo.653.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">exec_qty_</span></strong><span class="koboSpan" id="kobo.655.1"> on this execution and add it to the existing sum, as </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
      if (old_position * sideToValue(client_response-&gt;
        side_) &gt;= 0) { // opened / increased position.
</span><span class="koboSpan" id="kobo.657.2">        open_vwap_[side_index] += (client_response-&gt;price_
          * client_response-&gt;exec_qty_);
      }</span></pre>
<p><span class="koboSpan" id="kobo.658.1">Now, we need to handle the case where we had a pre-existing open position. </span><span class="koboSpan" id="kobo.658.2">This most recent execution reduces or flattens the position. </span><span class="koboSpan" id="kobo.658.3">In this case, we will need to update the realized PnL (</span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">real_pnl_</span></strong><span class="koboSpan" id="kobo.660.1">) using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.662.1"> entry for the side opposite to the side of execution. </span><span class="koboSpan" id="kobo.662.2">One thing to understand is that the realized PnL is only updated when an open position is reduced or closed because, in this case, we have bought and sold a certain quantity. </span><span class="koboSpan" id="kobo.662.3">Another way to think about this is that we can match some of the buy quantity with some of the sell quantity and create a pair of buy and sell trades. </span><span class="koboSpan" id="kobo.662.4">In this case, we have closed at least part of our position. </span><span class="koboSpan" id="kobo.662.5">In the previous case, where we either opened a new position or increased an already open position, we did not have a pair of buy and sell trades to match up, so we did not need to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">realized PnL.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">First, we</span><a id="_idIndexMarker1262"/><span class="koboSpan" id="kobo.665.1"> will compute an </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">opp_side_vwap</span></strong><span class="koboSpan" id="kobo.667.1"> value, which is the average price of all the executions on the other side, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.669.1"> entry for </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">opp_side_index</span></strong><span class="koboSpan" id="kobo.671.1"> and normalize it using the absolute value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">old_position</span></strong><span class="koboSpan" id="kobo.673.1"> before this execution. </span><span class="koboSpan" id="kobo.673.2">Remember that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.675.1"> variable is named poorly; it tracks the product of execution price and quantity, not just the price, so dividing it by the quantity represented by </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">old_position</span></strong><span class="koboSpan" id="kobo.677.1"> yields the actual VWAP. </span><span class="koboSpan" id="kobo.677.2">Then, we will update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.679.1"> entry for </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">opp_side_index</span></strong><span class="koboSpan" id="kobo.681.1"> using the product of the VWAP we computed in </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">opp_side_vwap</span></strong><span class="koboSpan" id="kobo.683.1"> and the absolute value of the new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">position_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.685.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">We can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">real_pnl_</span></strong><span class="koboSpan" id="kobo.688.1"> value by finding the minimum quantity value of the execution quantity (</span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">exec_qty_</span></strong><span class="koboSpan" id="kobo.690.1">) and the absolute value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">old_position</span></strong><span class="koboSpan" id="kobo.692.1">. </span><span class="koboSpan" id="kobo.692.2">We must multiply that by the difference between the current execution message’s price (</span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">price_</span></strong><span class="koboSpan" id="kobo.694.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">opp_side_vwap</span></strong><span class="koboSpan" id="kobo.696.1">. </span><span class="koboSpan" id="kobo.696.2">Finally, we need to multiply this product by </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">opp_side_value</span></strong><span class="koboSpan" id="kobo.698.1"> to account for whether a profit was made (bought at a lower price than the sell VWAP or sold at a higher price than the buy VWAP) or a loss was made (bought at a higher price than the sell VWAP or sold at a lower price than the </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">buy VWAP):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
        else { // decreased position.
</span><span class="koboSpan" id="kobo.700.2">        const auto opp_side_vwap = open_vwap_
          [opp_side_index] / std::abs(old_position);
        open_vwap_[opp_side_index] = opp_side_vwap * std::
          abs(position_);
        real_pnl_ += std::min
          (static_cast&lt;int32_t&gt;(client_response-&gt;
            exec_qty_), std::abs(old_position)) *
                     (opp_side_vwap - client_response-&gt;
                        price_) * sideToValue
                          (client_response-&gt;side_);</span></pre>
<p><span class="koboSpan" id="kobo.701.1">We need to</span><a id="_idIndexMarker1263"/><span class="koboSpan" id="kobo.702.1"> handle an edge case if this execution causes the position to flip, meaning it goes from a long position to a short position or vice versa. </span><span class="koboSpan" id="kobo.702.2">This position flip can happen, for instance, when we have a long/positive position of a certain amount and we receive a sell execution of a quantity larger than that position. </span><span class="koboSpan" id="kobo.702.3">Conversely, this can happen if we have a short/negative position of a certain amount and we receive a buy execution of a quantity larger than that position. </span><span class="koboSpan" id="kobo.702.4">In each of these cases, we go from having a positive/long position to a negative/short position or go from having a negative/short position to a positive/long position. </span><span class="koboSpan" id="kobo.702.5">In this case, we can simply reset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.704.1"> value corresponding to the opposite side to 0 and reset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.706.1"> value for the side of execution (and thus the side of the new position) so that it’s the product of the latest execution price and the absolute value of our </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">current </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">position_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
        if (position_ * old_position &lt; 0) { // flipped
          position to opposite sign.
</span><span class="koboSpan" id="kobo.710.2">          open_vwap_[side_index] = (client_response-&gt;price_
            * std::abs(position_));
          open_vwap_[opp_side_index] = 0;
        }
      }</span></pre>
<p><span class="koboSpan" id="kobo.711.1">Finally, we will wrap up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">PositionInfo::addFill()</span></strong><span class="koboSpan" id="kobo.713.1"> method by updating the unrealized PnL (</span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">unreal_pnl_</span></strong><span class="koboSpan" id="kobo.715.1">) value. </span><span class="koboSpan" id="kobo.715.2">The case where we are now flat (</span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">position_ == 0</span></strong><span class="koboSpan" id="kobo.717.1">) is straightforward – we reset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.719.1"> variable for both sides and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">unreal_pnl_</span></strong><span class="koboSpan" id="kobo.721.1"> to 0 since no open position implies </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">no </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">unreal_pnl_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.725.1">
      if (!position_) { // flat
        open_vwap_[sideToIndex(Side::BUY)] = open_vwap_
          [sideToIndex(Side::SELL)] = 0;
        unreal_pnl_ = 0;
      }</span></pre>
<p><span class="koboSpan" id="kobo.726.1">If we still </span><a id="_idIndexMarker1264"/><span class="koboSpan" id="kobo.727.1">have an open </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">position_</span></strong><span class="koboSpan" id="kobo.729.1"> after this execution, then we can compute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">unreal_pnl_</span></strong><span class="koboSpan" id="kobo.731.1"> value that was obtained by multiplying the absolute value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">position_</span></strong><span class="koboSpan" id="kobo.733.1"> with the difference between the execution price from the current execution and the VWAP computed from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">open_vwap_</span></strong><span class="koboSpan" id="kobo.735.1"> entry for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">position_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1"> side:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.738.1">
        else {
        if (position_ &gt; 0)
          unreal_pnl_ =
              (client_response-&gt;price_ - open_vwap_
                [sideToIndex(Side::BUY)] / std::abs
                  (position_)) *
              std::abs(position_);
        else
          unreal_pnl_ =
              (open_vwap_[sideToIndex(Side::SELL)] / std::
                abs(position_) - client_response-&gt;price_) *
              std::abs(position_);
      }</span></pre>
<p><span class="koboSpan" id="kobo.739.1">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">total_pnl_</span></strong><span class="koboSpan" id="kobo.741.1"> is just the summation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">real_pnl_</span></strong><span class="koboSpan" id="kobo.743.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">unreal_pnl_</span></strong><span class="koboSpan" id="kobo.745.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">explained previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.747.1">
      total_pnl_ = unreal_pnl_ + real_pnl_;
      std::string time_str;
      logger-&gt;log("%:% %() % % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str),
                  toString(), client_response-&gt;
                    toString().c_str());
    }</span></pre>
<p><span class="koboSpan" id="kobo.748.1">The final </span><a id="_idIndexMarker1265"/><span class="koboSpan" id="kobo.749.1">piece of functionality we need to add to </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.751.1"> is for handling changes in market prices and updating the unrealized PnL for any open position. </span><span class="koboSpan" id="kobo.751.2">We will investigate this functionality in the </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">next subsection.</span></span></p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.753.1">Handling order book changes in PositionInfo</span></h2>
<p><span class="koboSpan" id="kobo.754.1">When</span><a id="_idIndexMarker1266"/><span class="koboSpan" id="kobo.755.1"> there are market updates that cause changes in the order book we build, we need to update the unrealized and total PnL values. </span><span class="koboSpan" id="kobo.755.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">PositionInfo::updateBBO()</span></strong><span class="koboSpan" id="kobo.757.1"> method is called by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.759.1"> class for the trading instrument, which receives a market update. </span><span class="koboSpan" id="kobo.759.2">This, in turn, leads to an order book change. </span><span class="koboSpan" id="kobo.759.3">We provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">BBO</span></strong><span class="koboSpan" id="kobo.761.1"> object that corresponds to the trading instrument that was updated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">updateBBO()</span></strong><span class="koboSpan" id="kobo.763.1"> method. </span><span class="koboSpan" id="kobo.763.2">We save the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">bbo</span></strong><span class="koboSpan" id="kobo.765.1"> argument provided in this method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">bbo_</span></strong><span class="koboSpan" id="kobo.767.1"> data member in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.769.1"> struct. </span><span class="koboSpan" id="kobo.769.2">This method only has anything to do if </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">position_</span></strong><span class="koboSpan" id="kobo.771.1"> is non-zero and the bid and ask price values on the BBO provided are valid. </span><span class="koboSpan" id="kobo.771.2">This is the first thing we will </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">check for:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.773.1">
    auto updateBBO(const BBO *bbo, Logger *logger) noexcept {
      std::string time_str;
      bbo_ = bbo;
      if (position_ &amp;&amp; bbo-&gt;bid_price_ != Price_INVALID &amp;&amp;
        bbo-&gt;ask_price_ != Price_INVALID) {</span></pre>
<p><span class="koboSpan" id="kobo.774.1">If we need to update the unrealized PnL, we can use the mid-price of the BBO prices, which we can compute and save in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">mid_price</span></strong><span class="koboSpan" id="kobo.776.1"> variable, as </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.778.1">
        const auto mid_price = (bbo-&gt;bid_price_ + bbo-&gt;
          ask_price_) * 0.5;</span></pre>
<p><span class="koboSpan" id="kobo.779.1">After that, we can update </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">unreal_pnl_</span></strong><span class="koboSpan" id="kobo.781.1"> using the same logic that we saw in the previous subsection, except that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">mid_price</span></strong><span class="koboSpan" id="kobo.783.1"> value instead of an execution price. </span><span class="koboSpan" id="kobo.783.2">Let’s explain why we update the unrealized PnL even though we do not have additional executions. </span><span class="koboSpan" id="kobo.783.3">Let’s say we have a long position from an execution at a hypothetical price of 100. </span><span class="koboSpan" id="kobo.783.4">At this point, the initial unrealized PnL is 0. </span><span class="koboSpan" id="kobo.783.5">Let’s also assume that, in the future, the market prices (represented by our </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">mid_price</span></strong><span class="koboSpan" id="kobo.785.1"> variable) go up to 110. </span><span class="koboSpan" id="kobo.785.2">In that case, our realized PnL has not changed because we have not executed any sell orders. </span><span class="koboSpan" id="kobo.785.3">However, our unrealized PnL increases because if we decide to liquidate our long position, we would get executions at a price roughly equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">mid_price</span></strong><span class="koboSpan" id="kobo.787.1">. </span><span class="koboSpan" id="kobo.787.2">This is why we update the unrealized PnL when market prices change, even though no additional orders have been executed. </span><span class="koboSpan" id="kobo.787.3">Also, note that the realized PnL captures the PnL of pairs of buy and sell executions, so that does not need to be </span><a id="_idIndexMarker1267"/><span class="koboSpan" id="kobo.788.1">updated here since there were no </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">additional executions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
        if (position_ &gt; 0)
          unreal_pnl_ =
              (mid_price – open_vwap_
                [sideToIndex(Side::BUY)] / std::
                  abs(position_)) *
              std::abs(position_);
        else
          unreal_pnl_ =
              (open_vwap_[sideToIndex(Side::SELL)] / std::
                 abs(position_) – mid_price) *
              std::abs(position_);</span></pre>
<p><span class="koboSpan" id="kobo.791.1">Finally, we must update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">total_pnl_</span></strong><span class="koboSpan" id="kobo.793.1"> data member and log it if it has changed since the </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">last time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
        const auto old_total_pnl = total_pnl_;
        total_pnl_ = unreal_pnl_ + real_pnl_;
        if (total_pnl_ != old_total_pnl)
          logger-&gt;log("%:% %() % % %\n", __FILE__, __LINE__
            , __FUNCTION__, Common::
               getCurrentTimeStr(&amp;time_str),
                      toString(), bbo_-&gt;toString());
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.796.1">This</span><a id="_idIndexMarker1268"/><span class="koboSpan" id="kobo.797.1"> concludes all the functionality we need for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.799.1"> struct. </span><span class="koboSpan" id="kobo.799.2">We will now shift our discussion to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.801.1"> class, which we will use to manage the position and PnL for the entire trading engine across all </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">trading instruments.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.803.1">Designing PositionKeeper</span></h2>
<p><span class="koboSpan" id="kobo.804.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.806.1"> class</span><a id="_idIndexMarker1269"/><span class="koboSpan" id="kobo.807.1"> manages the position and PnL across all trading instruments in the trading engine. </span><span class="koboSpan" id="kobo.807.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.809.1"> class contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">std::array</span></strong><span class="koboSpan" id="kobo.811.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.813.1"> objects and is large enough to accommodate </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">ME_MAX_TICKERS</span></strong><span class="koboSpan" id="kobo.815.1"> number </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">of objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.817.1">
  class PositionKeeper {
  private:
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    std::array&lt;PositionInfo, ME_MAX_TICKERS&gt;
      ticker_position_;
  };</span></pre>
<p><span class="koboSpan" id="kobo.818.1">We will add a getter method to fetch and return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.820.1"> instance for a provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">TickerId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.822.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">getPositionInfo()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
    auto getPositionInfo(TickerId ticker_id) const noexcept {
      return &amp;(ticker_position_.at(ticker_id));
    }</span></pre>
<p><span class="koboSpan" id="kobo.826.1">We will also add a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">toString()</span></strong><span class="koboSpan" id="kobo.828.1"> method, which we will use for logging </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">purposes later:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.830.1">
    auto toString() const {
      double total_pnl = 0;
      Qty total_vol = 0;
      std::stringstream ss;
      for(TickerId i = 0; i &lt; ticker_position_.size(); ++i) {
        ss &lt;&lt; "TickerId:" &lt;&lt; tickerIdToString(i) &lt;&lt; " " &lt;&lt;
          ticker_position_.at(i).toString() &lt;&lt; "\n";
        total_pnl += ticker_position_.at(i).total_pnl_;
        total_vol += ticker_position_.at(i).volume_;
      }
      ss &lt;&lt; "Total PnL:" &lt;&lt; total_pnl &lt;&lt; " Vol:" &lt;&lt;
        total_vol &lt;&lt; "\n";
      return ss.str();
    }</span></pre>
<p><span class="koboSpan" id="kobo.831.1">Initializing an </span><a id="_idIndexMarker1270"/><span class="koboSpan" id="kobo.832.1">object of this class is straightforward and something we will </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">discuss next.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.834.1">Initializing PositionKeeper</span></h2>
<p><span class="koboSpan" id="kobo.835.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.837.1"> constructor</span><a id="_idIndexMarker1271"/><span class="koboSpan" id="kobo.838.1"> accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">Logger</span></strong><span class="koboSpan" id="kobo.840.1"> object and initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">logger_</span></strong><span class="koboSpan" id="kobo.842.1"> data member with that argument, as </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.844.1">
    PositionKeeper(Common::Logger *logger)
        : logger_(logger) {
    }</span></pre>
<p><span class="koboSpan" id="kobo.845.1">Next, we will see how order executions and changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">BBO</span></strong><span class="koboSpan" id="kobo.847.1"> are handled in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.849.1"> class and forwarded to the correct </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">PositionInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.851.1"> object.</span></span></p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.852.1">Handling order executions and market updates in PositionKeeper</span></h2>
<p><span class="koboSpan" id="kobo.853.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">PositionKeeper::addFill()</span></strong><span class="koboSpan" id="kobo.855.1"> method handles order executions and its implementation is </span><a id="_idIndexMarker1272"/><span class="koboSpan" id="kobo.856.1">straightforward. </span><span class="koboSpan" id="kobo.856.2">It simply calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">PositionInfo::addFill()</span></strong><span class="koboSpan" id="kobo.858.1"> method on the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.860.1"> object for that </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">TickerId</span></strong><span class="koboSpan" id="kobo.862.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.864.1">
    auto addFill(const Exchange::MEClientResponse
      *client_response) noexcept {
      ticker_position_.at(client_response-&gt;
        ticker_id_).addFill(client_response, logger_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.865.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">PositionKeeper::updateBBO()</span></strong><span class="koboSpan" id="kobo.867.1"> method handles changes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">BBO</span></strong><span class="koboSpan" id="kobo.869.1"> due to market updates and corresponding changes in </span><a id="_idIndexMarker1273"/><span class="koboSpan" id="kobo.870.1">the order book. </span><span class="koboSpan" id="kobo.870.2">It also simply calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">PositionInfo::updateBBO()</span></strong><span class="koboSpan" id="kobo.872.1"> method on the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.874.1"> object for </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">TickerId</span></strong><span class="koboSpan" id="kobo.876.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
    auto updateBBO(TickerId ticker_id, const BBO *bbo)
      noexcept {
      ticker_position_.at(ticker_id).updateBBO(bbo,
        logger_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.879.1">That concludes the design and implementation of everything we need in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.881.1"> class. </span><span class="koboSpan" id="kobo.881.2">In the next section, we will build an order manager class, which will be used by the trading strategies to manage their orders at a </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">higher level.</span></span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.883.1">Sending and managing orders</span></h1>
<p><span class="koboSpan" id="kobo.884.1">In </span><em class="italic"><span class="koboSpan" id="kobo.885.1">Chapter</span></em><span class="koboSpan" id="kobo.886.1">, </span><em class="italic"><span class="koboSpan" id="kobo.887.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.888.1">, we discussed the purpose of the trading system’s order manager </span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.889.1">component (the </span><em class="italic"><span class="koboSpan" id="kobo.890.1">Designing a framework for low-latency C++ trading algorithms</span></em><span class="koboSpan" id="kobo.891.1"> section). </span><span class="koboSpan" id="kobo.891.2">In this section, we will implement </span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.892.1">an </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">OrderManager</span></strong><span class="koboSpan" id="kobo.894.1"> class to</span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.895.1"> encapsulate the order management logic inside this class and thus make it easy for trading strategies to manage their orders. </span><span class="koboSpan" id="kobo.895.2">Before we build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">OrderManager</span></strong><span class="koboSpan" id="kobo.897.1"> class itself, we will need to define a basic building block called the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">OMOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.899.1"> structure.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.900.1">Defining the OMOrder struct and its related types</span></h2>
<p><span class="koboSpan" id="kobo.901.1">In this first subsection, we </span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.902.1">will define some enumerations and types to be used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">OrderManager</span></strong><span class="koboSpan" id="kobo.904.1"> class and its sub-components. </span><span class="koboSpan" id="kobo.904.2">All the source code for this subsection is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">Chapter9/trading/strategy/om_order.h</span></strong><span class="koboSpan" id="kobo.906.1"> source file </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">on GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">First, we must provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">include</span></strong><span class="koboSpan" id="kobo.910.1"> files that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">om_order.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.912.1">file needs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.913.1">
#pragma once
#include &lt;array&gt;
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Trading {</span></pre>
<p><span class="koboSpan" id="kobo.914.1">Now, we must declare an </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">OMOrderState</span></strong><span class="koboSpan" id="kobo.916.1"> enumeration, which will be used to track the state of a strategy order (</span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">OMOrder</span></strong><span class="koboSpan" id="kobo.918.1">) in the order manager. </span><span class="koboSpan" id="kobo.918.2">These states represent the state </span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.919.1">of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">OMOrder</span></strong><span class="koboSpan" id="kobo.921.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">described here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.923.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">INVALID</span></strong><span class="koboSpan" id="kobo.925.1"> state represents an invalid </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">order state</span></span></li>
<li><span class="koboSpan" id="kobo.927.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">PENDING_NEW</span></strong><span class="koboSpan" id="kobo.929.1"> state signifies that a new order has been sent out by </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">OrderManager</span></strong><span class="koboSpan" id="kobo.931.1"> but it has not been accepted by the electronic trading </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">exchange yet</span></span></li>
<li><span class="koboSpan" id="kobo.933.1">When we receive a response from the exchange to signify acceptance, the order goes from </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">PENDING_NEW</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.935.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">LIVE</span></strong></span></li>
<li><span class="koboSpan" id="kobo.937.1">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">PENDING_NEW</span></strong><span class="koboSpan" id="kobo.939.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">PENDING_CANCEL</span></strong><span class="koboSpan" id="kobo.941.1"> state represents the state of an order when a cancellation for an order has been sent to the exchange but has not been processed by the exchange or the response has not been </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">received back</span></span></li>
<li><span class="koboSpan" id="kobo.943.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">DEAD</span></strong><span class="koboSpan" id="kobo.945.1"> state</span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.946.1"> represents an order that does not exist – it has either not been sent yet or fully executed or </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">successfully cancelled:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.948.1">
  enum class OMOrderState : int8_t {
    INVALID = 0,
    PENDING_NEW = 1,
    LIVE = 2,
    PENDING_CANCEL = 3,
    DEAD = 4
  };</span></pre>
<p><span class="koboSpan" id="kobo.949.1">We must also add a method for converting </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">OMOrderState</span></strong><span class="koboSpan" id="kobo.951.1"> enumerations into strings for logging purposes, as </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.953.1">
  inline auto OMOrderStateToString(OMOrderState side) -&gt;
    std::string {
    switch (side) {
      case OMOrderState::PENDING_NEW:
        return "PENDING_NEW";
      case OMOrderState::LIVE:
        return "LIVE";
      case OMOrderState::PENDING_CANCEL:
        return "PENDING_CANCEL";
      case OMOrderState::DEAD:
        return "DEAD";
      case OMOrderState::INVALID:
        return "INVALID";
    }
    return "UNKNOWN";
  }</span></pre>
<p><span class="koboSpan" id="kobo.954.1">Now, we can </span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.955.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">OMOrder</span></strong><span class="koboSpan" id="kobo.957.1"> structure, which has the following </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">key fields:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.959.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.961.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">TickerId</span></strong><span class="koboSpan" id="kobo.963.1"> type to represent which trading instrument this order </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">is for</span></span></li>
<li><span class="koboSpan" id="kobo.965.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">order_id_</span></strong><span class="koboSpan" id="kobo.967.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">OrderId</span></strong><span class="koboSpan" id="kobo.969.1"> type, which is the unique order ID that’s been assigned to this </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">order object</span></span></li>
<li><span class="koboSpan" id="kobo.971.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">side_</span></strong><span class="koboSpan" id="kobo.973.1"> variable to hold the </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">Side</span></strong><span class="koboSpan" id="kobo.975.1"> property of </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">this order</span></span></li>
<li><span class="koboSpan" id="kobo.977.1">The order’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">Price</span></strong><span class="koboSpan" id="kobo.979.1"> is held in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">price_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.981.1">data member</span></span></li>
<li><span class="koboSpan" id="kobo.982.1">The live or requested </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">Qty</span></strong><span class="koboSpan" id="kobo.984.1"> for this order is saved in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">qty_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.986.1"> variable</span></span></li>
<li><span class="koboSpan" id="kobo.987.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">order_state_</span></strong><span class="koboSpan" id="kobo.989.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">OMOrderState</span></strong><span class="koboSpan" id="kobo.991.1"> type, which we defined previously, to represent the current state </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">OMOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.995.1">
  struct OMOrder {
    TickerId ticker_id_ = TickerId_INVALID;
    OrderId order_id_ = OrderId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty qty_ = Qty_INVALID;
    OMOrderState order_state_ = OMOrderState::INVALID;</span></pre>
<p><span class="koboSpan" id="kobo.996.1">We must also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">toString()</span></strong><span class="koboSpan" id="kobo.998.1"> method to stringify </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1000.1"> objects for </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">logging purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1002.1">
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "OMOrder" &lt;&lt; "["
         &lt;&lt; "tid:" &lt;&lt; tickerIdToString(ticker_id_) &lt;&lt; " "
         &lt;&lt; "oid:" &lt;&lt; orderIdToString(order_id_) &lt;&lt; " "
         &lt;&lt; "side:" &lt;&lt; sideToString(side_) &lt;&lt; " "
         &lt;&lt; "price:" &lt;&lt; priceToString(price_) &lt;&lt; " "
         &lt;&lt; "qty:" &lt;&lt; qtyToString(qty_) &lt;&lt; " "
         &lt;&lt; "state:" &lt;&lt; OMOrderStateToString(order_state_)
         &lt;&lt; "]";
      return ss.str();
    }
  };</span></pre>
<p><span class="koboSpan" id="kobo.1003.1">Here, we </span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.1004.1">define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">OMOrderSideHashMap</span></strong><span class="koboSpan" id="kobo.1006.1"> typedef to represent a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">std::array</span></strong><span class="koboSpan" id="kobo.1008.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1010.1"> objects and indicate that the capacity of this array is large enough to hold an entry for the buy side and another for the sell side. </span><span class="koboSpan" id="kobo.1010.2">Objects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">OMOrderSideHashMap</span></strong><span class="koboSpan" id="kobo.1012.1"> type will be indexed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">sideToIndex(Side::BUY)</span></strong><span class="koboSpan" id="kobo.1014.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">sideToIndex(Side::SELL)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1"> indices:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1017.1">
  typedef std::array&lt;OMOrder, sideToIndex(Side::MAX) + 1&gt;
    OMOrderSideHashMap;</span></pre>
<p><span class="koboSpan" id="kobo.1018.1">We must also define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">OMOrderTickerSideHashMap</span></strong><span class="koboSpan" id="kobo.1020.1">, which is just another </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">std::array</span></strong><span class="koboSpan" id="kobo.1022.1"> of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">OMOrderSideHashMap</span></strong><span class="koboSpan" id="kobo.1024.1"> object that’s large enough to hold all trading instruments – that is, of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">ME_MAX_TICKERS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1"> size:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1027.1">
  typedef std::array&lt;OMOrderSideHashMap, ME_MAX_TICKERS&gt;
    OMOrderTickerSideHashMap;</span></pre>
<p><span class="koboSpan" id="kobo.1028.1">Now, we can build the order manager class, which is used to manage </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1030.1"> objects for </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">trading strategies.</span></span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.1032.1">Designing the OrderManager class</span></h2>
<p><span class="koboSpan" id="kobo.1033.1">Our</span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.1034.1"> simplified order manager will manage </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1036.1"> objects on the trading strategy’s behalf. </span><span class="koboSpan" id="kobo.1036.2">To keep things simple, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1038.1"> class will allow, at most, a single order on the buy side and a single order on the sell side. </span><span class="koboSpan" id="kobo.1038.2">We will look at the details of this implementation in this section. </span><span class="koboSpan" id="kobo.1038.3">All the code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1040.1"> class can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">Chapter9/trading/strategy/order_manager.h</span></strong><span class="koboSpan" id="kobo.1042.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">Chapter9/trading/strategy/order_manager.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1044.1">source files.</span></span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.1045.1">Defining the data members in OrderManager</span></h2>
<p><span class="koboSpan" id="kobo.1046.1">We need </span><a id="_idIndexMarker1283"/><span class="koboSpan" id="kobo.1047.1">to define the data members that belong within our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1049.1"> class. </span><span class="koboSpan" id="kobo.1049.2">But before we do that, in the following code block, we have provided the header files we will need to include in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">order_manager.h</span></strong><span class="koboSpan" id="kobo.1051.1"> source file. </span><span class="koboSpan" id="kobo.1051.2">We must also forward declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1053.1"> class since we will refer to it in this class but want to avoid circular </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">dependency issues:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1055.1">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "exchange/order_server/client_response.h"
#include "om_order.h"
#include "risk_manager.h"
using namespace Common;
namespace Trading {
  class TradeEngine;</span></pre>
<p><span class="koboSpan" id="kobo.1056.1">Now, we can design the internal data members in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1058.1"> class. </span><span class="koboSpan" id="kobo.1058.2">The key members </span><a id="_idIndexMarker1284"/><span class="koboSpan" id="kobo.1059.1">are </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1061.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">trade_engine_</span></strong><span class="koboSpan" id="kobo.1063.1"> variable. </span><span class="koboSpan" id="kobo.1063.2">This is a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1065.1"> object. </span><span class="koboSpan" id="kobo.1065.2">We will use this to store the parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1067.1"> instance that is using this </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">order manager.</span></span></li>
<li><span class="koboSpan" id="kobo.1069.1">A constant reference to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1071.1"> object stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">risk_manager_</span></strong><span class="koboSpan" id="kobo.1073.1"> member variable. </span><span class="koboSpan" id="kobo.1073.2">This will be used to perform </span><em class="italic"><span class="koboSpan" id="kobo.1074.1">pre-trade</span></em><span class="koboSpan" id="kobo.1075.1"> risk checks – that is, risk checks that are performed before new orders are sent out to </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">the exchange.</span></span></li>
<li><span class="koboSpan" id="kobo.1077.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">ticker_side_order_</span></strong><span class="koboSpan" id="kobo.1079.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">OMOrderTickerSideHashMap</span></strong><span class="koboSpan" id="kobo.1081.1"> type to hold a pair (a buy and a sell) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1083.1"> objects for each trading instrument. </span><span class="koboSpan" id="kobo.1083.2">This will be used as a hash map that’s indexed first by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">TickerId</span></strong><span class="koboSpan" id="kobo.1085.1"> value of the instrument we want to send an order for and then indexed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">sideToIndex(Side::BUY)</span></strong><span class="koboSpan" id="kobo.1087.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">sideToIndex(Side::SELL)</span></strong><span class="koboSpan" id="kobo.1089.1"> values to manage the buy or </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">sell order.</span></span></li>
<li><span class="koboSpan" id="kobo.1091.1">New and unique order IDs starting from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">1</span></strong><span class="koboSpan" id="kobo.1093.1">, which we will generate using a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">next_order_id_</span></strong><span class="koboSpan" id="kobo.1095.1"> variable of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">OrderId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1"> type:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.1098.1">
  class OrderManager {
  private:
    TradeEngine *trade_engine_ = nullptr;
    const RiskManager&amp; risk_manager_;
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    OMOrderTickerSideHashMap ticker_side_order_;
    OrderId next_order_id_ = 1;
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.1099.1">That is all the</span><a id="_idIndexMarker1285"/><span class="koboSpan" id="kobo.1100.1"> data inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1102.1"> class. </span><span class="koboSpan" id="kobo.1102.2">In the next subsection, we will learn how to initialize these members and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">OrderManager</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1104.1">class itself.</span></span></p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.1105.1">Initializing OrderManager</span></h2>
<p><span class="koboSpan" id="kobo.1106.1">Initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1108.1"> is </span><a id="_idIndexMarker1286"/><span class="koboSpan" id="kobo.1109.1">straightforward. </span><span class="koboSpan" id="kobo.1109.2">In addition to what we initialized in the class definition itself, we must initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">trade_engine_</span></strong><span class="koboSpan" id="kobo.1111.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">risk_manager_</span></strong><span class="koboSpan" id="kobo.1113.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">logger_</span></strong><span class="koboSpan" id="kobo.1115.1"> data members, which we expect to be passed through the </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">constructor arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1117.1">
    OrderManager(Common::Logger *logger, TradeEngine
      *trade_engine, RiskManager&amp; risk_manager)
        : trade_engine_(trade_engine),
          risk_manager_(risk_manager), logger_(logger) {
    }</span></pre>
<p><span class="koboSpan" id="kobo.1118.1">As shown here, we must add a simple convenience function that we can use in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1120.1"> implementation called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">getOMOrderSideHashMap()</span></strong><span class="koboSpan" id="kobo.1122.1">. </span><span class="koboSpan" id="kobo.1122.2">This simply returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">OMOrderSideHashMap</span></strong><span class="koboSpan" id="kobo.1124.1"> instance for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">provided </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">TickerId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1128.1">
    auto getOMOrderSideHashMap(TickerId ticker_id) const {
      return &amp;(ticker_side_order_.at(ticker_id));
    }</span></pre>
<p><span class="koboSpan" id="kobo.1129.1">Next, we can move on to an important task in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1131.1"> – sending </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">new orders.</span></span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.1133.1">Sending new orders from OrderManager</span></h2>
<p><span class="koboSpan" id="kobo.1134.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">OrderManager::newOrder()</span></strong><span class="koboSpan" id="kobo.1136.1"> method is the lower-level method in our order manager class. </span><span class="koboSpan" id="kobo.1136.2">It </span><a id="_idIndexMarker1287"/><span class="koboSpan" id="kobo.1137.1">requires a pointer to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1139.1"> object for which this new order is being sent. </span><span class="koboSpan" id="kobo.1139.2">It also needs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">TickerId</span></strong><span class="koboSpan" id="kobo.1141.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">Price</span></strong><span class="koboSpan" id="kobo.1143.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">Side</span></strong><span class="koboSpan" id="kobo.1145.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">Qty</span></strong><span class="koboSpan" id="kobo.1147.1"> attributes to be set on the new order that’s being </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">sent out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1149.1">
  auto OrderManager::newOrder(OMOrder *order, TickerId
    ticker_id, Price price, Side side, Qty qty) noexcept -&gt; void {</span></pre>
<p><span class="koboSpan" id="kobo.1150.1">It creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1152.1"> structure of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">ClientRequestType::NEW</span></strong><span class="koboSpan" id="kobo.1154.1"> type and fills in</span><a id="_idIndexMarker1288"/><span class="koboSpan" id="kobo.1155.1"> the attributes that are passed through the arguments, sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">OrderId</span></strong><span class="koboSpan" id="kobo.1157.1"> to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">next_order_id_</span></strong><span class="koboSpan" id="kobo.1159.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">ClientId</span></strong><span class="koboSpan" id="kobo.1161.1"> to be the client ID of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1163.1">, which can be obtained by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">clientId()</span></strong><span class="koboSpan" id="kobo.1165.1"> method. </span><span class="koboSpan" id="kobo.1165.2">It also calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">TradeEngine::sendClientRequest()</span></strong><span class="koboSpan" id="kobo.1167.1"> and provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1169.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">new_request</span></strong><span class="koboSpan" id="kobo.1171.1">) it </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">just initialized:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1173.1">
    const Exchange::MEClientRequest
      new_request{Exchange::ClientRequestType::NEW,
        trade_engine_-&gt;clientId(), ticker_id,
         next_order_id_, side, price, qty};
    trade_engine_-&gt;sendClientRequest(&amp;new_request);</span></pre>
<p><span class="koboSpan" id="kobo.1174.1">Finally, it updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1176.1"> object pointer it was provided in the method parameters and assigns it the attributes that were just set on the new order that was sent out. </span><span class="koboSpan" id="kobo.1176.2">Note that the state of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1178.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">OMOrderState::PENDING_NEW</span></strong><span class="koboSpan" id="kobo.1180.1"> since it will be sent out shortly but will not be active until the exchange accepts it and we receive that response. </span><span class="koboSpan" id="kobo.1180.2">It also increments the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">next_order_id_</span></strong><span class="koboSpan" id="kobo.1182.1"> variable to maintain uniqueness on any new orders that might be sent </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">out later:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1184.1">
    *order = {ticker_id, next_order_id_, side, price, qty,
      OMOrderState::PENDING_NEW};
    ++next_order_id_;
    logger_-&gt;log("%:% %() % Sent new order % for %\n",
      __FILE__, __LINE__, __FUNCTION__,
                 Common::getCurrentTimeStr(&amp;time_str_),
                 new_request.toString().c_str(), order-&gt;
                   toString().c_str());
  }</span></pre>
<p><span class="koboSpan" id="kobo.1185.1">We will see where this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">newOrder()</span></strong><span class="koboSpan" id="kobo.1187.1"> method gets called from shortly, but before that, let’s look at the complementary task of </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">cancelling orders.</span></span></p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.1189.1">Cancelling orders from OrderManager</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">OrderManager::cancelOrder()</span></strong><span class="koboSpan" id="kobo.1191.1"> is the lower-level method in our order manager class and </span><a id="_idIndexMarker1289"/><span class="koboSpan" id="kobo.1192.1">will be used to send a cancel request for live orders being managed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1194.1">. </span><span class="koboSpan" id="kobo.1194.2">It only accepts a single parameter, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1196.1"> object for which it is going to send the </span><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">cancel request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1198.1">
  auto OrderManager::cancelOrder(OMOrder *order) noexcept
    -&gt; void {</span></pre>
<p><span class="koboSpan" id="kobo.1199.1">Like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">newOrder()</span></strong><span class="koboSpan" id="kobo.1201.1"> method, we must initialize an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">MEClientRequest</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">client_request</span></strong><span class="koboSpan" id="kobo.1204.1"> object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">ClientRequestType::CANCEL</span></strong><span class="koboSpan" id="kobo.1206.1"> type and populate the attributes in it from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1208.1"> object that was passed into the method. </span><span class="koboSpan" id="kobo.1208.2">It calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">TradeEngine::sendClientRequest()</span></strong><span class="koboSpan" id="kobo.1210.1"> method to send the cancel request out. </span><span class="koboSpan" id="kobo.1210.2">One thing to understand is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">next_order_id_</span></strong><span class="koboSpan" id="kobo.1212.1"> member variable is only used for generating new order IDs for new outgoing order requests. </span><span class="koboSpan" id="kobo.1212.2">Cancelling an existing order does not change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">next_order_id_</span></strong><span class="koboSpan" id="kobo.1214.1"> variable, as shown in the following code block. </span><span class="koboSpan" id="kobo.1214.2">In our design, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">next_order_id_</span></strong><span class="koboSpan" id="kobo.1216.1"> keeps incrementing sequentially each time we send an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1218.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">ClientRequestType::NEW</span></strong><span class="koboSpan" id="kobo.1220.1"> type. </span><span class="koboSpan" id="kobo.1220.2">Theoretically, we could reuse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">order_id_</span></strong><span class="koboSpan" id="kobo.1222.1"> value from the order we just cancelled on the next new order request, but that would require us to track the free order IDs, which is not too difficult either. </span><span class="koboSpan" id="kobo.1222.2">This was just a design choice we made, but feel free to modify this scheme and track free order IDs if </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">you wish:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1224.1">
    const Exchange::MEClientRequest cancel_request
      {Exchange::ClientRequestType::CANCEL, trade_engine_-&gt;
        clientId(),
     order-&gt;ticker_id_, order-&gt;order_id_, order-&gt;side_,
       order-&gt;price_,
     order-&gt;qty_};
    trade_engine_-&gt;sendClientRequest(&amp;cancel_request);</span></pre>
<p><span class="koboSpan" id="kobo.1225.1">Finally, we must update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">order_state_</span></strong><span class="koboSpan" id="kobo.1227.1"> value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1229.1"> object to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">OMOrderState::PENDING_CANCEL</span></strong><span class="koboSpan" id="kobo.1231.1"> to represent the fact that a cancel request has been </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">sent out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1233.1">
    order-&gt;order_state_ = OMOrderState::PENDING_CANCEL;
    logger_-&gt;log("%:% %() % Sent cancel % for %\n",
      __FILE__, __LINE__, __FUNCTION__,
                 Common::getCurrentTimeStr(&amp;time_str_),
                 cancel_request.toString().c_str(), order-&gt;
                   toString().c_str());
  }</span></pre>
<p><span class="koboSpan" id="kobo.1234.1">Previously, we </span><a id="_idIndexMarker1290"/><span class="koboSpan" id="kobo.1235.1">mentioned that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">newOrder()</span></strong><span class="koboSpan" id="kobo.1237.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">cancelOrder()</span></strong><span class="koboSpan" id="kobo.1239.1"> are lower-level methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1241.1"> class. </span><span class="koboSpan" id="kobo.1241.2">Trading strategies that use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1243.1"> will not call these methods directly; instead, they will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1245.1"> manage the orders by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">OrderManager::moveOrders()</span></strong><span class="koboSpan" id="kobo.1247.1"> method. </span><span class="koboSpan" id="kobo.1247.2">We will build this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">next subsection.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.1249.1">Adding methods to simplify order management</span></h2>
<p><span class="koboSpan" id="kobo.1250.1">Before we </span><a id="_idIndexMarker1291"/><span class="koboSpan" id="kobo.1251.1">build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">moveOrders()</span></strong><span class="koboSpan" id="kobo.1253.1"> method, we will build one more lower-level method that’s used by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1255.1">. </span><span class="koboSpan" id="kobo.1255.2">This method, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">moveOrder()</span></strong><span class="koboSpan" id="kobo.1257.1">, manages a single order and either sends a new order or cancels an existing order, depending on the arguments provided to it. </span><span class="koboSpan" id="kobo.1257.2">The most important parameter for this method is a pointer to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1259.1"> object. </span><span class="koboSpan" id="kobo.1259.2">It also accepts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">TickerId</span></strong><span class="koboSpan" id="kobo.1261.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">Price</span></strong><span class="koboSpan" id="kobo.1263.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">Side</span></strong><span class="koboSpan" id="kobo.1265.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">Qty</span></strong><span class="koboSpan" id="kobo.1267.1"> parameters. </span><span class="koboSpan" id="kobo.1267.2">The purpose of this method is to make sure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1269.1"> object that’s passed to it is placed or replaced with the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">price</span></strong><span class="koboSpan" id="kobo.1271.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">side</span></strong><span class="koboSpan" id="kobo.1273.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">qty</span></strong><span class="koboSpan" id="kobo.1275.1"> arguments. </span><span class="koboSpan" id="kobo.1275.2">This involves a combination of cancelling an existing order if it is not at the specified price and/or placing a new order with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">price</span></strong><span class="koboSpan" id="kobo.1277.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">qty</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1279.1">parameters specified:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1280.1">
    auto moveOrder(OMOrder *order, TickerId ticker_id,
      Price price, Side side, Qty qty) noexcept {</span></pre>
<p><span class="koboSpan" id="kobo.1281.1">The action this method decides to take depends on the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">order_state_</span></strong><span class="koboSpan" id="kobo.1283.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1285.1"> object passed to it. </span><span class="koboSpan" id="kobo.1285.2">We will go through the different </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">OMOrderState</span></strong><span class="koboSpan" id="kobo.1287.1"> cases one by one, starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">OMOrderState::LIVE</span></strong><span class="koboSpan" id="kobo.1289.1">. </span><span class="koboSpan" id="kobo.1289.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1291.1"> object is already live/active, it checks to make sure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">price</span></strong><span class="koboSpan" id="kobo.1293.1"> parameter matches the order’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">price_</span></strong><span class="koboSpan" id="kobo.1295.1"> attribute. </span><span class="koboSpan" id="kobo.1295.2">If that is not the case, then it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">OrderManager::cancelOrder()</span></strong><span class="koboSpan" id="kobo.1297.1"> method to cancel this order and replaces it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">next iteration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1299.1">
      switch (order-&gt;order_state_) {
        case OMOrderState::LIVE: {
          if(order-&gt;price_ != price || order-&gt;qty_ != qty)
            cancelOrder(order);
        }
          break;</span></pre>
<p><span class="koboSpan" id="kobo.1300.1">For cases </span><a id="_idIndexMarker1292"/><span class="koboSpan" id="kobo.1301.1">where the order is in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">INVALID</span></strong><span class="koboSpan" id="kobo.1303.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">DEAD</span></strong><span class="koboSpan" id="kobo.1305.1"> state, which means not active in the market, we will place the order using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">OrderManager::newOrder()</span></strong><span class="koboSpan" id="kobo.1307.1"> method we built previously. </span><span class="koboSpan" id="kobo.1307.2">But it needs to check with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1309.1"> whether this action is allowed by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">RiskManager::checkPreTradeRisk()</span></strong><span class="koboSpan" id="kobo.1311.1"> method and passing it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">TickerId</span></strong><span class="koboSpan" id="kobo.1313.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">Side</span></strong><span class="koboSpan" id="kobo.1315.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">Qty</span></strong><span class="koboSpan" id="kobo.1317.1"> attributes of the order we would like to send. </span><span class="koboSpan" id="kobo.1317.2">At this point, it should be clear why this is called pre-trade risk – we check if we can perform the action/trade before we do it. </span><span class="koboSpan" id="kobo.1317.3">We will discuss the design and implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1319.1">, as well as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">checkPreTradeRisk()</span></strong><span class="koboSpan" id="kobo.1321.1"> method, shortly. </span><span class="koboSpan" id="kobo.1321.2">For now, all you need to know is that it returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">RiskCheckResult</span></strong><span class="koboSpan" id="kobo.1323.1"> enumeration value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">RiskCheckResult::ALLOWED</span></strong><span class="koboSpan" id="kobo.1325.1"> if the risk checks pass and a different value if the risk checks fail – that is, the action/trade is not allowed. </span><span class="koboSpan" id="kobo.1325.2">In the following code block, we only send the order by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">newOrder()</span></strong><span class="koboSpan" id="kobo.1327.1"> method if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">checkPreTradeRisk()</span></strong><span class="koboSpan" id="kobo.1329.1"> method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">RiskCheckResult::ALLOWED</span></strong><span class="koboSpan" id="kobo.1331.1">. </span><span class="koboSpan" id="kobo.1331.2">As a final note, here, we log an error message if the risk check fails using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">riskCheckResultToString()</span></strong><span class="koboSpan" id="kobo.1333.1"> method. </span><span class="koboSpan" id="kobo.1333.2">We will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">this shortly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1335.1">
        case OMOrderState::INVALID:
        case OMOrderState::DEAD: {
          if(LIKELY(price != Price_INVALID)) {
            const auto risk_result = risk_manager_
              .checkPreTradeRisk(ticker_id, side, qty);
            if(LIKELY(risk_result == RiskCheckResult
              ::ALLOWED))
              newOrder(order, ticker_id, price, side, qty);
            else
              logger_-&gt;log("%:% %() % Ticker:% Side:% Qty:%
                RiskCheckResult:%\n", __FILE__, __LINE__,
                   __FUNCTION__,
                           Common::getCurrentTimeStr(&amp;time_
                             str_),
                           tickerIdToString(ticker_id),
                             sideToString(side),
                               qtyToString(qty),
                           riskCheckResultToString
                             (risk_result));
          }
        }
          break;</span></pre>
<p><span class="koboSpan" id="kobo.1336.1">For the</span><a id="_idIndexMarker1293"/><span class="koboSpan" id="kobo.1337.1"> cases where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1339.1"> object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">order_state_</span></strong><span class="koboSpan" id="kobo.1341.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">PENDING_NEW</span></strong><span class="koboSpan" id="kobo.1343.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">PENDING_CANCEL</span></strong><span class="koboSpan" id="kobo.1345.1">, we do nothing since we are waiting for a response from the electronic trading exchange before we </span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1">can proceed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1347.1">
        case OMOrderState::PENDING_NEW:
        case OMOrderState::PENDING_CANCEL:
          break;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.1348.1">Now, we have all the pieces we need to build our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">OrderManager::moveOrders()</span></strong><span class="koboSpan" id="kobo.1350.1"> method. </span><span class="koboSpan" id="kobo.1350.2">This is the primary method that’s used by trading strategies to generate and manage the orders it needs. </span><span class="koboSpan" id="kobo.1350.3">It accepts a few parameters – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">TickerId</span></strong><span class="koboSpan" id="kobo.1352.1"> parameter of the instrument, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">Price</span></strong><span class="koboSpan" id="kobo.1354.1"> parameter’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">bid_price</span></strong><span class="koboSpan" id="kobo.1356.1"> for the buy order, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">Price</span></strong><span class="koboSpan" id="kobo.1358.1"> parameter’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">ask_price</span></strong><span class="koboSpan" id="kobo.1360.1"> for the sell order, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">clip</span></strong><span class="koboSpan" id="kobo.1362.1"> parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">Qty</span></strong><span class="koboSpan" id="kobo.1364.1"> type, which will be the quantity of the buy and sell orders. </span><span class="koboSpan" id="kobo.1364.2">We will see where this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">clip</span></strong><span class="koboSpan" id="kobo.1366.1"> parameter comes from in the </span><em class="italic"><span class="koboSpan" id="kobo.1367.1">Defining the TradeEngineCfg structure</span></em><span class="koboSpan" id="kobo.1368.1"> subsection, in the </span><em class="italic"><span class="koboSpan" id="kobo.1369.1">Computing and managing risk</span></em><span class="koboSpan" id="kobo.1370.1"> section. </span><span class="koboSpan" id="kobo.1370.2">For now, note that the term </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">clip</span></strong><span class="koboSpan" id="kobo.1372.1"> comes from the term clip for ammunition for firearms, and in the context of our trading strategies, it means the size of each order that our trading strategy can send. </span><span class="koboSpan" id="kobo.1372.2">We will see that this parameter gets used to set the size of outgoing new order requests. </span><span class="koboSpan" id="kobo.1372.3">This is just the name of the variable we chose; it could also be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">trade_size</span></strong><span class="koboSpan" id="kobo.1374.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">order_size</span></strong><span class="koboSpan" id="kobo.1376.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1377.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1378.1">One </span><a id="_idIndexMarker1294"/><span class="koboSpan" id="kobo.1379.1">thing to note here is that passing a price value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">Price_INVALID</span></strong><span class="koboSpan" id="kobo.1381.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">bid_price</span></strong><span class="koboSpan" id="kobo.1383.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">ask_price</span></strong><span class="koboSpan" id="kobo.1385.1"> will cause the order to be cancelled – that is, it will only have an order on the buy side or the sell side instead of both. </span><span class="koboSpan" id="kobo.1385.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">moveOrder()</span></strong><span class="koboSpan" id="kobo.1387.1"> method cancels an order if the price on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1389.1"> does not match the price passed to the method. </span><span class="koboSpan" id="kobo.1389.2">And because any </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1391.1"> that is active in the market (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">OMOrderState::LIVE</span></strong><span class="koboSpan" id="kobo.1393.1">) will have a valid price other than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">Price_INVALID</span></strong><span class="koboSpan" id="kobo.1395.1">, that check evaluates to true and causes the order to be cancelled. </span><span class="koboSpan" id="kobo.1395.2">One more thing to note here is that, currently, we support a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">clip</span></strong><span class="koboSpan" id="kobo.1397.1"> value for both the buy and sell orders, but it is easy to extend this so that we have different quantities for the buy order and the sell order. </span><span class="koboSpan" id="kobo.1397.2">The implementation of this method is extremely simple – it fetches the buy order (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">bid_order</span></strong><span class="koboSpan" id="kobo.1399.1">) by indexing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">ticker_side_order_</span></strong><span class="koboSpan" id="kobo.1401.1"> container with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">ticker_id</span></strong><span class="koboSpan" id="kobo.1403.1"> value and indexing that with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">sideToIndex(Side::BUY)</span></strong><span class="koboSpan" id="kobo.1405.1"> value. </span><span class="koboSpan" id="kobo.1405.2">It then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">OrderManager::moveOrder()</span></strong><span class="koboSpan" id="kobo.1407.1"> method on this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">bid_order</span></strong><span class="koboSpan" id="kobo.1409.1"> and passes it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">bid_price</span></strong><span class="koboSpan" id="kobo.1411.1"> parameter for the price and passes it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">clip</span></strong><span class="koboSpan" id="kobo.1413.1"> parameter for the quantity. </span><span class="koboSpan" id="kobo.1413.2">We do the same thing for the sell order (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">ask_order</span></strong><span class="koboSpan" id="kobo.1415.1">), except we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">sideToIndex(Side::SELL)</span></strong><span class="koboSpan" id="kobo.1417.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">ask_price</span></strong><span class="koboSpan" id="kobo.1419.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1">sell side:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1421.1">
    auto moveOrders(TickerId ticker_id, Price bid_price,
      Price ask_price, Qty clip) noexcept {
      auto bid_order =
        &amp;(ticker_side_order_.at(ticker_id)
          .at(sideToIndex(Side::BUY)));
      moveOrder(bid_order, ticker_id, bid_price, Side::BUY,
        clip);
      auto ask_order = &amp;(ticker_side_order_
        .at(ticker_id).at(sideToIndex(Side::SELL)));
      moveOrder(ask_order, ticker_id, ask_price, Side::
        SELL, clip);
    }</span></pre>
<p><span class="koboSpan" id="kobo.1422.1">We need </span><a id="_idIndexMarker1295"/><span class="koboSpan" id="kobo.1423.1">to add one final functionality to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1425.1"> class, which is handling incoming order responses. </span><span class="koboSpan" id="kobo.1425.2">We will tackle this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">next subsection.</span></span></p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.1427.1">Handling order updates and updating orders</span></h2>
<p><span class="koboSpan" id="kobo.1428.1">Before we</span><a id="_idIndexMarker1296"/><span class="koboSpan" id="kobo.1429.1"> can wrap up our discussion on the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1431.1">, we need to add some code to handle incoming</span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.1432.1"> order responses in the form of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1434.1"> messages. </span><span class="koboSpan" id="kobo.1434.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">OrderManager::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.1436.1"> method we will build here expects to be called and passed a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">MEClientResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1438.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1439.1">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   client_response-&gt;toString().c_str());</span></pre>
<p><span class="koboSpan" id="kobo.1440.1">First, we must fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1442.1"> object that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1444.1"> message is meant for. </span><span class="koboSpan" id="kobo.1444.2">We can do that by accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1445.1">ticker_side_order_</span></strong><span class="koboSpan" id="kobo.1446.1"> container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.1448.1"> field in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1449.1">client_response</span></strong><span class="koboSpan" id="kobo.1450.1"> and converting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">side_</span></strong><span class="koboSpan" id="kobo.1452.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">client_response</span></strong><span class="koboSpan" id="kobo.1454.1"> message into an index using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">sideToIndex()</span></strong><span class="koboSpan" id="kobo.1456.1"> method. </span><span class="koboSpan" id="kobo.1456.2">This is shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1457.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1458.1">
      auto order = &amp;(ticker_side_order_.at(client_response
        -&gt;ticker_id_).at(sideToIndex(client_response
          -&gt;side_)));
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   order-&gt;toString().c_str());</span></pre>
<p><span class="koboSpan" id="kobo.1459.1">We will update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1460.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1461.1"> object we fetched previously, but that depends on the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1462.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1463.1"> we received. </span><span class="koboSpan" id="kobo.1463.2">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">ClientResponseType::ACCEPTED</span></strong><span class="koboSpan" id="kobo.1465.1">, all we need to do is set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">order_state_</span></strong><span class="koboSpan" id="kobo.1467.1"> member </span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.1468.1">of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1470.1"> object to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">OMOrderState::LIVE</span></strong><span class="koboSpan" id="kobo.1472.1"> to mark it as accepted and active in </span><span class="No-Break"><span class="koboSpan" id="kobo.1473.1">the market:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1474.1">
      switch (client_response-&gt;type_) {
        case Exchange::ClientResponseType::ACCEPTED: {
          order-&gt;order_state_ = OMOrderState::LIVE;
        }
          break;</span></pre>
<p><span class="koboSpan" id="kobo.1475.1">If the type</span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.1476.1"> of the response is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">ClientResponseType::CANCELED</span></strong><span class="koboSpan" id="kobo.1478.1">, then we just update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">order_state_</span></strong><span class="koboSpan" id="kobo.1480.1"> variable of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1482.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">OMOrderState::DEAD</span></strong><span class="koboSpan" id="kobo.1484.1"> since it is no longer active in </span><span class="No-Break"><span class="koboSpan" id="kobo.1485.1">the market:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1486.1">
        case Exchange::ClientResponseType::CANCELED: {
          order-&gt;order_state_ = OMOrderState::DEAD;
        }
          break;</span></pre>
<p><span class="koboSpan" id="kobo.1487.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1489.1"> is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">ClientResponseType::FILLED</span></strong><span class="koboSpan" id="kobo.1491.1"> type, which is done to denote an execution, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">qty_</span></strong><span class="koboSpan" id="kobo.1493.1"> field on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">OMOrder</span></strong><span class="koboSpan" id="kobo.1495.1"> to be the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">leaves_qty_</span></strong><span class="koboSpan" id="kobo.1497.1">. </span><span class="koboSpan" id="kobo.1497.2">This reflects the live quantity that still exists in the market. </span><span class="koboSpan" id="kobo.1497.3">We also need to check that if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1498.1">qty_</span></strong><span class="koboSpan" id="kobo.1499.1"> field (and thus the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">leaves_qty_</span></strong><span class="koboSpan" id="kobo.1501.1"> field on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">client_response</span></strong><span class="koboSpan" id="kobo.1503.1">) is 0, meaning the order was fully executed, the order is no longer active in the market. </span><span class="koboSpan" id="kobo.1503.2">If so, we must set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">order_state_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1505.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">OMOrderState::DEAD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1507.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1508.1">
        case Exchange::ClientResponseType::FILLED: {
          order-&gt;qty_ = client_response-&gt;leaves_qty_;
          if(!order-&gt;qty_)
            order-&gt;order_state_ = OMOrderState::DEAD;
        }
          break;</span></pre>
<p><span class="koboSpan" id="kobo.1509.1">We ignore the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">CANCEL_REJECTED</span></strong><span class="koboSpan" id="kobo.1511.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">INVALID</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">ClientResponseType</span></strong><span class="koboSpan" id="kobo.1514.1"> enumeration </span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.1515.1">values since there is no action that we </span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.1516.1">need </span><span class="No-Break"><span class="koboSpan" id="kobo.1517.1">to take:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1518.1">
        case Exchange::ClientResponseType::CANCEL_REJECTED:
        case Exchange::ClientResponseType::INVALID: {
        }
          break;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.1519.1">This concludes the discussion, design, and implementation of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1521.1"> component. </span><span class="koboSpan" id="kobo.1521.2">However, we referenced and used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1522.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1523.1"> in the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1525.1"> class without discussing all its details. </span><span class="koboSpan" id="kobo.1525.2">We will do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1526.1">next section.</span></span></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.1527.1">Computing and managing risk</span></h1>
<p><span class="koboSpan" id="kobo.1528.1">The </span><a id="_idIndexMarker1302"/><span class="koboSpan" id="kobo.1529.1">final component we still need to </span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.1530.1">build before we can build our trading strategies is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1532.1">. </span><span class="koboSpan" id="kobo.1532.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1534.1"> component tracks the active order quantities that a trading strategy has in the market through the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.1535.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1536.1"> instance that a trading strategy uses. </span><span class="koboSpan" id="kobo.1536.2">It also tracks the positions and realized and unrealized PnLs using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.1538.1"> instance, which tracks the trading strategy’s positions and PnLs. </span><span class="koboSpan" id="kobo.1538.2">It checks that the strategy stays</span><a id="_idIndexMarker1304"/><span class="koboSpan" id="kobo.1539.1"> within its assigned risk limits. </span><span class="koboSpan" id="kobo.1539.2">If the trading strategy goes past its risk limits, such as if it loses more money than it’s allowed, tries to send an order larger than it’s allowed, or builds a position larger than it’s allowed, it prevents it from trading. </span><span class="koboSpan" id="kobo.1539.3">To keep our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1541.1"> simple, we will only implement risk checks on the maximum allowed order size, the maximum allowed position, and the maximum allowed loss for each trading instrument in the client’s trading system. </span><span class="koboSpan" id="kobo.1541.2">The source code for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1543.1"> can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1544.1">Chapter9/trading/strategy/risk_manager.h</span></strong><span class="koboSpan" id="kobo.1545.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">Chapter9/trading/strategy/risk_manager.cpp</span></strong><span class="koboSpan" id="kobo.1547.1"> source files. </span><span class="koboSpan" id="kobo.1547.2">First, we will declare an enumeration and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1548.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1549.1"> struct. </span><span class="koboSpan" id="kobo.1549.2">We discussed the details of this component in </span><em class="italic"><span class="koboSpan" id="kobo.1550.1">Chapter</span></em><span class="koboSpan" id="kobo.1551.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1552.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.1553.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.1554.1">Designing a framework for low-latency C++ trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1555.1">algorithms</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1556.1"> section.</span></span></p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.1557.1">Defining the RiskCfg structure</span></h2>
<p><span class="koboSpan" id="kobo.1558.1">First, we will </span><a id="_idIndexMarker1305"/><span class="koboSpan" id="kobo.1559.1">define a structure that holds risk configurations. </span><span class="koboSpan" id="kobo.1559.2">This is called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">RiskCfg</span></strong><span class="koboSpan" id="kobo.1561.1"> struct and is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">Chapter9/common/types.h</span></strong><span class="koboSpan" id="kobo.1563.1"> header file. </span><span class="koboSpan" id="kobo.1563.2">The risk configuration holds the </span><span class="No-Break"><span class="koboSpan" id="kobo.1564.1">following parameters:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1565.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">max_order_size_</span></strong><span class="koboSpan" id="kobo.1567.1"> member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1568.1">Qty</span></strong><span class="koboSpan" id="kobo.1569.1"> type. </span><span class="koboSpan" id="kobo.1569.2">It represents the maximum allowed order size that a strategy is allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">to send.</span></span></li>
<li><span class="koboSpan" id="kobo.1571.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1572.1">max_position_</span></strong><span class="koboSpan" id="kobo.1573.1"> member variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1574.1">Qty</span></strong><span class="koboSpan" id="kobo.1575.1"> type. </span><span class="koboSpan" id="kobo.1575.2">This represents the maximum position that a strategy is allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.1576.1">to build.</span></span></li>
<li><span class="koboSpan" id="kobo.1577.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1578.1">max_loss_</span></strong><span class="koboSpan" id="kobo.1579.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">double</span></strong><span class="koboSpan" id="kobo.1581.1"> type. </span><span class="koboSpan" id="kobo.1581.2">This is the maximum allowed loss before the trading strategy is shut off from </span><span class="No-Break"><span class="koboSpan" id="kobo.1582.1">trading further.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1583.1">We must also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1584.1">toString()</span></strong><span class="koboSpan" id="kobo.1585.1"> method to the structure for </span><span class="No-Break"><span class="koboSpan" id="kobo.1586.1">logging purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1587.1">
  struct RiskCfg {
    Qty max_order_size_ = 0;
    Qty max_position_ = 0;
    double max_loss_ = 0;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "RiskCfg{"
         &lt;&lt; "max-order-size:" &lt;&lt;
           qtyToString(max_order_size_) &lt;&lt; " "
         &lt;&lt; "max-position:" &lt;&lt; qtyToString(max_position_)
         &lt;&lt; " "
         &lt;&lt; "max-loss:" &lt;&lt; max_loss_
         &lt;&lt; "}";
      return ss.str();
    }
  };</span></pre>
<p><span class="koboSpan" id="kobo.1588.1">We will </span><a id="_idIndexMarker1306"/><span class="koboSpan" id="kobo.1589.1">define another configuration structure in the next section. </span><span class="koboSpan" id="kobo.1589.2">This structure will be used to </span><span class="No-Break"><span class="koboSpan" id="kobo.1590.1">configure </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">TradeEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1592.1">.</span></span></p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.1593.1">Defining the TradeEngineCfg structure</span></h2>
<p><span class="koboSpan" id="kobo.1594.1">First, we </span><a id="_idIndexMarker1307"/><span class="koboSpan" id="kobo.1595.1">must define a structure to encapsulate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1597.1"> configurations. </span><span class="koboSpan" id="kobo.1597.2">We will call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">TradeEngineCfg</span></strong><span class="koboSpan" id="kobo.1599.1">. </span><span class="koboSpan" id="kobo.1599.2">This is what we use as the higher-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1601.1"> configuration and is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">Chapter9/common/types.h</span></strong><span class="koboSpan" id="kobo.1603.1"> header file. </span><span class="koboSpan" id="kobo.1603.2">It has the following important </span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">data members:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1605.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">clip_</span></strong><span class="koboSpan" id="kobo.1607.1"> member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">Qty</span></strong><span class="koboSpan" id="kobo.1609.1"> type. </span><span class="koboSpan" id="kobo.1609.2">This is what the trading strategies will use as the quantity of the orders that they </span><span class="No-Break"><span class="koboSpan" id="kobo.1610.1">send out.</span></span></li>
<li><span class="koboSpan" id="kobo.1611.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">threshold_</span></strong><span class="koboSpan" id="kobo.1613.1"> member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">double</span></strong><span class="koboSpan" id="kobo.1615.1"> type. </span><span class="koboSpan" id="kobo.1615.2">This will be used by the trading strategies and will be used against the feature values to decide if a trading decision needs to be made </span><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">or not.</span></span></li>
<li><span class="koboSpan" id="kobo.1617.1">The final member is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">risk_cfg_</span></strong><span class="koboSpan" id="kobo.1619.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">RiskCfg</span></strong><span class="koboSpan" id="kobo.1621.1"> type. </span><span class="koboSpan" id="kobo.1621.2">We defined this previously so that it can hold the </span><span class="No-Break"><span class="koboSpan" id="kobo.1622.1">risk configuration.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1623.1">As usual, we must also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">toString()</span></strong><span class="koboSpan" id="kobo.1625.1"> method to convert these objects into strings for logging purposes. </span><span class="koboSpan" id="kobo.1625.2">All the code described here can be seen in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1626.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1627.1">
  struct TradeEngineCfg {
    Qty clip_ = 0;
    double threshold_ = 0;
    RiskCfg risk_cfg_;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "TradeEngineCfg{"
         &lt;&lt; "clip:" &lt;&lt; qtyToString(clip_) &lt;&lt; " "
         &lt;&lt; "thresh:" &lt;&lt; threshold_ &lt;&lt; " "
         &lt;&lt; "risk:" &lt;&lt; risk_cfg_.toString()
         &lt;&lt; "}";
      return ss.str();
    }
  };</span></pre>
<p><span class="koboSpan" id="kobo.1628.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.1630.1"> type </span><a id="_idIndexMarker1308"/><span class="koboSpan" id="kobo.1631.1">we are defining here is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">std::array</span></strong><span class="koboSpan" id="kobo.1633.1"> of these </span><strong class="source-inline"><span class="koboSpan" id="kobo.1634.1">TradeEngineCfg</span></strong><span class="koboSpan" id="kobo.1635.1"> objects and is large enough to hold all possible </span><strong class="source-inline"><span class="koboSpan" id="kobo.1636.1">TickerId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1637.1">values (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1638.1">ME_MAX_TICKERS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1639.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1640.1">
  typedef std::array&lt;TradeEngineCfg, ME_MAX_TICKERS&gt;
    TradeEngineCfgHashMap;</span></pre>
<p><span class="koboSpan" id="kobo.1641.1">Now, we need to define a type to represent the outcome of risk checks – the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1642.1">RiskCheckResult</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1643.1"> enumeration.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.1644.1">Declaring the RiskCheckResult enumeration</span></h2>
<p><span class="koboSpan" id="kobo.1645.1">First, we</span><a id="_idIndexMarker1309"/><span class="koboSpan" id="kobo.1646.1"> will formally declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1647.1">RiskCheckResult</span></strong><span class="koboSpan" id="kobo.1648.1"> enumeration we encountered before. </span><span class="koboSpan" id="kobo.1648.2">But before we do that, let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1649.1">include</span></strong><span class="koboSpan" id="kobo.1650.1"> files we need in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1651.1">risk_manager.h</span></strong><span class="koboSpan" id="kobo.1652.1"> header file. </span><span class="koboSpan" id="kobo.1652.2">We will also need to forward declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1653.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1654.1"> class we built before so that we can use it without running into circular header </span><span class="No-Break"><span class="koboSpan" id="kobo.1655.1">dependency issues:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1656.1">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "position_keeper.h"
#include "om_order.h"
using namespace Common;
namespace Trading {
  class OrderManager;</span></pre>
<p><span class="koboSpan" id="kobo.1657.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1658.1">RiskCheckResult</span></strong><span class="koboSpan" id="kobo.1659.1"> enumeration</span><a id="_idIndexMarker1310"/><span class="koboSpan" id="kobo.1660.1"> is used to encapsulate information about the outcome of a risk check in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1661.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1662.1">. </span><span class="koboSpan" id="kobo.1662.2">Let’s look at these values in </span><span class="No-Break"><span class="koboSpan" id="kobo.1663.1">more detail:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">INVALID</span></strong><span class="koboSpan" id="kobo.1665.1"> represents an invalid </span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1">sentinel value.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1667.1">ORDER_TOO_LARGE</span></strong><span class="koboSpan" id="kobo.1668.1"> means that the risk check failed because the order quantity that we are attempting to send would exceed the maximum allowed order </span><span class="No-Break"><span class="koboSpan" id="kobo.1669.1">quantity limit.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1670.1">POSITION_TOO_LARGE</span></strong><span class="koboSpan" id="kobo.1671.1"> means that the current position, plus the order quantity on the side we are attempting to send, would cause us to potentially exceed the maximum position limit that’s been configured </span><span class="No-Break"><span class="koboSpan" id="kobo.1672.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1673.1">RiskManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1674.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1675.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1676.1">LOSS_TOO_LARGE</span></strong><span class="koboSpan" id="kobo.1677.1"> enumeration represents the fact that the risk check failed because the trading strategy’s total loss (realized plus unrealized loss) is above what is allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.1678.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">RiskManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1681.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1682.1">ALLOWED</span></strong><span class="koboSpan" id="kobo.1683.1"> enumeration is a value that represents that all risk checks passed successfully. </span><span class="koboSpan" id="kobo.1683.2">As mentioned previously, this is the only value that allows the trading strategy to send additional orders to </span><span class="No-Break"><span class="koboSpan" id="kobo.1684.1">the exchange:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.1685.1">
  enum class RiskCheckResult : int8_t {
    INVALID = 0,
    ORDER_TOO_LARGE = 1,
    POSITION_TOO_LARGE = 2,
    LOSS_TOO_LARGE = 3,
    ALLOWED = 4
  };</span></pre>
<p><span class="koboSpan" id="kobo.1686.1">We will also</span><a id="_idIndexMarker1311"/><span class="koboSpan" id="kobo.1687.1"> add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1688.1">riskCheckResultToString()</span></strong><span class="koboSpan" id="kobo.1689.1"> method to convert these enumerations into strings for </span><span class="No-Break"><span class="koboSpan" id="kobo.1690.1">logging purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1691.1">
  inline auto riskCheckResultToString(RiskCheckResult
    result) {
    switch (result) {
      case RiskCheckResult::INVALID:
        return "INVALID";
      case RiskCheckResult::ORDER_TOO_LARGE:
        return "ORDER_TOO_LARGE";
      case RiskCheckResult::POSITION_TOO_LARGE:
        return "POSITION_TOO_LARGE";
      case RiskCheckResult::LOSS_TOO_LARGE:
        return "LOSS_TOO_LARGE";
      case RiskCheckResult::ALLOWED:
        return "ALLOWED";
    }
    return "";
  }</span></pre>
<p><span class="koboSpan" id="kobo.1692.1">In the next </span><a id="_idIndexMarker1312"/><span class="koboSpan" id="kobo.1693.1">section, we will define the basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.1694.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1695.1"> struct, which holds the information we need to perform risk checks for a single </span><span class="No-Break"><span class="koboSpan" id="kobo.1696.1">trading instrument.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.1697.1">Defining the RiskInfo structure</span></h2>
<p><span class="koboSpan" id="kobo.1698.1">As </span><a id="_idIndexMarker1313"/><span class="koboSpan" id="kobo.1699.1">mentioned previously, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1700.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1701.1"> struct holds the information needed to perform risk checks for a single trading instrument. </span><span class="koboSpan" id="kobo.1701.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1702.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1703.1"> class maintains and manages a container of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1704.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1705.1"> objects. </span><span class="koboSpan" id="kobo.1705.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1706.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1707.1"> struct needs the following important </span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1">data members:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1709.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1710.1">const</span></strong><span class="koboSpan" id="kobo.1711.1"> pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1712.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.1713.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1714.1">position_info_</span></strong><span class="koboSpan" id="kobo.1715.1">. </span><span class="koboSpan" id="kobo.1715.2">This will be used to fetch the position and PnL information for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1716.1">trading instrument.</span></span></li>
<li><span class="koboSpan" id="kobo.1717.1">An object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">risk_cfg_</span></strong><span class="koboSpan" id="kobo.1719.1">) of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1720.1">RiskCfg</span></strong><span class="koboSpan" id="kobo.1721.1"> type to hold the configured risk limits for this instrument. </span><span class="koboSpan" id="kobo.1721.2">These are the limits that will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1722.1">checked against:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.1723.1">
  struct RiskInfo {
    const PositionInfo *position_info_ = nullptr;
    RiskCfg risk_cfg_;</span></pre>
<p><span class="koboSpan" id="kobo.1724.1">Let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1725.1">toString()</span></strong><span class="koboSpan" id="kobo.1726.1"> method to this class for </span><span class="No-Break"><span class="koboSpan" id="kobo.1727.1">logging purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1728.1">
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "RiskInfo" &lt;&lt; "["
         &lt;&lt; "pos:" &lt;&lt; position_info_-&gt;toString() &lt;&lt; " "
         &lt;&lt; risk_cfg_.toString()
         &lt;&lt; "]";
      return ss.str();
    }</span></pre>
<p><span class="koboSpan" id="kobo.1729.1">Finally, we</span><a id="_idIndexMarker1314"/><span class="koboSpan" id="kobo.1730.1"> must define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1731.1">TickerRiskInfoHashMap</span></strong><span class="koboSpan" id="kobo.1732.1"> type, which is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1733.1">std::array</span></strong><span class="koboSpan" id="kobo.1734.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1735.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1736.1"> objects of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1737.1">ME_MAX_TICKERS</span></strong><span class="koboSpan" id="kobo.1738.1"> size. </span><span class="koboSpan" id="kobo.1738.2">We will use this as a hash map of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1739.1">TickerId</span></strong><span class="koboSpan" id="kobo.1740.1"> to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1741.1">RiskInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1742.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1743.1">
  typedef std::array&lt;RiskInfo, ME_MAX_TICKERS&gt;
    TickerRiskInfoHashMap;</span></pre>
<p><span class="koboSpan" id="kobo.1744.1">Next, we will look at the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1745.1">checkPreTradeRisk()</span></strong><span class="koboSpan" id="kobo.1746.1"> method, which performs the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.1747.1">risk checks.</span></span></p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.1748.1">Performing risk checks in RiskInfo</span></h2>
<p><span class="koboSpan" id="kobo.1749.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1750.1">checkPreTradeRisk()</span></strong><span class="koboSpan" id="kobo.1751.1"> method accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1752.1">Side</span></strong><span class="koboSpan" id="kobo.1753.1"> argument and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1754.1">Qty</span></strong><span class="koboSpan" id="kobo.1755.1"> argument </span><a id="_idIndexMarker1315"/><span class="koboSpan" id="kobo.1756.1">and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1757.1">RiskCheckResult</span></strong><span class="koboSpan" id="kobo.1758.1"> enumeration value, depending on whether the risk check passes or fails for </span><span class="No-Break"><span class="koboSpan" id="kobo.1759.1">some reason:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1760.1">
    auto checkPreTradeRisk(Side side, Qty qty) const
      noexcept {</span></pre>
<p><span class="koboSpan" id="kobo.1761.1">First, it checks if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1762.1">qty</span></strong><span class="koboSpan" id="kobo.1763.1"> argument that’s passed to the method is larger than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">max_order_size_</span></strong><span class="koboSpan" id="kobo.1765.1"> member in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1766.1">RiskCfg</span></strong><span class="koboSpan" id="kobo.1767.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1768.1">risk_cfg_</span></strong><span class="koboSpan" id="kobo.1769.1">). </span><span class="koboSpan" id="kobo.1769.2">If this is the case, the risk check fails, and it returns the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1770.1">RiskCheckResult::ORDER_TOO_LARGE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1771.1"> enumeration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1772.1">
      if (UNLIKELY(qty &gt; risk_cfg_.max_order_size_))
        return RiskCheckResult::ORDER_TOO_LARGE;</span></pre>
<p><span class="koboSpan" id="kobo.1773.1">Then, it checks if the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.1774.1">position_</span></strong><span class="koboSpan" id="kobo.1775.1"> (which it fetches from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1776.1">position_info_</span></strong><span class="koboSpan" id="kobo.1777.1"> data member), plus the additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1778.1">qty</span></strong><span class="koboSpan" id="kobo.1779.1"> we want to send, exceeds the maximum allowed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1780.1">max_position_ limit</span></strong><span class="koboSpan" id="kobo.1781.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1782.1">RiskCfg</span></strong><span class="koboSpan" id="kobo.1783.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1784.1">risk_cfg_</span></strong><span class="koboSpan" id="kobo.1785.1">). </span><span class="koboSpan" id="kobo.1785.2">Note that it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1786.1">sideToValue(side)</span></strong><span class="koboSpan" id="kobo.1787.1"> method here to correctly compute what the position could be if this new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1788.1">qty</span></strong><span class="koboSpan" id="kobo.1789.1"> were to be executed and then uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1790.1">std::abs()</span></strong><span class="koboSpan" id="kobo.1791.1"> method to correctly compare against the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1792.1">max_position_</span></strong><span class="koboSpan" id="kobo.1793.1"> parameter. </span><span class="koboSpan" id="kobo.1793.2">In the case of a failure, it signifies the error by returning the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1794.1">RiskCheckResult::POSITION_TOO_LARGE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1795.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1796.1">
      if (UNLIKELY(std::abs(position_info_-&gt;position_ +
        sideToValue(side) * static_cast&lt;int32_t&gt;(qty)) &gt;
          static_cast&lt;int32_t&gt;(risk_cfg_.max_position_)))
        return RiskCheckResult::POSITION_TOO_LARGE;</span></pre>
<p><span class="koboSpan" id="kobo.1797.1">Finally, it </span><a id="_idIndexMarker1316"/><span class="koboSpan" id="kobo.1798.1">checks the last risk metric in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1799.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1800.1">, which is the total loss. </span><span class="koboSpan" id="kobo.1800.2">It checks </span><strong class="source-inline"><span class="koboSpan" id="kobo.1801.1">total_pnl_</span></strong><span class="koboSpan" id="kobo.1802.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1803.1">position_info_</span></strong><span class="koboSpan" id="kobo.1804.1"> against the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1805.1">max_loss_</span></strong><span class="koboSpan" id="kobo.1806.1"> parameter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1807.1">risk_cfg_</span></strong><span class="koboSpan" id="kobo.1808.1"> configuration. </span><span class="koboSpan" id="kobo.1808.2">If the loss exceeds the max loss allowed, it returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1809.1">RiskCheckResult::LOSS_TOO_LARGE</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1810.1">enumeration value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1811.1">
      if (UNLIKELY(position_info_-&gt;total_pnl_ &lt;
        risk_cfg_.max_loss_))
        return RiskCheckResult::LOSS_TOO_LARGE;</span></pre>
<p><span class="koboSpan" id="kobo.1812.1">Finally, if all the risk checks pass successfully, it returns the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">RiskCheckResult::ALLOWED</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1814.1"> value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1815.1">
      return RiskCheckResult::ALLOWED;
    }</span></pre>
<p><span class="koboSpan" id="kobo.1816.1">This important method concludes the design and implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1817.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1818.1"> struct. </span><span class="koboSpan" id="kobo.1818.2">Now, we can start building the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1819.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1820.1"> class, which is used by the other components </span><span class="No-Break"><span class="koboSpan" id="kobo.1821.1">we covered.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.1822.1">Designing the data members in RiskManager</span></h2>
<p><span class="koboSpan" id="kobo.1823.1">Now, we will </span><a id="_idIndexMarker1317"/><span class="koboSpan" id="kobo.1824.1">design our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1825.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1826.1">, starting by defining the data members that make up this class. </span><span class="koboSpan" id="kobo.1826.2">The key member is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1827.1">ticker_risk_</span></strong><span class="koboSpan" id="kobo.1828.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1829.1">TickerRiskInfoHashMap</span></strong><span class="koboSpan" id="kobo.1830.1"> type and holds </span><strong class="source-inline"><span class="koboSpan" id="kobo.1831.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1832.1"> objects. </span><span class="koboSpan" id="kobo.1832.2">We defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1833.1">this previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1834.1">
  class RiskManager {
  private:
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    TickerRiskInfoHashMap ticker_risk_;
  };</span></pre>
<p><span class="koboSpan" id="kobo.1835.1">Next, we will</span><a id="_idIndexMarker1318"/><span class="koboSpan" id="kobo.1836.1"> learn how to initialize the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1837.1">RiskManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1838.1"> class.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.1839.1">Initializing our RiskManager class</span></h2>
<p><span class="koboSpan" id="kobo.1840.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1841.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1842.1"> constructor</span><a id="_idIndexMarker1319"/><span class="koboSpan" id="kobo.1843.1"> expects a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1844.1">Logger</span></strong><span class="koboSpan" id="kobo.1845.1"> object, a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1846.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.1847.1"> object, and a reference to an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1848.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.1849.1"> type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1850.1">ticker_cfg</span></strong><span class="koboSpan" id="kobo.1851.1">) that holds the risk configurations. </span><span class="koboSpan" id="kobo.1851.2">It initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1852.1">logger_</span></strong><span class="koboSpan" id="kobo.1853.1"> member variable and stores the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1854.1">PositionInfo</span></strong><span class="koboSpan" id="kobo.1855.1"> objects from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1856.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.1857.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1858.1">getPositionInfo()</span></strong><span class="koboSpan" id="kobo.1859.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1860.1">RiskCfg</span></strong><span class="koboSpan" id="kobo.1861.1"> objects from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1862.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.1863.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1864.1">risk_cfg_</span></strong><span class="koboSpan" id="kobo.1865.1">) in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1866.1">TickerRiskInfoHashMap</span></strong><span class="koboSpan" id="kobo.1867.1"> data </span><span class="No-Break"><span class="koboSpan" id="kobo.1868.1">member (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1869.1">ticker_risk_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1870.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1871.1">
  RiskManager::RiskManager(Common::Logger *logger, const
    PositionKeeper *position_keeper, const
      TradeEngineCfgHashMap &amp;ticker_cfg)
      : logger_(logger) {
    for (TickerId i = 0; i &lt; ME_MAX_TICKERS; ++i) {
      ticker_risk_.at(i).position_info_ = position_keeper
        -&gt;getPositionInfo(i);
      ticker_risk_.at(i).risk_cfg_ =
        ticker_cfg[i].risk_cfg_;
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1872.1">Next, we will implement the final task that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1873.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1874.1"> needs to perform – performing </span><span class="No-Break"><span class="koboSpan" id="kobo.1875.1">risk checks.</span></span></p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.1876.1">Performing risk checks in RiskManager</span></h2>
<p><span class="koboSpan" id="kobo.1877.1">Given a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1878.1">TickerId</span></strong><span class="koboSpan" id="kobo.1879.1"> for an</span><a id="_idIndexMarker1320"/><span class="koboSpan" id="kobo.1880.1"> instrument, as well as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1881.1">Side</span></strong><span class="koboSpan" id="kobo.1882.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1883.1">Qty</span></strong><span class="koboSpan" id="kobo.1884.1"> for the order we expect to send, performing risk checks for it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1885.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1886.1"> is straightforward. </span><span class="koboSpan" id="kobo.1886.2">It simply fetches the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.1887.1">RiskInfo</span></strong><span class="koboSpan" id="kobo.1888.1"> object corresponding to the instrument, calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1889.1">RiskInfo::checkPreTradeRisk()</span></strong><span class="koboSpan" id="kobo.1890.1"> method, and returns the return value from </span><span class="No-Break"><span class="koboSpan" id="kobo.1891.1">that method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1892.1">
    auto checkPreTradeRisk(TickerId ticker_id, Side side,
      Qty qty) const noexcept {
      return ticker_risk_.at(ticker_id)
        .checkPreTradeRisk(side, qty);
    }</span></pre>
<p><span class="koboSpan" id="kobo.1893.1">That concludes our design and implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1894.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1895.1"> component, as well as all the components we needed before we can start putting them together and building our trading strategies. </span><span class="koboSpan" id="kobo.1895.2">We will start with that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1896.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1897.1">One important note is that we will need to build all the components presented in this chapter, as well as </span><em class="italic"><span class="koboSpan" id="kobo.1898.1">Building the C++ Market-Making and Liquidity-Taking Algorithms</span></em><span class="koboSpan" id="kobo.1899.1"> chapter before we can build and run a meaningful trading client. </span><span class="koboSpan" id="kobo.1899.2">Since our ecosystem consists of a server (trading exchange) and client (trading client) infrastructure, we will need to wait until the </span><em class="italic"><span class="koboSpan" id="kobo.1900.1">Building the C++ Market-Making and Liquidity-Taking Algorithms</span></em><span class="koboSpan" id="kobo.1901.1"> chapter, the </span><em class="italic"><span class="koboSpan" id="kobo.1902.1">Building and running the main trading application</span></em><span class="koboSpan" id="kobo.1903.1"> section, before we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1904.1">full ecosystem.</span></span></p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.1905.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1906.1">In this chapter, our primary focus was on adding intelligence and sophistication to the market participants’ trading systems. </span><span class="koboSpan" id="kobo.1906.2">First, we discussed our market-making and liquidity-taking trading strategies. </span><span class="koboSpan" id="kobo.1906.3">We discussed the motivation behind these strategies, how they seek to profit in the markets, and the trading dynamics of </span><span class="No-Break"><span class="koboSpan" id="kobo.1907.1">these algorithms.</span></span></p>
<p><span class="koboSpan" id="kobo.1908.1">We implemented the important components that make up the intelligence around our trading strategies. </span><span class="koboSpan" id="kobo.1908.2">The first one was the feature engine that’s used to compute trading features/signals from the market data so that they can be used by the trading strategies to make informed trading decisions. </span><span class="koboSpan" id="kobo.1908.3">The next one was the position keeper, which is in charge of tracking a trading strategy’s positions and PnLs as the strategy’s orders are executed in the market. </span><span class="koboSpan" id="kobo.1908.4">After, we looked at the order manager component, which sends and manages live orders in the market to simplify the trading strategy’s implementation. </span><span class="koboSpan" id="kobo.1908.5">The risk manager was the final and possibly the most vital component that we looked at since it is in charge of tracking and regulating the risk that a trading algorithm has currently taken, as well as any additional risk it is trying </span><span class="No-Break"><span class="koboSpan" id="kobo.1909.1">to take.</span></span></p>
<p><span class="koboSpan" id="kobo.1910.1">Now that we have all the important components in one place, in the next chapter, we will build our market-making strategy to provide passive liquidity in the market. </span><span class="koboSpan" id="kobo.1910.2">Then, we will build the liquidity-taking trading algorithm to send aggressive orders and initiate and manage positions in the market. </span><span class="koboSpan" id="kobo.1910.3">Finally, we will build our trade engine framework, which will house all the necessary components and build and drive the trading algorithms we built. </span><span class="koboSpan" id="kobo.1910.4">By doing this, we will complete our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.1911.1">trading ecosystem.</span></span></p>
</div>
</body></html>