["```cpp\n\n[10 x i64]\n```", "```cpp\n\n{ float, i64, float }\n```", "```cpp\n\n<{ float, i64, float }>\n```", "```cpp\n\n%el2 = extractvalue [10 x i64] %x, 1\n```", "```cpp\n\n%xnew = insertvalue [10 x i64] %x, i64 %el2, 0\n```", "```cpp\n\n%color = extractvalue { float, float, i64 } %pt, 2\n```", "```cpp\n\n@arr = common global [8 x i64] zeroinitializer\n```", "```cpp\n\ndefine i64 @second() {\n  %1 = load i64, ptr getelementptr inbounds ([8 x i64], ptr @arr, i64 0, i64 1)\n  ret i64 %1\n}\n```", "```cpp\n\n if (auto *ArrayTy =\n                 llvm::dyn_cast<ArrayTypeDeclaration>(Ty)) {\n    llvm::Type *Component =\n        convertType(ArrayTy->getType());\n    Expr *Nums = ArrayTy->getNums();\n    uint64_t NumElements =\n        llvm::cast<IntegerLiteral>(Nums)\n            ->getValue()\n            .getZExtValue();\n    llvm::Type *T =\n        llvm::ArrayType::get(Component, NumElements);\n    // TypeCache is a mapping between the original\n    // TypeDeclaration (Ty) and the current Type (T).\n    return TypeCache[Ty] = T;\n}\n```", "```cpp\n\n  for (auto *D : Proc->getDecls()) {\n    if (auto *Var =\n            llvm::dyn_cast<VariableDeclaration>(D)) {\n      llvm::Type *Ty = mapType(Var);\n      if (Ty->isAggregateType()) {\n        llvm::Value *Val = Builder.CreateAlloca(Ty);\n        // The following method requires a BasicBlock (Curr),\n        // a VariableDeclation (Var), and an llvm::Value (Val)\n        writeLocalVariable(Curr, Var, Val);\n      }\n    }\n  }\n```", "```cpp\n\n    auto &Selectors = Var->getSelectors();\n    for (auto I = Selectors.begin(), E = Selectors.end();\n         I != E; ) {\n      if (auto *IdxSel =\n              llvm::dyn_cast<IndexSelector>(*I)) {\n        llvm::SmallVector<llvm::Value *, 4> IdxList;\n        while (I != E) {\n          if (auto *Sel =\n                  llvm::dyn_cast<IndexSelector>(*I)) {\n            IdxList.push_back(emitExpr(Sel->getIndex()));\n            ++I;\n          } else\n            break;\n        }\n        Val = Builder.CreateInBoundsGEP(Val->getType(), Val, IdxList);\n        Val = Builder.CreateLoad(\n            Val->getType(), Val);\n      }\n      // . . . Check for additional selectors and handle\n      // appropriately by generating getelementptr and load.\n      else {\n        llvm::report_fatal_error(\"Unsupported selector\");\n      }\n    }\n```", "```cpp\n\nllvm::Value *FieldIdx = llvm::ConstantInt::get(Int32Ty, Idx);\n```", "```cpp\n\nArg->addAttr(llvm::Attribute::InReg);\n```", "```cpp\n\n%intconv = bitcast float %fp to i32\n```", "```cpp\n\nTYPE Shape = RECORD\n               color: INTEGER;\n               PROCEDURE (VAR s: Shape) GetColor(): INTEGER;\n               PROCEDURE (VAR s: Shape) Area(): REAL;\n             END;\n```", "```cpp\n\nPROCEDURE (VAR s: Shape) GetColor(): INTEGER;\nBEGIN RETURN s.color; END GetColor;\n```", "```cpp\n\nPROCEDURE (VAR s: Shape) Area(): REAL;\nBEGIN HALT; END;\n```", "```cpp\n\nTYPE Circle = RECORD (Shape)\n                radius: REAL;\n                PROCEDURE (VAR s: Circle) Area(): REAL;\n              END;\n```", "```cpp\n\nPROCEDURE (VAR s: Circle) Area(): REAL;\nBEGIN RETURN 2 * radius * radius; END;\n```", "```cpp\n\nIF shape IS Circle THEN (* … *) END;\n```", "```cpp\n\n@Shape = type { i64 }\n```", "```cpp\n\n@Circle = type { i64, float }\n```", "```cpp\n\n@Shape = type { ptr, i64 }\n```", "```cpp\n\n  // Load a pointer from the corresponding location.\n  %ptrToShapeObj = load ptr, ...\n  // Load the first element of the Shape class.\n  %vtable = load ptr, ptr %ptrToShapeObj, align 8\n```", "```cpp\n\n%offsetToArea = getelementptr inbounds ptr, ptr %vtable, i64 1\n```", "```cpp\n\n%ptrToAreaFunction = load ptr, ptr %offsetToArea, align 8\n```", "```cpp\n\n  %funcCall = call noundef float %ptrToAreaFunction(ptr noundef nonnull align 8 dereferenceable(12) %ptrToShapeObj)\n```"]