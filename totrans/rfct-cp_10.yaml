- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Static Analysis in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the complex and demanding world of software development, ensuring the quality
    and reliability of code is not just a necessity but a discipline in itself. As
    C++ developers, we constantly seek methodologies and tools that can aid us in
    this quest. This chapter is dedicated to one such powerful approach: static analysis.
    Renowned for being both the fastest and the cheapest way to identify bugs, static
    analysis stands as a pillar in the software quality assurance process. We will
    delve into its intricacies, explore popular tools such as Clang-Tidy, PVS-Studio,
    and SonarQube, and understand how to effectively integrate static analysis into
    your C++ development workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: The essence of static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis is the examination of source code without executing it. This
    process, typically automated by various tools, involves scanning the code to identify
    potential errors, code smells, security vulnerabilities, and other issues. It’s
    akin to a thorough proofreading session where the code is scrutinized for quality
    and reliability before it ever runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why static analysis? Here are the reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed and cost-effectiveness**: The foremost advantage of static analysis
    is its speed and cost-effectiveness. It is arguably the fastest and cheapest method
    to find bugs. Automating the detection of issues drastically reduces the time
    and effort required compared to manual code reviews and other testing methods.
    Catching and resolving issues early in the development cycle significantly lowers
    the cost of fixes, which escalates if bugs are found later in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-execution bug detection**: Static analysis occurs before the code is
    executed, making it a proactive measure in software quality assurance. This pre-execution
    analysis allows developers to identify and rectify issues without the overhead
    of setting up testing environments or dealing with the complexities of running
    the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coding standard enforcement**: It helps in maintaining a consistent coding
    standard, ensuring that the code base adheres to the best practices and conventions
    of C++ programming. This enforcement not only improves code quality but also enhances
    maintainability and readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comprehensive coverage**: With the ability to scan the entire code base,
    static analysis provides a level of thoroughness that is challenging to achieve
    through manual methods. This comprehensive coverage ensures that no part of the
    code is overlooked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and reliability**: Early detection of security vulnerabilities is
    another critical benefit. Static analysis contributes significantly to the security
    and reliability of the application by catching vulnerabilities that might otherwise
    go unnoticed until exploitation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Educational aspect**: It also serves an educational purpose, enhancing developers’
    understanding of C++ and familiarizing them with common pitfalls and best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent sections, we’ll explore how to leverage static analysis to
    its fullest potential in C++ projects. Following this, in the next chapter, we
    will compare and contrast these insights with dynamic analysis, offering a complete
    picture of the analysis landscape in C++ software development.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging newer compiler versions for enhanced static analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the production environment often mandates specific, sometimes older, compiler
    versions for various reasons, including stability and compatibility, there is
    immense value in periodically building your project with newer versions of compilers.
    This practice serves as a forward-looking static analysis strategy, harnessing
    the advancements and improvements made in the latest compiler releases.
  prefs: []
  type: TYPE_NORMAL
- en: Newer compiler versions are frequently equipped with enhanced analysis capabilities,
    more sophisticated warning mechanisms, and updated interpretations of the C++
    standard. They can identify issues and potential code improvements that older
    compilers might overlook. By compiling with these cutting-edge tools, developers
    can proactively discover and address latent issues in their code base, ensuring
    that the code remains robust and compliant with evolving C++ standards.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this approach offers a preview of potential issues that might
    arise when an eventual update to the production compiler is undertaken. It provides
    an opportunity to future-proof the code base, making the transition to newer compiler
    versions smoother and more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, incorporating newer compiler versions into the build process, even
    if they are not used for production builds, is a strategic measure. It not only
    elevates the quality of the code through advanced static analysis but also prepares
    the code base for future technological shifts, ensuring a state of continuous
    improvement and readiness for advancement.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler settings to harden C++ code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the pursuit of robust and secure C++ code, configuring compiler settings
    plays a pivotal role. Compiler flags and options can significantly enhance code
    quality by enabling stricter error checking, warnings, and security features.
    This section focuses on recommended settings for three major compilers in the
    C++ ecosystem: the **GNU Compiler Collection** (**GCC**), Clang, and **Microsoft
    Visual C++** (**MSVC**). These settings are particularly valuable in a static
    analysis context as they enable the detection of potential issues at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: GCC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GCC is known for its extensive set of options that can help harden C++ code.
    Key flags include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Wall -Wextra`: Enables most warning messages, catching potential issues such
    as uninitialized variables, unused parameters, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Werror`: Treats all warnings as errors, forcing them to be addressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wshadow`: Warns whenever a local variable shadows another variable, which
    can lead to confusing bugs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wnon-virtual-dtor`: Warns if a class with virtual functions has a non-virtual
    destructor, which can lead to undefined behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-pedantic`: Enforces strict ISO C++ compliance, rejecting non-standard code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wconversion`: Warns on implicit conversions that may alter a value, useful
    for preventing data loss'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wsign-conversion`: Warns on implicit conversions that change the sign of
    a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang, part of the LLVM project, shares many flags with GCC but also provides
    additional checks and a reputation for generating more human-readable warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Weverything`: Enables every warning available in Clang, providing a comprehensive
    check of the code. This can be overwhelming, so it’s often used with selective
    disabling of less critical warnings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Werror`, `-Wall`, `-Wextra`, `-Wshadow`, `-Wnon-virtual-dtor`, `-pedantic`,
    `-Wconversion`, and `-Wsign-conversion`: Similar to GCC, these flags are also
    applicable in Clang and serve the same purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wdocumentation`: Warns about documentation inconsistencies, which is useful
    when maintaining large code bases with extensive comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fsanitize=address`, `-fsanitize=undefined`: Enables `AddressSanitizer` and
    `UndefinedBehaviorSanitizer` to catch memory corruption and undefined behavior
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MSVC, while having a different set of flags, also offers robust options for
    enhancing code safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/W4`: Enables a higher warning level, similar to `-Wall` in GCC/Clang. This
    includes most of the useful warnings for common issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/WX`: Treats all compiler warnings as errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdl`: Enables additional security checks, such as buffer overflow detection
    and integer overflow checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/GS`: Provides buffer security checks, helping prevent common security vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/analyze`: Enables static code analysis to detect issues such as memory leaks,
    uninitialized variables, and other potential errors at compile time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By utilizing these compiler settings, developers can significantly harden their
    C++ code, making it more secure, robust, and compliant with best practices. While
    the default settings of compilers catch many issues, enabling these additional
    flags ensures a much stricter and more thorough analysis of the code. It is important
    to note that while these settings can greatly enhance code quality, they should
    be complemented with good programming practices and regular code reviews for the
    best results. In the next chapter, we will shift our focus to dynamic analysis,
    another key component in ensuring the overall quality and security of C++ applications.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis via multiple compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of C++ development, leveraging the capabilities of compilers for
    static analysis is an often underutilized strategy. Compilers such as GCC and
    Clang come equipped with a plethora of compilation flags that enable rigorous
    static analysis, helping to identify potential issues without the need for additional
    tools. Employing these flags is not only convenient but also highly effective
    in enhancing code quality.
  prefs: []
  type: TYPE_NORMAL
- en: One best practice that I advocate for is building C++ projects with multiple
    compilers. Each compiler has its unique set of diagnostics, and by utilizing more
    than one, projects can gain a more comprehensive insight into potential issues.
    GCC and Clang are particularly notable for their similarity in supported flags,
    as well as their wide-ranging support for various architectures and operating
    systems. This compatibility makes it feasible to integrate both into a project’s
    build process for cross-checking code.
  prefs: []
  type: TYPE_NORMAL
- en: However, incorporating these practices in a Windows environment can present
    additional challenges. While GCC and Clang are versatile, projects often also
    benefit from the distinct diagnostics provided by MSVC. MSVC integrates seamlessly
    with the Windows ecosystem and brings to the table a different perspective on
    code analysis, which can be especially beneficial for projects targeting Windows
    platforms. Although managing multiple compilers might introduce some complexity,
    the payoff in identifying a broader spectrum of potential issues is invaluable.
    By embracing this multi-compiler approach, projects can significantly enhance
    their static analysis rigor, leading to more robust and reliable C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting compiler differences – unused private members in GCC versus Clang
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A nuanced understanding of the diagnostic capabilities of different compilers
    can be crucial in C++ development. This is exemplified in the way GCC and Clang
    handle unused private member variables. Consider the following class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `number` private member in the `NumberWrapper` class is initialized
    but never used. This situation presents a potential issue in the code that could
    indicate redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare how GCC and Clang handle unused private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number` unused private member. This lack of warning might lead to unintentional
    neglect of inefficiencies or redundancies in the class design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning: private field ''number'' is not used`. This precise diagnostic helps
    in promptly identifying and addressing potential oversights in the class’s implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting compiler differences – compiler checks for uninitialized variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When dealing with class variables in C++, ensuring proper initialization is
    crucial to prevent undefined behavior. This aspect is highlighted in how different
    compilers detect uninitialized but used variables. Consider the example of the
    `NumberWrapper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `number` member variable is not initialized, leading to undefined
    behavior when it’s used in the constructor. It can print something such as `init`
    `with: 32767`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now compare the approaches used by GCC and Clang in this regard:'
  prefs: []
  type: TYPE_NORMAL
- en: '`warning: ''num.NumberWrapper::number'' is used uninitialized`. This warning
    serves as an important alert to developers, drawing attention to the risk of using
    uninitialized variables, which can lead to unpredictable program behavior or subtle
    bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clang’s diagnostic approach**: Interestingly, Clang version 17 does not generate
    a warning for the same code, potentially allowing this oversight to go unnoticed
    in environments where only Clang is used. This demonstrates a case where relying
    solely on Clang might miss certain classes of errors that GCC can catch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two examples discussed previously offer compelling insights into the distinctive
    strengths and nuances of GCC and Clang’s diagnostic capabilities. These instances
    – one highlighting Clang’s ability to flag unused private fields and the other
    showcasing GCC’s proficiency in warning about uninitialized class variables –
    exemplify the importance of a multi-compiler strategy in C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing both Clang and GCC, developers can harness a more comprehensive
    and diversified static analysis process. Each compiler, with its unique set of
    warnings and checks, can reveal different potential issues or optimizations. Clang,
    known for its detailed and specific warnings, such as flagging unused private
    fields, complements GCC’s vigilant checks for fundamental yet critical issues
    such as uninitialized variables. This synergy between the compilers ensures a
    more thorough vetting of the code, leading to higher quality and more reliable
    and maintainable software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, the combination of Clang and GCC does not just add value in terms
    of the sum of their individual capabilities; it creates a more robust and holistic
    environment for static analysis. As the C++ language and its compilers continue
    to evolve, staying adaptable and open to multiple tools for static analysis remains
    a best practice for developers aiming for excellence in their craft. This approach
    aligns well with the ever-present goal in software development: writing clean,
    efficient, and error-free code.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring static analysis with Clang-Tidy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we delve deeper into the realm of static analysis, a tool that stands out
    for its versatility and depth is Clang-Tidy. Developed by the LLVM Foundation,
    the same organization behind the Clang compiler, Clang-Tidy is a linter and static
    analysis tool designed for C++ code. It extends beyond the capabilities of what
    a traditional compiler would check, offering a range of diagnostics that include
    stylistic errors, programming mistakes, and even subtle bugs that are often missed
    during regular code reviews. Previously, we explored how Clang-Tidy can be adept
    at code formatting; now, we will explore its prowess in static analysis, uncovering
    its ability to scrutinize C++ code at a level that ensures not just conformity
    but also excellence in coding standards.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy works by using the Clang frontend to parse C++ code, enabling it
    to understand the code’s structure and syntax in depth. This deep understanding
    allows Clang-Tidy to perform complex checks that go beyond mere textual analysis,
    examining the code’s semantics and even the flow of execution. It’s not just about
    finding syntactic discrepancies; it’s about understanding the code’s behavior
    and intent.
  prefs: []
  type: TYPE_NORMAL
- en: Categories of checks in Clang-Tidy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Tidy categorizes its checks into several groups, each targeting specific
    types of issues. Let’s break down these categories and explore examples for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance checks**: Focus on identifying inefficient patterns in the code
    that can slow down execution; for example, unnecessary copying of objects. Clang-Tidy
    can flag cases where an object is copied but could be moved or passed by reference
    to avoid the overhead of copying:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`for` loops with range-based `for` loops for better readability and safety:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bug detection**: Identify potential errors or logical bugs in the code; for
    example, detecting null pointer dereferences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Style checks**: Enforce specific coding styles for consistency and readability;
    for example, enforcing variable naming conventions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Readability checks**: Focus on making the code more understandable and maintainable;
    for example, simplifying complex Boolean expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Security checks**: Target potential security vulnerabilities; for example,
    highlighting uses of dangerous functions known to pose security risks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expanding Clang-Tidy’s capabilities with custom checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Tidy’s versatility is further enhanced by its support for custom checks,
    allowing companies and projects to tailor static analysis to their specific needs
    and coding standards. This customization capability has led to the creation of
    various categories of checks, each aligning with the guidelines of different organizations
    or projects. Next, we explore some notable examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`google-runtime-references` enforces Google’s preference for pointers over
    non-const references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google’s Abseil checks**: Abseil is an open source collection of C++ library
    code developed by Google. Checks specific to Abseil ensure adherence to the library’s
    best practices, such as avoiding certain deprecated functions or classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuchsia checks**: Tailored for the Fuchsia operating system, these checks
    enforce coding standards and best practices specific to the Fuchsia project. They
    help maintain consistency and quality in the code base contributing to this OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zircon checks**: Zircon is the core platform that powers the Fuchsia OS.
    Clang-Tidy includes checks tailored to Zircon’s development, focusing on its unique
    architecture and development standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Darwin checks**: These checks are specifically designed for Darwin, the open
    source Unix-like operating system released by Apple. They ensure compliance with
    Darwin’s development practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLVM checks (llvm-*)**: These checks are designed to enforce LLVM coding
    standards. They are particularly useful for developers contributing to LLVM or
    its subprojects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C++ Core Guidelines checks**: Clang-Tidy includes checks that enforce the
    C++ Core Guidelines, a set of best practices for writing modern C++. This includes
    rules for type safety, resource management, and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-pro-type-member-init` ensures that class members are properly
    initialized. `cppcoreguidelines-pro-type-reinterpret-cast` warns against the use
    of `reinterpret_cast`, encouraging safer casting alternatives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-non-private-member-variables-in-classes` discourages the
    use of non-private member variables to maintain encapsulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-avoid-magic-numbers` help identify hardcoded numbers that
    may not have an obvious meaning, promoting readability and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-avoid-c-arrays` and `cppcoreguidelines-avoid-non-const-global-variables`,
    which promote the use of modern C++ constructs such as `std::array` or `std::vector`
    over C-style arrays and discourage the use of non-const global variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-pro-bounds-array-to-pointer-decay` and `cppcoreguidelines-pro-bounds-constant-array-index`
    warn against common pitfalls that can lead to **out-of-bounds** (**OOB**) errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-owning-memory` guides developers on when and how to use
    smart pointers such as `std::unique_ptr` or `std::shared_ptr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule of Five and Rule of Zero checks**: Clang-Tidy enforces the Rule of Five
    and Rule of Zero in C++ class design, ensuring that classes managing resources
    correctly implement copy and move constructors/assignment operators or avoid managing
    resources manually, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-special-member-functions` (ensuring the correct implementation
    of special member functions) and `cppcoreguidelines-interfaces-global-init` (avoiding
    global initialization order issues).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adherence to the C++ Core Guidelines via Clang-Tidy checks can significantly
    improve the quality of C++ code, making it more robust, maintainable, and aligned
    with modern C++ practices. These checks cover a wide range of best practices and
    are generally considered good to follow for most C++ projects, especially those
    aiming to leverage modern C++ features effectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Check packages for standards compliance**: Clang-Tidy offers “packages” of
    checks that help ensure compliance with certain high-level standards:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-performance C++ (hi-cpp)**: These checks focus on ensuring that the
    code is optimized for performance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certifications**: For projects that require adherence to specific certification
    standards (such as MISRA, CERT, and so on), Clang-Tidy offers checks that help
    align the code with these standards, although it’s important to note that using
    these checks alone may not be sufficient for full compliance with such certifications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add custom checks means that Clang-Tidy is not just a static
    analysis tool but a platform that can adapt to various coding standards and practices.
    This adaptability makes it an ideal choice for projects ranging from open source
    libraries to commercial software, each with its unique set of requirements and
    standards. By leveraging these specialized checks, teams can ensure that their
    code not only adheres to general best practices in C++ but also aligns with specific
    guidelines and nuances of their project or organization.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning Clang-Tidy for customized static analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring Clang-Tidy effectively is key to harnessing its full potential
    in a C++ project. This involves not just enabling and disabling certain checks
    but also controlling how specific parts of the code are analyzed. By customizing
    its behavior, developers can ensure that Clang-Tidy’s output is both relevant
    and actionable, focusing on the most important aspects of their code base. Let’s
    take a closer look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--checks=` option to enable specific checks, and prepend `-` to disable others.
    For instance, to turn on performance checks while turning off a specific one,
    you might use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NOLINT` comment to suppress all warnings for a specific line of code. This
    is a broad approach and might hide more than intended:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NOLINT(check-name)` to suppress specific warnings. This approach is preferable
    as it prevents over-suppression of potentially useful warnings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`--warnings-as-errors=` option. This can be applied globally or to specific
    checks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.clang-tidy` file at the project’s root. This file should list enabled checks
    and other configurations, as in the following example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Proper configuration of Clang-Tidy is crucial for effective static analysis
    in C++. By selectively enabling checks, specifically suppressing warnings where
    necessary, and treating critical warnings as errors, teams can maintain high code
    quality standards. The ability to fine-tune the analysis on a line-by-line basis
    with specific suppression comments ensures that Clang-Tidy provides focused and
    relevant feedback, making it an invaluable tool in the C++ developer’s toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of static analysis tools – comparing PVS-Studio, SonarQube, and others
    to Clang-Tidy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis tools are essential for ensuring code quality and adherence
    to best practices. While Clang-Tidy is a prominent tool in this space, particularly
    for C++ projects, there are other significant tools such as PVS-Studio and SonarQube,
    each with its unique features and strengths. Let’s compare these tools to Clang-Tidy
    and also mention a few other notable options.
  prefs: []
  type: TYPE_NORMAL
- en: PVS-Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using PVS-Studio has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus**: PVS-Studio is renowned for its deep analysis capabilities, particularly
    in detecting potential bugs, security flaws, and compliance with coding standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Languages supported**: While Clang-Tidy is focused primarily on C and C++,
    PVS-Studio supports a broader range of languages, including C#, Java, and even
    mixed C/C++/C# code bases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and usage**: PVS-Studio can be integrated into various IDEs and
    **continuous integration** (**CI**) systems. It differs from Clang-Tidy in that
    it’s a standalone tool, not tied to a specific compiler such as Clang.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique features**: It offers extensive checks for potential code vulnerabilities
    and is often praised for its detailed diagnostic messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SonarQube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SonarQube offers the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus**: SonarQube offers a comprehensive suite of code quality checks, including
    bugs, code smells, and security vulnerabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Languages supported**: It supports a wide range of programming languages,
    making it a versatile choice for multi-language projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and usage**: SonarQube stands out with its web-based dashboard
    that provides a detailed overview of the code quality, offering a more holistic
    view compared to Clang-Tidy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique features**: It includes features for code coverage and technical debt
    estimation, which are not the primary focus of Clang-Tidy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other notable tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other notable tools in this field include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cppcheck**: Focused specifically on C and C++ languages, Cppcheck is a static
    analysis tool that emphasizes detecting undefined behavior, dangerous coding constructs,
    and other subtle bugs that other tools might miss. It’s lightweight and can complement
    Clang-Tidy well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coverity**: Known for its high accuracy and support for a wide range of programming
    languages, Coverity is a tool used in both commercial and open source projects
    to detect software defects and security vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Static Analysis**: Integrated into the Visual Studio IDE, this
    tool provides checks specifically tailored for Windows development. It’s highly
    useful for developers working primarily in the Windows ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison with Clang-Tidy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now compare the aforementioned tools with Clang-Tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Language support**: Clang-Tidy is primarily focused on C and C++, while tools
    such as PVS-Studio, SonarQube, and Coverity support a broader range of languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and reporting**: Clang-Tidy is closely integrated with the LLVM/Clang
    ecosystem, making it an excellent choice for projects already using these tools.
    In contrast, SonarQube offers a comprehensive dashboard and PVS-Studio provides
    detailed reports, which are beneficial for larger projects or teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specific use cases**: Tools such as Cppcheck and Visual Studio Static Analysis
    have specific niches – Cppcheck for its lightweight nature and focus on C/C++,
    and Visual Studio Static Analysis for its Windows-specific checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commercial versus open source**: Clang-Tidy is open source and free to use,
    whereas tools such as Coverity and PVS-Studio are commercial products, offering
    enterprise-level features and support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into the world of static analysis for C++
    development, exploring a variety of tools and methodologies. We began with an
    overview of Clang-Tidy, developed by the LLVM Foundation, and its extensive capabilities
    in checking code for performance issues, modernization, bugs, style, readability,
    and security. We also covered other significant tools in the static analysis domain,
    including PVS-Studio, known for its vulnerability detection and multi-language
    support; SonarQube, with its comprehensive code quality checks and intuitive dashboard;
    and others such as Cppcheck, Coverity, and Visual Studio Static Analysis, each
    bringing unique strengths to the table.
  prefs: []
  type: TYPE_NORMAL
- en: A significant focus was on configuring Clang-Tidy, detailing how to fine-tune
    it for specific project needs, such as enabling or disabling diagnostics, managing
    warnings, and setting up configuration files. We also discussed the tool’s extensibility,
    highlighting custom checks for different coding standards and compliance packages
    for various requirements such as high-performance C++ and certifications.
  prefs: []
  type: TYPE_NORMAL
- en: This exploration provided us with a broader understanding of the static analysis
    landscape in C++, revealing how these tools can significantly enhance code quality.
    As we wrap up this chapter, we prepare to shift gears in the next one, where we
    will explore the realm of dynamic analysis, complementing our knowledge of static
    analysis with insights into the behavior of running code. This will complete our
    comprehensive look at tools and techniques essential for mastering C++ code quality.
  prefs: []
  type: TYPE_NORMAL
