- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Introduction to Static Analysis in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的静态分析简介
- en: 'In the complex and demanding world of software development, ensuring the quality
    and reliability of code is not just a necessity but a discipline in itself. As
    C++ developers, we constantly seek methodologies and tools that can aid us in
    this quest. This chapter is dedicated to one such powerful approach: static analysis.
    Renowned for being both the fastest and the cheapest way to identify bugs, static
    analysis stands as a pillar in the software quality assurance process. We will
    delve into its intricacies, explore popular tools such as Clang-Tidy, PVS-Studio,
    and SonarQube, and understand how to effectively integrate static analysis into
    your C++ development workflow.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂和需求高的软件开发世界中，确保代码的质量和可靠性不仅是一种必要性，而且本身就是一个学科。作为C++开发者，我们不断寻求可以帮助我们实现这一目标的方法和工具。本章致力于一种这样的强大方法：静态分析。以其既快又便宜地识别错误而闻名，静态分析在软件质量保证过程中是一个支柱。我们将深入研究其复杂性，探讨Clang-Tidy、PVS-Studio和SonarQube等流行工具，并了解如何有效地将静态分析集成到您的C++开发工作流程中。
- en: The essence of static analysis
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析的本质
- en: Static analysis is the examination of source code without executing it. This
    process, typically automated by various tools, involves scanning the code to identify
    potential errors, code smells, security vulnerabilities, and other issues. It’s
    akin to a thorough proofreading session where the code is scrutinized for quality
    and reliability before it ever runs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是对源代码的检查，而不执行它。这个过程通常由各种工具自动化，涉及扫描代码以识别潜在的错误、代码异味、安全漏洞和其他问题。它类似于一个彻底的校对会话，在代码运行之前对代码的质量和可靠性进行审查。
- en: 'Why static analysis? Here are the reasons:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么进行静态分析？以下是原因：
- en: '**Speed and cost-effectiveness**: The foremost advantage of static analysis
    is its speed and cost-effectiveness. It is arguably the fastest and cheapest method
    to find bugs. Automating the detection of issues drastically reduces the time
    and effort required compared to manual code reviews and other testing methods.
    Catching and resolving issues early in the development cycle significantly lowers
    the cost of fixes, which escalates if bugs are found later in production.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度和成本效益**：静态分析的主要优势是其速度和成本效益。它可能是找到错误最快和最便宜的方法。自动化问题的检测大大减少了与手动代码审查和其他测试方法相比所需的时间和精力。在开发周期早期发现并解决错误可以显著降低修复成本，如果在生产后期发现错误，修复成本会急剧上升。'
- en: '**Pre-execution bug detection**: Static analysis occurs before the code is
    executed, making it a proactive measure in software quality assurance. This pre-execution
    analysis allows developers to identify and rectify issues without the overhead
    of setting up testing environments or dealing with the complexities of running
    the code.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预执行错误检测**：静态分析在代码执行之前进行，使其成为软件质量保证中的主动措施。这种预执行分析允许开发者在不设置测试环境或处理代码运行的复杂性的情况下，识别和纠正问题。'
- en: '**Coding standard enforcement**: It helps in maintaining a consistent coding
    standard, ensuring that the code base adheres to the best practices and conventions
    of C++ programming. This enforcement not only improves code quality but also enhances
    maintainability and readability.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码标准执行**：它有助于保持一致的编码标准，确保代码库遵循C++编程的最佳实践和约定。这种执行不仅提高了代码质量，还增强了可维护性和可读性。'
- en: '**Comprehensive coverage**: With the ability to scan the entire code base,
    static analysis provides a level of thoroughness that is challenging to achieve
    through manual methods. This comprehensive coverage ensures that no part of the
    code is overlooked.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全面覆盖**：凭借扫描整个代码库的能力，静态分析提供了一种通过手动方法难以达到的彻底性。这种全面的覆盖确保了代码的任何部分都不会被忽视。'
- en: '**Security and reliability**: Early detection of security vulnerabilities is
    another critical benefit. Static analysis contributes significantly to the security
    and reliability of the application by catching vulnerabilities that might otherwise
    go unnoticed until exploitation.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和可靠性**：早期发现安全漏洞是另一个关键好处。静态分析通过捕捉可能否则直到被利用才被注意到的漏洞，对应用程序的安全性和可靠性做出了重大贡献。'
- en: '**Educational aspect**: It also serves an educational purpose, enhancing developers’
    understanding of C++ and familiarizing them with common pitfalls and best practices.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教育方面**：它还起到教育作用，增强开发者对C++的理解，并使他们熟悉常见的陷阱和最佳实践。'
- en: In the subsequent sections, we’ll explore how to leverage static analysis to
    its fullest potential in C++ projects. Following this, in the next chapter, we
    will compare and contrast these insights with dynamic analysis, offering a complete
    picture of the analysis landscape in C++ software development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging newer compiler versions for enhanced static analysis
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the production environment often mandates specific, sometimes older, compiler
    versions for various reasons, including stability and compatibility, there is
    immense value in periodically building your project with newer versions of compilers.
    This practice serves as a forward-looking static analysis strategy, harnessing
    the advancements and improvements made in the latest compiler releases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Newer compiler versions are frequently equipped with enhanced analysis capabilities,
    more sophisticated warning mechanisms, and updated interpretations of the C++
    standard. They can identify issues and potential code improvements that older
    compilers might overlook. By compiling with these cutting-edge tools, developers
    can proactively discover and address latent issues in their code base, ensuring
    that the code remains robust and compliant with evolving C++ standards.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this approach offers a preview of potential issues that might
    arise when an eventual update to the production compiler is undertaken. It provides
    an opportunity to future-proof the code base, making the transition to newer compiler
    versions smoother and more predictable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In essence, incorporating newer compiler versions into the build process, even
    if they are not used for production builds, is a strategic measure. It not only
    elevates the quality of the code through advanced static analysis but also prepares
    the code base for future technological shifts, ensuring a state of continuous
    improvement and readiness for advancement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Compiler settings to harden C++ code
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the pursuit of robust and secure C++ code, configuring compiler settings
    plays a pivotal role. Compiler flags and options can significantly enhance code
    quality by enabling stricter error checking, warnings, and security features.
    This section focuses on recommended settings for three major compilers in the
    C++ ecosystem: the **GNU Compiler Collection** (**GCC**), Clang, and **Microsoft
    Visual C++** (**MSVC**). These settings are particularly valuable in a static
    analysis context as they enable the detection of potential issues at compile time.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: GCC
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GCC is known for its extensive set of options that can help harden C++ code.
    Key flags include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`-Wall -Wextra`: Enables most warning messages, catching potential issues such
    as uninitialized variables, unused parameters, and more'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Werror`: Treats all warnings as errors, forcing them to be addressed'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wshadow`: Warns whenever a local variable shadows another variable, which
    can lead to confusing bugs'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wnon-virtual-dtor`: Warns if a class with virtual functions has a non-virtual
    destructor, which can lead to undefined behavior'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-pedantic`: Enforces strict ISO C++ compliance, rejecting non-standard code'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wconversion`: Warns on implicit conversions that may alter a value, useful
    for preventing data loss'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wsign-conversion`: Warns on implicit conversions that change the sign of
    a value'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang, part of the LLVM project, shares many flags with GCC but also provides
    additional checks and a reputation for generating more human-readable warnings:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`-Weverything`: Enables every warning available in Clang, providing a comprehensive
    check of the code. This can be overwhelming, so it’s often used with selective
    disabling of less critical warnings.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Werror`, `-Wall`, `-Wextra`, `-Wshadow`, `-Wnon-virtual-dtor`, `-pedantic`,
    `-Wconversion`, and `-Wsign-conversion`: Similar to GCC, these flags are also
    applicable in Clang and serve the same purposes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wdocumentation`: Warns about documentation inconsistencies, which is useful
    when maintaining large code bases with extensive comments.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fsanitize=address`, `-fsanitize=undefined`: Enables `AddressSanitizer` and
    `UndefinedBehaviorSanitizer` to catch memory corruption and undefined behavior
    issues.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSVC
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MSVC, while having a different set of flags, also offers robust options for
    enhancing code safety:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '`/W4`: Enables a higher warning level, similar to `-Wall` in GCC/Clang. This
    includes most of the useful warnings for common issues.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/WX`: Treats all compiler warnings as errors.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdl`: Enables additional security checks, such as buffer overflow detection
    and integer overflow checks.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/GS`: Provides buffer security checks, helping prevent common security vulnerabilities.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/analyze`: Enables static code analysis to detect issues such as memory leaks,
    uninitialized variables, and other potential errors at compile time.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By utilizing these compiler settings, developers can significantly harden their
    C++ code, making it more secure, robust, and compliant with best practices. While
    the default settings of compilers catch many issues, enabling these additional
    flags ensures a much stricter and more thorough analysis of the code. It is important
    to note that while these settings can greatly enhance code quality, they should
    be complemented with good programming practices and regular code reviews for the
    best results. In the next chapter, we will shift our focus to dynamic analysis,
    another key component in ensuring the overall quality and security of C++ applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis via multiple compilers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of C++ development, leveraging the capabilities of compilers for
    static analysis is an often underutilized strategy. Compilers such as GCC and
    Clang come equipped with a plethora of compilation flags that enable rigorous
    static analysis, helping to identify potential issues without the need for additional
    tools. Employing these flags is not only convenient but also highly effective
    in enhancing code quality.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: One best practice that I advocate for is building C++ projects with multiple
    compilers. Each compiler has its unique set of diagnostics, and by utilizing more
    than one, projects can gain a more comprehensive insight into potential issues.
    GCC and Clang are particularly notable for their similarity in supported flags,
    as well as their wide-ranging support for various architectures and operating
    systems. This compatibility makes it feasible to integrate both into a project’s
    build process for cross-checking code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: However, incorporating these practices in a Windows environment can present
    additional challenges. While GCC and Clang are versatile, projects often also
    benefit from the distinct diagnostics provided by MSVC. MSVC integrates seamlessly
    with the Windows ecosystem and brings to the table a different perspective on
    code analysis, which can be especially beneficial for projects targeting Windows
    platforms. Although managing multiple compilers might introduce some complexity,
    the payoff in identifying a broader spectrum of potential issues is invaluable.
    By embracing this multi-compiler approach, projects can significantly enhance
    their static analysis rigor, leading to more robust and reliable C++ code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting compiler differences – unused private members in GCC versus Clang
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A nuanced understanding of the diagnostic capabilities of different compilers
    can be crucial in C++ development. This is exemplified in the way GCC and Clang
    handle unused private member variables. Consider the following class definition:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `number` private member in the `NumberWrapper` class is initialized
    but never used. This situation presents a potential issue in the code that could
    indicate redundancy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare how GCC and Clang handle unused private members:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`number` unused private member. This lack of warning might lead to unintentional
    neglect of inefficiencies or redundancies in the class design.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning: private field ''number'' is not used`. This precise diagnostic helps
    in promptly identifying and addressing potential oversights in the class’s implementation.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting compiler differences – compiler checks for uninitialized variables
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When dealing with class variables in C++, ensuring proper initialization is
    crucial to prevent undefined behavior. This aspect is highlighted in how different
    compilers detect uninitialized but used variables. Consider the example of the
    `NumberWrapper` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this code, the `number` member variable is not initialized, leading to undefined
    behavior when it’s used in the constructor. It can print something such as `init`
    `with: 32767`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '在此代码中，`number` 成员变量未初始化，当它在构造函数中使用时会导致未定义的行为。它可能会打印出类似 `init` `with: 32767`
    的内容。'
- en: 'We’ll now compare the approaches used by GCC and Clang in this regard:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将比较 GCC 和 Clang 在此方面的方法：
- en: '`warning: ''num.NumberWrapper::number'' is used uninitialized`. This warning
    serves as an important alert to developers, drawing attention to the risk of using
    uninitialized variables, which can lead to unpredictable program behavior or subtle
    bugs.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warning: ''num.NumberWrapper::number'' is used uninitialized`。这个警告作为对开发者的一个重要警报，将注意力引向使用未初始化变量的风险，这可能导致程序行为不可预测或出现微妙的错误。'
- en: '**Clang’s diagnostic approach**: Interestingly, Clang version 17 does not generate
    a warning for the same code, potentially allowing this oversight to go unnoticed
    in environments where only Clang is used. This demonstrates a case where relying
    solely on Clang might miss certain classes of errors that GCC can catch.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clang 的诊断方法**：有趣的是，Clang 版本 17 对同一代码不生成警告，这可能在仅使用 Clang 的环境中导致这种疏忽未被发现。这表明，仅依赖
    Clang 可能会错过 GCC 可以捕获的某些错误类别。'
- en: The two examples discussed previously offer compelling insights into the distinctive
    strengths and nuances of GCC and Clang’s diagnostic capabilities. These instances
    – one highlighting Clang’s ability to flag unused private fields and the other
    showcasing GCC’s proficiency in warning about uninitialized class variables –
    exemplify the importance of a multi-compiler strategy in C++ development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的两个示例提供了对 GCC 和 Clang 诊断能力的独特优势和细微差别的深刻见解。这些实例——一个突出了 Clang 标记未使用私有字段的能力，另一个展示了
    GCC 在警告未初始化类变量方面的熟练程度——证明了在 C++ 开发中使用多编译器策略的重要性。
- en: By utilizing both Clang and GCC, developers can harness a more comprehensive
    and diversified static analysis process. Each compiler, with its unique set of
    warnings and checks, can reveal different potential issues or optimizations. Clang,
    known for its detailed and specific warnings, such as flagging unused private
    fields, complements GCC’s vigilant checks for fundamental yet critical issues
    such as uninitialized variables. This synergy between the compilers ensures a
    more thorough vetting of the code, leading to higher quality and more reliable
    and maintainable software.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Clang 和 GCC，开发者可以充分利用更全面和多样化的静态分析过程。每个编译器都有一套独特的警告和检查，可以揭示不同的潜在问题或优化。Clang
    以其详细和具体的警告而闻名，例如标记未使用的私有字段，这补充了 GCC 对基本但关键问题（如未初始化的变量）的警觉性检查。这种编译器之间的协同作用确保了对代码的更彻底审查，从而导致了更高品质、更可靠和易于维护的软件。
- en: 'In essence, the combination of Clang and GCC does not just add value in terms
    of the sum of their individual capabilities; it creates a more robust and holistic
    environment for static analysis. As the C++ language and its compilers continue
    to evolve, staying adaptable and open to multiple tools for static analysis remains
    a best practice for developers aiming for excellence in their craft. This approach
    aligns well with the ever-present goal in software development: writing clean,
    efficient, and error-free code.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Clang 和 GCC 的结合并不仅仅是它们各自能力的总和；它为静态分析创造了一个更强大和全面的生态环境。随着 C++ 语言及其编译器的持续发展，保持适应性和开放性，以接受多种静态分析工具，对于追求工艺卓越的开发者来说，这是一种最佳实践。这种方法与软件开发中始终存在的目标相吻合：编写干净、高效且无错误的代码。
- en: Exploring static analysis with Clang-Tidy
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Clang-Tidy 的静态分析
- en: As we delve deeper into the realm of static analysis, a tool that stands out
    for its versatility and depth is Clang-Tidy. Developed by the LLVM Foundation,
    the same organization behind the Clang compiler, Clang-Tidy is a linter and static
    analysis tool designed for C++ code. It extends beyond the capabilities of what
    a traditional compiler would check, offering a range of diagnostics that include
    stylistic errors, programming mistakes, and even subtle bugs that are often missed
    during regular code reviews. Previously, we explored how Clang-Tidy can be adept
    at code formatting; now, we will explore its prowess in static analysis, uncovering
    its ability to scrutinize C++ code at a level that ensures not just conformity
    but also excellence in coding standards.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy works by using the Clang frontend to parse C++ code, enabling it
    to understand the code’s structure and syntax in depth. This deep understanding
    allows Clang-Tidy to perform complex checks that go beyond mere textual analysis,
    examining the code’s semantics and even the flow of execution. It’s not just about
    finding syntactic discrepancies; it’s about understanding the code’s behavior
    and intent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Categories of checks in Clang-Tidy
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Tidy categorizes its checks into several groups, each targeting specific
    types of issues. Let’s break down these categories and explore examples for each:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance checks**: Focus on identifying inefficient patterns in the code
    that can slow down execution; for example, unnecessary copying of objects. Clang-Tidy
    can flag cases where an object is copied but could be moved or passed by reference
    to avoid the overhead of copying:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`for` loops with range-based `for` loops for better readability and safety:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Bug detection**: Identify potential errors or logical bugs in the code; for
    example, detecting null pointer dereferences:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Style checks**: Enforce specific coding styles for consistency and readability;
    for example, enforcing variable naming conventions:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Readability checks**: Focus on making the code more understandable and maintainable;
    for example, simplifying complex Boolean expressions:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Security checks**: Target potential security vulnerabilities; for example,
    highlighting uses of dangerous functions known to pose security risks:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Expanding Clang-Tidy’s capabilities with custom checks
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Tidy’s versatility is further enhanced by its support for custom checks,
    allowing companies and projects to tailor static analysis to their specific needs
    and coding standards. This customization capability has led to the creation of
    various categories of checks, each aligning with the guidelines of different organizations
    or projects. Next, we explore some notable examples:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`google-runtime-references` enforces Google’s preference for pointers over
    non-const references.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google’s Abseil checks**: Abseil is an open source collection of C++ library
    code developed by Google. Checks specific to Abseil ensure adherence to the library’s
    best practices, such as avoiding certain deprecated functions or classes.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuchsia checks**: Tailored for the Fuchsia operating system, these checks
    enforce coding standards and best practices specific to the Fuchsia project. They
    help maintain consistency and quality in the code base contributing to this OS.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zircon checks**: Zircon is the core platform that powers the Fuchsia OS.
    Clang-Tidy includes checks tailored to Zircon’s development, focusing on its unique
    architecture and development standards.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Darwin checks**: These checks are specifically designed for Darwin, the open
    source Unix-like operating system released by Apple. They ensure compliance with
    Darwin’s development practices.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLVM checks (llvm-*)**: These checks are designed to enforce LLVM coding
    standards. They are particularly useful for developers contributing to LLVM or
    its subprojects.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C++ Core Guidelines checks**: Clang-Tidy includes checks that enforce the
    C++ Core Guidelines, a set of best practices for writing modern C++. This includes
    rules for type safety, resource management, and performance.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-pro-type-member-init` ensures that class members are properly
    initialized. `cppcoreguidelines-pro-type-reinterpret-cast` warns against the use
    of `reinterpret_cast`, encouraging safer casting alternatives.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-non-private-member-variables-in-classes` discourages the
    use of non-private member variables to maintain encapsulation.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-avoid-magic-numbers` help identify hardcoded numbers that
    may not have an obvious meaning, promoting readability and maintainability.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-avoid-c-arrays` and `cppcoreguidelines-avoid-non-const-global-variables`,
    which promote the use of modern C++ constructs such as `std::array` or `std::vector`
    over C-style arrays and discourage the use of non-const global variables.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-pro-bounds-array-to-pointer-decay` and `cppcoreguidelines-pro-bounds-constant-array-index`
    warn against common pitfalls that can lead to **out-of-bounds** (**OOB**) errors.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-owning-memory` guides developers on when and how to use
    smart pointers such as `std::unique_ptr` or `std::shared_ptr`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule of Five and Rule of Zero checks**: Clang-Tidy enforces the Rule of Five
    and Rule of Zero in C++ class design, ensuring that classes managing resources
    correctly implement copy and move constructors/assignment operators or avoid managing
    resources manually, respectively.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-special-member-functions` (ensuring the correct implementation
    of special member functions) and `cppcoreguidelines-interfaces-global-init` (avoiding
    global initialization order issues).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adherence to the C++ Core Guidelines via Clang-Tidy checks can significantly
    improve the quality of C++ code, making it more robust, maintainable, and aligned
    with modern C++ practices. These checks cover a wide range of best practices and
    are generally considered good to follow for most C++ projects, especially those
    aiming to leverage modern C++ features effectively.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Check packages for standards compliance**: Clang-Tidy offers “packages” of
    checks that help ensure compliance with certain high-level standards:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-performance C++ (hi-cpp)**: These checks focus on ensuring that the
    code is optimized for performance.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certifications**: For projects that require adherence to specific certification
    standards (such as MISRA, CERT, and so on), Clang-Tidy offers checks that help
    align the code with these standards, although it’s important to note that using
    these checks alone may not be sufficient for full compliance with such certifications.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add custom checks means that Clang-Tidy is not just a static
    analysis tool but a platform that can adapt to various coding standards and practices.
    This adaptability makes it an ideal choice for projects ranging from open source
    libraries to commercial software, each with its unique set of requirements and
    standards. By leveraging these specialized checks, teams can ensure that their
    code not only adheres to general best practices in C++ but also aligns with specific
    guidelines and nuances of their project or organization.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning Clang-Tidy for customized static analysis
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring Clang-Tidy effectively is key to harnessing its full potential
    in a C++ project. This involves not just enabling and disabling certain checks
    but also controlling how specific parts of the code are analyzed. By customizing
    its behavior, developers can ensure that Clang-Tidy’s output is both relevant
    and actionable, focusing on the most important aspects of their code base. Let’s
    take a closer look at this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`--checks=` option to enable specific checks, and prepend `-` to disable others.
    For instance, to turn on performance checks while turning off a specific one,
    you might use the following:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`NOLINT` comment to suppress all warnings for a specific line of code. This
    is a broad approach and might hide more than intended:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`NOLINT(check-name)` to suppress specific warnings. This approach is preferable
    as it prevents over-suppression of potentially useful warnings:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`--warnings-as-errors=` option. This can be applied globally or to specific
    checks:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`.clang-tidy` file at the project’s root. This file should list enabled checks
    and other configurations, as in the following example:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Proper configuration of Clang-Tidy is crucial for effective static analysis
    in C++. By selectively enabling checks, specifically suppressing warnings where
    necessary, and treating critical warnings as errors, teams can maintain high code
    quality standards. The ability to fine-tune the analysis on a line-by-line basis
    with specific suppression comments ensures that Clang-Tidy provides focused and
    relevant feedback, making it an invaluable tool in the C++ developer’s toolkit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Overview of static analysis tools – comparing PVS-Studio, SonarQube, and others
    to Clang-Tidy
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis tools are essential for ensuring code quality and adherence
    to best practices. While Clang-Tidy is a prominent tool in this space, particularly
    for C++ projects, there are other significant tools such as PVS-Studio and SonarQube,
    each with its unique features and strengths. Let’s compare these tools to Clang-Tidy
    and also mention a few other notable options.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: PVS-Studio
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using PVS-Studio has the following benefits:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus**: PVS-Studio is renowned for its deep analysis capabilities, particularly
    in detecting potential bugs, security flaws, and compliance with coding standards.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Languages supported**: While Clang-Tidy is focused primarily on C and C++,
    PVS-Studio supports a broader range of languages, including C#, Java, and even
    mixed C/C++/C# code bases.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and usage**: PVS-Studio can be integrated into various IDEs and
    **continuous integration** (**CI**) systems. It differs from Clang-Tidy in that
    it’s a standalone tool, not tied to a specific compiler such as Clang.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique features**: It offers extensive checks for potential code vulnerabilities
    and is often praised for its detailed diagnostic messages.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SonarQube
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SonarQube offers the following benefits:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus**: SonarQube offers a comprehensive suite of code quality checks, including
    bugs, code smells, and security vulnerabilities'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Languages supported**: It supports a wide range of programming languages,
    making it a versatile choice for multi-language projects'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and usage**: SonarQube stands out with its web-based dashboard
    that provides a detailed overview of the code quality, offering a more holistic
    view compared to Clang-Tidy'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique features**: It includes features for code coverage and technical debt
    estimation, which are not the primary focus of Clang-Tidy'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other notable tools
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other notable tools in this field include the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Cppcheck**: Focused specifically on C and C++ languages, Cppcheck is a static
    analysis tool that emphasizes detecting undefined behavior, dangerous coding constructs,
    and other subtle bugs that other tools might miss. It’s lightweight and can complement
    Clang-Tidy well.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coverity**: Known for its high accuracy and support for a wide range of programming
    languages, Coverity is a tool used in both commercial and open source projects
    to detect software defects and security vulnerabilities.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Static Analysis**: Integrated into the Visual Studio IDE, this
    tool provides checks specifically tailored for Windows development. It’s highly
    useful for developers working primarily in the Windows ecosystem.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison with Clang-Tidy
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now compare the aforementioned tools with Clang-Tidy:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**Language support**: Clang-Tidy is primarily focused on C and C++, while tools
    such as PVS-Studio, SonarQube, and Coverity support a broader range of languages.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and reporting**: Clang-Tidy is closely integrated with the LLVM/Clang
    ecosystem, making it an excellent choice for projects already using these tools.
    In contrast, SonarQube offers a comprehensive dashboard and PVS-Studio provides
    detailed reports, which are beneficial for larger projects or teams.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specific use cases**: Tools such as Cppcheck and Visual Studio Static Analysis
    have specific niches – Cppcheck for its lightweight nature and focus on C/C++,
    and Visual Studio Static Analysis for its Windows-specific checks.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commercial versus open source**: Clang-Tidy is open source and free to use,
    whereas tools such as Coverity and PVS-Studio are commercial products, offering
    enterprise-level features and support.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into the world of static analysis for C++
    development, exploring a variety of tools and methodologies. We began with an
    overview of Clang-Tidy, developed by the LLVM Foundation, and its extensive capabilities
    in checking code for performance issues, modernization, bugs, style, readability,
    and security. We also covered other significant tools in the static analysis domain,
    including PVS-Studio, known for its vulnerability detection and multi-language
    support; SonarQube, with its comprehensive code quality checks and intuitive dashboard;
    and others such as Cppcheck, Coverity, and Visual Studio Static Analysis, each
    bringing unique strengths to the table.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: A significant focus was on configuring Clang-Tidy, detailing how to fine-tune
    it for specific project needs, such as enabling or disabling diagnostics, managing
    warnings, and setting up configuration files. We also discussed the tool’s extensibility,
    highlighting custom checks for different coding standards and compliance packages
    for various requirements such as high-performance C++ and certifications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This exploration provided us with a broader understanding of the static analysis
    landscape in C++, revealing how these tools can significantly enhance code quality.
    As we wrap up this chapter, we prepare to shift gears in the next one, where we
    will explore the realm of dynamic analysis, complementing our knowledge of static
    analysis with insights into the behavior of running code. This will complete our
    comprehensive look at tools and techniques essential for mastering C++ code quality.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
