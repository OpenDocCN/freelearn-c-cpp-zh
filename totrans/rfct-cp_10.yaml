- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Introduction to Static Analysis in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的静态分析简介
- en: 'In the complex and demanding world of software development, ensuring the quality
    and reliability of code is not just a necessity but a discipline in itself. As
    C++ developers, we constantly seek methodologies and tools that can aid us in
    this quest. This chapter is dedicated to one such powerful approach: static analysis.
    Renowned for being both the fastest and the cheapest way to identify bugs, static
    analysis stands as a pillar in the software quality assurance process. We will
    delve into its intricacies, explore popular tools such as Clang-Tidy, PVS-Studio,
    and SonarQube, and understand how to effectively integrate static analysis into
    your C++ development workflow.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂和需求高的软件开发世界中，确保代码的质量和可靠性不仅是一种必要性，而且本身就是一个学科。作为C++开发者，我们不断寻求可以帮助我们实现这一目标的方法和工具。本章致力于一种这样的强大方法：静态分析。以其既快又便宜地识别错误而闻名，静态分析在软件质量保证过程中是一个支柱。我们将深入研究其复杂性，探讨Clang-Tidy、PVS-Studio和SonarQube等流行工具，并了解如何有效地将静态分析集成到您的C++开发工作流程中。
- en: The essence of static analysis
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析的本质
- en: Static analysis is the examination of source code without executing it. This
    process, typically automated by various tools, involves scanning the code to identify
    potential errors, code smells, security vulnerabilities, and other issues. It’s
    akin to a thorough proofreading session where the code is scrutinized for quality
    and reliability before it ever runs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是对源代码的检查，而不执行它。这个过程通常由各种工具自动化，涉及扫描代码以识别潜在的错误、代码异味、安全漏洞和其他问题。它类似于一个彻底的校对会话，在代码运行之前对代码的质量和可靠性进行审查。
- en: 'Why static analysis? Here are the reasons:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么进行静态分析？以下是原因：
- en: '**Speed and cost-effectiveness**: The foremost advantage of static analysis
    is its speed and cost-effectiveness. It is arguably the fastest and cheapest method
    to find bugs. Automating the detection of issues drastically reduces the time
    and effort required compared to manual code reviews and other testing methods.
    Catching and resolving issues early in the development cycle significantly lowers
    the cost of fixes, which escalates if bugs are found later in production.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度和成本效益**：静态分析的主要优势是其速度和成本效益。它可能是找到错误最快和最便宜的方法。自动化问题的检测大大减少了与手动代码审查和其他测试方法相比所需的时间和精力。在开发周期早期发现并解决错误可以显著降低修复成本，如果在生产后期发现错误，修复成本会急剧上升。'
- en: '**Pre-execution bug detection**: Static analysis occurs before the code is
    executed, making it a proactive measure in software quality assurance. This pre-execution
    analysis allows developers to identify and rectify issues without the overhead
    of setting up testing environments or dealing with the complexities of running
    the code.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预执行错误检测**：静态分析在代码执行之前进行，使其成为软件质量保证中的主动措施。这种预执行分析允许开发者在不设置测试环境或处理代码运行的复杂性的情况下，识别和纠正问题。'
- en: '**Coding standard enforcement**: It helps in maintaining a consistent coding
    standard, ensuring that the code base adheres to the best practices and conventions
    of C++ programming. This enforcement not only improves code quality but also enhances
    maintainability and readability.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码标准执行**：它有助于保持一致的编码标准，确保代码库遵循C++编程的最佳实践和约定。这种执行不仅提高了代码质量，还增强了可维护性和可读性。'
- en: '**Comprehensive coverage**: With the ability to scan the entire code base,
    static analysis provides a level of thoroughness that is challenging to achieve
    through manual methods. This comprehensive coverage ensures that no part of the
    code is overlooked.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全面覆盖**：凭借扫描整个代码库的能力，静态分析提供了一种通过手动方法难以达到的彻底性。这种全面的覆盖确保了代码的任何部分都不会被忽视。'
- en: '**Security and reliability**: Early detection of security vulnerabilities is
    another critical benefit. Static analysis contributes significantly to the security
    and reliability of the application by catching vulnerabilities that might otherwise
    go unnoticed until exploitation.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和可靠性**：早期发现安全漏洞是另一个关键好处。静态分析通过捕捉可能否则直到被利用才被注意到的漏洞，对应用程序的安全性和可靠性做出了重大贡献。'
- en: '**Educational aspect**: It also serves an educational purpose, enhancing developers’
    understanding of C++ and familiarizing them with common pitfalls and best practices.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教育方面**：它还起到教育作用，增强开发者对C++的理解，并使他们熟悉常见的陷阱和最佳实践。'
- en: In the subsequent sections, we’ll explore how to leverage static analysis to
    its fullest potential in C++ projects. Following this, in the next chapter, we
    will compare and contrast these insights with dynamic analysis, offering a complete
    picture of the analysis landscape in C++ software development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何在C++项目中充分利用静态分析。在此之后，在下一章中，我们将比较和对比这些见解与动态分析，提供一个完整的C++软件开发分析景观图。
- en: Leveraging newer compiler versions for enhanced static analysis
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用较新版本的编译器进行增强的静态分析
- en: While the production environment often mandates specific, sometimes older, compiler
    versions for various reasons, including stability and compatibility, there is
    immense value in periodically building your project with newer versions of compilers.
    This practice serves as a forward-looking static analysis strategy, harnessing
    the advancements and improvements made in the latest compiler releases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管生产环境通常因稳定性、兼容性等原因而要求使用特定、有时较旧的编译器版本，但定期使用较新版本的编译器构建项目具有巨大的价值。这种做法作为一种前瞻性的静态分析策略，利用了最新编译器版本中的进步和改进。
- en: Newer compiler versions are frequently equipped with enhanced analysis capabilities,
    more sophisticated warning mechanisms, and updated interpretations of the C++
    standard. They can identify issues and potential code improvements that older
    compilers might overlook. By compiling with these cutting-edge tools, developers
    can proactively discover and address latent issues in their code base, ensuring
    that the code remains robust and compliant with evolving C++ standards.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的编译器版本通常配备了增强的分析能力、更复杂的警告机制和对C++标准的更新解释。它们可以识别出较旧编译器可能忽略的问题和潜在代码改进。通过使用这些尖端工具进行编译，开发者可以主动发现并解决代码库中的潜在问题，确保代码保持健壮并符合不断发展的C++标准。
- en: Additionally, this approach offers a preview of potential issues that might
    arise when an eventual update to the production compiler is undertaken. It provides
    an opportunity to future-proof the code base, making the transition to newer compiler
    versions smoother and more predictable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法还提供了对生产编译器最终更新时可能出现的潜在问题的预览。它提供了对未来证明代码库的机会，使过渡到较新编译器版本更加顺畅和可预测。
- en: In essence, incorporating newer compiler versions into the build process, even
    if they are not used for production builds, is a strategic measure. It not only
    elevates the quality of the code through advanced static analysis but also prepares
    the code base for future technological shifts, ensuring a state of continuous
    improvement and readiness for advancement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，将较新的编译器版本纳入构建过程，即使它们不用于生产构建，也是一种战略措施。这不仅通过高级静态分析提升了代码质量，而且为代码库未来的技术转变做好了准备，确保了持续改进和为进步做好准备的状态。
- en: Compiler settings to harden C++ code
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固C++代码的编译器设置
- en: 'In the pursuit of robust and secure C++ code, configuring compiler settings
    plays a pivotal role. Compiler flags and options can significantly enhance code
    quality by enabling stricter error checking, warnings, and security features.
    This section focuses on recommended settings for three major compilers in the
    C++ ecosystem: the **GNU Compiler Collection** (**GCC**), Clang, and **Microsoft
    Visual C++** (**MSVC**). These settings are particularly valuable in a static
    analysis context as they enable the detection of potential issues at compile time.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在追求健壮和安全的C++代码的过程中，配置编译器设置起着关键作用。编译器标志和选项可以通过启用更严格的错误检查、警告和安全功能显著提高代码质量。本节重点介绍C++生态系统中的三个主要编译器的推荐设置：**GNU编译器集合**（**GCC**）、Clang和**Microsoft
    Visual C++**（**MSVC**）。这些设置在静态分析环境中尤其有价值，因为它们能够在编译时检测到潜在问题。
- en: GCC
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GCC
- en: 'GCC is known for its extensive set of options that can help harden C++ code.
    Key flags include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GCC以其广泛的选项而闻名，这些选项可以帮助加固C++代码。关键标志包括以下内容：
- en: '`-Wall -Wextra`: Enables most warning messages, catching potential issues such
    as uninitialized variables, unused parameters, and more'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wall -Wextra`：启用大多数警告消息，捕获潜在问题，如未初始化的变量、未使用的参数等'
- en: '`-Werror`: Treats all warnings as errors, forcing them to be addressed'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Werror`：将所有警告视为错误，强制它们得到解决'
- en: '`-Wshadow`: Warns whenever a local variable shadows another variable, which
    can lead to confusing bugs'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wshadow`：当局部变量遮蔽另一个变量时发出警告，这可能导致令人困惑的错误'
- en: '`-Wnon-virtual-dtor`: Warns if a class with virtual functions has a non-virtual
    destructor, which can lead to undefined behavior'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wnon-virtual-dtor`: 如果一个类有虚函数但没有虚析构函数，将发出警告，这可能导致未定义的行为'
- en: '`-pedantic`: Enforces strict ISO C++ compliance, rejecting non-standard code'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-pedantic`: 强制执行严格的 ISO C++ 兼容性，拒绝非标准代码'
- en: '`-Wconversion`: Warns on implicit conversions that may alter a value, useful
    for preventing data loss'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wconversion`: 对于可能改变值的隐式转换发出警告，对于防止数据丢失很有用'
- en: '`-Wsign-conversion`: Warns on implicit conversions that change the sign of
    a value'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wsign-conversion`: 对于可能改变值符号的隐式转换发出警告'
- en: Clang
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clang
- en: 'Clang, part of the LLVM project, shares many flags with GCC but also provides
    additional checks and a reputation for generating more human-readable warnings:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Clang，作为 LLVM 项目的组成部分，与 GCC 共享许多标志，但也提供了额外的检查和生成更易读警告的声誉：
- en: '`-Weverything`: Enables every warning available in Clang, providing a comprehensive
    check of the code. This can be overwhelming, so it’s often used with selective
    disabling of less critical warnings.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Weverything`: 启用 Clang 中所有可用的警告，对代码进行全面检查。这可能会让人感到不知所措，因此通常与选择性禁用不太关键的警告一起使用。'
- en: '`-Werror`, `-Wall`, `-Wextra`, `-Wshadow`, `-Wnon-virtual-dtor`, `-pedantic`,
    `-Wconversion`, and `-Wsign-conversion`: Similar to GCC, these flags are also
    applicable in Clang and serve the same purposes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Werror`, `-Wall`, `-Wextra`, `-Wshadow`, `-Wnon-virtual-dtor`, `-pedantic`,
    `-Wconversion`, 和 `-Wsign-conversion`：与 GCC 类似，这些标志也适用于 Clang，并服务于相同的目的。'
- en: '`-Wdocumentation`: Warns about documentation inconsistencies, which is useful
    when maintaining large code bases with extensive comments.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wdocumentation`: 对于文档不一致性发出警告，这对于维护具有大量注释的大型代码库很有用。'
- en: '`-fsanitize=address`, `-fsanitize=undefined`: Enables `AddressSanitizer` and
    `UndefinedBehaviorSanitizer` to catch memory corruption and undefined behavior
    issues.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fsanitize=address`, `-fsanitize=undefined`: 启用 `AddressSanitizer` 和 `UndefinedBehaviorSanitizer`
    来捕获内存损坏和未定义行为问题。'
- en: MSVC
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MSVC
- en: 'MSVC, while having a different set of flags, also offers robust options for
    enhancing code safety:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MSVC，虽然有一组不同的标志，但也提供了增强代码安全性的强大选项：
- en: '`/W4`: Enables a higher warning level, similar to `-Wall` in GCC/Clang. This
    includes most of the useful warnings for common issues.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/W4`: 启用更高的警告级别，类似于 GCC/Clang 中的 `-Wall`。这包括大多数针对常见问题的有用警告。'
- en: '`/WX`: Treats all compiler warnings as errors.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/WX`: 将所有编译器警告视为错误。'
- en: '`/sdl`: Enables additional security checks, such as buffer overflow detection
    and integer overflow checks.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sdl`: 启用额外的安全检查，例如缓冲区溢出检测和整数溢出检查。'
- en: '`/GS`: Provides buffer security checks, helping prevent common security vulnerabilities.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/GS`: 提供缓冲区安全检查，有助于防止常见的安全漏洞。'
- en: '`/analyze`: Enables static code analysis to detect issues such as memory leaks,
    uninitialized variables, and other potential errors at compile time.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/analyze`: 启用静态代码分析，以在编译时检测内存泄漏、未初始化变量和其他潜在错误。'
- en: By utilizing these compiler settings, developers can significantly harden their
    C++ code, making it more secure, robust, and compliant with best practices. While
    the default settings of compilers catch many issues, enabling these additional
    flags ensures a much stricter and more thorough analysis of the code. It is important
    to note that while these settings can greatly enhance code quality, they should
    be complemented with good programming practices and regular code reviews for the
    best results. In the next chapter, we will shift our focus to dynamic analysis,
    another key component in ensuring the overall quality and security of C++ applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些编译器设置，开发者可以显著增强他们的 C++ 代码，使其更加安全、健壮，并符合最佳实践。虽然编译器的默认设置可以捕获许多问题，但启用这些附加标志确保了对代码进行更严格和更彻底的分析。需要注意的是，虽然这些设置可以极大地提高代码质量，但它们应该与良好的编程实践和定期的代码审查相结合，以获得最佳结果。在下一章中，我们将把重点转向动态分析，这是确保
    C++ 应用程序整体质量和安全性的另一个关键组成部分。
- en: Static analysis via multiple compilers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过多个编译器进行静态分析
- en: In the realm of C++ development, leveraging the capabilities of compilers for
    static analysis is an often underutilized strategy. Compilers such as GCC and
    Clang come equipped with a plethora of compilation flags that enable rigorous
    static analysis, helping to identify potential issues without the need for additional
    tools. Employing these flags is not only convenient but also highly effective
    in enhancing code quality.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 开发领域，利用编译器的静态分析功能是一种经常被低估的策略。例如 GCC 和 Clang 这样的编译器配备了大量的编译标志，这些标志能够实现严格的静态分析，有助于在不需要额外工具的情况下识别潜在问题。使用这些标志不仅方便，而且对于提高代码质量非常有效。
- en: One best practice that I advocate for is building C++ projects with multiple
    compilers. Each compiler has its unique set of diagnostics, and by utilizing more
    than one, projects can gain a more comprehensive insight into potential issues.
    GCC and Clang are particularly notable for their similarity in supported flags,
    as well as their wide-ranging support for various architectures and operating
    systems. This compatibility makes it feasible to integrate both into a project’s
    build process for cross-checking code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我提倡的一个最佳实践是使用多个编译器构建 C++ 项目。每个编译器都有其独特的诊断工具集，通过使用多个编译器，项目可以更全面地了解潜在问题。GCC 和
    Clang 在支持的标志相似性以及广泛支持各种架构和操作系统方面特别引人注目。这种兼容性使得将两者集成到项目的构建过程中进行交叉检查成为可能。
- en: However, incorporating these practices in a Windows environment can present
    additional challenges. While GCC and Clang are versatile, projects often also
    benefit from the distinct diagnostics provided by MSVC. MSVC integrates seamlessly
    with the Windows ecosystem and brings to the table a different perspective on
    code analysis, which can be especially beneficial for projects targeting Windows
    platforms. Although managing multiple compilers might introduce some complexity,
    the payoff in identifying a broader spectrum of potential issues is invaluable.
    By embracing this multi-compiler approach, projects can significantly enhance
    their static analysis rigor, leading to more robust and reliable C++ code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Windows 环境中实施这些实践可能会带来额外的挑战。虽然 GCC 和 Clang 功能强大，但项目通常也受益于 MSVC 提供的独特诊断。MSVC
    与 Windows 生态系统无缝集成，并为代码分析提供了不同的视角，这对于针对 Windows 平台的项目尤其有益。尽管管理多个编译器可能会引入一些复杂性，但识别更广泛潜在问题的回报是宝贵的。通过采用这种多编译器方法，项目可以显著提高其静态分析的严谨性，从而产生更健壮和可靠的
    C++ 代码。
- en: Highlighting compiler differences – unused private members in GCC versus Clang
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突出编译器差异 – GCC 与 Clang 中的未使用私有成员
- en: 'A nuanced understanding of the diagnostic capabilities of different compilers
    can be crucial in C++ development. This is exemplified in the way GCC and Clang
    handle unused private member variables. Consider the following class definition:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 开发中，对不同编译器的诊断能力有细微的理解可能至关重要。这一点在 GCC 和 Clang 处理未使用的私有成员变量方面得到了体现。考虑以下类定义：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `number` private member in the `NumberWrapper` class is initialized
    but never used. This situation presents a potential issue in the code that could
    indicate redundancy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`NumberWrapper` 类中的 `number` 私有成员被初始化但从未使用。这种情况在代码中可能表示潜在的问题，表明存在冗余。
- en: 'Let’s compare how GCC and Clang handle unused private members:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 GCC 和 Clang 如何处理未使用的私有成员：
- en: '`number` unused private member. This lack of warning might lead to unintentional
    neglect of inefficiencies or redundancies in the class design.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number` 未使用的私有成员。这种缺少警告可能会导致无意中忽视类设计中效率低下或冗余的问题。'
- en: '`warning: private field ''number'' is not used`. This precise diagnostic helps
    in promptly identifying and addressing potential oversights in the class’s implementation.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warning: private field ''number'' is not used`。这个精确的诊断有助于及时识别和解决类实现中潜在的错误。'
- en: Highlighting compiler differences – compiler checks for uninitialized variables
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突出编译器差异 – 编译器对未初始化变量的检查
- en: 'When dealing with class variables in C++, ensuring proper initialization is
    crucial to prevent undefined behavior. This aspect is highlighted in how different
    compilers detect uninitialized but used variables. Consider the example of the
    `NumberWrapper` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 C++ 中的类变量时，确保适当的初始化对于防止未定义行为至关重要。这一点在不同编译器检测未初始化但被使用的变量方面得到了强调。考虑以下 `NumberWrapper`
    类的例子：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this code, the `number` member variable is not initialized, leading to undefined
    behavior when it’s used in the constructor. It can print something such as `init`
    `with: 32767`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '在此代码中，`number` 成员变量未初始化，当它在构造函数中使用时会导致未定义的行为。它可能会打印出类似 `init` `with: 32767`
    的内容。'
- en: 'We’ll now compare the approaches used by GCC and Clang in this regard:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将比较 GCC 和 Clang 在此方面的方法：
- en: '`warning: ''num.NumberWrapper::number'' is used uninitialized`. This warning
    serves as an important alert to developers, drawing attention to the risk of using
    uninitialized variables, which can lead to unpredictable program behavior or subtle
    bugs.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warning: ''num.NumberWrapper::number'' is used uninitialized`。这个警告作为对开发者的一个重要警报，将注意力引向使用未初始化变量的风险，这可能导致程序行为不可预测或出现微妙的错误。'
- en: '**Clang’s diagnostic approach**: Interestingly, Clang version 17 does not generate
    a warning for the same code, potentially allowing this oversight to go unnoticed
    in environments where only Clang is used. This demonstrates a case where relying
    solely on Clang might miss certain classes of errors that GCC can catch.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clang 的诊断方法**：有趣的是，Clang 版本 17 对同一代码不生成警告，这可能在仅使用 Clang 的环境中导致这种疏忽未被发现。这表明，仅依赖
    Clang 可能会错过 GCC 可以捕获的某些错误类别。'
- en: The two examples discussed previously offer compelling insights into the distinctive
    strengths and nuances of GCC and Clang’s diagnostic capabilities. These instances
    – one highlighting Clang’s ability to flag unused private fields and the other
    showcasing GCC’s proficiency in warning about uninitialized class variables –
    exemplify the importance of a multi-compiler strategy in C++ development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的两个示例提供了对 GCC 和 Clang 诊断能力的独特优势和细微差别的深刻见解。这些实例——一个突出了 Clang 标记未使用私有字段的能力，另一个展示了
    GCC 在警告未初始化类变量方面的熟练程度——证明了在 C++ 开发中使用多编译器策略的重要性。
- en: By utilizing both Clang and GCC, developers can harness a more comprehensive
    and diversified static analysis process. Each compiler, with its unique set of
    warnings and checks, can reveal different potential issues or optimizations. Clang,
    known for its detailed and specific warnings, such as flagging unused private
    fields, complements GCC’s vigilant checks for fundamental yet critical issues
    such as uninitialized variables. This synergy between the compilers ensures a
    more thorough vetting of the code, leading to higher quality and more reliable
    and maintainable software.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Clang 和 GCC，开发者可以充分利用更全面和多样化的静态分析过程。每个编译器都有一套独特的警告和检查，可以揭示不同的潜在问题或优化。Clang
    以其详细和具体的警告而闻名，例如标记未使用的私有字段，这补充了 GCC 对基本但关键问题（如未初始化的变量）的警觉性检查。这种编译器之间的协同作用确保了对代码的更彻底审查，从而导致了更高品质、更可靠和易于维护的软件。
- en: 'In essence, the combination of Clang and GCC does not just add value in terms
    of the sum of their individual capabilities; it creates a more robust and holistic
    environment for static analysis. As the C++ language and its compilers continue
    to evolve, staying adaptable and open to multiple tools for static analysis remains
    a best practice for developers aiming for excellence in their craft. This approach
    aligns well with the ever-present goal in software development: writing clean,
    efficient, and error-free code.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Clang 和 GCC 的结合并不仅仅是它们各自能力的总和；它为静态分析创造了一个更强大和全面的生态环境。随着 C++ 语言及其编译器的持续发展，保持适应性和开放性，以接受多种静态分析工具，对于追求工艺卓越的开发者来说，这是一种最佳实践。这种方法与软件开发中始终存在的目标相吻合：编写干净、高效且无错误的代码。
- en: Exploring static analysis with Clang-Tidy
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Clang-Tidy 的静态分析
- en: As we delve deeper into the realm of static analysis, a tool that stands out
    for its versatility and depth is Clang-Tidy. Developed by the LLVM Foundation,
    the same organization behind the Clang compiler, Clang-Tidy is a linter and static
    analysis tool designed for C++ code. It extends beyond the capabilities of what
    a traditional compiler would check, offering a range of diagnostics that include
    stylistic errors, programming mistakes, and even subtle bugs that are often missed
    during regular code reviews. Previously, we explored how Clang-Tidy can be adept
    at code formatting; now, we will explore its prowess in static analysis, uncovering
    its ability to scrutinize C++ code at a level that ensures not just conformity
    but also excellence in coding standards.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步深入静态分析领域，一个因其多功能性和深度而脱颖而出的工具是 Clang-Tidy。由 LLVM 基金会开发，Clang 编译器的背后组织，Clang-Tidy
    是一个用于 C++ 代码的代码检查器和静态分析工具。它超越了传统编译器检查的能力，提供了一系列诊断，包括样式错误、编程错误，甚至是在常规代码审查中经常被忽视的微妙错误。之前，我们探讨了
    Clang-Tidy 如何擅长代码格式化；现在，我们将探讨其在静态分析方面的能力，揭示其能够以确保不仅符合规范，而且在编码标准上达到卓越水平的能力。
- en: Clang-Tidy works by using the Clang frontend to parse C++ code, enabling it
    to understand the code’s structure and syntax in depth. This deep understanding
    allows Clang-Tidy to perform complex checks that go beyond mere textual analysis,
    examining the code’s semantics and even the flow of execution. It’s not just about
    finding syntactic discrepancies; it’s about understanding the code’s behavior
    and intent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Tidy 通过使用 Clang 前端解析 C++ 代码来工作，使其能够深入理解代码的结构和语法。这种深入理解使 Clang-Tidy 能够执行复杂的检查，这些检查超越了简单的文本分析，检查代码的语义甚至执行流程。它不仅仅是寻找语法差异；它关于理解代码的行为和意图。
- en: Categories of checks in Clang-Tidy
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clang-Tidy 检查的分类
- en: 'Clang-Tidy categorizes its checks into several groups, each targeting specific
    types of issues. Let’s break down these categories and explore examples for each:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Tidy 将其检查分为几个组，每个组针对特定类型的问题。让我们分解这些类别，并探索每个类别的示例：
- en: '**Performance checks**: Focus on identifying inefficient patterns in the code
    that can slow down execution; for example, unnecessary copying of objects. Clang-Tidy
    can flag cases where an object is copied but could be moved or passed by reference
    to avoid the overhead of copying:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能检查**：专注于识别可能导致执行速度降低的代码中的低效模式；例如，不必要的对象复制。Clang-Tidy 可以标记出对象被复制，但可以移动或通过引用传递以避免复制的开销：'
- en: '[PRE2]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`for` loops with range-based `for` loops for better readability and safety:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于范围的 `for` 循环的 `for` 循环以提高可读性和安全性：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Bug detection**: Identify potential errors or logical bugs in the code; for
    example, detecting null pointer dereferences:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检测**：识别代码中的潜在错误或逻辑错误；例如，检测空指针解引用：'
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Style checks**: Enforce specific coding styles for consistency and readability;
    for example, enforcing variable naming conventions:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式检查**：强制执行特定的编码风格以保持一致性和可读性；例如，强制执行变量命名约定：'
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Readability checks**: Focus on making the code more understandable and maintainable;
    for example, simplifying complex Boolean expressions:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性检查**：专注于使代码更易于理解和维护；例如，简化复杂的布尔表达式：'
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Security checks**: Target potential security vulnerabilities; for example,
    highlighting uses of dangerous functions known to pose security risks:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性检查**：针对潜在的安全漏洞；例如，突出显示已知可能带来安全风险的危险函数的使用：'
- en: '[PRE22]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Expanding Clang-Tidy’s capabilities with custom checks
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过自定义检查扩展 Clang-Tidy 的功能
- en: 'Clang-Tidy’s versatility is further enhanced by its support for custom checks,
    allowing companies and projects to tailor static analysis to their specific needs
    and coding standards. This customization capability has led to the creation of
    various categories of checks, each aligning with the guidelines of different organizations
    or projects. Next, we explore some notable examples:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Tidy 的多功能性通过其自定义检查的支持得到进一步增强，允许公司和项目根据其特定的需求和编码标准定制静态分析。这种定制能力导致了各种检查类别的创建，每个类别都与不同组织或项目的指南相一致。接下来，我们将探讨一些显著的例子：
- en: '`google-runtime-references` enforces Google’s preference for pointers over
    non-const references.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google-runtime-references` 强制执行 Google 对指针而非非 const 引用的偏好。'
- en: '**Google’s Abseil checks**: Abseil is an open source collection of C++ library
    code developed by Google. Checks specific to Abseil ensure adherence to the library’s
    best practices, such as avoiding certain deprecated functions or classes.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google的Abseil检查**：Abseil是由Google开发的C++库代码的开源集合。针对Abseil的检查确保遵守库的最佳实践，例如避免某些已弃用的函数或类。'
- en: '**Fuchsia checks**: Tailored for the Fuchsia operating system, these checks
    enforce coding standards and best practices specific to the Fuchsia project. They
    help maintain consistency and quality in the code base contributing to this OS.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fuchsia检查**：针对Fuchsia操作系统定制，这些检查强制执行Fuchsia项目的特定编码标准和最佳实践。它们有助于保持贡献给该操作系统的代码库的一致性和质量。'
- en: '**Zircon checks**: Zircon is the core platform that powers the Fuchsia OS.
    Clang-Tidy includes checks tailored to Zircon’s development, focusing on its unique
    architecture and development standards.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zircon检查**：Zircon是Fuchsia OS的核心平台。Clang-Tidy包括针对Zircon开发的定制检查，重点关注其独特的架构和开发标准。'
- en: '**Darwin checks**: These checks are specifically designed for Darwin, the open
    source Unix-like operating system released by Apple. They ensure compliance with
    Darwin’s development practices.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Darwin检查**：这些检查专门为Darwin设计，Darwin是苹果公司发布的开源类Unix操作系统。它们确保符合Darwin的开发实践。'
- en: '**LLVM checks (llvm-*)**: These checks are designed to enforce LLVM coding
    standards. They are particularly useful for developers contributing to LLVM or
    its subprojects.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLVM检查（llvm-**）：这些检查旨在强制执行LLVM编码标准。它们对于向LLVM或其子项目贡献的开发者特别有用。'
- en: '**C++ Core Guidelines checks**: Clang-Tidy includes checks that enforce the
    C++ Core Guidelines, a set of best practices for writing modern C++. This includes
    rules for type safety, resource management, and performance.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C++ Core Guidelines检查**：Clang-Tidy包括强制执行C++ Core Guidelines的检查，这是一套编写现代C++的最佳实践。这包括类型安全、资源管理和性能的规则。'
- en: '`cppcoreguidelines-pro-type-member-init` ensures that class members are properly
    initialized. `cppcoreguidelines-pro-type-reinterpret-cast` warns against the use
    of `reinterpret_cast`, encouraging safer casting alternatives.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cppcoreguidelines-pro-type-member-init`确保类成员得到正确初始化。`cppcoreguidelines-pro-type-reinterpret-cast`警告使用`reinterpret_cast`，鼓励使用更安全的转换替代方案。'
- en: '`cppcoreguidelines-non-private-member-variables-in-classes` discourages the
    use of non-private member variables to maintain encapsulation.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cppcoreguidelines-non-private-member-variables-in-classes`不鼓励在类中使用非私有成员变量以维护封装性。'
- en: '`cppcoreguidelines-avoid-magic-numbers` help identify hardcoded numbers that
    may not have an obvious meaning, promoting readability and maintainability.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cppcoreguidelines-avoid-magic-numbers`帮助识别可能没有明显意义的硬编码数字，促进可读性和可维护性。'
- en: '`cppcoreguidelines-avoid-c-arrays` and `cppcoreguidelines-avoid-non-const-global-variables`,
    which promote the use of modern C++ constructs such as `std::array` or `std::vector`
    over C-style arrays and discourage the use of non-const global variables.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cppcoreguidelines-avoid-c-arrays`和`cppcoreguidelines-avoid-non-const-global-variables`促进使用现代C++构造，如`std::array`或`std::vector`，而不是C风格数组，并鼓励不使用非const全局变量。'
- en: '`cppcoreguidelines-pro-bounds-array-to-pointer-decay` and `cppcoreguidelines-pro-bounds-constant-array-index`
    warn against common pitfalls that can lead to **out-of-bounds** (**OOB**) errors.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cppcoreguidelines-pro-bounds-array-to-pointer-decay`和`cppcoreguidelines-pro-bounds-constant-array-index`警告常见的陷阱，这些陷阱可能导致**越界**（**OOB**）错误。'
- en: '`cppcoreguidelines-owning-memory` guides developers on when and how to use
    smart pointers such as `std::unique_ptr` or `std::shared_ptr`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cppcoreguidelines-owning-memory`指导开发者何时以及如何使用智能指针，如`std::unique_ptr`或`std::shared_ptr`。'
- en: '**Rule of Five and Rule of Zero checks**: Clang-Tidy enforces the Rule of Five
    and Rule of Zero in C++ class design, ensuring that classes managing resources
    correctly implement copy and move constructors/assignment operators or avoid managing
    resources manually, respectively.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**五条规则和零规则检查**：Clang-Tidy在C++类设计中强制执行五条规则和零规则，确保管理资源的类正确实现拷贝和移动构造函数/赋值运算符，或者分别避免手动管理资源。'
- en: '`cppcoreguidelines-special-member-functions` (ensuring the correct implementation
    of special member functions) and `cppcoreguidelines-interfaces-global-init` (avoiding
    global initialization order issues).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cppcoreguidelines-special-member-functions`（确保特殊成员函数的正确实现）和`cppcoreguidelines-interfaces-global-init`（避免全局初始化顺序问题）。'
- en: Adherence to the C++ Core Guidelines via Clang-Tidy checks can significantly
    improve the quality of C++ code, making it more robust, maintainable, and aligned
    with modern C++ practices. These checks cover a wide range of best practices and
    are generally considered good to follow for most C++ projects, especially those
    aiming to leverage modern C++ features effectively.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过 Clang-Tidy 检查遵守 C++ 核心指南可以显著提高 C++ 代码的质量，使其更加健壮、易于维护，并与现代 C++ 实践保持一致。这些检查涵盖了广泛的最佳实践，并且通常被认为对于大多数
    C++ 项目来说都是好的遵循，特别是那些旨在有效利用现代 C++ 特性的项目。
- en: '**Check packages for standards compliance**: Clang-Tidy offers “packages” of
    checks that help ensure compliance with certain high-level standards:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查包的标准合规性**：Clang-Tidy 提供了帮助确保符合某些高级标准的“包”检查：'
- en: '**High-performance C++ (hi-cpp)**: These checks focus on ensuring that the
    code is optimized for performance.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能 C++ (hi-cpp)**：这些检查侧重于确保代码针对性能进行了优化。'
- en: '**Certifications**: For projects that require adherence to specific certification
    standards (such as MISRA, CERT, and so on), Clang-Tidy offers checks that help
    align the code with these standards, although it’s important to note that using
    these checks alone may not be sufficient for full compliance with such certifications.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：对于需要遵守特定认证标准的项目（例如 MISRA、CERT 等），Clang-Tidy 提供了帮助代码与这些标准对齐的检查，尽管需要注意的是，仅使用这些检查可能不足以完全符合此类认证。'
- en: The ability to add custom checks means that Clang-Tidy is not just a static
    analysis tool but a platform that can adapt to various coding standards and practices.
    This adaptability makes it an ideal choice for projects ranging from open source
    libraries to commercial software, each with its unique set of requirements and
    standards. By leveraging these specialized checks, teams can ensure that their
    code not only adheres to general best practices in C++ but also aligns with specific
    guidelines and nuances of their project or organization.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 能够添加自定义检查意味着 Clang-Tidy 不仅是一个静态分析工具，还是一个可以适应各种编码标准和实践的平台。这种适应性使其成为从开源库到商业软件等不同项目的理想选择，每个项目都有其独特的需求和标准。通过利用这些专业检查，团队可以确保他们的代码不仅遵循
    C++ 的一般最佳实践，而且与项目或组织的具体指南和细微差别保持一致。
- en: Fine-tuning Clang-Tidy for customized static analysis
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微调 Clang-Tidy 以进行定制静态分析
- en: 'Configuring Clang-Tidy effectively is key to harnessing its full potential
    in a C++ project. This involves not just enabling and disabling certain checks
    but also controlling how specific parts of the code are analyzed. By customizing
    its behavior, developers can ensure that Clang-Tidy’s output is both relevant
    and actionable, focusing on the most important aspects of their code base. Let’s
    take a closer look at this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地配置 Clang-Tidy 对于在 C++ 项目中充分利用其全部潜力至关重要。这不仅仅涉及启用和禁用某些检查，还包括控制代码的特定部分如何进行分析。通过自定义其行为，开发者可以确保
    Clang-Tidy 的输出既相关又可操作，专注于代码库最重要的方面。让我们更详细地看看这一点：
- en: '`--checks=` option to enable specific checks, and prepend `-` to disable others.
    For instance, to turn on performance checks while turning off a specific one,
    you might use the following:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--checks=` 选项启用特定的检查，并使用 `-` 作为前缀来禁用其他检查。例如，为了打开性能检查同时关闭特定的一个，你可能使用以下命令：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`NOLINT` comment to suppress all warnings for a specific line of code. This
    is a broad approach and might hide more than intended:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOLINT` 注释用于抑制特定代码行的所有警告。这是一种宽泛的方法，可能会隐藏比预期更多的内容：'
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`NOLINT(check-name)` to suppress specific warnings. This approach is preferable
    as it prevents over-suppression of potentially useful warnings:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOLINT(check-name)` 用于抑制特定的警告。这种方法更可取，因为它可以防止过度抑制可能有用的警告：'
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`--warnings-as-errors=` option. This can be applied globally or to specific
    checks:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--warnings-as-errors=` 选项。这可以应用于全局或特定检查：'
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`.clang-tidy` file at the project’s root. This file should list enabled checks
    and other configurations, as in the following example:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建 `.clang-tidy` 文件。此文件应列出启用的检查和其他配置，如下例所示：
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Proper configuration of Clang-Tidy is crucial for effective static analysis
    in C++. By selectively enabling checks, specifically suppressing warnings where
    necessary, and treating critical warnings as errors, teams can maintain high code
    quality standards. The ability to fine-tune the analysis on a line-by-line basis
    with specific suppression comments ensures that Clang-Tidy provides focused and
    relevant feedback, making it an invaluable tool in the C++ developer’s toolkit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正确配置 Clang-Tidy 对于在 C++ 中进行有效的静态分析至关重要。通过选择性启用检查、在必要时特别抑制警告，并将关键警告视为错误，团队可以保持高代码质量标准。通过使用特定的抑制注释逐行微调分析的能力，确保
    Clang-Tidy 提供了专注且相关的反馈，使其成为 C++ 开发人员工具箱中的无价之宝。
- en: Overview of static analysis tools – comparing PVS-Studio, SonarQube, and others
    to Clang-Tidy
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析工具概述 – 将 PVS-Studio、SonarQube 和其他工具与 Clang-Tidy 进行比较
- en: Static analysis tools are essential for ensuring code quality and adherence
    to best practices. While Clang-Tidy is a prominent tool in this space, particularly
    for C++ projects, there are other significant tools such as PVS-Studio and SonarQube,
    each with its unique features and strengths. Let’s compare these tools to Clang-Tidy
    and also mention a few other notable options.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具对于确保代码质量和遵守最佳实践至关重要。虽然 Clang-Tidy 是这个领域的突出工具，尤其是在 C++ 项目中，但还有其他重要的工具，如
    PVS-Studio 和 SonarQube，每个工具都有其独特的功能和优势。让我们将这些工具与 Clang-Tidy 进行比较，并提及一些其他值得注意的选项。
- en: PVS-Studio
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PVS-Studio
- en: 'Using PVS-Studio has the following benefits:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PVS-Studio 有以下优势：
- en: '**Focus**: PVS-Studio is renowned for its deep analysis capabilities, particularly
    in detecting potential bugs, security flaws, and compliance with coding standards.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重点**：PVS-Studio 以其深入的分析能力而闻名，尤其是在检测潜在错误、安全漏洞和符合编码标准方面。'
- en: '**Languages supported**: While Clang-Tidy is focused primarily on C and C++,
    PVS-Studio supports a broader range of languages, including C#, Java, and even
    mixed C/C++/C# code bases.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的语言**：虽然 Clang-Tidy 主要关注 C 和 C++，但 PVS-Studio 支持更广泛的编程语言，包括 C#、Java，甚至混合
    C/C++/C# 代码库。'
- en: '**Integration and usage**: PVS-Studio can be integrated into various IDEs and
    **continuous integration** (**CI**) systems. It differs from Clang-Tidy in that
    it’s a standalone tool, not tied to a specific compiler such as Clang.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成和使用**：PVS-Studio 可以集成到各种 IDE 和 **持续集成**（**CI**）系统中。它与 Clang-Tidy 的不同之处在于它是一个独立工具，不依赖于特定编译器，如
    Clang。'
- en: '**Unique features**: It offers extensive checks for potential code vulnerabilities
    and is often praised for its detailed diagnostic messages.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独特功能**：它提供了对潜在代码漏洞的广泛检查，并因其详细的诊断信息而经常受到赞誉。'
- en: SonarQube
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SonarQube
- en: 'SonarQube offers the following benefits:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 提供以下优势：
- en: '**Focus**: SonarQube offers a comprehensive suite of code quality checks, including
    bugs, code smells, and security vulnerabilities'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重点**：SonarQube 提供了一套全面的代码质量检查，包括错误、代码异味和安全漏洞'
- en: '**Languages supported**: It supports a wide range of programming languages,
    making it a versatile choice for multi-language projects'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的语言**：它支持广泛的编程语言，使其成为多语言项目的多功能选择'
- en: '**Integration and usage**: SonarQube stands out with its web-based dashboard
    that provides a detailed overview of the code quality, offering a more holistic
    view compared to Clang-Tidy'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成和使用**：SonarQube 以其基于 Web 的仪表板脱颖而出，提供了对代码质量的详细概述，与 Clang-Tidy 相比提供了更全面的视角'
- en: '**Unique features**: It includes features for code coverage and technical debt
    estimation, which are not the primary focus of Clang-Tidy'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独特功能**：它包括代码覆盖率和技术债务估计功能，这些不是 Clang-Tidy 的主要关注点'
- en: Other notable tools
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他值得注意的工具
- en: 'Other notable tools in this field include the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该领域其他值得注意的工具包括以下：
- en: '**Cppcheck**: Focused specifically on C and C++ languages, Cppcheck is a static
    analysis tool that emphasizes detecting undefined behavior, dangerous coding constructs,
    and other subtle bugs that other tools might miss. It’s lightweight and can complement
    Clang-Tidy well.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cppcheck**：专注于 C 和 C++ 语言，Cppcheck 是一个静态分析工具，强调检测未定义行为、危险的编码结构以及其他其他工具可能错过的微妙错误。它轻量级且可以很好地补充
    Clang-Tidy。'
- en: '**Coverity**: Known for its high accuracy and support for a wide range of programming
    languages, Coverity is a tool used in both commercial and open source projects
    to detect software defects and security vulnerabilities.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Coverity**：以其高准确性和对广泛编程语言的支持而闻名，Coverity 是一种在商业和开源项目中用于检测软件缺陷和安全漏洞的工具。'
- en: '**Visual Studio Static Analysis**: Integrated into the Visual Studio IDE, this
    tool provides checks specifically tailored for Windows development. It’s highly
    useful for developers working primarily in the Windows ecosystem.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio 静态分析**：集成到 Visual Studio IDE 中，此工具提供针对 Windows 开发的特定检查。对于主要在
    Windows 生态系统中工作的开发者来说，它非常有用。'
- en: Comparison with Clang-Tidy
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Clang-Tidy 的比较
- en: 'Let’s now compare the aforementioned tools with Clang-Tidy:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们比较一下上述工具与 Clang-Tidy：
- en: '**Language support**: Clang-Tidy is primarily focused on C and C++, while tools
    such as PVS-Studio, SonarQube, and Coverity support a broader range of languages.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言支持**：Clang-Tidy 主要关注 C 和 C++，而像 PVS-Studio、SonarQube 和 Coverity 这样的工具支持更广泛的语言。'
- en: '**Integration and reporting**: Clang-Tidy is closely integrated with the LLVM/Clang
    ecosystem, making it an excellent choice for projects already using these tools.
    In contrast, SonarQube offers a comprehensive dashboard and PVS-Studio provides
    detailed reports, which are beneficial for larger projects or teams.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成和报告**：Clang-Tidy 与 LLVM/Clang 生态系统紧密集成，使其成为使用这些工具的项目的一个优秀选择。相比之下，SonarQube
    提供了全面的仪表板，而 PVS-Studio 提供了详细的报告，这对大型项目或团队来说是有益的。'
- en: '**Specific use cases**: Tools such as Cppcheck and Visual Studio Static Analysis
    have specific niches – Cppcheck for its lightweight nature and focus on C/C++,
    and Visual Studio Static Analysis for its Windows-specific checks.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定用例**：像 Cppcheck 和 Visual Studio 静态分析这样的工具具有特定的细分市场——Cppcheck 因其轻量级特性和对
    C/C++ 的关注，而 Visual Studio 静态分析则因其针对 Windows 的特定检查而闻名。'
- en: '**Commercial versus open source**: Clang-Tidy is open source and free to use,
    whereas tools such as Coverity and PVS-Studio are commercial products, offering
    enterprise-level features and support.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商业与开源**：Clang-Tidy 是开源的，免费使用，而像 Coverity 和 PVS-Studio 这样的工具是商业产品，提供企业级功能和支持。'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a deep dive into the world of static analysis for C++
    development, exploring a variety of tools and methodologies. We began with an
    overview of Clang-Tidy, developed by the LLVM Foundation, and its extensive capabilities
    in checking code for performance issues, modernization, bugs, style, readability,
    and security. We also covered other significant tools in the static analysis domain,
    including PVS-Studio, known for its vulnerability detection and multi-language
    support; SonarQube, with its comprehensive code quality checks and intuitive dashboard;
    and others such as Cppcheck, Coverity, and Visual Studio Static Analysis, each
    bringing unique strengths to the table.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 C++ 开发的静态分析世界，探索了各种工具和方法。我们从 Clang-Tidy 的概述开始，Clang-Tidy 是由 LLVM
    基金会开发的，它具有检查代码性能问题、现代化、错误、风格、可读性和安全性的广泛功能。我们还涵盖了静态分析领域中的其他重要工具，包括以漏洞检测和多语言支持著称的
    PVS-Studio、提供全面代码质量检查和直观仪表板的 SonarQube，以及其他如 Cppcheck、Coverity 和 Visual Studio
    静态分析的工具，每个工具都为桌面提供了独特的优势。
- en: A significant focus was on configuring Clang-Tidy, detailing how to fine-tune
    it for specific project needs, such as enabling or disabling diagnostics, managing
    warnings, and setting up configuration files. We also discussed the tool’s extensibility,
    highlighting custom checks for different coding standards and compliance packages
    for various requirements such as high-performance C++ and certifications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重点关注了配置 Clang-Tidy，详细说明了如何根据特定项目需求进行微调，例如启用或禁用诊断、管理警告以及设置配置文件。我们还讨论了工具的可扩展性，强调了针对不同编码标准和符合各种要求的定制检查以及认证包。
- en: This exploration provided us with a broader understanding of the static analysis
    landscape in C++, revealing how these tools can significantly enhance code quality.
    As we wrap up this chapter, we prepare to shift gears in the next one, where we
    will explore the realm of dynamic analysis, complementing our knowledge of static
    analysis with insights into the behavior of running code. This will complete our
    comprehensive look at tools and techniques essential for mastering C++ code quality.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这次探索使我们更广泛地了解了 C++ 静态分析领域，揭示了这些工具如何显著提高代码质量。随着本章的结束，我们准备在下一章中转换方向，我们将探索动态分析领域，通过了解运行代码的行为来补充我们对静态分析的知识。这将完成我们对掌握
    C++ 代码质量所需工具和技术的全面审视。
