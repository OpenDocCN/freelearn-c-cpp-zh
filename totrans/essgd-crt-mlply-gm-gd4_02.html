<html><head></head><body>
		<div id="_idContainer028">
			<h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor037"/>2</h1>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor038"/>Sending and Receiving Data</h1>
			<p>In the previous chapter, we saw how we can establish a connection between two computers using the high-level Godot Engine <strong class="source-inline">ENetMultiplayerPeer</strong> API. But what do we do after that? Why do we establish connections between computers? The foundation of a network is the communication between the connected computers, allowing them to send and receive data. This data is transferred by breaking down the content into small chunks <a id="_idIndexMarker036"/><span class="No-Break">called </span><span class="No-Break"><strong class="bold">packets</strong></span><span class="No-Break">.</span></p>
			<p>Each packet is like a postcard containing the necessary information, such as the sender’s and receiver’s IP addresses, the communication port, and the message’s content. We then send these packets over the network, where they can be routed to their intended recipient. Using communication protocols, such as the UDP protocol, we break the data into packets at the sending end and reassemble them at the receiving end of <span class="No-Break">the relationship.</span></p>
			<p>In this chapter, we will discuss the fundamentals of how packets are sent and received and what makes the UDP protocol unique. For that, we’ll need to go a bit lower and use the Godot Engine <strong class="source-inline">UDPServer</strong> and <strong class="source-inline">PacketPeerUDP</strong> classes. These are lower-level API classes, so we will go through some intense <span class="No-Break">content here.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Understanding packets</span></li>
				<li>Introduction to the <strong class="bold">JavaScript Object Notation</strong> (<span class="No-Break"><strong class="bold">JSON</strong></span><span class="No-Break">) format</span></li>
				<li>Sending packets <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">PacketPeerUDP</strong></span></li>
				<li>Listening to packets <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">UDPServer</strong></span></li>
				<li>Authenticating <span class="No-Break">the player</span></li>
				<li>Loading the <span class="No-Break">player’s avatar</span></li>
			</ul>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor039"/>Technical requirements</h1>
			<p>In this chapter, we’re going to keep up with our project in Godot Engine, but this time, we are going to use the files provided in the <strong class="source-inline">res://02.sending-and-receiving-data</strong> folder. So, if you haven’t already done so, download the project’s repository using this <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a><span class="No-Break">.</span></p>
			<p>Then, with the project added to your Godot Engine project manager, open the project and proceed to the <span class="No-Break"><strong class="source-inline">res://02.sending-and-receiving-data</strong></span><span class="No-Break"> folder.</span><a id="_idTextAnchor040"/></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor041"/>Understanding packets</h1>
			<p><strong class="bold">Packets</strong> are <a id="_idIndexMarker037"/>fundamental building blocks of communication over the network using the UDP protocol. They are small chunks of data that contain all the necessary information to reach their intended recipient. This includes the sender’s and receiver’s IP addresses, the communication port, and the <span class="No-Break">message’s content.</span></p>
			<p>Senders send packets to the receiver over the network. The receiving end reassembles the packets, allowing the receiver to understand the message sent. This process is known as <strong class="bold">packet switching</strong>. You can<a id="_idIndexMarker038"/> see a visual representation of <span class="No-Break">this here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 2.1 – Packet switching process" src="image/Figure_02.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Packet switching process</p>
			<p>Unlike other protocols, such as the TCP protocol, the UDP protocol does not guarantee that packets will arrive in the same order as they were sent. This means that the protocol is less reliable but more efficient <span class="No-Break">and faster.</span></p>
			<p>UDP is<a id="_idIndexMarker039"/> also different from other protocols due to its lack of connection state. Each packet contains all the data it needs to reach its receiving end. We address them individually, and the network routes them based on each packet’s own information. This contrasts with the<a id="_idIndexMarker040"/> TCP protocol as the latter needs to set up a prearranged, fixed data channel through a traditional <span class="No-Break">handshake procedure.</span></p>
			<p>This means that we can send these packets using the UDP protocol without a handshake. As long as our server is listening to messages at the specific port we’ve assigned, it will be able to receive the <span class="No-Break">sender’s message.</span></p>
			<p>Due to all that, the UDP protocol is more efficient for sending gameplay data across a network because it’s fast and doesn’t need to wait for confirmation of each packet in order at the receiver’s end. This is a huge advantage for online multiplayer games, especially ones where the player’s reaction time is important for <span class="No-Break">the gameplay.</span></p>
			<p>It’s also common to use the UDP protocol for quick message systems and even voice calls. One issue that may come with using UDP for voice calls is that sometimes the audio doesn’t reach the other side in the correct order, or in any order at all. This causes some issues, but since the communication is meant to be real time and users can ask the person at the other end of the conversation to repeat, the UDP protocol has become the go-to solution for this type of service. And this is what is important to understand—when it is and when it isn’t the <span class="No-Break">proper choice.</span></p>
			<p>Now that we have taken a glance at the protocols in which we can exchange data across the network, we need to understand what this data looks like. Can we send instances of objects across the network? How will they assemble at the <span class="No-Break">receiver’s end?</span></p>
			<p>Network communication is a bit lower level in this sense; we need to send only relevant information in data structures that both the sender and the receiver ends can understand. And for that, we commonly avoid passing binary data around, such <span class="No-Break">as objects.</span></p>
			<p>Instead, we serialize the important information and transmit the necessary chunks across the network so that the receiver end can create a whole new clone of the object using only the data we transmitted. This is way more reliable and allows for smaller bandwidth usage. One common data structure that we use is dictionaries in the format of <span class="No-Break">JSON fil<a id="_idTextAnchor042"/>es.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor043"/>Introduction to the JSON format</h1>
			<p>In network programming, transmitting objects directly through the network is not always reliable, as the data may get corrupted or lost in transit. Moreover, transmitting objects containing executable code may pose a security risk if the code is malicious. That’s why it’s a common practice to use data serialization to convert objects into a format that can be easily transmitted over <span class="No-Break">the network.</span></p>
			<p>One of the<a id="_idIndexMarker041"/> most commonly used data serialization formats is JSON. JSON is a lightweight, text-based format that can represent complex data structures such as arrays and objects, making it an ideal choice for <span class="No-Break">network communication.</span></p>
			<p>When using the Godot Engine network API with UDP, sending and receiving JSON files is a common practice. With JSON, we can serialize and deserialize data quickly and efficiently. JSON files are human-readable, making it easier for developers to debug and troubleshoot issues. JSON files are also flexible, meaning we can cherry-pick only the relevant data we need to send, making network communication even <span class="No-Break">more efficient.</span></p>
			<p>Unlike binary formats, JSON files are easy to read and modify as well. This makes it easier to debug and troubleshoot any issues that may arise during the transmission <span class="No-Break">of data.</span></p>
			<p>Now that we understand the advantages and the overall idea behind the JSON format, how do we use it properly? How does a JSON file help us transmit data around a network and keep players in the same <span class="No-Break">game context?</span></p>
			<p>As mentioned in this section, serialization is how we cherry-pick only the necessary information about a data structure, such as an object, and translate it into a format that we can pass around, and even store, to reconstruct the previous data structure. Serialization is one of the most important skills to learn in software engineering fields, <span class="No-Break">including networks.</span></p>
			<p>It is through serialization that we can translate the state of our application so that other instances of our application can further replicate this state through time—for instance, to make a save and load system or through space, as we are going to do in online multiplayer games. So, let’s understand how serialization works and how to <span class="No-Break">do<a id="_idTextAnchor044"/> it.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor045"/>Serialization</h2>
			<p><strong class="bold">Serialization</strong> in a networking <a id="_idIndexMarker042"/>context refers to the process of converting a complex data object, such as a <strong class="source-inline">Sprite2D</strong> node, into a simple, linear representation that we can store in a file. For instance, <strong class="source-inline">*.tscn</strong> files are serialized files that represent a scene in Godot <span class="No-Break">Engine’s editor.</span></p>
			<p>Serialization<a id="_idIndexMarker043"/> involves converting an object into a format that can be easily reconstructed on another machine or in another context. This can involve encoding the object’s properties, data, and other relevant information in a standardized format, such as JSON. Serialization is essential in network communication because it allows data to be transmitted and received efficiently and reliably, while also enabling interoperability between different programming languages <span class="No-Break">and systems.</span></p>
			<p>For instance, if we want to recreate a <strong class="source-inline">Sprite2D</strong> node on the client’s side based on data provided by the server, we can serialize important properties such as its position, rotation, scale, and texture. It would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
  "position": {
    "x": 2244,
    "y": 1667
  },
  "rotation": 45,
  "scale": {
    "x": 2,
    "y": 2
  },
  "texture_path": "res://assets/objects/Bullet.png"
}</pre>			<p>So, on the client’s side, we instantiate a new <strong class="source-inline">Sprite2D</strong> node and use this data to ensure it represents what the server wants the client to see. We are going to use serialization a lot moving forward. In Godot, we have the <strong class="source-inline">JSON</strong> helper class for creating and parsing <span class="No-Break">JSON data.</span></p>
			<p>The <strong class="source-inline">JSON.stringify()</strong> method is used to serialize an object or a data type, such as an integer or a dictionary, into a JSON-formatted string. This method takes an object as input and returns a string containing the JSON representation of the <span class="No-Break">input object.</span></p>
			<p>The string can then be<a id="_idIndexMarker044"/> transmitted over the network, stored in a file, or used in any other context where a string representation of the object is needed. The resulting string can easily be deserialized back into an object using the <span class="No-Break"><strong class="source-inline">JSON.parse_string()</strong></span><span class="No-Break"> method.</span></p>
			<p>On the other hand, the <strong class="source-inline">JSON.parse_string()</strong> method is used to deserialize a JSON-formatted string back into a recognized Godot data type or object. This method takes a string as input and returns the deserialized data. The resulting object can then be used in any context where the original object <span class="No-Break">was needed.</span></p>
			<p>When deserializing the JSON string, the method takes care of mapping the JSON values to the appropriate Godot Engine data types. This includes mapping strings to strings, numbers to numbers, and Booleans to Booleans, as well as parsing more complex types such as dictionaries <span class="No-Break">and objects.</span></p>
			<p>With both <strong class="source-inline">JSON.stringfy()</strong> and <strong class="source-inline">JSON.parse_string()</strong> methods, Godot Engine provides a simple and reliable way to convert data into a format that can be transmitted over the network or stored in <span class="No-Break">a file.</span></p>
			<p>We saw how we can translate our relevant data into an understandable standard format that we can store, transmit, and recreate at the receiver end. Let’s understand how we can pass this data around in <span class="No-Break">the network.</span></p>
			<p>This is fundamental knowledge when we deal with online multiplayer games because it’s through this process that we will be able to recreate objects and even the whole game state across players, making them share the same <span class="No-Break">game<a id="_idTextAnchor046"/> world.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor047"/>Sending packets with PacketPeerUDP</h1>
			<p>Now, let’s move on to<a id="_idIndexMarker045"/> practical knowledge. In this chapter, your task<a id="_idIndexMarker046"/> is to implement a login system for a game. Our project already has a cool user interface and is able to gather player data, such as their login name and password. Your mission is to make sure that only authorized players can access the game’s content by implementing a secure <span class="No-Break">authentication feature.</span></p>
			<p>Once a player <a id="_idIndexMarker047"/>successfully logs in, you need to display their<a id="_idIndexMarker048"/> character’s avatar based on what we have saved in our database. As a network engineer, you understand the importance of security when it comes to online systems. You know that a robust authentication system is essential to ensure that only legitimate users are granted access to the <span class="No-Break">game’s content.</span></p>
			<p>Therefore, you will need to develop a login system that checks players’ credentials against a secure database and verifies if they have permission to access the game’s features <span class="No-Break">or not.</span></p>
			<p>With your skills and experience, you need to create a system that will provide an excellent user experience while keeping players’ data secure. So, take up the challenge, and let’s create a login system that will be a testament to your skills as a <span class="No-Break">network engineer!</span></p>
			<p>In our project repository, open the <strong class="source-inline">res://02.sending-and-receiving-data//MainMenu.tscn</strong> scene, and let’s <span class="No-Break">g<a id="_idTextAnchor048"/>et started.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor049"/>Creating an AuthenticationCredentials Autoload</h2>
			<p>In Godot Engine, <strong class="bold">Autoloads</strong> are<a id="_idIndexMarker049"/> singletons that Godot loads automatically when the game starts. We can create and edit them in the editor itself and access them from any script in the game. We use Autoloads to store game-wide data or to provide global functionality, making them a convenient way to carry players’ credentials across <span class="No-Break">the game.</span></p>
			<p>One of the main advantages of using Autoloads for carrying player credentials is that they are available throughout scene changes. This means that any script in the game can access the Autoload and retrieve the players’ credentials when needed. This eliminates the need to pass credentials from one script to another, making the code cleaner and easier <span class="No-Break">to maintain.</span></p>
			<p>In addition to that, since <a id="_idIndexMarker050"/>Autoloads are persistent throughout the game’s lifetime, as long as players don’t close the game, we can access <span class="No-Break">their credentials.</span></p>
			<p>This can make the process of implementing a login system with authentication features more efficient <span class="No-Break">and streamlined.</span></p>
			<p>So, let’s<a id="_idIndexMarker051"/> create our <strong class="source-inline">AuthenticationCredentials</strong> Autoload, <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Create a new scene using a <strong class="source-inline">Node</strong> node as the <span class="No-Break">root node.</span></li>
				<li>Rename the root <span class="No-Break">node </span><span class="No-Break"><strong class="source-inline">AuthenticationCredentials</strong></span><span class="No-Break">.</span></li>
				<li>Attach a new script to it, save it as <strong class="source-inline">AuthenticationCredentials.gd</strong>, and <span class="No-Break">open it.</span></li>
				<li>Create a variable to store the player’s username; we can name this variable <strong class="source-inline">user</strong>, and it should be an empty string <span class="No-Break">by default:</span><pre class="source-code">
extends Node
var user = ""</pre></li>				<li>Then, create a variable to store the session’s token when we successfully validate <span class="No-Break">a login:</span><pre class="source-code">
var session_token = ""</pre></li>				<li>Save the scene, then go to <strong class="bold">Project</strong> | <strong class="bold">Project Settings</strong> and open the <span class="No-Break"><strong class="bold">Autoload</strong></span><span class="No-Break"> tab.</span></li>
				<li>In the <strong class="bold">Path</strong> field, click <a id="_idIndexMarker052"/>on the small <span class="No-Break">folder icon:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 2.2 – Autoload tab in the Project Settings menu" src="image/Figure_02.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Autoload tab in the Project Settings menu</p>
			<ol>
				<li value="8">From the <a id="_idIndexMarker053"/>pop-up menu, <span class="No-Break">select </span><span class="No-Break"><strong class="source-inline">AuthenticationCredentials.tscn</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 2.3 – Selecting the AuthenticationCredentials scene from the File menu" src="image/Figure_2.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Selecting the AuthenticationCredentials scene from the File menu</p>
			<ol>
				<li value="9">Leave the <strong class="bold">Node Name</strong> field as <strong class="bold">AuthenticationCredentials</strong> and click on the <span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<p>And there <a id="_idIndexMarker054"/>we have it. Now, you can access the variables and functions defined in the script of the <strong class="source-inline">AuthenticationCredentials.gd</strong> scene from anywhere in your project by calling the <span class="No-Break"><strong class="source-inline">AuthenticationCredentials</strong></span><span class="No-Break"> singleton.</span></p>
			<p>This is useful for keeping track of global state across multiple scenes and nodes in your game. It’s important to note that this Autoload should only exist on the client’s side of a multiplayer game, and not on the server’s side. So, make sure to remove it from your <span class="No-Break">server application.</span></p>
			<p>Now, let’s see how we can gather and send players’ credentials to the server. For that, we are going to work on the very login screen itself! Open <strong class="source-inline">LoginScreen.tscn</strong> and let’s move on to <a id="_idTextAnchor050"/>the <span class="No-Break">cool stuff.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor051"/>Sending players’ credentials</h2>
			<p>The <strong class="bold">L</strong><strong class="bold">oginScreen</strong> scene is the <a id="_idIndexMarker055"/>gateway to the game world. It’s essentially a <strong class="source-inline">Control</strong> node named <strong class="bold">LoginScreen</strong> with a user interface that captures players’ credentials so that we can authenticate them and give them access to <span class="No-Break">our world:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer022">
					<img alt="Figure 2.4 – The LoginScreen scene’s node hierarchy" src="image/Figure_02.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – The LoginScreen scene’s node hierarchy</p>
			<p>The interface includes two <strong class="source-inline">LineEdit</strong> nodes, one called <strong class="bold">UserLineEdit</strong> and another one called <strong class="bold">PasswordLineEdit</strong>. These <strong class="source-inline">LineEdit</strong> nodes allow players to input their login credentials. In case of any errors, we can use the <strong class="bold">ErrorLabel</strong> node to display any <span class="No-Break">necessary messages.</span></p>
			<p>As we collect the<a id="_idIndexMarker056"/> players’ credentials here, we can use the <strong class="bold">LoginButton</strong> node to trigger the login procedure. With this scene in place, our players can securely access their avatar screen once they successfully <span class="No-Break">log in.</span></p>
			<p>But now, we need to work on validating their logins before loading their avatar. So, let’s get our hands dirty. Proceed <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Open the <strong class="source-inline">LoginScreen.gd</strong> script and go to the <span class="No-Break"><strong class="source-inline">send_credentials()</strong></span><span class="No-Break"> function.</span></li>
				<li>Inside the <strong class="source-inline">send_credentials()</strong> function, create a dictionary called <strong class="source-inline">message</strong> that contains the user credentials we will authenticate in <span class="No-Break">the server.</span></li>
				<li>To store these credentials, create a key in the message dictionary called <strong class="source-inline">'authenticate_credentials'</strong>; its value should also be a dictionary. We’ll use it to store <span class="No-Break">players’ credentials.</span></li>
				<li>Use the <strong class="source-inline">user_line_edit</strong> and <strong class="source-inline">password_line_edit</strong> text properties to capture the player’s input for their username and <span class="No-Break">password, respectively:</span><pre class="source-code">
    var message = {'authenticate_credentials':
        {'user': user_line_edit.text, 'password':
            password_line_edit.text}}</pre></li>				<li>Instantiate a new <strong class="source-inline">PacketPeerUDP</strong> object called <strong class="source-inline">packet</strong> using the <span class="No-Break"><strong class="source-inline">PacketPeerUDP.new()</strong></span><span class="No-Break"> constructor:</span><pre class="source-code">
    var packet = PacketPeerUDP.new()</pre></li>				<li>Connect the <strong class="source-inline">packet</strong> object to the server’s address and port using the <strong class="source-inline">connect_to_host()</strong> method. Here, we are using our default <strong class="source-inline">ADDRESS</strong> and <strong class="source-inline">PORT</strong> constants that represent the IP address and port number of the server to which the client is connecting. They are <strong class="source-inline">127.0.0.1</strong> and <span class="No-Break"><strong class="source-inline">9999</strong></span><span class="No-Break"> respectively:</span><pre class="source-code">
packet.connect_to_host(ADDRESS, PORT)</pre></li>				<li>Serialize the message dictionary object into a JSON-formatted string using the <strong class="source-inline">JSON.stringify()</strong> method, and send it to the server using the <span class="No-Break"><strong class="source-inline">packet.put_var()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
    packet.put_var(JSON.stringify(message))</pre></li>				<li>Create a <strong class="source-inline">while</strong> loop to wait for a response from the server. The <strong class="source-inline">packet.wait()</strong> method waits for a packet to arrive at the bound address. It returns an <strong class="source-inline">OK</strong> error constant if it receives a packet; otherwise, it returns an error code based on Godot’s error constants. So, we can use that to wait for the arrival of our packet at the <span class="No-Break">server’s end:</span><pre class="source-code">
    while packet.wait() == OK:</pre></li>				<li>When we <a id="_idIndexMarker057"/>receive a response, we need to deserialize the response data from JSON format back into a dictionary object using the <strong class="source-inline">JSON.parse_string()</strong> method. Let’s store that in a variable <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">response</strong></span><span class="No-Break">:</span><pre class="source-code">
        var response = JSON.parse_string
            (packet.get_var())</pre></li>				<li>Check the <strong class="source-inline">response</strong> dictionary for the presence of an authentication token using the <strong class="source-inline">in</strong> operator. If the <strong class="source-inline">"token"</strong> string is present, store its value <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">AuthenticationCredentials.session_token</strong></span><span class="No-Break">:</span><pre class="source-code">
        if "token" in response:
            AuthenticationCredentials.session_token =
                response['token']</pre></li>				<li>After that, we can also store the <strong class="source-inline">user</strong> present in the message we got from the server as our <span class="No-Break">player’s username:</span><pre class="source-code">
            AuthenticationCredentials.user = message
                ['authenticate_credentials']['user']</pre></li>				<li>Update the user interface to indicate a successful authentication, and switch to the <strong class="source-inline">AvatarScreen.tscn</strong> scene. If the token is not present, display an error message to <span class="No-Break">the player:</span><pre class="source-code">
            error_label.text = "logged!!"</pre></li>				<li>Then, after all that, we can change the scene to the actual avatar screen using the <strong class="source-inline">get_tree().change_scene_to_file("res://AvatarScreen.tscn")</strong> method and break the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop:</span><pre class="source-code">
            get_tree().change_scene_to_file
                ("res://AvatarScreen.tscn")
            break</pre></li>				<li>In case we<a id="_idIndexMarker058"/> get a response from the server, and it doesn’t have the <strong class="source-inline">"token"</strong> key in it, we display an authentication failed message using the <strong class="source-inline">error_label.text</strong> and also break the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop:</span><pre class="source-code">
        else:
            error_label.text = "login failed,
                check your credentials"
            break</pre><p class="list-inset">At this point, the <strong class="source-inline">send_credentials()</strong> method should look <span class="No-Break">like this:</span></p><pre class="source-code">func send_credentials():
    var message = {'authenticate_credentials':
        {'user': user_line_edit.text, 'password':
            password_line_edit.text}}
    var packet = PacketPeerUDP.new()
    packet.connect_to_host(ADDRESS, PORT)
    packet.put_var(JSON.stringify(message))
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())
        if "token" in data:
            error_label.text = "logged!!"
            AuthenticationCredentials.user = message
                ['authenticate_credentials']['user']
            AuthenticationCredentials.session_token =
                data['token']
            get_tree().change_scene_to_file
                ("res://AvatarScreen.tscn")
            break
        else:
            error_label.text = "login failed,
                check your credentials"
            break</pre></li>			</ol>
			<p>Now that we’ve seen how the client side works and what it will do with players’ data, let’s understand how the other side of this connection will receive this data and handle it. For that, open the <a id="_idTextAnchor052"/><span class="No-Break"><strong class="source-inline">Server.tscn</strong></span><span class="No-Break"> scene.</span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor053"/>Listening to packets with UDPServer</h1>
			<p>Welcome to our<a id="_idIndexMarker059"/> Godot Engine server scene! This scene is where our game’s server logic <span class="No-Break">is implemented.</span></p>
			<p>The server is the backbone of our game, responsible for authenticating players and providing them with data about their avatars, such as their name and texture file. This node is called <strong class="source-inline">Server</strong>, and it has a pre-written script that includes some essential variables. Among them are two vital variables: <strong class="source-inline">database_file_path</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">logged_users</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">database_file_path</strong> variable<a id="_idIndexMarker060"/> is the path to the <strong class="source-inline">FakeDatabase</strong> JSON file, which represents a fake database that holds the players’ data. The <strong class="source-inline">logged_users</strong> variable is a dictionary that stores players who are currently <span class="No-Break">logged in.</span></p>
			<p>These variables are crucial to our server’s functionality, and we will use them to authenticate players and provide them with the data <span class="No-Break">they need.</span></p>
			<p>Let’s implement the <strong class="source-inline">Server</strong> node’s most important feature, which is to listen to packets. Proceed <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Open the <span class="No-Break"><strong class="source-inline">Server.gd</strong></span><span class="No-Break"> file.</span></li>
				<li>Declare a <strong class="source-inline">server</strong> variable and set it to <strong class="source-inline">UDPServer.new()</strong>. This creates a new instance of the <strong class="source-inline">UDPServer</strong> class that will allow us to listen to <span class="No-Break">incoming connections:</span><pre class="source-code">
var server = UDPServer.new()</pre></li>				<li>In the <strong class="source-inline">_ready()</strong> function, call the <strong class="source-inline">listen()</strong> method on the <strong class="source-inline">server</strong> variable, passing our default <strong class="source-inline">PORT</strong> constant as an argument. This will start the server and make it listen for <span class="No-Break">incoming connections:</span><pre class="source-code">
func _ready():
    server.listen(PORT)</pre></li>				<li>In the <strong class="source-inline">_process(delta)</strong> function, call the <strong class="source-inline">poll()</strong> method on the <strong class="source-inline">server</strong> variable to check for any incoming messages. This method will not block the game loop, so we can call it in the <strong class="source-inline">_process(delta)</strong> <span class="No-Break">function safely:</span><pre class="source-code">
func _process(delta):
    server.poll()</pre></li>				<li>Call the <strong class="source-inline">is_connection_available()</strong> method on the <strong class="source-inline">server</strong> variable to check whether a client sent a message. If it returns <strong class="source-inline">true</strong>, call the <strong class="source-inline">take_connection()</strong> method to obtain a <strong class="source-inline">PacketPeerUDP</strong> instance that we can use to read the <span class="No-Break">incoming message:</span><pre class="source-code">
if server.is_connection_available():
    var peer = server.take_connection()</pre></li>				<li>Use the <strong class="source-inline">get_var()</strong> method on the <strong class="source-inline">PacketPeerUDP</strong> instance we get to obtain the incoming message. Since we know that the message is a string in JSON format, we can use the <strong class="source-inline">JSON.parse_string()</strong> method to convert it to a dictionary object that we can <span class="No-Break">work with:</span><pre class="source-code">
var message = JSON.parse_string(peer.get_var())</pre></li>				<li>Check whether <a id="_idIndexMarker061"/>the incoming message contains the <strong class="source-inline">"authenticate_credentials"</strong> key. If it does, call the <strong class="source-inline">authenticate_player()</strong> function, passing <strong class="source-inline">peer</strong> and <strong class="source-inline">message</strong> <span class="No-Break">as arguments:</span><pre class="source-code">
if "authenticate_credentials" in message:
    authenticate_player(peer, message)</pre><p class="list-inset">We will create the <strong class="source-inline">authenticate_player()</strong> method in a moment, but for now, our script should look <span class="No-Break">like this:</span></p><pre class="source-code">extends Node
const PORT = 9999
@export var database_file_path =
    "res://FakeDatabase.json"
var database = {}
var logged_users = {}
var server = UDPServer.new()
func _ready():
    server.listen(PORT)
func _process(delta):
    server.poll()
    if server.is_connection_available():
        var peer = server.take_connection()
        var message = JSON.parse_string
            (peer.get_var())
        if "authenticate_credentials" in message:
            authenticate_player(peer, message)</pre></li>			</ol>
			<p>We just saw how we <a id="_idIndexMarker062"/>can open a communication channel between the client and the server and start to listen to messages. With that, we can filter these messages so that the server knows what the client is requesting—in our case, to authenticate the <span class="No-Break">players’ credentials.</span></p>
			<p>This is a low-level implementation of a network API. With that, we can create standard message formats and contents that trigger events on the server side and expect standard responses from the server. Let’s see how our server replies <a id="_idTextAnchor054"/>to this <span class="No-Break">client request.</span></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor055"/>Authenticating the player</h1>
			<p>Authenticating player <a id="_idIndexMarker063"/>credentials is a crucial aspect of any multiplayer game. In our project, we are building a login system for a game using Godot Engine. The login system allows players to log in with their username and password and then displays their character’s avatar upon <span class="No-Break">successful login.</span></p>
			<p>We are going to use a fake database, stored as a JSON file, to represent the players’ credentials. While this approach is simpler than using a full-fledged database management system, it has its own security risks. So, be aware of the risks of this approach in a <span class="No-Break">production-ready project.</span></p>
			<p>To authenticate player credentials in our project, we will also use Godot’s <strong class="source-inline">FileAccess</strong> class to load the fake database from the JSON file and parse the data. This will allow us to compare players’ login credentials with the data in the database and authenticate the player if<a id="_idTextAnchor056"/> the <span class="No-Break">credentials match.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor057"/>Loading a fake database</h2>
			<p>Now, let’s load our database so<a id="_idIndexMarker064"/> that we can check whether the data we got from the player’s client matches anything on our server. In a nutshell, a database is an organized collection of data. In our case, we’ll use a JSON file format as <span class="No-Break">our database.</span></p>
			<p>The advantage of using JSON files as databases is that they are easy to manipulate, and you don’t need to have prior knowledge of database structures <span class="No-Break">and safety.</span></p>
			<p>For instance, our fake database consists of <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{
  "user1": {
    "password":"test",
    "avatar":"res://Avatars/adventurer_idle.png",
    "name":"Sakaki"
  },
  "user2": {
    "password":"test",
    "avatar":"res://Avatars/player_idle.png",
    "name":"Keyaki"
  }
}</pre>			<p>You can even open it in the very Godot Text Editor itself; just double-click the <strong class="source-inline">res://FakeDatabase.json</strong> file provided in our <span class="No-Break">base project.</span></p>
			<p>The preceding JSON file represents a simple database that contains two user entries, <strong class="source-inline">"user1"</strong> and <strong class="source-inline">"user2"</strong>, each with a corresponding set of data. The data contained for each user includes a password, an avatar, and <span class="No-Break">a name.</span></p>
			<p>The <strong class="source-inline">"password"</strong> field holds the plain-text password for each user. This is a very simple approach to storing passwords, as it is not secure due to the possibility of it being compromised. However, it is suitable for <span class="No-Break">educational purposes.</span></p>
			<p>The <strong class="source-inline">"avatar"</strong> field contains a reference to a file that represents the user’s avatar. In this case, it is referencing two different image files from our game, one for <span class="No-Break">each user.</span></p>
			<p>Finally, the <strong class="source-inline">"name"</strong> field simply holds a string that represents the player’s <span class="No-Break">avatar name.</span></p>
			<p>Note that a database file shouldn’t by any means be available to the client. So, in your final project, make sure to <a id="_idIndexMarker065"/>remove your database file from Godot’s project and into a safe <span class="No-Break">database device.</span></p>
			<p>While JSON files are a great choice for certain projects, they may not be suitable for others. Here are some pros and cons <span class="No-Break">to consider:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Pros</strong></span><span class="No-Break">:</span><ul><li>They are easy to <a id="_idIndexMarker066"/>read and write, making them a great choice for small projects or when the speed of development is <span class="No-Break">a priority</span></li><li>JSON files can be parsed natively by most programming languages, including GDScript as we saw previously, which means you don’t need to install any additional software or libraries to work <span class="No-Break">with them</span></li><li>As we just saw, JSON files are human-readable and can be opened and edited using a simple text editor, which makes them great <span class="No-Break">for debugging</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Cons</strong></span><span class="No-Break">:</span><ul><li>They don’t <a id="_idIndexMarker067"/>scale well for large projects with many concurrent users, as there may be issues with data consistency <span class="No-Break">and performance</span></li><li>JSON files are not as flexible as other database formats when it comes to querying data and performing <span class="No-Break">complex operations</span></li></ul></li>
			</ul>
			<p>To load and read the data from<a id="_idIndexMarker068"/> our JSON fake database file, we’ll use Godot Engine’s <span class="No-Break"><strong class="source-inline">FileAccess</strong></span><span class="No-Break"> class.</span></p>
			<p>The <strong class="source-inline">FileAccess</strong> class is a built-in Godot class that provides an interface to load, read, write, and save files to and from the user’s disk. It is a powerful tool that is essential for any game or application that needs to access files from the <span class="No-Break">user’s device.</span></p>
			<p>Let’s dive into the specifics of how to use this class to load and parse our JSON fake database file into our game, <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Go to the <strong class="source-inline">load_database()</strong> function in the <span class="No-Break"><strong class="source-inline">Server.gd</strong></span><span class="No-Break"> script.</span></li>
				<li>In the function, create a new instance of the <strong class="source-inline">FileAccess</strong> class by calling the <strong class="source-inline">open</strong> method and passing in the path to the JSON file as the first argument and <strong class="source-inline">FileAccess.READ</strong> as the second argument. The <strong class="source-inline">READ</strong> constant tells the <strong class="source-inline">FileAccess</strong> class that the file should be opened <span class="No-Break">for reading:</span><pre class="source-code">
func load_database(path_to_database_file):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)</pre></li>				<li>Once the file is open, call the <strong class="source-inline">get_as_text()</strong> method to read the contents of the file as a <span class="No-Break">text string:</span><pre class="source-code">
    var file_content = file.get_as_text()</pre></li>				<li>Next, parse the contents of the file as a JSON string using the <strong class="source-inline">JSON.parse_string()</strong> method and store the resulting dictionary in the <span class="No-Break"><strong class="source-inline">fake_database</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
    fake_database = JSON.parse_string(file_content)</pre><p class="list-inset">Before we move on to replying to the player’s authentication request, let’s see how this function looks at the end of <span class="No-Break">these steps:</span></p><pre class="source-code">func load_database(path_to_database_file):
    var file = FileAccess.open(database_file_path,
        FileAccess.READ)
    var file_content = file.get_as_text()
    database = JSON.parse_string(file_content)</pre></li>			</ol>
			<p>With our database in <a id="_idIndexMarker069"/>place, we can look at our valid players and check whether the credentials we receive in the message sent by the client match the credentials we have stored. Ideally, we would use a safer format to avoid any data leaks or hack attacks, but this should do for our <span class="No-Break">small application.</span></p>
			<p>Now, let’s see how we can reply to the client with a valid response based on whether the player was successfully authenticated or if the authentication failed. In the former case, we will provide an authentication token to the player so that they can use it across their play session in order to keep them logged in without furthe<a id="_idTextAnchor058"/>r <span class="No-Break">authentication procedures.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor059"/>Replying to the authentication request</h2>
			<p>When a client sends<a id="_idIndexMarker070"/> their credentials to the server to be authenticated, the server will receive them and start the authentication process. The server will use the credentials to search in our fake database, which contains user data, for a matching record. If the credentials match, the server will generate a session token and send it back to <span class="No-Break">the client.</span></p>
			<p>A session token<a id="_idIndexMarker071"/> is a unique string of characters that identifies the client on the server side, and the client must present it on all subsequent requests to the server to prove <span class="No-Break">their identity.</span></p>
			<p>To validate credentials, we call the <strong class="source-inline">load_database</strong> function, which we can do in the <strong class="source-inline">_ready()</strong> function to load the fake database into <span class="No-Break">our server.</span></p>
			<p>Then, we will use the username that the player provided through the <strong class="bold">LoginScreen</strong> node to look up the record in the dictionary. If the record exists, we will compare the password provided by the client with the one stored in the record. If they match, we will generate a session token and store it in the <strong class="source-inline">logged_users</strong> dictionary, along with the username, to keep track of the <span class="No-Break">authenticated users.</span></p>
			<p>If a client tries to use an invalid or expired session token, the server will deny the request, and the client will need to authenticate again. This way, we can ensure that only authenticated clients have access to the server’s resources as <span class="No-Break">they play.</span></p>
			<p>Now, let’s move on to the <strong class="source-inline">authenticate_player()</strong> function and create our authentication logic. Proceed <a id="_idIndexMarker072"/><span class="No-Break">as follows:</span></p>
			<ol>
				<li>Access the <strong class="source-inline">authenticate_credentials</strong> key from the <strong class="source-inline">message</strong> dictionary and store it in the <strong class="source-inline">credentials</strong> variable, <span class="No-Break">like so:</span><pre class="source-code">
func authenticate_player(peer, message):
    var credentials = message
        ['authenticate_credentials']</pre></li>				<li>Check whether the <strong class="source-inline">user</strong> and <strong class="source-inline">password</strong> keys are present in the <strong class="source-inline">credentials</strong> dictionary by running the <span class="No-Break">following code:</span><pre class="source-code">
    if "user" in credentials and "password" in
        credentials:</pre></li>				<li>If the keys are present, extract the values of the <strong class="source-inline">user</strong> and <strong class="source-inline">password</strong> keys from the <strong class="source-inline">credentials</strong> dictionary and store them in <span class="No-Break">separate variables:</span><pre class="source-code">
var user = credentials["user"]
var password = credentials["password"]</pre></li>				<li>Check whether the <strong class="source-inline">user</strong> key we just stored is present in our <strong class="source-inline">fake_database</strong> <span class="No-Break">dictionary keys:</span><pre class="source-code">
if user in fake_database.keys():</pre></li>				<li>If the <strong class="source-inline">user</strong> is key present, check whether the <strong class="source-inline">password</strong> key matches the one stored in the <span class="No-Break"><strong class="source-inline">fake_database</strong></span><span class="No-Break"> dictionary:</span><pre class="source-code">
if fake_database[user]["password"] == password:</pre></li>				<li>If the <strong class="source-inline">password</strong> key matches, generate a random integer token and store it in the <strong class="source-inline">logged_users</strong> dictionary with <strong class="source-inline">user</strong> as the key so that we can always check them <span class="No-Break">when necessary:</span><pre class="source-code">
var token = randi()
logged_users[user] = token</pre></li>				<li>Create a dictionary called <strong class="source-inline">response</strong> with a single key-value pair. The key is <strong class="source-inline">token</strong> and the value is the <span class="No-Break"><strong class="source-inline">token</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
var response = {"token":token}</pre></li>				<li>Send the <strong class="source-inline">response</strong> dictionary back to the client in JSON format using the <span class="No-Break"><strong class="source-inline">peer.put_var()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
peer.put_var(JSON.stringify(response))</pre></li>				<li>If the password <a id="_idIndexMarker073"/>does not match, send an empty string to the client to indicate that the <span class="No-Break">authentication failed:</span><pre class="source-code">
else:
    peer.put_var("")</pre><p class="list-inset">With that, we should have a method that properly handles and replies to the player’s authentication request. Let’s see how it <span class="No-Break">ended up:</span></p><pre class="source-code">func authenticate_player(peer, message):
    var credentials = message['authenticate_
        credentials']
    if "user" in credentials and "password" in
        credentials:
        var user = credentials["user"]
        var password = credentials["password"]
        if user in database.keys():
            if database[user]["password"] == password:
                var token = randi()
                var response = {"token":token}
                logged_users[user] = token
                peer.put_var(JSON.stringify(response))
            else:
                peer.put_var("")</pre></li>			</ol>
			<p>Now, let’s move on to one important part of this whole process. The player will get a request with a token that, as we saw in the <em class="italic">Sending Player’s Credentials</em> section, they will store in the <strong class="source-inline">AuthenticationCredentials</strong> Autoload. So, after that, the player’s game will<a id="_idIndexMarker074"/> change the scene to <strong class="bold">AvatarScreen</strong> and try to request <span class="No-Break">their avatar.</span></p>
			<p>Let’s see how players will be able to keep their session valid throughout this process. The following section is fundamental even after the player actually starts playing the game. So, stay tuned to understand how we can always ensure the play<a id="_idTextAnchor060"/>er is still holding a <span class="No-Break">valid token.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor061"/>Maintaining the player’s session</h2>
			<p>One of the most important aspects <a id="_idIndexMarker075"/>of any online game is keeping the player’s session alive throughout their playtime. In our project, we are going to make sure that the player’s token is available throughout the whole game session, even when changing between different scenes. This way, we can maintain the player’s identity as they play <span class="No-Break">the game.</span></p>
			<p>To achieve this, we will store the token on the player’s machine using the <strong class="source-inline">AuthenticationCredentials</strong> singleton. This way, the player’s token will be available to all the game’s scripts, allowing us to check whether the player is still authenticated before proceeding to any <span class="No-Break">other scene.</span></p>
			<p>By keeping the token on the player’s machine, we can avoid constant login requests to the server to authenticate the player again, ensuring faster and smoother gameplay. To ensure that the player’s credentials are still valid, we will use the <strong class="source-inline">get_authentication_token()</strong> method to allow the player’s client to make a request to the server for their <span class="No-Break">authentication token.</span></p>
			<p>We call this method whenever the player is about to transition to a new scene or when a certain amount of time has passed since their last request. This way, we can ensure that the player is still authenticated and can proceed with their gameplay without <span class="No-Break">any issues.</span></p>
			<p>So, still in the <strong class="source-inline">Server.gd</strong> script, go to the <strong class="source-inline">get_authentication_token()</strong> method, and let’s start providing players with what they need to play our game moving on! Proceed <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Inside the <strong class="source-inline">get_authentication_token()</strong> method, let’s extract the user’s information from the <strong class="source-inline">message</strong> argument. For that, we can create a new variable called <strong class="source-inline">credentials</strong> and assign it the value of the <span class="No-Break"><strong class="source-inline">message</strong></span><span class="No-Break"> argument:</span><pre class="source-code">
func get_authentication_token(peer, message):
    var credentials = message</pre></li>				<li>Then, let’s check whether the <strong class="source-inline">credentials</strong> dictionary has a key <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">"user"</strong></span><span class="No-Break">:</span><pre class="source-code">
    if "user" in credentials:</pre></li>				<li>Check whether the <strong class="source-inline">token</strong> key provided by the client matches the stored <strong class="source-inline">token</strong> key for <span class="No-Break">the user:</span><pre class="source-code">
    if credentials['token'] == logged_users
        [credentials['user']]:</pre></li>				<li>Create a <a id="_idIndexMarker076"/>variable called <strong class="source-inline">token</strong> to store the <strong class="source-inline">token</strong> key we found in the <strong class="source-inline">logged_users</strong> variable. Then, let’s return the user’s authentication <strong class="source-inline">token</strong> key by calling the <strong class="source-inline">peer.put_var()</strong> method and passing the JSON-formatted token string so that the client receives a response from <span class="No-Break">the server:</span><pre class="source-code">
    var token = logged_users[credentials['user']]
    peer.put_var(JSON.stringify(token))</pre><p class="list-inset">Our function should look <span class="No-Break">like this:</span></p><pre class="source-code">func get_authentication_token(peer, message):
    var credentials = message
    if "user" in credentials:
        if credentials['token'] == logged_users
            [credentials['user']]:
            Var token = logged_users[credentials
                ['user']]
            peer.put_var(JSON.stringify(token))</pre></li>			</ol>
			<p>Now, whenever we need to make any procedure that requires confirmation from the server that the player is still in a valid play session, we can call this function. But to actually do that, we need to add two lines of code to our server so that it understands when the client makes such <span class="No-Break">a request.</span></p>
			<p>In the <strong class="source-inline">_process()</strong> function, we check whether the client is making a request for the <strong class="source-inline">authenticate_credentials()</strong> method. Let’s check whether the client is making a request for the <strong class="source-inline">get_session_token()</strong> method<a id="_idIndexMarker077"/> instead, and if so, we call it. The <strong class="source-inline">_process()</strong> function should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func _process(delta):
    server.poll()
    if server.is_connection_available():
        var peer = server.take_connection()
        var message = JSON.parse_string(peer.get_var())
        if "authenticate_credentials" in message:
            authenticate_player(peer, message)
        elif "get_authentication_token" in message:
            get_authentication_token(peer, message)</pre>			<p>Now, let’s move on to the final part of our little project, where we are going to provi<a id="_idTextAnchor062"/>de and load the player’s <span class="No-Break">avatar data.</span></p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor063"/>Loading the player’s avatar</h1>
			<p>Welcome<a id="_idIndexMarker078"/> to <strong class="bold">AvatarScreen</strong>! This is where the player will be able to customize their avatar appearance and select a unique name in the final version of our (fake) game. To display their current available avatar, we need to load the player’s avatar data from the database and display it on <span class="No-Break">the screen.</span></p>
			<p>For that, the <strong class="bold">AvatarScreen</strong> scene is made up of a <strong class="source-inline">Control</strong> node called <strong class="bold">AvatarScreen</strong>, which holds all the other nodes in the scene, including a <strong class="source-inline">Control</strong> node <span class="No-Break">called </span><span class="No-Break"><strong class="bold">AvatarCard</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 2.5 – The AvatarScreen scene’s node hierarchy" src="image/Figure_02.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – The AvatarScreen scene’s node hierarchy</p>
			<p>The <strong class="bold">AvatarCard</strong> node <a id="_idIndexMarker079"/>contains a <strong class="bold">TextureRect</strong> node to display the avatar’s image using a texture file and a <strong class="bold">Label</strong> node to display the <span class="No-Break">avatar’s name.</span></p>
			<p>To load the player’s avatar, we first need to retrieve the path to the image file from our fake database, which we previously populated with avatar information. So, before we dive into the action in the <strong class="bold">AvatarScreen</strong> logic, let’s create the avatar retrieving logic in the <strong class="source-inline">Server.gd</strong> script, and let’s work on the <strong class="source-inline">get_avatar()</strong> function this time. Proceed <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Inside the <strong class="source-inline">get_avatar()</strong> function, create a local <strong class="source-inline">dictionary</strong> variable that contains the contents of <span class="No-Break">the message:</span><pre class="source-code">
func get_avatar(peer, message):
    var dictionary = message</pre></li>				<li>Check whether there’s a <strong class="source-inline">"user"</strong> key present in the <span class="No-Break"><strong class="source-inline">dictionary</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
    if "user" in dictionary:</pre></li>				<li>If we find the <strong class="source-inline">"user"</strong> key in this dictionary, let’s create a local <strong class="source-inline">user</strong> variable that is equal to the value of the <strong class="source-inline">user</strong> key in the <span class="No-Break"><strong class="source-inline">dictionary</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
        var user = dictionary['user']</pre></li>				<li>Check whether the <strong class="source-inline">'token'</strong> key in the <strong class="source-inline">dictionary</strong> variable matches the token stored in the <strong class="source-inline">logged_users</strong> dictionary for the user specified by the <span class="No-Break"><strong class="source-inline">user</strong></span><span class="No-Break"> key:</span><pre class="source-code">
        if dictionary['token'] == logged_users[user]:</pre></li>				<li>If this is the case, create a local <strong class="source-inline">avatar</strong> variable that is equal to the value of the <strong class="source-inline">'avatar'</strong> key in the <strong class="source-inline">fake_database</strong> dictionary for the user specified by the <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">user'</strong></span><span class="No-Break"> key:</span><pre class="source-code">
            var avatar = fake_database[dictionary
                ['user']]['avatar']</pre></li>				<li>Create a local <strong class="source-inline">nick_name</strong> variable<a id="_idIndexMarker080"/> that is equal to the value of the <strong class="source-inline">name</strong> key in the <strong class="source-inline">fake_database</strong> dictionary for the user specified by the <span class="No-Break"><strong class="source-inline">user</strong></span><span class="No-Break"> key:</span><pre class="source-code">
            var nick_name = fake_database[dictionary
                ['user']]['name']</pre></li>				<li>Create a <strong class="source-inline">response</strong> dictionary with the <strong class="source-inline">avatar</strong> and <strong class="source-inline">name</strong> keys and values of <strong class="source-inline">avatar</strong> and <span class="No-Break"><strong class="source-inline">nick_name</strong></span><span class="No-Break"> respectively:</span><pre class="source-code">
            var response = {"avatar": avatar, "name":
                nick_name}</pre></li>				<li>Use the <strong class="source-inline">peer.put_var()</strong> method to send the <strong class="source-inline">response</strong> dictionary as a JSON string to <span class="No-Break">the client:</span><pre class="source-code">
            peer.put_var(JSON.stringify(response))</pre><p class="list-inset">With that, we wrapped up our server, so we are ready to move to the <strong class="bold">AvatarScreen</strong> node. But before we do that, let’s see how the <strong class="source-inline">get_avatar()</strong> function looks after <span class="No-Break">our work:</span></p><pre class="source-code">func get_avatar(peer, message):
    var dictionary = message
    if "user" in dictionary:
        var user = dictionary['user']
        if dictionary['token'] == logged_users[user]:
            var avatar = database[dictionary
                ['user']]['avatar']
            var nick_name = database[dictionary
                ['user']]['name']
            var response = {"avatar": avatar, "name":
                nick_name}
            peer.put_var(JSON.stringify(response))</pre><p class="list-inset">Now, let’s open the <strong class="source-inline">AvatarScreen.gd</strong> script so that we can finally display our player’s avatar! Go ahead to the <strong class="source-inline">request_authentication()</strong> function because, as mentioned before, every time we need to perform operations on the player’s data, we<a id="_idIndexMarker081"/> need to verify <span class="No-Break">their credentials.</span></p></li>				<li>Inside the <strong class="source-inline">request_authentication()</strong> function, create a variable called <strong class="source-inline">request</strong> that holds a dictionary with the <strong class="source-inline">'get_authentication_token'</strong>, <strong class="source-inline">'user'</strong>, and <strong class="source-inline">'token'</strong> keys. The value of <strong class="source-inline">'get_authentication_token'</strong> should be set to <strong class="source-inline">true</strong> just so that the server understands the request, while the values of <strong class="source-inline">"user</strong><strong class="source-inline">"</strong> and <strong class="source-inline">"token"</strong> should be retrieved from the <span class="No-Break"><strong class="source-inline">AuthenticationCredentials</strong></span><span class="No-Break"> singleton:</span><pre class="source-code">
func request_authentication(packet):
    var request = {'get_authentication_token': true,
        "user": AuthenticationCredentials.user, "token
           ": AuthenticationCredentials.session_token}</pre></li>				<li>Use <strong class="source-inline">packet</strong> to send<a id="_idIndexMarker082"/> this request to the server by encoding the request as a JSON string using <strong class="source-inline">JSON.stringify()</strong> and then using the <strong class="source-inline">put_var()</strong> method to <span class="No-Break">send it:</span><pre class="source-code">
    packet.put_var(JSON.stringify(request))</pre></li>				<li>Use a <strong class="source-inline">while</strong> loop to wait for a response from the server. Inside the loop, create a variable called <strong class="source-inline">data</strong> to store the JSON response from the server, decoded <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">JSON.parse_string()</strong></span><span class="No-Break">:</span><pre class="source-code">
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())</pre></li>				<li>Check whether the <strong class="source-inline">data</strong> variable is equal to the <strong class="source-inline">session_token</strong> variable stored in the <strong class="source-inline">AuthenticationCredentials</strong> singleton. If it is, call the <strong class="source-inline">request_avatar</strong> function and break out of <span class="No-Break">the loop:</span><pre class="source-code">
        if data == AuthenticationCredentials.
            session_token:
            request_avatar(packet)
            break</pre><p class="list-inset">At the end, our <strong class="source-inline">request_authentication()</strong> function should look <span class="No-Break">like this:</span></p><pre class="source-code">func request_authentication(packet):
    var request = {'get_authentication_token': true,
        "user": AuthenticationCredentials.user,
             "token": AuthenticationCredentials.
                  session_token}
    packet.put_var(JSON.stringify(request))
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())
        if data == AuthenticationCredentials.
            session_token:
            request_avatar(packet)
            break</pre><p class="list-inset">It’s finally time to retrieve the player’s avatar data and display their avatar so that they can engage in our game world! For that, let’s go to the <strong class="source-inline">request_avatar()</strong> function and create the avatar request and creation <span class="No-Break">displaying logic.</span></p></li>				<li>Inside the <strong class="source-inline">request_avatar()</strong> function, create a dictionary named <strong class="source-inline">request</strong> with the <strong class="source-inline">'get_avatar'</strong>, <strong class="source-inline">'token'</strong>, and <strong class="source-inline">"user"</strong> keys and their respective values. We get the<a id="_idIndexMarker083"/> user and session tokens from the <span class="No-Break"><strong class="source-inline">AuthenticationCredentials</strong></span><span class="No-Break"> Autoload:</span><pre class="source-code">
func request_avatar(packet):
    var request = {'get_avatar': true, 'token':
        AuthenticationCredentials.session_token,
            "user": AuthenticationCredentials.user}</pre></li>				<li>Use the <strong class="source-inline">packet.put_var()</strong> method to send the <strong class="source-inline">request</strong> dictionary as a JSON-formatted string to <span class="No-Break">the server:</span><pre class="source-code">
    packet.put_var(JSON.stringify(request))</pre></li>				<li>Create a <strong class="source-inline">while</strong> loop to wait for the server to respond. Inside the loop, parse the response as a dictionary using the <strong class="source-inline">JSON.parse_string</strong> method and store it in a variable <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break">:</span><pre class="source-code">
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())</pre></li>				<li>Check whether the dictionary data contains the <strong class="source-inline">"avatar"</strong> key. If it does, load the texture of the avatar image from the path in the <strong class="source-inline">"avatar"</strong> key value, and set it as the texture of the <strong class="bold">TextureRect</strong> node, called <strong class="source-inline">texture_rect</strong>. Also, set the value of the <strong class="bold">Label</strong> node called <strong class="source-inline">label</strong> to the value of the <strong class="source-inline">"name"</strong> key in the <strong class="source-inline">data</strong> dictionary. Finally, exit the <strong class="source-inline">while</strong> loop <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">break</strong></span><span class="No-Break">:</span><pre class="source-code">
        if "avatar" in data:
            var texture = load(data['avatar'])
            texture_rect.texture = texture
            label.text = data['name']
            break</pre><p class="list-inset">We have almost <a id="_idIndexMarker084"/>finished our login screen! Before we add the final touch, let’s see how the <strong class="source-inline">request_avatar()</strong> method <span class="No-Break">ended up:</span></p><pre class="source-code">func request_avatar(packet):
    var request = {'get_avatar': true, 'token':
        AuthenticationCredentials.session_token,
            "user": AuthenticationCredentials.user}
    packet.put_var(JSON.stringify(request))
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())
        if "avatar" in data:
            var texture = load(data['avatar'])
            texture_rect.texture = texture
            label.text = data['name']
            break</pre></li>				<li>Now, the final<a id="_idIndexMarker085"/> touch is to add yet another check on the <strong class="source-inline">Server.gd</strong> script to handle when we receive an avatar request. So, the <strong class="source-inline">_process()</strong> method should become something <span class="No-Break">like this:</span><pre class="source-code">
func _process(delta):
    server.poll()
    if server.is_connection_available():
        var peer = server.take_connection()
        var message = JSON.parse_string
            (peer.get_var())
        if "authenticate_credentials" in message:
            authenticate_player(peer, message)
        elif "get_authentication_token" in message:
            get_authentication_token(peer, message)
        elif "get_avatar" in message:
            get_avatar(peer, message)</pre><p class="list-inset">And if we test our game by hitting the <strong class="bold">Play</strong> button, or if we test the <strong class="bold">MainMenu</strong> scene, we can verify that our game <span class="No-Break">is working!</span></p></li>				<li>The first thing we need to do is to select the <strong class="bold">Server</strong> button in one of the <span class="No-Break">debugging instances:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 2.6 – Pressing the Server button in the MainMenu scene" src="image/Figure_02.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Pressing the Server button in the MainMenu scene</p>
			<ol>
				<li value="19">Then, in another<a id="_idIndexMarker086"/> instance, choose <strong class="bold">Client</strong>, and it should immediately open the <span class="No-Break"><strong class="bold">LoginScreen</strong></span><span class="No-Break"> scene:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 2.7 – Inserting the player’s username into the client’s LoginScreen UserLineEdit" src="image/Figure_02.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Inserting the player’s username into the client’s LoginScreen UserLineEdit</p>
			<ol>
				<li value="20">Choose one of the users we have available in our fake database and insert <span class="No-Break">their credentials:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 2.8 – Inserting the player’s username into the client’s LoginScreen PasswordLineEdit" src="image/Figure_02.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Inserting the player’s username into the client’s LoginScreen PasswordLineEdit</p>
			<ol>
				<li value="21">As soon as you<a id="_idIndexMarker087"/> press the <strong class="bold">Login</strong> button with the correct credentials, it should load the <strong class="bold">AvatarScreen</strong> scene with the <span class="No-Break">respective avatar:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after a successful authentication" src="image/Figure_02.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after a successful authentication</p>
			<p>Congratulations! You’ve made your first login screen with authentication features, serializing and deserializing players’ data all across the network. Be proud of yourself—this is a <span class="No-Break">great feat!</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor064"/>Summary</h1>
			<p>In this chapter, we saw how we can establish a connection between server and client using the UDP protocol implementation in Godot Engine’s network API. With that, the network peers can open a communication channel and <span class="No-Break">exchange data.</span></p>
			<p>Since this implementation works on quite a low-level approach, we saw how we can create a simple API for our peers to make, understand, and reply to each other’s requests. Depending on the request, it might be necessary to follow a process known as serialization, which is how we take relevant information from our game state and turn it into a format that we can store and pass around. In our case, we saw that JSON format is one of the most common <span class="No-Break">serialization formats.</span></p>
			<p>Using the JSON format, we saw how we can parse our Godot Engine string as JSON and also how to turn a JSON file into a dictionary that we can work with more efficiently <span class="No-Break">using GDScript.</span></p>
			<p>At the end of the chapter, we saw how we can authenticate players’ credentials, matching them against a fake database. With successful authentication, we gathered players’ data to display their respective avatars based on their data in <span class="No-Break">our database.</span></p>
			<p>In the next chapter, we are going to add a new complexity level by allowing multiple clients to log in to the same server and finally have a shared experience. For that, we will create a <strong class="source-inline">Lobby</strong> node that displays all logged players’ names <span class="No-Break">and avatars!</span></p>
		</div>
	</body></html>