<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor037"/>2</h1>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor038"/>Sending and Receiving Data</h1>
			<p>In the previous chapter, we saw how we can establish a connection between two computers using the high-level Godot Engine <code>ENetMultiplayerPeer</code> API. But what do we do after that? Why do we establish connections between computers? The foundation of a network is the communication between the connected computers, allowing them to send and receive data. This data is transferred by breaking down the content into small chunks <a id="_idIndexMarker036"/>called <strong class="bold">packets</strong>.</p>
			<p>Each packet is like a postcard containing the necessary information, such as the sender’s and receiver’s IP addresses, the communication port, and the message’s content. We then send these packets over the network, where they can be routed to their intended recipient. Using communication protocols, such as the UDP protocol, we break the data into packets at the sending end and reassemble them at the receiving end of the relationship.</p>
			<p>In this chapter, we will discuss the fundamentals of how packets are sent and received and what makes the UDP protocol unique. For that, we’ll need to go a bit lower and use the Godot Engine <code>UDPServer</code> and <code>PacketPeerUDP</code> classes. These are lower-level API classes, so we will go through some intense content here.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Understanding packets</li>
				<li>Introduction to the <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) format</li>
				<li>Sending packets with <code>PacketPeerUDP</code></li>
				<li>Listening to packets with <code>UDPServer</code></li>
				<li>Authenticating the player</li>
				<li>Loading the player’s avatar</li>
			</ul>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor039"/>Technical requirements</h1>
			<p>In this chapter, we’re going to keep up with our project in Godot Engine, but this time, we are going to use the files provided in the <code>res://02.sending-and-receiving-data</code> folder. So, if you haven’t already done so, download the project’s repository using this link: <a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a>.</p>
			<p>Then, with the project added to your Godot Engine project manager, open the project and proceed to the <code>res://02.sending-and-receiving-data</code> folder.<a id="_idTextAnchor040"/></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor041"/>Understanding packets</h1>
			<p><strong class="bold">Packets</strong> are <a id="_idIndexMarker037"/>fundamental building blocks of communication over the network using the UDP protocol. They are small chunks of data that contain all the necessary information to reach their intended recipient. This includes the sender’s and receiver’s IP addresses, the communication port, and the message’s content.</p>
			<p>Senders send packets to the receiver over the network. The receiving end reassembles the packets, allowing the receiver to understand the message sent. This process is known as <strong class="bold">packet switching</strong>. You can<a id="_idIndexMarker038"/> see a visual representation of this here:</p>
			<div><div><img alt="Figure 2.1 – Packet switching process" src="img/Figure_02.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Packet switching process</p>
			<p>Unlike other protocols, such as the TCP protocol, the UDP protocol does not guarantee that packets will arrive in the same order as they were sent. This means that the protocol is less reliable but more efficient and faster.</p>
			<p>UDP is<a id="_idIndexMarker039"/> also different from other protocols due to its lack of connection state. Each packet contains all the data it needs to reach its receiving end. We address them individually, and the network routes them based on each packet’s own information. This contrasts with the<a id="_idIndexMarker040"/> TCP protocol as the latter needs to set up a prearranged, fixed data channel through a traditional handshake procedure.</p>
			<p>This means that we can send these packets using the UDP protocol without a handshake. As long as our server is listening to messages at the specific port we’ve assigned, it will be able to receive the sender’s message.</p>
			<p>Due to all that, the UDP protocol is more efficient for sending gameplay data across a network because it’s fast and doesn’t need to wait for confirmation of each packet in order at the receiver’s end. This is a huge advantage for online multiplayer games, especially ones where the player’s reaction time is important for the gameplay.</p>
			<p>It’s also common to use the UDP protocol for quick message systems and even voice calls. One issue that may come with using UDP for voice calls is that sometimes the audio doesn’t reach the other side in the correct order, or in any order at all. This causes some issues, but since the communication is meant to be real time and users can ask the person at the other end of the conversation to repeat, the UDP protocol has become the go-to solution for this type of service. And this is what is important to understand—when it is and when it isn’t the proper choice.</p>
			<p>Now that we have taken a glance at the protocols in which we can exchange data across the network, we need to understand what this data looks like. Can we send instances of objects across the network? How will they assemble at the receiver’s end?</p>
			<p>Network communication is a bit lower level in this sense; we need to send only relevant information in data structures that both the sender and the receiver ends can understand. And for that, we commonly avoid passing binary data around, such as objects.</p>
			<p>Instead, we serialize the important information and transmit the necessary chunks across the network so that the receiver end can create a whole new clone of the object using only the data we transmitted. This is way more reliable and allows for smaller bandwidth usage. One common data structure that we use is dictionaries in the format of JSON fil<a id="_idTextAnchor042"/>es.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor043"/>Introduction to the JSON format</h1>
			<p>In network programming, transmitting objects directly through the network is not always reliable, as the data may get corrupted or lost in transit. Moreover, transmitting objects containing executable code may pose a security risk if the code is malicious. That’s why it’s a common practice to use data serialization to convert objects into a format that can be easily transmitted over the network.</p>
			<p>One of the<a id="_idIndexMarker041"/> most commonly used data serialization formats is JSON. JSON is a lightweight, text-based format that can represent complex data structures such as arrays and objects, making it an ideal choice for network communication.</p>
			<p>When using the Godot Engine network API with UDP, sending and receiving JSON files is a common practice. With JSON, we can serialize and deserialize data quickly and efficiently. JSON files are human-readable, making it easier for developers to debug and troubleshoot issues. JSON files are also flexible, meaning we can cherry-pick only the relevant data we need to send, making network communication even more efficient.</p>
			<p>Unlike binary formats, JSON files are easy to read and modify as well. This makes it easier to debug and troubleshoot any issues that may arise during the transmission of data.</p>
			<p>Now that we understand the advantages and the overall idea behind the JSON format, how do we use it properly? How does a JSON file help us transmit data around a network and keep players in the same game context?</p>
			<p>As mentioned in this section, serialization is how we cherry-pick only the necessary information about a data structure, such as an object, and translate it into a format that we can pass around, and even store, to reconstruct the previous data structure. Serialization is one of the most important skills to learn in software engineering fields, including networks.</p>
			<p>It is through serialization that we can translate the state of our application so that other instances of our application can further replicate this state through time—for instance, to make a save and load system or through space, as we are going to do in online multiplayer games. So, let’s understand how serialization works and how to do<a id="_idTextAnchor044"/> it.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor045"/>Serialization</h2>
			<p><code>Sprite2D</code> node, into a simple, linear representation that we can store in a file. For instance, <code>*.tscn</code> files are serialized files that represent a scene in Godot Engine’s editor.</p>
			<p>Serialization<a id="_idIndexMarker043"/> involves converting an object into a format that can be easily reconstructed on another machine or in another context. This can involve encoding the object’s properties, data, and other relevant information in a standardized format, such as JSON. Serialization is essential in network communication because it allows data to be transmitted and received efficiently and reliably, while also enabling interoperability between different programming languages and systems.</p>
			<p>For instance, if we want to recreate a <code>Sprite2D</code> node on the client’s side based on data provided by the server, we can serialize important properties such as its position, rotation, scale, and texture. It would look like this:</p>
			<pre class="source-code">
{
  "position": {
    "x": 2244,
    "y": 1667
  },
  "rotation": 45,
  "scale": {
    "x": 2,
    "y": 2
  },
  "texture_path": "res://assets/objects/Bullet.png"
}</pre>			<p>So, on the client’s side, we instantiate a new <code>Sprite2D</code> node and use this data to ensure it represents what the server wants the client to see. We are going to use serialization a lot moving forward. In Godot, we have the <code>JSON</code> helper class for creating and parsing JSON data.</p>
			<p>The <code>JSON.stringify()</code> method is used to serialize an object or a data type, such as an integer or a dictionary, into a JSON-formatted string. This method takes an object as input and returns a string containing the JSON representation of the input object.</p>
			<p>The string can then be<a id="_idIndexMarker044"/> transmitted over the network, stored in a file, or used in any other context where a string representation of the object is needed. The resulting string can easily be deserialized back into an object using the <code>JSON.parse_string()</code> method.</p>
			<p>On the other hand, the <code>JSON.parse_string()</code> method is used to deserialize a JSON-formatted string back into a recognized Godot data type or object. This method takes a string as input and returns the deserialized data. The resulting object can then be used in any context where the original object was needed.</p>
			<p>When deserializing the JSON string, the method takes care of mapping the JSON values to the appropriate Godot Engine data types. This includes mapping strings to strings, numbers to numbers, and Booleans to Booleans, as well as parsing more complex types such as dictionaries and objects.</p>
			<p>With both <code>JSON.stringfy()</code> and <code>JSON.parse_string()</code> methods, Godot Engine provides a simple and reliable way to convert data into a format that can be transmitted over the network or stored in a file.</p>
			<p>We saw how we can translate our relevant data into an understandable standard format that we can store, transmit, and recreate at the receiver end. Let’s understand how we can pass this data around in the network.</p>
			<p>This is fundamental knowledge when we deal with online multiplayer games because it’s through this process that we will be able to recreate objects and even the whole game state across players, making them share the same game<a id="_idTextAnchor046"/> world.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor047"/>Sending packets with PacketPeerUDP</h1>
			<p>Now, let’s move on to<a id="_idIndexMarker045"/> practical knowledge. In this chapter, your task<a id="_idIndexMarker046"/> is to implement a login system for a game. Our project already has a cool user interface and is able to gather player data, such as their login name and password. Your mission is to make sure that only authorized players can access the game’s content by implementing a secure authentication feature.</p>
			<p>Once a player <a id="_idIndexMarker047"/>successfully logs in, you need to display their<a id="_idIndexMarker048"/> character’s avatar based on what we have saved in our database. As a network engineer, you understand the importance of security when it comes to online systems. You know that a robust authentication system is essential to ensure that only legitimate users are granted access to the game’s content.</p>
			<p>Therefore, you will need to develop a login system that checks players’ credentials against a secure database and verifies if they have permission to access the game’s features or not.</p>
			<p>With your skills and experience, you need to create a system that will provide an excellent user experience while keeping players’ data secure. So, take up the challenge, and let’s create a login system that will be a testament to your skills as a network engineer!</p>
			<p>In our project repository, open the <code>res://02.sending-and-receiving-data//MainMenu.tscn</code> scene, and let’s g<a id="_idTextAnchor048"/>et started.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor049"/>Creating an AuthenticationCredentials Autoload</h2>
			<p>In Godot Engine, <strong class="bold">Autoloads</strong> are<a id="_idIndexMarker049"/> singletons that Godot loads automatically when the game starts. We can create and edit them in the editor itself and access them from any script in the game. We use Autoloads to store game-wide data or to provide global functionality, making them a convenient way to carry players’ credentials across the game.</p>
			<p>One of the main advantages of using Autoloads for carrying player credentials is that they are available throughout scene changes. This means that any script in the game can access the Autoload and retrieve the players’ credentials when needed. This eliminates the need to pass credentials from one script to another, making the code cleaner and easier to maintain.</p>
			<p>In addition to that, since <a id="_idIndexMarker050"/>Autoloads are persistent throughout the game’s lifetime, as long as players don’t close the game, we can access their credentials.</p>
			<p>This can make the process of implementing a login system with authentication features more efficient and streamlined.</p>
			<p>So, let’s<a id="_idIndexMarker051"/> create our <code>AuthenticationCredentials</code> Autoload, as follows:</p>
			<ol>
				<li>Create a new scene using a <code>Node</code> node as the root node.</li>
				<li>Rename the root node <code>AuthenticationCredentials</code>.</li>
				<li>Attach a new script to it, save it as <code>AuthenticationCredentials.gd</code>, and open it.</li>
				<li>Create a variable to store the player’s username; we can name this variable <code>user</code>, and it should be an empty string by default:<pre class="source-code">
extends Node
var user = ""</pre></li>				<li>Then, create a variable to store the session’s token when we successfully validate a login:<pre class="source-code">
var session_token = ""</pre></li>				<li>Save the scene, then go to <strong class="bold">Project</strong> | <strong class="bold">Project Settings</strong> and open the <strong class="bold">Autoload</strong> tab.</li>
				<li>In the <strong class="bold">Path</strong> field, click <a id="_idIndexMarker052"/>on the small folder icon:</li>
			</ol>
			<div><div><img alt="Figure 2.2 – Autoload tab in the Project Settings menu" src="img/Figure_02.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Autoload tab in the Project Settings menu</p>
			<ol>
				<li value="8">From the <a id="_idIndexMarker053"/>pop-up menu, select <code>AuthenticationCredentials.tscn</code>:</li>
			</ol>
			<div><div><img alt="Figure 2.3 – Selecting the AuthenticationCredentials scene from the File menu" src="img/Figure_2.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Selecting the AuthenticationCredentials scene from the File menu</p>
			<ol>
				<li value="9">Leave the <strong class="bold">Node Name</strong> field as <strong class="bold">AuthenticationCredentials</strong> and click on the <strong class="bold">Add</strong> button.</li>
			</ol>
			<p>And there <a id="_idIndexMarker054"/>we have it. Now, you can access the variables and functions defined in the script of the <code>AuthenticationCredentials.gd</code> scene from anywhere in your project by calling the <code>AuthenticationCredentials</code> singleton.</p>
			<p>This is useful for keeping track of global state across multiple scenes and nodes in your game. It’s important to note that this Autoload should only exist on the client’s side of a multiplayer game, and not on the server’s side. So, make sure to remove it from your server application.</p>
			<p>Now, let’s see how we can gather and send players’ credentials to the server. For that, we are going to work on the very login screen itself! Open <code>LoginScreen.tscn</code> and let’s move on to <a id="_idTextAnchor050"/>the cool stuff.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor051"/>Sending players’ credentials</h2>
			<p>The <code>Control</code> node named <strong class="bold">LoginScreen</strong> with a user interface that captures players’ credentials so that we can authenticate them and give them access to our world:</p>
			<div><div><img alt="Figure 2.4 – The LoginScreen scene’s node hierarchy" src="img/Figure_02.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – The LoginScreen scene’s node hierarchy</p>
			<p>The interface includes two <code>LineEdit</code> nodes, one called <code>LineEdit</code> nodes allow players to input their login credentials. In case of any errors, we can use the <strong class="bold">ErrorLabel</strong> node to display any necessary messages.</p>
			<p>As we collect the<a id="_idIndexMarker056"/> players’ credentials here, we can use the <strong class="bold">LoginButton</strong> node to trigger the login procedure. With this scene in place, our players can securely access their avatar screen once they successfully log in.</p>
			<p>But now, we need to work on validating their logins before loading their avatar. So, let’s get our hands dirty. Proceed as follows:</p>
			<ol>
				<li>Open the <code>LoginScreen.gd</code> script and go to the <code>send_credentials()</code> function.</li>
				<li>Inside the <code>send_credentials()</code> function, create a dictionary called <code>message</code> that contains the user credentials we will authenticate in the server.</li>
				<li>To store these credentials, create a key in the message dictionary called <code>'authenticate_credentials'</code>; its value should also be a dictionary. We’ll use it to store players’ credentials.</li>
				<li>Use the <code>user_line_edit</code> and <code>password_line_edit</code> text properties to capture the player’s input for their username and password, respectively:<pre class="source-code">
    var message = {'authenticate_credentials':
        {'user': user_line_edit.text, 'password':
            password_line_edit.text}}</pre></li>				<li>Instantiate a new <code>PacketPeerUDP</code> object called <code>packet</code> using the <code>PacketPeerUDP.new()</code> constructor:<pre class="source-code">
    var packet = PacketPeerUDP.new()</pre></li>				<li>Connect the <code>packet</code> object to the server’s address and port using the <code>connect_to_host()</code> method. Here, we are using our default <code>ADDRESS</code> and <code>PORT</code> constants that represent the IP address and port number of the server to which the client is connecting. They are <code>127.0.0.1</code> and <code>9999</code> respectively:<pre class="source-code">
packet.connect_to_host(ADDRESS, PORT)</pre></li>				<li>Serialize the message dictionary object into a JSON-formatted string using the <code>JSON.stringify()</code> method, and send it to the server using the <code>packet.put_var()</code> method:<pre class="source-code">
    packet.put_var(JSON.stringify(message))</pre></li>				<li>Create a <code>while</code> loop to wait for a response from the server. The <code>packet.wait()</code> method waits for a packet to arrive at the bound address. It returns an <code>OK</code> error constant if it receives a packet; otherwise, it returns an error code based on Godot’s error constants. So, we can use that to wait for the arrival of our packet at the server’s end:<pre class="source-code">
    while packet.wait() == OK:</pre></li>				<li>When we <a id="_idIndexMarker057"/>receive a response, we need to deserialize the response data from JSON format back into a dictionary object using the <code>JSON.parse_string()</code> method. Let’s store that in a variable called <code>response</code>:<pre class="source-code">
        var response = JSON.parse_string
            (packet.get_var())</pre></li>				<li>Check the <code>response</code> dictionary for the presence of an authentication token using the <code>in</code> operator. If the <code>"token"</code> string is present, store its value in <code>AuthenticationCredentials.session_token</code>:<pre class="source-code">
        if "token" in response:
            AuthenticationCredentials.session_token =
                response['token']</pre></li>				<li>After that, we can also store the <code>user</code> present in the message we got from the server as our player’s username:<pre class="source-code">
            AuthenticationCredentials.user = message
                ['authenticate_credentials']['user']</pre></li>				<li>Update the user interface to indicate a successful authentication, and switch to the <code>AvatarScreen.tscn</code> scene. If the token is not present, display an error message to the player:<pre class="source-code">
            error_label.text = "logged!!"</pre></li>				<li>Then, after all that, we can change the scene to the actual avatar screen using the <code>get_tree().change_scene_to_file("res://AvatarScreen.tscn")</code> method and break the <code>while</code> loop:<pre class="source-code">
            get_tree().change_scene_to_file
                ("res://AvatarScreen.tscn")
            break</pre></li>				<li>In case we<a id="_idIndexMarker058"/> get a response from the server, and it doesn’t have the <code>"token"</code> key in it, we display an authentication failed message using the <code>error_label.text</code> and also break the <code>while</code> loop:<pre class="source-code">
        else:
            error_label.text = "login failed,
                check your credentials"
            break</pre><p class="list-inset">At this point, the <code>send_credentials()</code> method should look like this:</p><pre class="source-code">func send_credentials():
    var message = {'authenticate_credentials':
        {'user': user_line_edit.text, 'password':
            password_line_edit.text}}
    var packet = PacketPeerUDP.new()
    packet.connect_to_host(ADDRESS, PORT)
    packet.put_var(JSON.stringify(message))
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())
        if "token" in data:
            error_label.text = "logged!!"
            AuthenticationCredentials.user = message
                ['authenticate_credentials']['user']
            AuthenticationCredentials.session_token =
                data['token']
            get_tree().change_scene_to_file
                ("res://AvatarScreen.tscn")
            break
        else:
            error_label.text = "login failed,
                check your credentials"
            break</pre></li>			</ol>
			<p>Now that we’ve seen how the client side works and what it will do with players’ data, let’s understand how the other side of this connection will receive this data and handle it. For that, open the <a id="_idTextAnchor052"/><code>Server.tscn</code> scene.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor053"/>Listening to packets with UDPServer</h1>
			<p>Welcome to our<a id="_idIndexMarker059"/> Godot Engine server scene! This scene is where our game’s server logic is implemented.</p>
			<p>The server is the backbone of our game, responsible for authenticating players and providing them with data about their avatars, such as their name and texture file. This node is called <code>Server</code>, and it has a pre-written script that includes some essential variables. Among them are two vital variables: <code>database_file_path</code> and <code>logged_users</code>.</p>
			<p>The <code>database_file_path</code> variable<a id="_idIndexMarker060"/> is the path to the <code>FakeDatabase</code> JSON file, which represents a fake database that holds the players’ data. The <code>logged_users</code> variable is a dictionary that stores players who are currently logged in.</p>
			<p>These variables are crucial to our server’s functionality, and we will use them to authenticate players and provide them with the data they need.</p>
			<p>Let’s implement the <code>Server</code> node’s most important feature, which is to listen to packets. Proceed as follows:</p>
			<ol>
				<li>Open the <code>Server.gd</code> file.</li>
				<li>Declare a <code>server</code> variable and set it to <code>UDPServer.new()</code>. This creates a new instance of the <code>UDPServer</code> class that will allow us to listen to incoming connections:<pre class="source-code">
var server = UDPServer.new()</pre></li>				<li>In the <code>_ready()</code> function, call the <code>listen()</code> method on the <code>server</code> variable, passing our default <code>PORT</code> constant as an argument. This will start the server and make it listen for incoming connections:<pre class="source-code">
func _ready():
    server.listen(PORT)</pre></li>				<li>In the <code>_process(delta)</code> function, call the <code>poll()</code> method on the <code>server</code> variable to check for any incoming messages. This method will not block the game loop, so we can call it in the <code>_process(delta)</code> function safely:<pre class="source-code">
func _process(delta):
    server.poll()</pre></li>				<li>Call the <code>is_connection_available()</code> method on the <code>server</code> variable to check whether a client sent a message. If it returns <code>true</code>, call the <code>take_connection()</code> method to obtain a <code>PacketPeerUDP</code> instance that we can use to read the incoming message:<pre class="source-code">
if server.is_connection_available():
    var peer = server.take_connection()</pre></li>				<li>Use the <code>get_var()</code> method on the <code>PacketPeerUDP</code> instance we get to obtain the incoming message. Since we know that the message is a string in JSON format, we can use the <code>JSON.parse_string()</code> method to convert it to a dictionary object that we can work with:<pre class="source-code">
var message = JSON.parse_string(peer.get_var())</pre></li>				<li>Check whether <a id="_idIndexMarker061"/>the incoming message contains the <code>"authenticate_credentials"</code> key. If it does, call the <code>authenticate_player()</code> function, passing <code>peer</code> and <code>message</code> as arguments:<pre class="source-code">
if "authenticate_credentials" in message:
    authenticate_player(peer, message)</pre><p class="list-inset">We will create the <code>authenticate_player()</code> method in a moment, but for now, our script should look like this:</p><pre class="source-code">extends Node
const PORT = 9999
@export var database_file_path =
    "res://FakeDatabase.json"
var database = {}
var logged_users = {}
var server = UDPServer.new()
func _ready():
    server.listen(PORT)
func _process(delta):
    server.poll()
    if server.is_connection_available():
        var peer = server.take_connection()
        var message = JSON.parse_string
            (peer.get_var())
        if "authenticate_credentials" in message:
            authenticate_player(peer, message)</pre></li>			</ol>
			<p>We just saw how we <a id="_idIndexMarker062"/>can open a communication channel between the client and the server and start to listen to messages. With that, we can filter these messages so that the server knows what the client is requesting—in our case, to authenticate the players’ credentials.</p>
			<p>This is a low-level implementation of a network API. With that, we can create standard message formats and contents that trigger events on the server side and expect standard responses from the server. Let’s see how our server replies <a id="_idTextAnchor054"/>to this client request.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor055"/>Authenticating the player</h1>
			<p>Authenticating player <a id="_idIndexMarker063"/>credentials is a crucial aspect of any multiplayer game. In our project, we are building a login system for a game using Godot Engine. The login system allows players to log in with their username and password and then displays their character’s avatar upon successful login.</p>
			<p>We are going to use a fake database, stored as a JSON file, to represent the players’ credentials. While this approach is simpler than using a full-fledged database management system, it has its own security risks. So, be aware of the risks of this approach in a production-ready project.</p>
			<p>To authenticate player credentials in our project, we will also use Godot’s <code>FileAccess</code> class to load the fake database from the JSON file and parse the data. This will allow us to compare players’ login credentials with the data in the database and authenticate the player if<a id="_idTextAnchor056"/> the credentials match.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor057"/>Loading a fake database</h2>
			<p>Now, let’s load our database so<a id="_idIndexMarker064"/> that we can check whether the data we got from the player’s client matches anything on our server. In a nutshell, a database is an organized collection of data. In our case, we’ll use a JSON file format as our database.</p>
			<p>The advantage of using JSON files as databases is that they are easy to manipulate, and you don’t need to have prior knowledge of database structures and safety.</p>
			<p>For instance, our fake database consists of the following:</p>
			<pre class="source-code">
{
  "user1": {
    "password":"test",
    "avatar":"res://Avatars/adventurer_idle.png",
    "name":"Sakaki"
  },
  "user2": {
    "password":"test",
    "avatar":"res://Avatars/player_idle.png",
    "name":"Keyaki"
  }
}</pre>			<p>You can even open it in the very Godot Text Editor itself; just double-click the <code>res://FakeDatabase.json</code> file provided in our base project.</p>
			<p>The preceding JSON file represents a simple database that contains two user entries, <code>"user1"</code> and <code>"user2"</code>, each with a corresponding set of data. The data contained for each user includes a password, an avatar, and a name.</p>
			<p>The <code>"password"</code> field holds the plain-text password for each user. This is a very simple approach to storing passwords, as it is not secure due to the possibility of it being compromised. However, it is suitable for educational purposes.</p>
			<p>The <code>"avatar"</code> field contains a reference to a file that represents the user’s avatar. In this case, it is referencing two different image files from our game, one for each user.</p>
			<p>Finally, the <code>"name"</code> field simply holds a string that represents the player’s avatar name.</p>
			<p>Note that a database file shouldn’t by any means be available to the client. So, in your final project, make sure to <a id="_idIndexMarker065"/>remove your database file from Godot’s project and into a safe database device.</p>
			<p>While JSON files are a great choice for certain projects, they may not be suitable for others. Here are some pros and cons to consider:</p>
			<ul>
				<li><strong class="bold">Pros</strong>:<ul><li>They are easy to <a id="_idIndexMarker066"/>read and write, making them a great choice for small projects or when the speed of development is a priority</li><li>JSON files can be parsed natively by most programming languages, including GDScript as we saw previously, which means you don’t need to install any additional software or libraries to work with them</li><li>As we just saw, JSON files are human-readable and can be opened and edited using a simple text editor, which makes them great for debugging</li></ul></li>
				<li><strong class="bold">Cons</strong>:<ul><li>They don’t <a id="_idIndexMarker067"/>scale well for large projects with many concurrent users, as there may be issues with data consistency and performance</li><li>JSON files are not as flexible as other database formats when it comes to querying data and performing complex operations</li></ul></li>
			</ul>
			<p>To load and read the data from<a id="_idIndexMarker068"/> our JSON fake database file, we’ll use Godot Engine’s <code>FileAccess</code> class.</p>
			<p>The <code>FileAccess</code> class is a built-in Godot class that provides an interface to load, read, write, and save files to and from the user’s disk. It is a powerful tool that is essential for any game or application that needs to access files from the user’s device.</p>
			<p>Let’s dive into the specifics of how to use this class to load and parse our JSON fake database file into our game, as follows:</p>
			<ol>
				<li>Go to the <code>load_database()</code> function in the <code>Server.gd</code> script.</li>
				<li>In the function, create a new instance of the <code>FileAccess</code> class by calling the <code>open</code> method and passing in the path to the JSON file as the first argument and <code>FileAccess.READ</code> as the second argument. The <code>READ</code> constant tells the <code>FileAccess</code> class that the file should be opened for reading:<pre class="source-code">
func load_database(path_to_database_file):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)</pre></li>				<li>Once the file is open, call the <code>get_as_text()</code> method to read the contents of the file as a text string:<pre class="source-code">
    var file_content = file.get_as_text()</pre></li>				<li>Next, parse the contents of the file as a JSON string using the <code>JSON.parse_string()</code> method and store the resulting dictionary in the <code>fake_database</code> variable:<pre class="source-code">
    fake_database = JSON.parse_string(file_content)</pre><p class="list-inset">Before we move on to replying to the player’s authentication request, let’s see how this function looks at the end of these steps:</p><pre class="source-code">func load_database(path_to_database_file):
    var file = FileAccess.open(database_file_path,
        FileAccess.READ)
    var file_content = file.get_as_text()
    database = JSON.parse_string(file_content)</pre></li>			</ol>
			<p>With our database in <a id="_idIndexMarker069"/>place, we can look at our valid players and check whether the credentials we receive in the message sent by the client match the credentials we have stored. Ideally, we would use a safer format to avoid any data leaks or hack attacks, but this should do for our small application.</p>
			<p>Now, let’s see how we can reply to the client with a valid response based on whether the player was successfully authenticated or if the authentication failed. In the former case, we will provide an authentication token to the player so that they can use it across their play session in order to keep them logged in without furthe<a id="_idTextAnchor058"/>r authentication procedures.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor059"/>Replying to the authentication request</h2>
			<p>When a client sends<a id="_idIndexMarker070"/> their credentials to the server to be authenticated, the server will receive them and start the authentication process. The server will use the credentials to search in our fake database, which contains user data, for a matching record. If the credentials match, the server will generate a session token and send it back to the client.</p>
			<p>A session token<a id="_idIndexMarker071"/> is a unique string of characters that identifies the client on the server side, and the client must present it on all subsequent requests to the server to prove their identity.</p>
			<p>To validate credentials, we call the <code>load_database</code> function, which we can do in the <code>_ready()</code> function to load the fake database into our server.</p>
			<p>Then, we will use the username that the player provided through the <code>logged_users</code> dictionary, along with the username, to keep track of the authenticated users.</p>
			<p>If a client tries to use an invalid or expired session token, the server will deny the request, and the client will need to authenticate again. This way, we can ensure that only authenticated clients have access to the server’s resources as they play.</p>
			<p>Now, let’s move on to the <code>authenticate_player()</code> function and create our authentication logic. Proceed <a id="_idIndexMarker072"/>as follows:</p>
			<ol>
				<li>Access the <code>authenticate_credentials</code> key from the <code>message</code> dictionary and store it in the <code>credentials</code> variable, like so:<pre class="source-code">
func authenticate_player(peer, message):
    var credentials = message
        ['authenticate_credentials']</pre></li>				<li>Check whether the <code>user</code> and <code>password</code> keys are present in the <code>credentials</code> dictionary by running the following code:<pre class="source-code">
    if "user" in credentials and "password" in
        credentials:</pre></li>				<li>If the keys are present, extract the values of the <code>user</code> and <code>password</code> keys from the <code>credentials</code> dictionary and store them in separate variables:<pre class="source-code">
var user = credentials["user"]
var password = credentials["password"]</pre></li>				<li>Check whether the <code>user</code> key we just stored is present in our <code>fake_database</code> dictionary keys:<pre class="source-code">
if user in fake_database.keys():</pre></li>				<li>If the <code>user</code> is key present, check whether the <code>password</code> key matches the one stored in the <code>fake_database</code> dictionary:<pre class="source-code">
if fake_database[user]["password"] == password:</pre></li>				<li>If the <code>password</code> key matches, generate a random integer token and store it in the <code>logged_users</code> dictionary with <code>user</code> as the key so that we can always check them when necessary:<pre class="source-code">
var token = randi()
logged_users[user] = token</pre></li>				<li>Create a dictionary called <code>response</code> with a single key-value pair. The key is <code>token</code> and the value is the <code>token</code> variable:<pre class="source-code">
var response = {"token":token}</pre></li>				<li>Send the <code>response</code> dictionary back to the client in JSON format using the <code>peer.put_var()</code> method:<pre class="source-code">
peer.put_var(JSON.stringify(response))</pre></li>				<li>If the password <a id="_idIndexMarker073"/>does not match, send an empty string to the client to indicate that the authentication failed:<pre class="source-code">
else:
    peer.put_var("")</pre><p class="list-inset">With that, we should have a method that properly handles and replies to the player’s authentication request. Let’s see how it ended up:</p><pre class="source-code">func authenticate_player(peer, message):
    var credentials = message['authenticate_
        credentials']
    if "user" in credentials and "password" in
        credentials:
        var user = credentials["user"]
        var password = credentials["password"]
        if user in database.keys():
            if database[user]["password"] == password:
                var token = randi()
                var response = {"token":token}
                logged_users[user] = token
                peer.put_var(JSON.stringify(response))
            else:
                peer.put_var("")</pre></li>			</ol>
			<p>Now, let’s move on to one important part of this whole process. The player will get a request with a token that, as we saw in the <em class="italic">Sending Player’s Credentials</em> section, they will store in the <code>AuthenticationCredentials</code> Autoload. So, after that, the player’s game will<a id="_idIndexMarker074"/> change the scene to <strong class="bold">AvatarScreen</strong> and try to request their avatar.</p>
			<p>Let’s see how players will be able to keep their session valid throughout this process. The following section is fundamental even after the player actually starts playing the game. So, stay tuned to understand how we can always ensure the play<a id="_idTextAnchor060"/>er is still holding a valid token.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor061"/>Maintaining the player’s session</h2>
			<p>One of the most important aspects <a id="_idIndexMarker075"/>of any online game is keeping the player’s session alive throughout their playtime. In our project, we are going to make sure that the player’s token is available throughout the whole game session, even when changing between different scenes. This way, we can maintain the player’s identity as they play the game.</p>
			<p>To achieve this, we will store the token on the player’s machine using the <code>AuthenticationCredentials</code> singleton. This way, the player’s token will be available to all the game’s scripts, allowing us to check whether the player is still authenticated before proceeding to any other scene.</p>
			<p>By keeping the token on the player’s machine, we can avoid constant login requests to the server to authenticate the player again, ensuring faster and smoother gameplay. To ensure that the player’s credentials are still valid, we will use the <code>get_authentication_token()</code> method to allow the player’s client to make a request to the server for their authentication token.</p>
			<p>We call this method whenever the player is about to transition to a new scene or when a certain amount of time has passed since their last request. This way, we can ensure that the player is still authenticated and can proceed with their gameplay without any issues.</p>
			<p>So, still in the <code>Server.gd</code> script, go to the <code>get_authentication_token()</code> method, and let’s start providing players with what they need to play our game moving on! Proceed as follows:</p>
			<ol>
				<li>Inside the <code>get_authentication_token()</code> method, let’s extract the user’s information from the <code>message</code> argument. For that, we can create a new variable called <code>credentials</code> and assign it the value of the <code>message</code> argument:<pre class="source-code">
func get_authentication_token(peer, message):
    var credentials = message</pre></li>				<li>Then, let’s check whether the <code>credentials</code> dictionary has a key called <code>"user"</code>:<pre class="source-code">
    if "user" in credentials:</pre></li>				<li>Check whether the <code>token</code> key provided by the client matches the stored <code>token</code> key for the user:<pre class="source-code">
    if credentials['token'] == logged_users
        [credentials['user']]:</pre></li>				<li>Create a <a id="_idIndexMarker076"/>variable called <code>token</code> to store the <code>token</code> key we found in the <code>logged_users</code> variable. Then, let’s return the user’s authentication <code>token</code> key by calling the <code>peer.put_var()</code> method and passing the JSON-formatted token string so that the client receives a response from the server:<pre class="source-code">
    var token = logged_users[credentials['user']]
    peer.put_var(JSON.stringify(token))</pre><p class="list-inset">Our function should look like this:</p><pre class="source-code">func get_authentication_token(peer, message):
    var credentials = message
    if "user" in credentials:
        if credentials['token'] == logged_users
            [credentials['user']]:
            Var token = logged_users[credentials
                ['user']]
            peer.put_var(JSON.stringify(token))</pre></li>			</ol>
			<p>Now, whenever we need to make any procedure that requires confirmation from the server that the player is still in a valid play session, we can call this function. But to actually do that, we need to add two lines of code to our server so that it understands when the client makes such a request.</p>
			<p>In the <code>_process()</code> function, we check whether the client is making a request for the <code>authenticate_credentials()</code> method. Let’s check whether the client is making a request for the <code>get_session_token()</code> method<a id="_idIndexMarker077"/> instead, and if so, we call it. The <code>_process()</code> function should look like this:</p>
			<pre class="source-code">
func _process(delta):
    server.poll()
    if server.is_connection_available():
        var peer = server.take_connection()
        var message = JSON.parse_string(peer.get_var())
        if "authenticate_credentials" in message:
            authenticate_player(peer, message)
        elif "get_authentication_token" in message:
            get_authentication_token(peer, message)</pre>			<p>Now, let’s move on to the final part of our little project, where we are going to provi<a id="_idTextAnchor062"/>de and load the player’s avatar data.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor063"/>Loading the player’s avatar</h1>
			<p>Welcome<a id="_idIndexMarker078"/> to <strong class="bold">AvatarScreen</strong>! This is where the player will be able to customize their avatar appearance and select a unique name in the final version of our (fake) game. To display their current available avatar, we need to load the player’s avatar data from the database and display it on the screen.</p>
			<p>For that, the <code>Control</code> node called <code>Control</code> node called <strong class="bold">AvatarCard</strong>:</p>
			<div><div><img alt="Figure 2.5 – The AvatarScreen scene’s node hierarchy" src="img/Figure_02.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – The AvatarScreen scene’s node hierarchy</p>
			<p>The <strong class="bold">AvatarCard</strong> node <a id="_idIndexMarker079"/>contains a <strong class="bold">TextureRect</strong> node to display the avatar’s image using a texture file and a <strong class="bold">Label</strong> node to display the avatar’s name.</p>
			<p>To load the player’s avatar, we first need to retrieve the path to the image file from our fake database, which we previously populated with avatar information. So, before we dive into the action in the <code>Server.gd</code> script, and let’s work on the <code>get_avatar()</code> function this time. Proceed as follows:</p>
			<ol>
				<li>Inside the <code>get_avatar()</code> function, create a local <code>dictionary</code> variable that contains the contents of the message:<pre class="source-code">
func get_avatar(peer, message):
    var dictionary = message</pre></li>				<li>Check whether there’s a <code>"user"</code> key present in the <code>dictionary</code> variable:<pre class="source-code">
    if "user" in dictionary:</pre></li>				<li>If we find the <code>"user"</code> key in this dictionary, let’s create a local <code>user</code> variable that is equal to the value of the <code>user</code> key in the <code>dictionary</code> variable:<pre class="source-code">
        var user = dictionary['user']</pre></li>				<li>Check whether the <code>'token'</code> key in the <code>dictionary</code> variable matches the token stored in the <code>logged_users</code> dictionary for the user specified by the <code>user</code> key:<pre class="source-code">
        if dictionary['token'] == logged_users[user]:</pre></li>				<li>If this is the case, create a local <code>avatar</code> variable that is equal to the value of the <code>'avatar'</code> key in the <code>fake_database</code> dictionary for the user specified by the <code>'</code><code>user'</code> key:<pre class="source-code">
            var avatar = fake_database[dictionary
                ['user']]['avatar']</pre></li>				<li>Create a local <code>nick_name</code> variable<a id="_idIndexMarker080"/> that is equal to the value of the <code>name</code> key in the <code>fake_database</code> dictionary for the user specified by the <code>user</code> key:<pre class="source-code">
            var nick_name = fake_database[dictionary
                ['user']]['name']</pre></li>				<li>Create a <code>response</code> dictionary with the <code>avatar</code> and <code>name</code> keys and values of <code>avatar</code> and <code>nick_name</code> respectively:<pre class="source-code">
            var response = {"avatar": avatar, "name":
                nick_name}</pre></li>				<li>Use the <code>peer.put_var()</code> method to send the <code>response</code> dictionary as a JSON string to the client:<pre class="source-code">
            peer.put_var(JSON.stringify(response))</pre><p class="list-inset">With that, we wrapped up our server, so we are ready to move to the <code>get_avatar()</code> function looks after our work:</p><pre class="source-code">func get_avatar(peer, message):
    var dictionary = message
    if "user" in dictionary:
        var user = dictionary['user']
        if dictionary['token'] == logged_users[user]:
            var avatar = database[dictionary
                ['user']]['avatar']
            var nick_name = database[dictionary
                ['user']]['name']
            var response = {"avatar": avatar, "name":
                nick_name}
            peer.put_var(JSON.stringify(response))</pre><p class="list-inset">Now, let’s open the <code>AvatarScreen.gd</code> script so that we can finally display our player’s avatar! Go ahead to the <code>request_authentication()</code> function because, as mentioned before, every time we need to perform operations on the player’s data, we<a id="_idIndexMarker081"/> need to verify their credentials.</p></li>				<li>Inside the <code>request_authentication()</code> function, create a variable called <code>request</code> that holds a dictionary with the <code>'get_authentication_token'</code>, <code>'user'</code>, and <code>'token'</code> keys. The value of <code>'get_authentication_token'</code> should be set to <code>true</code> just so that the server understands the request, while the values of <code>"user</code><code>"</code> and <code>"token"</code> should be retrieved from the <code>AuthenticationCredentials</code> singleton:<pre class="source-code">
func request_authentication(packet):
    var request = {'get_authentication_token': true,
        "user": AuthenticationCredentials.user, "token
           ": AuthenticationCredentials.session_token}</pre></li>				<li>Use <code>packet</code> to send<a id="_idIndexMarker082"/> this request to the server by encoding the request as a JSON string using <code>JSON.stringify()</code> and then using the <code>put_var()</code> method to send it:<pre class="source-code">
    packet.put_var(JSON.stringify(request))</pre></li>				<li>Use a <code>while</code> loop to wait for a response from the server. Inside the loop, create a variable called <code>data</code> to store the JSON response from the server, decoded using <code>JSON.parse_string()</code>:<pre class="source-code">
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())</pre></li>				<li>Check whether the <code>data</code> variable is equal to the <code>session_token</code> variable stored in the <code>AuthenticationCredentials</code> singleton. If it is, call the <code>request_avatar</code> function and break out of the loop:<pre class="source-code">
        if data == AuthenticationCredentials.
            session_token:
            request_avatar(packet)
            break</pre><p class="list-inset">At the end, our <code>request_authentication()</code> function should look like this:</p><pre class="source-code">func request_authentication(packet):
    var request = {'get_authentication_token': true,
        "user": AuthenticationCredentials.user,
             "token": AuthenticationCredentials.
                  session_token}
    packet.put_var(JSON.stringify(request))
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())
        if data == AuthenticationCredentials.
            session_token:
            request_avatar(packet)
            break</pre><p class="list-inset">It’s finally time to retrieve the player’s avatar data and display their avatar so that they can engage in our game world! For that, let’s go to the <code>request_avatar()</code> function and create the avatar request and creation displaying logic.</p></li>				<li>Inside the <code>request_avatar()</code> function, create a dictionary named <code>request</code> with the <code>'get_avatar'</code>, <code>'token'</code>, and <code>"user"</code> keys and their respective values. We get the<a id="_idIndexMarker083"/> user and session tokens from the <code>AuthenticationCredentials</code> Autoload:<pre class="source-code">
func request_avatar(packet):
    var request = {'get_avatar': true, 'token':
        AuthenticationCredentials.session_token,
            "user": AuthenticationCredentials.user}</pre></li>				<li>Use the <code>packet.put_var()</code> method to send the <code>request</code> dictionary as a JSON-formatted string to the server:<pre class="source-code">
    packet.put_var(JSON.stringify(request))</pre></li>				<li>Create a <code>while</code> loop to wait for the server to respond. Inside the loop, parse the response as a dictionary using the <code>JSON.parse_string</code> method and store it in a variable named <code>data</code>:<pre class="source-code">
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())</pre></li>				<li>Check whether the dictionary data contains the <code>"avatar"</code> key. If it does, load the texture of the avatar image from the path in the <code>"avatar"</code> key value, and set it as the texture of the <code>texture_rect</code>. Also, set the value of the <code>label</code> to the value of the <code>"name"</code> key in the <code>data</code> dictionary. Finally, exit the <code>while</code> loop with <code>break</code>:<pre class="source-code">
        if "avatar" in data:
            var texture = load(data['avatar'])
            texture_rect.texture = texture
            label.text = data['name']
            break</pre><p class="list-inset">We have almost <a id="_idIndexMarker084"/>finished our login screen! Before we add the final touch, let’s see how the <code>request_avatar()</code> method ended up:</p><pre class="source-code">func request_avatar(packet):
    var request = {'get_avatar': true, 'token':
        AuthenticationCredentials.session_token,
            "user": AuthenticationCredentials.user}
    packet.put_var(JSON.stringify(request))
    while packet.wait() == OK:
        var data = JSON.parse_string(packet.get_var())
        if "avatar" in data:
            var texture = load(data['avatar'])
            texture_rect.texture = texture
            label.text = data['name']
            break</pre></li>				<li>Now, the final<a id="_idIndexMarker085"/> touch is to add yet another check on the <code>Server.gd</code> script to handle when we receive an avatar request. So, the <code>_process()</code> method should become something like this:<pre class="source-code">
func _process(delta):
    server.poll()
    if server.is_connection_available():
        var peer = server.take_connection()
        var message = JSON.parse_string
            (peer.get_var())
        if "authenticate_credentials" in message:
            authenticate_player(peer, message)
        elif "get_authentication_token" in message:
            get_authentication_token(peer, message)
        elif "get_avatar" in message:
            get_avatar(peer, message)</pre><p class="list-inset">And if we test our game by hitting the <strong class="bold">Play</strong> button, or if we test the <strong class="bold">MainMenu</strong> scene, we can verify that our game is working!</p></li>				<li>The first thing we need to do is to select the <strong class="bold">Server</strong> button in one of the debugging instances:</li>
			</ol>
			<div><div><img alt="Figure 2.6 – Pressing the Server button in the MainMenu scene" src="img/Figure_02.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Pressing the Server button in the MainMenu scene</p>
			<ol>
				<li value="19">Then, in another<a id="_idIndexMarker086"/> instance, choose <strong class="bold">Client</strong>, and it should immediately open the <strong class="bold">LoginScreen</strong> scene:</li>
			</ol>
			<div><div><img alt="Figure 2.7 – Inserting the player’s username into the client’s LoginScreen UserLineEdit" src="img/Figure_02.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Inserting the player’s username into the client’s LoginScreen UserLineEdit</p>
			<ol>
				<li value="20">Choose one of the users we have available in our fake database and insert their credentials:</li>
			</ol>
			<div><div><img alt="Figure 2.8 – Inserting the player’s username into the client’s LoginScreen PasswordLineEdit" src="img/Figure_02.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Inserting the player’s username into the client’s LoginScreen PasswordLineEdit</p>
			<ol>
				<li value="21">As soon as you<a id="_idIndexMarker087"/> press the <strong class="bold">Login</strong> button with the correct credentials, it should load the <strong class="bold">AvatarScreen</strong> scene with the respective avatar:</li>
			</ol>
			<div><div><img alt="Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after a successful authentication" src="img/Figure_02.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after a successful authentication</p>
			<p>Congratulations! You’ve made your first login screen with authentication features, serializing and deserializing players’ data all across the network. Be proud of yourself—this is a great feat!</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor064"/>Summary</h1>
			<p>In this chapter, we saw how we can establish a connection between server and client using the UDP protocol implementation in Godot Engine’s network API. With that, the network peers can open a communication channel and exchange data.</p>
			<p>Since this implementation works on quite a low-level approach, we saw how we can create a simple API for our peers to make, understand, and reply to each other’s requests. Depending on the request, it might be necessary to follow a process known as serialization, which is how we take relevant information from our game state and turn it into a format that we can store and pass around. In our case, we saw that JSON format is one of the most common serialization formats.</p>
			<p>Using the JSON format, we saw how we can parse our Godot Engine string as JSON and also how to turn a JSON file into a dictionary that we can work with more efficiently using GDScript.</p>
			<p>At the end of the chapter, we saw how we can authenticate players’ credentials, matching them against a fake database. With successful authentication, we gathered players’ data to display their respective avatars based on their data in our database.</p>
			<p>In the next chapter, we are going to add a new complexity level by allowing multiple clients to log in to the same server and finally have a shared experience. For that, we will create a <code>Lobby</code> node that displays all logged players’ names and avatars!</p>
		</div>
	</body></html>