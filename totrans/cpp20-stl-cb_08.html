<html><head></head><body>
		<div id="_idContainer042">
			<h1 id="_idParaDest-251"><a id="_idTextAnchor250"/><em class="italic">Chapter 8</em>: Utility Classes</h1>
			<p>The C++ Standard Library includes an assortment of utility classes designed for specific tasks. Some are common, and you've probably seen many of these classes in other recipes in this book.</p>
			<p>This chapter covers a broad range of utilities, including time measurement, generic types, smart pointers, and more, in the following recipes:</p>
			<ul>
				<li>Manage optional values with <strong class="source-inline">std::optional</strong></li>
				<li>Use <strong class="source-inline">std::any</strong> for type safety</li>
				<li>Store different types with <strong class="source-inline">std::variant</strong></li>
				<li>Time events with <strong class="source-inline">std::chrono</strong></li>
				<li>Use fold expressions for variadic tuples</li>
				<li>Manage allocated memory with <strong class="source-inline">std::unique_ptr</strong></li>
				<li>Share objects with <strong class="source-inline">std::shared_ptr</strong></li>
				<li>Use weak pointers with shared objects</li>
				<li>Share members of a managed object</li>
				<li>Compare random number engines</li>
				<li>Compare random number distribution generators</li>
			</ul>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor251"/>Technical requirements</h1>
			<p>The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08</a>.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/>Manage optional values with std::optional</h1>
			<p>Introduced<a id="_idIndexMarker666"/> with <a id="_idIndexMarker667"/>C++17, the <strong class="source-inline">std::optional</strong> class holds an <em class="italic">optional value</em>.</p>
			<p>Consider the case where you have a function that may or may not return a value – for example, a function that checks if a number is <em class="italic">prime</em> but returns the first factor if there is one. This function should return either a value or a <strong class="source-inline">bool</strong> status. We could create a <strong class="source-inline">struct</strong> that carries both value and status:</p>
			<p class="source-code">struct factor_t {</p>
			<p class="source-code">    bool is_prime;</p>
			<p class="source-code">    long factor;</p>
			<p class="source-code">};</p>
			<p class="source-code">factor_t factor(long n) {</p>
			<p class="source-code">    factor_t r{};</p>
			<p class="source-code">    for(long i = 2; i &lt;= n / 2; ++i) {</p>
			<p class="source-code">        if (n % i == 0) {</p>
			<p class="source-code">            r.is_prime = false;</p>
			<p class="source-code">            r.factor = i;</p>
			<p class="source-code">            return r;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    r.is_prime = true;</p>
			<p class="source-code">    return r;</p>
			<p class="source-code">}</p>
			<p>It's a clumsy solution but it works, and it's not uncommon. </p>
			<p>It could be made a lot simpler with the <strong class="source-inline">optional</strong> class:</p>
			<p class="source-code">optional&lt;long&gt; factor(long n) {</p>
			<p class="source-code">    for (long i = 2; i &lt;= n / 2; ++i) {</p>
			<p class="source-code">        if (n % i == 0) return {i};</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return {};</p>
			<p class="source-code">}</p>
			<p>With <strong class="source-inline">optional</strong>, we can<a id="_idIndexMarker668"/> return a value or a <a id="_idIndexMarker669"/>non-value.</p>
			<p>We can call it, like this:</p>
			<p class="source-code">long a{ 42 };</p>
			<p class="source-code">long b{ 73 };</p>
			<p class="source-code">auto x = factor(a);</p>
			<p class="source-code">auto y = factor(b);</p>
			<p class="source-code">if(x) cout &lt;&lt; format("lowest factor of {} is {}\n", a, *x);</p>
			<p class="source-code">else cout &lt;&lt; format("{} is prime\n", a);</p>
			<p class="source-code">if(y) cout &lt;&lt; format("lowest factor of {} is {}\n", b, *y);</p>
			<p class="source-code">else cout &lt;&lt; format("{} is prime\n", b);</p>
			<p>Our output is:</p>
			<p class="source-code">lowest factor of 42 is 2</p>
			<p class="source-code">73 is prime</p>
			<p>The optional class allows us to easily return the optional value and easily test for a value. </p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>How to do it…</h2>
			<p>In this recipe, we'll look at some examples of how to use the <strong class="source-inline">optional</strong> class:</p>
			<ul>
				<li>The <strong class="source-inline">optional</strong> class is quite simple. We construct an optional value using standard template notation: <p class="source-code"><strong class="bold">optional&lt;int&gt;</strong> a{ 42 };</p><p class="source-code">cout &lt;&lt; *a &lt;&lt; '\n';</p></li>
			</ul>
			<p>We access the value of the <strong class="source-inline">optional</strong> with the <strong class="source-inline">*</strong> pointer dereference operator. </p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">42</strong></p>
			<ul>
				<li>We test if the <strong class="source-inline">optional</strong> has a value using its <strong class="source-inline">bool</strong> operator:<p class="source-code"><strong class="bold">if(a)</strong> cout &lt;&lt; *a &lt;&lt; '\n';</p><p class="source-code">else cout &lt;&lt; "no value\n";<strong class="source-inline"> </strong></p></li>
			</ul>
			<p>If <strong class="source-inline">a</strong> were <a id="_idIndexMarker670"/>constructed without a <a id="_idIndexMarker671"/>value:</p>
			<p class="source-code">optional&lt;int&gt; a{};</p>
			<p>The output would reflect the <strong class="source-inline">else</strong> condition:</p>
			<p class="source-code"><strong class="bold">no value</strong></p>
			<ul>
				<li>We can further simplify this by declaring a <em class="italic">type alias</em>:<p class="source-code"><strong class="bold">using</strong> oint = std::optional&lt;int&gt;;</p><p class="source-code"><strong class="bold">oint</strong> a{ 42 };</p><p class="source-code"><strong class="bold">oint</strong> b{ 73 };</p></li>
				<li>If we want to operate on <strong class="source-inline">oint</strong> objects, with <strong class="source-inline">oint</strong> objects as the result, we can provide operator overloads:<p class="source-code">oint <strong class="bold">operator+</strong>(const oint&amp; a, const oint&amp; b) {</p><p class="source-code">    <strong class="bold">if(a &amp;&amp; b)</strong> return *a + *b;</p><p class="source-code">    else return <strong class="bold">{}</strong>;</p><p class="source-code">}</p><p class="source-code">oint <strong class="bold">operator+</strong>(const oint&amp; a, const int b) {</p><p class="source-code">    <strong class="bold">if(a)</strong> return *a + b;</p><p class="source-code">    else return <strong class="bold">{}</strong>;</p><p class="source-code">}</p></li>
			</ul>
			<p>Now, we can operate on the <strong class="source-inline">oint</strong> objects directly:</p>
			<p class="source-code">auto sum{ <strong class="bold">a + b</strong> };</p>
			<p class="source-code"><strong class="bold">if(sum)</strong> {</p>
			<p class="source-code">    cout &lt;&lt; format("{} + {} = {}\n", *a, *b, *sum);</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    cout &lt;&lt; "NAN\n";</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">42 + 73 = 115</strong></p>
			<ul>
				<li>Suppose <a id="_idIndexMarker672"/>we<a id="_idIndexMarker673"/> declare <strong class="source-inline">b</strong> with the default constructor:<p class="source-code">oint <strong class="bold">b{}</strong>;</p></li>
			</ul>
			<p>Now, we get the <strong class="source-inline">else</strong> branch output:</p>
			<p class="source-code">NAN</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/>How it works…</h2>
			<p>The <strong class="source-inline">std::optional</strong> class is made for simplicity. It provides operator overloads for many common functions. It also includes member functions for further flexibility.</p>
			<p>The <strong class="source-inline">optional</strong> class provides an <strong class="source-inline">operator bool</strong> overload for determining if the object has a value:</p>
			<p class="source-code">optional&lt;int&gt; n{ 42 };</p>
			<p class="source-code">if(n) ... // has a value</p>
			<p>Or, you may use the <strong class="source-inline">has_value()</strong> member function:</p>
			<p class="source-code">if(n.has_value()) ... // has a value</p>
			<p>To access the value, you may use the <strong class="source-inline">operator*</strong> overload:</p>
			<p class="source-code">x = *n;  // * retruns the value</p>
			<p>Or, you may use the <strong class="source-inline">value()</strong> member function:</p>
			<p class="source-code">x = n.value();  // * retruns the value</p>
			<p>The <strong class="source-inline">reset()</strong> member <a id="_idIndexMarker674"/>function destroys the value and<a id="_idIndexMarker675"/> resets the state of the <strong class="source-inline">optional</strong> object:</p>
			<p class="source-code">n.reset();      // no longer has a value</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor255"/>There's more…</h2>
			<p>The <strong class="source-inline">optional</strong> class <a id="_idIndexMarker676"/>provides exception support with the <strong class="source-inline">value()</strong> method:</p>
			<p class="source-code">b.reset();</p>
			<p class="source-code">try {</p>
			<p class="source-code">    cout &lt;&lt; b.<strong class="bold">value()</strong> &lt;&lt; '\n';</p>
			<p class="source-code">} catch(const <strong class="bold">std::bad_optional_access</strong>&amp; e) {</p>
			<p class="source-code">    cout &lt;&lt; format("b.value(): {}\n", e.what());</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">b.value(): bad optional access</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Only the <strong class="source-inline">value()</strong> method throws an exception. The behavior of the <strong class="source-inline">*</strong> operator is <em class="italic">undefined</em> for an invalid value.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor256"/>Use std::any for type safety</h1>
			<p>Introduced <a id="_idIndexMarker677"/>with C++17, the <strong class="source-inline">std::any</strong> class provides a type-safe container for a single object of any type. </p>
			<p>For example, this is a default-constructed <strong class="source-inline">any</strong> object:</p>
			<p class="source-code">any x{};</p>
			<p>This object has no value. We can test that with the <strong class="source-inline">has_value()</strong> method:</p>
			<p class="source-code">if(x.has_value()) cout &lt;&lt; "have value\n";</p>
			<p class="source-code">else cout &lt;&lt; "no value\n";</p>
			<p>Output:</p>
			<p class="source-code">no value</p>
			<p>We assign a value to the <strong class="source-inline">any</strong> object with the assignment operator:</p>
			<p class="source-code">x = 42;</p>
			<p>Now, the <strong class="source-inline">any</strong> object has a value, and a type:</p>
			<p class="source-code">if(x.has_value()) {</p>
			<p class="source-code">    cout &lt;&lt; format("x has type: {}\n", x.type().name());</p>
			<p class="source-code">    cout &lt;&lt; format("x has value: {}\n", any_cast&lt;int&gt;(x));</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    cout &lt;&lt; "no value\n";</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">x has type: i</p>
			<p class="source-code">x has value: 42</p>
			<p>The <strong class="source-inline">type()</strong> method returns a <strong class="source-inline">type_info</strong> object. The <strong class="source-inline">type_info::name()</strong> method returns an implementation-defined name for the type in a C-string. In this case, for GCC, the <strong class="source-inline">i</strong> means <strong class="source-inline">int</strong>.</p>
			<p>We use the <strong class="source-inline">any_cast&lt;</strong><em class="italic">type</em><strong class="source-inline">&gt;()</strong> non-member function to cast the value for use.</p>
			<p>We can re-assign the <strong class="source-inline">any</strong> object with different values of different types:</p>
			<p class="source-code">x = "abc"s;</p>
			<p class="source-code">cout &lt;&lt; format("x is type {} with value {}\n", </p>
			<p class="source-code">    x.type().name(), any_cast&lt;string&gt;(x))</p>
			<p>Output:</p>
			<p class="source-code">x is type NSt7__cxx1112basic_string... with value abc</p>
			<p>I've abbreviated the long type name from GCC but you get the idea. The same <strong class="source-inline">any</strong> object that once held an <strong class="source-inline">int</strong> now contains an STL <strong class="source-inline">string</strong> object.</p>
			<p>The main usefulness of the <strong class="source-inline">any</strong> class is in creating a polymorphic function. Let's examine<a id="_idIndexMarker678"/> how to do that in this recipe:</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor257"/>How to do it…</h2>
			<p>In this recipe, we'll build a polymorphic function using the <strong class="source-inline">any</strong> class. A polymorphic function is one that can take objects of different types in its parameters:</p>
			<ul>
				<li>Our polymorphic function takes an <strong class="source-inline">any</strong> object and prints its type and value:<p class="source-code">void <strong class="bold">p_any</strong>(const <strong class="bold">any</strong>&amp; a) {</p><p class="source-code">    if (!a.<strong class="bold">has_value()</strong>) {</p><p class="source-code">        cout &lt;&lt; "None.\n";</p><p class="source-code">    } else if (<strong class="bold">a.type()</strong> == typeid(<strong class="bold">int</strong>)) {</p><p class="source-code">        cout &lt;&lt; format("int: {}\n", any_cast&lt;<strong class="bold">int</strong>&gt;(a));</p><p class="source-code">    } else if (<strong class="bold">a.type()</strong> == typeid(<strong class="bold">string</strong>)) {</p><p class="source-code">        cout &lt;&lt; format("string: \"{}\"\n", </p><p class="source-code">            any_cast&lt;<strong class="bold">const string</strong>&amp;&gt;(a));</p><p class="source-code">    } else if (<strong class="bold">a.type()</strong> == typeid(<strong class="bold">list&lt;int&gt;</strong>)) {</p><p class="source-code">        cout &lt;&lt; "list&lt;int&gt;: ";</p><p class="source-code">        for(auto&amp; i : any_cast&lt;<strong class="bold">const list&lt;int&gt;</strong>&amp;&gt;(a)) </p><p class="source-code">            cout &lt;&lt; format("{} ", i);</p><p class="source-code">        cout &lt;&lt; '\n';</p><p class="source-code">    } <strong class="bold">else</strong> {</p><p class="source-code">        cout &lt;&lt; format("something else: {}\n", </p><p class="source-code">            a.type().name());</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">p_any()</strong> function first tests to see if the object has a value. It then tests the <strong class="source-inline">type()</strong> method against various types and takes appropriate action for each type. </p>
			<p>Before the <strong class="source-inline">any</strong> class, we<a id="_idIndexMarker679"/> would have had to write four different specializations for this function, and we still wouldn't be able to easily handle the default case.</p>
			<ul>
				<li>We call this function from <strong class="source-inline">main()</strong>, like this:<p class="source-code">p_any({});</p><p class="source-code">p_any(47);</p><p class="source-code">p_any("abc"s);</p><p class="source-code">p_any(any(list{ 1, 2, 3 }));</p><p class="source-code">p_any(any(vector{ 1, 2, 3 }));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code">None.</p>
			<p class="source-code">int: 47</p>
			<p class="source-code">string: "abc"</p>
			<p class="source-code">list&lt;int&gt;: 1 2 3</p>
			<p class="source-code">something else: St6vectorIiSaIiEE</p>
			<p>Our polymorphic function handles the various types with a minimum of code.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor258"/>How it works…</h2>
			<p>The <strong class="source-inline">std::any</strong> copy constructor and assignment operator use <em class="italic">direct initialization</em> to make a non-<strong class="source-inline">const</strong> copy of the target object as the <em class="italic">contained</em> object. The type of the contained object is stored separately as a <strong class="source-inline">typeid</strong> object. </p>
			<p>Once initialized, the <strong class="source-inline">any</strong> object has the following methods:</p>
			<ul>
				<li><strong class="source-inline">emplace()</strong> replaces the contained object, constructing the new object in place.</li>
				<li><strong class="source-inline">reset()</strong> destroys the contained object.</li>
				<li><strong class="source-inline">has_value()</strong> returns <strong class="source-inline">true</strong> if there is a contained object.</li>
				<li><strong class="source-inline">type()</strong> returns a <strong class="source-inline">typeid</strong> object, representing the type of the contained object.</li>
				<li><strong class="source-inline">operator=()</strong> replaces the contained object by a <em class="italic">copy</em> or <em class="italic">move</em> operation.</li>
			</ul>
			<p>The <strong class="source-inline">any</strong> class<a id="_idIndexMarker680"/> also supports the following non-member functions:</p>
			<ul>
				<li><strong class="source-inline">any_cast&lt;T&gt;()</strong>, a template function, provides type-safe access to the contained object.</li>
			</ul>
			<p>Keep in mind that the <strong class="source-inline">any_cast&lt;T&gt;()</strong> function returns a copy of the contained object. You may use <strong class="source-inline">any_cast&lt;T&amp;&gt;()</strong> to return a reference.</p>
			<ul>
				<li><strong class="source-inline">std::swap()</strong> specializes the <strong class="source-inline">std::swap</strong> algorithm.<strong class="source-inline"> </strong></li>
			</ul>
			<p>If you try to cast an <strong class="source-inline">any</strong> object with the wrong type, it throws a <strong class="source-inline">bad_any_cast</strong> exception:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    cout &lt;&lt; any_cast&lt;int&gt;(x) &lt;&lt; '\n';</p>
			<p class="source-code">} catch(std::bad_any_cast&amp; e) {</p>
			<p class="source-code">    cout &lt;&lt; format("any: {}\n", e.what());</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">any: bad any_cast</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor259"/>Store different types with std::variant</h1>
			<p>Introduced <a id="_idIndexMarker681"/>with C++17, the <strong class="source-inline">std::variant</strong> class may hold different values, one at a time, where each value must fit in the same allocated memory space. It's useful for holding alternative types for use in a single context. </p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor260"/>Differences from the primitive union structure</h2>
			<p>The <strong class="source-inline">variant</strong> class<a id="_idIndexMarker682"/> is a <em class="italic">tagged union</em>. It differs<a id="_idIndexMarker683"/> from the primitive <strong class="source-inline">union</strong> structure in that only one type may be in effect at a time.</p>
			<p>The primitive <strong class="source-inline">union</strong> type, inherited from C, is a structure where the same datum may be accessed as different types. For example:</p>
			<p class="source-code">union ipv4 {</p>
			<p class="source-code">    struct {</p>
			<p class="source-code">        uint8_t <strong class="bold">a</strong>; uint8_t <strong class="bold">b</strong>; uint8_t <strong class="bold">c</strong>; uint8_t <strong class="bold">d</strong>;</p>
			<p class="source-code">    } quad;</p>
			<p class="source-code">    uint32_t <strong class="bold">int32</strong>;</p>
			<p class="source-code">} addr;</p>
			<p class="source-code">addr.<strong class="bold">int32</strong> = 0x2A05A8C0;</p>
			<p class="source-code">cout &lt;&lt; format("ip addr dotted quad: {}.{}.{}.{}\n", </p>
			<p class="source-code">    addr.<strong class="bold">quad.a</strong>, addr.<strong class="bold">quad.b</strong>, addr.<strong class="bold">quad.c</strong>, addr.<strong class="bold">quad.d</strong>);</p>
			<p class="source-code">cout &lt;&lt; format("ip addr int32 (LE): {:08X}\n", addr.<strong class="bold">int32</strong>);</p>
			<p>Output:</p>
			<p class="source-code">ip addr dotted quad: 192.168.5.42</p>
			<p class="source-code">ip addr int32 (LE): 2A05A8C0</p>
			<p>In this example, the <strong class="source-inline">union</strong> has two members, types <strong class="source-inline">struct</strong> and <strong class="source-inline">uint32_t</strong>, where <strong class="source-inline">struct</strong> has four <strong class="source-inline">uint8_t</strong> members. This gives us two <em class="italic">different perspectives of the same 32-bit memory space</em>. We can view the same <strong class="source-inline">ipv4</strong> address as either a 32-bit unsigned <a id="_idIndexMarker684"/>integer (<strong class="bold">Little Endian</strong> or <strong class="bold">LE</strong>) or four 8-bit unsigned integers in the common <em class="italic">dotted quad</em> notation. This provides a bitwise polymorphy that can be useful at the systems level.</p>
			<p><strong class="source-inline">variant</strong> doesn't work<a id="_idIndexMarker685"/> like that. The <strong class="source-inline">variant</strong> class<a id="_idIndexMarker686"/> is a <em class="italic">tagged union</em>, where each datum is tagged with its type. If we store a value as <strong class="source-inline">uint32_t</strong>, we may only access it as <strong class="source-inline">uint32_t</strong>. This makes <strong class="source-inline">variant</strong> type safe but not a replacement for <strong class="source-inline">union</strong>.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor261"/>How to do it…</h2>
			<p>In this recipe, we<a id="_idIndexMarker687"/> demonstrate the use of <strong class="source-inline">std::variant</strong> with a small catalogue of household pets of various species.</p>
			<ul>
				<li>We'll start with a simple class to hold an <strong class="source-inline">Animal</strong>:<p class="source-code">class Animal {</p><p class="source-code">    string_view _name{};</p><p class="source-code">    string_view _sound{};</p><p class="source-code">    Animal();</p><p class="source-code">public:</p><p class="source-code">    Animal(string_view n, string_view s) </p><p class="source-code">        : _name{ n }, _sound{ s } {}</p><p class="source-code">    void speak() const {</p><p class="source-code">        cout &lt;&lt; format("{} says {}\n", _name, _sound);</p><p class="source-code">    }</p><p class="source-code">    void sound(string_view s) {</p><p class="source-code">        _sound = s;</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>The name of the animal and the sound that the animal makes are passed in the constructor. </p>
			<ul>
				<li>Individual<a id="_idIndexMarker688"/> species classes inherit from <strong class="source-inline">Animal</strong>:<p class="source-code">class Cat : public Animal {</p><p class="source-code">public:</p><p class="source-code">    Cat(string_view n) : Animal(n, "meow") {}</p><p class="source-code">};</p><p class="source-code">class Dog : public Animal {</p><p class="source-code">public:</p><p class="source-code">    Dog(string_view n) : Animal(n, "arf!") {}</p><p class="source-code">};</p><p class="source-code">class Wookie : public Animal {</p><p class="source-code">public:</p><p class="source-code">    Wookie(string_view n) : Animal(n, "grrraarrgghh!") {}</p><p class="source-code">};</p></li>
			</ul>
			<p>Each of these classes set the sound for their specific species by calling the parent constructor.</p>
			<ul>
				<li>Now, we can define our <strong class="source-inline">variant</strong> type in an alias:<p class="source-code">using v_animal = std::variant&lt;Cat, Dog, Wookie&gt;;</p></li>
			</ul>
			<p>This <strong class="source-inline">variant</strong> can hold any of the types, <strong class="source-inline">Cat</strong>, <strong class="source-inline">Dog</strong>, or <strong class="source-inline">Wookie</strong>.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we create a <strong class="source-inline">list</strong> using our <strong class="source-inline">v_animal</strong> alias as the type:<p class="source-code">int main() {</p><p class="source-code">    list&lt;v_animal&gt; pets{ </p><p class="source-code">        <strong class="bold">Cat</strong>{"Hobbes"}, <strong class="bold">Dog</strong>{"Fido"}, <strong class="bold">Cat</strong>{"Max"}, </p><p class="source-code">        <strong class="bold">Wookie</strong>{"Chewie"}</p><p class="source-code">    };</p><p class="source-code">    ...</p></li>
			</ul>
			<p>Each element in the list is of a type included in the <strong class="source-inline">variant</strong> definition. </p>
			<ul>
				<li>The <strong class="source-inline">variant</strong> class provides several different ways to access elements. First, we'll look at the <strong class="source-inline">visit()</strong> function. </li>
			</ul>
			<p><strong class="source-inline">visit()</strong> calls a <em class="italic">functor</em> with the object currently contained in the <strong class="source-inline">variant</strong>. First, let's <a id="_idIndexMarker689"/>define a functor that accepts any of our pets:</p>
			<p class="source-code">struct animal_speaks {</p>
			<p class="source-code">    void operator()(const Dog&amp; d) const { d.speak(); }</p>
			<p class="source-code">    void operator()(const Cat&amp; c) const { c.speak(); }</p>
			<p class="source-code">    void operator()(const Wookie&amp; w) const { </p>
			<p class="source-code">      w.speak(); }</p>
			<p class="source-code">};</p>
			<p>This is a simple functor class with overloads for each of the <strong class="source-inline">Animal</strong> sub-classes. We call it with <strong class="source-inline">visit()</strong>, with each of our <strong class="source-inline">list</strong> elements:</p>
			<p class="source-code">for (const v_animal&amp; a : pets) {</p>
			<p class="source-code">    visit(animal_speaks{}, a);</p>
			<p class="source-code">}</p>
			<p>We get this output:</p>
			<p class="source-code"><strong class="bold">Hobbes says meow</strong></p>
			<p class="source-code"><strong class="bold">Fido says arf!</strong></p>
			<p class="source-code"><strong class="bold">Max says meow</strong></p>
			<p class="source-code"><strong class="bold">Chewie says grrraarrgghh!</strong></p>
			<ul>
				<li>The <strong class="source-inline">variant</strong> class also provides an <strong class="source-inline">index()</strong> method:<p class="source-code">for(const v_animal &amp;a : pets) {</p><p class="source-code">    auto idx{ a.index() };</p><p class="source-code">    if(idx == 0) get&lt;Cat&gt;(a).speak();</p><p class="source-code">    if(idx == 1) get&lt;Dog&gt;(a).speak();</p><p class="source-code">    if(idx == 2) get&lt;Wookie&gt;(a).speak();</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Hobbes says meow</strong></p>
			<p class="source-code"><strong class="bold">Fido says arf!</strong></p>
			<p class="source-code"><strong class="bold">Max says meow</strong></p>
			<p class="source-code"><strong class="bold">Chewie says grrraarrgghh!</strong></p>
			<p>Each <strong class="source-inline">variant</strong> object<a id="_idIndexMarker690"/> is indexed, based on the order in which the types were declared in the template arguments. Our <strong class="source-inline">v_animal</strong> type was defined with <strong class="source-inline">std::variant&lt;Cat, Dog, Wookie&gt;</strong>, and these types are indexed as <strong class="source-inline">0</strong> – <strong class="source-inline">2</strong>, in that order.</p>
			<ul>
				<li>The <strong class="source-inline">get_if&lt;T&gt;()</strong> function tests a given element against a type:<p class="source-code">for (const v_animal&amp; a : pets) {</p><p class="source-code">    if(const auto c{ get_if&lt;Cat&gt;(&amp;a) }; c) {</p><p class="source-code">        c-&gt;speak();</p><p class="source-code">    } else if(const auto d{ get_if&lt;Dog&gt;(&amp;a) }; d) {</p><p class="source-code">        d-&gt;speak();</p><p class="source-code">    } else if(const auto w{ get_if&lt;Wookie&gt;(&amp;a) }; w) {</p><p class="source-code">        w-&gt;speak();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Hobbes says meow</strong></p>
			<p class="source-code"><strong class="bold">Fido says arf!</strong></p>
			<p class="source-code"><strong class="bold">Max says meow</strong></p>
			<p class="source-code"><strong class="bold">Chewie says grrraarrgghh!</strong></p>
			<p>The <strong class="source-inline">get_if&lt;T&gt;()</strong> function returns a pointer if the type of the element matches <strong class="source-inline">T</strong>; otherwise, it returns <strong class="source-inline">nullptr</strong>.</p>
			<ul>
				<li>Finally, the <strong class="source-inline">holds_alternative&lt;T&gt;()</strong> function returns <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. We can<a id="_idIndexMarker691"/> use this to test a type against an element, without returning the element:<p class="source-code">size_t n_cats{}, n_dogs{}, n_wookies{};</p><p class="source-code">for(const v_animal&amp; a : pets) {</p><p class="source-code">    if(holds_alternative&lt;Cat&gt;(a)) ++n_cats;</p><p class="source-code">    if(holds_alternative&lt;Dog&gt;(a)) ++n_dogs;</p><p class="source-code">    if(holds_alternative&lt;Wookie&gt;(a)) ++n_wookies;</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; format("there are {} cat(s), "</p><p class="source-code">               "{} dog(s), "</p><p class="source-code">               "and {} wookie(s)\n",</p><p class="source-code">               n_cats, n_dogs, n_wookies);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">there are 2 cat(s), 1 dog(s), and 1 wookie(s)</strong></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor262"/>How it works…</h2>
			<p>The <strong class="source-inline">std::variant</strong> class is a single-object container. An instance of <strong class="source-inline">variant&lt;X, Y, Z&gt;</strong> must hold exactly one object of type <strong class="source-inline">X</strong>, <strong class="source-inline">Y</strong>, or <strong class="source-inline">Z</strong>. It holds both the value and the type of its current object.</p>
			<p>The <strong class="source-inline">index()</strong> method tells us the type of the current object:</p>
			<p class="source-code">if(v.index() == 0) // if variant is type X</p>
			<p>The <strong class="source-inline">holds_alternative&lt;T&gt;()</strong> non-member function returns <strong class="source-inline">true</strong> if <strong class="source-inline">T</strong> is the type of the current object:</p>
			<p class="source-code">if(holds_alternative&lt;X&gt;(v))  // if current variant obj is type X</p>
			<p>We can<a id="_idIndexMarker692"/> retrieve the current object with the <strong class="source-inline">get()</strong> non-member function:</p>
			<p class="source-code">auto o{ get&lt;X&gt;(v) };  // current variant obj must be type X</p>
			<p>We can combine the test for type and retrieval with the <strong class="source-inline">get_if()</strong> non-member function:</p>
			<p class="source-code">auto* p{ get_if&lt;X&gt;(v) };  // nullptr if current obj not type X</p>
			<p>The <strong class="source-inline">visit()</strong> non-member function invokes a callable object with the current variant object as its single parameter:</p>
			<p class="source-code">visit(f, v);  // calls f(v) with current variant obj</p>
			<p>The <strong class="source-inline">visit()</strong> function is the only way to retrieve an object without testing its type. In combination with a functor that can handle each type, this can be very flexible:</p>
			<p class="source-code">struct animal_speaks {</p>
			<p class="source-code">    void operator()(const Dog&amp; d) const { d.speak(); }</p>
			<p class="source-code">    void operator()(const Cat&amp; c) const { c.speak(); }</p>
			<p class="source-code">    void operator()(const Wookie&amp; v) const { v.speak(); }</p>
			<p class="source-code">};</p>
			<p class="source-code">main() {</p>
			<p class="source-code">    for (const v_animal&amp; a : pets) {</p>
			<p class="source-code">        visit(animal_speaks{}, a);</p>
			<p class="source-code">    } </p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">Hobbes says meow</p>
			<p class="source-code">Fido says arf!</p>
			<p class="source-code">Max says meow</p>
			<p class="source-code">Chewie says grrraarrgghh!</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor263"/>Time events with std::chrono</h1>
			<p>The <strong class="source-inline">std::chrono</strong> library <a id="_idIndexMarker693"/>provides tools for measuring and <a id="_idIndexMarker694"/>reporting time and intervals. </p>
			<p>Many of these classes and functions were introduced with C++11. There have been significant changes and updates for C++20, but at the time of writing, many of those updates are not yet implemented on the systems I've tested.</p>
			<p>Using the <strong class="source-inline">chrono</strong> library, this recipe explores techniques for timing events. </p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor264"/>How to do it…</h2>
			<p>The <strong class="source-inline">system_clock</strong> class is used for reporting the current date and time. The <strong class="source-inline">steady_clock</strong> and <strong class="source-inline">high_resolution_clock</strong> classes are used for timing events. Let's look at the differences between these clocks:</p>
			<ul>
				<li>Because these names can be long and unwieldy, we'll use some type aliases throughout this recipe:<p class="source-code">using std::chrono::system_clock;</p><p class="source-code">using std::chrono::steady_clock;</p><p class="source-code">using std::chrono::high_resolution_clock;</p><p class="source-code">using std::chrono::duration;</p><p class="source-code">using seconds = duration&lt;double&gt;;</p><p class="source-code">using milliseconds = duration&lt;double, std::milli&gt;;</p><p class="source-code">using microseconds = duration&lt;double, std::micro&gt;;</p><p class="source-code">using fps24 = duration&lt;unsigned long, std::ratio&lt;1, 24&gt;&gt;;</p></li>
			</ul>
			<p>The <strong class="source-inline">duration</strong> class <a id="_idIndexMarker695"/>represents an interval between two points<a id="_idIndexMarker696"/> in time. These aliases are convenient for using different intervals.</p>
			<ul>
				<li>We can get the current time and date by using the <strong class="source-inline">system_clock</strong> class:<p class="source-code">auto t = <strong class="bold">system_clock::now()</strong>;</p><p class="source-code">cout &lt;&lt; format("system_clock::now is <strong class="bold">{:%F %T}</strong>\n", t);</p></li>
			</ul>
			<p>The <strong class="source-inline">system_clock::now()</strong> function returns a <strong class="source-inline">time_point</strong> object. The <strong class="source-inline">&lt;chrono&gt;</strong> library includes a <strong class="source-inline">format()</strong> specialization for <strong class="source-inline">time_point</strong> that uses <strong class="source-inline">strftime()</strong> format specifiers.</p>
			<p>The output is:</p>
			<p class="source-code"><strong class="bold">system_clock::now is 2022-02-05 13:52:15</strong></p>
			<p>The <strong class="source-inline">&lt;iomanip&gt;</strong> header includes <strong class="source-inline">put_time()</strong>, which works like <strong class="source-inline">strftime()</strong> for <strong class="source-inline">ostream</strong>:</p>
			<p class="source-code">std::time_t now_t = <strong class="bold">system_clock::to_time_t(t)</strong>;</p>
			<p class="source-code">cout &lt;&lt; "system_clock::now is " </p>
			<p class="source-code">     &lt;&lt; std::put_time(std::localtime(&amp;now_t), "%F %T") </p>
			<p class="source-code">     &lt;&lt; '\n';</p>
			<p><strong class="source-inline">put_time()</strong> takes a pointer to a C-style <strong class="source-inline">time_t*</strong> value. <strong class="source-inline">system_clock::to_time_t</strong> converts a <strong class="source-inline">time_point</strong> object to <strong class="source-inline">time_t</strong>.</p>
			<p>This gives the same output as our <strong class="source-inline">format()</strong> example:</p>
			<p class="source-code"><strong class="bold">system_clock::now is 2022-02-05 13:52:15</strong></p>
			<ul>
				<li>We can also use <strong class="source-inline">system_clock</strong> to time an event. First, we need something to time. Here's<a id="_idIndexMarker697"/> a<a id="_idIndexMarker698"/> function that counts prime numbers:<p class="source-code">constexpr uint64_t MAX_PRIME{ 0x1FFFF }</p><p class="source-code">uint64_t count_primes() {</p><p class="source-code">    constexpr auto is_prime = [](const uint64_t n) {</p><p class="source-code">        for(uint64_t i{ 2 }; i &lt; n / 2; ++i) {</p><p class="source-code">            if(n % i == 0) return false;</p><p class="source-code">        }</p><p class="source-code">        return true;</p><p class="source-code">    };</p><p class="source-code">    uint64_t count{ 0 };</p><p class="source-code">    uint64_t start{ 2 };</p><p class="source-code">    uint64_t end{ MAX_PRIME };</p><p class="source-code">    for(uint64_t i{ start }; i &lt;= end ; ++i) {</p><p class="source-code">        if(is_prime(i)) ++count;</p><p class="source-code">   }</p><p class="source-code">   return count;</p><p class="source-code">}</p></li>
			</ul>
			<p>This function counts the prime numbers between 2 and <strong class="source-inline">0x1FFFF</strong> (131,071), which should take a few seconds on most modern systems. </p>
			<ul>
				<li>Now, we write a <strong class="source-inline">timer</strong> function to time our <strong class="source-inline">count_primes()</strong>:<p class="source-code"><strong class="bold">seconds</strong> timer(uint64_t(*f)()) {</p><p class="source-code">    auto t1{ <strong class="bold">system_clock</strong>::now() };</p><p class="source-code">    uint64_t count{ f() };</p><p class="source-code">    auto t2{ <strong class="bold">system_clock</strong>::now() };</p><p class="source-code">    <strong class="bold">seconds</strong> secs{ t2 - t1 };</p><p class="source-code">    cout &lt;&lt; format("there are {} primes in range\n", </p><p class="source-code">      count);</p><p class="source-code">    return secs;</p><p class="source-code">}</p></li>
			</ul>
			<p>This <a id="_idIndexMarker699"/>function <a id="_idIndexMarker700"/>takes an function <strong class="source-inline">f</strong> and returns <strong class="source-inline">duration&lt;double&gt;</strong>. We use <strong class="source-inline">system_clock::now()</strong> to mark the time before and after the call to <strong class="source-inline">f()</strong>. We take the difference between the two times and return it in a <strong class="source-inline">duration</strong> object.</p>
			<ul>
				<li>We can call our <strong class="source-inline">timer()</strong> from <strong class="source-inline">main()</strong>, like this:<p class="source-code">int main() {</p><p class="source-code">    auto <strong class="bold">secs</strong>{ <strong class="bold">timer</strong>(<strong class="bold">count_primes</strong>) };</p><p class="source-code">    cout &lt;&lt; format("time elapsed: {:.3f} seconds\n", </p><p class="source-code">        secs.<strong class="bold">count</strong>());</p><p class="source-code">    ...</p></li>
			</ul>
			<p>This passes the <strong class="source-inline">count_primes()</strong> function to <strong class="source-inline">timer()</strong> and stores the <strong class="source-inline">duration</strong> object in <strong class="source-inline">secs</strong>.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">there are 12252 primes in range</strong></p>
			<p class="source-code"><strong class="bold">time elapsed: 3.573 seconds</strong></p>
			<p>The <strong class="source-inline">count()</strong> method on the <strong class="source-inline">duration</strong> object returns the duration in the specified units – in this case, <strong class="source-inline">double</strong>, representing <em class="italic">seconds</em> of duration. </p>
			<p>This was run on a VM running <em class="italic">Debian</em> with GCC. The exact time will vary on different systems.</p>
			<ul>
				<li>The <strong class="source-inline">system_clock</strong> class is designed to provide the current <em class="italic">wall clock</em> time. While its resolution may support timing purposes, it is not guaranteed to be <em class="italic">monotonic</em>. In other words, it may not always provide consistent <em class="italic">ticks</em> (timing intervals).</li>
			</ul>
			<p>The <strong class="source-inline">chrono</strong> library <a id="_idIndexMarker701"/>provides a more suitable clock<a id="_idIndexMarker702"/> in <strong class="source-inline">steady_clock</strong>. It has the same interface as <strong class="source-inline">system_clock</strong> but provides more reliable ticks for timing purposes:</p>
			<p class="source-code">seconds timer(uint64_t(*f)()) {</p>
			<p class="source-code">    auto t1{ <strong class="bold">steady_clock</strong>::now() };</p>
			<p class="source-code">    uint64_t count{ f() };</p>
			<p class="source-code">    auto t2{ <strong class="bold">steady_clock</strong>::now() };</p>
			<p class="source-code">    seconds secs{ t2 - t1 };</p>
			<p class="source-code">    cout &lt;&lt; format("there are {} primes in range\n", </p>
			<p class="source-code">      count);</p>
			<p class="source-code">    return secs;</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">steady_clock</strong> is designed to provide reliably consistent monotonic ticks, suitable for timing events. It uses a relative time reference, so it's not useful for wall clock time. While <strong class="source-inline">system_clock</strong> measures by beginning from a fixed point in time (1 January 1970, 00:00 UTC), <strong class="source-inline">steady_clock</strong> uses a relative time. </p>
			<p>Another option is <strong class="source-inline">high_resolution_clock</strong>, which provides the shortest tick period available on a given system but is not implemented consistently across different implementations. It may be an alias for <strong class="source-inline">system_clock</strong> or <strong class="source-inline">steady_clock</strong>, and it may or may not be monotonic. <strong class="source-inline">high_resolution_clock</strong> is not recommended for general-purpose use.</p>
			<ul>
				<li>Our <strong class="source-inline">timer()</strong> function returns <strong class="source-inline">seconds</strong>, which is an alias for <strong class="source-inline">duration&lt;double&gt;</strong>:<p class="source-code">using seconds = duration&lt;double&gt;;</p></li>
			</ul>
			<p>The duration<a id="_idIndexMarker703"/> class takes an optional second template <a id="_idIndexMarker704"/>parameter, a <strong class="source-inline">std::ratio</strong> class:</p>
			<p class="source-code">template&lt;class Rep, class Period = std::ratio&lt;1&gt;&gt;</p>
			<p class="source-code">class duration;</p>
			<p>The <strong class="source-inline">&lt;chrono&gt;</strong> header provides convenience types for many decimal ratios, including <strong class="source-inline">milli</strong> and <strong class="source-inline">micro</strong>:</p>
			<p class="source-code">using milliseconds = duration&lt;double, std::milli&gt;;</p>
			<p class="source-code">using microseconds = duration&lt;double, std::micro&gt;;</p>
			<p>If we require something else, we may provide our own:</p>
			<p class="source-code">using fps24 = duration&lt;unsigned long, std::ratio&lt;1, 24&gt;&gt;;</p>
			<p><strong class="source-inline">fps24</strong> represents the number of frames of film shot at the standard 24 frames per second. The ratio is 1/24 of a second.</p>
			<p>This allows us to easily convert between different ranges of duration:</p>
			<p class="source-code">cout &lt;&lt; format("time elapsed: {:.3f} sec\n", <strong class="bold">secs</strong>.count());</p>
			<p class="source-code">cout &lt;&lt; format("time elapsed: {:.3f} ms\n", </p>
			<p class="source-code">    <strong class="bold">milliseconds</strong>(secs).count());</p>
			<p class="source-code">cout &lt;&lt; format("time elapsed: {:.3e} μs\n", </p>
			<p class="source-code">    <strong class="bold">microseconds</strong>(secs).count());</p>
			<p class="source-code">cout &lt;&lt; format("time elapsed: {} frames at 24 fps\n", </p>
			<p class="source-code">    <strong class="bold">floor</strong>&lt;<strong class="bold">fps24</strong>&gt;(secs).count());</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">time elapsed: 3.573 sec</strong></p>
			<p class="source-code"><strong class="bold">time elapsed: 3573.077 ms</strong></p>
			<p class="source-code"><strong class="bold">time elapsed: 3.573e+06 μs</strong></p>
			<p class="source-code"><strong class="bold">time elapsed: 85 frames at 24 fps</strong></p>
			<p>Because the <strong class="source-inline">fps24</strong> alias uses <strong class="source-inline">unsigned long</strong> instead of <strong class="source-inline">double</strong>, a type conversion is required. The <strong class="source-inline">floor</strong> function provides this by discarding the fractional part. <strong class="source-inline">round()</strong> and <strong class="source-inline">ceil()</strong> are also available in this context.</p>
			<ul>
				<li>For <a id="_idIndexMarker705"/>convenience, the <strong class="source-inline">chrono</strong> library provides <strong class="source-inline">format()</strong> specializations <a id="_idIndexMarker706"/>for the standard <strong class="source-inline">duration</strong> ratios:<p class="source-code">cout &lt;&lt; format("time elapsed: {:.3}\n", secs);</p><p class="source-code">cout &lt;&lt; format("time elapsed: {:.3}\n", milliseconds(secs));</p><p class="source-code">cout &lt;&lt; format("time elapsed: {:.3}\n", microseconds(secs));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">time elapsed: 3.573s</strong></p>
			<p class="source-code"><strong class="bold">time elapsed: 3573.077ms</strong></p>
			<p class="source-code"><strong class="bold">time elapsed: 3573076.564μs</strong></p>
			<p>These results will vary on different implementations.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor265"/>How it works…</h2>
			<p>There are two<a id="_idIndexMarker707"/> major<a id="_idIndexMarker708"/> pieces to the <strong class="source-inline">chrono</strong> library, the <em class="italic">clock</em> classes and the <strong class="source-inline">duration</strong> class. </p>
			<h3>The clock classes</h3>
			<p>The clock <a id="_idIndexMarker709"/>classes include:</p>
			<ul>
				<li><strong class="source-inline">system_clock</strong> – provides wall clock time.</li>
				<li><strong class="source-inline">steady_clock</strong> – provides guaranteed monotonic ticks for duration measurements.</li>
				<li><strong class="source-inline">high_resolution_clock</strong> – provides the shortest available tick period. It may be an alias of <strong class="source-inline">system_clock</strong> or <strong class="source-inline">steady_clock</strong> on some systems.</li>
			</ul>
			<p>We use <strong class="source-inline">system_clock</strong> to display the current time and date. We use <strong class="source-inline">steady_clock</strong> to measure intervals. </p>
			<p>Each of the clock classes has a <strong class="source-inline">now()</strong> method that returns <strong class="source-inline">time_point</strong>, representing the current value of the clock. <strong class="source-inline">now()</strong> is a static member function, so it's called on the class without instantiating an object:</p>
			<p class="source-code">auto t1{ steady_clock::now() };</p>
			<h3>The std::duration class</h3>
			<p>The <strong class="source-inline">duration</strong> class is<a id="_idIndexMarker710"/> used to hold a time interval – that is, the difference between two <strong class="source-inline">time_point</strong> objects. It is generally constructed with a <strong class="source-inline">time_point</strong> object's subtraction (<strong class="source-inline">-</strong>) operator. </p>
			<p class="source-code">duration&lt;double&gt; secs{ t2 - t1 };</p>
			<p>The <strong class="source-inline">time_point</strong> subtraction operator doubles as a constructor for <strong class="source-inline">duration</strong>:</p>
			<p class="source-code">template&lt;class C, class D1, class D2&gt;</p>
			<p class="source-code">constexpr duration&lt;D1,D2&gt;</p>
			<p class="source-code">operator-( const time_point&lt;C,D1&gt;&amp; pt_lhs,</p>
			<p class="source-code">    const time_point&lt;C,D2&gt;&amp; pt_rhs );</p>
			<p>The <strong class="source-inline">duration</strong> class has template parameters for type representation and a <strong class="source-inline">ratio</strong> object:</p>
			<p class="source-code">template&lt;class <strong class="bold">Rep</strong>, class <strong class="bold">Period</strong> = std::<strong class="bold">ratio</strong>&lt;1&gt;&gt;</p>
			<p class="source-code">class duration;</p>
			<p>The <strong class="source-inline">Period</strong> template parameter defaults to a <strong class="source-inline">ratio</strong> of 1:1, which is seconds.</p>
			<p>The library provides <strong class="source-inline">ratio</strong> aliases (such as <strong class="source-inline">micro</strong> and <strong class="source-inline">milli</strong>) for powers-of-10 from <strong class="source-inline">atto</strong> (1/1,000,000,000,000,000,000) through <strong class="source-inline">exa</strong> (1,000,000,000,000,000,000/1). This allows us to create standard durations, as we did in our example:</p>
			<p class="source-code">using milliseconds = duration&lt;double, std::<strong class="bold">milli</strong>&gt;;</p>
			<p class="source-code">using microseconds = duration&lt;double, std::<strong class="bold">micro</strong>&gt;;</p>
			<p>The <strong class="source-inline">count()</strong> method gives us the duration in the <strong class="source-inline">Rep</strong> type:</p>
			<p class="source-code">constexpr Rep count() const;</p>
			<p>This allows us to <a id="_idIndexMarker711"/>easily access the duration for display or other purposes:</p>
			<p class="source-code">cout &lt;&lt; format("duration: {}\n", secs.count());</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor266"/>Use fold expressions for variadic tuples</h1>
			<p>The <strong class="source-inline">std::tuple</strong> class <a id="_idIndexMarker712"/>is essentially a more <a id="_idIndexMarker713"/>complex, and<a id="_idIndexMarker714"/> less convenient, <strong class="source-inline">struct</strong>. The interface for <strong class="source-inline">tuple</strong> is cumbersome, although <em class="italic">class template argument deduction</em> and <em class="italic">structured binding</em> have made it somewhat easier. </p>
			<p>I tend to use <strong class="source-inline">struct</strong> before <strong class="source-inline">tuple</strong> for most applications, with one significant exception: the one real advantage of <strong class="source-inline">tuple</strong> is that it can be used with <em class="italic">fold expressions</em> in a variadic context.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor267"/>Fold expressions</h2>
			<p>Designed to <a id="_idIndexMarker715"/>make it easier to expand a variadic parameter pack, <em class="italic">fold expressions</em> are a new feature with C++17. Prior to fold expressions, expanding a parameter pack required a recursive function:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">void f(T final) {</p>
			<p class="source-code">    cout &lt;&lt; final &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p class="source-code">template&lt;typename T, typename... Args&gt;</p>
			<p class="source-code">void f(T first, Args... args) {</p>
			<p class="source-code">    cout &lt;&lt; first;</p>
			<p class="source-code">    <strong class="bold">f(args...)</strong>;</p>
			<p class="source-code">}</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    f("hello", ' ', 47, ' ', "world");</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">hello 47 world</p>
			<p>Using a<a id="_idIndexMarker716"/> fold<a id="_idIndexMarker717"/> expression, this is much simpler:</p>
			<p class="source-code">template&lt;typename... Args&gt;</p>
			<p class="source-code">void f(Args... args) {</p>
			<p class="source-code">    <strong class="bold">(cout &lt;&lt; ... &lt;&lt; args)</strong>;</p>
			<p class="source-code">    cout &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">hello 47 world</p>
			<p>There are four types of fold expressions:</p>
			<ul>
				<li>Unary right fold: <strong class="source-inline">(args op ...)</strong></li>
				<li>Unary left fold: <strong class="source-inline">(... op args)</strong></li>
				<li>Binary right fold: <strong class="source-inline">(args op ... op init)</strong></li>
				<li>Binary left fold: <strong class="source-inline">(init op ... op args)</strong></li>
			</ul>
			<p>The expression in the example above is a <em class="italic">binary left fold</em>:</p>
			<p class="source-code">(cout &lt;&lt; ... &lt;&lt; args);</p>
			<p>This expands to:</p>
			<p class="source-code">cout &lt;&lt; "hello" &lt;&lt; ' ' &lt;&lt; 47 &lt;&lt; ' ' &lt;&lt; "world";</p>
			<p>Fold expressions<a id="_idIndexMarker718"/> are a great convenience for many purposes. Let's look at how we can use them with tuples.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor268"/>How to do it…</h2>
			<p>In this recipe, we'll create a template function that operates on a tuple with varying numbers and types of elements:</p>
			<ul>
				<li>The<a id="_idIndexMarker719"/> heart <a id="_idIndexMarker720"/>of this recipe is a function that takes a tuple of unknown size and type and prints each element with <strong class="source-inline">format()</strong>:<p class="source-code">template&lt;typename... T&gt;</p><p class="source-code">constexpr void print_t(const tuple&lt;T...&gt;&amp; <strong class="bold">tup</strong>) {</p><p class="source-code">    auto lpt =</p><p class="source-code">        [<strong class="bold">&amp;tup</strong>] <strong class="bold">&lt;size_t... I&gt;</strong> </p><p class="source-code">          (std::<strong class="bold">index_sequence</strong>&lt;I...&gt;)</p><p class="source-code">            constexpr {</p><p class="source-code">            (..., ( cout &lt;&lt;</p><p class="source-code">                format((I? ", {}" : "{}"), </p><p class="source-code">                  <strong class="bold">get&lt;I&gt;(tup)</strong>)</p><p class="source-code">            ));</p><p class="source-code">            cout &lt;&lt; '\n';</p><p class="source-code">        };</p><p class="source-code">    lpt(std::<strong class="bold">make_index_sequence</strong>&lt;sizeof...(T)&gt;());</p><p class="source-code">}</p></li>
			</ul>
			<p>The heart of this function is in the lambda expression. It uses the <strong class="source-inline">index_sequence</strong> object to generate a parameter pack of index values. We then use a fold expression to call <strong class="source-inline">get&lt;I&gt;</strong> with each index value. The templated lambda requires C++20.  </p>
			<p>You could use a separate function in place of the lambda, but I like keeping it in a single scope.</p>
			<ul>
				<li>We <a id="_idIndexMarker721"/>can<a id="_idIndexMarker722"/> now call this from <strong class="source-inline">main()</strong> with a variety of tuples:<p class="source-code">int main() {</p><p class="source-code">    tuple lables{ "ID", "Name", "Scale" };</p><p class="source-code">    tuple employee{ 123456, "John Doe", 3.7 };</p><p class="source-code">    tuple nums{ 1, 7, "forty-two", 47, 73L, -111.11 };</p><p class="source-code">    </p><p class="source-code">    print_t(lables);</p><p class="source-code">    print_t(employee);</p><p class="source-code">    print_t(nums);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">ID, Name, Scale</strong></p>
			<p class="source-code"><strong class="bold">123456, John Doe, 3.7</strong></p>
			<p class="source-code"><strong class="bold">1, 7, forty-two, 47, 73, -111.11</strong></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor269"/>How it works…</h2>
			<p>The challenge with <strong class="source-inline">tuple</strong> is its restrictive interface. You can retrieve elements with <strong class="source-inline">std::tie()</strong>, with <em class="italic">structured bindings</em>, or the <strong class="source-inline">std::get&lt;&gt;</strong> function. None of these techniques are useful if you don't know the number and type of elements in the <strong class="source-inline">tuple</strong>. </p>
			<p>We get around this limitation by using the <strong class="source-inline">index_sequence</strong> class. <strong class="source-inline">index_sequence</strong> is a specialization of <strong class="source-inline">integer_sequence</strong> that provides a parameter pack of the <strong class="source-inline">size_t</strong> elements, which we can use to index our <strong class="source-inline">tuple</strong>. We call our lambda function with <strong class="source-inline">make_index_sequence</strong> to set up a parameter pack in the lambda:</p>
			<p class="source-code">lpt(std::make_index_sequence&lt;sizeof...(T)&gt;());</p>
			<p>The templated lambda is constructed with a parameter pack of <strong class="source-inline">size_t</strong> indexes for the <strong class="source-inline">get()</strong> function: </p>
			<p class="source-code">[&amp;tup] &lt;size_t... I&gt; (std::index_sequence&lt;I...&gt;) constexpr {</p>
			<p class="source-code">   ...</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">get()</strong> function <a id="_idIndexMarker723"/>takes the index value as a template <a id="_idIndexMarker724"/>parameter. We use a <em class="italic">unary left fold expression</em> to call <strong class="source-inline">get&lt;I&gt;()</strong>:</p>
			<p class="source-code">(...<strong class="bold">,</strong> ( cout &lt;&lt; format("{} ", std::get&lt;<strong class="bold">I</strong>&gt;(tup))));</p>
			<p>The fold expression takes each element of the function's parameter pack and applies the comma operator. The right-hand side of the comma has a <strong class="source-inline">format()</strong> function that prints each element of the tuple. </p>
			<p>This makes it possible to deduce the number of elements in the tuple, which makes it useable in a variadic context. Keep in mind that, as with template functions in general, the compiler will generate a separate specialization of this function for each combination of <strong class="source-inline">tuple</strong> parameters.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor270"/>There's more…</h2>
			<p>We can use this technique for other tasks. For example, here's a function that returns the sum of all the <strong class="source-inline">int</strong> values in a <strong class="source-inline">tuple</strong> of unknown size:</p>
			<p class="source-code">template&lt;typename... T&gt;</p>
			<p class="source-code">constexpr int sum_t(const tuple&lt;T...&gt;&amp; tup) {</p>
			<p class="source-code">    int accum{};</p>
			<p class="source-code">    auto lpt =</p>
			<p class="source-code">        [&amp;tup, &amp;accum] &lt;size_t... I&gt; </p>
			<p class="source-code">          (std::index_sequence&lt;I...&gt;) </p>
			<p class="source-code">        constexpr {</p>
			<p class="source-code">            (..., ( </p>
			<p class="source-code">                accum += get&lt;I&gt;(tup)</p>
			<p class="source-code">            ));</p>
			<p class="source-code">        };</p>
			<p class="source-code">    lpt(std::make_index_sequence&lt;sizeof...(T)&gt;());</p>
			<p class="source-code">    return accum;</p>
			<p class="source-code">}</p>
			<p>We can call this with several <strong class="source-inline">tuple</strong> objects of varying numbers of <strong class="source-inline">int</strong> values:</p>
			<p class="source-code">tuple ti1{ 1, 2, 3, 4, 5 };</p>
			<p class="source-code">tuple ti2{ 9, 10, 11, 12, 13, 14, 15 };</p>
			<p class="source-code">tuple ti3{ 47, 73, 42 };</p>
			<p class="source-code">auto sum1{ sum_t(ti1) };</p>
			<p class="source-code">auto sum2{ sum_t(ti2) };</p>
			<p class="source-code">auto sum3{ sum_t(ti3) };</p>
			<p class="source-code">cout &lt;&lt; format("sum of ti1: {}\n", sum1);</p>
			<p class="source-code">cout &lt;&lt; format("sum of ti2: {}\n", sum2);</p>
			<p class="source-code">cout &lt;&lt; format("sum of ti3: {}\n", sum3);</p>
			<p>Output:</p>
			<p class="source-code">sum of ti1: 15</p>
			<p class="source-code">sum of ti2: 84</p>
			<p class="source-code">sum of ti3: 162</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor271"/>Manage allocated memory with std::unique_ptr</h1>
			<p><em class="italic">Smart pointers</em> are an <a id="_idIndexMarker725"/>excellent tool<a id="_idIndexMarker726"/> for managing allocated <em class="italic">heap memory</em>. </p>
			<p>Heap memory is managed at the lowest level by the C functions, <strong class="source-inline">malloc()</strong> and <strong class="source-inline">free()</strong>. <strong class="source-inline">malloc()</strong> allocates a block of memory from the heap, and <strong class="source-inline">free()</strong> returns it to the heap. These functions do not perform initialization and do not call constructors or destructors. If you fail to return allocated memory to the heap with a call to <strong class="source-inline">free()</strong>, the behavior is undefined and often leads to memory leaks and security vulnerabilities.</p>
			<p>C++ provides the <strong class="source-inline">new</strong> and <strong class="source-inline">delete</strong> operators to allocate and free heap memory, in place of <strong class="source-inline">malloc()</strong> and <strong class="source-inline">free()</strong>. The <strong class="source-inline">new</strong> and <strong class="source-inline">delete</strong> operators call object constructors and destructors but still do not manage memory. If you allocate memory with <strong class="source-inline">new</strong> and fail to free it with <strong class="source-inline">delete</strong>, you will leak memory.</p>
			<p>Introduced <a id="_idIndexMarker727"/>with C++14, smart pointers comply with the <strong class="bold">Resource Acquisition Is Initialization</strong> (<strong class="bold">RAII</strong>) idiom. This means that when memory is allocated for an object, that object's constructor is called. And when the object's destructor is called, the memory is automatically returned to the heap. </p>
			<p>For example, when we create a new smart pointer with <strong class="source-inline">make_unique()</strong>:</p>
			<p class="source-code">{   // beginning of scope</p>
			<p class="source-code">    auto p = <strong class="bold">make_unique&lt;Thing&gt;()</strong>; // memory alloc’d,</p>
			<p class="source-code">                                   // ctor called</p>
			<p class="source-code">    process_thing(p);   // p is unique_ptr&lt;Thing&gt;</p>
			<p class="source-code">}   // end of scope, dtor called, memory freed</p>
			<p><strong class="source-inline">make_unique()</strong> allocates memory for a <strong class="source-inline">Thing</strong> object, calls the <strong class="source-inline">Thing</strong> default constructor, constructs a <strong class="source-inline">unique_ptr&lt;Thing&gt;</strong> object, and returns the <strong class="source-inline">unique_ptr</strong>. When <strong class="source-inline">p</strong> goes out of scope, the <strong class="source-inline">Thing</strong> destructor is called, and the memory is automatically returned to the heap.</p>
			<p>Aside from the memory management, a smart pointer works very much like a primitive pointer:</p>
			<p class="source-code">auto x = *p;  // *p derefs the pointer, returns Thing object</p>
			<p class="source-code">auto y = p-&gt;thname; // p-&gt; derefs the pointer, returns member</p>
			<p><strong class="source-inline">unique_ptr</strong> is a <a id="_idIndexMarker728"/>smart pointer that allows <a id="_idIndexMarker729"/>only one instance of the pointer. It may be moved, but it may not be copied. Let's take a closer look at how to use <strong class="source-inline">unique_ptr</strong>.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor272"/>How to do it…</h2>
			<p>In this recipe, we examine <strong class="source-inline">std::unique_ptr</strong> with a demonstration class that prints when its constructors and destructor are called:</p>
			<ul>
				<li>First, we'll create a simple demonstration class:<p class="source-code">struct Thing {</p><p class="source-code">    string_view thname{ "unk" };</p><p class="source-code">    Thing() {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("default ctor: {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">    Thing(const string_view&amp; n) : thname(n) {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("param ctor: {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">    ~Thing() {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("dtor: {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>This class has a default constructor, a parameterized constructor, and a destructor. Each of these has a simple print statement to tell us what was called.</p>
			<ul>
				<li>When <a id="_idIndexMarker730"/>we <a id="_idIndexMarker731"/>just construct a <strong class="source-inline">unique_ptr</strong>, it does not allocate memory or construct a managed object:<p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">unique_ptr&lt;Thing&gt;</strong> p1;</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<ul>
				<li>When we use the <strong class="source-inline">new</strong> operator, it allocates memory and constructs a <strong class="source-inline">Thing</strong> object:<p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">unique_ptr&lt;Thing&gt;</strong> p1{ <strong class="bold">new</strong> Thing };</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">default ctor: unk</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p class="source-code"><strong class="bold">dtor: unk</strong></p>
			<p>The <strong class="source-inline">new</strong> operator constructs a <strong class="source-inline">Thing</strong> object by calling the default constructor. The <strong class="source-inline">unique_ptr&lt;Thing&gt;</strong> destructor calls the <strong class="source-inline">Thing</strong> destructor when the smart pointer reaches the end of its scope.</p>
			<p>The <strong class="source-inline">Thing</strong> default constructor does not initialize the <strong class="source-inline">thname</strong> string, leaving its default value, <strong class="source-inline">"unk"</strong>. </p>
			<ul>
				<li>We<a id="_idIndexMarker732"/> can<a id="_idIndexMarker733"/> use <strong class="source-inline">make_unique()</strong> to get the same result:<p class="source-code">int main() {</p><p class="source-code">    auto p1 = <strong class="bold">make_unique&lt;Thing&gt;</strong>();</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">default ctor: unk</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p class="source-code"><strong class="bold">dtor: unk</strong></p>
			<p>The <strong class="source-inline">make_unique()</strong> helper function takes care of the memory allocation and returns a <strong class="source-inline">unique_ptr</strong> object. This is the recommended way to construct a <strong class="source-inline">unique_ptr</strong>. </p>
			<ul>
				<li>Any arguments you pass to <strong class="source-inline">make_unique()</strong> are used in constructing the target object:<p class="source-code">int main() {</p><p class="source-code">    auto p1 = make_unique&lt;Thing&gt;(<strong class="bold">"Thing 1"</strong>) };</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">param ctor: Thing 1</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p class="source-code"><strong class="bold">dtor: Thing 1</strong></p>
			<p>The parameterized constructor assigns a value to <strong class="source-inline">thname</strong>, so our <strong class="source-inline">Thing</strong> object is now <strong class="source-inline">"Thing 1"</strong>.</p>
			<ul>
				<li>Let's write a function that takes a <strong class="source-inline">unique_ptr&lt;Thing&gt;</strong> argument:<p class="source-code">void process_thing(<strong class="bold">unique_ptr&lt;Thing&gt;</strong> p) {</p><p class="source-code">    if(p) cout &lt;&lt; format("processing: {}\n", </p><p class="source-code">      p-&gt;thname);</p><p class="source-code">    else cout &lt;&lt; "invalid pointer\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>If we<a id="_idIndexMarker734"/> try <a id="_idIndexMarker735"/>to pass a <strong class="source-inline">unique_ptr</strong> to this function, we get a compiler error:</p>
			<p class="source-code">process_thing(p1);</p>
			<p>Compiler error:</p>
			<p class="source-code"><strong class="bold">error: use of deleted function...</strong></p>
			<p>This is because the function call tries to make a copy of the <strong class="source-inline">unique_ptr</strong> object, but the <strong class="source-inline">unique_ptr</strong> copy constructor is <em class="italic">deleted</em> to prevent copying. The solution is to have the function take a <strong class="source-inline">const&amp;</strong> reference:</p>
			<p class="source-code">void process_thing(<strong class="bold">const unique_ptr&lt;Thing&gt;&amp;</strong> p) {</p>
			<p class="source-code">    if(p) cout &lt;&lt; format("processing: {}\n", </p>
			<p class="source-code">      p-&gt;thname);</p>
			<p class="source-code">    else cout &lt;&lt; "invalid pointer\n";</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">param ctor: Thing 1</strong></p>
			<p class="source-code"><strong class="bold">processing: Thing 1</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p class="source-code"><strong class="bold">dtor: Thing 1</strong></p>
			<ul>
				<li>We can call <strong class="source-inline">process_thing()</strong> with a temporary object, which is immediately <a id="_idIndexMarker736"/>destroyed at the end<a id="_idIndexMarker737"/> of the function scope:<p class="source-code">int main() {</p><p class="source-code">    auto p1{ make_unique&lt;Thing&gt;("Thing 1") };</p><p class="source-code">    process_thing(p1);</p><p class="source-code">    <strong class="bold">process_thing(make_unique&lt;Thing&gt;("Thing 2"));</strong></p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code">param ctor: Thing 1</p>
			<p class="source-code">processing: Thing 1</p>
			<p class="source-code"><strong class="bold">param ctor: Thing 2</strong></p>
			<p class="source-code"><strong class="bold">processing: Thing 2</strong></p>
			<p class="source-code"><strong class="bold">dtor: Thing 2</strong></p>
			<p class="source-code">end of main()</p>
			<p class="source-code">dtor: Thing 1</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor273"/>How it works…</h2>
			<p>A <em class="italic">smart pointer</em> is simply an object that presents a pointer interface while owning and managing the resources of another object.</p>
			<p>The <strong class="source-inline">unique_ptr</strong> class is distinguished by its deleted copy constructor and copy assignment operator, which prevents the smart pointer from being copied.</p>
			<p>You may not copy a <strong class="source-inline">unique_ptr</strong>:</p>
			<p class="source-code">auto p2 = p1;</p>
			<p>Compiler error:</p>
			<p class="source-code">error: use of deleted function...</p>
			<p>But <a id="_idIndexMarker738"/>you<a id="_idIndexMarker739"/> can move a <strong class="source-inline">unique_ptr</strong>:</p>
			<p class="source-code">auto p2 = std::move(p1);</p>
			<p class="source-code">process_thing(p1);</p>
			<p class="source-code">process_thing(p2);</p>
			<p>After the <strong class="source-inline">move</strong>, <strong class="source-inline">p1</strong> is invalid and <strong class="source-inline">p2</strong> is <strong class="source-inline">"Thing 1"</strong>.</p>
			<p>Output:</p>
			<p class="source-code">invalid pointer</p>
			<p class="source-code">processing: Thing 1</p>
			<p class="source-code">end of main()</p>
			<p class="source-code">dtor: Thing 1</p>
			<p>The <strong class="source-inline">unique_ptr</strong> interface has a method to reset a pointer:</p>
			<p class="source-code">p1.reset();  // pointer is now invalid</p>
			<p class="source-code">process_thing(p1);</p>
			<p>Output:</p>
			<p class="source-code">dtor: Thing 1</p>
			<p class="source-code">invalid pointer</p>
			<p>The <strong class="source-inline">reset()</strong> method may also be used to replace the managed object with another of the<a id="_idIndexMarker740"/> same<a id="_idIndexMarker741"/> type:</p>
			<p class="source-code">p1.reset(new Thing("Thing 3"));</p>
			<p class="source-code">process_thing(p1);</p>
			<p>Output:</p>
			<p class="source-code">param ctor: Thing 3</p>
			<p class="source-code">dtor: Thing 1</p>
			<p class="source-code">processing: Thing 3</p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor274"/>Share objects with std::shared_ptr</h1>
			<p>The <strong class="source-inline">std::shared_ptr</strong> class is <a id="_idIndexMarker742"/>a smart pointer<a id="_idIndexMarker743"/> that owns its managed object and maintains a <em class="italic">use counter</em> to keep track of copies. This recipe explores the use of <strong class="source-inline">shared_ptr</strong> to manage memory while sharing copies of the pointer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more detail about smart pointers, see the introduction to the <em class="italic">Manage allocated memory with std::unique_ptr</em> recipe earlier in this chapter.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor275"/>How to do it…</h2>
			<p>In this recipe, we examine <strong class="source-inline">std::shared_ptr</strong> with a demonstration class that prints when its constructors and destructor are called:</p>
			<ul>
				<li>First, we create a simple demonstration class:<p class="source-code">struct Thing {</p><p class="source-code">    string_view thname{ "unk" };</p><p class="source-code">    Thing() {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("default ctor: {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">    Thing(const string_view&amp; n) : thname(n) {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("param ctor: {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">    ~Thing() {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("dtor: {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>This class has a default constructor, a parameterized constructor, and a destructor. Each<a id="_idIndexMarker744"/> of these has a simple print <a id="_idIndexMarker745"/>statement to tell us what was called.</p>
			<ul>
				<li>The <strong class="source-inline">shared_ptr</strong> class works very much like other smart pointers, in that it may be constructed with the <strong class="source-inline">new</strong> operator or with its helper, the <strong class="source-inline">make_shared()</strong> function:<p class="source-code">int main() {</p><p class="source-code">    shared_ptr&lt;Thing&gt; p1{ new Thing("Thing 1") };</p><p class="source-code">    auto p2 = make_shared&lt;Thing&gt;("Thing 2");</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">param ctor: Thing 1</strong></p>
			<p class="source-code"><strong class="bold">param ctor: Thing 2</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p class="source-code"><strong class="bold">dtor: Thing 2</strong></p>
			<p class="source-code"><strong class="bold">dtor: Thing 1</strong></p>
			<p>The <strong class="source-inline">make_shared()</strong> function is recommended, as it manages the construction process and is less prone to error.</p>
			<p>As with the other smart pointers, the managed object is destroyed, and its memory is returned to the heap when the pointer goes out of scope.</p>
			<ul>
				<li>Here's a function to check the use count of a <strong class="source-inline">shared_ptr</strong> object:<p class="source-code">void check_thing_ptr(const shared_ptr&lt;Thing&gt;&amp; p) {</p><p class="source-code">    if(p) cout &lt;&lt; format("{} use count: {}\n", </p><p class="source-code">        <strong class="bold">p-&gt;thname</strong>, <strong class="bold">p.use_count()</strong>);</p><p class="source-code">    else cout &lt;&lt; "invalid pointer\n";</p><p class="source-code">}</p></li>
			</ul>
			<p><strong class="source-inline">thname</strong> is a member <a id="_idIndexMarker746"/>of the <strong class="source-inline">Thing</strong> class, so we<a id="_idIndexMarker747"/> access it through the pointer with the <strong class="source-inline">p-&gt;</strong> member dereference operator. The <strong class="source-inline">use_count()</strong> function is a member of the <strong class="source-inline">shared_ptr</strong> class, so we access it with the <strong class="source-inline">p.</strong> object member operator. </p>
			<p>Let's call this with our pointers:</p>
			<p class="source-code">check_thing_ptr(p1);</p>
			<p class="source-code">check_thing_ptr(p2);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 1</strong></p>
			<p class="source-code"><strong class="bold">Thing 2 use count: 1</strong></p>
			<ul>
				<li>When we make copies of our pointers, the use count increases, but no new objects are constructed:<p class="source-code">cout &lt;&lt; "make 4 copies of p1:\n";</p><p class="source-code">auto pa = p1;</p><p class="source-code">auto pb = p1;</p><p class="source-code">auto pc = p1;</p><p class="source-code">auto pd = p1;</p><p class="source-code">check_thing_ptr(p1);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">make 4 copies of p1:</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 5</strong></p>
			<ul>
				<li>When <a id="_idIndexMarker748"/>we <a id="_idIndexMarker749"/>check any of the other copies, we get the same result:<p class="source-code">check_thing_ptr(pa);</p><p class="source-code">check_thing_ptr(pb);</p><p class="source-code">check_thing_ptr(pc);</p><p class="source-code">check_thing_ptr(pd);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 5</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 5</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 5</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 5</strong></p>
			<p>Each pointer reports the same use count. </p>
			<ul>
				<li>When the copies go out of scope, they are destroyed, and the use count is decremented:<p class="source-code">{   // new scope</p><p class="source-code">    cout &lt;&lt; "make 4 copies of p1:\n";</p><p class="source-code">    auto pa = p1;</p><p class="source-code">    auto pb = p1;</p><p class="source-code">    auto pc = p1;</p><p class="source-code">    auto pd = p1;</p><p class="source-code">    check_thing_ptr(p1);</p><p class="source-code">}   // end of scope</p><p class="source-code">check_thing_ptr(p1);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">make 4 copies of p1:</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 5</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 1</strong></p>
			<ul>
				<li>Destroying<a id="_idIndexMarker750"/> a<a id="_idIndexMarker751"/> copy reduces the use count but does not destroy the managed object. The object is destroyed when the final copy goes out of scope and the use count reaches zero:<p class="source-code">{    </p><p class="source-code">    cout &lt;&lt; "make 4 copies of p1:\n";</p><p class="source-code">    auto pa = p1;</p><p class="source-code">    auto pb = p1;</p><p class="source-code">    auto pc = p1;</p><p class="source-code">    auto pd = p1;</p><p class="source-code">    check_thing_ptr(p1);</p><p class="source-code">    pb.reset();</p><p class="source-code">    p1.reset();</p><p class="source-code">    check_thing_ptr(pd);</p><p class="source-code">}   // end of scope</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">make 4 copies of p1:</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 5</strong></p>
			<p class="source-code"><strong class="bold">Thing 1 use count: 3</strong></p>
			<p class="source-code"><strong class="bold">dtor: Thing 1</strong></p>
			<p>Destroying <strong class="source-inline">pb</strong> (a copy) and <strong class="source-inline">p1</strong> (the original) leaves three copies of the pointer (<strong class="source-inline">pa</strong>, <strong class="source-inline">bc</strong>, and <strong class="source-inline">pd</strong>), so the managed object remains.</p>
			<p>The remaining three pointer copies are destroyed at the end of the scope in which they were created. Then the object is destroyed and its memory returned to the heap.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor276"/>How it works…</h2>
			<p>The <strong class="source-inline">shared_ptr</strong> class is distinguished by its management of multiple pointers to the same managed object. </p>
			<p>The <strong class="source-inline">shared_ptr</strong> object's copy constructor and copy assignment operator increment a <em class="italic">use counter</em>. The destructor decrements the use counter until it reaches zero, then destroys the managed object, and returns its memory to the heap.</p>
			<p>The <strong class="source-inline">shared_ptr</strong> class manages both the managed object and a heap-allocated <em class="italic">control block</em>. The <a id="_idIndexMarker752"/>control block contains the use<a id="_idIndexMarker753"/> counter, along with other housekeeping objects. The control block is managed and shared between copies along with the managed object. This allows the original <strong class="source-inline">shared_ptr</strong> object to cede control to its copies, so that the last remaining <strong class="source-inline">shared_ptr</strong> may manage the object and its memory.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor277"/>Use weak pointers with shared objects</h1>
			<p>Strictly<a id="_idIndexMarker754"/> speaking, <strong class="source-inline">std::weak_ptr</strong> is not a smart<a id="_idIndexMarker755"/> pointer. Rather, it's an <em class="italic">observer</em> that operates in cooperation with <strong class="source-inline">shared_ptr</strong>. A <strong class="source-inline">weak_ptr</strong> object does not hold a pointer on its own.</p>
			<p>There are circumstances where <strong class="source-inline">shared_ptr</strong> objects may create dangling pointers or race conditions, which could lead to memory leaks or other problems. The solution is to use <strong class="source-inline">weak_ptr</strong> objects with <strong class="source-inline">shared_ptr</strong>. </p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor278"/>How to do it…</h2>
			<p>In this recipe, we examine the use of <strong class="source-inline">std::weak_ptr</strong> with <strong class="source-inline">std::shared_ptr</strong>, using a demonstration class that prints when its constructors and destructor are called.</p>
			<ul>
				<li>We start <a id="_idIndexMarker756"/>with <a id="_idIndexMarker757"/>the same class we've used to demonstrate <strong class="source-inline">shared_ptr</strong> and <strong class="source-inline">unique_ptr</strong>:<p class="source-code">struct Thing {</p><p class="source-code">    string_view thname{ "unk" };</p><p class="source-code">    Thing() {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">default ctor:</strong> {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">    Thing(const string_view&amp; n) : thname(n) {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">param ctor:</strong> {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">    ~Thing() {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">dtor:</strong> {}\n", thname);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>This class has a default constructor, a parameterized constructor, and a destructor. Each of these has a simple print statement to tell us what was called.</p>
			<ul>
				<li>We also need a function to examine a <strong class="source-inline">weak_ptr</strong> object:<p class="source-code">void <strong class="bold">get_weak_thing</strong>(const <strong class="bold">weak_ptr&lt;Thing&gt;&amp;</strong> p) {</p><p class="source-code">    if(<strong class="bold">auto</strong> sp = <strong class="bold">p.lock()</strong>) cout &lt;&lt; </p><p class="source-code">        format("{}: count {}\n", sp-&gt;thname, </p><p class="source-code">          p.use_count());</p><p class="source-code">    else cout &lt;&lt; "no shared object\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>A <strong class="source-inline">weak_ptr</strong> does not operate as a pointer on its own; it requires the use of a <strong class="source-inline">shared_ptr</strong>. The <strong class="source-inline">lock()</strong> function returns a <strong class="source-inline">shared_ptr</strong> object, which can then be used to access the managed object.</p>
			<ul>
				<li>Because <strong class="source-inline">weak_ptr</strong> requires an associated <strong class="source-inline">shared_ptr</strong>, we'll start <strong class="source-inline">main()</strong> by<a id="_idIndexMarker758"/> creating a <strong class="source-inline">shared_ptr&lt;Thing&gt;</strong> object. When<a id="_idIndexMarker759"/> we create a <strong class="source-inline">weak_ptr</strong> object without assigning the <strong class="source-inline">shared_ptr</strong>, the <strong class="source-inline">expired</strong> flag is initially set:<p class="source-code">int main() {</p><p class="source-code">    auto <strong class="bold">thing1</strong> = <strong class="bold">make_shared&lt;Thing&gt;</strong>("Thing 1");</p><p class="source-code">    <strong class="bold">weak_ptr&lt;Thing&gt;</strong> wp1;</p><p class="source-code">    cout &lt;&lt; format("expired: {}\n", <strong class="bold">wp1.expired()</strong>);</p><p class="source-code">    get_weak_thing(wp1);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">param ctor: Thing 1</strong></p>
			<p class="source-code"><strong class="bold">expired: true</strong></p>
			<p class="source-code"><strong class="bold">no shared object</strong></p>
			<p>The <strong class="source-inline">make_shared()</strong> function allocates memory and constructs a <strong class="source-inline">Thing</strong> object.</p>
			<p>The <strong class="source-inline">weak_ptr&lt;Thing&gt;</strong> declaration constructs a <strong class="source-inline">weak_ptr</strong> object without assigning a <strong class="source-inline">shared_ptr</strong>. So, when we check the <strong class="source-inline">expired</strong> flag, it's <strong class="source-inline">true</strong>, indicating that there is no associated <strong class="source-inline">shared_ptr</strong>.</p>
			<p>The <strong class="source-inline">get_weak_thing()</strong> function is not able to obtain a lock because there is no <strong class="source-inline">shared_ptr</strong> available.</p>
			<ul>
				<li>When we<a id="_idIndexMarker760"/> assign the <strong class="source-inline">shared_ptr</strong> to the <strong class="source-inline">weak_ptr</strong>, we can use the <strong class="source-inline">weak_ptr</strong> to <a id="_idIndexMarker761"/>access the managed object:<p class="source-code">wp1 = thing1;</p><p class="source-code">get_weak_thing(wp1);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Thing 1: count 2</strong></p>
			<p>The <strong class="source-inline">get_weak_thing()</strong> function is now able to obtain a lock and access the managed object. The <strong class="source-inline">lock()</strong> method returns a <strong class="source-inline">shared_ptr</strong>, and the <strong class="source-inline">use_count()</strong> reflects the fact that there is now a second <strong class="source-inline">shared_ptr</strong> managing the <strong class="source-inline">Thing</strong> object.</p>
			<p>The new <strong class="source-inline">shared_ptr</strong> is destroyed at the end of the <strong class="source-inline">get_weak_thing()</strong> scope. </p>
			<ul>
				<li>The <strong class="source-inline">weak_ptr</strong> class has a constructor that takes a <strong class="source-inline">shared_ptr</strong> for one-step construction:<p class="source-code">weak_ptr&lt;Thing&gt; wp2(<strong class="bold">thing1</strong>);</p><p class="source-code">get_weak_thing(wp2);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Thing 1: count 2</strong></p>
			<p>The <strong class="source-inline">use_count()</strong> is <strong class="source-inline">2</strong> again. Remember that the previous <strong class="source-inline">shared_ptr</strong> was destroyed when its enclosing <strong class="source-inline">get_weak_thing()</strong> scope ended.</p>
			<ul>
				<li>When we reset <strong class="source-inline">shared_ptr</strong>, its associated <strong class="source-inline">weak_ptr</strong> objects are expired:<p class="source-code">thing1.<strong class="bold">reset</strong>();</p><p class="source-code">get_weak_thing(<strong class="bold">wp1</strong>);</p><p class="source-code">get_weak_thing(<strong class="bold">wp2</strong>);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code">dtor: Thing 1</p>
			<p class="source-code">no shared object</p>
			<p class="source-code">no shared object</p>
			<p>After the <strong class="source-inline">reset()</strong>, the use count reaches zero, and the managed object is destroyed and the memory released.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor279"/>How it works…</h2>
			<p>A <strong class="source-inline">weak_ptr</strong> object is an <em class="italic">observer</em> that holds a non-owning reference to a <strong class="source-inline">shared_ptr</strong> object. The <strong class="source-inline">weak_ptr</strong> observes the <strong class="source-inline">shared_ptr</strong> so that it knows when the<a id="_idIndexMarker762"/> managed<a id="_idIndexMarker763"/> object is, and is not, available. This allows use of a <strong class="source-inline">shared_ptr</strong> in circumstances where you may not always know if the managed object is active. </p>
			<p>The <strong class="source-inline">weak_ptr</strong> class has a <strong class="source-inline">use_count()</strong> function that returns the use count of <strong class="source-inline">shared_ptr</strong>, or <strong class="source-inline">0</strong> if the managed object has been deleted:</p>
			<p class="source-code">long use_count() const noexcept;</p>
			<p><strong class="source-inline">weak_ptr</strong> also has an <strong class="source-inline">expired()</strong> function that reports if the managed object has been deleted:</p>
			<p class="source-code">bool expired() const noexcept;</p>
			<p>The <strong class="source-inline">lock()</strong> function is the preferred way to access the shared pointer. It checks <strong class="source-inline">expired()</strong> to see if the managed object is available. If so, it returns a new <strong class="source-inline">shared_ptr</strong> that shares ownership with the managed object. Otherwise, it returns an empty <strong class="source-inline">shared_ptr</strong>. It does all that as one atomic operation:</p>
			<p class="source-code">std::shared_ptr&lt;T&gt; lock() const noexcept;</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor280"/>There's more…</h2>
			<p>One important <a id="_idIndexMarker764"/>use case for <strong class="source-inline">weak_ptr</strong> is when there's a possibility of circular references to <strong class="source-inline">shared_ptr</strong> objects. For example, consider the case of two classes that link to each other (perhaps in a hierarchy):</p>
			<p class="source-code">struct circB;</p>
			<p class="source-code">struct circA {</p>
			<p class="source-code">    <strong class="bold">shared_ptr&lt;circB&gt;</strong> p;</p>
			<p class="source-code">    ~circA() { <strong class="bold">cout &lt;&lt; "dtor A\n";</strong> }</p>
			<p class="source-code">};</p>
			<p class="source-code">struct circB {</p>
			<p class="source-code">    <strong class="bold">shared_ptr&lt;circA&gt;</strong> p;</p>
			<p class="source-code">    ~circB() { <strong class="bold">cout &lt;&lt; "dtor B\n";</strong> }</p>
			<p class="source-code">};</p>
			<p>We have print statements in the destructors, so we can see when the objects are destroyed. We can now create two objects that point at each other with <strong class="source-inline">shared_ptr</strong>:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    auto a{ <strong class="bold">make_shared&lt;circA&gt;</strong>() };</p>
			<p class="source-code">    auto b{ <strong class="bold">make_shared&lt;circB&gt;</strong>() };</p>
			<p class="source-code">    <strong class="bold">a-&gt;p = b</strong>;</p>
			<p class="source-code">    <strong class="bold">b-&gt;p = a</strong>;</p>
			<p class="source-code">    cout &lt;&lt; "end of main()\n";</p>
			<p class="source-code">}</p>
			<p>When we run this, notice that the destructors are never called:</p>
			<p class="source-code">end of main()</p>
			<p>Because the objects maintain shared pointers that refer to each other, the use counts never reach zero, and the managed objects are never destroyed. </p>
			<p>We can resolve this problem by changing one of the classes to use a <strong class="source-inline">weak_ptr</strong>:</p>
			<p class="source-code">struct circB {</p>
			<p class="source-code">    <strong class="bold">weak_ptr&lt;circA&gt;</strong> p;</p>
			<p class="source-code">    ~circB() { cout &lt;&lt; "dtor B\n"; }</p>
			<p class="source-code">};</p>
			<p>The code in <strong class="source-inline">main()</strong> remains the same, and we get this output:</p>
			<p class="source-code">end of main()</p>
			<p class="source-code">dtor A</p>
			<p class="source-code">dtor B</p>
			<p>By changing one <strong class="source-inline">shared_ptr</strong> to a <strong class="source-inline">weak_ptr</strong>, we have resolved the circular reference, and <a id="_idIndexMarker765"/>the objects are now properly destroyed at the end of their scope. </p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor281"/>Share members of a managed object</h1>
			<p>The <strong class="source-inline">std::shared_ptr</strong> class<a id="_idIndexMarker766"/> provides an <em class="italic">aliasing constructor</em> to <a id="_idIndexMarker767"/>share a pointer managed<a id="_idIndexMarker768"/> by another unrelated pointer:</p>
			<p class="source-code">shared_ptr( shared_ptr&lt;Y&gt;&amp;&amp; <strong class="bold">ref</strong>, element_type* <strong class="bold">ptr</strong> ) noexcept;</p>
			<p>This returns an aliased <strong class="source-inline">shared_ptr</strong> object that uses the resources of <strong class="source-inline">ref</strong> but returns a pointer to <strong class="source-inline">ptr</strong>. The <strong class="source-inline">use_count</strong> is shared with ref. The deleter is shared with <strong class="source-inline">ref</strong>. But <strong class="source-inline">get()</strong> returns <strong class="source-inline">ptr</strong>. This allows us to share a member of a managed object without sharing the entire object, and without allowing the entire object to be deleted while we're still using the member.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor282"/>How to do it…</h2>
			<p>In this recipe, we create a managed object and share members of that object:</p>
			<ul>
				<li>We start with a class for the managed object:<p class="source-code">struct animal {</p><p class="source-code">    <strong class="bold">string name{};</strong></p><p class="source-code">    <strong class="bold">string sound{};</strong></p><p class="source-code">    animal(const string&amp; n, const string&amp; a)</p><p class="source-code">            : <strong class="bold">name{n}</strong>, <strong class="bold">sound{a}</strong> {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">ctor:</strong> {}\n", name);</p><p class="source-code">    }</p><p class="source-code">    ~animal() {</p><p class="source-code">        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">dtor:</strong> {}\n", name);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>This class <a id="_idIndexMarker769"/>has<a id="_idIndexMarker770"/> two members, <strong class="source-inline">string</strong> types for <strong class="source-inline">name</strong> and <strong class="source-inline">sound</strong> of the <strong class="source-inline">animal</strong> object. We also have print statements for the constructor and the destructor. </p>
			<ul>
				<li>Now, we need a function to create an animal but only share its name and sound:<p class="source-code">auto make_animal(const string&amp; n, const string&amp; s) {</p><p class="source-code">    auto ap = make_shared&lt;animal&gt;(n, s);</p><p class="source-code">    auto np = shared_ptr&lt;string&gt;(ap, &amp;ap-&gt;name);</p><p class="source-code">    auto sp = shared_ptr&lt;string&gt;(ap, &amp;ap-&gt;sound);</p><p class="source-code">    return tuple(np, sp);</p><p class="source-code">}</p></li>
			</ul>
			<p>This function creates <strong class="source-inline">shared_ptr</strong> with an <strong class="source-inline">animal</strong> object, constructed with a name and a sound. We then create aliased <strong class="source-inline">shared_ptr</strong> objects for the name and sound. When we return the <strong class="source-inline">name</strong> and <strong class="source-inline">sound</strong> pointers, the <strong class="source-inline">animal</strong> pointer goes out of scope. It is not deleted because the aliased pointers keep the use count from reaching zero.</p>
			<ul>
				<li>In our <strong class="source-inline">main()</strong> function, we call <strong class="source-inline">make_animal()</strong> and inspect the results:<p class="source-code">int main() {</p><p class="source-code">    auto [name, sound] =</p><p class="source-code">        make_animal("Velociraptor", "Grrrr!");</p><p class="source-code">    cout &lt;&lt; format("The {} says {}\n", *name, *sound);</p><p class="source-code">    cout &lt;&lt; format("Use count: name {}, sound {}\n", </p><p class="source-code">        name.use_count(), sound.use_count()); </p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">ctor: Velociraptor</strong></p>
			<p class="source-code"><strong class="bold">The Velociraptor says Grrrr!</strong></p>
			<p class="source-code"><strong class="bold">Use count: name 2, sound 2</strong></p>
			<p class="source-code"><strong class="bold">dtor: Velociraptor</strong></p>
			<p>We can see<a id="_idIndexMarker771"/> that<a id="_idIndexMarker772"/> the aliased pointers each show a <strong class="source-inline">use_count</strong> of <strong class="source-inline">2</strong>. When the <strong class="source-inline">make_animal()</strong> function creates the aliased pointers, they each increase the use count of the <strong class="source-inline">animal</strong> pointer. When the function ends, the <strong class="source-inline">animal</strong> pointer goes out of scope, leaving its use count at 2, which is reflected in the aliased pointers. The aliased pointers go out of scope at the end of <strong class="source-inline">main()</strong>, which allows the <strong class="source-inline">animal</strong> pointer to be destroyed. </p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor283"/>How it works…</h2>
			<p>The <em class="italic">aliased</em> shared pointer seems a bit abstract, but it's simpler than it appears. </p>
			<p>A shared pointer uses a <em class="italic">control block</em> to manage its resources. One control block is associated with one managed object and is shared among the pointers that share that object. The control block generally contains:</p>
			<ul>
				<li>A pointer to the managed object</li>
				<li>The <em class="italic">deleter</em></li>
				<li>The <em class="italic">allocator</em></li>
				<li>The number of <strong class="source-inline">shared_ptr</strong> objects that own the managed object (this is the <em class="italic">use count</em>)</li>
				<li>The number of <strong class="source-inline">weak_ptr</strong> objects that refer to the managed object</li>
			</ul>
			<p>In the case of an aliased shared pointer, the control block includes the pointer to the <em class="italic">aliased object</em>. Everything else remains the same.</p>
			<p>Aliased shared pointers participate in the use count, just like non-aliased shared pointers, preventing<a id="_idIndexMarker773"/> the managed object from being <a id="_idIndexMarker774"/>destroyed until the use count reaches zero. The deleter is not changed, so it destroys the managed object.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is possible to use any pointer to construct an aliased shared pointer. Usually, the pointer refers to a member within the aliased object. If the aliased pointer does not refer to an element of the managed object, you will need to manage its construction and destruction separately.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor284"/>Compare random number engines</h1>
			<p>The <strong class="source-inline">random</strong> library <a id="_idIndexMarker775"/>provides a selection of random number generators, each with different strategies and properties. In this recipe, we examine a function to compare the different options by creating a histogram of their output.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor285"/>How to do it…</h2>
			<p>In this recipe, we compare the different random number generators provided by the C++ <strong class="source-inline">random</strong> library:</p>
			<ul>
				<li>We start with some constants to provide uniform parameters for the random number generators:<p class="source-code">constexpr size_t <strong class="bold">n_samples</strong>{ 1000 };</p><p class="source-code">constexpr size_t <strong class="bold">n_partitions</strong>{ 10 };</p><p class="source-code">constexpr size_t <strong class="bold">n_max</strong>{ 50 };</p></li>
			</ul>
			<p><strong class="source-inline">n_samples</strong> is the number of samples to examine, <strong class="source-inline">n_partitions</strong> is the number of partitions in which to display the samples, and <strong class="source-inline">n_max</strong> is the maximum size of a bar in the histogram (this will vary some due to rounding). </p>
			<p>These numbers provide a reasonable display of the differences between the engines. Increasing the ratio of <em class="italic">samples</em> versus <em class="italic">partitions</em> tends to smooth out the curves<a id="_idIndexMarker776"/> and obscure the differences between the engines.</p>
			<ul>
				<li>This is the function that collects random number samples and displays a histogram:<p class="source-code">template &lt;typename RNG&gt;</p><p class="source-code">void <strong class="bold">histogram</strong>(const string_view&amp; rng_name) {</p><p class="source-code">    auto p_ratio = (double)RNG::max() / n_partitions;</p><p class="source-code">    RNG <strong class="bold">rng{}</strong>;  // construct the engine object</p><p class="source-code">    // collect the samples</p><p class="source-code">    <strong class="bold">vector&lt;size_t&gt; v</strong>(n_partitions);</p><p class="source-code">    for(size_t i{}; i &lt; n_samples; ++i) {</p><p class="source-code">        <strong class="bold">++v[rng() / p_ratio];</strong></p><p class="source-code">    }</p><p class="source-code">    // display the histogram</p><p class="source-code">    auto max_el = std::max_element(v.begin(), </p><p class="source-code">      v.end());</p><p class="source-code">    auto v_ratio = *max_el / n_max;</p><p class="source-code">    if(v_ratio &lt; 1) v_ratio = 1;</p><p class="source-code">    cout &lt;&lt; format("engine: {}\n", rng_name);</p><p class="source-code">    for(size_t i{}; i &lt; n_partitions; ++i) {</p><p class="source-code">        cout &lt;&lt; format("<strong class="bold">{:02}:{:*&lt;{}}</strong>\n",</p><p class="source-code">            i + 1, ' ', v[i] / v_ratio);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>In a nutshell, this<a id="_idIndexMarker777"/> function stores a histogram of collected samples in a <strong class="source-inline">vector</strong>. It then displays the histogram as a series of asterisks on the console.</p>
			<ul>
				<li>We call <strong class="source-inline">histogram()</strong> from <strong class="source-inline">main()</strong>, like this:<p class="source-code">int main() {</p><p class="source-code">    histogram&lt;std::random_device&gt;("random_device");</p><p class="source-code">    histogram&lt;std::default_random_engine&gt;</p><p class="source-code">        ("default_random_engine");</p><p class="source-code">    histogram&lt;std::minstd_rand0&gt;("minstd_rand0");</p><p class="source-code">    histogram&lt;std::minstd_rand&gt;("minstd_rand");</p><p class="source-code">    histogram&lt;std::mt19937&gt;("mt19937");</p><p class="source-code">    histogram&lt;std::mt19937_64&gt;("mt19937_64");</p><p class="source-code">    histogram&lt;std::ranlux24_base&gt;("ranlux24_base");</p><p class="source-code">    histogram&lt;std::ranlux48_base&gt;("ranlux48_base");</p><p class="source-code">    histogram&lt;std::ranlux24&gt;("ranlux24");</p><p class="source-code">    histogram&lt;std::ranlux48&gt;("ranlux48");</p><p class="source-code">    histogram&lt;std::knuth_b&gt;("knuth_b");</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B18267_08_01.jpg" alt="Figure 8.1 – A screenshot of output from the first two random number engines&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – A screenshot of output from the first two random number engines</p>
			<p>This screenshot shows histograms of the first two random number engines. Your output will vary. </p>
			<p>If we raise the value of <strong class="source-inline">n_samples</strong> to 100,000, you'll see that the variance between <a id="_idIndexMarker778"/>engines becomes more difficult to discern:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B18267_08_02.jpg" alt="Figure 8.2 – A screenshot of output with 100,000 samples&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – A screenshot of output with 100,000 samples</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor286"/>How it works…</h2>
			<p>Each of the random number engines has a functor interface that returns the next random number in the sequence: </p>
			<p class="source-code">result_type operator()();</p>
			<p>The functor returns a random value, evenly distributed between the <strong class="source-inline">min()</strong> and <strong class="source-inline">max()</strong> values. All the random number engines have this interface in common. </p>
			<p>The <strong class="source-inline">histogram()</strong> function takes advantage of this uniformity by using the class of the random number engine in a template:</p>
			<p class="source-code">template &lt;typename RNG&gt;</p>
			<p>(<strong class="bold">RNG</strong> is a common abbreviation for <strong class="bold">Random Number Generator</strong>. The library documentation<a id="_idIndexMarker779"/> refers to these classes as <em class="italic">engines</em>, which is synonymous with RNG for our purposes.)</p>
			<p>We instantiate<a id="_idIndexMarker780"/> an object with the RNG class and create a histogram in a <strong class="source-inline">vector</strong>:</p>
			<p class="source-code">RNG rng{};</p>
			<p class="source-code"><strong class="bold">vector&lt;size_t&gt; v(n_partitions)</strong>;</p>
			<p class="source-code">for(size_t i{}; i &lt; n_samples; ++i) {</p>
			<p class="source-code">    ++v[<strong class="bold">rng()</strong> / p_ratio];</p>
			<p class="source-code">}</p>
			<p>This allows us to easily compare the results of the various random number engines with this technique. </p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor287"/>There's more…</h2>
			<p>Each of the <a id="_idIndexMarker781"/>random number engines in the library have different methodologies and characteristics. When you run the histogram multiple times, you'll notice that most of the engines have the same distribution each time they're run. That's because they are <em class="italic">deterministic</em> – that is, they generate the same sequence of numbers each time. <strong class="source-inline">std::random_device</strong> is non-deterministic on most systems. You can use it to seed one of the other engines if you need more variation. It is also common to seed an RNG with the current date and time.</p>
			<p>The <strong class="source-inline">std::default_random_engine</strong> is a suitable choice for most purposes. </p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor288"/>Compare random number distribution generators</h1>
			<p>The C++ Standard <a id="_idIndexMarker782"/>Library provides a selection of random number distribution generators, each with its own properties. In this recipe, we examine a function to compare the different options by creating a histogram of their output.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/>How to do it…</h2>
			<p>Like the random number engines, the distribution generators have some common interface elements. Unlike the random number engines, the distribution generators have a variety of properties to set. We can create a template function to print a histogram of the various distributions, but the initializations of the various distribution generators vary significantly:</p>
			<ul>
				<li>We start with some constants:<p class="source-code">constexpr size_t n_samples{ 10 * 1000 };</p><p class="source-code">constexpr size_t n_max{ 50 };</p></li>
			</ul>
			<p>The <strong class="source-inline">n_samples</strong> constant is the number of samples to generate for each histogram – in this case, 10,000. </p>
			<p>The <strong class="source-inline">n_max</strong> constant is used as a divisor while generating our histograms.</p>
			<ul>
				<li>Our histogram function takes a distribution generator as an argument and prints a histogram for that distribution algorithm:<p class="source-code">void dist_histogram(auto distro,</p><p class="source-code">        const string_view&amp; dist_name) {</p><p class="source-code">   <strong class="bold"> std::default_random_engine rng{};</strong></p><p class="source-code"><strong class="bold">    map&lt;long, size_t&gt; m;</strong></p><p class="source-code">    // create the histogram map</p><p class="source-code">    for(size_t i{}; i &lt; n_samples; ++i) </p><p class="source-code">       <strong class="bold"> ++m[(long)distro(rng)];</strong></p><p class="source-code">    // print the histogram</p><p class="source-code">    auto max_elm_it = max_element(m.begin(), m.end(),</p><p class="source-code">        [](const auto&amp; a, const auto&amp; b)</p><p class="source-code">        { return a.second &lt; b.second; }</p><p class="source-code">        );</p><p class="source-code">    size_t max_elm = max_elm_it-&gt;second;</p><p class="source-code">    size_t max_div = std::max(max_elm / n_max,</p><p class="source-code">        size_t(1));</p><p class="source-code">    cout &lt;&lt; format("{}:\n", dist_name);</p><p class="source-code">    for (const auto [randval, count] : m) {</p><p class="source-code">        if (count &lt; max_elm / n_max) continue;</p><p class="source-code">        cout &lt;&lt; format("{:3}:{:*&lt;{}}\n",</p><p class="source-code">            randval, ' ', count / max_div);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">dist_histogram()</strong> function <a id="_idIndexMarker783"/>uses a <strong class="source-inline">map</strong> to store the histogram. It then displays the histogram as a series of asterisks on the console.</p>
			<ul>
				<li>We call <strong class="source-inline">dist_histogram()</strong> from <strong class="source-inline">main()</strong>, like this:<p class="source-code">int main() {</p><p class="source-code">    dist_histogram(std::uniform_int_distribution&lt;int&gt;</p><p class="source-code">        {0, 9}, uniform_int_distribution");</p><p class="source-code">    dist_histogram(std::normal_distribution&lt;double&gt;</p><p class="source-code">        {0.0, 2.0}, "normal_distribution");</p><p class="source-code">...</p></li>
			</ul>
			<p>Calling the <strong class="source-inline">dist_histogram()</strong> function is more complex than it was for the random number generators. Each random distribution class has a different set of parameters, according<a id="_idIndexMarker784"/> to its algorithm. </p>
			<p>For the full list, refer to the <strong class="source-inline">distribution.cpp</strong> file in the GitHub archive.</p>
			<p>Output:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B18267_08_03.jpg" alt="Figure 8.3 – A screenshot of random distribution histograms&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – A screenshot of random distribution histograms</p>
			<p>Each of the <a id="_idIndexMarker785"/>distribution algorithms produces very different output. You will want to experiment with the different options for each random distribution generator.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/>How it works…</h2>
			<p>Each of the distribution generators has a functor that returns the next value in the random distribution:</p>
			<p class="source-code">result_type operator()( Generator&amp; g );</p>
			<p>The functor takes a random number generator (RNG) object as an argument:</p>
			<p class="source-code">std::default_random_engine <strong class="bold">rng{}</strong>;</p>
			<p class="source-code">map&lt;long, size_t&gt; <strong class="bold">m</strong>;</p>
			<p class="source-code">for (size_t i{}; i &lt; n_samples; ++i) <strong class="bold">++m[(long)distro(rng)]</strong>;</p>
			<p>For our <a id="_idIndexMarker786"/>purposes, we're using the <strong class="source-inline">std::default_random_engine</strong> for our RNG. </p>
			<p>As with the RNG histogram, this is a useful tool to visualize the various random distribution algorithms available in the <strong class="source-inline">random</strong> library. You will want to experiment with the various parameters available for each algorithm.</p>
		</div>
	</body></html>