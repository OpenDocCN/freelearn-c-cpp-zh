<html><head></head><body>
		<div><h1 id="_idParaDest-251"><a id="_idTextAnchor250"/><em class="italic">Chapter 8</em>: Utility Classes</h1>
			<p>The C++ Standard Library includes an assortment of utility classes designed for specific tasks. Some are common, and you've probably seen many of these classes in other recipes in this book.</p>
			<p>This chapter covers a broad range of utilities, including time measurement, generic types, smart pointers, and more, in the following recipes:</p>
			<ul>
				<li>Manage optional values with <code>std::optional</code></li>
				<li>Use <code>std::any</code> for type safety</li>
				<li>Store different types with <code>std::variant</code></li>
				<li>Time events with <code>std::chrono</code></li>
				<li>Use fold expressions for variadic tuples</li>
				<li>Manage allocated memory with <code>std::unique_ptr</code></li>
				<li>Share objects with <code>std::shared_ptr</code></li>
				<li>Use weak pointers with shared objects</li>
				<li>Share members of a managed object</li>
				<li>Compare random number engines</li>
				<li>Compare random number distribution generators</li>
			</ul>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor251"/>Technical requirements</h1>
			<p>The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08</a>.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/>Manage optional values with std::optional</h1>
			<p>Introduced<a id="_idIndexMarker666"/> with <a id="_idIndexMarker667"/>C++17, the <code>std::optional</code> class holds an <em class="italic">optional value</em>.</p>
			<p>Consider the case where you have a function that may or may not return a value – for example, a function that checks if a number is <em class="italic">prime</em> but returns the first factor if there is one. This function should return either a value or a <code>bool</code> status. We could create a <code>struct</code> that carries both value and status:</p>
			<pre>struct factor_t {
    bool is_prime;
    long factor;
};
factor_t factor(long n) {
    factor_t r{};
    for(long i = 2; i &lt;= n / 2; ++i) {
        if (n % i == 0) {
            r.is_prime = false;
            r.factor = i;
            return r;
        }
    }
    r.is_prime = true;
    return r;
}</pre>
			<p>It's a clumsy solution but it works, and it's not uncommon. </p>
			<p>It could be made a lot simpler with the <code>optional</code> class:</p>
			<pre>optional&lt;long&gt; factor(long n) {
    for (long i = 2; i &lt;= n / 2; ++i) {
        if (n % i == 0) return {i};
    }
    return {};
}</pre>
			<p>With <code>optional</code>, we can<a id="_idIndexMarker668"/> return a value or a <a id="_idIndexMarker669"/>non-value.</p>
			<p>We can call it, like this:</p>
			<pre>long a{ 42 };
long b{ 73 };
auto x = factor(a);
auto y = factor(b);
if(x) cout &lt;&lt; format("lowest factor of {} is {}\n", a, *x);
else cout &lt;&lt; format("{} is prime\n", a);
if(y) cout &lt;&lt; format("lowest factor of {} is {}\n", b, *y);
else cout &lt;&lt; format("{} is prime\n", b);</pre>
			<p>Our output is:</p>
			<pre>lowest factor of 42 is 2
73 is prime</pre>
			<p>The optional class allows us to easily return the optional value and easily test for a value. </p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>How to do it…</h2>
			<p>In this recipe, we'll look at some examples of how to use the <code>optional</code> class:</p>
			<ul>
				<li>The <code>optional</code> class is quite simple. We construct an optional value using standard template notation: <pre><strong class="bold">optional&lt;int&gt;</strong> a{ 42 };
cout &lt;&lt; *a &lt;&lt; '\n';</pre></li>
			</ul>
			<p>We access the value of the <code>optional</code> with the <code>*</code> pointer dereference operator. </p>
			<p>Output:</p>
			<pre><strong class="bold">42</strong></pre>
			<ul>
				<li>We test if the <code>optional</code> has a value using its <code>bool</code> operator:<pre><code> </code></pre></li>
			</ul>
			<p>If <code>a</code> were <a id="_idIndexMarker670"/>constructed without a <a id="_idIndexMarker671"/>value:</p>
			<pre>optional&lt;int&gt; a{};</pre>
			<p>The output would reflect the <code>else</code> condition:</p>
			<pre><strong class="bold">no value</strong></pre>
			<ul>
				<li>We can further simplify this by declaring a <em class="italic">type alias</em>:<pre><strong class="bold">using</strong> oint = std::optional&lt;int&gt;;
<strong class="bold">oint</strong> a{ 42 };
<strong class="bold">oint</strong> b{ 73 };</pre></li>
				<li>If we want to operate on <code>oint</code> objects, with <code>oint</code> objects as the result, we can provide operator overloads:<pre>oint <strong class="bold">operator+</strong>(const oint&amp; a, const oint&amp; b) {
    <strong class="bold">if(a &amp;&amp; b)</strong> return *a + *b;
    else return <strong class="bold">{}</strong>;
}
oint <strong class="bold">operator+</strong>(const oint&amp; a, const int b) {
    <strong class="bold">if(a)</strong> return *a + b;
    else return <strong class="bold">{}</strong>;
}</pre></li>
			</ul>
			<p>Now, we can operate on the <code>oint</code> objects directly:</p>
			<pre>auto sum{ <strong class="bold">a + b</strong> };
<strong class="bold">if(sum)</strong> {
    cout &lt;&lt; format("{} + {} = {}\n", *a, *b, *sum);
} else {
    cout &lt;&lt; "NAN\n";
}</pre>
			<p>Output:</p>
			<pre><strong class="bold">42 + 73 = 115</strong></pre>
			<ul>
				<li>Suppose <a id="_idIndexMarker672"/>we<a id="_idIndexMarker673"/> declare <code>b</code> with the default constructor:<pre>oint <strong class="bold">b{}</strong>;</pre></li>
			</ul>
			<p>Now, we get the <code>else</code> branch output:</p>
			<pre>NAN</pre>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/>How it works…</h2>
			<p>The <code>std::optional</code> class is made for simplicity. It provides operator overloads for many common functions. It also includes member functions for further flexibility.</p>
			<p>The <code>optional</code> class provides an <code>operator bool</code> overload for determining if the object has a value:</p>
			<pre>optional&lt;int&gt; n{ 42 };
if(n) ... // has a value</pre>
			<p>Or, you may use the <code>has_value()</code> member function:</p>
			<pre>if(n.has_value()) ... // has a value</pre>
			<p>To access the value, you may use the <code>operator*</code> overload:</p>
			<pre>x = *n;  // * retruns the value</pre>
			<p>Or, you may use the <code>value()</code> member function:</p>
			<pre>x = n.value();  // * retruns the value</pre>
			<p>The <code>reset()</code> member <a id="_idIndexMarker674"/>function destroys the value and<a id="_idIndexMarker675"/> resets the state of the <code>optional</code> object:</p>
			<pre>n.reset();      // no longer has a value</pre>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor255"/>There's more…</h2>
			<p>The <code>optional</code> class <a id="_idIndexMarker676"/>provides exception support with the <code>value()</code> method:</p>
			<pre>b.reset();
try {
    cout &lt;&lt; b.<strong class="bold">value()</strong> &lt;&lt; '\n';
} catch(const <strong class="bold">std::bad_optional_access</strong>&amp; e) {
    cout &lt;&lt; format("b.value(): {}\n", e.what());
}</pre>
			<p>Output:</p>
			<pre>b.value(): bad optional access</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Only the <code>value()</code> method throws an exception. The behavior of the <code>*</code> operator is <em class="italic">undefined</em> for an invalid value.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor256"/>Use std::any for type safety</h1>
			<p>Introduced <a id="_idIndexMarker677"/>with C++17, the <code>std::any</code> class provides a type-safe container for a single object of any type. </p>
			<p>For example, this is a default-constructed <code>any</code> object:</p>
			<pre>any x{};</pre>
			<p>This object has no value. We can test that with the <code>has_value()</code> method:</p>
			<pre>if(x.has_value()) cout &lt;&lt; "have value\n";
else cout &lt;&lt; "no value\n";</pre>
			<p>Output:</p>
			<pre>no value</pre>
			<p>We assign a value to the <code>any</code> object with the assignment operator:</p>
			<pre>x = 42;</pre>
			<p>Now, the <code>any</code> object has a value, and a type:</p>
			<pre>if(x.has_value()) {
    cout &lt;&lt; format("x has type: {}\n", x.type().name());
    cout &lt;&lt; format("x has value: {}\n", any_cast&lt;int&gt;(x));
} else {
    cout &lt;&lt; "no value\n";
}</pre>
			<p>Output:</p>
			<pre>x has type: i
x has value: 42</pre>
			<p>The <code>type()</code> method returns a <code>type_info</code> object. The <code>type_info::name()</code> method returns an implementation-defined name for the type in a C-string. In this case, for GCC, the <code>i</code> means <code>int</code>.</p>
			<p>We use the <code>any_cast&lt;</code><em class="italic">type</em><code>&gt;()</code> non-member function to cast the value for use.</p>
			<p>We can re-assign the <code>any</code> object with different values of different types:</p>
			<pre>x = "abc"s;
cout &lt;&lt; format("x is type {} with value {}\n", 
    x.type().name(), any_cast&lt;string&gt;(x))</pre>
			<p>Output:</p>
			<pre>x is type NSt7__cxx1112basic_string... with value abc</pre>
			<p>I've abbreviated the long type name from GCC but you get the idea. The same <code>any</code> object that once held an <code>int</code> now contains an STL <code>string</code> object.</p>
			<p>The main usefulness of the <code>any</code> class is in creating a polymorphic function. Let's examine<a id="_idIndexMarker678"/> how to do that in this recipe:</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor257"/>How to do it…</h2>
			<p>In this recipe, we'll build a polymorphic function using the <code>any</code> class. A polymorphic function is one that can take objects of different types in its parameters:</p>
			<ul>
				<li>Our polymorphic function takes an <code>any</code> object and prints its type and value:<pre>void <strong class="bold">p_any</strong>(const <strong class="bold">any</strong>&amp; a) {
    if (!a.<strong class="bold">has_value()</strong>) {
        cout &lt;&lt; "None.\n";
    } else if (<strong class="bold">a.type()</strong> == typeid(<strong class="bold">int</strong>)) {
        cout &lt;&lt; format("int: {}\n", any_cast&lt;<strong class="bold">int</strong>&gt;(a));
    } else if (<strong class="bold">a.type()</strong> == typeid(<strong class="bold">string</strong>)) {
        cout &lt;&lt; format("string: \"{}\"\n", 
            any_cast&lt;<strong class="bold">const string</strong>&amp;&gt;(a));
    } else if (<strong class="bold">a.type()</strong> == typeid(<strong class="bold">list&lt;int&gt;</strong>)) {
        cout &lt;&lt; "list&lt;int&gt;: ";
        for(auto&amp; i : any_cast&lt;<strong class="bold">const list&lt;int&gt;</strong>&amp;&gt;(a)) 
            cout &lt;&lt; format("{} ", i);
        cout &lt;&lt; '\n';
    } <strong class="bold">else</strong> {
        cout &lt;&lt; format("something else: {}\n", 
            a.type().name());
    }
}</pre></li>
			</ul>
			<p>The <code>p_any()</code> function first tests to see if the object has a value. It then tests the <code>type()</code> method against various types and takes appropriate action for each type. </p>
			<p>Before the <code>any</code> class, we<a id="_idIndexMarker679"/> would have had to write four different specializations for this function, and we still wouldn't be able to easily handle the default case.</p>
			<ul>
				<li>We call this function from <code>main()</code>, like this:<pre>p_any({});
p_any(47);
p_any("abc"s);
p_any(any(list{ 1, 2, 3 }));
p_any(any(vector{ 1, 2, 3 }));</pre></li>
			</ul>
			<p>Output:</p>
			<pre>None.
int: 47
string: "abc"
list&lt;int&gt;: 1 2 3
something else: St6vectorIiSaIiEE</pre>
			<p>Our polymorphic function handles the various types with a minimum of code.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor258"/>How it works…</h2>
			<p>The <code>std::any</code> copy constructor and assignment operator use <em class="italic">direct initialization</em> to make a non-<code>const</code> copy of the target object as the <em class="italic">contained</em> object. The type of the contained object is stored separately as a <code>typeid</code> object. </p>
			<p>Once initialized, the <code>any</code> object has the following methods:</p>
			<ul>
				<li><code>emplace()</code> replaces the contained object, constructing the new object in place.</li>
				<li><code>reset()</code> destroys the contained object.</li>
				<li><code>has_value()</code> returns <code>true</code> if there is a contained object.</li>
				<li><code>type()</code> returns a <code>typeid</code> object, representing the type of the contained object.</li>
				<li><code>operator=()</code> replaces the contained object by a <em class="italic">copy</em> or <em class="italic">move</em> operation.</li>
			</ul>
			<p>The <code>any</code> class<a id="_idIndexMarker680"/> also supports the following non-member functions:</p>
			<ul>
				<li><code>any_cast&lt;T&gt;()</code>, a template function, provides type-safe access to the contained object.</li>
			</ul>
			<p>Keep in mind that the <code>any_cast&lt;T&gt;()</code> function returns a copy of the contained object. You may use <code>any_cast&lt;T&amp;&gt;()</code> to return a reference.</p>
			<ul>
				<li><code>std::swap()</code> specializes the <code>std::swap</code> algorithm.<code> </code></li>
			</ul>
			<p>If you try to cast an <code>any</code> object with the wrong type, it throws a <code>bad_any_cast</code> exception:</p>
			<pre>try {
    cout &lt;&lt; any_cast&lt;int&gt;(x) &lt;&lt; '\n';
} catch(std::bad_any_cast&amp; e) {
    cout &lt;&lt; format("any: {}\n", e.what());
}</pre>
			<p>Output:</p>
			<pre>any: bad any_cast</pre>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor259"/>Store different types with std::variant</h1>
			<p>Introduced <a id="_idIndexMarker681"/>with C++17, the <code>std::variant</code> class may hold different values, one at a time, where each value must fit in the same allocated memory space. It's useful for holding alternative types for use in a single context. </p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor260"/>Differences from the primitive union structure</h2>
			<p>The <code>variant</code> class<a id="_idIndexMarker682"/> is a <em class="italic">tagged union</em>. It differs<a id="_idIndexMarker683"/> from the primitive <code>union</code> structure in that only one type may be in effect at a time.</p>
			<p>The primitive <code>union</code> type, inherited from C, is a structure where the same datum may be accessed as different types. For example:</p>
			<pre>union ipv4 {
    struct {
        uint8_t <strong class="bold">a</strong>; uint8_t <strong class="bold">b</strong>; uint8_t <strong class="bold">c</strong>; uint8_t <strong class="bold">d</strong>;
    } quad;
    uint32_t <strong class="bold">int32</strong>;
} addr;
addr.<strong class="bold">int32</strong> = 0x2A05A8C0;
cout &lt;&lt; format("ip addr dotted quad: {}.{}.{}.{}\n", 
    addr.<strong class="bold">quad.a</strong>, addr.<strong class="bold">quad.b</strong>, addr.<strong class="bold">quad.c</strong>, addr.<strong class="bold">quad.d</strong>);
cout &lt;&lt; format("ip addr int32 (LE): {:08X}\n", addr.<strong class="bold">int32</strong>);</pre>
			<p>Output:</p>
			<pre>ip addr dotted quad: 192.168.5.42
ip addr int32 (LE): 2A05A8C0</pre>
			<p>In this example, the <code>union</code> has two members, types <code>struct</code> and <code>uint32_t</code>, where <code>struct</code> has four <code>uint8_t</code> members. This gives us two <em class="italic">different perspectives of the same 32-bit memory space</em>. We can view the same <code>ipv4</code> address as either a 32-bit unsigned <a id="_idIndexMarker684"/>integer (<strong class="bold">Little Endian</strong> or <strong class="bold">LE</strong>) or four 8-bit unsigned integers in the common <em class="italic">dotted quad</em> notation. This provides a bitwise polymorphy that can be useful at the systems level.</p>
			<p><code>variant</code> doesn't work<a id="_idIndexMarker685"/> like that. The <code>variant</code> class<a id="_idIndexMarker686"/> is a <em class="italic">tagged union</em>, where each datum is tagged with its type. If we store a value as <code>uint32_t</code>, we may only access it as <code>uint32_t</code>. This makes <code>variant</code> type safe but not a replacement for <code>union</code>.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor261"/>How to do it…</h2>
			<p>In this recipe, we<a id="_idIndexMarker687"/> demonstrate the use of <code>std::variant</code> with a small catalogue of household pets of various species.</p>
			<ul>
				<li>We'll start with a simple class to hold an <code>Animal</code>:<pre>class Animal {
    string_view _name{};
    string_view _sound{};
    Animal();
public:
    Animal(string_view n, string_view s) 
        : _name{ n }, _sound{ s } {}
    void speak() const {
        cout &lt;&lt; format("{} says {}\n", _name, _sound);
    }
    void sound(string_view s) {
        _sound = s;
    }
};</pre></li>
			</ul>
			<p>The name of the animal and the sound that the animal makes are passed in the constructor. </p>
			<ul>
				<li>Individual<a id="_idIndexMarker688"/> species classes inherit from <code>Animal</code>:<pre>class Cat : public Animal {
public:
    Cat(string_view n) : Animal(n, "meow") {}
};
class Dog : public Animal {
public:
    Dog(string_view n) : Animal(n, "arf!") {}
};
class Wookie : public Animal {
public:
    Wookie(string_view n) : Animal(n, "grrraarrgghh!") {}
};</pre></li>
			</ul>
			<p>Each of these classes set the sound for their specific species by calling the parent constructor.</p>
			<ul>
				<li>Now, we can define our <code>variant</code> type in an alias:<pre>using v_animal = std::variant&lt;Cat, Dog, Wookie&gt;;</pre></li>
			</ul>
			<p>This <code>variant</code> can hold any of the types, <code>Cat</code>, <code>Dog</code>, or <code>Wookie</code>.</p>
			<ul>
				<li>In <code>main()</code>, we create a <code>list</code> using our <code>v_animal</code> alias as the type:<pre>int main() {
    list&lt;v_animal&gt; pets{ 
        <strong class="bold">Cat</strong>{"Hobbes"}, <strong class="bold">Dog</strong>{"Fido"}, <strong class="bold">Cat</strong>{"Max"}, 
        <strong class="bold">Wookie</strong>{"Chewie"}
    };
    ...</pre></li>
			</ul>
			<p>Each element in the list is of a type included in the <code>variant</code> definition. </p>
			<ul>
				<li>The <code>variant</code> class provides several different ways to access elements. First, we'll look at the <code>visit()</code> function. </li>
			</ul>
			<p><code>visit()</code> calls a <em class="italic">functor</em> with the object currently contained in the <code>variant</code>. First, let's <a id="_idIndexMarker689"/>define a functor that accepts any of our pets:</p>
			<pre>struct animal_speaks {
    void operator()(const Dog&amp; d) const { d.speak(); }
    void operator()(const Cat&amp; c) const { c.speak(); }
    void operator()(const Wookie&amp; w) const { 
      w.speak(); }
};</pre>
			<p>This is a simple functor class with overloads for each of the <code>Animal</code> sub-classes. We call it with <code>visit()</code>, with each of our <code>list</code> elements:</p>
			<pre>for (const v_animal&amp; a : pets) {
    visit(animal_speaks{}, a);
}</pre>
			<p>We get this output:</p>
			<pre><strong class="bold">Hobbes says meow</strong>
<strong class="bold">Fido says arf!</strong>
<strong class="bold">Max says meow</strong>
<strong class="bold">Chewie says grrraarrgghh!</strong></pre>
			<ul>
				<li>The <code>variant</code> class also provides an <code>index()</code> method:<pre>for(const v_animal &amp;a : pets) {
    auto idx{ a.index() };
    if(idx == 0) get&lt;Cat&gt;(a).speak();
    if(idx == 1) get&lt;Dog&gt;(a).speak();
    if(idx == 2) get&lt;Wookie&gt;(a).speak();
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Hobbes says meow</strong>
<strong class="bold">Fido says arf!</strong>
<strong class="bold">Max says meow</strong>
<strong class="bold">Chewie says grrraarrgghh!</strong></pre>
			<p>Each <code>variant</code> object<a id="_idIndexMarker690"/> is indexed, based on the order in which the types were declared in the template arguments. Our <code>v_animal</code> type was defined with <code>std::variant&lt;Cat, Dog, Wookie&gt;</code>, and these types are indexed as <code>0</code> – <code>2</code>, in that order.</p>
			<ul>
				<li>The <code>get_if&lt;T&gt;()</code> function tests a given element against a type:<pre>for (const v_animal&amp; a : pets) {
    if(const auto c{ get_if&lt;Cat&gt;(&amp;a) }; c) {
        c-&gt;speak();
    } else if(const auto d{ get_if&lt;Dog&gt;(&amp;a) }; d) {
        d-&gt;speak();
    } else if(const auto w{ get_if&lt;Wookie&gt;(&amp;a) }; w) {
        w-&gt;speak();
    }
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Hobbes says meow</strong>
<strong class="bold">Fido says arf!</strong>
<strong class="bold">Max says meow</strong>
<strong class="bold">Chewie says grrraarrgghh!</strong></pre>
			<p>The <code>get_if&lt;T&gt;()</code> function returns a pointer if the type of the element matches <code>T</code>; otherwise, it returns <code>nullptr</code>.</p>
			<ul>
				<li>Finally, the <code>holds_alternative&lt;T&gt;()</code> function returns <code>true</code> or <code>false</code>. We can<a id="_idIndexMarker691"/> use this to test a type against an element, without returning the element:<pre>size_t n_cats{}, n_dogs{}, n_wookies{};
for(const v_animal&amp; a : pets) {
    if(holds_alternative&lt;Cat&gt;(a)) ++n_cats;
    if(holds_alternative&lt;Dog&gt;(a)) ++n_dogs;
    if(holds_alternative&lt;Wookie&gt;(a)) ++n_wookies;
}
cout &lt;&lt; format("there are {} cat(s), "
               "{} dog(s), "
               "and {} wookie(s)\n",
               n_cats, n_dogs, n_wookies);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">there are 2 cat(s), 1 dog(s), and 1 wookie(s)</strong></pre>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor262"/>How it works…</h2>
			<p>The <code>std::variant</code> class is a single-object container. An instance of <code>variant&lt;X, Y, Z&gt;</code> must hold exactly one object of type <code>X</code>, <code>Y</code>, or <code>Z</code>. It holds both the value and the type of its current object.</p>
			<p>The <code>index()</code> method tells us the type of the current object:</p>
			<pre>if(v.index() == 0) // if variant is type X</pre>
			<p>The <code>holds_alternative&lt;T&gt;()</code> non-member function returns <code>true</code> if <code>T</code> is the type of the current object:</p>
			<pre>if(holds_alternative&lt;X&gt;(v))  // if current variant obj is type X</pre>
			<p>We can<a id="_idIndexMarker692"/> retrieve the current object with the <code>get()</code> non-member function:</p>
			<pre>auto o{ get&lt;X&gt;(v) };  // current variant obj must be type X</pre>
			<p>We can combine the test for type and retrieval with the <code>get_if()</code> non-member function:</p>
			<pre>auto* p{ get_if&lt;X&gt;(v) };  // nullptr if current obj not type X</pre>
			<p>The <code>visit()</code> non-member function invokes a callable object with the current variant object as its single parameter:</p>
			<pre>visit(f, v);  // calls f(v) with current variant obj</pre>
			<p>The <code>visit()</code> function is the only way to retrieve an object without testing its type. In combination with a functor that can handle each type, this can be very flexible:</p>
			<pre>struct animal_speaks {
    void operator()(const Dog&amp; d) const { d.speak(); }
    void operator()(const Cat&amp; c) const { c.speak(); }
    void operator()(const Wookie&amp; v) const { v.speak(); }
};
main() {
    for (const v_animal&amp; a : pets) {
        visit(animal_speaks{}, a);
    } 
}</pre>
			<p>Output:</p>
			<pre>Hobbes says meow
Fido says arf!
Max says meow
Chewie says grrraarrgghh!</pre>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor263"/>Time events with std::chrono</h1>
			<p>The <code>std::chrono</code> library <a id="_idIndexMarker693"/>provides tools for measuring and <a id="_idIndexMarker694"/>reporting time and intervals. </p>
			<p>Many of these classes and functions were introduced with C++11. There have been significant changes and updates for C++20, but at the time of writing, many of those updates are not yet implemented on the systems I've tested.</p>
			<p>Using the <code>chrono</code> library, this recipe explores techniques for timing events. </p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor264"/>How to do it…</h2>
			<p>The <code>system_clock</code> class is used for reporting the current date and time. The <code>steady_clock</code> and <code>high_resolution_clock</code> classes are used for timing events. Let's look at the differences between these clocks:</p>
			<ul>
				<li>Because these names can be long and unwieldy, we'll use some type aliases throughout this recipe:<pre>using std::chrono::system_clock;
using std::chrono::steady_clock;
using std::chrono::high_resolution_clock;
using std::chrono::duration;
using seconds = duration&lt;double&gt;;
using milliseconds = duration&lt;double, std::milli&gt;;
using microseconds = duration&lt;double, std::micro&gt;;
using fps24 = duration&lt;unsigned long, std::ratio&lt;1, 24&gt;&gt;;</pre></li>
			</ul>
			<p>The <code>duration</code> class <a id="_idIndexMarker695"/>represents an interval between two points<a id="_idIndexMarker696"/> in time. These aliases are convenient for using different intervals.</p>
			<ul>
				<li>We can get the current time and date by using the <code>system_clock</code> class:<pre>auto t = <strong class="bold">system_clock::now()</strong>;
cout &lt;&lt; format("system_clock::now is <strong class="bold">{:%F %T}</strong>\n", t);</pre></li>
			</ul>
			<p>The <code>system_clock::now()</code> function returns a <code>time_point</code> object. The <code>&lt;chrono&gt;</code> library includes a <code>format()</code> specialization for <code>time_point</code> that uses <code>strftime()</code> format specifiers.</p>
			<p>The output is:</p>
			<pre><strong class="bold">system_clock::now is 2022-02-05 13:52:15</strong></pre>
			<p>The <code>&lt;iomanip&gt;</code> header includes <code>put_time()</code>, which works like <code>strftime()</code> for <code>ostream</code>:</p>
			<pre>std::time_t now_t = <strong class="bold">system_clock::to_time_t(t)</strong>;
cout &lt;&lt; "system_clock::now is " 
     &lt;&lt; std::put_time(std::localtime(&amp;now_t), "%F %T") 
     &lt;&lt; '\n';</pre>
			<p><code>put_time()</code> takes a pointer to a C-style <code>time_t*</code> value. <code>system_clock::to_time_t</code> converts a <code>time_point</code> object to <code>time_t</code>.</p>
			<p>This gives the same output as our <code>format()</code> example:</p>
			<pre><strong class="bold">system_clock::now is 2022-02-05 13:52:15</strong></pre>
			<ul>
				<li>We can also use <code>system_clock</code> to time an event. First, we need something to time. Here's<a id="_idIndexMarker697"/> a<a id="_idIndexMarker698"/> function that counts prime numbers:<pre>constexpr uint64_t MAX_PRIME{ 0x1FFFF }
uint64_t count_primes() {
    constexpr auto is_prime = [](const uint64_t n) {
        for(uint64_t i{ 2 }; i &lt; n / 2; ++i) {
            if(n % i == 0) return false;
        }
        return true;
    };
    uint64_t count{ 0 };
    uint64_t start{ 2 };
    uint64_t end{ MAX_PRIME };
    for(uint64_t i{ start }; i &lt;= end ; ++i) {
        if(is_prime(i)) ++count;
   }
   return count;
}</pre></li>
			</ul>
			<p>This function counts the prime numbers between 2 and <code>0x1FFFF</code> (131,071), which should take a few seconds on most modern systems. </p>
			<ul>
				<li>Now, we write a <code>timer</code> function to time our <code>count_primes()</code>:<pre><strong class="bold">seconds</strong> timer(uint64_t(*f)()) {
    auto t1{ <strong class="bold">system_clock</strong>::now() };
    uint64_t count{ f() };
    auto t2{ <strong class="bold">system_clock</strong>::now() };
    <strong class="bold">seconds</strong> secs{ t2 - t1 };
    cout &lt;&lt; format("there are {} primes in range\n", 
      count);
    return secs;
}</pre></li>
			</ul>
			<p>This <a id="_idIndexMarker699"/>function <a id="_idIndexMarker700"/>takes an function <code>f</code> and returns <code>duration&lt;double&gt;</code>. We use <code>system_clock::now()</code> to mark the time before and after the call to <code>f()</code>. We take the difference between the two times and return it in a <code>duration</code> object.</p>
			<ul>
				<li>We can call our <code>timer()</code> from <code>main()</code>, like this:<pre>int main() {
    auto <strong class="bold">secs</strong>{ <strong class="bold">timer</strong>(<strong class="bold">count_primes</strong>) };
    cout &lt;&lt; format("time elapsed: {:.3f} seconds\n", 
        secs.<strong class="bold">count</strong>());
    ...</pre></li>
			</ul>
			<p>This passes the <code>count_primes()</code> function to <code>timer()</code> and stores the <code>duration</code> object in <code>secs</code>.</p>
			<p>Output:</p>
			<pre><strong class="bold">there are 12252 primes in range</strong>
<strong class="bold">time elapsed: 3.573 seconds</strong></pre>
			<p>The <code>count()</code> method on the <code>duration</code> object returns the duration in the specified units – in this case, <code>double</code>, representing <em class="italic">seconds</em> of duration. </p>
			<p>This was run on a VM running <em class="italic">Debian</em> with GCC. The exact time will vary on different systems.</p>
			<ul>
				<li>The <code>system_clock</code> class is designed to provide the current <em class="italic">wall clock</em> time. While its resolution may support timing purposes, it is not guaranteed to be <em class="italic">monotonic</em>. In other words, it may not always provide consistent <em class="italic">ticks</em> (timing intervals).</li>
			</ul>
			<p>The <code>chrono</code> library <a id="_idIndexMarker701"/>provides a more suitable clock<a id="_idIndexMarker702"/> in <code>steady_clock</code>. It has the same interface as <code>system_clock</code> but provides more reliable ticks for timing purposes:</p>
			<pre>seconds timer(uint64_t(*f)()) {
    auto t1{ <strong class="bold">steady_clock</strong>::now() };
    uint64_t count{ f() };
    auto t2{ <strong class="bold">steady_clock</strong>::now() };
    seconds secs{ t2 - t1 };
    cout &lt;&lt; format("there are {} primes in range\n", 
      count);
    return secs;
}</pre>
			<p><code>steady_clock</code> is designed to provide reliably consistent monotonic ticks, suitable for timing events. It uses a relative time reference, so it's not useful for wall clock time. While <code>system_clock</code> measures by beginning from a fixed point in time (1 January 1970, 00:00 UTC), <code>steady_clock</code> uses a relative time. </p>
			<p>Another option is <code>high_resolution_clock</code>, which provides the shortest tick period available on a given system but is not implemented consistently across different implementations. It may be an alias for <code>system_clock</code> or <code>steady_clock</code>, and it may or may not be monotonic. <code>high_resolution_clock</code> is not recommended for general-purpose use.</p>
			<ul>
				<li>Our <code>timer()</code> function returns <code>seconds</code>, which is an alias for <code>duration&lt;double&gt;</code>:<pre>using seconds = duration&lt;double&gt;;</pre></li>
			</ul>
			<p>The duration<a id="_idIndexMarker703"/> class takes an optional second template <a id="_idIndexMarker704"/>parameter, a <code>std::ratio</code> class:</p>
			<pre>template&lt;class Rep, class Period = std::ratio&lt;1&gt;&gt;
class duration;</pre>
			<p>The <code>&lt;chrono&gt;</code> header provides convenience types for many decimal ratios, including <code>milli</code> and <code>micro</code>:</p>
			<pre>using milliseconds = duration&lt;double, std::milli&gt;;
using microseconds = duration&lt;double, std::micro&gt;;</pre>
			<p>If we require something else, we may provide our own:</p>
			<pre>using fps24 = duration&lt;unsigned long, std::ratio&lt;1, 24&gt;&gt;;</pre>
			<p><code>fps24</code> represents the number of frames of film shot at the standard 24 frames per second. The ratio is 1/24 of a second.</p>
			<p>This allows us to easily convert between different ranges of duration:</p>
			<pre>cout &lt;&lt; format("time elapsed: {:.3f} sec\n", <strong class="bold">secs</strong>.count());
cout &lt;&lt; format("time elapsed: {:.3f} ms\n", 
    <strong class="bold">milliseconds</strong>(secs).count());
cout &lt;&lt; format("time elapsed: {:.3e} μs\n", 
    <strong class="bold">microseconds</strong>(secs).count());
cout &lt;&lt; format("time elapsed: {} frames at 24 fps\n", 
    <strong class="bold">floor</strong>&lt;<strong class="bold">fps24</strong>&gt;(secs).count());</pre>
			<p>Output:</p>
			<pre><strong class="bold">time elapsed: 3.573 sec</strong>
<strong class="bold">time elapsed: 3573.077 ms</strong>
<strong class="bold">time elapsed: 3.573e+06 μs</strong>
<strong class="bold">time elapsed: 85 frames at 24 fps</strong></pre>
			<p>Because the <code>fps24</code> alias uses <code>unsigned long</code> instead of <code>double</code>, a type conversion is required. The <code>floor</code> function provides this by discarding the fractional part. <code>round()</code> and <code>ceil()</code> are also available in this context.</p>
			<ul>
				<li>For <a id="_idIndexMarker705"/>convenience, the <code>chrono</code> library provides <code>format()</code> specializations <a id="_idIndexMarker706"/>for the standard <code>duration</code> ratios:<pre>cout &lt;&lt; format("time elapsed: {:.3}\n", secs);
cout &lt;&lt; format("time elapsed: {:.3}\n", milliseconds(secs));
cout &lt;&lt; format("time elapsed: {:.3}\n", microseconds(secs));</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">time elapsed: 3.573s</strong>
<strong class="bold">time elapsed: 3573.077ms</strong>
<strong class="bold">time elapsed: 3573076.564μs</strong></pre>
			<p>These results will vary on different implementations.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor265"/>How it works…</h2>
			<p>There are two<a id="_idIndexMarker707"/> major<a id="_idIndexMarker708"/> pieces to the <code>chrono</code> library, the <em class="italic">clock</em> classes and the <code>duration</code> class. </p>
			<h3>The clock classes</h3>
			<p>The clock <a id="_idIndexMarker709"/>classes include:</p>
			<ul>
				<li><code>system_clock</code> – provides wall clock time.</li>
				<li><code>steady_clock</code> – provides guaranteed monotonic ticks for duration measurements.</li>
				<li><code>high_resolution_clock</code> – provides the shortest available tick period. It may be an alias of <code>system_clock</code> or <code>steady_clock</code> on some systems.</li>
			</ul>
			<p>We use <code>system_clock</code> to display the current time and date. We use <code>steady_clock</code> to measure intervals. </p>
			<p>Each of the clock classes has a <code>now()</code> method that returns <code>time_point</code>, representing the current value of the clock. <code>now()</code> is a static member function, so it's called on the class without instantiating an object:</p>
			<pre>auto t1{ steady_clock::now() };</pre>
			<h3>The std::duration class</h3>
			<p>The <code>duration</code> class is<a id="_idIndexMarker710"/> used to hold a time interval – that is, the difference between two <code>time_point</code> objects. It is generally constructed with a <code>time_point</code> object's subtraction (<code>-</code>) operator. </p>
			<pre>duration&lt;double&gt; secs{ t2 - t1 };</pre>
			<p>The <code>time_point</code> subtraction operator doubles as a constructor for <code>duration</code>:</p>
			<pre>template&lt;class C, class D1, class D2&gt;
constexpr duration&lt;D1,D2&gt;
operator-( const time_point&lt;C,D1&gt;&amp; pt_lhs,
    const time_point&lt;C,D2&gt;&amp; pt_rhs );</pre>
			<p>The <code>duration</code> class has template parameters for type representation and a <code>ratio</code> object:</p>
			<pre>template&lt;class <strong class="bold">Rep</strong>, class <strong class="bold">Period</strong> = std::<strong class="bold">ratio</strong>&lt;1&gt;&gt;
class duration;</pre>
			<p>The <code>Period</code> template parameter defaults to a <code>ratio</code> of 1:1, which is seconds.</p>
			<p>The library provides <code>ratio</code> aliases (such as <code>micro</code> and <code>milli</code>) for powers-of-10 from <code>atto</code> (1/1,000,000,000,000,000,000) through <code>exa</code> (1,000,000,000,000,000,000/1). This allows us to create standard durations, as we did in our example:</p>
			<pre>using milliseconds = duration&lt;double, std::<strong class="bold">milli</strong>&gt;;
using microseconds = duration&lt;double, std::<strong class="bold">micro</strong>&gt;;</pre>
			<p>The <code>count()</code> method gives us the duration in the <code>Rep</code> type:</p>
			<pre>constexpr Rep count() const;</pre>
			<p>This allows us to <a id="_idIndexMarker711"/>easily access the duration for display or other purposes:</p>
			<pre>cout &lt;&lt; format("duration: {}\n", secs.count());</pre>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor266"/>Use fold expressions for variadic tuples</h1>
			<p>The <code>std::tuple</code> class <a id="_idIndexMarker712"/>is essentially a more <a id="_idIndexMarker713"/>complex, and<a id="_idIndexMarker714"/> less convenient, <code>struct</code>. The interface for <code>tuple</code> is cumbersome, although <em class="italic">class template argument deduction</em> and <em class="italic">structured binding</em> have made it somewhat easier. </p>
			<p>I tend to use <code>struct</code> before <code>tuple</code> for most applications, with one significant exception: the one real advantage of <code>tuple</code> is that it can be used with <em class="italic">fold expressions</em> in a variadic context.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor267"/>Fold expressions</h2>
			<p>Designed to <a id="_idIndexMarker715"/>make it easier to expand a variadic parameter pack, <em class="italic">fold expressions</em> are a new feature with C++17. Prior to fold expressions, expanding a parameter pack required a recursive function:</p>
			<pre>template&lt;typename T&gt;
void f(T final) {
    cout &lt;&lt; final &lt;&lt; '\n';
}
template&lt;typename T, typename... Args&gt;
void f(T first, Args... args) {
    cout &lt;&lt; first;
    <strong class="bold">f(args...)</strong>;
}
int main() {
    f("hello", ' ', 47, ' ', "world");
}</pre>
			<p>Output:</p>
			<pre>hello 47 world</pre>
			<p>Using a<a id="_idIndexMarker716"/> fold<a id="_idIndexMarker717"/> expression, this is much simpler:</p>
			<pre>template&lt;typename... Args&gt;
void f(Args... args) {
    <strong class="bold">(cout &lt;&lt; ... &lt;&lt; args)</strong>;
    cout &lt;&lt; '\n';
}</pre>
			<p>Output:</p>
			<pre>hello 47 world</pre>
			<p>There are four types of fold expressions:</p>
			<ul>
				<li>Unary right fold: <code>(args op ...)</code></li>
				<li>Unary left fold: <code>(... op args)</code></li>
				<li>Binary right fold: <code>(args op ... op init)</code></li>
				<li>Binary left fold: <code>(init op ... op args)</code></li>
			</ul>
			<p>The expression in the example above is a <em class="italic">binary left fold</em>:</p>
			<pre>(cout &lt;&lt; ... &lt;&lt; args);</pre>
			<p>This expands to:</p>
			<pre>cout &lt;&lt; "hello" &lt;&lt; ' ' &lt;&lt; 47 &lt;&lt; ' ' &lt;&lt; "world";</pre>
			<p>Fold expressions<a id="_idIndexMarker718"/> are a great convenience for many purposes. Let's look at how we can use them with tuples.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor268"/>How to do it…</h2>
			<p>In this recipe, we'll create a template function that operates on a tuple with varying numbers and types of elements:</p>
			<ul>
				<li>The<a id="_idIndexMarker719"/> heart <a id="_idIndexMarker720"/>of this recipe is a function that takes a tuple of unknown size and type and prints each element with <code>format()</code>:<pre>template&lt;typename... T&gt;
constexpr void print_t(const tuple&lt;T...&gt;&amp; <strong class="bold">tup</strong>) {
    auto lpt =
        [<strong class="bold">&amp;tup</strong>] <strong class="bold">&lt;size_t... I&gt;</strong> 
          (std::<strong class="bold">index_sequence</strong>&lt;I...&gt;)
            constexpr {
            (..., ( cout &lt;&lt;
                format((I? ", {}" : "{}"), 
                  <strong class="bold">get&lt;I&gt;(tup)</strong>)
            ));
            cout &lt;&lt; '\n';
        };
    lpt(std::<strong class="bold">make_index_sequence</strong>&lt;sizeof...(T)&gt;());
}</pre></li>
			</ul>
			<p>The heart of this function is in the lambda expression. It uses the <code>index_sequence</code> object to generate a parameter pack of index values. We then use a fold expression to call <code>get&lt;I&gt;</code> with each index value. The templated lambda requires C++20.  </p>
			<p>You could use a separate function in place of the lambda, but I like keeping it in a single scope.</p>
			<ul>
				<li>We <a id="_idIndexMarker721"/>can<a id="_idIndexMarker722"/> now call this from <code>main()</code> with a variety of tuples:<pre>int main() {
    tuple lables{ "ID", "Name", "Scale" };
    tuple employee{ 123456, "John Doe", 3.7 };
    tuple nums{ 1, 7, "forty-two", 47, 73L, -111.11 };
    
    print_t(lables);
    print_t(employee);
    print_t(nums);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">ID, Name, Scale</strong>
<strong class="bold">123456, John Doe, 3.7</strong>
<strong class="bold">1, 7, forty-two, 47, 73, -111.11</strong></pre>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor269"/>How it works…</h2>
			<p>The challenge with <code>tuple</code> is its restrictive interface. You can retrieve elements with <code>std::tie()</code>, with <em class="italic">structured bindings</em>, or the <code>std::get&lt;&gt;</code> function. None of these techniques are useful if you don't know the number and type of elements in the <code>tuple</code>. </p>
			<p>We get around this limitation by using the <code>index_sequence</code> class. <code>index_sequence</code> is a specialization of <code>integer_sequence</code> that provides a parameter pack of the <code>size_t</code> elements, which we can use to index our <code>tuple</code>. We call our lambda function with <code>make_index_sequence</code> to set up a parameter pack in the lambda:</p>
			<pre>lpt(std::make_index_sequence&lt;sizeof...(T)&gt;());</pre>
			<p>The templated lambda is constructed with a parameter pack of <code>size_t</code> indexes for the <code>get()</code> function: </p>
			<pre>[&amp;tup] &lt;size_t... I&gt; (std::index_sequence&lt;I...&gt;) constexpr {
   ...
};</pre>
			<p>The <code>get()</code> function <a id="_idIndexMarker723"/>takes the index value as a template <a id="_idIndexMarker724"/>parameter. We use a <em class="italic">unary left fold expression</em> to call <code>get&lt;I&gt;()</code>:</p>
			<pre>(...<strong class="bold">,</strong> ( cout &lt;&lt; format("{} ", std::get&lt;<strong class="bold">I</strong>&gt;(tup))));</pre>
			<p>The fold expression takes each element of the function's parameter pack and applies the comma operator. The right-hand side of the comma has a <code>format()</code> function that prints each element of the tuple. </p>
			<p>This makes it possible to deduce the number of elements in the tuple, which makes it useable in a variadic context. Keep in mind that, as with template functions in general, the compiler will generate a separate specialization of this function for each combination of <code>tuple</code> parameters.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor270"/>There's more…</h2>
			<p>We can use this technique for other tasks. For example, here's a function that returns the sum of all the <code>int</code> values in a <code>tuple</code> of unknown size:</p>
			<pre>template&lt;typename... T&gt;
constexpr int sum_t(const tuple&lt;T...&gt;&amp; tup) {
    int accum{};
    auto lpt =
        [&amp;tup, &amp;accum] &lt;size_t... I&gt; 
          (std::index_sequence&lt;I...&gt;) 
        constexpr {
            (..., ( 
                accum += get&lt;I&gt;(tup)
            ));
        };
    lpt(std::make_index_sequence&lt;sizeof...(T)&gt;());
    return accum;
}</pre>
			<p>We can call this with several <code>tuple</code> objects of varying numbers of <code>int</code> values:</p>
			<pre>tuple ti1{ 1, 2, 3, 4, 5 };
tuple ti2{ 9, 10, 11, 12, 13, 14, 15 };
tuple ti3{ 47, 73, 42 };
auto sum1{ sum_t(ti1) };
auto sum2{ sum_t(ti2) };
auto sum3{ sum_t(ti3) };
cout &lt;&lt; format("sum of ti1: {}\n", sum1);
cout &lt;&lt; format("sum of ti2: {}\n", sum2);
cout &lt;&lt; format("sum of ti3: {}\n", sum3);</pre>
			<p>Output:</p>
			<pre>sum of ti1: 15
sum of ti2: 84
sum of ti3: 162</pre>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor271"/>Manage allocated memory with std::unique_ptr</h1>
			<p><em class="italic">Smart pointers</em> are an <a id="_idIndexMarker725"/>excellent tool<a id="_idIndexMarker726"/> for managing allocated <em class="italic">heap memory</em>. </p>
			<p>Heap memory is managed at the lowest level by the C functions, <code>malloc()</code> and <code>free()</code>. <code>malloc()</code> allocates a block of memory from the heap, and <code>free()</code> returns it to the heap. These functions do not perform initialization and do not call constructors or destructors. If you fail to return allocated memory to the heap with a call to <code>free()</code>, the behavior is undefined and often leads to memory leaks and security vulnerabilities.</p>
			<p>C++ provides the <code>new</code> and <code>delete</code> operators to allocate and free heap memory, in place of <code>malloc()</code> and <code>free()</code>. The <code>new</code> and <code>delete</code> operators call object constructors and destructors but still do not manage memory. If you allocate memory with <code>new</code> and fail to free it with <code>delete</code>, you will leak memory.</p>
			<p>Introduced <a id="_idIndexMarker727"/>with C++14, smart pointers comply with the <strong class="bold">Resource Acquisition Is Initialization</strong> (<strong class="bold">RAII</strong>) idiom. This means that when memory is allocated for an object, that object's constructor is called. And when the object's destructor is called, the memory is automatically returned to the heap. </p>
			<p>For example, when we create a new smart pointer with <code>make_unique()</code>:</p>
			<pre>{   // beginning of scope
    auto p = <strong class="bold">make_unique&lt;Thing&gt;()</strong>; // memory alloc’d,
                                   // ctor called
    process_thing(p);   // p is unique_ptr&lt;Thing&gt;
}   // end of scope, dtor called, memory freed</pre>
			<p><code>make_unique()</code> allocates memory for a <code>Thing</code> object, calls the <code>Thing</code> default constructor, constructs a <code>unique_ptr&lt;Thing&gt;</code> object, and returns the <code>unique_ptr</code>. When <code>p</code> goes out of scope, the <code>Thing</code> destructor is called, and the memory is automatically returned to the heap.</p>
			<p>Aside from the memory management, a smart pointer works very much like a primitive pointer:</p>
			<pre>auto x = *p;  // *p derefs the pointer, returns Thing object
auto y = p-&gt;thname; // p-&gt; derefs the pointer, returns member</pre>
			<p><code>unique_ptr</code> is a <a id="_idIndexMarker728"/>smart pointer that allows <a id="_idIndexMarker729"/>only one instance of the pointer. It may be moved, but it may not be copied. Let's take a closer look at how to use <code>unique_ptr</code>.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor272"/>How to do it…</h2>
			<p>In this recipe, we examine <code>std::unique_ptr</code> with a demonstration class that prints when its constructors and destructor are called:</p>
			<ul>
				<li>First, we'll create a simple demonstration class:<pre>struct Thing {
    string_view thname{ "unk" };
    Thing() {
        <strong class="bold">cout</strong> &lt;&lt; format("default ctor: {}\n", thname);
    }
    Thing(const string_view&amp; n) : thname(n) {
        <strong class="bold">cout</strong> &lt;&lt; format("param ctor: {}\n", thname);
    }
    ~Thing() {
        <strong class="bold">cout</strong> &lt;&lt; format("dtor: {}\n", thname);
    }
};</pre></li>
			</ul>
			<p>This class has a default constructor, a parameterized constructor, and a destructor. Each of these has a simple print statement to tell us what was called.</p>
			<ul>
				<li>When <a id="_idIndexMarker730"/>we <a id="_idIndexMarker731"/>just construct a <code>unique_ptr</code>, it does not allocate memory or construct a managed object:<pre>int main() {
    <strong class="bold">unique_ptr&lt;Thing&gt;</strong> p1;
    cout &lt;&lt; "end of main()\n";
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">end of main()</strong></pre>
			<ul>
				<li>When we use the <code>new</code> operator, it allocates memory and constructs a <code>Thing</code> object:<pre>int main() {
    <strong class="bold">unique_ptr&lt;Thing&gt;</strong> p1{ <strong class="bold">new</strong> Thing };
    cout &lt;&lt; "end of main()\n";
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">default ctor: unk</strong>
<strong class="bold">end of main()</strong>
<strong class="bold">dtor: unk</strong></pre>
			<p>The <code>new</code> operator constructs a <code>Thing</code> object by calling the default constructor. The <code>unique_ptr&lt;Thing&gt;</code> destructor calls the <code>Thing</code> destructor when the smart pointer reaches the end of its scope.</p>
			<p>The <code>Thing</code> default constructor does not initialize the <code>thname</code> string, leaving its default value, <code>"unk"</code>. </p>
			<ul>
				<li>We<a id="_idIndexMarker732"/> can<a id="_idIndexMarker733"/> use <code>make_unique()</code> to get the same result:<pre>int main() {
    auto p1 = <strong class="bold">make_unique&lt;Thing&gt;</strong>();
    cout &lt;&lt; "end of main()\n";
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">default ctor: unk</strong>
<strong class="bold">end of main()</strong>
<strong class="bold">dtor: unk</strong></pre>
			<p>The <code>make_unique()</code> helper function takes care of the memory allocation and returns a <code>unique_ptr</code> object. This is the recommended way to construct a <code>unique_ptr</code>. </p>
			<ul>
				<li>Any arguments you pass to <code>make_unique()</code> are used in constructing the target object:<pre>int main() {
    auto p1 = make_unique&lt;Thing&gt;(<strong class="bold">"Thing 1"</strong>) };
    cout &lt;&lt; "end of main()\n";
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">param ctor: Thing 1</strong>
<strong class="bold">end of main()</strong>
<strong class="bold">dtor: Thing 1</strong></pre>
			<p>The parameterized constructor assigns a value to <code>thname</code>, so our <code>Thing</code> object is now <code>"Thing 1"</code>.</p>
			<ul>
				<li>Let's write a function that takes a <code>unique_ptr&lt;Thing&gt;</code> argument:<pre>void process_thing(<strong class="bold">unique_ptr&lt;Thing&gt;</strong> p) {
    if(p) cout &lt;&lt; format("processing: {}\n", 
      p-&gt;thname);
    else cout &lt;&lt; "invalid pointer\n";
}</pre></li>
			</ul>
			<p>If we<a id="_idIndexMarker734"/> try <a id="_idIndexMarker735"/>to pass a <code>unique_ptr</code> to this function, we get a compiler error:</p>
			<pre>process_thing(p1);</pre>
			<p>Compiler error:</p>
			<pre><strong class="bold">error: use of deleted function...</strong></pre>
			<p>This is because the function call tries to make a copy of the <code>unique_ptr</code> object, but the <code>unique_ptr</code> copy constructor is <em class="italic">deleted</em> to prevent copying. The solution is to have the function take a <code>const&amp;</code> reference:</p>
			<pre>void process_thing(<strong class="bold">const unique_ptr&lt;Thing&gt;&amp;</strong> p) {
    if(p) cout &lt;&lt; format("processing: {}\n", 
      p-&gt;thname);
    else cout &lt;&lt; "invalid pointer\n";
}</pre>
			<p>Output:</p>
			<pre><strong class="bold">param ctor: Thing 1</strong>
<strong class="bold">processing: Thing 1</strong>
<strong class="bold">end of main()</strong>
<strong class="bold">dtor: Thing 1</strong></pre>
			<ul>
				<li>We can call <code>process_thing()</code> with a temporary object, which is immediately <a id="_idIndexMarker736"/>destroyed at the end<a id="_idIndexMarker737"/> of the function scope:<pre>int main() {
    auto p1{ make_unique&lt;Thing&gt;("Thing 1") };
    process_thing(p1);
    <strong class="bold">process_thing(make_unique&lt;Thing&gt;("Thing 2"));</strong>
    cout &lt;&lt; "end of main()\n";
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre>param ctor: Thing 1
processing: Thing 1
<strong class="bold">param ctor: Thing 2</strong>
<strong class="bold">processing: Thing 2</strong>
<strong class="bold">dtor: Thing 2</strong>
end of main()
dtor: Thing 1</pre>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor273"/>How it works…</h2>
			<p>A <em class="italic">smart pointer</em> is simply an object that presents a pointer interface while owning and managing the resources of another object.</p>
			<p>The <code>unique_ptr</code> class is distinguished by its deleted copy constructor and copy assignment operator, which prevents the smart pointer from being copied.</p>
			<p>You may not copy a <code>unique_ptr</code>:</p>
			<pre>auto p2 = p1;</pre>
			<p>Compiler error:</p>
			<pre>error: use of deleted function...</pre>
			<p>But <a id="_idIndexMarker738"/>you<a id="_idIndexMarker739"/> can move a <code>unique_ptr</code>:</p>
			<pre>auto p2 = std::move(p1);
process_thing(p1);
process_thing(p2);</pre>
			<p>After the <code>move</code>, <code>p1</code> is invalid and <code>p2</code> is <code>"Thing 1"</code>.</p>
			<p>Output:</p>
			<pre>invalid pointer
processing: Thing 1
end of main()
dtor: Thing 1</pre>
			<p>The <code>unique_ptr</code> interface has a method to reset a pointer:</p>
			<pre>p1.reset();  // pointer is now invalid
process_thing(p1);</pre>
			<p>Output:</p>
			<pre>dtor: Thing 1
invalid pointer</pre>
			<p>The <code>reset()</code> method may also be used to replace the managed object with another of the<a id="_idIndexMarker740"/> same<a id="_idIndexMarker741"/> type:</p>
			<pre>p1.reset(new Thing("Thing 3"));
process_thing(p1);</pre>
			<p>Output:</p>
			<pre>param ctor: Thing 3
dtor: Thing 1
processing: Thing 3</pre>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor274"/>Share objects with std::shared_ptr</h1>
			<p>The <code>std::shared_ptr</code> class is <a id="_idIndexMarker742"/>a smart pointer<a id="_idIndexMarker743"/> that owns its managed object and maintains a <em class="italic">use counter</em> to keep track of copies. This recipe explores the use of <code>shared_ptr</code> to manage memory while sharing copies of the pointer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more detail about smart pointers, see the introduction to the <em class="italic">Manage allocated memory with std::unique_ptr</em> recipe earlier in this chapter.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor275"/>How to do it…</h2>
			<p>In this recipe, we examine <code>std::shared_ptr</code> with a demonstration class that prints when its constructors and destructor are called:</p>
			<ul>
				<li>First, we create a simple demonstration class:<pre>struct Thing {
    string_view thname{ "unk" };
    Thing() {
        <strong class="bold">cout</strong> &lt;&lt; format("default ctor: {}\n", thname);
    }
    Thing(const string_view&amp; n) : thname(n) {
        <strong class="bold">cout</strong> &lt;&lt; format("param ctor: {}\n", thname);
    }
    ~Thing() {
        <strong class="bold">cout</strong> &lt;&lt; format("dtor: {}\n", thname);
    }
};</pre></li>
			</ul>
			<p>This class has a default constructor, a parameterized constructor, and a destructor. Each<a id="_idIndexMarker744"/> of these has a simple print <a id="_idIndexMarker745"/>statement to tell us what was called.</p>
			<ul>
				<li>The <code>shared_ptr</code> class works very much like other smart pointers, in that it may be constructed with the <code>new</code> operator or with its helper, the <code>make_shared()</code> function:<pre>int main() {
    shared_ptr&lt;Thing&gt; p1{ new Thing("Thing 1") };
    auto p2 = make_shared&lt;Thing&gt;("Thing 2");
    cout &lt;&lt; "end of main()\n";
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">param ctor: Thing 1</strong>
<strong class="bold">param ctor: Thing 2</strong>
<strong class="bold">end of main()</strong>
<strong class="bold">dtor: Thing 2</strong>
<strong class="bold">dtor: Thing 1</strong></pre>
			<p>The <code>make_shared()</code> function is recommended, as it manages the construction process and is less prone to error.</p>
			<p>As with the other smart pointers, the managed object is destroyed, and its memory is returned to the heap when the pointer goes out of scope.</p>
			<ul>
				<li>Here's a function to check the use count of a <code>shared_ptr</code> object:<pre>void check_thing_ptr(const shared_ptr&lt;Thing&gt;&amp; p) {
    if(p) cout &lt;&lt; format("{} use count: {}\n", 
        <strong class="bold">p-&gt;thname</strong>, <strong class="bold">p.use_count()</strong>);
    else cout &lt;&lt; "invalid pointer\n";
}</pre></li>
			</ul>
			<p><code>thname</code> is a member <a id="_idIndexMarker746"/>of the <code>Thing</code> class, so we<a id="_idIndexMarker747"/> access it through the pointer with the <code>p-&gt;</code> member dereference operator. The <code>use_count()</code> function is a member of the <code>shared_ptr</code> class, so we access it with the <code>p.</code> object member operator. </p>
			<p>Let's call this with our pointers:</p>
			<pre>check_thing_ptr(p1);
check_thing_ptr(p2);</pre>
			<p>Output:</p>
			<pre><strong class="bold">Thing 1 use count: 1</strong>
<strong class="bold">Thing 2 use count: 1</strong></pre>
			<ul>
				<li>When we make copies of our pointers, the use count increases, but no new objects are constructed:<pre>cout &lt;&lt; "make 4 copies of p1:\n";
auto pa = p1;
auto pb = p1;
auto pc = p1;
auto pd = p1;
check_thing_ptr(p1);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">make 4 copies of p1:</strong>
<strong class="bold">Thing 1 use count: 5</strong></pre>
			<ul>
				<li>When <a id="_idIndexMarker748"/>we <a id="_idIndexMarker749"/>check any of the other copies, we get the same result:<pre>check_thing_ptr(pa);
check_thing_ptr(pb);
check_thing_ptr(pc);
check_thing_ptr(pd);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Thing 1 use count: 5</strong>
<strong class="bold">Thing 1 use count: 5</strong>
<strong class="bold">Thing 1 use count: 5</strong>
<strong class="bold">Thing 1 use count: 5</strong></pre>
			<p>Each pointer reports the same use count. </p>
			<ul>
				<li>When the copies go out of scope, they are destroyed, and the use count is decremented:<pre>{   // new scope
    cout &lt;&lt; "make 4 copies of p1:\n";
    auto pa = p1;
    auto pb = p1;
    auto pc = p1;
    auto pd = p1;
    check_thing_ptr(p1);
}   // end of scope
check_thing_ptr(p1);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">make 4 copies of p1:</strong>
<strong class="bold">Thing 1 use count: 5</strong>
<strong class="bold">Thing 1 use count: 1</strong></pre>
			<ul>
				<li>Destroying<a id="_idIndexMarker750"/> a<a id="_idIndexMarker751"/> copy reduces the use count but does not destroy the managed object. The object is destroyed when the final copy goes out of scope and the use count reaches zero:<pre>{    
    cout &lt;&lt; "make 4 copies of p1:\n";
    auto pa = p1;
    auto pb = p1;
    auto pc = p1;
    auto pd = p1;
    check_thing_ptr(p1);
    pb.reset();
    p1.reset();
    check_thing_ptr(pd);
}   // end of scope</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">make 4 copies of p1:</strong>
<strong class="bold">Thing 1 use count: 5</strong>
<strong class="bold">Thing 1 use count: 3</strong>
<strong class="bold">dtor: Thing 1</strong></pre>
			<p>Destroying <code>pb</code> (a copy) and <code>p1</code> (the original) leaves three copies of the pointer (<code>pa</code>, <code>bc</code>, and <code>pd</code>), so the managed object remains.</p>
			<p>The remaining three pointer copies are destroyed at the end of the scope in which they were created. Then the object is destroyed and its memory returned to the heap.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor276"/>How it works…</h2>
			<p>The <code>shared_ptr</code> class is distinguished by its management of multiple pointers to the same managed object. </p>
			<p>The <code>shared_ptr</code> object's copy constructor and copy assignment operator increment a <em class="italic">use counter</em>. The destructor decrements the use counter until it reaches zero, then destroys the managed object, and returns its memory to the heap.</p>
			<p>The <code>shared_ptr</code> class manages both the managed object and a heap-allocated <em class="italic">control block</em>. The <a id="_idIndexMarker752"/>control block contains the use<a id="_idIndexMarker753"/> counter, along with other housekeeping objects. The control block is managed and shared between copies along with the managed object. This allows the original <code>shared_ptr</code> object to cede control to its copies, so that the last remaining <code>shared_ptr</code> may manage the object and its memory.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor277"/>Use weak pointers with shared objects</h1>
			<p>Strictly<a id="_idIndexMarker754"/> speaking, <code>std::weak_ptr</code> is not a smart<a id="_idIndexMarker755"/> pointer. Rather, it's an <em class="italic">observer</em> that operates in cooperation with <code>shared_ptr</code>. A <code>weak_ptr</code> object does not hold a pointer on its own.</p>
			<p>There are circumstances where <code>shared_ptr</code> objects may create dangling pointers or race conditions, which could lead to memory leaks or other problems. The solution is to use <code>weak_ptr</code> objects with <code>shared_ptr</code>. </p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor278"/>How to do it…</h2>
			<p>In this recipe, we examine the use of <code>std::weak_ptr</code> with <code>std::shared_ptr</code>, using a demonstration class that prints when its constructors and destructor are called.</p>
			<ul>
				<li>We start <a id="_idIndexMarker756"/>with <a id="_idIndexMarker757"/>the same class we've used to demonstrate <code>shared_ptr</code> and <code>unique_ptr</code>:<pre>struct Thing {
    string_view thname{ "unk" };
    Thing() {
        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">default ctor:</strong> {}\n", thname);
    }
    Thing(const string_view&amp; n) : thname(n) {
        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">param ctor:</strong> {}\n", thname);
    }
    ~Thing() {
        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">dtor:</strong> {}\n", thname);
    }
};</pre></li>
			</ul>
			<p>This class has a default constructor, a parameterized constructor, and a destructor. Each of these has a simple print statement to tell us what was called.</p>
			<ul>
				<li>We also need a function to examine a <code>weak_ptr</code> object:<pre>void <strong class="bold">get_weak_thing</strong>(const <strong class="bold">weak_ptr&lt;Thing&gt;&amp;</strong> p) {
    if(<strong class="bold">auto</strong> sp = <strong class="bold">p.lock()</strong>) cout &lt;&lt; 
        format("{}: count {}\n", sp-&gt;thname, 
          p.use_count());
    else cout &lt;&lt; "no shared object\n";
}</pre></li>
			</ul>
			<p>A <code>weak_ptr</code> does not operate as a pointer on its own; it requires the use of a <code>shared_ptr</code>. The <code>lock()</code> function returns a <code>shared_ptr</code> object, which can then be used to access the managed object.</p>
			<ul>
				<li>Because <code>weak_ptr</code> requires an associated <code>shared_ptr</code>, we'll start <code>main()</code> by<a id="_idIndexMarker758"/> creating a <code>shared_ptr&lt;Thing&gt;</code> object. When<a id="_idIndexMarker759"/> we create a <code>weak_ptr</code> object without assigning the <code>shared_ptr</code>, the <code>expired</code> flag is initially set:<pre>int main() {
    auto <strong class="bold">thing1</strong> = <strong class="bold">make_shared&lt;Thing&gt;</strong>("Thing 1");
    <strong class="bold">weak_ptr&lt;Thing&gt;</strong> wp1;
    cout &lt;&lt; format("expired: {}\n", <strong class="bold">wp1.expired()</strong>);
    get_weak_thing(wp1);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">param ctor: Thing 1</strong>
<strong class="bold">expired: true</strong>
<strong class="bold">no shared object</strong></pre>
			<p>The <code>make_shared()</code> function allocates memory and constructs a <code>Thing</code> object.</p>
			<p>The <code>weak_ptr&lt;Thing&gt;</code> declaration constructs a <code>weak_ptr</code> object without assigning a <code>shared_ptr</code>. So, when we check the <code>expired</code> flag, it's <code>true</code>, indicating that there is no associated <code>shared_ptr</code>.</p>
			<p>The <code>get_weak_thing()</code> function is not able to obtain a lock because there is no <code>shared_ptr</code> available.</p>
			<ul>
				<li>When we<a id="_idIndexMarker760"/> assign the <code>shared_ptr</code> to the <code>weak_ptr</code>, we can use the <code>weak_ptr</code> to <a id="_idIndexMarker761"/>access the managed object:<pre>wp1 = thing1;
get_weak_thing(wp1);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Thing 1: count 2</strong></pre>
			<p>The <code>get_weak_thing()</code> function is now able to obtain a lock and access the managed object. The <code>lock()</code> method returns a <code>shared_ptr</code>, and the <code>use_count()</code> reflects the fact that there is now a second <code>shared_ptr</code> managing the <code>Thing</code> object.</p>
			<p>The new <code>shared_ptr</code> is destroyed at the end of the <code>get_weak_thing()</code> scope. </p>
			<ul>
				<li>The <code>weak_ptr</code> class has a constructor that takes a <code>shared_ptr</code> for one-step construction:<pre>weak_ptr&lt;Thing&gt; wp2(<strong class="bold">thing1</strong>);
get_weak_thing(wp2);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Thing 1: count 2</strong></pre>
			<p>The <code>use_count()</code> is <code>2</code> again. Remember that the previous <code>shared_ptr</code> was destroyed when its enclosing <code>get_weak_thing()</code> scope ended.</p>
			<ul>
				<li>When we reset <code>shared_ptr</code>, its associated <code>weak_ptr</code> objects are expired:<pre>thing1.<strong class="bold">reset</strong>();
get_weak_thing(<strong class="bold">wp1</strong>);
get_weak_thing(<strong class="bold">wp2</strong>);</pre></li>
			</ul>
			<p>Output:</p>
			<pre>dtor: Thing 1
no shared object
no shared object</pre>
			<p>After the <code>reset()</code>, the use count reaches zero, and the managed object is destroyed and the memory released.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor279"/>How it works…</h2>
			<p>A <code>weak_ptr</code> object is an <em class="italic">observer</em> that holds a non-owning reference to a <code>shared_ptr</code> object. The <code>weak_ptr</code> observes the <code>shared_ptr</code> so that it knows when the<a id="_idIndexMarker762"/> managed<a id="_idIndexMarker763"/> object is, and is not, available. This allows use of a <code>shared_ptr</code> in circumstances where you may not always know if the managed object is active. </p>
			<p>The <code>weak_ptr</code> class has a <code>use_count()</code> function that returns the use count of <code>shared_ptr</code>, or <code>0</code> if the managed object has been deleted:</p>
			<pre>long use_count() const noexcept;</pre>
			<p><code>weak_ptr</code> also has an <code>expired()</code> function that reports if the managed object has been deleted:</p>
			<pre>bool expired() const noexcept;</pre>
			<p>The <code>lock()</code> function is the preferred way to access the shared pointer. It checks <code>expired()</code> to see if the managed object is available. If so, it returns a new <code>shared_ptr</code> that shares ownership with the managed object. Otherwise, it returns an empty <code>shared_ptr</code>. It does all that as one atomic operation:</p>
			<pre>std::shared_ptr&lt;T&gt; lock() const noexcept;</pre>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor280"/>There's more…</h2>
			<p>One important <a id="_idIndexMarker764"/>use case for <code>weak_ptr</code> is when there's a possibility of circular references to <code>shared_ptr</code> objects. For example, consider the case of two classes that link to each other (perhaps in a hierarchy):</p>
			<pre>struct circB;
struct circA {
    <strong class="bold">shared_ptr&lt;circB&gt;</strong> p;
    ~circA() { <strong class="bold">cout &lt;&lt; "dtor A\n";</strong> }
};
struct circB {
    <strong class="bold">shared_ptr&lt;circA&gt;</strong> p;
    ~circB() { <strong class="bold">cout &lt;&lt; "dtor B\n";</strong> }
};</pre>
			<p>We have print statements in the destructors, so we can see when the objects are destroyed. We can now create two objects that point at each other with <code>shared_ptr</code>:</p>
			<pre>int main() {
    auto a{ <strong class="bold">make_shared&lt;circA&gt;</strong>() };
    auto b{ <strong class="bold">make_shared&lt;circB&gt;</strong>() };
    <strong class="bold">a-&gt;p = b</strong>;
    <strong class="bold">b-&gt;p = a</strong>;
    cout &lt;&lt; "end of main()\n";
}</pre>
			<p>When we run this, notice that the destructors are never called:</p>
			<pre>end of main()</pre>
			<p>Because the objects maintain shared pointers that refer to each other, the use counts never reach zero, and the managed objects are never destroyed. </p>
			<p>We can resolve this problem by changing one of the classes to use a <code>weak_ptr</code>:</p>
			<pre>struct circB {
    <strong class="bold">weak_ptr&lt;circA&gt;</strong> p;
    ~circB() { cout &lt;&lt; "dtor B\n"; }
};</pre>
			<p>The code in <code>main()</code> remains the same, and we get this output:</p>
			<pre>end of main()
dtor A
dtor B</pre>
			<p>By changing one <code>shared_ptr</code> to a <code>weak_ptr</code>, we have resolved the circular reference, and <a id="_idIndexMarker765"/>the objects are now properly destroyed at the end of their scope. </p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor281"/>Share members of a managed object</h1>
			<p>The <code>std::shared_ptr</code> class<a id="_idIndexMarker766"/> provides an <em class="italic">aliasing constructor</em> to <a id="_idIndexMarker767"/>share a pointer managed<a id="_idIndexMarker768"/> by another unrelated pointer:</p>
			<pre>shared_ptr( shared_ptr&lt;Y&gt;&amp;&amp; <strong class="bold">ref</strong>, element_type* <strong class="bold">ptr</strong> ) noexcept;</pre>
			<p>This returns an aliased <code>shared_ptr</code> object that uses the resources of <code>ref</code> but returns a pointer to <code>ptr</code>. The <code>use_count</code> is shared with ref. The deleter is shared with <code>ref</code>. But <code>get()</code> returns <code>ptr</code>. This allows us to share a member of a managed object without sharing the entire object, and without allowing the entire object to be deleted while we're still using the member.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor282"/>How to do it…</h2>
			<p>In this recipe, we create a managed object and share members of that object:</p>
			<ul>
				<li>We start with a class for the managed object:<pre>struct animal {
    <strong class="bold">string name{};</strong>
    <strong class="bold">string sound{};</strong>
    animal(const string&amp; n, const string&amp; a)
            : <strong class="bold">name{n}</strong>, <strong class="bold">sound{a}</strong> {
        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">ctor:</strong> {}\n", name);
    }
    ~animal() {
        <strong class="bold">cout</strong> &lt;&lt; format("<strong class="bold">dtor:</strong> {}\n", name);
    }
};</pre></li>
			</ul>
			<p>This class <a id="_idIndexMarker769"/>has<a id="_idIndexMarker770"/> two members, <code>string</code> types for <code>name</code> and <code>sound</code> of the <code>animal</code> object. We also have print statements for the constructor and the destructor. </p>
			<ul>
				<li>Now, we need a function to create an animal but only share its name and sound:<pre>auto make_animal(const string&amp; n, const string&amp; s) {
    auto ap = make_shared&lt;animal&gt;(n, s);
    auto np = shared_ptr&lt;string&gt;(ap, &amp;ap-&gt;name);
    auto sp = shared_ptr&lt;string&gt;(ap, &amp;ap-&gt;sound);
    return tuple(np, sp);
}</pre></li>
			</ul>
			<p>This function creates <code>shared_ptr</code> with an <code>animal</code> object, constructed with a name and a sound. We then create aliased <code>shared_ptr</code> objects for the name and sound. When we return the <code>name</code> and <code>sound</code> pointers, the <code>animal</code> pointer goes out of scope. It is not deleted because the aliased pointers keep the use count from reaching zero.</p>
			<ul>
				<li>In our <code>main()</code> function, we call <code>make_animal()</code> and inspect the results:<pre>int main() {
    auto [name, sound] =
        make_animal("Velociraptor", "Grrrr!");
    cout &lt;&lt; format("The {} says {}\n", *name, *sound);
    cout &lt;&lt; format("Use count: name {}, sound {}\n", 
        name.use_count(), sound.use_count()); 
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">ctor: Velociraptor</strong>
<strong class="bold">The Velociraptor says Grrrr!</strong>
<strong class="bold">Use count: name 2, sound 2</strong>
<strong class="bold">dtor: Velociraptor</strong></pre>
			<p>We can see<a id="_idIndexMarker771"/> that<a id="_idIndexMarker772"/> the aliased pointers each show a <code>use_count</code> of <code>2</code>. When the <code>make_animal()</code> function creates the aliased pointers, they each increase the use count of the <code>animal</code> pointer. When the function ends, the <code>animal</code> pointer goes out of scope, leaving its use count at 2, which is reflected in the aliased pointers. The aliased pointers go out of scope at the end of <code>main()</code>, which allows the <code>animal</code> pointer to be destroyed. </p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor283"/>How it works…</h2>
			<p>The <em class="italic">aliased</em> shared pointer seems a bit abstract, but it's simpler than it appears. </p>
			<p>A shared pointer uses a <em class="italic">control block</em> to manage its resources. One control block is associated with one managed object and is shared among the pointers that share that object. The control block generally contains:</p>
			<ul>
				<li>A pointer to the managed object</li>
				<li>The <em class="italic">deleter</em></li>
				<li>The <em class="italic">allocator</em></li>
				<li>The number of <code>shared_ptr</code> objects that own the managed object (this is the <em class="italic">use count</em>)</li>
				<li>The number of <code>weak_ptr</code> objects that refer to the managed object</li>
			</ul>
			<p>In the case of an aliased shared pointer, the control block includes the pointer to the <em class="italic">aliased object</em>. Everything else remains the same.</p>
			<p>Aliased shared pointers participate in the use count, just like non-aliased shared pointers, preventing<a id="_idIndexMarker773"/> the managed object from being <a id="_idIndexMarker774"/>destroyed until the use count reaches zero. The deleter is not changed, so it destroys the managed object.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is possible to use any pointer to construct an aliased shared pointer. Usually, the pointer refers to a member within the aliased object. If the aliased pointer does not refer to an element of the managed object, you will need to manage its construction and destruction separately.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor284"/>Compare random number engines</h1>
			<p>The <code>random</code> library <a id="_idIndexMarker775"/>provides a selection of random number generators, each with different strategies and properties. In this recipe, we examine a function to compare the different options by creating a histogram of their output.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor285"/>How to do it…</h2>
			<p>In this recipe, we compare the different random number generators provided by the C++ <code>random</code> library:</p>
			<ul>
				<li>We start with some constants to provide uniform parameters for the random number generators:<pre>constexpr size_t <strong class="bold">n_samples</strong>{ 1000 };
constexpr size_t <strong class="bold">n_partitions</strong>{ 10 };
constexpr size_t <strong class="bold">n_max</strong>{ 50 };</pre></li>
			</ul>
			<p><code>n_samples</code> is the number of samples to examine, <code>n_partitions</code> is the number of partitions in which to display the samples, and <code>n_max</code> is the maximum size of a bar in the histogram (this will vary some due to rounding). </p>
			<p>These numbers provide a reasonable display of the differences between the engines. Increasing the ratio of <em class="italic">samples</em> versus <em class="italic">partitions</em> tends to smooth out the curves<a id="_idIndexMarker776"/> and obscure the differences between the engines.</p>
			<ul>
				<li>This is the function that collects random number samples and displays a histogram:<pre>template &lt;typename RNG&gt;
void <strong class="bold">histogram</strong>(const string_view&amp; rng_name) {
    auto p_ratio = (double)RNG::max() / n_partitions;
    RNG <strong class="bold">rng{}</strong>;  // construct the engine object
    // collect the samples
    <strong class="bold">vector&lt;size_t&gt; v</strong>(n_partitions);
    for(size_t i{}; i &lt; n_samples; ++i) {
        <strong class="bold">++v[rng() / p_ratio];</strong>
    }
    // display the histogram
    auto max_el = std::max_element(v.begin(), 
      v.end());
    auto v_ratio = *max_el / n_max;
    if(v_ratio &lt; 1) v_ratio = 1;
    cout &lt;&lt; format("engine: {}\n", rng_name);
    for(size_t i{}; i &lt; n_partitions; ++i) {
        cout &lt;&lt; format("<strong class="bold">{:02}:{:*&lt;{}}</strong>\n",
            i + 1, ' ', v[i] / v_ratio);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>In a nutshell, this<a id="_idIndexMarker777"/> function stores a histogram of collected samples in a <code>vector</code>. It then displays the histogram as a series of asterisks on the console.</p>
			<ul>
				<li>We call <code>histogram()</code> from <code>main()</code>, like this:<pre>int main() {
    histogram&lt;std::random_device&gt;("random_device");
    histogram&lt;std::default_random_engine&gt;
        ("default_random_engine");
    histogram&lt;std::minstd_rand0&gt;("minstd_rand0");
    histogram&lt;std::minstd_rand&gt;("minstd_rand");
    histogram&lt;std::mt19937&gt;("mt19937");
    histogram&lt;std::mt19937_64&gt;("mt19937_64");
    histogram&lt;std::ranlux24_base&gt;("ranlux24_base");
    histogram&lt;std::ranlux48_base&gt;("ranlux48_base");
    histogram&lt;std::ranlux24&gt;("ranlux24");
    histogram&lt;std::ranlux48&gt;("ranlux48");
    histogram&lt;std::knuth_b&gt;("knuth_b");
}</pre></li>
			</ul>
			<p>Output:</p>
			<div><div><img src="img/B18267_08_01.jpg" alt="Figure 8.1 – A screenshot of output from the first two random number engines&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – A screenshot of output from the first two random number engines</p>
			<p>This screenshot shows histograms of the first two random number engines. Your output will vary. </p>
			<p>If we raise the value of <code>n_samples</code> to 100,000, you'll see that the variance between <a id="_idIndexMarker778"/>engines becomes more difficult to discern:</p>
			<div><div><img src="img/B18267_08_02.jpg" alt="Figure 8.2 – A screenshot of output with 100,000 samples&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – A screenshot of output with 100,000 samples</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor286"/>How it works…</h2>
			<p>Each of the random number engines has a functor interface that returns the next random number in the sequence: </p>
			<pre>result_type operator()();</pre>
			<p>The functor returns a random value, evenly distributed between the <code>min()</code> and <code>max()</code> values. All the random number engines have this interface in common. </p>
			<p>The <code>histogram()</code> function takes advantage of this uniformity by using the class of the random number engine in a template:</p>
			<pre>template &lt;typename RNG&gt;</pre>
			<p>(<strong class="bold">RNG</strong> is a common abbreviation for <strong class="bold">Random Number Generator</strong>. The library documentation<a id="_idIndexMarker779"/> refers to these classes as <em class="italic">engines</em>, which is synonymous with RNG for our purposes.)</p>
			<p>We instantiate<a id="_idIndexMarker780"/> an object with the RNG class and create a histogram in a <code>vector</code>:</p>
			<pre>RNG rng{};
<strong class="bold">vector&lt;size_t&gt; v(n_partitions)</strong>;
for(size_t i{}; i &lt; n_samples; ++i) {
    ++v[<strong class="bold">rng()</strong> / p_ratio];
}</pre>
			<p>This allows us to easily compare the results of the various random number engines with this technique. </p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor287"/>There's more…</h2>
			<p>Each of the <a id="_idIndexMarker781"/>random number engines in the library have different methodologies and characteristics. When you run the histogram multiple times, you'll notice that most of the engines have the same distribution each time they're run. That's because they are <em class="italic">deterministic</em> – that is, they generate the same sequence of numbers each time. <code>std::random_device</code> is non-deterministic on most systems. You can use it to seed one of the other engines if you need more variation. It is also common to seed an RNG with the current date and time.</p>
			<p>The <code>std::default_random_engine</code> is a suitable choice for most purposes. </p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor288"/>Compare random number distribution generators</h1>
			<p>The C++ Standard <a id="_idIndexMarker782"/>Library provides a selection of random number distribution generators, each with its own properties. In this recipe, we examine a function to compare the different options by creating a histogram of their output.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/>How to do it…</h2>
			<p>Like the random number engines, the distribution generators have some common interface elements. Unlike the random number engines, the distribution generators have a variety of properties to set. We can create a template function to print a histogram of the various distributions, but the initializations of the various distribution generators vary significantly:</p>
			<ul>
				<li>We start with some constants:<pre>constexpr size_t n_samples{ 10 * 1000 };
constexpr size_t n_max{ 50 };</pre></li>
			</ul>
			<p>The <code>n_samples</code> constant is the number of samples to generate for each histogram – in this case, 10,000. </p>
			<p>The <code>n_max</code> constant is used as a divisor while generating our histograms.</p>
			<ul>
				<li>Our histogram function takes a distribution generator as an argument and prints a histogram for that distribution algorithm:<pre>void dist_histogram(auto distro,
        const string_view&amp; dist_name) {
   <strong class="bold"> std::default_random_engine rng{};</strong>
<strong class="bold">    map&lt;long, size_t&gt; m;</strong>
    // create the histogram map
    for(size_t i{}; i &lt; n_samples; ++i) 
       <strong class="bold"> ++m[(long)distro(rng)];</strong>
    // print the histogram
    auto max_elm_it = max_element(m.begin(), m.end(),
        [](const auto&amp; a, const auto&amp; b)
        { return a.second &lt; b.second; }
        );
    size_t max_elm = max_elm_it-&gt;second;
    size_t max_div = std::max(max_elm / n_max,
        size_t(1));
    cout &lt;&lt; format("{}:\n", dist_name);
    for (const auto [randval, count] : m) {
        if (count &lt; max_elm / n_max) continue;
        cout &lt;&lt; format("{:3}:{:*&lt;{}}\n",
            randval, ' ', count / max_div);
    }
}</pre></li>
			</ul>
			<p>The <code>dist_histogram()</code> function <a id="_idIndexMarker783"/>uses a <code>map</code> to store the histogram. It then displays the histogram as a series of asterisks on the console.</p>
			<ul>
				<li>We call <code>dist_histogram()</code> from <code>main()</code>, like this:<pre>int main() {
    dist_histogram(std::uniform_int_distribution&lt;int&gt;
        {0, 9}, uniform_int_distribution");
    dist_histogram(std::normal_distribution&lt;double&gt;
        {0.0, 2.0}, "normal_distribution");
...</pre></li>
			</ul>
			<p>Calling the <code>dist_histogram()</code> function is more complex than it was for the random number generators. Each random distribution class has a different set of parameters, according<a id="_idIndexMarker784"/> to its algorithm. </p>
			<p>For the full list, refer to the <code>distribution.cpp</code> file in the GitHub archive.</p>
			<p>Output:</p>
			<div><div><img src="img/B18267_08_03.jpg" alt="Figure 8.3 – A screenshot of random distribution histograms&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – A screenshot of random distribution histograms</p>
			<p>Each of the <a id="_idIndexMarker785"/>distribution algorithms produces very different output. You will want to experiment with the different options for each random distribution generator.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/>How it works…</h2>
			<p>Each of the distribution generators has a functor that returns the next value in the random distribution:</p>
			<pre>result_type operator()( Generator&amp; g );</pre>
			<p>The functor takes a random number generator (RNG) object as an argument:</p>
			<pre>std::default_random_engine <strong class="bold">rng{}</strong>;
map&lt;long, size_t&gt; <strong class="bold">m</strong>;
for (size_t i{}; i &lt; n_samples; ++i) <strong class="bold">++m[(long)distro(rng)]</strong>;</pre>
			<p>For our <a id="_idIndexMarker786"/>purposes, we're using the <code>std::default_random_engine</code> for our RNG. </p>
			<p>As with the RNG histogram, this is a useful tool to visualize the various random distribution algorithms available in the <code>random</code> library. You will want to experiment with the various parameters available for each algorithm.</p>
		</div>
	</body></html>