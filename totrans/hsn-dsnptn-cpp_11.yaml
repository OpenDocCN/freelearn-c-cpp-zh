- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: ScopeGuard
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScopeGuard
- en: This chapter covers a pattern that can be seen as a generalization of the RAII
    idiom we studied earlier. In its earliest form, it is an old and established C++
    pattern, however, it is also one that has particularly benefited from the language
    additions in C++11, C++14, and C++17\. We will witness the evolution of this pattern
    as the language becomes more powerful. The ScopeGuard pattern exists at the intersection
    of declarative programming (say what you want to happen, not how you want it done)
    and error-safe programs (especially exception safety). We will have to learn a
    bit about both before we fully understand ScopeGuard.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种模式，它可以被视为我们之前研究的RAII语法的泛化。在其最初形式中，它是一个古老且成熟的C++模式，然而，它也是从C++11、C++14和C++17的语言添加中特别受益的模式。我们将见证随着语言变得更加强大，这个模式的演变。ScopeGuard模式存在于声明式编程（说明你想要发生什么，而不是你想要如何实现）和错误安全程序（特别是异常安全）的交叉点。在我们完全理解ScopeGuard之前，我们需要了解一些关于这两个方面的知识。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How can we write error-safe and exception-safe code? How does RAII make error
    handling easier?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何编写错误安全和异常安全的代码？RAII如何使错误处理更容易？
- en: What is composability as applied to error handling?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可组合性应用于错误处理是什么意思？
- en: Why is RAII not powerful enough for error handling, and how is it generalized?
    How can we implement declarative error handling in C++?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么RAII在错误处理方面不够强大，以及它是如何泛化的？我们如何在C++中实现声明式错误处理？
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is the example code: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例代码：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11)。
- en: 'You will also need the Google Benchmark library installed and configured: [https://github.com/google/benchmark](https://github.com/google/benchmark)
    (see [*Chapter 4*](B19262_04.xhtml#_idTextAnchor152), *Swap – From Simple to Subtle*,
    for installation instructions).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装和配置Google Benchmark库：[https://github.com/google/benchmark](https://github.com/google/benchmark)（参见[*第4章*](B19262_04.xhtml#_idTextAnchor152)，*交换
    – 从简单到微妙*，获取安装说明）。
- en: This chapter is rather heavy on advanced C++ features, so keep a C++ reference
    nearby ([https://en.cppreference.com](https://en.cppreference.com) unless you
    want to dig through the standard itself).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对高级C++特性有相当大的依赖，所以请将C++参考手册放在附近（[https://en.cppreference.com](https://en.cppreference.com)，除非你想直接查阅标准本身）。
- en: 'Finally, a very thorough and complete implementation of ScopeGuard can be found
    in the Folly library: [https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h](https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h);
    it includes C++ library programming details beyond those covered in this book.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Folly库中可以找到一个非常详尽和完整的ScopeGuard实现：[https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h](https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h)；它包括本书中未涵盖的C++库编程细节。
- en: Error handling and resource acquisition is initialization
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和资源获取即初始化
- en: We begin by reviewing the concepts of error handling, and, in particular, writing
    exception-safe code in C++. The **Resource Acquisition Is Initialization** (**RAII**)
    idiom is one of the primary methods of error handling in C++. We have already
    dedicated an entire chapter to it, and you will need it here to make sense of
    what we are about to do. Let’s first recognize the problem we are facing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先回顾错误处理的概念，特别是C++中编写异常安全代码。**资源获取即初始化**（**RAII**）是C++中错误处理的主要方法之一。我们已经为它专门写了一整章，你在这里需要它来理解我们即将要做的事情。让我们首先认识到我们面临的问题。
- en: Error safety and exception safety
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误安全和异常安全
- en: 'For the rest of this chapter, we will consider the following problem—suppose
    we are implementing a database of records. The records are stored on disk, but
    there is also an in-memory index for fast access to the records. The database
    API offers a method to insert records into the database:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将考虑以下问题——假设我们正在实现一个记录数据库。记录存储在磁盘上，但还有一个内存索引，用于快速访问记录。数据库API提供了一个将记录插入数据库的方法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the insertion succeeds, both the index and the disk storage are updated and
    consistent with each other. If something goes wrong, an exception is thrown.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入成功，索引和磁盘存储都会更新，并且彼此一致。如果出现问题，则会抛出异常。
- en: 'While it appears to the clients of the database that the insertion is a single
    transaction, the implementation has to deal with the fact that it is done in multiple
    steps—we need to insert the record into the index and write it to disk. To facilitate
    this, the database contains two classes, each responsible for its type of storage:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据库的客户端看起来插入是一个单一的事务，但实现必须处理这样一个事实：它是通过多个步骤完成的——我们需要将记录插入索引并写入磁盘。为了便于这样做，数据库包含两个类，每个类负责其类型的存储：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The implementation of the `insert()` function must insert the record into both
    the storage and the index, there is no way around it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`函数的实现必须将记录插入存储和索引中，没有其他方法可以绕过这一点：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unfortunately, either of these operations can fail. Let’s see first what happens
    if the storage insertion fails. Let’s assume that all failures in the program
    are signaled by throwing exceptions. If the storage insertion fails, the storage
    remains unchanged, the index insertion is not attempted at all, and the exception
    is propagated out of the `Database::insert()` function. That is exactly what we
    want—the insertion failed, the database is unchanged, and an exception is thrown.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这两种操作都可能失败。让我们首先看看如果存储插入失败会发生什么。假设程序中的所有失败都通过抛出异常来表示。如果存储插入失败，存储保持不变，索引插入根本不会尝试，异常会从`Database::insert()`函数中传播出去。这正是我们想要的——插入失败，数据库保持不变，并抛出异常。
- en: So, what happens if the storage insertion succeeds but the index fails? Things
    are not looking so good this time—the disk is altered successfully, then the index
    insertion fails, and the exception propagates to the caller of `Database::insert()`
    to signal the insertion failure, but the truth is the insertion did not completely
    fail. It did not completely succeed either.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果存储插入成功但索引失败会发生什么？这次情况看起来并不太好——磁盘被成功更改，然后索引插入失败，异常传播到`Database::insert()`的调用者以表示插入失败，但事实是插入并没有完全失败。它也没有完全成功。
- en: The database is left in an inconsistent state; there is a record on disk that
    is not accessible from the index. This is a failure to handle an error condition,
    exception-unsafe code, and it just won’t do.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库被留在一个不一致的状态；磁盘上有一个记录无法从索引中访问。这是处理错误条件失败、异常不安全的代码，这绝对是不行的。
- en: 'The impulsive attempt to change the order of the sub-operations does not help:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 试图改变子操作顺序的冲动尝试并没有帮助：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sure, everything is now fine if the index fails. But we have the same problem
    if the storage insertion throws an exception—we now have an entry in the index
    that is pointing to nowhere since the record was never written to disk.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果索引失败，现在一切看起来都很正常。但如果存储插入抛出异常，我们仍然会遇到同样的问题——现在索引中有一个条目指向了无意义的位置，因为记录从未被写入磁盘。
- en: 'Obviously, we cannot just ignore the exceptions thrown by `Index` or `Storage`;
    we have to somehow deal with them to maintain the consistency of the database.
    We know how to handle exceptions; that’s what the `try-catch` block is for:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不能简单地忽略`Index`或`Storage`抛出的异常；我们必须以某种方式处理它们，以保持数据库的一致性。我们知道如何处理异常；这就是`try-catch`块的作用：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, if the storage fails, we don’t need to do anything special. If the index
    fails, we have to undo the last operation on the storage (let’s assume that it
    has the API to do that). Now the database is again consistent as if the insertion
    never happened. Even though we caught the exception thrown by the index, we still
    need to signal to the caller that the insertion fails, so we re-throw the exception.
    So far, so good.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果存储失败，我们不需要做任何特殊的事情。如果索引失败，我们必须撤销存储上最后的操作（假设它有执行该操作的API）。现在数据库再次保持一致性，就像插入从未发生一样。尽管我们捕获了索引抛出的异常，我们仍然需要向调用者发出插入失败的信号，所以我们重新抛出异常。到目前为止，一切顺利。
- en: 'The situation is not much different if we choose to use error codes instead
    of exceptions; let’s consider the variant where all `insert()` functions return
    `true` if they succeed and `false` if they fail:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择使用错误代码而不是异常，情况并没有太大的不同；让我们考虑所有`insert()`函数在成功时返回`true`，失败时返回`false`的变体：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have to check the return value of every function, undo the first action if
    the second one fails, and return `true` only if both actions succeed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须检查每个函数的返回值，如果第二个操作失败则撤销第一个动作，并且只有当两个操作都成功时才返回`true`。
- en: So far, so good; we were able to fix the simplest two-stage problem, so the
    code is error-safe. Now, it is time to up the complexity. Suppose that our storage
    needs some cleanup to be performed at the end of the transaction, for example,
    the inserted record is not in its final state until we call the `Storage::finalize()`
    method (maybe this is done so `Storage::undo()` can work, and after the insertion
    is finalized it can no longer be undone). Note the difference between `undo()`
    and `finalize()`; the former must be called only if we want to roll back the transaction,
    while the latter must be called if the storage insertion succeeded, regardless
    of what happens after.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；我们能够修复最简单的两阶段问题，因此代码是错误安全的。现在，是时候提高复杂性了。假设我们的存储需要在事务结束时进行一些清理，例如，插入的记录只有在调用`Storage::finalize()`方法后才会处于最终状态（也许这是为了使`Storage::undo()`能够工作，并且在插入最终化后不能再撤销）。注意`undo()`和`finalize()`之间的区别；前者只有在想要回滚事务时才必须调用，而后者必须在存储插入成功后调用，无论之后发生什么。
- en: 'Our requirements are met with this flow of control:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的需求通过以下控制流程得到满足：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Or we have something similar in the case of returning error codes (for the rest
    of this chapter, we will use exceptions in all our examples, but conversion to
    error codes is not hard).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在返回错误代码的情况下（在本章的其余部分，我们将使用异常作为所有示例，但转换为错误代码并不困难）。
- en: 'This is already getting ugly, particularly the part about getting the cleanup
    code (in our case, `S.finalize()`) to run in every execution path. It’s only going
    to get worse if we have a more complex sequence of actions that must all be undone
    unless the entire operation succeeds. Here is the control flow for three actions,
    each with its own rollback and cleanup:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经变得很丑陋了，尤其是关于获取清理代码（在我们的情况下，`S.finalize()`）以在每条执行路径上运行的部分。如果我们有一个更复杂的动作序列，这些动作都必须撤销，除非整个操作成功，那么情况只会变得更糟。以下是三个动作的控制流程，每个动作都有自己的回滚和清理：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The obvious problem is the explicit tests for success, either as conditionals
    or as try-catch blocks. The more serious problem is that this way of error handling
    is not composable. The solution for N+1 actions is not the code for N actions
    with some bits added to it; no, we have to go deep inside the code and add the
    right pieces there. But we have already seen the C++ idiom for solving this very
    problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的问题是对成功进行的显式测试，无论是作为条件还是作为try-catch块。更严重的问题是这种错误处理方式是不可组合的。N+1个动作的解决方案不是在N个动作的代码中添加一些位；不，我们必须深入代码并正确地添加这些部分。但我们已经看到了解决这个问题的C++惯用法。
- en: Resource Acquisition Is Initialization
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源获取即初始化
- en: 'The RAII idiom binds resources to objects. The object is constructed when the
    resource is acquired, and the resource is deleted when the object is destroyed.
    In our case, we are interested only in the second half, the destruction. The advantage
    of the RAII idiom is that the destructors of all local objects must be called
    when the control reaches the end of the scope, regardless of how it happens (`return`,
    `throw`, `break`, and so on). Since we struggled with the cleanup, let’s hand
    that off to an RAII object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: RAII惯用法将资源绑定到对象上。当获取资源时对象被构造，当对象被销毁时资源被删除。在我们的情况下，我们只对后半部分感兴趣，即销毁。RAII惯用法的好处是，当控制达到作用域的末尾时，必须调用所有局部对象的析构函数，无论发生什么情况（`return`、`throw`、`break`等）。由于我们已经与清理作斗争，让我们将清理工作交给一个RAII对象：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `StorageFinalizer` object binds to the `Storage` object when it is constructed
    and calls `finalize()` when it is destroyed. Since there is no way to exit the
    scope in which the `StorageFinalizer` object is defined without calling its destructor,
    we do not need to worry about the control flow, at least for the cleanup; it is
    going to happen. Note that the `StorageFinalizer` is properly constructed after
    the storage insertion succeeds; if the first insertion fails, there is nothing
    to finalize.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当`StorageFinalizer`对象被构造时，它会绑定到`Storage`对象并在被销毁时调用`finalize()`方法。由于没有方法可以不调用其析构函数就退出定义`StorageFinalizer`对象的范围，所以我们不需要担心控制流，至少对于清理来说是这样；它将会发生。注意，`StorageFinalizer`在存储插入成功后才会被正确构造；如果第一次插入失败，就没有什么可以最终化的。
- en: 'This code works, but it looks somehow half-done; we have two actions that are
    performed at the end of the function, and the first one (cleanup, or `finalize()`)
    is automated while the second one (rollback, or `undo()`) is not. Also, the technique
    is still not composable; here is the flow of control for three actions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作，但它看起来有些半途而废；我们在函数末尾执行了两个操作，第一个操作（清理或`finalize()`）是自动化的，而第二个操作（回滚或`undo()`）则不是。此外，技术本身仍然不可组合；以下是三个操作的流程控制：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, to add another action, we have to add a try-catch block deep in the
    code. On the other hand, the cleanup part by itself is perfectly composable. Consider
    what the previous code looks like if we don’t need to do a rollback:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了添加另一个操作，我们必须在代码深处添加一个try-catch块。另一方面，清理部分本身是完全可以组合的。考虑如果我们不需要执行回滚，之前的代码看起来会是什么样子：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we need one more action, we simply add two lines at the end of the function,
    and the cleanup happens in the right order. If we could do the same for the rollback,
    we would be all set.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行另一个操作，我们只需在函数末尾添加两行代码，清理工作将按正确顺序进行。如果我们能够对回滚也做同样的事情，我们就可以万事大吉了。
- en: 'We cannot simply move the call to `undo()` into a destructor of another object;
    the destructors are always called, but the rollback happens only in the case of
    an error. But we can make the destructor call the rollback conditionally:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将对`undo()`的调用移动到另一个对象的析构函数中；析构函数总是被调用，但回滚只有在发生错误时才会发生。但我们可以使析构函数有条件地调用回滚：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Examine the code now; if the storage insertion fails, the exception is thrown
    and the database is unchanged. If it succeeds, two RAII objects are constructed.
    The first one will unconditionally call `S.finalize()` at the end of the scope.
    The second one will call `S.undo()` unless we commit the change first by calling
    the `commit()` method on the `StorageGuard` object. That will happen unless the
    index insertion fails, in which case an exception is thrown, the rest of the code
    in the scope is bypassed, and the control jumps straight to the end of the scope
    (the closing `}`) where the destructors of all local objects are called. Since
    we never called `commit()` in this scenario, the `StorageGuard` is still active
    and will undo the insertion. Note also that there are no explicit `try-catch`
    blocks at all: the actions that used to be in the `catch` clause are now done
    by the destructors. The exception should be, of course, caught eventually (in
    all examples that accompany this chapter, the exception is caught in `main()`).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查代码；如果存储插入失败，将抛出异常且数据库保持不变。如果成功，将构造两个RAII对象。第一个对象将在作用域结束时无条件调用`S.finalize()`。第二个对象将调用`S.undo()`，除非我们首先通过在`StorageGuard`对象上调用`commit()`方法提交更改。除非索引插入失败，否则会发生这种情况，此时将抛出异常，作用域内的其余代码将被跳过，控制直接跳转到作用域的末尾（即关闭的`}`），在那里调用所有局部对象的析构函数。由于我们在此场景中从未调用`commit()`，因此`StorageGuard`仍然处于活动状态并将撤销插入。注意，这里根本没有任何显式的`try-catch`块：以前在`catch`子句中执行的操作现在由析构函数完成。当然，异常最终应该被捕获（在伴随本章的所有示例中，异常都在`main()`中被捕获）。
- en: The destructors of the local objects are called in reverse construction order.
    This is important; if we have to undo the insertion, this can be done only until
    the action is finalized, so the rollback has to happen before the cleanup. Therefore,
    we construct the RAII objects in the correct order—first, the cleanup (to be done
    last), then the rollback guard (to be done first, if necessary).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本地对象的析构函数按反向构造顺序被调用。这很重要；如果我们必须撤销插入，这只能在操作最终化之前完成，因此回滚必须在清理之前发生。因此，我们按正确的顺序构造RAII对象——首先，清理（最后执行），然后是回滚保护（如果需要，首先执行）。
- en: The code now looks very nice, with no try-catch blocks at all. In some ways,
    it does not look like regular C++. This programming style is called **declarative
    programming**; it is a programming paradigm in which the program logic is expressed
    without explicitly stating the flow of control (the opposite, and the more common
    in C++, is **imperative programming**, where the program describes which steps
    to do and in what order, but not necessarily why). There are declarative programming
    languages (the prime example is SQL), but C++ is not one of them. Nonetheless,
    C++ is very good at implementing constructs that allow the creation of higher-order
    languages on top of C++, and so we have implemented a declarative error-handling
    language. Our program now says that after the record was inserted into storage,
    two actions are pending—the cleanup and the rollback.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在看起来非常好，完全没有try-catch块。在某种程度上，它看起来不像常规的C++。这种编程风格被称为**声明式编程**；它是一种编程范式，其中程序逻辑通过不明确声明控制流（与C++中更常见的相反，即**命令式编程**，其中程序描述了要执行哪些步骤以及它们的顺序，但不一定说明为什么）来表达。有声明式编程语言（主要例子是SQL），但C++不是其中之一。尽管如此，C++非常擅长实现允许在C++之上创建高级语言的构造，因此我们实现了一种声明式错误处理语言。我们的程序现在表示，在记录被插入存储后，有两个待执行的动作——清理和回滚。
- en: The rollback is disarmed if the entire function succeeds. The code looks linear,
    without the explicit flow of control, in other words, declarative.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整个函数执行成功，则回滚将被解除。代码看起来是线性的，没有显式的控制流，换句话说，是声明式的。
- en: 'Nice as it is, it is also far from perfect. The obvious problem is that we
    have to write a guard or a finalizer class for every action in our program. The
    less obvious one is that writing these classes correctly is not easy, and we have
    not done a particularly good job so far. Take a moment to figure out what is missing
    before looking at the fixed version here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很好，但它也远非完美。明显的问题是，我们必须为程序中的每个动作编写一个保护器或最终化器类。不那么明显的问题是，正确编写这些类并不容易，我们到目前为止做得并不特别出色。在查看这里修复的版本之前，花点时间想一下缺少了什么：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we need is a general framework that lets us schedule an arbitrary action
    to be executed at the end of the scope, unconditionally or conditionally. The
    next section presents the pattern that provides such a framework, ScopeGuard.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个通用框架，让我们能够安排在作用域结束时无条件或条件性地执行任意操作。下一节将介绍提供这种框架的模式，即范围保护。
- en: The ScopeGuard pattern
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围保护模式
- en: In this section, we learn how to write the on-exit action RAII classes such
    as the ones we implemented in the previous section, but without all the boilerplate
    code. This can be done in C++03 but is much improved in C++14, and again in C++17.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何编写退出时执行的动作RAII类，就像我们在上一节中实现的那样，但不需要所有样板代码。这可以在C++03中完成，但在C++14中得到了很大的改进，然后在C++17中再次改进。
- en: ScopeGuard basics
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围保护基础
- en: Let’s start with the more difficult problem—how to implement a generic rollback
    class, a generic version of `StorageGuard` from the last section. The only difference
    between that and the cleanup class is that the cleanup is always active, but the
    rollback is canceled after the action is committed. If we have the conditional
    rollback version, we can always take out the condition check, and we get the cleanup
    version, so let’s not worry about that for now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更困难的问题开始——如何实现一个通用的回滚类，即上一节中`StorageGuard`的通用版本。与清理类之间的唯一区别是，清理始终处于活动状态，但回滚在操作提交后取消。如果我们有条件回滚版本，我们可以总是去掉条件检查，从而得到清理版本，所以我们现在不必担心这个问题。
- en: 'In our example, the rollback is a call to the `S.undo()` method. To simplify
    the example, let’s start with a rollback that calls a regular function, not a
    member function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，回滚是一个调用`S.undo()`方法的操作。为了简化示例，让我们从一个调用常规函数而不是成员函数的回滚开始：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the implementation is finished, the program should look something like
    this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实施完成，程序应该看起来像这样：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code tells us (in a declarative manner!) that if the insert action succeeded,
    we schedule the rollback to be done upon exiting the scope. The rollback will
    call the `undo()` function with the argument `S`, which in turn will undo the
    insertion. If we made it to the end of the function, we disarm the guard and disable
    the rollback call, which commits the insertion and makes it permanent.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以声明式的方式告诉我们，如果插入操作成功，我们将在退出作用域时安排回滚操作。回滚将调用带有参数`S`的`undo()`函数，这反过来将撤销插入操作。如果我们到达了函数的末尾，我们将解除保护并禁用回滚调用，这将提交插入操作并使其永久化。
- en: 'A much more general and reusable solution was proposed by Andrei Alexandrescu
    in the *Dr. Dobbs* article in 2000 ([http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?](http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?)).
    Let’s look at the implementation and analyze it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Andrei Alexandrescu 在 2000 年的 *Dr. Dobbs* 文章中提出了一种更通用且可重用的解决方案（[http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?](http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?)）。让我们看看实现并分析它：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the top, we have the base class for all the scope guards, `ScopeGuardImplBase`.
    The base class holds the commit flag and the code to manipulate it; the constructor
    initially creates the guard in the armed state, so the deferred action will happen
    in the destructor. The call to `commit()` will prevent that from happening and
    make the destructor do nothing. Finally, there is a copy constructor that creates
    a new guard in the same state as the original but then disarms the original guard.
    This is so the rollback does not happen twice, from the destructors of both objects.
    The object is copyable but not assignable. We use C++03 features for everything
    here, including the disabled assignment operator. This implementation is fundamentally
    C++03; the few C++11 twists are just icing on the cake (that is about to change
    in the next section).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们有所有作用域保护器的基类，`ScopeGuardImplBase`。基类持有提交标志和操作它的代码；构造函数最初将保护器创建在武装状态，因此延迟操作将在析构函数中发生。对`commit()`的调用将阻止这种情况发生，并使析构函数不执行任何操作。最后，还有一个拷贝构造函数，它创建一个与原始对象状态相同的新保护器，然后解除原始保护器的武装。这样做是为了防止回滚在两个对象的析构函数中发生两次。对象是可拷贝的但不可赋值。我们在这里使用
    C++03 的所有功能，包括禁用的赋值运算符。这个实现本质上就是 C++03；少数 C++11 的变化只是锦上添花（这将在下一节中改变）。
- en: There are several details of the implementation of `ScopeGuardImplBase` that
    may seem odd and need elaboration. First of all, the destructor is not virtual;
    this is not a typo or a bug, this is intentional, as we will see later. Second,
    the `commit_` flag is declared `mutable`. This is, of course, so that it can be
    changed by the `commit()` method, which we declared `const`. So, why is `commit()`
    declared `const`? One reason is so we can call it on the source object from the
    copy constructor, to transfer the responsibility for the rollback from the other
    object to this one. In this sense, the copy constructor really does a move and
    will be officially declared as such later. The second reason for `const` will
    become obvious later (it is related to the non-virtual destructor, of all things).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScopeGuardImplBase` 实现的几个细节可能看起来很奇怪，需要详细说明。首先，析构函数不是虚拟的；这不是一个打字错误或错误，这是故意的，就像我们稍后将要看到的那样。其次，`commit_`标志被声明为`mutable`。当然，这是为了让它可以通过我们声明的`const`方法`commit()`被改变。那么，为什么`commit()`被声明为`const`呢？一个原因是我们可以从拷贝构造函数中调用它，将回滚的责任从另一个对象转移到这个对象。从这个意义上说，拷贝构造函数实际上执行了一个移动操作，稍后将被正式声明为这样的操作。`const`声明的第二个原因稍后就会变得明显（它与非虚拟析构函数有关）。'
- en: Let’s now turn to the derived class, `ScopeGuardImpl`. This is a class template
    with two type parameters—the first is the type of the function or any other callable
    object we are going to call for the rollback, and the second is the type of the
    argument. Our rollback function is restricted, for now, to having only one argument.
    That function is called in the destructor of the `ScopeGuard` object unless the
    guard was disarmed by calling `commit()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向派生类，`ScopeGuardImpl`。这是一个带有两个类型参数的类模板——第一个是我们将要调用的用于回滚的函数或任何其他可调用对象的类型，第二个是参数的类型。目前，我们的回滚函数仅限于只有一个参数。这个函数在`ScopeGuard`对象的析构函数中被调用，除非通过调用`commit()`解除保护。
- en: Finally, we have a factory function template, `MakeGuard`. This is a very common
    idiom in C++; if you need to create an instantiation of a class template from
    the constructor arguments, use a template function that can deduce the type of
    the parameters and that of the return value from the arguments (in C++17 class
    templates can do that too, as we will see later).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个工厂函数模板，`MakeGuard`。这在C++中是一个非常常见的惯用法；如果你需要从构造函数参数创建一个类模板的实例，请使用一个模板函数，它可以从参数推导出参数类型和返回值类型（在C++17中，类模板也可以这样做，我们稍后会看到）。
- en: 'How is this all used to create a guard object that will call `undo(S)` for
    us? Like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是如何用来创建一个将为我们调用`undo(S)`的守卫对象的？如下所示：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `MakeGaurd` function deduces the types of the `undo()` function and the
    argument `S` and returns a `ScopeGuard` object of the corresponding type. The
    return is by value, so there is a copy involved (the compiler may choose to elide
    the copy as an optimization, but is not required to). The returned object is a
    temporary variable, it has no name and binds it to the base class reference `SG`
    (casting from the derived class to the base class is implicit for both pointers
    and references). The lifetime of the temporary variable is until the closing semicolon
    of the statement that created it, as everyone knows. But then, what does the `SG`
    reference point to after the end of the statement? It has to be bound to something,
    as references cannot be unbound, they are not like `NULL` pointers. The truth
    is, “everyone” knows wrong, or rather only mostly right—usually, the temporaries
    indeed live until the end of the statement. However, binding a temporary to a
    `const` reference extends its lifetime to coincide with the lifetime of the reference
    itself. In other words, the unnamed temporary `ScopeGuard` object created by `MakeGuard`
    will not be destroyed until the `SG` reference goes out of scope. Const-ness is
    important here, but do not worry, you can’t forget it; the language does not permit
    binding non-`const` references to temporary variables, so the compiler will let
    you know. So this explains the `commit()` method; it has to be `const` since we
    are going to call it on the `const` reference (and, therefore, the `commit_` flag
    has to be `mutable`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeGuard`函数推导出`undo()`函数的类型和参数`S`的类型，并返回相应类型的`ScopeGuard`对象。返回是通过值进行的，因此涉及到一个复制（编译器可能会选择省略复制作为优化，但不是必须的）。返回的对象是一个临时变量，它没有名字，并将其绑定到基类引用`SG`（从派生类到基类的指针和引用的转换是隐式的）。临时变量的生命周期直到创建它的语句的结束分号，正如大家所知。但是，在语句结束后，`SG`引用指向什么？它必须绑定到某个东西，因为引用不能解绑，它们不像`NULL`指针。事实是，“每个人”都知道错了，或者说只是大部分正确——通常，临时变量确实会一直活到语句的结束。然而，将临时变量绑定到`const`引用会将其生命周期延长到与引用本身的生存期一致。换句话说，`MakeGuard`创建的无名`ScopeGuard`对象将不会在`SG`引用超出作用域之前被销毁。在这里，`const`属性很重要，但不必担心，你不会忘记它；语言不允许将非`const`引用绑定到临时变量，因此编译器会告诉你。因此，这就解释了`commit()`方法；它必须是`const`的，因为我们将在`const`引用上调用它（因此，`commit_`标志必须是`mutable`）。'
- en: But what about the destructor? At the end of the scope, the destructor of the
    `ScopeGuardImplBase` class will be called, since that is the type of reference
    that goes out of scope. The base class destructor itself does nothing, it’s the
    derived class that has the destructor we want. A polymorphic class with a virtual
    destructor would have served us right, but we did not take that route. Instead,
    we availed ourselves of yet another special rule in the C++ standard concerning
    the `const` references and temporary variables—not only is the lifetime of the
    temporary variable extended but also the destructor of the derived class, that
    is the actual class that was constructed, is going to be called at the end of
    the scope.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，关于析构函数呢？在作用域结束时，`ScopeGuardImplBase`类的析构函数将被调用，因为这是超出作用域的引用类型。基类析构函数本身不执行任何操作，执行我们想要的析构函数的是派生类。一个具有虚拟析构函数的多态类会为我们提供正确的服务，但我们没有走这条路。相反，我们利用了C++标准中关于`const`引用和临时变量的另一条特殊规则——不仅临时变量的生命周期被延长，而且派生类的析构函数，即实际构造的类，将在作用域结束时被调用。
- en: Note that this rule applies only to destructors; you still cannot call derived
    class methods on the base class `SG` reference. Also, the lifetime extension works
    only when the temporary variable is directly bound to a `const` reference. It
    does not work if, for example, we initialize another `const` reference from the
    first one. This is why we had to return the `ScopeGuard` object from the `MakeGuard`
    function by value; if we tried to return it by reference, the temporary would
    be bound to that reference, which is going to go away at the end of the statement.
    The second reference, `SG`, initialized from the first one, would not have extended
    the lifetime of the object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这条规则仅适用于析构函数；你仍然不能在基类`SG`引用上调用派生类方法。此外，生命周期扩展仅在临时变量直接绑定到`const`引用时才有效。如果，例如，我们从第一个引用初始化另一个`const`引用，则不会生效。这就是为什么我们必须通过值从`MakeGuard`函数返回`ScopeGuard`对象；如果我们尝试通过引用返回它，临时变量将绑定到那个引用，而这个引用将在语句结束时消失。第二个引用`SG`是从第一个引用初始化的，它并没有扩展对象的生命周期。
- en: 'The function implementation we just saw comes very close to the original goal,
    it is just a bit more verbose (and it mentions `ScopeGuardImplBase` instead of
    the promised `ScopeGuard`). Fear not, for the last step is merely syntactic sugar:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的函数实现非常接近原始目标，只是稍微有点冗长（并且提到了`ScopeGuardImplBase`而不是承诺的`ScopeGuard`）。不用担心，最后一步仅仅是语法糖：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can write this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样写：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is as far as we are going to get with the language tools we’ve used so
    far. Ideally, the desired syntax would be as follows (and we are not very far
    off):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们迄今为止使用语言工具所能达到的。理想情况下，所需的语法应该是这样的（而且我们并不遥远）：（此处省略具体语法示例）
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can tidy up our `ScopeGuard` a bit by making use of the C++11 features.
    First of all, we can properly disable the assignment operator. Second, we can
    stop pretending that our copy constructor is anything other than a move constructor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用C++11的特性来稍微整理一下我们的`ScopeGuard`。首先，我们可以正确地禁用赋值运算符。其次，我们可以停止假装我们的复制构造函数除了移动构造函数之外还有什么：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Moving to C++14, we can make one more simplification and deduce the return
    type of the `MakeGuard` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 转向C++14，我们可以进一步简化，并推断出`MakeGuard`函数的返回类型：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is still one concession we had to make—we did not really need the `undo(S)`
    function what we really wanted was to call `S.undo()`. This is done just as easily
    with a member function variant of `ScopeGuard`. In fact, the only reason we have
    not done so from the beginning is to make the example easier to follow; the member
    function pointer syntax is not the most straightforward aspect of C++:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须做出一项让步——我们实际上并不需要`undo(S)`函数，我们真正想要的是调用`S.undo()`。这可以通过`ScopeGuard`的成员函数变体轻松实现。事实上，我们之所以从一开始就没有这样做，只是为了使示例更容易理解；成员函数指针语法并不是C++中最直接的部分：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, if both versions of the ScopeGuard template are used in the same
    program, we have to rename one of them. Also, our function guard is limited to
    calling functions with only one argument, while our member function guard can
    call only member functions with no arguments. In C++03, this problem is solved
    in a tedious but reliable way—we have to create versions of the implementation,
    `ScopeGuardImpl0`, `ScopeGuardImp1`, `ScopeGuardImpl2`, and so on, for functions
    with zero, one, two, and so on arguments. We then create `ScopeObjGuardImpl0`,
    `ScopeObjGuardImpl1`, and so on, for member functions with zero, one, two, and
    so on arguments. If we do not create enough, the compiler will let us know. The
    base class remains the same for all these variants of the derived class, and so
    is the `ScopeGuard` `typedef`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果在同一个程序中使用了`ScopeGuard`模板的两个版本，我们必须重命名其中一个。此外，我们的函数守卫只能调用只有一个参数的函数，而我们的成员函数守卫只能调用没有参数的成员函数。在C++03中，这个问题通过一种繁琐但可靠的方式得到解决——我们必须为具有零、一、二等参数的函数创建实现版本，例如`ScopeGuardImpl0`、`ScopeGuardImp1`、`ScopeGuardImpl2`等。然后，我们为具有零、一、二等参数的成员函数创建`ScopeObjGuardImpl0`、`ScopeObjGuardImpl1`等。如果我们没有创建足够的版本，编译器会告诉我们。所有这些派生类变体都有相同的基类，`ScopeGuard`的`typedef`也是如此。
- en: In C++11, we have variadic templates that are designed to address this exact
    problem, but we’re not going to see such an implementation here. There is no reason
    for it; we can do so much better than that, as you are about to see.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，我们有变长模板，旨在解决这个确切的问题，但在这里我们不会看到这样的实现。没有必要；我们可以做得更好，正如你即将看到的。
- en: Generic ScopeGuard
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型ScopeGuard
- en: We are now firmly in C++11 territory, nothing that you are about to see has
    a C++03 equivalent of any practical worth.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完全处于C++11的领域，你即将看到的任何内容都没有C++03的等效物，具有任何实际价值。
- en: Our `ScopeGuard` has, so far, allowed us to all arbitrary functions as rollback
    for any action. Just like the hand-crafted guard objects, the scope guards are
    composable and guarantee exception safety. But our implementation, so far, is
    somewhat limited in what exactly we can call to implement the rollback; it has
    to be a function or a member function. While this seems to cover a lot, we may
    want to call, for example, two functions to do a single rollback. We could, of
    course, write a wrapper function for that, but that sets us back on the path toward
    single-purpose hand-crafted rollback objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`ScopeGuard`允许我们将任意函数作为任何操作的回滚。就像手工制作的守卫对象一样，作用域守卫是可组合的，并保证异常安全。但到目前为止，我们的实现对我们可以调用来实现回滚的功能有限；它必须是一个函数或成员函数。虽然这似乎涵盖了大部分，我们可能还想调用，例如，两个函数来完成单个回滚。我们当然可以为此编写一个包装函数，但这又让我们回到了单用途手工回滚对象的道路上。
- en: 'There is, in truth, another problem with our implementation. We decided to
    capture the function argument by reference:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的实现中还存在另一个问题。我们决定通过引用捕获函数参数：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This mostly works, unless the argument is a constant or a temporary variable;
    then, our code will not compile.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常都有效，除非参数是一个常量或临时变量；那么，我们的代码将无法编译。
- en: 'C++11 gives us another way to create arbitrary callable objects: lambda expressions.
    Lambdas are actually classes, but they behave like functions in that they can
    be called with parentheses. They can take arguments, but they can also capture
    any arguments from the containing scope, and that often obviates the need to pass
    arguments to the function call itself. We can also write arbitrary code and package
    it in a lambda expression. This sounds ideal for the scope guard; we could just
    write something that says, *at the end of the scope run* *this code*.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++11给我们提供了创建任意可调用对象的另一种方法：lambda表达式。Lambda实际上是类，但它们的行为像函数，因为它们可以用括号调用。它们可以接受参数，但也可以捕获包含作用域中的任何参数，这通常消除了传递参数给函数调用的需要。我们还可以编写任意代码，并将其打包在lambda表达式中。这听起来对作用域守卫来说很理想；我们只需编写一些代码，说“在作用域运行结束时”执行这些代码。
- en: 'Let’s see what a lambda expression ScopeGuard looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看lambda表达式作用域守卫的样子：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The base class is essentially the same as before, except we are not going to
    use the `const` reference trick anymore, and so the `Impl` suffix is gone; what
    you see is not an implementation aid but the base of the guard class itself; it
    contains the reusable code dealing with the `commit_` flag. Since we do not use
    the `const` reference, we can stop pretending that the `commit()` method is const,
    and drop the `mutable` declaration from `commit_`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基类基本上与之前相同，只是我们不再使用`const`引用技巧，因此`Impl`后缀已经消失；你所看到的不再是实现辅助，而是守卫类的本身基础；它包含处理`commit_`标志的可重用代码。由于我们不使用`const`引用，我们可以停止假装`commit()`方法是`const`的，并从`commit_`中删除`mutable`声明。
- en: The derived class, on the other hand, is much different. First of all, there
    is only one class for all types of rollback, and the argument type parameter is
    gone; instead, we have a functional object that is going to be a lambda, and it’ll
    contain all the arguments that it needs. The destructor is the same as before
    (except for the missing argument to the callable `func_`), and so is the move
    constructor. But the primary constructor of the object is quite different; the
    callable object is stored by value, and initialized from either a `const` reference
    or an r-value reference, with a suitable overload selected automatically by the
    compiler.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，派生类有很大的不同。首先，只有一个类用于所有类型的回滚，参数类型已经消失；相反，我们有一个将要成为lambda的功能对象，它将包含它需要的所有参数。析构函数与之前相同（除了缺少对可调用`func_`的参数），移动构造函数也是如此。但对象的主体构造函数相当不同；可调用对象按值存储，并从`const`引用或右值引用初始化，编译器会自动选择合适的重载。
- en: The `MakeGuard` function is largely unchanged, and we do not need two of them;
    we can use perfect forwarding (`std::forward`) to forward the argument of any
    type to one of the constructors of `ScopeGuard`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeGuard`函数基本上没有变化，我们不需要两个；我们可以使用完美转发（`std::forward`）将任何类型的参数转发到`ScopeGuard`的一个构造函数。'
- en: 'Here is how this ScopeGuard is used:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这个作用域守卫的示例：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The punctuation-rich construct that is used as an argument to `MakeGuard` is
    the lambda expression. It creates a callable object, and calling this object will
    run the code in the body of the lambda, in our case `S.undo()`. There is no `S`
    variable declared in the lambda object itself, so it has to be captured from the
    containing scope. All captures are done by reference (`[&]`). Finally, the object
    is called with no arguments; the parentheses can be omitted, although `MakeGuard([&]()
    { S.undo(); });` is also valid. The function does not return anything, that is,
    the return type is `void`; it does not have to be explicitly declared. Note that,
    so far, we have used C++11 lambdas and have not taken advantage of the more powerful
    C++14 lambdas. This will usually be the case with ScopeGuard, although in practice,
    you would probably use C++14 just for auto-deduced return types, if nothing else.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用作`MakeGuard`参数的标点符号丰富的结构是lambda表达式。它创建了一个可调用对象，调用此对象将运行lambda体内的代码，在我们的例子中是`S.undo()`。在lambda对象本身中没有声明`S`变量，因此它必须从包含的作用域中捕获。所有捕获都是通过引用（`[&]`）完成的。最后，对象被不带参数地调用；括号可以省略，尽管`MakeGuard([&]()
    { S.undo(); });`也是有效的。该函数不返回任何内容，即返回类型是`void`；不需要显式声明。请注意，到目前为止，我们使用了C++11 lambda，并没有利用更强大的C++14
    lambda。这通常是ScopeGuard的情况，尽管在实践中，您可能会仅为了自动推导的返回类型而使用C++14，如果其他什么也不做的话。
- en: 'We have, until now, intentionally set aside the matter of the regular cleanup
    and focused on error handling and the rollback. Now that we have a decent working
    ScopeGuard, we can tie up loose ends quite easily:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，我们有意将常规清理问题放在一边，专注于错误处理和回滚。现在我们有了相当不错的ScopeGuard，我们可以轻松地解决悬而未决的问题：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, nothing special needs to be added to our framework to support
    the cleanup. We simply create another ScopeGuard that we never disarm.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不需要在我们的框架中添加任何特殊的东西来支持清理。我们只需创建另一个我们永远不会解除武装的ScopeGuard。
- en: 'We should also point out that, in C++17, we no longer need the `MakeGuard`
    function since the compiler can deduce the template arguments from the constructor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该指出，在C++17中，我们不再需要`MakeGuard`函数，因为编译器可以从构造函数中推导出模板参数：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As long as we are on the subject of making ScopeGuard use prettier, we should
    consider some helpful macros. We can easily write a macro for the cleanup guard,
    the one that is always executed. We would like the resulting syntax to look something
    like this (if this isn’t declarative enough, I don’t know what is):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在讨论使ScopeGuard使用起来更美观的话题，我们应该考虑一些有用的宏。我们可以轻松地为清理守卫编写一个宏，即总是执行的那个。我们希望生成的语法看起来像这样（如果这还不够声明性，我不知道还有什么）：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can, in fact, get that very syntax. First of all, we need to generate a
    name for the guard, what used to be called `SF`, and we need it to be something
    unique. From the cutting edge of modern C++, we are now reaching decades back,
    to classic C and its preprocessor tricks, to generate a unique name for an anonymous
    variable:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以获取那个非常具体的语法。首先，我们需要为守卫生成一个名称，过去被称为`SF`，并且我们需要它是一个独一无二的名称。从现代C++的尖端，我们追溯到几十年前的经典C及其预处理器技巧，以生成一个匿名变量的唯一名称：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `__CONCAT__` macros are how you concatenate two tokens in the preprocessor
    (and yes, you need two of them, that’s the way the preprocessor works). The first
    token will be a user-specified prefix, and the second one is something unique.
    Many compilers support a preprocessor variable, `__COUNTER__`, that is incremented
    every time it’s used, so it’s never the same. However, it is not in the standard.
    If `__COUNTER__` is not available, we have to use the line number `__LINE__` as
    a unique identifier. Of course, it is only unique if we don’t put two guards on
    the same line, so don’t.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`__CONCAT__`宏是在预处理器中将两个标记连接起来的方法（是的，你需要两个，这就是预处理器的工作方式）。第一个标记将是一个用户指定的前缀，第二个是一个独一无二的标记。许多编译器支持一个预处理器变量`__COUNTER__`，每次使用时都会递增，所以它永远不会相同。然而，它不在标准中。如果`__COUNTER__`不可用，我们必须使用行号`__LINE__`作为唯一标识符。当然，只有在我们没有在同一行上放置两个守卫的情况下，它才是唯一的，所以不要这样做。'
- en: 'Now that we have a way to generate an anonymous variable name, we can implement
    the `ON_SCOPE_EXIT` macro. It would be trivial to implement one where the code
    is passed as a macro argument, but it would not give us the syntax we want; the
    argument has to be in parentheses, so at best we could get `ON_SCOPE_EXIT(S.finalize();)`.
    Also, commas in the code confuse the preprocessor, since it interprets them as
    a separator between the macro arguments. If you look carefully at the syntax we
    requested, `ON_SCOPE_EXIT { S.finalize(); };`, you will realize that this macro
    has no arguments at all, and the body of the lambda expression is just typed after
    the no-argument macro. The macro expansion, therefore, ends on something that
    can be followed by an opening curly brace. Here is how this is done:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了生成匿名变量名的方法，我们可以实现 `ON_SCOPE_EXIT` 宏。实现一个将代码作为宏参数传递的宏是微不足道的，但它不会给我们想要的语法；参数必须放在括号内，所以我们最多只能得到
    `ON_SCOPE_EXIT(S.finalize();)`。此外，代码中的逗号会混淆预处理器，因为它将其解释为宏参数之间的分隔符。如果你仔细观察我们请求的语法
    `ON_SCOPE_EXIT { S.finalize(); };`，你会意识到这个宏根本没有任何参数，lambda 表达式的主体只是类型化在无参数宏之后。因此，宏展开在可以跟随开括号的东西上结束。以下是它是如何完成的：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The macro expansion declares an anonymous variable that starts with `SCOPE_EXIT_STATE`,
    followed by a unique number, and it ends on the incomplete lambda expression,
    `[&]()`, that is completed by the code in the curly braces. In order to not have
    a closing parenthesis of the former `MakeGuard` function, which the macro cannot
    generate (the macro is expanded before the lambda body, so it cannot generate
    any code after that), we have to replace the `MakeGuard` function (or the `ScopeGuard`
    constructor in C++17) with an operator. The choice of the operator does not matter;
    we use `+`, but we could use any binary operator. The first argument to the operator
    is a temporary object of a unique type, it limits the overload resolution only
    to the `operator+()` defined previously (the object itself is not used at all,
    we only need its type). The `operator+()` itself is exactly what `MakeGuard` used
    to be, it deduces the type of the lambda expression and creates the corresponding
    `ScopeGuard` object. The only downside of this technique is that the closing semicolon
    at the end of the `ON_SCOPE_EXIT` statement is required, and should you forget
    it, the compiler will remind you in the most obscure and opaque way possible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 宏展开声明了一个以 `SCOPE_EXIT_STATE` 开头的匿名变量，后面跟着一个唯一的数字，并在不完整的 lambda 表达式 `[&]()` 上结束，该表达式由花括号中的代码完成。为了不产生前一个
    `MakeGuard` 函数的闭括号（宏无法生成，因为宏在 lambda 体之前展开，所以它不能生成任何代码），我们必须将 `MakeGuard` 函数（或
    C++17 中的 `ScopeGuard` 构造函数）替换为一个操作符。操作符的选择并不重要；我们使用 `+`，但也可以使用任何二元操作符。操作符的第一个参数是一个唯一的临时对象，它仅限于之前定义的
    `operator+()` 的重载解析（该对象本身根本不使用，我们只需要它的类型）。`operator+()` 本身就是 `MakeGuard` 之前所用的，它推断
    lambda 表达式的类型并创建相应的 `ScopeGuard` 对象。这种技术的唯一缺点是，在 `ON_SCOPE_EXIT` 语句的末尾需要一个分号，如果你忘记了，编译器将以最隐晦和模糊的方式提醒你。
- en: 'Our program code can now be further tidied up:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序代码现在可以进一步整理：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is tempting to apply the same technique to the second guard. Unfortunately,
    this is not so simple; we have to know the name of this variable so we can call
    `commit()` on it. We can define a similar macro that does not use an anonymous
    variable but instead takes the user-specified name:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 很有诱惑力将同样的技术应用到第二个守卫上。不幸的是，这并不简单；我们必须知道这个变量的名字，以便我们可以调用其上的 `commit()` 方法。我们可以定义一个类似的宏，它不使用匿名变量，而是使用用户指定的名字：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use it to complete the conversion of our code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来完成我们代码的转换：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this point, we should revisit the issue of composability. For three actions,
    each with its own rollback and cleanup, we now have the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该重新审视可组合性的问题。对于三个动作，每个都有自己的回滚和清理，我们现在有以下内容：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One can see how this pattern is trivially extended to any number of actions.
    An observant reader might wonder whether they have noticed a bug in the code,
    though—should not the rollback guards be dismissed in reverse construction order?
    This is not a bug, although neither is the reverse order of all `commit()` calls.
    The reason is that `commit()` cannot throw an exception, it was declared `noexcept`,
    and indeed its implementation is such that no exception can be thrown. This is
    vitally important for the ScopeGuard pattern to work; if `commit()` could throw,
    then there would be no way to guarantee that all rollback guards are properly
    disarmed. At the end of the scope, some actions would be rolled back, and others
    would not, leaving the system in an inconsistent state.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，这种模式可以轻易扩展到任意数量的动作。一个细心的读者可能会怀疑他们是否在代码中发现了错误——回滚保护不应该按照反向构造顺序取消吗？这不是一个错误，尽管所有`commit()`调用的反向顺序也不是错误。原因是`commit()`不能抛出异常，它被声明为`noexcept`，而且确实其实现是这样的，不能抛出异常。这对范围保护模式的工作至关重要；如果`commit()`可以抛出异常，那么就无法保证所有回滚保护都被正确解除。在作用域结束时，一些动作会被回滚，而其他动作则不会，这将使系统处于不一致的状态。
- en: While ScopeGuard was primarily designed to make exception-safe code easier to
    write, the interaction of the ScopeGuard pattern with exceptions is far from trivial,
    and we should spend more time on it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然范围保护主要设计用来使编写异常安全代码更容易，但范围保护模式与异常的交互远非简单，我们应该花更多时间来关注它。
- en: ScopeGuard and exceptions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围保护与异常
- en: The ScopeGuard pattern is designed to correctly run various cleanup and rollback
    operations automatically upon exiting a scope, no matter what caused the exit—normal
    completion by reaching the end of the scope, an early return, or an exception.
    This makes writing error-safe code in general, and exception-safe code in particular,
    much easier; as long as we queued up the right guards after every action, the
    correct cleanup and error handling will automatically happen. That is, of course,
    assuming that ScopeGuard itself is functioning correctly in the presence of exceptions.
    We are going to learn how to make sure it does and how to use it to make the rest
    of the code error-safe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 范围保护模式旨在在退出作用域时自动正确执行各种清理和回滚操作，无论退出原因是什么——正常完成作用域的末尾、提前返回或异常。这使得编写错误安全代码变得容易，尤其是异常安全代码；只要我们在每次动作之后都排好正确的保护程序，正确的清理和错误处理就会自动发生。当然，这是假设范围保护在异常存在的情况下本身运行正确。我们将学习如何确保它确实如此，以及如何使用它来使其余代码错误安全。
- en: What must not throw an exception
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么不能抛出异常
- en: We have already seen that the `commit()` function that is used to commit an
    action and disarm the rollback guard must never throw an exception. Fortunately,
    that is easy to guarantee since all this function does is set a flag. But what
    happens if the rollback function also fails, and throws an exception?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，用于提交动作并解除回滚保护的`commit()`函数绝对不能抛出异常。幸运的是，这很容易保证，因为这个函数所做的只是设置一个标志。但如果回滚函数也失败了，并抛出了异常怎么办？
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The short answer is *nothing good*. In general, we have a conundrum—we cannot
    allow the action, in our case the storage insertion, to remain, but we also cannot
    undo it, since that also fails. Specifically, in C++, two exceptions cannot propagate
    at the same time. For that reason, the destructors are not allowed to throw exceptions;
    a destructor may be called when an exception is thrown, and if that destructor
    also throws, we now have two exceptions propagating at the same time. If this
    happens, the program immediately terminates. This is not so much a shortcoming
    of the language as a reflection on the unsolvable nature of the problem in general;
    we cannot let things stay the way they are, but we also failed in an attempt to
    change something. There aren’t any good options left.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是*没有好办法*。一般来说，我们面临一个难题——我们既不能允许动作（在我们的例子中是存储插入）继续进行，也不能撤销它，因为那样也会失败。具体来说，在C++中，两个异常不能同时传播。因此，析构函数不允许抛出异常；当抛出异常时可能会调用析构函数，如果该析构函数也抛出异常，那么我们现在有两个异常同时传播。如果发生这种情况，程序将立即终止。这与其说是语言的不足，不如说是对一般问题不可解性的反映；我们无法让事情保持原样，但我们也未能成功改变某些东西。已经没有好的选择了。
- en: In general, there are three ways a C++ program can handle this situation. The
    best option is not to fall into this trap—if the rollback cannot throw, none of
    this will happen. A well-written exception-safe program thus goes to great lengths
    to provide non-throwing rollback and cleanup. For example, the main action can
    produce the new data and have it ready, then making the data available to the
    callers is as simple as swapping a pointer, definitely a non-throwing operation.
    The rollback involves only swapping the pointer back and maybe deleting something
    (as we already said, destructors should not throw exceptions; if they do, the
    program behavior is undefined).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C++程序有三种处理这种情况的方法。最好的选择是不陷入这个陷阱——如果回滚不能抛出异常，这一切都不会发生。因此，一个编写良好的异常安全程序会竭尽全力提供非抛出回滚和清理。例如，主要动作可以生成新数据并使其就绪，然后只需交换一个指针，就可以简单地将数据提供给调用者，这肯定是一个非抛出操作。回滚只涉及交换指针回原位，可能还需要删除某些东西（正如我们之前所说的，析构函数不应该抛出异常；如果它们这样做，程序的行为是未定义的）。
- en: 'The second option is to suppress the exception in the rollback. We tried to
    undo the operation, it didn’t work, there is nothing else we can do about it,
    so let’s push on. The danger here is that the program may be in an undefined state,
    and every operation from this point forward may be incorrect. This is, however,
    the worst-case scenario. In practice, the consequences may be less severe. For
    example, for our database, we may know that if the rollback fails, there is a
    chunk of disk space that is claimed by the record but is unreachable from the
    index. The caller will be correctly informed that the insertion failed, but we
    have wasted some disk space. This may be preferable to terminating the program
    outright. If this is what we want, we have to catch any exceptions that might
    be thrown by the ScopeGuard action:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是在回滚中抑制异常。我们尝试撤销操作，但失败了，我们对此无能为力，所以让我们继续前进。这里的危险是程序可能处于未定义的状态，从这一点开始的所有操作都可能是不正确的。然而，这只是一个最坏的情况。在实践中，后果可能不那么严重。例如，对于我们的数据库，我们可能知道如果回滚失败，有一块磁盘空间被记录占用，但无法从索引中访问。调用者将正确地被告知插入失败，但我们浪费了一些磁盘空间。这可能比直接终止程序更好。如果我们希望这样做，我们必须捕获任何可能由ScopeGuard操作抛出的异常：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `catch` clause is empty; we catch everything but do nothing. This implementation
    is sometimes called a *shielded ScopeGuard*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`子句是空的；我们捕获了一切，但什么也没做。这种实现有时被称为*屏蔽的ScopeGuard*。'
- en: 'The final option is to allow the program to fail. That will happen with no
    effort on our part if we just let two exceptions happen, but we could also print
    a message or otherwise signal to the user what is about to happen and why. If
    we want to insert our own dying action before the program terminates, we have
    to write code that is very similar to previously:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种选择是允许程序失败。如果我们只是让两个异常发生，那么这不需要我们做出任何努力就会发生。但我们可以打印一条消息或以其他方式向用户发出即将发生的事情以及原因的信号。如果我们想在程序终止之前插入自己的死亡动作，我们必须编写与之前非常相似的代码：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The key difference is the `throw;` statement without any arguments. This re-throws
    the exception we caught and allows it to continue propagating.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的区别是没有参数的`throw;`语句。这重新抛出了我们捕获的异常，并允许它继续传播。
- en: 'The difference between the last two code fragments highlights a subtle detail
    that we have glossed over earlier, but one that will become important later. It
    is imprecise to say that in C++ the destructors should not throw exceptions. The
    correct statement is that an exception should not propagate out of the destructor.
    The destructor can throw anything it wants as long as it also catches it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个代码片段之间的区别突显了一个我们之前略过的微妙细节，但这个细节在以后会变得很重要。说在C++中析构函数不应该抛出异常是不准确的。正确的说法是，异常不应该从析构函数中传播出来。只要析构函数也捕获它，它可以抛出任何它想要的东西：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Up until now, we have dealt with exceptions mostly as a nuisance; the program
    has to remain in a well-defined state if something somewhere throws something,
    but other than that, we have no use for these exceptions; we just pass them on.
    On the other hand, our code could work with any type of error handling, be it
    exceptions or error codes. If we knew for sure that errors are always signaled
    by exceptions and that any return from a function other than an exception thrown
    is a success, we could take advantage of that to automate the detection of success
    or failure and therefore allow a commit or rollback to happen as needed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要将异常视为一种麻烦；如果某个地方抛出了异常，程序必须保持一个良好的定义状态，但除此之外，我们没有使用这些异常；我们只是将它们传递下去。另一方面，我们的代码可以与任何类型的错误处理一起工作，无论是异常还是错误代码。如果我们确信错误总是通过异常来表示，并且任何非抛出异常的函数返回都是成功，我们可以利用这一点来自动检测成功或失败，从而允许根据需要发生提交或回滚。
- en: Exception-driven ScopeGuard
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常驱动的ScopeGuard
- en: We are now going to assume that if a function returns without throwing an exception,
    the operation has succeeded. If the function throws, it obviously failed. The
    objective now is to get rid of the explicit call to `commit()` and instead detect
    whether the destructor of ScopeGuard is executed because an exception was thrown,
    or because the function returned normally.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将假设如果一个函数没有抛出异常就返回，那么操作已经成功。如果函数抛出异常，显然失败了。现在的目标是取消对`commit()`的显式调用，而是检测ScopeGuard的析构函数是因抛出异常而执行，还是因为函数正常返回。
- en: There are two parts to this implementation. The first part is specifying when
    we want the action to be taken. The cleanup guard must be executed regardless
    of how we exit the scope. The rollback guard is executed only in case of failure.
    For completeness, we can also have a guard that is executed only if the function
    has succeeded. The second part is determining what actually happened.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现有两个部分。第一部分是指定我们希望在何时执行操作。清理守卫必须无论以何种方式退出作用域都要执行。回滚守卫仅在失败的情况下执行。为了完整性，我们还可以有一个仅在函数成功时执行的守卫。第二部分是确定实际上发生了什么。
- en: 'We will start with the second part. Our ScopeGuard now needs two additional
    parameters that will tell us whether it should be executed on success and whether
    it should be executed on failure (both can be enabled at the same time). Only
    the destructor of `ScopeGuard` needs to be modified:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第二部分开始。我们的ScopeGuard现在需要两个额外的参数，这两个参数将告诉我们是否应该在成功时执行，以及是否应该在失败时执行（两者可以同时启用）。只需要修改ScopeGuard的析构函数：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We still need to figure out how to implement the pseudo-functions `is_success()`
    and `is_failure()`. Remember that failure means that an exception was thrown.
    In C++, we have a function for that: `std::uncaught_exception()`. It returns true
    if an exception is currently propagating, and false otherwise. Armed with this
    knowledge, we can implement our guard:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要弄清楚如何实现伪函数`is_success()`和`is_failure()`。记住，失败意味着抛出了异常。在C++中，我们有一个函数可以做到这一点：`std::uncaught_exception()`。如果当前正在传播异常，它返回true，否则返回false。有了这个知识，我们可以实现我们的守卫：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, back to the first part: `ScopeGuard` will execute the delayed action if
    the conditions are right, so how do we tell it what conditions are right? Using
    the macro approach we developed earlier, we can define three versions of the guard—`ON_SCOPE_EXIT`
    is always executed, `ON_SCOPE_SUCCESS` is executed only if no exceptions were
    thrown, and `ON_SCOPE_FAILURE` is executed if an exception was thrown. The latter
    replaces our `ON_SCOPE_EXIT_ROLLBACK` macro, only now it too can use an anonymous
    variable name, since there are no explicit calls to `commit()`. The three macros
    are defined in a very similar way, we just need three different unique types instead
    of one `ScopeGuardOnExit`, so we can decide which `operator+()` to call:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到第一部分：ScopeGuard将在条件正确时执行延迟操作，那么我们如何告诉它正确的条件呢？使用我们之前开发的宏方法，我们可以定义三个版本的守卫——`ON_SCOPE_EXIT`总是执行，`ON_SCOPE_SUCCESS`仅在未抛出异常时执行，而`ON_SCOPE_FAILURE`在抛出异常时执行。后者替换了我们的`ON_SCOPE_EXIT_ROLLBACK`宏，但现在它也可以使用匿名变量名，因为没有显式调用`commit()`。这三个宏以非常相似的方式定义，我们只需要三个不同的唯一类型而不是一个`ScopeGuardOnExit`，这样我们就可以决定调用哪个`operator+()`：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Each overload of `operator+()` constructs a `ScopeGuard` object with different
    Boolean arguments that control when it does and does not execute. Each macro directs
    the lambda expression to the desired overload by specifying the type of the first
    argument to the `operator+()` using one of the unique tree types we defined just
    for this purpose: `ScopeGuardOnExit`, `ScopeGuardOnSuccess`, and `ScopeGuardOnFailure`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `operator+()` 的重载都会使用不同的布尔参数构建一个 `ScopeGuard` 对象，这些参数控制它何时执行以及何时不执行。每个宏通过指定
    `operator+()` 的第一个参数的类型，使用我们为此目的定义的唯一树类型之一来指导 lambda 表达式：`ScopeGuardOnExit`、`ScopeGuardOnSuccess`
    和 `ScopeGuardOnFailure`。
- en: 'This implementation can pass simple and even fairly elaborate tests and appears
    to work. Unfortunately, it has a fatal flaw—it does not correctly detect success
    or failure. To be sure, it works fine if our `Database::insert()` function was
    called from the normal control flow, where it may or may not succeed. The problem
    is we may call `Database::insert()` from a destructor of some other object, and
    that object may be used in a scope where an exception is thrown:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现可以通过简单的甚至相当复杂的测试，看起来似乎可以工作。不幸的是，它有一个致命的缺陷——它不能正确地检测成功或失败。当然，如果我们的 `Database::insert()`
    函数是从正常的控制流中调用的，它可能成功也可能失败，它工作得很好。问题是，我们可能从某个其他对象的析构函数中调用 `Database::insert()`，而这个对象可能被用于一个抛出异常的作用域中：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, `db_.insert()` runs in the presence of an uncaught exception, and so `std::uncaught_exception()`
    will return `true`. The problem is this is not the exception we were looking for.
    This exception does not indicate that `insert()` failed, but it will be treated
    as such and the database insertion will be undone.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`db_.insert()` 在未捕获异常的存在下运行，因此 `std::uncaught_exception()` 将返回 `true`。问题是这并不是我们正在寻找的异常。这个异常并不表明
    `insert()` 失败了，但它将被视为失败，并且数据库插入将被撤销。
- en: What we really need is to know how many exceptions are currently propagating.
    This may seem a strange statement since C++ does not allow multiple exceptions
    to propagate at the same time. However, we have already seen that this is an oversimplification;
    the second exception can propagate just fine as long as it does not escape the
    destructor. In the same manner, three or more exceptions can propagate if we have
    nested destructor calls, we just have to catch them all in time. To solve this
    problem correctly, we need to know how many exceptions were propagating when the
    `Database::insert()` function was called. Then, we can compare it with the number
    of exceptions propagating at the end of the function, however we got there. If
    these numbers are the same, `insert()` did not throw any exceptions, and any preexisting
    ones are not our concern. If a new exception was added, `insert()` has failed,
    and the exit handling must change accordingly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要知道的是当前正在传播多少个异常。这个说法可能听起来有些奇怪，因为 C++ 不允许同时传播多个异常。然而，我们已经看到这是一个过度简化的说法；第二个异常只要它没有逃离析构函数，就可以很好地传播。同样，如果有嵌套析构函数调用，三个或更多异常也可以传播，我们只需及时捕获它们即可。为了正确解决这个问题，我们需要知道在调用
    `Database::insert()` 函数时正在传播多少个异常。然后，我们可以将其与函数结束时的异常传播数量进行比较，无论我们如何到达那里。如果这些数字相同，`insert()`
    没有抛出任何异常，并且任何现有的异常都不是我们的问题。如果添加了新的异常，`insert()` 失败了，并且退出处理必须相应地更改。
- en: 'C++17 lets us implement this detection; in addition to the previous `std::uncaught_exception()`,
    which is deprecated (and removed in C++20), we now have a new function, `std::uncaught_exceptions()`,
    which returns the number of currently propagating exceptions. We can now implement
    this `UncaughtExceptionDetector` to detect new exceptions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 允许我们实现这种检测；除了之前已弃用的 `std::uncaught_exception()`（在 C++20 中被移除），我们现在有一个新的函数，`std::uncaught_exceptions()`，它返回当前正在传播的异常数量。我们现在可以实现这个
    `UncaughtExceptionDetector` 来检测新的异常：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this detector, we can finally implement the automatic `ScopeGuard`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个检测器，我们最终可以实现自动的 `ScopeGuard`：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The need to use C++17 may present a (hopefully short-term) obstacle to using
    this technique in programs constrained to older versions of the language. While
    there is no other standard-compliant, portable way to solve this problem, most
    modern compilers have ways to get to the uncaught exception counter. This is how
    it is done in GCC or Clang (the names starting with `__` are GCC internal types
    and functions):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用 C++17 可能会在使用此技术在受限于较旧语言版本的程序中遇到（希望是短期）障碍。虽然没有其他符合标准、可移植的解决此问题的方法，但大多数现代编译器都有方法来获取未捕获异常计数器。这就是在
    GCC 或 Clang（以 `__` 开头的名称是 GCC 内部类型和函数）中是如何做的：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Whether we use the exception-driven ScopeGuard or the explicitly named ScopeGuard
    (perhaps to handle error codes as well as exceptions), we have accomplished our
    goals—we now can specify deferred actions that must be taken at the end of a function
    or any other scope.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用异常驱动的ScopeGuard还是显式命名的ScopeGuard（可能用于处理错误代码以及异常），我们都已经实现了目标——我们现在可以指定在函数或任何其他作用域结束时必须执行的操作。
- en: At the end of this chapter, we will show another implementation of ScopeGuard
    that can be found in several sources on the web. This implementation deserves
    some consideration, but you should be aware of the downsides as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们将展示另一种可以在网络上找到的ScopeGuard实现。这种实现值得考虑，但你也应该意识到它的缺点。
- en: Type-erased ScopeGuard
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型擦除的ScopeGuard
- en: 'If you search online for a ScopeGuard example, you may chance upon an implementation
    that uses `std::function` instead of a class template. The implementation itself
    is quite simple:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网上搜索ScopeGuard示例，可能会偶然发现一个使用`std::function`而不是类模板的实现。这个实现本身相当简单：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that this ScopeGuard is a class, not a class template. It has template
    constructors that can accept the same lambda expression or another callable object
    as the other guard. But the variable used to store that expression has the same
    type no matter what the type of the callable is. That type is `std::function<void()>`,
    a wrapper for any function that takes no arguments and returns nothing. How can
    a value of any type be stored in an object of some fixed type? That is the magic
    of type erasure, and we have a whole chapter dedicated to it ([*Chapter 6*](B19262_06.xhtml#_idTextAnchor266),
    *Understanding Type Erasure*). This non-template ScopeGuard makes the code that
    uses it simpler (at least in the pre-C++17 version) because there are no types
    to deduce:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个ScopeGuard是一个类，而不是类模板。它有模板构造函数，可以接受与另一个守卫相同的lambda表达式或另一个可调用对象。但用于存储该表达式的变量无论可调用对象是什么类型，都具有相同的类型。这种类型是`std::function<void()>`，它是任何不接受任何参数且不返回任何内容的函数的包装器。如何将任何类型的值存储在某种固定类型的对象中？这就是类型擦除的魔法，我们有一个专门的章节来介绍它([第6章](B19262_06.xhtml#_idTextAnchor266)，*理解类型擦除*)。这个非模板的ScopeGuard使得使用它的代码更简单（至少在C++17之前），因为没有需要推断的类型：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There is, however, a serious downside to this approach—a type-erased object
    has to do a non-trivial amount of computation to achieve its magic. As a minimum,
    it involves an indirect or a virtual function call, and often some memory is allocated
    and deallocated as well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有一个严重的缺点——类型擦除的对象必须进行相当数量的计算才能实现其魔法。至少，它涉及到间接或虚拟函数调用，并且通常还需要分配和释放一些内存。
- en: 'Using the lessons of [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding
    Type Erasure*, we can come up with a slightly more efficient type erasure implementation;
    in particular, we can insist that the on-exit callable fits into the guard’s buffer:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用[第6章](B19262_06.xhtml#_idTextAnchor266)的教训，*理解类型擦除*，我们可以提出一个稍微更有效的类型擦除实现；特别是，我们可以坚持在退出时调用的可调用对象适合守卫的缓冲区：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can compare the runtime cost of the type-erased ScopeGuard versus the template
    `ScopeGuard` using the Google Benchmark library. The results will depend on what
    operation we are guarding, of course: for long computations and expensive on-exit
    actions, a slight difference in `ScopeGuard`’s run time makes no difference. The
    difference is going to be more pronounced if the computations in the scope and
    upon exiting the scope are fast:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Google Benchmark库比较类型擦除的ScopeGuard与模板`ScopeGuard`的运行时成本。结果将取决于我们正在保护的操作：对于长时间计算和昂贵的退出操作，`ScopeGuard`的运行时差异微不足道。如果作用域内的计算和退出作用域的计算很快，差异将会更加明显：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that the memory is never allocated (`rand()` returns non-negative random
    numbers) and the pointer `p` is always `null`, so we are benchmarking the call
    to `rand()` plus the overhead of `ScopeGuard`. For comparison, we can call `delete`
    explicitly, without the guard. The result shows that the template version of the
    guard has no measurable overhead, while both type-erased implementations have
    some:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，内存永远不会被分配（`rand()`返回非负随机数），指针`p`始终是`null`，因此我们正在基准测试`rand()`调用以及ScopeGuard的开销。为了比较，我们可以显式调用`delete`，而不使用守卫。结果显示，守卫的模板版本没有可测量的开销，而两种类型擦除的实现都有一些：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our own type-erased version adds about 1 nanosecond to each iteration, and
    the one based on `std::function` takes almost twice as long. Benchmarks of this
    sort are strongly affected by compiler optimizations and can produce very different
    results in response to even slight changes in the code. For example, let us change
    the code to always construct the new object:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的类型擦除版本为每个迭代增加了大约1纳秒，而基于`std::function`的版本则几乎需要两倍的时间。这种类型的基准测试强烈受到编译器优化的影响，并且可能会对代码的微小变化产生非常不同的结果。例如，让我们将代码改为始终构造新对象：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we call the operator new on each iteration of the loop, so the corresponding
    deletion must happen as well. This time, the compiler was able to optimize the
    template `ScopeGuard` much better than the type-erased one:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对循环的每次迭代都调用operator new，因此相应的删除也必须发生。这次，编译器能够比类型擦除版本更好地优化模板`ScopeGuard`：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Overall, there isn’t much of a reason to use type erasure here. The runtime
    cost may be negligible or significant, but there is usually nothing to gain in
    exchange. The only advantage of the type-erased version is that the guard itself
    is always of the same type. But the type of the guard is almost always irrelevant:
    we create the variable as `auto` or using constructor template argument deduction,
    and the only explicit operation we may need to do on the guard is to disarm it.
    Thus, we never need to write any code that depends on the guard’s type. Overall,
    the template-based ScopeGuard, with or without macros, remains the pattern of
    choice for automatically releasing resources and performing other actions at the
    end of a scope.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，在这里使用类型擦除并没有太大的理由。运行时成本可能微不足道或相当显著，但通常没有什么可以获得的。类型擦除版本的唯一优势是守卫本身总是同一类型。但守卫的类型几乎总是无关紧要：我们创建变量时使用`auto`或构造函数模板参数推导，我们可能需要的唯一显式操作是对守卫进行解除武装。因此，我们永远不需要编写任何依赖于守卫类型的代码。总的来说，基于模板的ScopeGuard，无论是否有宏，都是自动释放资源并在作用域结束时执行其他操作的优选模式。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have studied, in detail, one of the best C++ patterns for
    writing exception-safe and error-safe code. The ScopeGuard pattern allows us to
    schedule an arbitrary action, a fragment of C++ code, to be executed upon completion
    of a scope. The scope may be a function, the body of a loop, or just a scope inserted
    into the program to manage the lifetime of local variables. The actions that are
    executed to the end may be conditional on the successful completion of the scope,
    however, that is defined. The ScopeGuard pattern works equally well when success
    or failure are indicated by return codes or exceptions, although in the latter
    case we can automatically detect the failure (with return codes, the programmer
    has to explicitly specify which return values mean success and which do not).
    We have observed the evolution of the ScopeGuard pattern as more recent language
    features are used. In its optimal form, ScopeGuard provides a simple declarative
    way to specify post-conditions and deferred actions, such as cleanup or rollback,
    in a manner that is trivially composable for any number of actions that need to
    be committed or undone.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细研究了编写异常安全和错误安全代码的最佳C++模式之一。ScopeGuard模式允许我们在作用域完成后执行任意操作，即C++代码片段。作用域可能是一个函数，循环体，或者只是插入到程序中以管理局部变量生命周期的作用域。执行到最后的操作可能取决于作用域的成功完成，无论定义如何。ScopeGuard模式在成功或失败通过返回代码或异常指示时同样有效，尽管在后一种情况下我们可以自动检测失败（对于返回代码，程序员必须明确指定哪些返回值表示成功，哪些不表示成功）。我们已经观察到了ScopeGuard模式的演变，随着更现代的语言特性的使用。在其最佳形式中，ScopeGuard提供了一种简单声明式的方式来指定后置条件和延迟操作，如清理或回滚，这种方式对于任何需要提交或撤销的操作数量都是简单可组合的。
- en: The next chapter describes another very C++-specific pattern, the Friends Factory,
    which is a kind of Factory, only instead of objects during the execution of a
    program, it manufactures functions during its compilation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将描述另一种非常C++特定的模式，即Friends Factory，它是一种工厂模式，只是在程序执行期间制造对象，而不是在编译期间制造函数。
- en: Questions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an error-safe or exception-safe, program?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是错误安全或异常安全的程序？
- en: How can we make a routine that performs several related actions be error-safe?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使执行多个相关操作的例程成为错误安全的？
- en: How does RAII assist in writing error-safe programs?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII是如何帮助编写错误安全程序的？
- en: How does the ScopeGuard pattern generalize the RAII idiom?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ScopeGuard模式是如何泛化RAII惯用的？
- en: How can the program automatically detect when a function exits successfully
    and when it fails?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序如何自动检测函数成功退出和失败的情况？
- en: What are the advantages and drawbacks of a type-erased ScopeGuard
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型擦除的ScopeGuard有什么优点和缺点？
