["```cpp\n    @rpc(\"any_peer\", \"call_local\")\n    func setup_multiplayer(player_id):\n         var self_id = multiplayer.get_unique_id()\n         var is_player = self_id == player_id\n         set_process_unhandled_input(is_player)\n         camera.enabled = is_player\n    ```", "```cpp\n    func setup_multiplayer(player_id):\n         var self_id = multiplayer.get_unique_id()     var is_player = self_id == player_id      set_process_unhandled_input(is_player)      camera.enabled = is_player\n         if not multiplayer.is_server():\n    ```", "```cpp\n    _unhandled_input() callback after adding this new logic:\n    ```", "```cpp\n    func _unhandled_input(event):\n         if event.is_action_pressed(\"shoot\"):\n              weapon.rpc(\"set_firing\", true)\n         elif event.is_action_released(\"shoot\"):\n              weapon.rpc(\"set_firing\", false)\n    # Thrusting logic. The spaceship enables its thrust based on if the `thurst_acti\n    on` was pressed or released\n         if event.is_action_pressed(thrust_action):\n              spaceship.rpc_id(1, \"set_thrusting\", true)\n         elif event.is_action_released(thrust_action):\n              spaceship.rpc_id(1, \"set_thrusting\", false)\n    # Turning logic. If a turning key is just pressed or still pressed, the spaceshi\n    p turns, it only stops turning if neither `turn_left_action` or `turn_right_action\n    ` are pressed.\n         if event.is_action_pressed(turn_left_action):\n              spaceship.rpc_id(1, \"set_direction\", -1)\n              spaceship.rpc_id(1, \"set_turning\", true)\n         elif event.is_action_released(turn_left_action):\n              if Input.is_action_pressed(turn_right_action):\n    spaceship.rpc_id(1, \"set_direction\", 1)\n    12 Implementing Lag Compensation 8\n         else:\n              spaceship.rpc_id(1, \"set_turning\", false)\n              spaceship.rpc_id(1, \"set_direction\", 0)\n         if event.is_action_pressed(turn_right_action):\n              spaceship.rpc_id(1, \"set_direction\", 1)\n              spaceship.rpc_id(1, \"set_turning\", true)\n         elif event.is_action_released(turn_right_action):\n         if Input.is_action_pressed(turn_left_action):\n              spaceship.rpc_id(1, \"set_direction\", -1)\n         else:\n              spaceship.rpc_id(1, \"set_turning\", false)\n              spaceship.rpc_id(1, \"set_direction\", 0)\n    ```", "```cpp\n    @export var thrusting = false : set = set_thrusting @export var turning = false : set = set_turning\n    @export_range(-1, 1, 1) var direction = 0 : set = set_direction\n    ```", "```cpp\n    @rpc(\"any_peer\", \"call_local\")\n    func set_thrusting(is_thrusting):\n         thrusting = is_thrusting\n    @rpc(\"any_peer\", \"call_local\")\n    func set_turning(is_turning):\n         turning = is_turning\n    @rpc(\"any_peer\", \"call_local\")\n    func set_direction(new_direction):\n         direction = new_direction\n    ```", "```cpp\n    func thrust(delta):\n         linear_velocity += (acceleration * delta) * Vector2.RIGHT.rotated(rotation)\n    func turn(delta):\n         angular_velocity += (direction * turn_torque) * delta\n    ```", "```cpp\n    func _physics_process(delta):\n    if thrusting:\n         thrust(delta)\n    if turning:\n         turn(delta)\n    ```", "```cpp\n# Only clients should get statistics about their connection with the server, so we don't call that on the server itself.\nif not multiplayer.is_server():\n     var server_connection = multiplayer.multiplayer_peer.get_peer(1)\n     var latency = server_connection.get_statistic(ENetPacketPeer.PEER_ROUND_TRIP_TIM\nE))\n     print(latency)\n```", "```cpp\n    @onready var previous_position = spaceship.position\n    @onready var previous_rotation = spaceship.rotation\n    ```", "```cpp\n    func _on_interpolation_timer_timeout():\n         rpc(\"interpolate_position\", spaceship.position, $InterpolationTimer.wait_time)\n         rpc(\"interpolate_rotation\", spaceship.rotation, $InterpolationTimer.wait_time)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_position(target_position, duration_in_seconds):\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_position(target_position, duration_in_seconds):\n         var tween = create_tween()\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_position(target_position, duration_in_seconds):\n         var tween = create_tween()\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_position(target_position, duration_in_seconds):\n         var tween = create_tween()\n         var final_value = lerp(previous_position, target_position, 1.0)\n         tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_position(target_position, duration_in_seconds):\n         var tween = create_tween()\n         var final_value = lerp(previous_position, target_position, 1.0)\n         tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)\n         var tweener = tween.tween_property(spaceship, \"position\", final_value, duration_\n    in_seconds)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_position(target_position, duration_in_seconds):\n         var tween = create_tween()\n         var final_value = lerp(previous_position, target_position, 1.0)\n         tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)\n         var tweener = tween.tween_property(spaceship, \"position\", final_value, duration_\n    in_seconds)\n         tweener.from(previous_position)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_position(target_position, duration_in_seconds):var tween = create_tween()\n         var final_value = lerp(previous_position, target_position, 1.0)\n         tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)\n         var tweener = tween.tween_property(spaceship, \"position\", final_value, duration_\n    in_seconds)\n         tweener.from(previous_position)\n         previous_position = final_value\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func interpolate_rotation(target_rotation, duration_in_seconds):\n         var tween = create_tween()\n         var final_value = lerp_angle(previous_rotation, target_rotation, 1.0)\n         tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)\n         var tweener = tween.tween_property(spaceship, \"rotation\", final_value, duration_\n    in_seconds)\n         tweener.from(previous_rotation)\n         previous_rotation = final_value\n    ```", "```cpp\n    @rpc(\"any_peer\", \"call_local\")\n    func setup_multiplayer(player_id):\n         var self_id = multiplayer.get_unique_id() var      is_player = self_id == player_id      set_process_unhandled_input(is_player)      camera.enabled = is_player\n         if not multiplayer.is_server():\n              camera.make_current()\n         else:\n    ```", "```cpp\n    @rpc(\"any_peer\", \"call_local\")\n    func setup_multiplayer(player_id):\n         var self_id = multiplayer.get_unique_id()\n         var is_player = self_id == player_id\n         set_process_unhandled_input(is_player)\n         camera.enabled = is_player\n         if not multiplayer.is_server():\n              camera.make_current()\n         else:\n              $InterpolationTimer.start()\n              $SynchronizationTimer.start()\n    ```", "```cpp\n    func _on_synchronization_timer_timeout():\n         rpc(\"synchronize_position\", spaceship.position, $SynchronizationTimer.wait_time)\n         rpc(\"synchronize_rotation\", spaceship.rotation, $SynchronizationTimer.wait_time)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func synchronize_position(new_position, synchronization_tic):\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func synchronize_position(new_position, synchronization_tic):\n         for tween in get_tree().get_processed_tweens():\n              tween.stop()\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func synchronize_position(new_position,      synchronization_tic):\n         for tween in get_tree().get_processed_tweens():\n         tween.stop()\n         var future_position = predict_position(new_position, synchronization_tic)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func synchronize_position(new_position, synchronization_tic):\n    for tween in get_tree().get_processed_tweens():\n    tween.stop()\n    var future_position = predict_position(new_position, synchronization_tic)\n    spaceship.position = new_position\n    previous_position = new_position\n    ```", "```cpp\n    func predict_position(new_position, seconds_ahead):\n    ```", "```cpp\n    func predict_position(new_position, seconds_ahead):\n    var distance = previous_position.distance_to(new_position)\n    var direction = previous_position.direction_to(new_position)\n    ```", "```cpp\n    func predict_position(new_position, seconds_ahead): var distance = previous_position.distance_to(new_position) var direction = previous_position.direction_to(new_position) var linear_velocity = (direction * distance) / seconds_ahead spaceship.linear_velocity = linear_velocity\n    ```", "```cpp\n    func predict_position(new_position, seconds_ahead):\n    var distance = previous_position.distance_to(new_position)\n    var direction = previous_position.direction_to(new_position)\n    var linear_velocity = (direction * distance) / seconds_ahead\n    spaceship.linear_velocity = linear_velocity\n    var next_position = new_position + (linear_velocity * seconds_ahead)\n    return next_position\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func synchronize_rotation(new_rotation, synchronization_tic):\n    for tween in get_tree().get_processed_tweens():\n    tween.stop()\n    var future_rotation = predict_rotation(new_rotation, synchronization_tic)\n    spaceship.rotation = new_rotation\n    previous_rotation = new_rotation\n    ```", "```cpp\n    func predict_rotation(new_rotation, seconds_ahead):\n    var angular_velocity = lerp_angle(previous_rotation, new_rotation, 1.0) / second\n    s_ahead\n    spaceship.angular_velocity = angular_velocity\n    var next_rotation = spaceship.rotation + (angular_velocity * seconds_ahead)\n    return next_rotation\n    ```", "```cpp\n    func extrapolate_position(next_position, seconds_ahead):\n    ```", "```cpp\n    func extrapolate_position(next_position, seconds_ahead):\n         var tween = create_tween()\n         tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)\n         var tweener = tween.tween_property(spaceship, \"position\", next_position, seconds_ahead)\n         tweener.from(previous_position)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func synchronize_position(new_position, synchronization_tic):\n         for tween in get_tree().get_processed_tweens():\n              tween.stop()\n         var future_position = predict_position(new_position, synchronization_tic)\n         extrapolate_position(future_position, synchronization_tic)\n         spaceship.position = new_position\n         previous_position = new_position\n    ```", "```cpp\n    func extrapolate_rotation(target_rotation, seconds_ahead):\n         var tween = create_tween()\n         tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)\n         var tweener = tween.tween_property(spaceship, \"rotation\", target_rotation, secon\n    ds_ahead)\n         tweener.from(previous_rotation)\n    ```", "```cpp\n    @rpc(\"authority\", \"call_remote\")\n    func synchronize_rotation(new_rotation, synchronization_tic):\n         for tween in get_tree().get_processed_tweens():\n              tween.stop()\n         var future_rotation = predict_rotation(new_rotation, synchronization_tic)\n         extrapolate_rotation(future_rotation, synchronization_tic)\n         spaceship.rotation = new_rotation\n         previous_rotation = new_rotation\n    ```"]