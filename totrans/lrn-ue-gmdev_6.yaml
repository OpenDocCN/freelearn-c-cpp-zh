- en: Chapter 6. A Particle System and Sound
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：粒子系统与声音
- en: In this chapter, we will touch on the components of a game that are extremely
    important but often go unnoticed unless they are badly designed and out of place.
    Yes, we will cover particle system and sound in this chapter. In most games, they
    blend in so naturally that they are easily forgotten. They can also be used to
    create the most memorable moments in a game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将触及游戏组件中极其重要但往往被忽视的部分，除非它们设计不当或位置不当。是的，我们将在本章中涵盖粒子系统和声音。在大多数游戏中，它们融合得如此自然，以至于很容易被遗忘。它们也可以用来创造游戏中最难忘的时刻。
- en: Just to recap, particle systems are used very often to create sparks, explosions,
    smoke, rain, snow, and other similar effects in a game that are dynamic, kind
    of fuzzy, and random in nature. Sound can be in the form of ambient sounds, such
    as the sound of rustling leaves and wind, one-off sounds, such as a pan dropping
    in the kitchen, or repetitive sounds, such as the running steps of a character
    or even music playing on the radio. Sound can be used to set the mood of a game,
    alert the player to something that needs attention, and provide realism to a level
    to make a place come alive. Let's get started.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简单回顾一下，粒子系统常用于在游戏中创建火花、爆炸、烟雾、雨、雪和其他类似效果，这些效果是动态的、有点模糊且具有随机性。声音可以是环境声音，如树叶沙沙声和风声，一次性声音，如厨房里锅子掉落的声音，或重复性声音，如角色的跑步脚步声甚至收音机播放的音乐。声音可以用来设定游戏氛围，提醒玩家注意某些需要关注的事情，并为场景提供现实主义，使一个地方变得生动。让我们开始吧。
- en: What is a particle system?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是粒子系统？
- en: A particle system is a way to model fuzzy objects, such as rain, fire, clouds,
    smoke, and water, which do not have smooth, well-defined surfaces and are nonrigid.
    The system is an optimized method to achieve such fluid-looking and dynamic visual
    representations by controlling the movement, behavior, interaction, and look of
    many tiny geometry objects or sprites.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是一种模拟模糊物体（如雨、火、云、烟和水）的方法，这些物体没有平滑、明确的外表面，且是非刚性的。该系统通过控制许多小几何对象或精灵的运动、行为、交互和外观，实现了一种优化方法，以获得这种流畅和动态的视觉表现。
- en: Using a combination of different particles made of different shapes, sizes,
    materials, and textures, with different movement speeds, rotation direction/speeds,
    spawn rates, concentration, visibility duration, and many more factors, we are
    able to create a huge variety of dynamic complex systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用由不同形状、大小、材料和纹理组成的不同粒子，具有不同的运动速度、旋转方向/速度、生成率、浓度、可见持续时间等因素的组合，我们能够创建出大量动态复杂的系统。
- en: In this chapter, we will learn about the components of the particle system using
    Unreal's Particle System editor and Cascade editor and use these editors to create
    a few additions for your level.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用虚幻的粒子系统编辑器和Cascade编辑器来了解粒子系统的组件，并使用这些编辑器为您的场景创建一些附加内容。
- en: Exploring an existing particle system
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索现有的粒子系统
- en: We will start by first seeing what kind of particle systems we get in the default
    package of Unreal Engine 4\. Go to **Content Browser** | **Game** | **Particles**.
    There are a couple of particle systems that we can already drag and place in the
    level and check out how they look.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看看在虚幻引擎4的默认包中我们能得到什么样的粒子系统。转到**内容浏览器** | **游戏** | **粒子**。有几个粒子系统我们可以直接拖放到场景中，并查看它们的外观。
- en: 'To open a particle system, simply double-click on any of the systems. Let''s
    take a look at **P_Fire** together. Feel free to check out the rest of the systems
    as well. However, I will use this as an example to understand what we need in
    order to create a new particle system for our level. This screenshot shows **P_Fire**
    in the editor:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开粒子系统，只需双击任何一个系统。让我们一起来查看**P_Fire**。您可以随意查看其他系统。然而，我将使用这个例子来了解我们为了创建我们场景的新粒子系统需要什么。此截图显示了编辑器中的**P_Fire**：
- en: '![Exploring an existing particle system](img/B03679_06_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![探索现有的粒子系统](img/B03679_06_01.jpg)'
- en: On the left-hand side is **Viewport** where we can preview the particle system.
    On the right-hand side, in the **Emitters** tab, you can see several columns of
    boxes with **Flames** (twice), **Smoke**, **Embers**, and **Sparks** mentioned
    on top of each of the columns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧是**视口**，我们可以预览粒子系统。在右侧的**发射器**选项卡中，你可以看到几个带有**火焰**（两次）、**烟雾**、**火星**和**火花**字样的盒子列。
- en: Emitters can be thought of as separate components that make up the particle
    system, and you can give each emitter different properties depending on what you
    want to create. When you put a bunch of emitters together, you will see them combining
    to give you a whole visual effect. In this **P_Fire** particle system, you can
    see flames moving in an unpredictable manner with some sparks and embers floating
    around and smoke simulating a fire bursting into flames. In the next section,
    let's go through more concrete terminology that describes the particle system
    in Unreal Engine 4.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器可以被视为构成粒子系统的独立组件，你可以根据你想要创建的内容为每个发射器赋予不同的属性。当你将多个发射器组合在一起时，你会看到它们组合起来为你提供一个完整的视觉效果。在这个**P_Fire**粒子系统中，你可以看到火焰以不可预测的方式移动，伴随着一些火花和火星漂浮，烟雾模拟火焰爆发。在下一节中，我们将探讨更多具体的术语，这些术语描述了Unreal
    Engine 4中的粒子系统。
- en: The main components of a particle system
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统的主体组件
- en: 'Very briefly, the following paragraph (taken from the official Unreal 4 documentation
    that''s available online) very aptly describes the relationship between the different
    components that are used in particle systems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，以下段落（摘自在线可用的官方Unreal 4文档）非常恰当地描述了粒子系统中不同组件之间的关系：
- en: '*"Modules, which define particle behavior and are placed within...Emitters,
    which are used to emit a specific type of particle for an effect, and any number
    of which can be placed within a...Particle System, which is an asset available
    in the Content Browser, and which can then in turn be referenced by an...Emitter
    Actor, which is a placeable object that exists within your level, controlling
    where and how the particles are used in your scene.",*'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"模块，用于定义粒子行为，并放置在...发射器，用于发射特定类型的粒子以产生效果，可以在...粒子系统中放置任意数量的发射器，粒子系统是内容浏览器中可用的一项资产，然后可以反过来由...发射器演员引用，发射器演员是存在于你的关卡中的一个可放置对象，用于控制粒子在你的场景中如何使用。"* '
- en: Read this several times to make sure that you are clear on the relationship
    between the different components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 多次阅读以确保你对不同组件之间的关系有清晰的认识。
- en: So, as described in the earlier section where we looked at **P_Fire**, we know
    that the emitters are labelled as **Flames**, **Embers**, **Sparks**, **Smoke**,
    and so on. The different properties of each of the emitters are defined by adding
    modules, such as **Lifetime**, **Initial Velocity**, and so on, into them. Together,
    all the emitters make up a particle system. Lastly, when you place the emitters
    in your game level, you are, in fact, dragging the emitter actor, which references
    a particular particle system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们在前面关于**P_Fire**的描述中提到的，我们知道发射器被标记为**火焰**、**火星**、**火花**、**烟雾**等等。每个发射器的不同属性是通过向其中添加模块来定义的，例如**生命周期**、**初始速度**等等。所有发射器共同构成了一个粒子系统。最后，当你将发射器放置在游戏关卡中时，实际上你是在拖动引用特定粒子系统的发射器演员。
- en: Modules
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: The **Default Required** and **Spawn** modules are the modules that every emitter
    needs to have. There is also a long list of other optional modules that the Cascade
    Particle editor offers to customize your particle system. In the current version
    of the editor that I am using, I have the **Acceleration**, **Attractor**, **Beam**,
    **Camera**, **Collision**, **Color**, **Event**, **Kill**, **Lifetime**, **Location**,
    **Orbit**, **Orientation**, **Parameter**, **Rotation**, **Rotation Rate**, **Size**,
    **Spawn**, **SubUV**, **Vector Field**, and **Velocity** modules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认必需**和**生成**模块是每个发射器都需要拥有的模块。还有一长串其他可选模块，Cascade粒子编辑器提供这些模块以自定义你的粒子系统。在我使用的当前版本编辑器中，我有**加速度**、**吸引**、**光束**、**相机**、**碰撞**、**颜色**、**事件**、**杀死**、**生命周期**、**位置**、**轨道**、**方向**、**参数**、**旋转**、**旋转速率**、**大小**、**生成**、**子UV**、**矢量场**和**速度**模块。'
- en: We will cover a few of the frequently used modules from this long list of modules
    through a simple exercise that's based on **P_Fire**. I understand that it would
    be very boring and not very useful when grasping the basics here if I simply gave
    you all those definitions that you can find easily online. Instead, we will go
    through this section by customizing **P_Fire** to create a fireplace for our level.
    At the same time, we will go through the key values within the different modules
    that you can adjust. Thus, you can take a look at how these values impact the
    look of the particle system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个基于 **P_Fire** 的简单练习，从这长长的模块列表中涵盖一些常用的模块。我理解，如果我只是简单地给出您可以在网上轻易找到的所有定义，那么在这里掌握基础知识将会非常无聊且不太有用。相反，我们将通过自定义
    **P_Fire** 来创建我们关卡中的壁炉，从而进入这一节。同时，我们将了解不同模块中可以调整的关键值。这样，您可以看看这些值如何影响粒子系统的外观。
- en: For more detailed documentation on the definition of each module and parameter,
    you can refer to the Unreal 4 online documentation ([https://docs.unrealengine.com/latest/INT/Engine/Rendering/ParticleSystems/Reference/index.html](https://docs.unrealengine.com/latest/INT/Engine/Rendering/ParticleSystems/Reference/index.html)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每个模块和参数的定义的更详细文档，您可以参考 Unreal 4 在线文档（[https://docs.unrealengine.com/latest/INT/Engine/Rendering/ParticleSystems/Reference/index.html](https://docs.unrealengine.com/latest/INT/Engine/Rendering/ParticleSystems/Reference/index.html)）。
- en: 'The commonly used modules are listed as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的模块如下所示：
- en: '| Module | Key parameters it can control |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 它可以控制的键参数 |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Required** | Material used for the particles |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **必需** | 用于粒子的材质 |'
- en: '| **Spawn** | Rate and distribution of the spawn |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **生成** | 生成的速率和分布 |'
- en: '| **Initial Size** | Size of the initial particle |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **初始大小** | 初始粒子的尺寸 |'
- en: '| **Lifetime** | Time duration for which the particle stays visible |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **生命周期** | 粒子保持可见的时间长度 |'
- en: '| **Color Over Life** | Color of the particles over their lifetimes |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **生命周期中的颜色** | 粒子在其生命周期中的颜色 |'
- en: The design principles of a particle system
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统的设计原则
- en: The design principles of a particle system can be configured through a research
    and iterative creative process. Let's take a look at each one of them in the following
    section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统的设计原则可以通过研究和迭代创意过程进行配置。让我们在接下来的部分中逐一查看。
- en: Research
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 研究
- en: Details are probably key to designing a realistic particle system. Very often,
    creating a particle system lies in the realm of an artist as we need an artistic
    touch to create a visually appealing and somewhat realistic replica of the effect
    that we want to create.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 细节可能是设计逼真粒子系统的关键。通常，创建粒子系统属于艺术家的领域，因为我们需要艺术感来创建一个视觉上吸引人且在一定程度上逼真的效果复制品。
- en: 'For starters, it is good to research a little on what the actual effect looks
    like. Here are some steps to help you get started:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，研究一下实际效果看起来是什么样子是很好的。以下是一些帮助您开始的步骤：
- en: Identify the different components that are needed (break the particle effects
    down into the different components).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定所需的不同组件（将粒子效果分解为不同的组件）。
- en: Determine the relationship among the different components (the size of the particles
    that are relative to one another, spawn rate, lifetimes, and so on).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定不同组件之间的关系（相对大小的粒子、生成速率、生命周期等）。
- en: Next, look at other similar effects that are created in the **Computer Graphics**
    (**CG**) space. The reason for doing this is that sometimes, actual effects can
    be a little too monotonous, and there are many amazing visual effect people out
    there who you can learn from to spice things up a little. So, it is a great idea
    to spend a little time checking out what others have done already, rather than
    spending a whole lot of time experimenting and not getting what you want to achieve.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，看看在 **计算机图形学**（**CG**）空间中创建的其他类似效果。这样做的原因是，有时实际效果可能有点单调，而且有许多令人惊叹的视觉效果人员，您可以向他们学习，为效果增添一些活力。因此，花点时间检查一下别人已经做了什么，而不是花大量时间实验却得不到想要的结果，这是一个很好的主意。
- en: The iterative creative process
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代创意过程
- en: Creating the perfect looking particle system that you want usually involves
    quite a bit of tweaking and playing around with the parameters that you have.
    The key to doing this is knowing what parameters there are and what they affect.
    During the initial phase of design, you should also try adding or removing certain
    modules to see how they actually impact the overall look of the system. This does
    not mean that more is always better. Additionally, it is also wise to save backup
    copies of your iterations so that you can always go back to the previous versions
    easily.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你想要的完美外观的粒子系统通常需要相当多的调整和参数试验。做到这一点的关键是了解有哪些参数以及它们的影响。在设计初期阶段，你也应该尝试添加或删除某些模块，以了解它们实际上如何影响系统的整体外观。这并不意味着越多越好。此外，保存迭代备份副本也是明智之举，这样你就可以轻松地回到之前的版本。
- en: Being extremely proficient in creating the particle system, I think, involves
    a combination of good design planning, having the patience to iterate, and making
    small adjustments to get the look that you eventually want.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，在创建粒子系统方面非常熟练，涉及良好的设计规划、有耐心进行迭代以及进行小的调整以获得你最终想要的外观。
- en: Example – creating a fireplace particle system
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 – 创建壁炉粒子系统
- en: In this example, we will duplicate **P_Fire** and edit it to create a fire for
    a fireplace in the level. We will also change a part of the current level in which
    we have to place this new fireplace particle system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将复制**P_Fire**并编辑它以在级别中创建一个壁炉。我们还将更改当前级别的一部分，其中我们必须放置这个新的壁炉粒子系统。
- en: 'Go to **Content Browser** | **Particles**, select **P_Fire**, and duplicate
    it. Rename it `P_Fireplace`. This screenshot shows how **P_Fireplace** is created
    in the `Particles` folder:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**内容浏览器** | **粒子**，选择**P_Fire**并复制它。将其重命名为`P_Fireplace`。此截图显示了在`粒子`文件夹中创建**P_Fireplace**的方式：
- en: '![Example – creating a fireplace particle system](img/B03679_06_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 创建壁炉粒子系统](img/B03679_06_02.jpg)'
- en: 'Let''s open **Chapter5Level** and rename it `Chapter6Level` first. We will
    first add a fireplace structure to the level to set the context for this fireplace
    effect. This will help you follow the creation process better. This screenshot
    shows the original living room space:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开**Chapter5Level**并将其重命名为`Chapter6Level`。我们首先将在级别中添加一个壁炉结构，为这个壁炉效果设定上下文。这将帮助你更好地跟随创建过程。此截图显示了原始客厅空间：
- en: '![Example – creating a fireplace particle system](img/B03679_06_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 创建壁炉粒子系统](img/B03679_06_03.jpg)'
- en: 'The following screenshot shows the modified living room space with a fireplace:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有壁炉的修改后的客厅空间：
- en: '![Example – creating a fireplace particle system](img/B03679_06_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 创建壁炉粒子系统](img/B03679_06_04.jpg)'
- en: 'This screenshot shows a zoomed in version of the fireplace structure if you
    intend to construct it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算构建它，此截图显示了壁炉结构的放大版本：
- en: '![Example – creating a fireplace particle system](img/B03679_06_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 创建壁炉粒子系统](img/B03679_06_05.jpg)'
- en: 'Zooming in on the metal vents will look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 放大金属通风口将看起来像这样：
- en: '![Example – creating a fireplace particle system](img/B03679_06_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 创建壁炉粒子系统](img/B03679_06_06.jpg)'
- en: 'What we did here was delete the lights and low cabinet structure and replaced
    it with this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是删除灯光和低柜结构，并用这个替换：
- en: '**TopWoodPanel** (material: **M_Wood_Walnut**): X = 120, Y = 550, Z = 60'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TopWoodPanel**（材料：**M_Wood_Walnut**）：X = 120, Y = 550, Z = 60'
- en: 'Concrete pillars around the glass (material: **M_Brick_Cut_Stone**)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玻璃周围的混凝土柱（材料：**M_Brick_Cut_Stone**）
- en: '**ConcretePillar_L** and **ConcretePillar_R**: X = 100, Y = 150, Z = 220'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConcretePillar_L**和**ConcretePillar_R**：X = 100, Y = 150, Z = 220'
- en: '**ConcretePillar_Top**: X = 100, Y = 250, Z = 100'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConcretePillar_Top**：X = 100, Y = 250, Z = 100'
- en: 'Fireplace glass and inside (material: **M_Glass**)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 壁炉玻璃和内部（材料：**M_Glass**）
- en: '**Fireglass**: X = 5, Y = 250, Z = 120'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fireglass**：X = 5, Y = 250, Z = 120'
- en: '**MetalPanel** and **MetalPanel_Subtractive**: X = 40, Y = 160, Z = 10'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MetalPanel**和**MetalPanel_Subtractive**：X = 40, Y = 160, Z = 10'
- en: '**FireVent1** to **FireVent5**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FireVent1**到**FireVent5**'
- en: 'Use the BSP subtractive cylinder with the following setting, as shown in the
    following screenshot. Here, **Z** is **10**, **Outer Radius** is **3**, and **Sides**
    is **8**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下设置的 BSP 减法圆柱体，如图所示。在这里，**Z** 是 **10**，**外半径** 是 **3**，**侧面** 是 **8**：
- en: '![Example – creating a fireplace particle system](img/B03679_06_07.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 创建壁炉粒子系统](img/B03679_06_07.jpg)'
- en: 'The lower extended structure (made up of two BSPs) consists of the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下方扩展结构（由两个 BSP 组成）包括以下内容：
- en: '**Thinner extension platform**: X = 140, Y = 550, Z = 10'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较薄的扩展平台**：X = 140，Y = 550，Z = 10'
- en: '**Thicker base**: X = 120, Y = 550, Z = 30'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较厚的底部**：X = 120，Y = 550，Z = 30'
- en: Crafting P_Fireplace
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作**P_Fireplace**
- en: 'Now, double-click on **P_Fireplace** to open up the Cascade Particle System
    editor. Since we duplicated it from **P_Fire**, it has the same emitters as **P_Fire**:
    the two **Flame**, one **Smoke**, one **Sparks**, one **Embers**, and one **Distortion**
    module.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，双击**P_Fireplace**以打开级联粒子系统编辑器。由于我们从**P_Fire**中复制了它，它具有与**P_Fire**相同的发射器：两个**火焰**，一个**烟雾**，一个**火花**，一个**火星**和一个**扭曲**模块。
- en: Observe the current viewport. What do you see? The original **P_Fire** effect
    is more like a sequence of random bursts of flames that disappear pretty quickly
    after the initial burst. What kind of fire do we need for the fireplace that we
    have created? We need more or less continuous and slower moving flames that hover
    in a fixed position.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 观察当前视口。你看到了什么？原始的**P_Fire**效果更像是随机爆发的火焰序列，在初始爆发后很快消失。我们为创建的壁炉需要什么样的火焰？我们需要更多或更少的连续且移动较慢的火焰，这些火焰在固定位置悬浮。
- en: With this difference and objective in mind, we will next determine which of
    the components of **P_Fire** we want to keep as our fire effect for the fireplace.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这种差异和目标意识，我们接下来将确定我们想要保留哪些**P_Fire**组件作为壁炉的火焰效果。
- en: Observing the solo emitters of the system
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察系统的单个发射器
- en: 'Using the solo button and checkbox in each of the modules, toggle **S** on
    or off, and alternatively mark/unmark the checkbox to observe the individual components.
    This screenshot shows you the location of the solo button and checkbox:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个模块中的单独按钮和复选框，切换**S**的开关，并交替标记/取消标记复选框以观察单个组件。此截图显示了单独按钮和复选框的位置：
- en: '![Observing the solo emitters of the system](img/B03679_06_08.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![观察系统的单个发射器](img/B03679_06_08.jpg)'
- en: Deleting non-essential emitters
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除非必要发射器
- en: The first step was to delete the second **Flame** emitter (the first being the
    left-most) and the **Smoke** emitter. The reason for this was, I think, so that
    I could work with a single flame to create a fire for the fireplace. The **Smoke**
    emitter was removed mainly because of it is a gas/electric fire; thus, I would
    expect less smoke. You could alternatively unmark the checkbox at the top of the
    window to hide the entire emitter first before deleting it permanently.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是删除第二个**火焰**发射器（第一个是最左侧的）和**烟雾**发射器。我认为这样做的原因是，我可以使用单个火焰来为壁炉创建火焰效果。删除**烟雾**发射器主要是因为这是一个气/电火焰；因此，我预计烟雾会少一些。你也可以选择先取消勾选窗口顶部的复选框，隐藏整个发射器，然后再永久删除它。
- en: Focusing on editing the Flame emitter
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专注于编辑火焰发射器
- en: 'Keeping the only **Flame** emitter, the flame was still appearing at random
    spots within a certain radius and then disappearing quickly after that. We will
    address each of the issues here one by one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保留唯一的**火焰**发射器，火焰仍然在某个半径内的随机位置出现，然后很快消失。我们将逐一解决以下问题：
- en: '**Configure Lifetime**: So, since we need to have the fire burning continuously
    instead of in short bursts, I will first adjust the **Lifetime** property so that
    the fire burns for a longer period of time before disappearing. Change **Distribution
    Float Uniform**, with **Min** kept as **0.7**, **Max** as **1.0**, and **Distribution
    Constant** as **1.2**.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置寿命**：因此，由于我们需要让火焰持续燃烧而不是短时间爆发，我将首先调整**寿命**属性，以便火焰在消失之前燃烧更长的时间。将**分布浮点均匀**设置为**最小值**为**0.7**，**最大值**为**1.0**，**分布常数**为**1.2**。'
- en: '**Remove Const Accleration+**: Now, the flame lingers longer on screen before
    disappearing. However, the flames seem to be drifting away from the spawn location
    after they are spawned. For a fireplace, flames more or less remain in the same
    location. So, I turn off **Const Acceleration+** in the **Flames** module by unmarking
    the checkbox. The flames now seem to be moving away from the spawn location a
    lot less.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除恒定加速度+**：现在，火焰在屏幕上停留的时间更长，然后消失。然而，火焰似乎在生成后从生成位置漂移。对于一个壁炉，火焰大致保持在相同的位置。因此，我在**火焰**模块中取消勾选复选框以关闭**恒定加速度+**。现在，火焰似乎很少从生成位置漂移。'
- en: '**Remove Initial Velocity**: After removing the acceleration module, it still
    seems like the flames are moving away; my guess for this is that the particles
    had some initial velocity, and so I turned off this module to confirm my suspicion
    and it seemed to work.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除初始速度**：在移除加速度模块后，火焰看起来仍然像是在远离；我猜测这是因为粒子有一些初始速度，所以我关闭了这个模块来证实我的怀疑，并且看起来效果不错。'
- en: '**Configure Spawn**: The flames looked quite sparse as they are small, and
    this creates some blank space within the spawn area during short intervals. I
    could adjust the size of the flame to make it bigger, but when I did this, the
    flame looked too distorted. So, I decided to increase the spawn rate instead so
    that more flames could occur per minute. Change the spawn rate for **Rate Scale
    Distribution** from **5.0** to **20.0**. Increase **Distribution Float Constant**
    from **1.0** to **3.0**.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置生成**：由于火焰很小，看起来相当稀疏，这会在短时间内生成区域内产生一些空白空间。我可以调整火焰的大小使其更大，但当我这样做时，火焰看起来过于扭曲。所以，我决定增加生成率，这样每分钟就能产生更多的火焰。将**速率缩放分布**的**5.0**改为**20.0**。将**分布浮点常数**从**1.0**增加到**3.0**。'
- en: Looking at the complete particle system
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看完整的粒子系统
- en: Now, I've turned the other emitters back on again to look at the whole particle
    system effect and also see if it requires more editing. It looks pretty okay for
    a fireplace fire now so I've stopped here. Feel free to go ahead and adjust the
    other properties to improve the design. These are the very basics of modifying
    an existing particle system, and I hope you have familiarized yourself with the
    particle system editor through this exercise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经重新开启了其他发射器，以查看整个粒子系统效果，并看看是否需要更多的编辑。现在看起来作为壁炉火焰已经相当不错了，所以我在这里停止了。请随意调整其他属性以改进设计。这些都是修改现有粒子系统的基本方法，我希望你通过这次练习已经熟悉了粒子系统编辑器。
- en: Sound and music
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音和音乐
- en: 'Sound and music are an essential part of the game experience. Ever watched
    television with the volume switched off? Just watching subtitles and lip movements
    is not enough. You want to hear what the character on the screen is saying and
    how they are saying it. For games, it is pretty much similar, and on top of this,
    pretty often, you get cues through the sound and music. If you have played *Alien:
    Isolation*, you need to listen to the sounds in the game to know whether you have
    an alien coming in your direction. This can be a matter of life and death in the
    game. It pretty much determines whether you end up as a winner or simply a delicious
    meal for the alien. So, are we ready now to learn how sound and music are created
    for games, and how we use the Unreal Editor to incorporate them into our game
    level?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 声音和音乐是游戏体验的重要组成部分。你有没有看过电视，音量调到静音？仅仅看字幕和唇语是不够的。你想要听到屏幕上的人物在说什么，以及他们是如何说的。对于游戏来说，情况基本上是相似的，而且，通常，你会通过声音和音乐获得提示。如果你玩过《异形：隔离》，你需要听游戏中的声音来判断是否有异形朝你这边靠近。这在游戏中可能是生死攸关的事情。这基本上决定了你最终是成为赢家还是成为异形的美食。那么，我们现在准备好学习如何为游戏制作声音和音乐，以及如何使用虚幻引擎编辑器将它们整合到我们的游戏关卡中了吗？
- en: How do we produce sound and music for games?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何为游戏制作声音和音乐？
- en: Many game productions have original music written for in-game scenarios; some
    also use actual songs sung by professional singers as theme songs. Music in games
    is a big thing and it's dearly remembered by fans of the game. Sometimes, the
    music itself is enough to trigger memories of the gaming experience. Thus, game
    studios need to spend time creating suitable music to complement their games.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏制作都有专为游戏场景编写的原创音乐；一些游戏还使用专业歌手演唱的实际歌曲作为主题曲。游戏中的音乐非常重要，并且被游戏粉丝深深记住。有时，音乐本身就足以唤起游戏体验的记忆。因此，游戏工作室需要花时间创作合适的音乐来补充他们的游戏。
- en: If you are a huge fan of video game music, there are also concerts that you
    can go to where the orchestra plays music from popular games (check out Video
    Games Live at [http://www.videogameslive.com/index.php?s=home](http://www.videogameslive.com/index.php?s=home)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个视频游戏音乐的超级粉丝，你也可以去参加音乐会，那里管弦乐队演奏流行游戏的音乐（查看[Video Games Live](http://www.videogameslive.com/index.php?s=home)）。
- en: Creating music for a game is very similar to composing music for a piece; it
    should trigger appropriate emotions when it's played. The choice of music needs
    to match the pace and situations of the game. Using a JRPG game as an example,
    you should be able to differentiate between in-battle music versus the music that's
    played when you are in a menu, loading the game, or when you've just won a battle.
    Very often, music is created on the basis of the needs of the game, and the music
    composer has to probably come up with a few different versions and let the team
    and/or management review it before the best piece is selected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏创作音乐与为作品创作音乐非常相似；当它播放时，应该激发适当的情感。音乐的选择需要与游戏的节奏和情境相匹配。以JRPG游戏为例，你应该能够区分战斗音乐和你在菜单中、加载游戏时或刚刚赢得战斗时播放的音乐。通常，音乐是根据游戏的需求创作的，音乐作曲家可能需要提出几个不同的版本，并让团队和/或管理层审查，然后选择最佳作品。
- en: If you do not intend to create original music or sound for your game, you can
    find many free downloadable sounds and music online these days. When using free
    online music and sounds, do ensure that you do not violate any digital rights
    or copyrights when incorporating them in your game.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有打算为你的游戏创作原创音乐或声音，现在网上可以找到许多免费下载的声音和音乐。在使用免费在线音乐和声音时，务必确保在将它们融入你的游戏中时，没有违反任何数字版权或版权。
- en: Audio quality
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音质
- en: The reason why we are discussing audio quality is because sound quality, like
    image quality, is of huge importance these days. We already use the 4K resolution
    image quality today, and there will be more devices and games that would support
    this in the future. How about sounds? The listening experience needs to match
    the quality of the image and provide more than just mono or stereo sounds. Sound
    experience has also progressed to multichannel surround sound, starting at 5.1,
    7.1, and beyond these days, to obtain a life-like immersive audio experience.
    This is definitely something to think about when creating, storing, and playing
    audio files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论音质的原因是因为音质，就像图像质量一样，在当今社会非常重要。我们今天已经使用了4K分辨率的图像质量，未来将有更多设备和游戏支持这一标准。那么声音呢？听觉体验需要与图像质量相匹配，并不仅仅是提供单声道或立体声声音。声音体验也已经发展到多声道环绕声，从5.1、7.1开始，现在甚至更高级，以获得逼真的沉浸式音频体验。这绝对是在创建、存储和播放音频文件时需要考虑的事情。
- en: How are sounds recorded?
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音是如何录制的？
- en: Sounds are generated in the form of analog waves, which are continuous waves,
    which you'll see shortly in the upcoming figure. We can record surround sound
    through a recording device. For multichannel sound recording, you need to have
    certain methods to record music that can use a simple recording setup known as
    **Deca Tree**. Here, microphones are placed in a particular fashion to capture
    sounds from the left, right, front, and back of the source. There are also many
    processing techniques that can filter and convert sounds that are recorded to
    mimic the various components needed for each of the channels.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 声音以模拟波的形式产生，是连续的波，你将在接下来的图中看到。我们可以通过录音设备录制环绕声。对于多声道录音，你需要有某些方法来录制可以使用简单录音设置的音乐，这种设置被称为**十点树**。在这里，麦克风以特定的方式放置，以捕捉来自源头的左、右、前和后的声音。还有许多处理技术可以过滤和转换录制的声音，以模仿每个通道所需的各个组成部分。
- en: We take samples of the analog sound waves that are produced by a piano at close
    intervals (the rate at which the samples are taken between intervals is known
    as sampling frequency). The process of taking samples from analog waves to store
    them digitally is known as **Pulse Code Modulation** (**PCM**). These samples
    can be stored in uncompressed PCM-like formats or be compressed into a smaller
    and more manageable file size using audio compression techniques. Wav, MP3, Ogg
    Vorbis, Dolby TrueHD, and DTS-HD are some of the formats that audio is commonly
    saved as. Ideally, we want to save audio into a lossless compressed format so
    that we get a small manageable file that contains amazing sounds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以接近的时间间隔（采样频率即为采样间隔的速率）采集钢琴产生的模拟声波样本。从模拟波中采集样本以数字方式存储的过程称为**脉冲编码调制**（**PCM**）。这些样本可以存储在未压缩的PCM类似格式中，或者使用音频压缩技术压缩成更小、更易于管理的文件大小。Wav、MP3、Ogg
    Vorbis、Dolby TrueHD和DTS-HD是音频通常保存的一些格式。理想情况下，我们希望将音频保存到无损压缩格式中，以便我们得到一个包含惊人声音的小型可管理文件。
- en: When the digital format of the sound is played back, the analog sound wave is
    reconstructed using the stored information. Close resemblance to the original
    analog sound waves is one way to ensure sounds of good quality. By increasing
    the number of channels to create a 3D sound effect using the basic 5.1 surround,
    which requires five speakers, one for front left, one front right, one center,
    one back left (as surround), one back right (as surround) and a subwoofer, also
    greatly improves the listening experience.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当播放数字格式的声音时，使用存储的信息重建模拟声音波。与原始模拟声音波非常相似是确保声音质量良好的方法之一。通过增加通道数量，使用基本的5.1环绕声创建3D音效，这需要五个扬声器，一个用于前左，一个用于前右，一个用于中心，一个用于后左（作为环绕），一个用于后右（作为环绕）和一个低音炮，也极大地改善了听觉体验。
- en: The Unreal audio system
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unreal音频系统
- en: We now have a general understanding of why we need audio in games and how it's
    created and recorded. Let's learn about the Unreal audio system and the editor
    that can be used to import these audio files into the game, and we'll also learn
    about the tools that can be used to edit and control playbacks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对为什么游戏需要音频以及它是如何创建和录制的有了基本的了解。让我们了解Unreal音频系统以及可以用来将这些音频文件导入游戏的编辑器，我们还将了解可以用来编辑和控制播放的工具。
- en: Getting audio into Unreal
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将音频导入Unreal
- en: How do we get the audio files into Unreal? What do you need to take note of?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将音频文件导入Unreal？需要注意哪些事项？
- en: The audio format
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频格式
- en: Unreal supports the importing of sounds only in the `.wav` format. The `.wav`
    format is a widely used format that can store raw uncompressed sound data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal仅支持导入`.wav`格式的声音。`.wav`格式是一种广泛使用的格式，可以存储原始未压缩的声音数据。
- en: The sampling rate
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采样率
- en: The sampling rate is recommended at 44100 Hz or 22050 Hz. As mentioned earlier,
    the sampling rate determines how often the analog wave is recorded. The higher
    the frequency (measured in Hertz or Hz), the more data points of the analog wave
    that are collected, which aids in a better reconstruction of the wave.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的采样率为44100 Hz或22050 Hz。如前所述，采样率决定了模拟波记录的频率。频率越高（以赫兹或Hz计），收集的模拟波数据点越多，这有助于更好地重建波形。
- en: Bit depth
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位深度
- en: 'The bit depth is set as 16\. It determines the granularity at which the amplitude
    of the audio wave can be recorded, which is also known as the resolution of the
    sound. For a bit depth of 16, you can get up to 65,536 integer values (216). The
    reason why we are concerned with the bit depth is because during the sampling
    process of the analog waves, the actual value of the amplitude of the wave is
    approximated to one of the integer values that can be stored based on the bit
    depth. The following figure shows two different bit depths. The figure on the
    left-hand side illustrates when the bit depth is low, and the signal is more inaccurately
    sampled because it is sampled in larger increments. The figure on the right-hand
    side illustrates when the bit depth is higher, and it can be sampled at smaller
    increments, resulting in a more accurate representation of the wave:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 位深度设置为16。它决定了音频波振幅可以记录的粒度，也称为声音的分辨率。对于16位的位深度，可以得到高达65,536个整数值（2^16）。我们之所以关注位深度，是因为在模拟波的采样过程中，波振幅的实际值被近似为基于位深度可以存储的某个整数值。以下图显示了两种不同的位深度。左侧的图显示了位深度低时，信号采样不准确，因为它以较大的增量进行采样。右侧的图显示了位深度高时，可以以较小的增量进行采样，从而更准确地表示波形：
- en: '![Bit depth](img/B03679_06_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![位深度](img/B03679_06_09.jpg)'
- en: The loss in accuracy of the representation of the wave can be termed as a quantization
    error. When the bit depth is too low, the quantization error is high.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 波形表示精度损失可以称为量化误差。当位深度太低时，量化误差会很高。
- en: The **Signal to Quantization Noise Ratio** (**SQNR**) is the measurement used
    to determine the quality of this conversion. It is calculated using the ratio
    between the maximum nominal signal strength and the quantization error. The better
    the ratio, the better the conversion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**信噪比**（**SQNR**）是用于确定这种转换质量的测量方法。它是通过最大标称信号强度与量化误差之间的比率来计算的。比率越好，转换质量越好。'
- en: Supported sound channels
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的声音通道
- en: Unreal currently supports channels such as mono, stereo, 2.1, 4.1, 5.1 6.1,
    and 7.1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal目前支持单声道、立体声、2.1、4.1、5.1、6.1和7.1等通道。
- en: When importing files into Unreal, take note of the file naming convention that
    is in place so that the right sound is played from the right channel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当将文件导入虚幻引擎时，请注意文件命名约定，以确保正确的声音从正确的声道播放。
- en: 'The following table shows the 7.1 surround sound configuration with all the
    file naming conventions that are necessary for the correct playback:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了7.1环绕声配置以及所有必要的文件命名约定，以确保正确播放：
- en: '| **Speakers** | Front-left |   | Front-center |   | Front-right |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **扬声器** | 前左 |   | 前中 |   | 前右 |'
- en: '| **Extension** | `_fl` |   | `_fc` |   | `_fr` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | `_fl` |   | `_fc` |   | `_fr` |'
- en: '|   |   |   |   |   |   |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **Speakers** | Side-left |   | Low frequency (commonly known as subwoofer)
    |   | Side-right |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **扬声器** | 左侧 |   | 低频（通常称为低音炮） |   | 右侧 |'
- en: '| **Extension** | `_sl` |   | `_lf` |   | `_sr` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | `_sl` |   | `_lf` |   | `_sr` |'
- en: '|   |   |   |   |   |   |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **Speakers** | Back-left |   |   |   | Back-right |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **扬声器** | 后左 |   |   |   | 后右 |'
- en: '| **Extension** | `_bl` |   |   |   | `_br` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | `_bl` |   |   |   | `_br` |'
- en: 'This table shows you the files that are used for the 5.1 surround system:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了用于5.1环绕声系统的文件：
- en: '| **Speakers** | Front-left |   | Front-center |   | Front-right |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **扬声器** | 前左 |   | 前中 |   | 前右 |'
- en: '| **Extension** | `_fl` |   | `_fc` |   | `_fr` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | `_fl` |   | `_fc` |   | `_fr` |'
- en: '|   |   |   |   |   |   |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **Speakers** | Side-left |   | Low frequency (commonly known as subwoofer)
    |   | Side-right |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **扬声器** | 左侧 |   | 低频（通常称为低音炮） |   | 右侧 |'
- en: '| **Extension** | `_sl` |   | `_lf` |   | `_sr` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | `_sl` |   | `_lf` |   | `_sr` |'
- en: 'This table shows you the files that are used for the 4.0 system:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了用于4.0系统的文件：
- en: '| **Speakers** | Front-left |   |   |   | Front-right |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **扬声器** | 前左 |   |   |   | 前右 |'
- en: '| **Extension** | `_fl` |   |   |   | `_fr` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | `_fl` |   |   |   | `_fr` |'
- en: '|   |   |   |   |   |   |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **Speakers** | Side-left |   |   |   | Side-right |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **扬声器** | 左侧 |   |   |   | 右侧 |'
- en: '| **Extension** | `_sl` |   |   |   | `_sr` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | `_sl` |   | `_lf` |   | `_sr` |'
- en: Unreal sound formats and terminologies
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚幻引擎声音格式和术语
- en: 'There are a couple of terms in the Unreal Sound system that we need to get
    acquainted with:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎声音系统中，有几个术语我们需要熟悉：
- en: '**Sound waves**: These are the actual audio files that are in the `.wav` format.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声音波**：这些是实际以`.wav`格式存在的音频文件。'
- en: '**Sound cues**: This is the control system for a sound wave file. Sound cues
    are what we use to manipulate the volume, start, and end of the sound waves. So,
    in order to control how an audio file is played in the game, you can edit the
    properties on the Sound Cue, which, in turn, affects the wave file or files that
    it is associated with.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声音提示**：这是声音波文件的控制系统。声音提示是我们用来操纵声音波音量、开始和结束的工具。因此，为了控制音频文件在游戏中的播放方式，您可以在声音提示上编辑属性，这反过来会影响与之关联的波形文件或文件。'
- en: '**Ambient Sound Actor**: This is the class actor that you add to the game level.
    This actor is associated with the Sound Cue to play the audio files that you need
    for the game.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境声音演员**：这是您添加到游戏关卡中的类演员。此演员与声音提示相关联，以播放您为游戏所需的音频文件。'
- en: Now, we are ready to use the Sound Editor in Unreal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好在虚幻引擎中使用声音编辑器。
- en: The Sound Cue Editor
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音提示编辑器
- en: Since we are not editing the actual audio file per se, the sound editor in Unreal
    is known as the Sound Cue Editor. We are, in fact, editing the way the sound can
    be played through a control device known as a Sound Cue.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并非编辑实际的音频文件，因此虚幻引擎中的声音编辑器被称为声音提示编辑器。实际上，我们正在编辑通过称为声音提示的控制设备播放声音的方式。
- en: Let's learn more about the functionalities of the Sound Cue Editor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解声音提示编辑器的功能。
- en: How to open the Sound Cue Editor
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何打开声音提示编辑器
- en: 'Go to **Content Browser** | **Audio**. Go to any Sound Cue file, and double-click
    to open the Sound Cue Editor. This screenshot shows where I could find a Sound
    Cue in **Content Browser**:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**内容浏览器** | **音频**。打开任何声音提示文件，双击以打开声音提示编辑器。此截图显示了在**内容浏览器**中找到声音提示的位置：
- en: '![How to open the Sound Cue Editor](img/B03679_06_10.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![如何打开声音提示编辑器](img/B03679_06_10.jpg)'
- en: 'When you double-click on a Sound Cue, the Sound Cue Editor opens up, and it
    looks quite a lot like the Blueprint Editor with modules and lines. This screenshot
    shows you what the Sound Cue Editor for **Collapse_Cue** looks like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当您双击声音提示时，声音提示编辑器会打开，其外观与蓝图编辑器非常相似，具有模块和线条。此截图显示了**Collapse_Cue**的声音提示编辑器的外观：
- en: '![How to open the Sound Cue Editor](img/B03679_06_11.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何打开声音提示编辑器](img/B03679_06_11.jpg)'
- en: 'Notice that in the preceding screenshot **Collapse_Cue** it has two inputs
    called **Wave Player: Collapse 01** and **Wave Player: Collapse 02**. These are
    joined to a **Random** node, and the output goes to the final node known as **Output**.
    What this does is that when this Sound Cue is played, one of the two collapse
    sounds gets randomly selected and is played. This creates a variety when sounds
    are played in the same circumstance; they are both collapse sound effects but
    slightly different.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，在前面的屏幕截图 **Collapse_Cue** 中，它有两个输入，分别称为 **Wave Player: Collapse 01** 和 **Wave
    Player: Collapse 02**。这些输入连接到一个 **Random** 节点，输出连接到最后一个节点，称为 **Output**。这样做的作用是，当播放这个声音提示时，两个折叠声音中的一个会被随机选择并播放。这为在相同情况下播放的声音创造了多样性；它们都是折叠声音效果，但略有不同。'
- en: We will learn more about the components that we could use to design the Sound
    Cues later. We'll also go through an exercise later to create our own Sound Cue
    in the editor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后了解更多关于我们可以用来设计声音提示的组件。我们还将进行一个练习，在编辑器中创建自己的声音提示。
- en: Exercise – importing a sound into the Unreal Editor
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 – 将声音导入到虚幻编辑器中
- en: You may come across a situation where you have created your own audio effect
    file and want to use it in the game. We will first start by importing this file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到这样的情况，你创建了自己的音频效果文件，并想在游戏中使用它。我们将首先从导入这个文件开始。
- en: For this exercise, I have used an audio clip downloaded from a Wikipedia site
    ([https://en.wikipedia.org/wiki/The_Four_Seasons_(Vivaldi)](https://en.wikipedia.org/wiki/The_Four_Seasons_(Vivaldi)))
    with a Vivaldi piece from The Four Seasons. This is shared by John Harrison.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我使用了一个从维基百科网站下载的音频剪辑（[https://en.wikipedia.org/wiki/The_Four_Seasons_(Vivaldi)](https://en.wikipedia.org/wiki/The_Four_Seasons_(Vivaldi)))，其中包含维瓦尔第的《四季》作品。这是由
    John Harrison 分享的。
- en: This file is in the Oggs format, and yes, Unreal only supports `.wav` files.
    First, I converted the file type from `.ogg` to `.wav` using software that's listed
    on the Vorbis website at [http://vorbis.com/software/](http://vorbis.com/software/).
    Be careful about the WAV file settings that Unreal is expecting it to be in.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是 Oggs 格式，是的，虚幻引擎只支持 `.wav` 文件。首先，我使用 Vorbis 网站上列出的软件将文件类型从 `.ogg` 转换为 `.wav`（[http://vorbis.com/software/](http://vorbis.com/software/)）。请注意
    Unreal 对 WAV 文件设置的要求。
- en: 'After getting the right wav file, we are ready to import it into the Sound
    Editor. Go to **Content Browser** | **Content** | **Audio**, right-click on it
    to display the contextual menu, navigate to **New Asset** | **Import to /Game/Audio**,
    and browse to the folder where you saved the `.wav` file and select it. This screenshot
    shows where you can find the function in the editor to import the `.wav` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得正确的 wav 文件后，我们就可以将其导入到声音编辑器中。转到 **内容浏览器** | **内容** | **音频**，右键单击以显示上下文菜单，导航到
    **新建资产** | **导入到 /Game/Audio**，然后浏览到保存 `.wav` 文件的文件夹并选择它。这张截图显示了在编辑器中找到导入 `.wav`
    文件功能的位置：
- en: '![Exercise – importing a sound into the Unreal Editor](img/B03679_06_12.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 将声音导入到虚幻编辑器中](img/B03679_06_12.jpg)'
- en: 'This screenshot shows you how the Vivaldi WAV file is successfully imported
    as a sound wave in the `Audio` folder with the WAV file settings:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了如何将 Vivaldi WAV 文件成功导入到 `Audio` 文件夹中，并使用 WAV 文件设置：
- en: '![Exercise – importing a sound into the Unreal Editor](img/B03679_06_13.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 将声音导入到虚幻编辑器中](img/B03679_06_13.jpg)'
- en: 'Next, create a Sound Cue for the Vivaldi sound wave that we have just imported.
    To recap, a Sound Cue is used to control the playback of the sound wave file.
    A sound wave file merely has the contents of the audio file. Right-click on the
    sound wave asset, as shown in this screenshot, and select **Create Cue** in the
    contextual menu:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为刚刚导入的维瓦尔第声音波形创建一个声音提示。为了回顾，声音提示用于控制声音波形文件的播放。声音波形文件仅包含音频文件的内容。如截图所示，右键单击声音波形资产，在上下文菜单中选择
    **创建提示**：
- en: '![Exercise – importing a sound into the Unreal Editor](img/B03679_06_14.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 将声音导入到虚幻编辑器中](img/B03679_06_14.jpg)'
- en: Double-click on the newly created Sound Cue (which has a default name with the
    same name as the sound wave file with a `Cue` suffix). In the example here, it
    will be `Vivaldi_Spring_Allegro_ByJohnHarrison_Cue`. Double-click on this Cue
    to view the contents. The following screenshot shows the contents of `Vivaldi_Spring_Allegro_ByJohnHarrison_Cue`.
    The wave player output is connected directly to **Output**. This is the simplest
    connection for a Sound Cue where we input the wave to the **Output**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 双击新创建的声音提示（其默认名称与声音波形文件同名，并带有`Cue`后缀）。在此例中，它将是`Vivaldi_Spring_Allegro_ByJohnHarrison_Cue`。双击此提示以查看内容。以下截图显示了`Vivaldi_Spring_Allegro_ByJohnHarrison_Cue`的内容。波形播放器的输出直接连接到**输出**。这是声音提示中最简单的连接，我们将波形输入到**输出**。
- en: '![Exercise – importing a sound into the Unreal Editor](img/B03679_06_15.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 将声音导入Unreal编辑器](img/B03679_06_15.jpg)'
- en: Now, let's hear the sound we have imported. Within the Sound Cue Editor, look
    for the **Play Cue** button in the top-left corner of the editor. Take a look
    at the following screenshot for location of the button. After clicking the button,
    you would hear the music we have just imported. You have just successfully imported
    a custom wave file into Unreal. Now, let's transfer it to the game level.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们听听我们导入的声音。在声音提示编辑器中，查找编辑器左上角的**播放提示**按钮。查看以下截图以确定按钮的位置。点击按钮后，你会听到我们刚刚导入的音乐。你刚刚成功地将自定义波形文件导入到Unreal中。现在，让我们将其转移到游戏关卡中。
- en: '![Exercise – importing a sound into the Unreal Editor](img/B03679_06_16.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 将声音导入Unreal编辑器](img/B03679_06_16.jpg)'
- en: Exercise – adding custom sounds to a level
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 – 向关卡添加自定义声音
- en: In order to place sound in the level, you need to use the **Ambient Sound**
    node to associate it with a sound cue, which would, in turn, play the audio files.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在关卡中放置声音，你需要使用**环境声音**节点将其与声音提示关联，这将反过来播放音频文件。
- en: 'To create an **Ambient Sound** node, go to **Modes** | **All Classes**, drag
    and drop **Ambient Sound** into the game level:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**环境声音**节点，转到**模式** | **所有类**，将**环境声音**拖放到游戏关卡中：
- en: '![Exercise – adding custom sounds to a level](img/B03679_06_17.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 向关卡添加自定义声音](img/B03679_06_17.jpg)'
- en: Click on the Ambient Sound Actor that you have just placed into the level, and
    rename it `AmbientSound_Vivaldi`. In the **Details** panel, scroll to the **Sound**
    section, click on the arrow next to **Sound** to display the sound assets that
    you have in the game level packages, as shown in the following screenshot. Select
    **Vivaldi_Spring_Allegro_ByJohnHarrison_Cue**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 点击你刚刚放置到关卡中的环境声音演员，并将其重命名为`AmbientSound_Vivaldi`。在**详细信息**面板中，滚动到**声音**部分，点击**声音**旁边的箭头以显示你在游戏关卡包中的声音资产，如下面的截图所示。选择**Vivaldi_Spring_Allegro_ByJohnHarrison_Cue**。
- en: '![Exercise – adding custom sounds to a level](img/B03679_06_18.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 向关卡添加自定义声音](img/B03679_06_18.jpg)'
- en: Check whether you can still hear the music by clicking on the **Play** button
    in the **Details** panel of **AmbientSound_Vivaldi**. Now, let's build the level
    and run it. Notice that the music plays when you start the level.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**AmbientSound_Vivaldi**的**详细信息**面板中的**播放**按钮，检查你是否还能听到音乐。现在，让我们构建关卡并运行它。注意，当你开始关卡时，音乐会播放。
- en: Configuring the Sound Cue Editor
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置声音提示编辑器
- en: Double-click on **Vivaldi_Spring_Allegro_ByJohnHarrison_Cue** to open the Sound
    Cue Editor. Notice that on the right-hand side, there is **Palette** with a list
    of nodes, as shown in the following screenshot. These nodes can be used to control
    how the sounds are played or heard.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**Vivaldi_Spring_Allegro_ByJohnHarrison_Cue**以打开声音提示编辑器。注意，在右侧有一个**调色板**，其中包含节点列表，如下面的截图所示。这些节点可以用来控制声音的播放或听到的方式。
- en: '![Configuring the Sound Cue Editor](img/B03679_06_19.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![配置声音提示编辑器](img/B03679_06_19.jpg)'
- en: If you find that your sound design cannot be achieved using the nodes in the
    list, you can alternatively request for new nodes to be created via the UE4 source
    code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现无法使用列表中的节点来实现你的声音设计，你可以通过UE4源代码请求创建新的节点。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Both particles and sound are very interesting components of a game and require
    very specialized skills that are very apt for their design and creation. Particle
    system creators often have strong artistic and technical backgrounds; an artistic
    touch is needed to create suitable textures, and a technical ability helps to
    adjust distributions/values that create an appropriate overall effect. Audio engineers
    often have a strong music background. They are probably composers and musicians
    themselves with a passion for games.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子和声音都是游戏中的非常有趣的组件，它们需要非常专业的技能，非常适合它们的设计和创建。粒子系统创建者通常拥有强大的艺术和技术背景；需要艺术感来创建合适的纹理，而技术能力有助于调整分布/值，以创建适当的整体效果。音频工程师通常拥有强大的音乐背景。他们可能是作曲家和音乐家，对游戏充满热情。
- en: In the first half of the chapter, we learned about what a particle system is.
    We learned how particle systems are used to create in-game effects, such as falling
    snow, rainfall, flames, fireworks, explosion effects, and much more. A particle
    system can efficiently render small moving fuzzy particles using textures through
    a combination of emitters. Each emitter has many configurable modules that can
    control properties, such as a spawn rate, lifetime, velocity, and the acceleration
    needed to create the required effect. In this chapter, we covered how to edit
    an existing fire explosion particle system, turn it into a fireplace effect, and
    place it in a living room. Through this example, we also went through some basic
    principles that could be applied to the particle system design process, and how
    to make minor adjustments to a few popular basic modules to create the effect
    we wanted.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前半部分，我们学习了什么是粒子系统。我们学习了粒子系统是如何用于创建游戏中的效果的，例如下雪、降雨、火焰、烟花、爆炸效果等等。粒子系统可以通过发射器的组合，有效地使用纹理渲染小型的移动模糊粒子。每个发射器都有许多可配置的模块，可以控制属性，如出生率、寿命、速度以及创建所需效果所需的加速度。在本章中，我们介绍了如何编辑现有的火爆炸粒子系统，将其转变为壁炉效果，并将其放置在客厅中。通过这个例子，我们还探讨了可以应用于粒子系统设计过程的一些基本原理，以及如何对几个流行的基本模块进行微调，以创建我们想要的效果。
- en: The second half of the chapter covered how to include sounds in a level. We
    learned how sounds/music are conceptualized, created, recorded, and eventually,
    imported into the Unreal Editor. We also covered the audio format that the Unreal
    Editor currently supports, and a little explanation of each of the components
    is given to give you a better insight into sounds. Next, we went through a simple
    exercise to import an online audio file and get the music we have downloaded playing
    in the game level.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的后半部分介绍了如何在关卡中包含声音。我们学习了声音/音乐的构思、创作、录制，以及最终导入到Unreal编辑器中的过程。我们还介绍了Unreal编辑器目前支持的音频格式，并对每个组件进行了一些解释，以便您更好地了解声音。接下来，我们进行了一个简单的练习，导入在线音频文件，并在游戏关卡中播放我们下载的音乐。
- en: I hope you have gained a little more understanding about the creation process
    of the particle system and the audio effects that are needed for the games in
    this chapter. We will continue to improve our game level with a little terrain
    editing and also create cinematic effects in the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您对本章中游戏所需的粒子系统创建过程和音频效果有了更深入的理解。我们将通过一些地形编辑继续提升我们的游戏关卡，并在下一章中创建电影般的效果。
