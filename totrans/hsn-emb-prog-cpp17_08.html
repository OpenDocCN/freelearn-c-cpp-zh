<html><head></head><body>
        

                            
                    <h1 class="header-title">Testing OS-Based Applications</h1>
                
            
            
                
<p>Often, an embedded system uses a more or less regular <strong>Operating System</strong> (<strong>OS</strong>), which means that, often much, is the same as on our desktop OS in terms of runtime environment and tools, especially when targeting embedded Linux. Yet, differences in terms of performance and access offered by the embedded hardware versus our PC makes it essential to consider where to perform which parts of developing and testing, as well as how to integrate this into our development workflow.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Developing cross-platform code</li>
<li>Debugging and testing cross-platform code under Linux</li>
<li>Effectively using cross-compilers</li>
<li>Creating a build system that supports multiple targets</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding real hardware</h1>
                
            
            
                
<p>One of the biggest advantages of OS-based development on platforms such as embedded Linux is that it's so similar to a regular desktop Linux installation. Especially when running an OS such as a Debian-based Linux distribution (Armbian, Raspbian, and others) on SoCs, we have practically the same tools available, with the entire package manager, compiler collections, and libraries available with a few keystrokes.</p>
<p>This is, however, also its biggest pitfall.</p>
<p>We can write code, copy it over to the SBC, compile it there, run the test, and make changes to the code before repeating the process. Or, we can even write the code on the SBC itself, essentially using it as our sole development platform.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The main reasons why we should never do this are as follows:</p>
<ul>
<li>A modern PC is much faster.</li>
<li>Testing on real hardware should never be done until the final stages of development.</li>
<li>Automated integration testing is made much harder.</li>
</ul>
<p>Here, the first point seems fairly obvious. What takes a single or dual-core ARM SoC a good minute to compile will quickly go from start of compilation to linking the objects in ten seconds or less with a relatively modern multi-core, multithreaded processor at 3+ GHz, and a toolchain that supports multi-core compilation.</p>
<p>This means that, instead of waiting half a minute or longer before we can run a new test or start a debugging session, we can do so almost instantly.</p>
<p>The next two points are related. While it may seem advantageous to test on the real hardware, it comes with its own complications. One thing is that this hardware relies on a number of external factors to work properly, including its power supply, any wiring between power sources, peripherals, and signal interfaces. Things such as electromagnetic interference may also cause issues, in terms of signal degradation, as well as interrupts being triggered due to electromagnetic coupling.</p>
<p>An example of electromagnetic coupling became apparent while developing the club status service project of <a href="47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml">Chapter 3</a>, <em>Developing for Embedded Linux and Similar Systems</em>. Here, one of the signal wires for the switches ran alongside 230V AC wiring. Changes in the current on this mains wiring induced pulses in the signal wire, causing false interrupt trigger events.</p>
<p>All of these potential hardware-related issues show that such tests aren't nearly as deterministic as we would wish them to be. The potential result of this is that project development takes much longer than planned, with debugging being complicated due to conflicting and non-deterministic test results.</p>
<p>Another effect of a focus on developing on and for real hardware is that it makes automated testing much harder. The reason for this is that we cannot use any generic build cluster and, for example, Linux VM-based testing environment, as is common with mainstream <strong>Continuous</strong> <strong>Integration</strong> (<strong>CI</strong>) services.</p>
<p>Instead of this, we would have to somehow integrate something such as an SBC into the CI system, having it either cross-compile and copy the binary to the SBC for running the test, or compile it on the SBC itself, which gets us back to the first point.</p>
<p class="mce-root"/>
<p>In the next few sections, we'll look at a of approaches to make embedded Linux-based development as painless as possible, starting with cross-compilation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross-compiling for SBCs</h1>
                
            
            
                
<p>The compile process takes the source files, turning them into an intermediate format, after which this format can be used to target a specific CPU architecture. For us, this means that we aren't limited to compiling applications for an SBC on that SBC itself, but we can do so on our development PC.</p>
<p>To do so for an SBC such as the Raspberry Pi (Broadcom Cortex-A-based ARM SoCs), we need to install the <kbd>arm-linux-gnueabihf</kbd> toolchain, which targets the ARM architecture with hard float (hardware floating point) support, outputting Linux-compatible binaries.</p>
<p>On a Debian-based Linux system, we can install the entire toolchain with the following commands:</p>
<pre><strong>sudo apt install build-essential</strong>
<strong>sudo apt install g++-arm-linux-gnueabihf</strong>
<strong>sudo apt install gdb-multiarch</strong>  </pre>
<p>The first command installs the native GCC-based toolchain for the system (if it wasn't already installed), along with any common related tools and utilities, including <kbd>make</kbd>, <kbd>libtool</kbd>, <kbd>flex</kbd>, and others. The second command installs the actual cross-compiler. Finally, the third package is the version of the GDB debugger that supports multiple architectures, which we'll need later on for doing remote debugging on the real hardware, as well as for analyzing core dumps produced when our application crashes.</p>
<p>We can now use the g++ compiler for the target SBC using its full name on the command line:</p>
<pre><strong>arm-linux-gnueabihf-g++</strong>  </pre>
<p>To test whether the toolchain was properly installed, we can execute the following command, which should tell us the compiler details including the version:</p>
<pre><strong>arm-linux-gnueabihf-g++ -v</strong>  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In addition to this, we may need to link with some shared libraries that exist on the target system. For this, we can copy the entire contents of the <kbd>/lib</kbd> and <kbd>/usr</kbd> folders and include them as part of the system root for the compiler:</p>
<pre><strong>mkdir ~/raspberry/sysroot</strong>
<strong>scp -r pi@Pi-system:/lib ~/raspberry/sysroot</strong>
<strong>scp -r pi@Pi-system:/usr ~/raspberry/sysroot</strong>  </pre>
<p>Here, <kbd>Pi-system</kbd> is the IP address or network name of the Raspberry Pi or similar system. After this, we can tell GCC to use these folders instead of the standard paths using the <kbd>sysroot</kbd> flag:</p>
<pre><strong>--sysroot=dir</strong>  </pre>
<p>Here <kbd>dir</kbd> would be the folder where we copied these folders to, in this example that would be <kbd>~/raspberry/sysroot</kbd>.</p>
<p>Alternatively, we can just copy the header and library files we require and add them as part of the source tree. Whichever approach is the easiest mostly depends on the dependencies of the project in question.</p>
<p>For the club status service project, we require at the very least the headers and libraries for WiringPi, as well as those for the POCO project and its dependencies. We could determine the dependencies we need and copy the required includes and library files that are missing from the toolchain we installed earlier. Unless there's a pressing need to do so, it's far easier to just copy the entire folders from the SBC's OS.</p>
<p>As an alternative to using the <kbd>sysroot</kbd> method, we can also explicitly define the paths to the shared libraries that we wish to use while linking our code. This of course comes with its own set of advantages and disadvantages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integration test for club status service</h1>
                
            
            
                
<p>In order to test the club status service on a regular desktop Linux (or macOS or Windows) system before we embark on cross-compiling and testing on real hardware, a simple integration test was written, which uses mocks for the GPIO and I2C peripherals.</p>
<p>In the source code for the project covered in <a href="47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml">Chapter 3</a>, <em>Developing for Embedded Linux and Similar Systems</em>, the files for these peripherals are found in the <kbd>wiring</kbd> folder of that project.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We start with the <kbd>wiringPi.h</kbd> header:</p>
<pre>#include &lt;Poco/Timer.h&gt;<br/><br/><br/>#define  INPUT              0<br/>#define  OUTPUT                   1<br/>#define  PWM_OUTPUT         2<br/>#define  GPIO_CLOCK         3<br/>#define  SOFT_PWM_OUTPUT          4<br/>#define  SOFT_TONE_OUTPUT   5<br/>#define  PWM_TONE_OUTPUT          6</pre>
<p>We include a header from the POCO framework to allow us to easily create a timer instance later on. Then, we define all possible pin modes, just as the actual WiringPi header defines:</p>
<pre>#define  LOW                0<br/>#define  HIGH               1<br/><br/>#define  PUD_OFF                  0<br/>#define  PUD_DOWN           1<br/>#define  PUD_UP                   2<br/><br/>#define  INT_EDGE_SETUP          0<br/>#define  INT_EDGE_FALLING  1<br/>#define  INT_EDGE_RISING         2<br/>#define  INT_EDGE_BOTH           3</pre>
<p>These defines define further pin modes, including the digital input levels, the possible states of the pull-ups and pull-downs on the pins, and finally the possible types of interrupts, defining the trigger or triggers for an interrupt:</p>
<pre>typedef void (*ISRCB)(void); </pre>
<p>This <kbd>typedef</kbd> defines the format for an interrupt callback function pointer.</p>
<p>Let's now look at the <kbd>WiringTimer</kbd> class:</p>
<pre>class WiringTimer {<br/>    Poco::Timer* wiringTimer;<br/>    Poco::TimerCallback&lt;WiringTimer&gt;* cb;<br/>    uint8_t triggerCnt;<br/><br/> public:<br/>    ISRCB isrcb_0;<br/>    ISRCB isrcb_7;<br/>    bool isr_0_set;<br/>    bool isr_7_set;<br/><br/>    WiringTimer();<br/>    ~WiringTimer();<br/>    void start();<br/>    void trigger(Poco::Timer &amp;t);<br/> };</pre>
<p>This class is the integral part of the GPIO-side of our mock implementation. Its main purpose is to keep track of which of the two interrupts we're interested in have been registered, and to trigger them at regular intervals using the timer, as we'll see in a moment:</p>
<pre>int wiringPiSetup(); <br/>void pinMode(int pin, int mode); <br/>void pullUpDnControl(int pin, int pud); <br/>int digitalRead(int pin);<br/>int wiringPiISR(int pin, int mode, void (*function)(void));</pre>
<p>Finally, we define the standard WiringPi functions before moving on the implementation:</p>
<pre>#include "wiringPi.h"<br/><br/><br/>#include &lt;fstream&gt;<br/>#include &lt;memory&gt;<br/><br/><br/>WiringTimer::WiringTimer() {<br/>   triggerCnt = 0;<br/>   isrcb_0 = 0;<br/>   isrcb_7 = 0;<br/>   isr_0_set = false;<br/>   isr_7_set = false;<br/><br/>   wiringTimer = new Poco::Timer(10 * 1000, 10 * 1000);<br/>   cb = new Poco::TimerCallback&lt;WiringTimer&gt;(*this, <br/>   &amp;WiringTimer::trigger);<br/>}</pre>
<p>In the class constructor, we set the default values before creating the timer instance, configuring it to call our callback function every ten seconds, after an initial 10-second delay:</p>
<pre>WiringTimer::~WiringTimer() {<br/>   delete wiringTimer;<br/>   delete cb;<br/>}</pre>
<p class="mce-root"/>
<p>In the destructor, we delete the timer callback instance:</p>
<pre>void WiringTimer::start() {<br/>   wiringTimer-&gt;start(*cb);<br/>}</pre>
<p>In this function, we actually start the timer:</p>
<pre>void WiringTimer::trigger(Poco::Timer &amp;t) {<br/>    if (triggerCnt == 0) {<br/>          char val = 0x00;<br/>          std::ofstream PIN0VAL;<br/>          PIN0VAL.open("pin0val", std::ios_base::binary | std::ios_base::trunc);<br/>          PIN0VAL.put(val);<br/>          PIN0VAL.close();<br/><br/>          isrcb_0();<br/><br/>          ++triggerCnt;<br/>    }<br/>    else if (triggerCnt == 1) {<br/>          char val = 0x01;<br/>          std::ofstream PIN7VAL;<br/>          PIN7VAL.open("pin7val", std::ios_base::binary | std::ios_base::trunc);<br/>          PIN7VAL.put(val);<br/>          PIN7VAL.close();<br/><br/>          isrcb_7();<br/><br/>          ++triggerCnt;<br/>    }<br/>    else if (triggerCnt == 2) {<br/>          char val = 0x00;<br/>          std::ofstream PIN7VAL;<br/>          PIN7VAL.open("pin7val", std::ios_base::binary | std::ios_base::trunc);<br/>          PIN7VAL.put(val);<br/>          PIN7VAL.close();<br/><br/>          isrcb_7();<br/><br/>          ++triggerCnt;<br/>    }<br/>    else if (triggerCnt == 3) {<br/>          char val = 0x01;<br/>          std::ofstream PIN0VAL;<br/>          PIN0VAL.open("pin0val", std::ios_base::binary | std::ios_base::trunc);<br/>          PIN0VAL.put(val);<br/>          PIN0VAL.close();<br/><br/>          isrcb_0();<br/><br/>          triggerCnt = 0;<br/>    }<br/> }<br/><br/></pre>
<p>This last function in the class is the callback for the timer. The way it functions is that it keeps track of how many times it has been triggered, with it setting the appropriate pin level in the form of a value in a file that we write to disk.</p>
<p>After the initial delay, the first trigger will set the lock switch to <kbd>false</kbd>, the second the status switch to <kbd>true</kbd>, the third the status switch back to <kbd>false</kbd>, and finally the fourth trigger sets the lock switch back to <kbd>true</kbd>, before resetting the counter and starting over again:</p>
<pre>namespace Wiring {<br/>   std::unique_ptr&lt;WiringTimer&gt; wt;<br/>   bool initialized = false;<br/>}</pre>
<p>We add a global namespace in which we have a <kbd>unique_ptr</kbd> instance for a <kbd>WiringTimer</kbd> class instance, along with an initialization status indicator.</p>
<pre>int wiringPiSetup() {<br/>    char val = 0x01;<br/>    std::ofstream PIN0VAL;<br/>    std::ofstream PIN7VAL;<br/>    PIN0VAL.open("pin0val", std::ios_base::binary | std::ios_base::trunc);<br/>    PIN7VAL.open("pin7val", std::ios_base::binary | std::ios_base::trunc);<br/>    PIN0VAL.put(val);<br/>    val = 0x00;<br/>    PIN7VAL.put(val);<br/>    PIN0VAL.close();<br/>    PIN7VAL.close();<br/><br/>    Wiring::wt = std::make_unique&lt;WiringTimer&gt;();<br/>    Wiring::initialized = true;<br/><br/>    return 0;<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The setup function is used to write the default values for the mocked GPIO pin inputs value to disk. We also create the pointer to a <kbd>WiringTimer</kbd> instance here:</p>
<pre> void pinMode(int pin, int mode) {<br/>    // <br/><br/>    return;<br/> }<br/><br/> void pullUpDnControl(int pin, int pud) {<br/>    // <br/><br/>    return;<br/> }</pre>
<p>Because our mocked implementation determines the behavior of the pins, we can ignore any input on these functions. For testing purposes, we could add an assert to validate that these functions have been called at the right times with the appropriate settings:</p>
<pre> int digitalRead(int pin) {<br/>    if (pin == 0) {<br/>          std::ifstream PIN0VAL;<br/>          PIN0VAL.open("pin0val", std::ios_base::binary);<br/>          int val = PIN0VAL.get();<br/>          PIN0VAL.close();<br/><br/>          return val;<br/>    }<br/>    else if (pin == 7) {<br/>          std::ifstream PIN7VAL;<br/>          PIN7VAL.open("pin7val", std::ios_base::binary);<br/>          int val = PIN7VAL.get();<br/>          PIN7VAL.close();<br/><br/>          return val;<br/>    }<br/><br/>    return 0;<br/> }</pre>
<p>When reading the value for one of the two mocked pins, we open its respective file and read out its content, which is either the 1 or 0 set by the setup function or by the callback:</p>
<pre>//This value is then returned to the calling function.<br/><br/><br/> int wiringPiISR(int pin, int mode, void (*function)(void)) {<br/>    if (!Wiring::initialized) { <br/>          return 1;<br/>    }<br/><br/>    if (pin == 0) { <br/>          Wiring::wt-&gt;isrcb_0 = function;<br/>          Wiring::wt-&gt;isr_0_set = true;<br/>    }<br/>    else if (pin == 7) {<br/>          Wiring::wt-&gt;isrcb_7 = function;<br/>          Wiring::wt-&gt;isr_7_set = true;<br/>    }<br/><br/>    if (Wiring::wt-&gt;isr_0_set &amp;&amp; Wiring::wt-&gt;isr_7_set) {<br/>          Wiring::wt-&gt;start();<br/>    }<br/><br/>    return 0;<br/> }</pre>
<p>This function is used to register an interrupt and its associated callback function. After an initial check that the mock has been initialized by the setup function, we then continue to register the interrupt for one of the two specified pins.</p>
<p>Once both pins have had an interrupt set for them, we start the timer, which will in turn start generating events for the interrupt callbacks.</p>
<p>Next is the I2C bus mock:</p>
<pre>int wiringPiI2CSetup(const int devId);<br/>int wiringPiI2CWriteReg8(int fd, int reg, int data);</pre>
<p>We just need two functions here: the setup function and the simple one-byte register write function.</p>
<p>The implementation is as follows:</p>
<pre>#include "wiringPiI2C.h"<br/><br/>#include "../club.h"<br/><br/>#include &lt;Poco/NumberFormatter.h&gt;<br/><br/>using namespace Poco;<br/><br/><br/>int wiringPiI2CSetup(const int devId) {<br/>   Club::log(LOG_INFO, "wiringPiI2CSetup: setting up device ID: 0x" <br/>                                        + NumberFormatter::formatHex(devId));<br/><br/><br/>   return 0;<br/>}</pre>
<p>In the setup function, we log the requested device ID (I2C bus address) and return a standard device handle. Here, we use the <kbd>log()</kbd> function from the <kbd>Club</kbd> class to make the mock integrate into the rest of the code:</p>
<pre>int wiringPiI2CWriteReg8(int fd, int reg, int data) {<br/>    Club::log(LOG_INFO, "wiringPiI2CWriteReg8: Device handle 0x" + NumberFormatter::formatHex(fd) <br/>                                        + ", Register 0x" + NumberFormatter::formatHex(reg)<br/>                                        + " set to: 0x" + NumberFormatter::formatHex(data));<br/><br/>    return 0;<br/>}</pre>
<p>Since the code that would call this function wouldn't be expecting a response, beyond a simple acknowledgment that the data has been received, we can just log the received data and further details here. The <kbd>NumberFormatter</kbd> class from POCO is used here as well for formatting the integer data as hexadecimal values like in the application, for consistency.</p>
<p>We now compile the project and use the following command-line command:</p>
<pre><strong>make TEST=1</strong>  </pre>
<p>Running the application (under GDB, to see when new threads are created/destroyed) now gets us the following output:</p>
<pre> <strong>Starting ClubStatus server...<br/> Initialised C++ Mosquitto library.<br/> Created listener, entering loop...<br/> [New Thread 0x7ffff49c9700 (LWP 35462)]<br/> [New Thread 0x7ffff41c8700 (LWP 35463)]<br/> [New Thread 0x7ffff39c7700 (LWP 35464)]<br/> Initialised the HTTP server.<br/> INFO:       Club: starting up...<br/> INFO:       Club: Finished wiringPi setup.<br/> INFO:       Club: Finished configuring pins.<br/> INFO:       Club: Configured interrupts.<br/> [New Thread 0x7ffff31c6700 (LWP 35465)]<br/> INFO:       Club: Started update thread.<br/> Connected. Subscribing to topics...<br/> INFO:       ClubUpdater: Starting i2c relay device.<br/> INFO:       wiringPiI2CSetup: setting up device ID: 0x20<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x6 set to: 0x0<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x0<br/> INFO:       ClubUpdater: Finished configuring the i2c relay device's registers.</strong>  </pre>
<p>At this point, the system has been configured with all interrupts set and the I2C device configured by the application. The timer has started its initial countdown:</p>
<pre> <strong>INFO:       ClubUpdater: starting initial update run.<br/> INFO:       ClubUpdater: New lights, clubstatus off.<br/> DEBUG:      ClubUpdater: Power timer not active, using current power state: off<br/> INFO:       ClubUpdater: Red on.<br/> DEBUG:      ClubUpdater: Changing output register to: 0x8<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x8<br/> DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x8<br/> INFO:       ClubUpdater: Initial status update complete.</strong>  </pre>
<p>The initial status of the GPIO pins has been read out and both switches are found to be in the <kbd>off</kbd> position, so we activate the red light on the traffic light indicator by writing its position in the register:</p>
<pre> <strong>INFO:       ClubUpdater: Entering waiting condition.</strong><strong><br/> INFO:       ClubUpdater: lock status changed to unlocked<br/> INFO:       ClubUpdater: New lights, clubstatus off.<br/> DEBUG:      ClubUpdater: Power timer not active, using current power state: off<br/> INFO:       ClubUpdater: Yellow on.<br/> DEBUG:      ClubUpdater: Changing output register to: 0x4<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x4<br/> DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x4<br/> INFO:       ClubUpdater: status switch status changed to on<br/> INFO:       ClubUpdater: Opening club.<br/> INFO:       ClubUpdater: Started power timer...<br/> DEBUG:      ClubUpdater: Sent MQTT message.<br/> INFO:       ClubUpdater: New lights, clubstatus on.<br/> DEBUG:      ClubUpdater: Power timer active, inverting power state from: on<br/> INFO:       ClubUpdater: Green on.<br/> DEBUG:      ClubUpdater: Changing output register to: 0x2<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x2<br/> DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x2<br/> INFO:       ClubUpdater: status switch status changed to off<br/> INFO:       ClubUpdater: Closing club.<br/> INFO:       ClubUpdater: Started timer.<br/> INFO:       ClubUpdater: Started power timer...<br/> DEBUG:      ClubUpdater: Sent MQTT message.<br/> INFO:       ClubUpdater: New lights, clubstatus off.<br/> DEBUG:      ClubUpdater: Power timer active, inverting power state from: off<br/> INFO:       ClubUpdater: Yellow on.<br/> DEBUG:      ClubUpdater: Changing output register to: 0x5<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x5<br/> DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x5<br/> INFO:       ClubUpdater: setPowerState called.<br/> DEBUG:      ClubUpdater: Writing relay with: 0x4<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x4<br/> DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x4<br/> DEBUG:      ClubUpdater: Written relay outputs.<br/> DEBUG:      ClubUpdater: Finished setPowerState.<br/> INFO:       ClubUpdater: lock status changed to locked<br/> INFO:       ClubUpdater: New lights, clubstatus off.<br/> DEBUG:      ClubUpdater: Power timer not active, using current power state: off<br/> INFO:       ClubUpdater: Red on.<br/> DEBUG:      ClubUpdater: Changing output register to: 0x8<br/> INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x8<br/> DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x8</strong>  </pre>
<p>Next, the timer starts triggering the callback function repeatedly, causing it to go through its different stages. This allows us to ascertain that the basic functioning of the code is correct.</p>
<p>At this point, we can start implementing more complex test cases, conceivably even implementing scriptable test cases using an embedded Lua, Python runtime or similar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mock versus hardware</h1>
                
            
            
                
<p>An obvious question to ask when mocking away large sections of code and hardware peripherals is how realistic the resulting mock is. We obviously want to be able to cover as many real-life scenarios as possible with our integration test before we move to testing on the target system.</p>
<p class="mce-root"/>
<p>If we want to know which test cases we wish to cover in our mock, we have to look both at our project requirements (what it should be able to handle), and which situations and inputs can occur in a real-life scenario.</p>
<p>For this, we would analyze the underlying code to see what conditions can occur, and decide on which ones are relevant for us.</p>
<p>In the case of the WiringPi mocks we looked at earlier, a quick glance at the source code for the library's implementation makes it clear just how much we simplified our code compared to the version we would be using on our target system.</p>
<p>Looking at the basic WiringPi setup function, we see that it does the following:</p>
<ul>
<li>Determines the exact board model and SoC to get the GPIO layout</li>
<li>Opens the Linux device for the memory-mapped GPIO pins</li>
<li>Sets the memory offsets into the GPIO device and uses <kbd>mmap()</kbd> to map specific peripherals such as PWM, timer, and GPIO into memory</li>
</ul>
<p>Instead of ignoring calls to <kbd>pinMode()</kbd>, the implementation does the following:</p>
<ul>
<li>Appropriately sets the hardware GPIO direction register in the SoC (for input/output mode)</li>
<li>Starts PWM, soft PWM, or Tone mode on a pin (as requested); sub-functions set the appropriate registers</li>
</ul>
<p>This continues with the I2C side, where the setup function implementation looks like this:</p>
<pre>int wiringPiI2CSetup (const int devId) { 
   int rev; 
   const char *device; 
    
   rev = piGpioLayout(); 
    
   if (rev == 1) { 
         device = "/dev/i2c-0"; 
   } 
   else { 
         device = "/dev/i2c-1"; 
   } 
    
   return wiringPiI2CSetupInterface (device, devId); 
} </pre>
<p>Compared to our mock implementation, the main difference is in that an I2C peripheral is expected to be present on the in-memory filesystem of the OS, and the board revision determines which one we pick.</p>
<p class="mce-root"/>
<p>The last function that gets called tries to open the device, as in Linux and similar OSes every device is simply a file that we can open and get a file handle to, if successful. This file handle is the ID that gets returned when the function returns:</p>
<pre>int wiringPiI2CSetupInterface (const char *device, int devId) { 
   int fd; 
   if ((fd = open (device, O_RDWR)) &lt; 0) { 
         return wiringPiFailure (WPI_ALMOST, "Unable to open I2C device: %s\n", 
                                                                                                strerror (errno)); 
   } 
    
   if (ioctl (fd, I2C_SLAVE, devId) &lt; 0) { 
         return wiringPiFailure (WPI_ALMOST, "Unable to select I2C device: %s\n",                                                                                                strerror (errno)); 
   } 
    
   return fd; 
} </pre>
<p>After opening the I2C device, the Linux system function, <kbd>ioctl()</kbd>, is used to send data to the I2C peripheral, in this case, the address of the I2C slave device that we wish to use. If successful, we get a non-negative response and return the integer that's our file handle.</p>
<p>Writing and reading the I2C bus is also handled using <kbd>ioctl()</kbd>, as we can see in the same source file:</p>
<pre>static inline int i2c_smbus_access (int fd, char rw, uint8_t command, int size, union i2c_smbus_data *data) { 
   struct i2c_smbus_ioctl_data args; 
 
   args.read_write = rw; 
   args.command    = command; 
   args.size       = size; 
   args.data       = data; 
   return ioctl(fd, I2C_SMBUS, &amp;args); 
} </pre>
<p>This same inline function is called for every single I2C bus access. With the I2C device that we wish to use already selected, we can simply target the I2C peripheral and have it transmit the payload to the device.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, the <kbd>i2c_smbus_data</kbd> type is a simple union to support various sizes for the return value (when performing a read operation):</p>
<pre>union i2c_smbus_data { 
   uint8_t byte; 
   uint16_t word; 
   uint8_t block[I2C_SMBUS_BLOCK_MAX + 2]; 
}; </pre>
<p>Here, we mostly see the benefit of using an abstract API. Without it, we would have peppered our code with low-level calls that would have been much harder to mock away. What we also see is that there are a number of conditions that we should likely be testing as well, such as a missing I2C slave device, read and write errors on the I2C bus that may result in unexpected behavior, as well as unexpected input on GPIO pins, including for interrupt pins as was noted at the beginning of this chapter already.</p>
<p>Although obviously not all scenarios can be planned for, efforts should be made to document all realistic scenarios and incorporate them into the mocked-up implementation, so that they can be enabled at will during integration and regression testing and while debugging.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing with Valgrind</h1>
                
            
            
                
<p>Valgrind is the most commonly used collection of open source tools for analyzing and profiling everything from the cache and heap behavior of an application to memory leaks and potential multithreading issues. It works in tandem with the underlying operating system as, depending on the tool used, it has to intercept everything from memory allocations to instructions related to multithreading and related. This is the reason why it is only fully supported under Linux on 64-bit x86_64 architectures.</p>
<p>Using Valgrind on other supported platforms (Linux on x86, PowerPC, ARM, S390, MIPS, and ARM, also Solaris and macOS) is definitely also an option, but the primary development target of the Valgrind project is x86_64/Linux, making it the best platform to do profiling and debugging on, even if other platforms will be targeted later on.</p>
<p>On the Valgrind website at <a href="http://valgrind.org/info/platforms.html">http://valgrind.org/info/platforms.html</a>, we can see a full overview of the currently supported platforms.</p>
<p>One very attractive property of Valgrind is that none of its tools require us to alter the source code or resulting binary in any fashion. This makes it very easy to integrate into an existing workflow, including automated testing and integration systems.</p>
<p class="mce-root"/>
<p>On Windows-based system, tools such as Dr. Memory (<a href="http://drmemory.org/">http://drmemory.org/</a>) are available as well, which can handle at least the profiling of memory-related behavior. This particular tool also comes with Dr. Fuzz, a tool that can repeatedly call functions with varying inputs, potentially useful for integration testing.</p>
<p>By using an integration test such as what we looked at in the previous section, we're free to fully analyze the behavior of our code from the comfort of our PC. Since all of Valgrind's tools significantly slow down the execution of our code (10-100 times), being able to do most of the debugging and profiling on a fast system means that we can save a significant amount of time before embarking on testing on the target hardware.</p>
<p>Of the tools we'll likely use the most often, <strong>Memcheck</strong>, <strong>Helgrind</strong>, and <strong>DRD</strong> are useful for detecting memory allocation and multithreading issues. Once our code passes through these three tools, while using an extensive integration test that provides wide coverage of the code, we can move on to profiling and optimizing.</p>
<p>To profile our code, we then use <strong>Callgrind</strong> to see where our code spends the most of the time executing, followed by <strong>Massif</strong> to do profiling of heap allocations. With the information we can glean from this data, we can make changes to the code to streamline common allocation and de-allocation cases. It might also show us where it might make sense to use a cache to reuse resources instead of discarding them from memory.</p>
<p>Finally, we would run another cycle of MemCheck, Helgrind, and DRD to ensure that our changes didn't cause any regressions. Once we're satisfied, we move on to deploying the code on the target system and see how it performs there.</p>
<p>If the target system also runs Linux or other supported OSes, we can use Valgrind on there as well, to check that we didn't miss anything. Depending on the exact platform (OS and CPU architecture), we may run into limitations of the Valgrind port for that platform. These can include errors such as <em>unhandled instruction</em>, where the tool hasn't had a CPU instruction implemented and hence Valgrind cannot continue.</p>
<p>By extending the integration test to use the SBC instead of a local process, we can set up a continuous integration system whereby, in addition to the tests on a local process, we also run them on real hardware, taking into account the limitations of the real hardware platform relative to the x86_64-based Linux system used for most of the testing.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Multi-target build system</h1>
                
            
            
                
<p>Cross-compilation and multi-target build systems are among the words that tend to frighten a lot of people, mostly because they evoke images of hugely complicated build scripts that require arcane incantations to perform the desired operation. In this chapter, we'll be looking at a simple Makefile-based build system, based on a build system that has seen use in commercial projects across a range of hardware targets.</p>
<p>The one thing that makes a build system pleasant to use is to be able to get everything set up for compilation with minimal fuss and have a central location from which we can control all relevant aspects of building the project, or parts of it, along with building and running tests.</p>
<p>For this reason, we have a single Makefile at the top of the project, which handles all of the basics, including the determining of which platform we run on. The only simplification we're making here is that we assume a Unix-like environment, with MSYS2 or Cygwin on Windows, and Linux, BSD, and OS X/macOS and others using their native shell environments. We could, however, also adapt it to allow for Microsoft Visual Studio, <strong>Intel Compiler Collection</strong> (<strong>ICC</strong>), and other compilers, so long as they provide the basic tools.</p>
<p>Key to the build system are simple Makefiles, in which we define the specific details of the target platform, for example, for a standard Linux system running on x86_x64 hardware:</p>
<pre> <strong>TARGET_OS = linux<br/> TARGET_ARCH = x86_64<br/><br/> export CC = gcc<br/> export CXX = g++<br/> export CPP = cpp<br/> export AR = ar<br/> export LD = g++<br/> export STRIP = strip<br/> export OBJCOPY = objcopy<br/><br/> PLATFORM_FLAGS = -D__PLATFORM_LINUX__ -D_LARGEFILE64_SOURCE -D __LINUX__<br/> STD_FLAGS = $(PLATFORM_FLAGS) -Og -g3 -Wall -c -fmessage-length=0 -ffunction-sections -fdata-sections -DPOCO_HAVE_GCC_ATOMICS -DPOCO_UTIL_NO_XMLCONFIGURATION -DPOCO_HAVE_FD_EPOLL<br/> STD_CFLAGS = $(STD_FLAGS)<br/> STD_CXXFLAGS = -std=c++11 $(STD_FLAGS)<br/> STD_LDFLAGS = -L $(TOP)/build/$(TARGET)/libboost/lib \<br/>                         -L $(TOP)/build/$(TARGET)/poco/lib \<br/>                         -Wl,--gc-sections<br/> STD_INCLUDE = -I. -I $(TOP)/build/$(TARGET)/libboost/include \<br/>                         -I $(TOP)/build/$(TARGET)/poco/include \<br/>                         -I $(TOP)/extern/boost-1.58.0<br/> STD_LIBDIRS = $(STD_LDFLAGS)<br/> STD_LIBS = -ldl -lrt -lboost_system -lssl -lcrypto -lpthread</strong>
  </pre>
<p>Here, we can set the names of the command-line tools that we'll be using for compiling, creating archives, stripping debug symbols from binaries, and so on. The build system will use the target OS and architecture to keep the created binaries separate so that we can use the same source tree to create binaries for all target platforms in one run.</p>
<p>We can see how we separate the flags that we'll be passing to the compiler and linker into different categories: platform-specific ones, common (standard) flags, and finally flags specific for the C and C++ compiler. The former is useful when integrating external dependencies that have been integrated into the source tree, yet are written in C. These dependencies we'll find in the <kbd>extern</kbd> folder, as we'll see in more detail in a moment.</p>
<p>This kind of file will be heavily customized to fit a specific project, adding the required includes, libraries, and compile flags. For this example file, we can see a project that uses the POCO and Boost libraries, along with OpenSSL, tweaking the POCO library for the target platform.</p>
<p>First, let's look at the top of the configuration file for macOS:</p>
<pre>TARGET_OS = osx<br/> TARGET_ARCH = x86_64<br/><br/> export CC = clang<br/> export CXX = clang++<br/> export CPP = cpp<br/> export AR = ar<br/> export LD = clang++<br/> export STRIP = strip<br/> export OBJCOPY = objcopy</pre>
<p>Although the rest of the file is almost the same, here we can see a good example of generalizing what a tool is called. Although Clang supports the same flags as GCC, its tools are called differently. With this approach, we just write the different names once in this file and everything will just work.</p>
<p>This continues with the Linux on ARM target, which is set up as a cross-compilation target:</p>
<pre>TARGET_OS = linux<br/> TARGET_ARCH = armv7<br/> TOOLCHAIN_NAME = arm-linux-gnueabihf<br/><br/> export CC = $(TOOLCHAIN_NAME)-gcc<br/> export CXX = $(TOOLCHAIN_NAME)-g++<br/> export AR = $(TOOLCHAIN_NAME)-ar<br/> export LD = $(TOOLCHAIN_NAME)-g++<br/> export STRIP = $(TOOLCHAIN_NAME)-strip<br/> export OBJCOPY = $(TOOLCHAIN_NAME)-objcopy</pre>
<p>Here, we see the reappearance of the cross-compilation toolchain for ARM Linux platforms, which we looked at earlier in this chapter. To save ourselves typing, we define the basic name once so that it is easy to redefine. This also shows how flexible Makefiles are. With some more creativity, we could create a set of templates that would generalize entire toolchains into a simple Makefile to be included by the main Makefile depending on hints in the platform's Makefile (or other configuration file), making this highly flexible.</p>
<p>Moving on, we'll look at the main Makefile as found in the root of the project:</p>
<pre>ifndef TARGET<br/> $(error TARGET parameter not provided.)<br/> endif</pre>
<p>Since we cannot guess what platform the user wants us to target, we require that the target is specified, with the platform name as the value, for example, <kbd>linux-x86_x64</kbd>:</p>
<pre>export TOP := $(CURDIR)<br/> export TARGET</pre>
<p>Later on in the system, we'll need to know which folder we're in on the local filesystem so that we can specify absolute paths. We use the standard Make variable for this and export it as our own environment variable, along with the build target name:</p>
<pre>UNAME := $(shell uname)<br/> ifeq ($(UNAME), Linux)<br/> export HOST = linux<br/> else<br/> export HOST = win32<br/> export FILE_EXT = .exe<br/> endif</pre>
<p>Using the (command-line) <kbd>uname</kbd> command, we can check which OS we're running on, with each OS that supports the command in its shell returning its name, such as <kbd>Linux</kbd> for Linux and <kbd>Darwin</kbd> for macOS. On pure Windows (no MSYS2 or Cygwin), the command doesn't exist, which would get us the second part of this <kbd>if/else</kbd> statement.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This statement could be expanded to support more OSes, depending on what the build system requires. In this case, it is only used to determine whether executables we create should have a file extension:</p>
<pre>ifeq ($(HOST), linux)<br/> export MKDIR   = mkdir -p<br/> export RM            = rm -rf<br/> export CP            = cp -RL<br/> else<br/> export MKDIR   = mkdir -p<br/> export RM            = rm -rf<br/> export CP            = cp -RL<br/> endif</pre>
<p>In this <kbd>if/else</kbd> statement, we can set the appropriate command-line commands for common file operations. Since we're taking the easy way out, we're assuming the use of MSYS2 or similar Bash shell on Windows.</p>
<p>We could take the concept of generalizing further at this point as well, splitting off the OS file CLI tools as its own set of Makefiles, which we can then include as part of OS-specific settings:</p>
<pre>include Makefile.$(TARGET)<br/><br/> export TARGET_OS<br/> export TARGET_ARCH<br/> export TOOLCHAIN_NAME</pre>
<p>At this point, we use the target parameter provided to the Makefile to include the appropriate configuration file. After exporting some details from it, we now have a configured build system:</p>
<pre>all: extern-$(TARGET) core<br/><br/> extern:<br/>    $(MAKE) -C ./extern $(LIBRARY)<br/><br/> extern-$(TARGET):<br/>    $(MAKE) -C ./extern all-$(TARGET)<br/><br/> core:<br/>    $(MAKE) -C ./Core<br/><br/> clean: clean-core clean-extern<br/><br/> clean-extern:<br/>    $(MAKE) -C ./extern clean-$(TARGET)<br/><br/> clean-core:<br/>    $(MAKE) -C ./Core clean<br/><br/> .PHONY: all clean core extern clean-extern clean-core extern-$(TARGET)</pre>
<p>From this single Makefile, we can choose to compile the entire project or just the dependencies or the core project. We can also compile a specific external dependency and nothing else.</p>
<p>Finally, we can clean the core project, the dependencies, or both.</p>
<p>This top Makefile is primarily for controlling the underlying Makefiles. The next two Makefiles are found in the <kbd>Core</kbd> and <kbd>extern</kbd> folders. Of these, the <kbd>Core</kbd> Makefile simply directly compiles the project's core:</p>
<pre>include ../Makefile.$(TARGET) 
 
OUTPUT := CoreProject 
 
INCLUDE = $(STD_INCLUDE) 
LIBDIRS = $(STD_LIBDIRS) 
 
include ../version 
VERSIONINFO = -D__VERSION="\"$(VERSION)\"" </pre>
<p>As the first step, we include the Makefile configuration for the target platform so that we have access to all of its definitions. These could also have been exported in the main Makefile, but this way we're free to customize the build system even more.</p>
<p>We specify the name of the output binary that we're building, before some small tasks, including opening the <kbd>version</kbd> file (with Makefile syntax) in the root of the project, which contains the version number of the source we're building from. This is prepared to be passed as a preprocessor definition into the compiler:</p>
<pre>ifdef RELEASE 
TIMESTAMP = $(shell date --date=@`git show -s --format=%ct $(RELEASE)^{commit}` -u +%Y-%m-%dT%H:%M:%SZ) 
else ifdef GITTIME 
TIMESTAMP = $(shell date --date=@`git show -s --format=%ct` -u +%Y-%m-%dT%H:%M:%SZ) 
TS_SAFE = _$(shell date --date=@`git show -s --format=%ct` -u +%Y-%m-%dT%H%M%SZ) 
else 
TIMESTAMP = $(shell date -u +%Y-%m-%dT%H:%M:%SZ) 
TS_SAFE = _$(shell date -u +%Y-%m-%dT%H%M%SZ) 
endif </pre>
<p class="mce-root"/>
<p>This is another section where we rely on having a Bash shell or something compatible around, as we use the date command in order to create a timestamp for the build. The format depends on what parameter was passed to the main Makefile. If we're building a release, we take the timestamp from the Git repository, with the Git commit tag name used to retrieve the commit timestamp for that tag before formatting it.</p>
<p>If <kbd>GITTIME</kbd> is passed as parameter, the timestamp of the most recent Git commit is used. Otherwise, the current time and date is used (UTC).</p>
<p>This bit of code is intended to solve one of the issues that comes with having lots of test and integration builds: keeping track of which ones were built when and with which revision of the source code. It could be adapted to other file revision systems, as long as it supports similar functionality with the retrieving of specific timestamps.</p>
<p>Of note is the second timestamp we're creating. This is a slightly different formatted version of the timestamp that is affixed to the produced binary, except when we're building in release mode:</p>
<pre>CFLAGS = $(STD_CFLAGS) $(INCLUDE) $(VERSIONINFO) -D__TIMESTAMP="\"$(TIMESTAMP)\"" 
CXXFLAGS = $(STD_CXXFLAGS) $(INCLUDE) $(VERSIONINFO) -D__TIMESTAMP="\"$(TIMESTAMP)\"" 
 
OBJROOT := $(TOP)/build/$(TARGET)/obj 
CPP_SOURCES := $(wildcard *.cpp) 
CPP_OBJECTS := $(addprefix $(OBJROOT)/,$(CPP_SOURCES:.cpp=.o)) 
OBJECTS := $(CPP_OBJECTS) </pre>
<p>Here, we set the flags we wish to pass to the compiler, including the version and timestamp, both being passed as preprocessor definitions.</p>
<p>Finally, the sources in the current project folder are collected and the output folder for the object files is set. As we can see here, we'll be writing the object files to a folder underneath the project root, with further separation by the compile target:</p>
<pre>.PHONY: all clean 
 
all: makedirs $(CPP_OBJECTS) $(C_OBJECTS) $(TOP)/build/bin/$(TARGET)/$(OUTPUT)_$(VERSION)_$(TARGET)$(TS_SAFE) 
    
makedirs: 
   $(MKDIR) $(TOP)/build/bin/$(TARGET) 
   $(MKDIR) $(OBJROOT) 
    
$(OBJROOT)/%.o: %.cpp 
   $(CXX) -o $@ $&lt; $(CXXFLAGS) </pre>
<p class="mce-root"/>
<p>This part is fairly generic for a Makefile. We have the <kbd>all</kbd> target, along with one to make the folders on the filesystem, if they don't exist yet. Finally, we take in the array of source files in the next target, compiling them as configured and outputting the object file in the appropriate folder:</p>
<pre>$(TOP)/build/bin/$(TARGET)/$(OUTPUT)_$(VERSION)_$(TARGET)$(TS_SAFE): $(OBJECTS) 
   $(LD) -o $@ $(OBJECTS) $(LIBDIRS) $(LIBS) 
   $(CP) $@ $@.debug 
ifeq ($(TARGET_OS), osx) 
   $(STRIP) -S $@ 
else 
   $(STRIP) -S --strip-unneeded $@      
endif </pre>
<p>After we have created all of the object files from our source files, we want to link them together, which happens in this step. We can also see where the binary will end up: in a <kbd>bin</kbd> sub-folder of the project's build folder.</p>
<p>The linker is called, and we create a copy of the resulting binary, which we post-fix with <kbd>.debug</kbd> to indicate that it is the version with all of the debug information. The original binary is then stripped of its debug symbols and other unneeded information, leaving us with a small binary to copy to the remote test system and a larger version with all of the debug information for when we need to analyze core dumps or do remote debugging.</p>
<p>What we also see here is a small hack that got added due to an unsupported command-line flag by Clang's linker, requiring the implementation of a special case. While working on cross-platform compiling and similar tasks, one is likely to run into many of such small details, all of which complicate the writing of a universal build system that simply works:</p>
<pre>clean: 
   $(RM) $(CPP_OBJECTS) 
   $(RM) $(C_OBJECTS) </pre>
<p>As a final step, we allow for the generated object files to be deleted.</p>
<p>The second sub-Makefile in <kbd>extern</kbd> is also of note, as it controls all of the underlying dependencies:</p>
<pre>ifndef TARGET 
$(error TARGET parameter not provided.) 
endif 
 
all: libboost poco 
 
all-linux-%: 
   $(MAKE) libboost poco 
 
all-qnx-%: 
   $(MAKE) libboost poco 
    
all-osx-%: 
   $(MAKE) libboost poco 
    
all-windows: 
   $(MAKE) libboost poco </pre>
<p>An interesting feature here is the dependency selector based on the target platform. If we have dependencies that shouldn't be compiled for a specific platform, we can skip them here. This feature also allows us to directly instruct this Makefile to compile all dependencies for a specific platform. Here, we allow for the targeting of QNX, Linux, OS X/macOS, and Windows, while ignoring the architecture:</p>
<pre>libboost: 
   cd boost-1.58.0 &amp;&amp; $(MAKE) 
    
poco: 
   cd poco-1.7.4 &amp;&amp; $(MAKE) </pre>
<p>The actual targets merely call another Makefile at the top of the dependency project, which in turn compiles that dependency and adds it to the build folder, where it can be used by the <kbd>Core</kbd>'s Makefile.</p>
<p>Of course, we can also directly compile the project from this Makefile using an existing build system, such as here for OpenSSL:</p>
<pre>openssl: 
   $(MKDIR) $(TOP)/build/$(TARGET)/openssl 
   $(MKDIR) $(TOP)/build/$(TARGET)/openssl/include 
   $(MKDIR) $(TOP)/build/$(TARGET)/openssl/lib 
   cd openssl-1.0.2 &amp;&amp; ./Configure --openssldir="$(TOP)/build/$(TARGET)/openssl" shared os/compiler:$(TOOLCHAIN_NAME):$(OPENSSL_PARAMS) &amp;&amp; \ 
     $(MAKE) build_libs 
   $(CP) openssl-1.0.2/include $(TOP)/build/$(TARGET)/openssl 
   $(CP) openssl-1.0.2/libcrypto.a $(TOP)/build/$(TARGET)/openssl/lib/. 
   $(CP) openssl-1.0.2/libssl.a $(TOP)/build/$(TARGET)/openssl/lib/. </pre>
<p>This code works through all of the usual steps of building OpenSSL by hand, before copying the resulting binaries to their target folders.</p>
<p>One issue with cross-platform build systems one may notice is that a common GNU tool such as Autoconf is extremely slow on OSes such as Windows, due to it launching many processes as it runs hundreds of tests. Even on Linux, this process can take a long time, which is very annoying and time consuming when running through the same build process multiple times a day.</p>
<p>The ideal case is having a simple Makefile in which everything is predefined and in a known state so that no library discovery and such are needed. This was one of the motivations behind adding the POCO library source code to one project and having a simple Makefile compile it:</p>
<pre>include ../../Makefile.$(TARGET) 
 
all: poco-foundation poco-json poco-net poco-util 
 
poco-foundation: 
   cd Foundation &amp;&amp; $(MAKE) 
    
poco-json: 
   cd JSON &amp;&amp; $(MAKE) 
    
poco-net: 
   cd Net &amp;&amp; $(MAKE) 
    
poco-util: 
   cd Util &amp;&amp; $(MAKE) 
    
clean: 
   cd Foundation &amp;&amp; $(MAKE) clean 
   cd JSON &amp;&amp; $(MAKE) clean 
   cd Net &amp;&amp; $(MAKE) clean 
   cd Util &amp;&amp; $(MAKE) clean </pre>
<p>This Makefile then calls the individual Makefile for each module, as in this example:</p>
<pre>include ../../../Makefile.$(TARGET) 
 
OUTPUT = libPocoNet.a 
INCLUDE = $(STD_INCLUDE) -Iinclude 
CFLAGS = $(STD_CFLAGS) $(INCLUDE) 
OBJROOT = $(TOP)/extern/poco-1.7.4/Net/$(TARGET) 
INCLOUT = $(TOP)/build/$(TARGET)/poco 
SOURCES := $(wildcard src/*.cpp) 
HEADERS := $(addprefix $(INCLOUT)/,$(wildcard include/Poco/Net/*.h)) 
 
OBJECTS := $(addprefix $(OBJROOT)/,$(notdir $(SOURCES:.cpp=.o))) 
 
all: makedir $(OBJECTS) $(TOP)/build/$(TARGET)/poco/lib/$(OUTPUT) $(HEADERS) 
 
$(OBJROOT)/%.o: src/%.cpp 
   $(CC) -c -o $@ $&lt; $(CFLAGS) 
    
makedir: 
   $(MKDIR) $(TARGET) 
   $(MKDIR) $(TOP)/build/$(TARGET)/poco 
   $(MKDIR) $(TOP)/build/$(TARGET)/poco/lib 
   $(MKDIR) $(TOP)/build/$(TARGET)/poco/include 
   $(MKDIR) $(TOP)/build/$(TARGET)/poco/include/Poco 
   $(MKDIR) $(TOP)/build/$(TARGET)/poco/include/Poco/Net 
    
$(INCLOUT)/%.h: %.h 
   $(CP) $&lt; $(INCLOUT)/$&lt; 
 
$(TOP)/build/$(TARGET)/poco/lib/$(OUTPUT): $(OBJECTS) 
   -rm -f $@ 
   $(AR) rcs $@ $^ 
    
clean: 
   $(RM) $(OBJECTS) </pre>
<p>This Makefile compiles the entire <kbd>Net</kbd> module of the library. It's similar in structure to the one for compiling the project core source files. In addition to compiling the object files, it puts them into an archive so that we can link against it later, and copies this archive as well as the header files to their place in the build folder.</p>
<p>The main reason for compiling the library for the project was to allow for specific optimizations and tweaks that wouldn't be available with a precompiled library. By having everything but the basics stripped out of the library's original build system, trying out different settings was made very easy and even worked on Windows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Remote testing on real hardware</h1>
                
            
            
                
<p>After we have done all of the local testing of our code and are reasonably certain that it should work on the real hardware, we can use the cross-compile build system to create a binary that we can then run on the target system.</p>
<p>At this point, we can simply copy the resulting binary and associated files to the target system and see whether it works. The more scientific way to do this is to use GDB. With the GDB server service installed on the target Linux system, we can connect to it with GDB from our PC, either via the network or a serial connection.</p>
<p>For SBCs running a Debian-based Linux installation, the GDB server can be easily installed:</p>
<pre><strong>sudo apt install gdbserver</strong>  </pre>
<p>Although it is called <kbd>gdbserver</kbd>, its essential function is that of a remote stub implementation for the debugger, which runs on the host system. This makes <kbd>gdbserver</kbd> very lightweight and simple to implement for new targets.</p>
<p>After this, we want to make sure that <kbd>gdbserver</kbd> is running by logging in to the system and starting it in one of a variety of ways. We can do so for TPC connections over the network like this:</p>
<pre><strong>gdbserver host:2345 &lt;program&gt; &lt;parameters&gt;</strong>  </pre>
<p>Or we can attach it to a running process:</p>
<pre><strong>gdbserver host:2345 --attach &lt;PID&gt;</strong>  </pre>
<p>The <kbd>host</kbd> part of the first argument refers to the name (or IP address) of the host system that will be connecting. This parameter is currently ignored, meaning that it can also be left empty. The port section has to be a port that is not currently in use on the target system.</p>
<p>Or we can use some kind of serial connection:</p>
<pre><strong>gdbserver /dev/tty0 &lt;program&gt; &lt;parameters&gt;</strong>
<strong>gdbserver --attach /dev/tty0 &lt;PID&gt;</strong>  </pre>
<p>The moment we launch <kbd>gdbserver</kbd>, it pauses the execution of the target application if it was already running, allowing us to connect with the debugger from the host system. While on the target system, we can run a binary that has been stripped of its debug symbols; these are required to be present in the binary that we use on the host side:</p>
<pre><strong>$ gdb-multiarch &lt;program&gt;</strong>
<strong>(gdb) target remote &lt;IP&gt;:&lt;port&gt;</strong>
<strong>Remote debugging using &lt;IP&gt;:&lt;port&gt;</strong>  </pre>
<p>At this point, debug symbols would be loaded from the binary, along with those from any dependencies (if available). Connecting over a serial connection would look similar, just with the address and port replaced with the serial interface path or name. The <kbd>baud</kbd> rate of the serial connection (if not the default 9,600 baud) is specified as a parameter to GDB when we're starting:</p>
<pre><strong>$ gdb-multiarch -baud &lt;baud rate&gt; &lt;program&gt;</strong>  </pre>
<p>Once we have told GDB the details of the remote target, we should see the usual GDB command-line interface appear, allowing us to step through, analyze, and debug the program as if it was running locally on our system.</p>
<p class="mce-root">As mentioned earlier in this chapter, we're using <kbd>gdb-multiarch</kbd> as this version of the GDB debugger supports different architectures, which is useful since we'll likely be running the debugger on an x86_64 system, whereas the SBC is very likely ARM-based, but could also be MIPS or x86 (i686).</p>
<p>In addition to running the application directly with <kbd>gdbserver</kbd>, we can also start <kbd>gdbserver</kbd> to just wait for a debugger to connect:</p>
<pre><strong>gdbserver --multi &lt;host&gt;:&lt;port&gt;</strong>  </pre>
<p>Or we can do this:</p>
<pre><strong>gdbserver --multi &lt;serial port&gt;</strong>  </pre>
<p>We would then connect to this remote target like this:</p>
<pre><strong>$ gdb-multiarch &lt;program&gt;</strong>
<strong>(gdb) target extended-remote &lt;remote IP&gt;:&lt;port&gt;</strong>
<strong>(gdb) set remote exec-file &lt;remote file path&gt;</strong>
<strong>(gdb) run</strong>  </pre>
<p>At this point, we should find ourselves at the GDB command-line interface again, with the program binary loaded on both target and host.</p>
<p>A big advantage of this method is that <kbd>gdbserver</kbd> does not exit when the application that's being debugged exits. In addition, this mode allows us to debug different applications simultaneously on the same target, assuming that the target supports this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at how to develop and test embedded, OS-based applications. We learned how to install and use a cross-compilation toolchain, how to do remote debugging using GDB, and how to write a build system that allows us to compile for a wide variety of target systems with minimal effort required to add a new target.</p>
<p>At this point, you are expected to be able to develop and debug an embedded application for a Linux-based SBC or similar, while being able to work in an efficient way.</p>
<p>In the next chapter, we'll be looking at how to develop for and test applications for more constrained, MCU-based platforms.</p>


            

            
        
    </body></html>