<html><head></head><body>
<div id="_idContainer007">
<h1 class="chapter-number" id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.2.1">Causes of Bad Code</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we discussed coding standards in C++ and the core development principles. </span><span class="koboSpan" id="kobo.3.2">As we delve into refactoring existing code, it is crucial to understand what leads to subpar or bad code. </span><span class="koboSpan" id="kobo.3.3">Recognizing these causes enables us to avoid repeating the same mistakes, address existing issues, and prioritize future </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">improvements effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Bad code can</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.6.1"> result from various factors, ranging from external pressures to internal team dynamics. </span><span class="koboSpan" id="kobo.6.2">One significant factor is the need to deliver the product quickly, especially in fast-paced environments such as start-ups. </span><span class="koboSpan" id="kobo.6.3">Here, the pressure to release features rapidly often leads to compromises in code quality as developers might cut corners or skip essential best practices to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">tight deadlines.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Another contributing factor is the multiple ways of solving the same problem in C++. </span><span class="koboSpan" id="kobo.8.2">The language’s flexibility and richness, while powerful, can result in inconsistencies and difficulties in maintaining a coherent code base. </span><span class="koboSpan" id="kobo.8.3">Different developers might approach the same problem in various ways, leading to a fragmented and harder-to-maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">The developer’s personal taste also plays a role. </span><span class="koboSpan" id="kobo.10.2">Individual preferences and coding styles can impact the overall quality and readability of the code. </span><span class="koboSpan" id="kobo.10.3">What one developer considers elegant, another might find convoluted, leading to subjective differences that affect code consistency </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">and clarity.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Lastly, a lack of knowledge of modern C++ features can result in inefficient or error-prone code. </span><span class="koboSpan" id="kobo.12.2">As C++ evolves, it introduces new features and paradigms that require a deep understanding to be used effectively. </span><span class="koboSpan" id="kobo.12.3">When developers are not up to date with these advancements, they might fall back on outdated practices, missing out on improvements that can enhance code quality </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">and performance.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">By exploring these aspects, we aim to provide a thorough understanding of the factors contributing to bad code. </span><span class="koboSpan" id="kobo.14.2">This knowledge is essential for any developer aiming to refactor and improve an existing code base effectively. </span><span class="koboSpan" id="kobo.14.3">Let’s dive in and uncover the root causes of bad code in </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">C++ development.</span></span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.16.1">The need to deliver the product</span></h1>
<p><span class="koboSpan" id="kobo.17.1">When </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.18.1">developers examine pre-existing code, they may question why it was written in a manner that is less elegant or lacks extensibility. </span><span class="koboSpan" id="kobo.18.2">It is often easy to criticize the job done by others, but it is crucial to understand the original developer’s circumstances. </span><span class="koboSpan" id="kobo.18.3">Suppose the project was originally developed in a start-up company. </span><span class="koboSpan" id="kobo.18.4">In that case, it is important to consider that start-up culture significantly emphasizes fast product delivery and the need to outpace competitors. </span><span class="koboSpan" id="kobo.18.5">While this can be advantageous, it can also lead to the development of bad code. </span><span class="koboSpan" id="kobo.18.6">One of the main reasons for this is the pressure to deliver quickly, which may cause developers to cut corners or skip essential coding practices (for example, the SOLID principles mentioned in previous chapters) in order to meet deadlines. </span><span class="koboSpan" id="kobo.18.7">This can result in code that lacks proper documentation, is difficult to maintain, and may be susceptible </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">to errors.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Furthermore, the limited resources and small development teams of start-ups can exacerbate the need for speed, as developers may not have the manpower to focus on optimizing and refining the code base. </span><span class="koboSpan" id="kobo.20.2">As a result, the code can become cluttered and inefficient, leading to decreased performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">increased bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In addition, the focus on fast delivery in start-up culture can make it difficult for developers to keep up with the latest advancements in C++. </span><span class="koboSpan" id="kobo.22.2">This may result in outdated code that lacks important features, uses inefficient or deprecated functions, and is not optimized </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">for performance.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.24.1">The developer’s personal taste</span></h1>
<p><span class="koboSpan" id="kobo.25.1">Another </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.26.1">significant factor contributing to bad code is the developer’s personal taste. </span><span class="koboSpan" id="kobo.26.2">Individual preferences and coding styles can vary widely, leading to subjective differences that impact code consistency and readability. </span><span class="koboSpan" id="kobo.26.3">For example, consider two developers, Bob and Alice. </span><span class="koboSpan" id="kobo.26.4">Bob prefers using concise, compact code that leverages advanced C++ features, while Alice favors more explicit and verbose code, prioritizing clarity </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">and simplicity.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Bob might write a function using modern C++ features such as lambda expressions and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">auto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.30.1"> keyword:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.31.1">
auto process_data = [](const std::vector&lt;int&gt;&amp; data) {
    return std::accumulate(data.begin(), data.end(), 0L);
};</span></pre>
<p><span class="koboSpan" id="kobo.32.1">Alice, on the</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.33.1"> other hand, might prefer a more traditional approach, avoiding lambdas and using </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">explicit types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.35.1">
long process_data(const std::vector&lt;int&gt;&amp; data) {
    long sum = 0;
    for (int value : data) {
        sum += value;
    }
    return sum;
}</span></pre>
<p><span class="koboSpan" id="kobo.36.1">While both approaches are valid and achieve the same result, the difference in style can lead to confusion and inconsistency within the code base. </span><span class="koboSpan" id="kobo.36.2">If Bob and Alice are working on the same project without adhering to a common coding standard, the code can become a patchwork of differing styles, making it harder to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">and understand.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Additionally, Bob’s use of modern features might introduce complexity that could be difficult for team members unfamiliar with these features, while Alice’s verbose style might be seen as overly simplistic and inefficient by those who prefer more concise code. </span><span class="koboSpan" id="kobo.38.2">These differences, rooted in personal taste, underscore the importance of establishing and following team-wide coding standards to ensure consistency and maintainability in the </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">By recognizing and addressing the impact of personal coding preferences, teams can work toward creating a cohesive and readable code base that aligns with best practices and enhances overall </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">code quality.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.42.1">Multiple ways of solving the same problem in C++</span></h1>
<p><span class="koboSpan" id="kobo.43.1">C++ is a versatile </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.44.1">language that offers multiple ways to solve the same problem, a characteristic that can both empower and confuse developers. </span><span class="koboSpan" id="kobo.44.2">This flexibility often leads to inconsistencies within a code base, especially when different developers have varying levels of expertise and preferences. </span><span class="koboSpan" id="kobo.44.3">In this chapter, we will show a few examples to illustrate how the same problem can be approached in different ways, highlighting the potential benefits and pitfalls of each method. </span><span class="koboSpan" id="kobo.44.4">As discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.45.1">The developer’s personal taste</span></em><span class="koboSpan" id="kobo.46.1"> section, developers such as Bob and Alice might approach the same problem using different techniques, leading to a fragmented </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">code base.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.48.1">Revisiting Bob and Alice’s example</span></h2>
<p><span class="koboSpan" id="kobo.49.1">To recap, Bob</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.50.1"> used modern C++ features such as lambda expressions and </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">auto</span></strong><span class="koboSpan" id="kobo.52.1"> to process data concisely, while Alice preferred a more explicit and verbose approach. </span><span class="koboSpan" id="kobo.52.2">Both methods achieve the same result, but the difference in style can lead to confusion and inconsistency within the code base. </span><span class="koboSpan" id="kobo.52.3">While Bob’s approach is more compact and leverages modern C++ features, Alice’s method is straightforward and easier to understand for those unfamiliar </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">with lambdas.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.54.1">Raw pointers and C functions versus Standard Library functions</span></h2>
<p><span class="koboSpan" id="kobo.55.1">Consider a </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.56.1">project that heavily uses raw pointers and C functions for copying data, a common practice in older C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">code bases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.58.1">
void copy_array(const char* source, char* destination, size_t size) {
    for (size_t i = 0; i &lt; size; ++i) {
        destination[i] = source[i];
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.59.1">This approach, while functional, is prone to errors such as buffer overflows and requires manual memory management. </span><span class="koboSpan" id="kobo.59.2">In contrast, a modern C++ approach would use standard library functions such </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">std::copy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
void copy_array(const std::vector&lt;char&gt;&amp; source, std::vector&lt;char&gt;&amp; destination) {
    std::copy(source.begin(), source.end(), std::back_inserter(destination));
}</span></pre>
<p><span class="koboSpan" id="kobo.64.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">std::copy</span></strong><span class="koboSpan" id="kobo.66.1"> not only simplifies the code but also leverages well-tested library functions that handle edge cases and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">improve safety.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.68.1">Inheritance versus templates</span></h2>
<p><span class="koboSpan" id="kobo.69.1">Another area </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.70.1">where C++ offers multiple solutions is code reuse and abstraction. </span><span class="koboSpan" id="kobo.70.2">Some projects prefer using inheritance, which can lead to a rigid and </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">complex hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
class Shape {
public:
    virtual void draw() const = 0;
    virtual ~Shape() = default;
};
class Circle : public Shape {
public:
    void draw() const override {
        // Draw circle
    }
};
class Square : public Shape {
public:
    void draw() const override {
        // Draw square
    }
};
class ShapeDrawer {
public:
    explicit ShapeDrawer(std::unique_ptr&lt;Shape&gt; shape) : shape_(std::move(shape)) {}
    void draw() const {
        shape_-&gt;draw();
    }
private:
    std::unique_ptr&lt;Shape&gt; shape_;
};</span></pre>
<p><span class="koboSpan" id="kobo.73.1">While</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.74.1"> inheritance provides a clear structure and allows polymorphic behavior, it can become cumbersome as the hierarchy grows. </span><span class="koboSpan" id="kobo.74.2">An alternative approach is to use templates to achieve polymorphism without the overhead of virtual functions. </span><span class="koboSpan" id="kobo.74.3">Here’s how templates can be used to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">similar functionality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.76.1">
template&lt;typename ShapeType&gt;
class ShapeDrawer {
public:
    explicit ShapeDrawer(ShapeType shape) : shape_(std::move(shape)) {}
    void draw() const {
        shape_.draw();
    }
private:
    ShapeType shape_;
};
class Circle {
public:
    void draw() const {
        // Draw circle
    }
};
class Square {
public:
    void draw() const {
        // Draw square
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.77.1">In this </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.78.1">example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">ShapeDrawer</span></strong><span class="koboSpan" id="kobo.80.1"> uses templates to achieve polymorphic behavior. </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">ShapeDrawer</span></strong><span class="koboSpan" id="kobo.82.1"> can work with any type that provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">draw</span></strong><span class="koboSpan" id="kobo.84.1"> method. </span><span class="koboSpan" id="kobo.84.2">This approach avoids the overhead associated with virtual function calls and can be more efficient, especially in </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">performance-critical applications.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.86.1">Example – handling errors</span></h2>
<p><span class="koboSpan" id="kobo.87.1">Another </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.88.1">example of solving the same problem in different ways is error handling. </span><span class="koboSpan" id="kobo.88.2">Consider a project where Bob uses a traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">error code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
int process_file(const std::string&amp; filename) {
    FILE* file = fopen(filename.c_str(), "r");
    if (!file) {
        return -1; // Error opening file
    }
    // Process file
    return fclose(file);
}</span></pre>
<p><span class="koboSpan" id="kobo.91.1">Alice, on the other hand, prefers using exceptions for </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">error handling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
void process_file(const std::string&amp; filename) {
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("Error opening file");
    }
    // Process file
}</span></pre>
<p><span class="koboSpan" id="kobo.94.1">Using exceptions can make the code cleaner by separating error handling from the main logic, but it requires an understanding of exception safety and handling. </span><span class="koboSpan" id="kobo.94.2">Error code, while simpler, can clutter the code with repetitive checks and may be </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">less informative.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.96.1">Projects using different approaches</span></h2>
<p><span class="koboSpan" id="kobo.97.1">In real-world projects, you</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.98.1"> might encounter a mix of these approaches, reflecting the varied backgrounds and preferences of different developers, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">these examples:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Project A</span></strong><span class="koboSpan" id="kobo.101.1"> uses raw pointers and C functions for performance-critical sections, relying on the developers’ expertise to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">memory safely</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Project B</span></strong><span class="koboSpan" id="kobo.104.1"> prefers standard library containers and algorithms, prioritizing safety and readability over </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">raw performance</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Project C</span></strong><span class="koboSpan" id="kobo.107.1"> employs a deep inheritance hierarchy to model its domain, emphasizing clear relationships </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">between entities</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.109.1">Project D</span></strong><span class="koboSpan" id="kobo.110.1"> utilizes templates extensively to achieve high performance and flexibility, despite the steeper learning curve and </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">potential complexity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.112.1">Each approach has its pros and cons, and choosing the right one depends on the project’s requirements, the team’s expertise, and the specific problem being solved. </span><span class="koboSpan" id="kobo.112.2">However, these multiple ways of solving the same problem can lead to a fragmented and inconsistent code base if not </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">managed carefully.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">C++ provides multiple ways to solve the same problem, from raw pointers and C functions to standard library containers and templates. </span><span class="koboSpan" id="kobo.114.2">While this flexibility is powerful, it can also lead to inconsistencies and complexity in a code base. </span><span class="koboSpan" id="kobo.114.3">Understanding the strengths and weaknesses of each approach and striving for consistency through coding standards and team agreements is crucial for maintaining high-quality, maintainable code. </span><span class="koboSpan" id="kobo.114.4">By embracing modern C++ features and best practices, developers can write code that is both efficient and robust, reducing the likelihood of errors and improving overall </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">code quality.</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.116.1">Lack of knowledge in C++</span></h1>
<p><span class="koboSpan" id="kobo.117.1">One of the </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.118.1">major contributors to bad code is a lack of knowledge in C++. </span><span class="koboSpan" id="kobo.118.2">C++ is a complex and evolving language with a wide range of features, and staying updated with its latest standards requires continuous learning. </span><span class="koboSpan" id="kobo.118.3">Developers who are not familiar with modern C++ practices can inadvertently write inefficient or error-prone code. </span><span class="koboSpan" id="kobo.118.4">This section explores how gaps in understanding C++ can lead to various issues, using examples to illustrate </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">common pitfalls.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Consider two developers, Bob and Alice. </span><span class="koboSpan" id="kobo.120.2">Bob has extensive experience with older versions of C++ but hasn’t kept up with recent updates, while Alice is well versed in modern </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">C++ features.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.122.1">Using raw pointers and manual memory management</span></h2>
<p><span class="koboSpan" id="kobo.123.1">Bob might use raw pointers and manual memory management, a common practice in older </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">C++ code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
void process() {
    int* data = new int[100];
    // ... </span><span class="koboSpan" id="kobo.125.2">perform operations on data
    delete[] data;
}</span></pre>
<p><span class="koboSpan" id="kobo.126.1">This</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.127.1"> approach is prone to errors such as memory leaks and undefined behavior if </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">delete[]</span></strong><span class="koboSpan" id="kobo.129.1"> is missed or incorrectly matched with </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">new</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">For instance, if an exception is thrown after the allocation but before </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">delete[]</span></strong><span class="koboSpan" id="kobo.133.1">, the memory will leak. </span><span class="koboSpan" id="kobo.133.2">Alice, familiar with modern C++, would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">std::vector</span></strong><span class="koboSpan" id="kobo.135.1"> to manage memory safely </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">and efficiently:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
void process() {
    std::vector&lt;int&gt; data(100);
    // ... </span><span class="koboSpan" id="kobo.137.2">perform operations on data
}</span></pre>
<p><span class="koboSpan" id="kobo.138.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">std::vector</span></strong><span class="koboSpan" id="kobo.140.1"> eliminates the need for manual memory management, reducing the risk of memory leaks and making the code more robust and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">to maintain.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.142.1">Incorrect use of smart pointers</span></h2>
<p><span class="koboSpan" id="kobo.143.1">Bob tries to adopt modern practices but misuses </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.145.1">, leading to potential </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">performance issues:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
std::shared_ptr&lt;int&gt; create() {
    std::shared_ptr&lt;int&gt; ptr(new int(42));
    return ptr;
}</span></pre>
<p><span class="koboSpan" id="kobo.148.1">This</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.149.1"> approach involves two separate allocations: one for the integer and another for the control block of </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">Alice, knowing the benefits of </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">std::make_shared</span></strong><span class="koboSpan" id="kobo.153.1">, uses it to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">memory allocation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
std::shared_ptr&lt;int&gt; create() {
    return std::make_shared&lt;int&gt;(42);
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">std::make_shared</span></strong><span class="koboSpan" id="kobo.157.1"> combines the allocations into a single memory block, improving performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">cache locality.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.159.1">Efficient use of move semantics</span></h2>
<p><span class="koboSpan" id="kobo.160.1">Bob might not fully understand move semantics and how they can improve performance when dealing with temporary objects. </span><span class="koboSpan" id="kobo.160.2">Consider a function that appends elements </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">std::vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
void append_data(std::vector&lt;int&gt;&amp; target, const std::vector&lt;int&gt;&amp; source) {
    for (const int&amp; value : source) {
        target.push_back(value); // Copies each element
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.165.1">This approach involves copying each element from </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">source</span></strong><span class="koboSpan" id="kobo.167.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">target</span></strong><span class="koboSpan" id="kobo.169.1">, which can be inefficient. </span><span class="koboSpan" id="kobo.169.2">Alice, understanding move semantics, would optimize this by </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">std::move</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
void append_data(std::vector&lt;int&gt;&amp; target, std::vector&lt;int&gt;&amp;&amp; source) {
    for (int&amp; value : source) {
        target.push_back(std::move(value)); // Moves each element
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.174.1">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">std::move</span></strong><span class="koboSpan" id="kobo.176.1">, Alice ensures that each element is moved rather than copied, which is more efficient. </span><span class="koboSpan" id="kobo.176.2">Additionally, Alice might also consider using </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">std::move</span></strong><span class="koboSpan" id="kobo.178.1"> for the entire </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.179.1">container if </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">source</span></strong><span class="koboSpan" id="kobo.181.1"> is no </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">longer needed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
void append_data(std::vector&lt;int&gt;&amp; target, std::vector&lt;int&gt;&amp;&amp; source) {
    target.insert(target.end(), std::make_move_iterator(source.begin()), std::make_move_iterator(source.end()));
}</span></pre>
<p><span class="koboSpan" id="kobo.184.1">This approach moves the elements of the entire container efficiently, leveraging move semantics to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">unnecessary copying.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.186.1">Misusing const correctness</span></h2>
<p><span class="koboSpan" id="kobo.187.1">Bob might neglect const correctness, leading to potential bugs and </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">unclear code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
class MyClass {
public:
    int get_value() { return value; }
    void set_value(int v) { value = v; }
private:
    int value;
};</span></pre>
<p><span class="koboSpan" id="kobo.190.1">Without const correctness, it’s unclear whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">get_value</span></strong><span class="koboSpan" id="kobo.192.1"> modifies the state of the object. </span><span class="koboSpan" id="kobo.192.2">Alice applies const correctness to clarify the intent and </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">improve safety:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
class MyClass {
public:
    int get_value() const { return value; }
    void set_value(int v) { value = v; }
private:
    int value;
};</span></pre>
<p><span class="koboSpan" id="kobo.195.1">Marking </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">get_value</span></strong><span class="koboSpan" id="kobo.197.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">const</span></strong><span class="koboSpan" id="kobo.199.1"> guarantees that it does not modify the object, making the code clearer </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.200.1">and preventing </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">accidental modifications.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.202.1">Inefficient string handling</span></h2>
<p><span class="koboSpan" id="kobo.203.1">Bob might handle strings using C-style character arrays, which can lead to buffer overflows and </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">complex code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
char message[100];
strcpy(message, "Hello, world!");
std::cout &lt;&lt; message &lt;&lt; std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.206.1">This approach is error-prone and difficult to manage. </span><span class="koboSpan" id="kobo.206.2">Alice, aware of the capabilities of </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">std::string</span></strong><span class="koboSpan" id="kobo.208.1">, simplifies the code and avoids </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">potential errors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
std::string message = "Hello, world!";
std::cout &lt;&lt; message &lt;&lt; std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.211.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">std::string</span></strong><span class="koboSpan" id="kobo.213.1"> provides automatic memory management and a rich set of functions for string manipulation, making the code safer and </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">more expressive.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.215.1">Undefined behavior with lambdas</span></h2>
<p><span class="koboSpan" id="kobo.216.1">Lambda functions introduced in C++11 provide powerful capabilities, but they can lead to undefined behavior if not used correctly. </span><span class="koboSpan" id="kobo.216.2">Bob might write a lambda that captures a local variable by reference and returns it, leading to </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">dangling references:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
auto create_lambda() {
    int value = 42;
    return [&amp;]() { return value; };
}
auto lambda = create_lambda();
int result = lambda(); // Undefined behavior</span></pre>
<p><span class="koboSpan" id="kobo.219.1">Alice, understanding the risks, captures the variable by value to ensure it </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">remains valid:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
auto create_lambda() {
    int value = 42;
    return [=]() { return value; };
}
auto lambda = create_lambda();
int result = lambda(); // Safe</span></pre>
<p><span class="koboSpan" id="kobo.222.1">Capturing by value avoids the risk of dangling references and ensures the lambda remains safe </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">to use.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.224.1">Misunderstanding undefined behavior</span></h2>
<p><span class="koboSpan" id="kobo.225.1">Bob might inadvertently </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.226.1">write code that leads to undefined behavior by relying on </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">uninitialized variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
int sum() {
    int x;
    int y = 5;
    return x + y; // Undefined behavior: x is uninitialized
}</span></pre>
<p><span class="koboSpan" id="kobo.229.1">Accessing uninitialized variables can lead to unpredictable behavior and hard-to-debug issues. </span><span class="koboSpan" id="kobo.229.2">Alice, understanding</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.230.1"> the importance of initialization, ensures that all variables are </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">properly initialized:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
int sum() {
    int x = 0;
    int y = 5;
    return x + y; // Defined behavior
}</span></pre>
<p><span class="koboSpan" id="kobo.233.1">Properly initializing variables prevents undefined behavior and makes the code </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">more reliable.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.235.1">Misuse of C-style arrays</span></h2>
<p><span class="koboSpan" id="kobo.236.1">Using C-style arrays </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.237.1">can lead to various issues, such as a lack of bounds checking and difficulty in managing array sizes. </span><span class="koboSpan" id="kobo.237.2">Consider the following example where a function creates a C array on the stack and </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">returns it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
int* create_array() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr; // Undefined behavior: returning a pointer to a local array
}</span></pre>
<p><span class="koboSpan" id="kobo.240.1">Returning a pointer to a local array leads to undefined behavior because the array goes out of scope when the function returns. </span><span class="koboSpan" id="kobo.240.2">A safer approach is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">std::array</span></strong><span class="koboSpan" id="kobo.242.1">, which can be returned safely from a function. </span><span class="koboSpan" id="kobo.242.2">It provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">size</span></strong><span class="koboSpan" id="kobo.244.1"> method and is compatible with C++ algorithms such </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">std::sort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
std::array&lt;int, 5&gt; create_array() {
    return {1, 2, 3, 4, 5};
}</span></pre>
<p><span class="koboSpan" id="kobo.249.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">std::array</span></strong><span class="koboSpan" id="kobo.251.1"> not only avoids undefined behavior but also enhances safety and interoperability with the C++ Standard Library. </span><span class="koboSpan" id="kobo.251.2">For example, sorting an array </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">becomes straightforward:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
std::array&lt;int, 5&gt; arr = create_array();
std::sort(arr.begin(), arr.end());</span></pre>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.254.1">Insufficient pointer usage</span></h1>
<p><span class="koboSpan" id="kobo.255.1">Modern C++ provides </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.256.1">smart pointers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.258.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.260.1"> to manage dynamic memory more safely and efficiently. </span><span class="koboSpan" id="kobo.260.2">It’s generally better to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.262.1"> instead of raw pointers for exclusive ownership. </span><span class="koboSpan" id="kobo.262.2">When multiple actors need to share ownership of a resource, </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.264.1"> can be used. </span><span class="koboSpan" id="kobo.264.2">However, there are common issues related to the misuse </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">std::shared_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.268.1">Building std::shared_ptr</span></h2>
<p><span class="koboSpan" id="kobo.269.1">Using the </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.270.1">constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.272.1"> to create an object leads to separate allocations for the control block and the </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">managed object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
std::shared_ptr&lt;int&gt; create() {
    std::shared_ptr&lt;int&gt; ptr(new int(42));
    return ptr;
}</span></pre>
<p><span class="koboSpan" id="kobo.275.1">A better approach is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">std::make_shared</span></strong><span class="koboSpan" id="kobo.277.1">, which combines the allocations into a single memory block, improving performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">cache locality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
std::shared_ptr&lt;int&gt; create() {
    return std::make_shared&lt;int&gt;(42);
}</span></pre>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.280.1">Copying std::shared_ptr by value</span></h2>
<p><span class="koboSpan" id="kobo.281.1">Copying </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.283.1"> by value</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.284.1"> within the same thread stack is less efficient because the reference counter is atomic. </span><span class="koboSpan" id="kobo.284.2">It’s recommended to pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">std::shared_ptr</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.286.1">by reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
void process_shared_ptr(std::shared_ptr&lt;int&gt; ptr) {
    // Inefficient: copies shared_ptr by value
}
void process_shared_ptr(const std::shared_ptr&lt;int&gt;&amp; ptr) {
    // Efficient: passes shared_ptr by reference
}</span></pre>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.288.1">Cyclic dependencies with std::shared_ptr</span></h2>
<p><span class="koboSpan" id="kobo.289.1">Cyclic dependencies</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.290.1"> can occur when two or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.292.1"> instances reference each other, preventing the reference count from reaching zero and causing memory leaks. </span><span class="koboSpan" id="kobo.292.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
struct B;
struct A {
    std::shared_ptr&lt;B&gt; b_ptr;
    ~A() { std::cout &lt;&lt; "A destroyed\n"; }
};
struct B {
    std::shared_ptr&lt;A&gt; a_ptr;
    ~B() { std::cout &lt;&lt; "B destroyed\n"; }
};
void create_cycle() {
    auto a = std::make_shared&lt;A&gt;();
    auto b = std::make_shared&lt;B&gt;();
    a-&gt;b_ptr = b;
    b-&gt;a_ptr = a;
}</span></pre>
<p><span class="koboSpan" id="kobo.295.1">In this </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.296.1">scenario, </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">A</span></strong><span class="koboSpan" id="kobo.298.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">B</span></strong><span class="koboSpan" id="kobo.300.1"> reference each other, creating a cycle that prevents their destruction. </span><span class="koboSpan" id="kobo.300.2">This issue can be resolved using </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.302.1"> to break </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the cycle:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
struct B;
struct A {
    std::weak_ptr&lt;B&gt; b_ptr; // Use weak_ptr to break the cycle
    ~A() { std::cout &lt;&lt; "A destroyed\n"; }
};
struct B {
    std::shared_ptr&lt;A&gt; a_ptr;
    ~B() { std::cout &lt;&lt; "B destroyed\n"; }
};
void create_cycle() {
    auto a = std::make_shared&lt;A&gt;();
    auto b = std::make_shared&lt;B&gt;();
    a-&gt;b_ptr = b;
    b-&gt;a_ptr = a;
}</span></pre>
<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.305.1">Checking the std::weak_ptr status</span></h2>
<p><span class="koboSpan" id="kobo.306.1">A common mistake</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.307.1"> when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.309.1"> is to check its status with </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">expired()</span></strong><span class="koboSpan" id="kobo.311.1"> and then lock it, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">not thread-safe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
std::weak_ptr&lt;int&gt; weak_ptr = some_shared_ptr;
void check_and_use_weak_ptr() {
    if (!weak_ptr.expired()) {
        // This is not thread-safe
        auto shared_ptr = weak_ptr.lock();
        shared_ptr-&gt;do_something();
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.314.1">The correct approach is to lock </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.316.1"> and check that the returned </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.318.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
void check_and_use_weak_ptr_correctly() {
    // This is thread-safe
    if (auto shared_ptr = weak_ptr.lock()) {
        // Use shared_ptr
        shared_ptr-&gt;do_something();
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.323.1">Lack of knowledge in C++ can lead to various issues, from memory management errors to inefficient and unreadable code. </span><span class="koboSpan" id="kobo.323.2">By staying updated with modern C++ features and best practices, developers </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.324.1">can write code that is safer, more efficient, and easier to maintain. </span><span class="koboSpan" id="kobo.324.2">Continuous learning and adaptation are key to overcoming these challenges and improving overall code quality. </span><span class="koboSpan" id="kobo.324.3">Bob and Alice’s examples highlight the importance of understanding and applying modern C++ practices to avoid common pitfalls and produce </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">high-quality code.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.326.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.327.1">In this chapter, we explored various causes of bad code in C++ and how a lack of knowledge in modern C++ practices can lead to inefficient, error-prone, or undefined behavior. </span><span class="koboSpan" id="kobo.327.2">By examining specific examples, we highlighted the importance of continuous learning and adaptation to keep up with the evolving features </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">of C++.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">We began by discussing the pitfalls of using raw pointers and manual memory management, showing how modern C++ practices such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">std::vector</span></strong><span class="koboSpan" id="kobo.331.1"> can eliminate the need for manual memory management and reduce the risk of memory leaks. </span><span class="koboSpan" id="kobo.331.2">The advantages of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.333.1"> for exclusive ownership and </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.335.1"> for shared ownership were emphasized, while common issues such as inefficient memory allocation, unnecessary copying, and cyclic dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">were highlighted.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">In the context of </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.339.1">, we demonstrated the benefits of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">std::make_shared</span></strong><span class="koboSpan" id="kobo.341.1"> over the constructor to reduce memory allocations and improve performance. </span><span class="koboSpan" id="kobo.341.2">The efficiency gained by passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.343.1"> by reference rather than by value due to the atomic reference counter was also explained. </span><span class="koboSpan" id="kobo.343.2">We illustrated the problem of cyclic dependencies and how </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.345.1"> can be used to break cycles and prevent memory leaks. </span><span class="koboSpan" id="kobo.345.2">The correct way to check and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.347.1"> by locking it and checking the resulting </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.349.1"> to ensure thread safety was </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">also covered.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Efficient use of move semantics was discussed to optimize performance by reducing unnecessary copying of temporary objects. </span><span class="koboSpan" id="kobo.351.2">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">std::move</span></strong><span class="koboSpan" id="kobo.353.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">std::make_move_iterator</span></strong><span class="koboSpan" id="kobo.355.1"> can significantly enhance program performance. </span><span class="koboSpan" id="kobo.355.2">The importance of const correctness was highlighted, showing how applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">const</span></strong><span class="koboSpan" id="kobo.357.1"> to methods can clarify intent and improve </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">code safety.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">We addressed the dangers of using C-style character arrays and how </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">std::string</span></strong><span class="koboSpan" id="kobo.361.1"> can simplify string handling, reduce errors, and provide better memory management. </span><span class="koboSpan" id="kobo.361.2">The misuse of C-style arrays was explored, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">std::array</span></strong><span class="koboSpan" id="kobo.363.1"> was presented as a safer and more robust alternative. </span><span class="koboSpan" id="kobo.363.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">std::array</span></strong><span class="koboSpan" id="kobo.365.1">, we can avoid undefined behavior and leverage C++ Standard Library algorithms such </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">std::sort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">Finally, the proper use of lambda functions was discussed, along with the potential pitfalls of capturing variables by reference, which can lead to dangling references. </span><span class="koboSpan" id="kobo.369.2">Capturing variables by value ensures that the lambda remains safe </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Through these examples, we learned about the critical importance of adopting modern C++ features and best practices to write safer, more efficient, and maintainable code. </span><span class="koboSpan" id="kobo.371.2">By staying updated with the latest standards and continuously improving our understanding of C++, we can avoid common pitfalls and produce </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">high-quality software.</span></span></p>
</div>
</body></html>