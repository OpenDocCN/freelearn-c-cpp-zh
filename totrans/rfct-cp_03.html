<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-44"><a id="_idTextAnchor043"/>3</h1>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Causes of Bad Code</h1>
<p>In the previous chapters, we discussed coding standards in C++ and the core development principles. As we delve into refactoring existing code, it is crucial to understand what leads to subpar or bad code. Recognizing these causes enables us to avoid repeating the same mistakes, address existing issues, and prioritize future improvements effectively.</p>
<p>Bad code can<a id="_idIndexMarker094"/> result from various factors, ranging from external pressures to internal team dynamics. One significant factor is the need to deliver the product quickly, especially in fast-paced environments such as start-ups. Here, the pressure to release features rapidly often leads to compromises in code quality as developers might cut corners or skip essential best practices to meet tight deadlines.</p>
<p>Another contributing factor is the multiple ways of solving the same problem in C++. The language’s flexibility and richness, while powerful, can result in inconsistencies and difficulties in maintaining a coherent code base. Different developers might approach the same problem in various ways, leading to a fragmented and harder-to-maintain code base.</p>
<p>The developer’s personal taste also plays a role. Individual preferences and coding styles can impact the overall quality and readability of the code. What one developer considers elegant, another might find convoluted, leading to subjective differences that affect code consistency and clarity.</p>
<p>Lastly, a lack of knowledge of modern C++ features can result in inefficient or error-prone code. As C++ evolves, it introduces new features and paradigms that require a deep understanding to be used effectively. When developers are not up to date with these advancements, they might fall back on outdated practices, missing out on improvements that can enhance code quality and performance.</p>
<p>By exploring these aspects, we aim to provide a thorough understanding of the factors contributing to bad code. This knowledge is essential for any developer aiming to refactor and improve an existing code base effectively. Let’s dive in and uncover the root causes of bad code in C++ development.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>The need to deliver the product</h1>
<p>When <a id="_idIndexMarker095"/>developers examine pre-existing code, they may question why it was written in a manner that is less elegant or lacks extensibility. It is often easy to criticize the job done by others, but it is crucial to understand the original developer’s circumstances. Suppose the project was originally developed in a start-up company. In that case, it is important to consider that start-up culture significantly emphasizes fast product delivery and the need to outpace competitors. While this can be advantageous, it can also lead to the development of bad code. One of the main reasons for this is the pressure to deliver quickly, which may cause developers to cut corners or skip essential coding practices (for example, the SOLID principles mentioned in previous chapters) in order to meet deadlines. This can result in code that lacks proper documentation, is difficult to maintain, and may be susceptible to errors.</p>
<p>Furthermore, the limited resources and small development teams of start-ups can exacerbate the need for speed, as developers may not have the manpower to focus on optimizing and refining the code base. As a result, the code can become cluttered and inefficient, leading to decreased performance and increased bugs.</p>
<p>In addition, the focus on fast delivery in start-up culture can make it difficult for developers to keep up with the latest advancements in C++. This may result in outdated code that lacks important features, uses inefficient or deprecated functions, and is not optimized for performance.</p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>The developer’s personal taste</h1>
<p>Another <a id="_idIndexMarker096"/>significant factor contributing to bad code is the developer’s personal taste. Individual preferences and coding styles can vary widely, leading to subjective differences that impact code consistency and readability. For example, consider two developers, Bob and Alice. Bob prefers using concise, compact code that leverages advanced C++ features, while Alice favors more explicit and verbose code, prioritizing clarity and simplicity.</p>
<p>Bob might write a function using modern C++ features such as lambda expressions and the <code>auto</code> keyword:</p>
<pre class="source-code">
auto process_data = [](const std::vector&lt;int&gt;&amp; data) {
    return std::accumulate(data.begin(), data.end(), 0L);
};</pre>
<p>Alice, on the<a id="_idIndexMarker097"/> other hand, might prefer a more traditional approach, avoiding lambdas and using explicit types:</p>
<pre class="source-code">
long process_data(const std::vector&lt;int&gt;&amp; data) {
    long sum = 0;
    for (int value : data) {
        sum += value;
    }
    return sum;
}</pre>
<p>While both approaches are valid and achieve the same result, the difference in style can lead to confusion and inconsistency within the code base. If Bob and Alice are working on the same project without adhering to a common coding standard, the code can become a patchwork of differing styles, making it harder to maintain and understand.</p>
<p>Additionally, Bob’s use of modern features might introduce complexity that could be difficult for team members unfamiliar with these features, while Alice’s verbose style might be seen as overly simplistic and inefficient by those who prefer more concise code. These differences, rooted in personal taste, underscore the importance of establishing and following team-wide coding standards to ensure consistency and maintainability in the code base.</p>
<p>By recognizing and addressing the impact of personal coding preferences, teams can work toward creating a cohesive and readable code base that aligns with best practices and enhances overall code quality.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Multiple ways of solving the same problem in C++</h1>
<p>C++ is a versatile <a id="_idIndexMarker098"/>language that offers multiple ways to solve the same problem, a characteristic that can both empower and confuse developers. This flexibility often leads to inconsistencies within a code base, especially when different developers have varying levels of expertise and preferences. In this chapter, we will show a few examples to illustrate how the same problem can be approached in different ways, highlighting the potential benefits and pitfalls of each method. As discussed in the <em class="italic">The developer’s personal taste</em> section, developers such as Bob and Alice might approach the same problem using different techniques, leading to a fragmented code base.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Revisiting Bob and Alice’s example</h2>
<p>To recap, Bob<a id="_idIndexMarker099"/> used modern C++ features such as lambda expressions and <code>auto</code> to process data concisely, while Alice preferred a more explicit and verbose approach. Both methods achieve the same result, but the difference in style can lead to confusion and inconsistency within the code base. While Bob’s approach is more compact and leverages modern C++ features, Alice’s method is straightforward and easier to understand for those unfamiliar with lambdas.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Raw pointers and C functions versus Standard Library functions</h2>
<p>Consider a <a id="_idIndexMarker100"/>project that heavily uses raw pointers and C functions for copying data, a common practice in older C++ code bases:</p>
<pre class="source-code">
void copy_array(const char* source, char* destination, size_t size) {
    for (size_t i = 0; i &lt; size; ++i) {
        destination[i] = source[i];
    }
}</pre>
<p>This approach, while functional, is prone to errors such as buffer overflows and requires manual memory management. In contrast, a modern C++ approach would use standard library functions such as <code>std::copy</code>:</p>
<pre class="source-code">
void copy_array(const std::vector&lt;char&gt;&amp; source, std::vector&lt;char&gt;&amp; destination) {
    std::copy(source.begin(), source.end(), std::back_inserter(destination));
}</pre>
<p>Using <code>std::copy</code> not only simplifies the code but also leverages well-tested library functions that handle edge cases and improve safety.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Inheritance versus templates</h2>
<p>Another area <a id="_idIndexMarker101"/>where C++ offers multiple solutions is code reuse and abstraction. Some projects prefer using inheritance, which can lead to a rigid and complex hierarchy:</p>
<pre class="source-code">
class Shape {
public:
    virtual void draw() const = 0;
    virtual ~Shape() = default;
};
class Circle : public Shape {
public:
    void draw() const override {
        // Draw circle
    }
};
class Square : public Shape {
public:
    void draw() const override {
        // Draw square
    }
};
class ShapeDrawer {
public:
    explicit ShapeDrawer(std::unique_ptr&lt;Shape&gt; shape) : shape_(std::move(shape)) {}
    void draw() const {
        shape_-&gt;draw();
    }
private:
    std::unique_ptr&lt;Shape&gt; shape_;
};</pre>
<p>While<a id="_idIndexMarker102"/> inheritance provides a clear structure and allows polymorphic behavior, it can become cumbersome as the hierarchy grows. An alternative approach is to use templates to achieve polymorphism without the overhead of virtual functions. Here’s how templates can be used to achieve similar functionality:</p>
<pre class="source-code">
template&lt;typename ShapeType&gt;
class ShapeDrawer {
public:
    explicit ShapeDrawer(ShapeType shape) : shape_(std::move(shape)) {}
    void draw() const {
        shape_.draw();
    }
private:
    ShapeType shape_;
};
class Circle {
public:
    void draw() const {
        // Draw circle
    }
};
class Square {
public:
    void draw() const {
        // Draw square
    }
};</pre>
<p>In this <a id="_idIndexMarker103"/>example, <code>ShapeDrawer</code> uses templates to achieve polymorphic behavior. <code>ShapeDrawer</code> can work with any type that provides a <code>draw</code> method. This approach avoids the overhead associated with virtual function calls and can be more efficient, especially in performance-critical applications.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Example – handling errors</h2>
<p>Another <a id="_idIndexMarker104"/>example of solving the same problem in different ways is error handling. Consider a project where Bob uses a traditional error code:</p>
<pre class="source-code">
int process_file(const std::string&amp; filename) {
    FILE* file = fopen(filename.c_str(), "r");
    if (!file) {
        return -1; // Error opening file
    }
    // Process file
    return fclose(file);
}</pre>
<p>Alice, on the other hand, prefers using exceptions for error handling:</p>
<pre class="source-code">
void process_file(const std::string&amp; filename) {
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("Error opening file");
    }
    // Process file
}</pre>
<p>Using exceptions can make the code cleaner by separating error handling from the main logic, but it requires an understanding of exception safety and handling. Error code, while simpler, can clutter the code with repetitive checks and may be less informative.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Projects using different approaches</h2>
<p>In real-world projects, you<a id="_idIndexMarker105"/> might encounter a mix of these approaches, reflecting the varied backgrounds and preferences of different developers, such as these examples:</p>
<ul>
<li><strong class="bold">Project A</strong> uses raw pointers and C functions for performance-critical sections, relying on the developers’ expertise to manage memory safely</li>
<li><strong class="bold">Project B</strong> prefers standard library containers and algorithms, prioritizing safety and readability over raw performance</li>
<li><strong class="bold">Project C</strong> employs a deep inheritance hierarchy to model its domain, emphasizing clear relationships between entities</li>
<li><strong class="bold">Project D</strong> utilizes templates extensively to achieve high performance and flexibility, despite the steeper learning curve and potential complexity</li>
</ul>
<p>Each approach has its pros and cons, and choosing the right one depends on the project’s requirements, the team’s expertise, and the specific problem being solved. However, these multiple ways of solving the same problem can lead to a fragmented and inconsistent code base if not managed carefully.</p>
<p>C++ provides multiple ways to solve the same problem, from raw pointers and C functions to standard library containers and templates. While this flexibility is powerful, it can also lead to inconsistencies and complexity in a code base. Understanding the strengths and weaknesses of each approach and striving for consistency through coding standards and team agreements is crucial for maintaining high-quality, maintainable code. By embracing modern C++ features and best practices, developers can write code that is both efficient and robust, reducing the likelihood of errors and improving overall code quality.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Lack of knowledge in C++</h1>
<p>One of the <a id="_idIndexMarker106"/>major contributors to bad code is a lack of knowledge in C++. C++ is a complex and evolving language with a wide range of features, and staying updated with its latest standards requires continuous learning. Developers who are not familiar with modern C++ practices can inadvertently write inefficient or error-prone code. This section explores how gaps in understanding C++ can lead to various issues, using examples to illustrate common pitfalls.</p>
<p>Consider two developers, Bob and Alice. Bob has extensive experience with older versions of C++ but hasn’t kept up with recent updates, while Alice is well versed in modern C++ features.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Using raw pointers and manual memory management</h2>
<p>Bob might use raw pointers and manual memory management, a common practice in older C++ code:</p>
<pre class="source-code">
void process() {
    int* data = new int[100];
    // ... perform operations on data
    delete[] data;
}</pre>
<p>This<a id="_idIndexMarker107"/> approach is prone to errors such as memory leaks and undefined behavior if <code>delete[]</code> is missed or incorrectly matched with <code>new</code>. For instance, if an exception is thrown after the allocation but before <code>delete[]</code>, the memory will leak. Alice, familiar with modern C++, would use <code>std::vector</code> to manage memory safely and efficiently:</p>
<pre class="source-code">
void process() {
    std::vector&lt;int&gt; data(100);
    // ... perform operations on data
}</pre>
<p>Using <code>std::vector</code> eliminates the need for manual memory management, reducing the risk of memory leaks and making the code more robust and easier to maintain.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Incorrect use of smart pointers</h2>
<p>Bob tries to adopt modern practices but misuses <code>std::shared_ptr</code>, leading to potential performance issues:</p>
<pre class="source-code">
std::shared_ptr&lt;int&gt; create() {
    std::shared_ptr&lt;int&gt; ptr(new int(42));
    return ptr;
}</pre>
<p>This<a id="_idIndexMarker108"/> approach involves two separate allocations: one for the integer and another for the control block of <code>std::shared_ptr</code>. Alice, knowing the benefits of <code>std::make_shared</code>, uses it to optimize memory allocation:</p>
<pre class="source-code">
std::shared_ptr&lt;int&gt; create() {
    return std::make_shared&lt;int&gt;(42);
}</pre>
<p><code>std::make_shared</code> combines the allocations into a single memory block, improving performance and cache locality.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Efficient use of move semantics</h2>
<p>Bob might not fully understand move semantics and how they can improve performance when dealing with temporary objects. Consider a function that appends elements to <code>std::vector</code>:</p>
<pre class="source-code">
void append_data(std::vector&lt;int&gt;&amp; target, const std::vector&lt;int&gt;&amp; source) {
    for (const int&amp; value : source) {
        target.push_back(value); // Copies each element
    }
}</pre>
<p>This approach involves copying each element from <code>source</code> to <code>target</code>, which can be inefficient. Alice, understanding move semantics, would optimize this by using <code>std::move</code>:</p>
<pre class="source-code">
void append_data(std::vector&lt;int&gt;&amp; target, std::vector&lt;int&gt;&amp;&amp; source) {
    for (int&amp; value : source) {
        target.push_back(std::move(value)); // Moves each element
    }
}</pre>
<p>By using <code>std::move</code>, Alice ensures that each element is moved rather than copied, which is more efficient. Additionally, Alice might also consider using <code>std::move</code> for the entire <a id="_idIndexMarker109"/>container if <code>source</code> is no longer needed:</p>
<pre class="source-code">
void append_data(std::vector&lt;int&gt;&amp; target, std::vector&lt;int&gt;&amp;&amp; source) {
    target.insert(target.end(), std::make_move_iterator(source.begin()), std::make_move_iterator(source.end()));
}</pre>
<p>This approach moves the elements of the entire container efficiently, leveraging move semantics to avoid unnecessary copying.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Misusing const correctness</h2>
<p>Bob might neglect const correctness, leading to potential bugs and unclear code:</p>
<pre class="source-code">
class MyClass {
public:
    int get_value() { return value; }
    void set_value(int v) { value = v; }
private:
    int value;
};</pre>
<p>Without const correctness, it’s unclear whether <code>get_value</code> modifies the state of the object. Alice applies const correctness to clarify the intent and improve safety:</p>
<pre class="source-code">
class MyClass {
public:
    int get_value() const { return value; }
    void set_value(int v) { value = v; }
private:
    int value;
};</pre>
<p>Marking <code>get_value</code> as <code>const</code> guarantees that it does not modify the object, making the code clearer <a id="_idIndexMarker110"/>and preventing accidental modifications.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Inefficient string handling</h2>
<p>Bob might handle strings using C-style character arrays, which can lead to buffer overflows and complex code:</p>
<pre class="source-code">
char message[100];
strcpy(message, "Hello, world!");
std::cout &lt;&lt; message &lt;&lt; std::endl;</pre>
<p>This approach is error-prone and difficult to manage. Alice, aware of the capabilities of <code>std::string</code>, simplifies the code and avoids potential errors:</p>
<pre class="source-code">
std::string message = "Hello, world!";
std::cout &lt;&lt; message &lt;&lt; std::endl;</pre>
<p>Using <code>std::string</code> provides automatic memory management and a rich set of functions for string manipulation, making the code safer and more expressive.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Undefined behavior with lambdas</h2>
<p>Lambda functions introduced in C++11 provide powerful capabilities, but they can lead to undefined behavior if not used correctly. Bob might write a lambda that captures a local variable by reference and returns it, leading to dangling references:</p>
<pre class="source-code">
auto create_lambda() {
    int value = 42;
    return [&amp;]() { return value; };
}
auto lambda = create_lambda();
int result = lambda(); // Undefined behavior</pre>
<p>Alice, understanding the risks, captures the variable by value to ensure it remains valid:</p>
<pre class="source-code">
auto create_lambda() {
    int value = 42;
    return [=]() { return value; };
}
auto lambda = create_lambda();
int result = lambda(); // Safe</pre>
<p>Capturing by value avoids the risk of dangling references and ensures the lambda remains safe to use.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Misunderstanding undefined behavior</h2>
<p>Bob might inadvertently <a id="_idIndexMarker111"/>write code that leads to undefined behavior by relying on uninitialized variables:</p>
<pre class="source-code">
int sum() {
    int x;
    int y = 5;
    return x + y; // Undefined behavior: x is uninitialized
}</pre>
<p>Accessing uninitialized variables can lead to unpredictable behavior and hard-to-debug issues. Alice, understanding<a id="_idIndexMarker112"/> the importance of initialization, ensures that all variables are properly initialized:</p>
<pre class="source-code">
int sum() {
    int x = 0;
    int y = 5;
    return x + y; // Defined behavior
}</pre>
<p>Properly initializing variables prevents undefined behavior and makes the code more reliable.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Misuse of C-style arrays</h2>
<p>Using C-style arrays <a id="_idIndexMarker113"/>can lead to various issues, such as a lack of bounds checking and difficulty in managing array sizes. Consider the following example where a function creates a C array on the stack and returns it:</p>
<pre class="source-code">
int* create_array() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr; // Undefined behavior: returning a pointer to a local array
}</pre>
<p>Returning a pointer to a local array leads to undefined behavior because the array goes out of scope when the function returns. A safer approach is to use <code>std::array</code>, which can be returned safely from a function. It provides the <code>size</code> method and is compatible with C++ algorithms such as <code>std::sort</code>:</p>
<pre class="source-code">
std::array&lt;int, 5&gt; create_array() {
    return {1, 2, 3, 4, 5};
}</pre>
<p>Using <code>std::array</code> not only avoids undefined behavior but also enhances safety and interoperability with the C++ Standard Library. For example, sorting an array becomes straightforward:</p>
<pre class="source-code">
std::array&lt;int, 5&gt; arr = create_array();
std::sort(arr.begin(), arr.end());</pre>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Insufficient pointer usage</h1>
<p>Modern C++ provides <a id="_idIndexMarker114"/>smart pointers such as <code>std::unique_ptr</code> and <code>std::shared_ptr</code> to manage dynamic memory more safely and efficiently. It’s generally better to use <code>std::unique_ptr</code> instead of raw pointers for exclusive ownership. When multiple actors need to share ownership of a resource, <code>std::shared_ptr</code> can be used. However, there are common issues related to the misuse of <code>std::shared_ptr</code>.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Building std::shared_ptr</h2>
<p>Using the <a id="_idIndexMarker115"/>constructor of <code>std::shared_ptr</code> to create an object leads to separate allocations for the control block and the managed object:</p>
<pre class="source-code">
std::shared_ptr&lt;int&gt; create() {
    std::shared_ptr&lt;int&gt; ptr(new int(42));
    return ptr;
}</pre>
<p>A better approach is to use <code>std::make_shared</code>, which combines the allocations into a single memory block, improving performance and cache locality:</p>
<pre class="source-code">
std::shared_ptr&lt;int&gt; create() {
    return std::make_shared&lt;int&gt;(42);
}</pre>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Copying std::shared_ptr by value</h2>
<p>Copying <code>std::shared_ptr</code> by value<a id="_idIndexMarker116"/> within the same thread stack is less efficient because the reference counter is atomic. It’s recommended to pass <code>std::shared_ptr</code> by reference:</p>
<pre class="source-code">
void process_shared_ptr(std::shared_ptr&lt;int&gt; ptr) {
    // Inefficient: copies shared_ptr by value
}
void process_shared_ptr(const std::shared_ptr&lt;int&gt;&amp; ptr) {
    // Efficient: passes shared_ptr by reference
}</pre>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Cyclic dependencies with std::shared_ptr</h2>
<p>Cyclic dependencies<a id="_idIndexMarker117"/> can occur when two or more <code>std::shared_ptr</code> instances reference each other, preventing the reference count from reaching zero and causing memory leaks. Consider the following example:</p>
<pre class="source-code">
struct B;
struct A {
    std::shared_ptr&lt;B&gt; b_ptr;
    ~A() { std::cout &lt;&lt; "A destroyed\n"; }
};
struct B {
    std::shared_ptr&lt;A&gt; a_ptr;
    ~B() { std::cout &lt;&lt; "B destroyed\n"; }
};
void create_cycle() {
    auto a = std::make_shared&lt;A&gt;();
    auto b = std::make_shared&lt;B&gt;();
    a-&gt;b_ptr = b;
    b-&gt;a_ptr = a;
}</pre>
<p>In this <a id="_idIndexMarker118"/>scenario, <code>A</code> and <code>B</code> reference each other, creating a cycle that prevents their destruction. This issue can be resolved using <code>std::weak_ptr</code> to break the cycle:</p>
<pre class="source-code">
struct B;
struct A {
    std::weak_ptr&lt;B&gt; b_ptr; // Use weak_ptr to break the cycle
    ~A() { std::cout &lt;&lt; "A destroyed\n"; }
};
struct B {
    std::shared_ptr&lt;A&gt; a_ptr;
    ~B() { std::cout &lt;&lt; "B destroyed\n"; }
};
void create_cycle() {
    auto a = std::make_shared&lt;A&gt;();
    auto b = std::make_shared&lt;B&gt;();
    a-&gt;b_ptr = b;
    b-&gt;a_ptr = a;
}</pre>
<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Checking the std::weak_ptr status</h2>
<p>A common mistake<a id="_idIndexMarker119"/> when using <code>std::weak_ptr</code> is to check its status with <code>expired()</code> and then lock it, which is not thread-safe:</p>
<pre class="source-code">
std::weak_ptr&lt;int&gt; weak_ptr = some_shared_ptr;
void check_and_use_weak_ptr() {
    if (!weak_ptr.expired()) {
        // This is not thread-safe
        auto shared_ptr = weak_ptr.lock();
        shared_ptr-&gt;do_something();
    }
}</pre>
<p>The correct approach is to lock <code>std::weak_ptr</code> and check that the returned <code>std::shared_ptr</code> is not <code>null</code>:</p>
<pre class="source-code">
void check_and_use_weak_ptr_correctly() {
    // This is thread-safe
    if (auto shared_ptr = weak_ptr.lock()) {
        // Use shared_ptr
        shared_ptr-&gt;do_something();
    }
}</pre>
<p>Lack of knowledge in C++ can lead to various issues, from memory management errors to inefficient and unreadable code. By staying updated with modern C++ features and best practices, developers <a id="_idIndexMarker120"/>can write code that is safer, more efficient, and easier to maintain. Continuous learning and adaptation are key to overcoming these challenges and improving overall code quality. Bob and Alice’s examples highlight the importance of understanding and applying modern C++ practices to avoid common pitfalls and produce high-quality code.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Summary</h1>
<p>In this chapter, we explored various causes of bad code in C++ and how a lack of knowledge in modern C++ practices can lead to inefficient, error-prone, or undefined behavior. By examining specific examples, we highlighted the importance of continuous learning and adaptation to keep up with the evolving features of C++.</p>
<p>We began by discussing the pitfalls of using raw pointers and manual memory management, showing how modern C++ practices such as <code>std::vector</code> can eliminate the need for manual memory management and reduce the risk of memory leaks. The advantages of using <code>std::unique_ptr</code> for exclusive ownership and <code>std::shared_ptr</code> for shared ownership were emphasized, while common issues such as inefficient memory allocation, unnecessary copying, and cyclic dependencies were highlighted.</p>
<p>In the context of <code>std::shared_ptr</code>, we demonstrated the benefits of using <code>std::make_shared</code> over the constructor to reduce memory allocations and improve performance. The efficiency gained by passing <code>std::shared_ptr</code> by reference rather than by value due to the atomic reference counter was also explained. We illustrated the problem of cyclic dependencies and how <code>std::weak_ptr</code> can be used to break cycles and prevent memory leaks. The correct way to check and use <code>std::weak_ptr</code> by locking it and checking the resulting <code>std::shared_ptr</code> to ensure thread safety was also covered.</p>
<p>Efficient use of move semantics was discussed to optimize performance by reducing unnecessary copying of temporary objects. Using <code>std::move</code> and <code>std::make_move_iterator</code> can significantly enhance program performance. The importance of const correctness was highlighted, showing how applying <code>const</code> to methods can clarify intent and improve code safety.</p>
<p>We addressed the dangers of using C-style character arrays and how <code>std::string</code> can simplify string handling, reduce errors, and provide better memory management. The misuse of C-style arrays was explored, and <code>std::array</code> was presented as a safer and more robust alternative. By using <code>std::array</code>, we can avoid undefined behavior and leverage C++ Standard Library algorithms such as <code>std::sort</code>.</p>
<p>Finally, the proper use of lambda functions was discussed, along with the potential pitfalls of capturing variables by reference, which can lead to dangling references. Capturing variables by value ensures that the lambda remains safe to use.</p>
<p>Through these examples, we learned about the critical importance of adopting modern C++ features and best practices to write safer, more efficient, and maintainable code. By staying updated with the latest standards and continuously improving our understanding of C++, we can avoid common pitfalls and produce high-quality software.</p>
</div>
</body></html>