- en: Elements of WebAssembly - Wat, Wasm, and the JavaScript API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly的元素 - Wat、Wasm和JavaScript API
- en: '[Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    described the history of WebAssembly and provided a high-level overview of the
    technology as well as the potential use cases and limitations. WebAssembly was
    described as being composed of multiple elements, not just the binary instruction
    format specified in the official definition.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)，*什么是WebAssembly？*，描述了WebAssembly的历史，并提供了该技术的概述以及潜在的使用案例和限制。WebAssembly被描述为由多个元素组成，而不仅仅是官方定义中指定的二进制指令格式。'
- en: In this chapter, we will dig into the elements that correspond to the official
    specifications created by the WebAssembly Working Group. We will examine the Wat
    and the binary format in greater detail to gain a better understanding of how
    they relate to modules. We will review the *JavaScript API* and *Web API* to ensure
    you're able to utilize the WebAssembly effectively in the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨与WebAssembly工作组创建的官方规范相对应的元素。我们将更详细地研究Wat和二进制格式，以更好地理解它们与模块的关系。我们将回顾*JavaScript
    API*和*Web API*，以确保您能够有效地在浏览器中使用WebAssembly。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解以下内容：
- en: How the text and binary formats are related
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本格式和二进制格式之间的关系
- en: What Wat is and where it fits in to the development process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wat是什么以及它在开发过程中的位置
- en: The binary format and module (Wasm) file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制格式和模块（Wasm）文件
- en: The components of the JavaScript and Web API and how they relate to the Wasm
    module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript和Web API的组成部分以及它们与Wasm模块的关系
- en: How to utilize WasmFiddle to evaluate the phases of WebAssembly (C/C++ > Wat
    > Wasm)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用WasmFiddle评估WebAssembly（C/C++ > Wat > Wasm）的阶段
- en: Common structure and abstract syntax
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见结构和抽象语法
- en: 'In [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    we talked about how the binary and text formats of WebAssembly both map to a common
    structure in the form of an abstract syntax. Before getting into the nuts and
    bolts of these formats, it''s worth mentioning how these are related within the
    *Core Specification*. The following diagram is a visual representation of the
    table of contents (with some sections excluded for clarity):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)，*什么是WebAssembly？*中，我们讨论了WebAssembly的二进制和文本格式如何映射到以抽象语法形式存在的共同结构。在深入探讨这些格式的细节之前，值得提及的是它们在*核心规范*中的关系。以下图表是目录的视觉表示（为了清晰起见，省略了一些部分）：
- en: '![](img/24a8a8a0-7afd-4ffe-892c-bb162b09b784.png)*Core Specification* table
    of contents'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/24a8a8a0-7afd-4ffe-892c-bb162b09b784.png)*核心规范*目录'
- en: As you can see, the **Text Format** and **Binary Format** sections contain subsections
    for **Values**, **Types**, **Instructions**, and **Modules** that correlate with
    the **Structure** section. Consequently, much of what we cover in the next section
    for the text format have direct corollaries with the binary format. With that
    in mind, let's dive into the text format.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**文本格式**和**二进制格式**部分包含与**结构**部分相对应的**值**、**类型**、**指令**和**模块**的子部分。因此，我们在下一节中涵盖的文本格式的大部分内容与二进制格式有直接对应关系。考虑到这一点，让我们深入文本格式。
- en: Wat
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wat
- en: The *Text Format* section of the *Core Specification* provides technical descriptions
    for common language concepts such as values, types, and instructions. These are
    important concepts to know and understand if you're planning on building tooling
    for WebAssembly, but not necessary if you just plan on using it in your applications.
    That being said, the text format is an important part of WebAssembly, so there
    are concepts you should be aware of. In this section, we will dig into some of
    the details of the text format and highlight important points from the *Core Specification*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心规范*的*文本格式*部分提供了对常见语言概念（如值、类型和指令）的技术描述。如果您计划为WebAssembly构建工具，了解这些概念很重要，但如果您只是计划在应用程序中使用它，则不是必需的。尽管如此，文本格式是WebAssembly的重要组成部分，因此您应该了解一些概念。在本节中，我们将深入研究文本格式的某些细节，并突出*核心规范*中的重要观点。'
- en: Definitions and S-expressions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和S表达式
- en: 'To understand Wat, let''s start with the first sentence of the description
    taken directly from the WebAssembly *Core Specification*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Wat，让我们从WebAssembly *核心规范*的描述中的第一句话开始：
- en: '"The textual format for WebAssembly modules is a rendering of their abstract
    syntax into S-expressions."'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"WebAssembly模块的文本格式是将它们的抽象语法渲染成S表达式。"'
- en: So what are **symbolic expressions** (**S-expressions**)? S-expressions are
    notations for nested list (tree-structured) data. Essentially, they provide a
    simple and elegant way to represent list-based data in textual form. To understand
    how textual representations of nested lists map to a tree structure, let's extrapolate
    the tree structure from an HTML page. The following example contains a simple
    HTML page and the corresponding tree structure diagram.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是**符号表达式**（**S-expressions**）？S-expressions是嵌套列表（树结构）数据的表示法。本质上，它们提供了一种简单而优雅的方式来以文本形式表示基于列表的数据。为了理解嵌套列表的文本表示如何映射到树结构，让我们从一个HTML页面中提取树结构。以下示例包含一个简单的HTML页面和相应的树结构图。
- en: 'A simple HTML page:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的HTML页面：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The corresponding tree structure is:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的树结构是：
- en: '![](img/fbdfac80-c6f7-45cb-beb9-5ebdc2ed8ffe.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbdfac80-c6f7-45cb-beb9-5ebdc2ed8ffe.png)'
- en: A tree structure diagram for an HTML page
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面的树结构图
- en: Even if you've never seen a tree structure before, it's still clear to see how
    the HTML maps to the tree in terms of structure and hierarchy. Mapping HTML elements
    is relatively simple because it's a markup language with well-defined tags and
    no actual logic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你以前从未见过树结构，仍然可以清楚地看到HTML在结构和层次方面如何映射到树。映射HTML元素相对简单，因为它是一种具有明确定义标签而没有实际逻辑的标记语言。
- en: 'Wat represents modules that can have multiple functions with varying parameters.
    To demonstrate the relationship between source code, Wat, and the corresponding
    tree structure, let''s start with a simple C function that adds 2 to the number
    that is passed in as a parameter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Wat表示可以具有多个具有不同参数的模块。为了演示源代码、Wat和相应的树结构之间的关系，让我们从一个简单的C函数开始，该函数将2加到作为参数传入的数字上：
- en: 'Here is a C function that adds `2` to the `num` argument passed in and returns
    the result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个C函数，它将`2`加到传入的`num`参数上并返回结果：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Converting the `addTwo` function to valid Wat produces this result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将`addTwo`函数转换为有效的Wat得到以下结果：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    we talked about language concepts associated with the *Core Specification* (*Functions*,
    *Linear Memory*, *Tables*, and so on). Within that specification, the *Structure*
    section defines each of these concepts in the context of an abstract syntax. The
    *Text Format* section of the specification corresponds with these concepts as
    well, and you can see them defined by their keywords in the preceding snippet
    (`func`, `memory`, `table`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)，“什么是WebAssembly？”中，我们讨论了与*核心规范*相关的语言概念（*函数*、*线性内存*、*表*等）。在该规范中，*结构*部分在抽象语法的上下文中定义了这些概念。规范的*文本格式*部分也与这些概念相对应，你可以在前面的代码片段（`func`、`memory`、`table`）中看到它们的定义。
- en: 'Tree Structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构：
- en: '![](img/28fa4fdc-1b9e-4672-b752-8bb1a272e9e0.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28fa4fdc-1b9e-4672-b752-8bb1a272e9e0.png)'
- en: A tree structure diagram for Wat
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Wat的树结构图
- en: The entire tree would be too large to fit on a page, so this diagram is limited
    to the first five lines of the Wat source text. Each filled-in dot represents
    a list node (or the contents of a set of parentheses). As you can see, code written
    in s-expressions can be clearly and concisely expressed in a tree structure, which
    is why s-expressions were chosen for WebAssembly's text format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 整个树结构太大，无法在一页上显示，因此此图仅限于Wat源文本的前五行。每个填充的点代表一个列表节点（或一组括号的内容）。正如你所见，用s-expressions编写的代码可以清晰地以树结构简洁地表达，这也是为什么s-expressions被选为WebAssembly的文本格式。
- en: Values, types, and instructions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值、类型和指令
- en: 'Although detailed coverage of the *Text Format* section of the *Core Specification*
    is out of the scope of this text, it''s worth demonstrating how some of the language
    concepts map to the corresponding Wat. The following diagram demonstrates these
    mappings in a sample Wat snippet. The C code that this was compiled from represents
    a function that takes a word as a parameter and returns the square root of the
    character count:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对*核心规范*中*文本格式*部分的详细说明超出了本文的范围，但展示一些语言概念如何映射到相应的Wat仍然很有价值。以下图表通过一个Wat代码片段展示了这些映射。从编译此代码的C语言代码表示一个函数，该函数接受一个单词作为参数并返回字符计数的平方根：
- en: '![](img/7c3b4124-7f45-49c6-a933-de3bf3861864.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c3b4124-7f45-49c6-a933-de3bf3861864.png)'
- en: Wat example with language concept details
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 包含语言概念细节的Wat示例
- en: If you intend on writing or editing Wat, note that it supports block and line
    comments. The instructions are split up into blocks and consist of setting and
    getting memory associated with variables with valid types. You are able to control
    the flow of logic using `if` statements and loops are supported using the `loop`
    keyword.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算编写或编辑 Wat，请注意它支持块和行注释。指令被分成块，包括设置和获取与变量相关联的内存，这些变量具有有效的类型。您可以使用 `if` 语句控制逻辑流程，并使用
    `loop` 关键字支持循环。
- en: Role in the development process
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发过程中的作用
- en: 'The text format allows for the representation of a binary Wasm module in textual
    form. This has some profound implications with regard to the ease of development
    and debugging. Having a textual representation of a WebAssembly module allows
    developers to view the source of a loaded module in a browser, which eliminates
    the black-box issues that inhibited the adoption of NaCl. It also allows for tooling
    to be built around troubleshooting modules. The official website describes the
    use cases that drove the design of the text format:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文本格式允许以文本形式表示二进制 Wasm 模块。这在开发调试的易用性方面具有深远的影响。拥有 WebAssembly 模块的文本表示允许开发者在一个浏览器中查看加载模块的源代码，这消除了阻碍
    NaCl 采用的黑盒问题。它还允许围绕模块故障排除构建工具。官方网站描述了推动文本格式设计的用例：
- en: • View Source on a WebAssembly module, thus fitting into the Web (where every
    source can be viewed) in a natural way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebAssembly 模块上查看源代码，从而以自然的方式融入 Web（在 Web 中，可以查看每个源）。
- en: • Presentation in browser development tools when source maps aren't present
    (which is necessarily the case with the Minimum Viable Product (MVP)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器开发工具中呈现时没有源映射（这在最小可行产品（MVP）的情况下是必然的）。
- en: • Writing WebAssembly code directly for reasons including pedagogical, experimental,
    debugging, optimization, and testing of the spec itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: •   直接编写 WebAssembly 代码，原因包括教学、实验、调试、优化和规范本身的测试。
- en: The last item in the list reflects that the text format isn't intended to be
    written by hand in the course of normal development, but rather generated from
    a tool like Emscripten. You probably won't see or manipulate any `.wat` files
    when you're generating modules, but you may be viewing them in a debugging context.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后一项反映了文本格式并不是在正常开发过程中手动编写的，而是从 Emscripten 等工具生成。在生成模块时，您可能不会看到或操作任何 `.wat`
    文件，但在调试环境中可能会查看它们。
- en: Not only is the text format valuable with regards to debugging, but having this
    intermediate format reduces the amount of reliance on a single tool for compilation.
    Several different tools currently exist to consume and emit this s-expression
    syntax, some of which are used by Emscripten to compile your code down to a `.wasm`
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅文本格式在调试方面有价值，而且拥有这种中间格式减少了对于单一编译工具的依赖。目前存在多种不同的工具可以消费和生成这种 s-expression 语法，其中一些被
    Emscripten 用于将您的代码编译成 `.wasm` 文件。
- en: Binary format and the module file (Wasm)
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制格式和模块文件（Wasm）
- en: The *Binary Format* section of the *Core Specification* provides the same level
    of detail with regard to language concepts as the *Text format* section. In this
    section, we will briefly cover some high-level details about the binary format
    and discuss the various sections that make up a Wasm module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 核心规范中的 *二进制格式* 部分提供了与 *文本格式* 部分相同级别的语言概念细节。在本节中，我们将简要介绍二进制格式的某些高级细节，并讨论构成 Wasm
    模块的各个部分。
- en: Definition and module overview
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和模块概述
- en: The binary format is defined as a dense linear encoding of the abstract syntax.
    Without getting too technical, that essentially means it's an efficient form of
    binary that allows for fast decoding, small file size, and reduced memory usage.
    The file representation of the binary format is a `.wasm` file, which will be
    the compilation output from Emscripten that we'll use for our examples.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制格式被定义为抽象语法的密集线性编码。不深入技术细节的话，这基本上意味着它是一种高效的二进制形式，允许快速解码、小文件大小和减少内存使用。二进制格式的文件表示形式是
    `.wasm` 文件，这是我们使用 Emscripten 编译并用于示例的输出。
- en: The *Values*, *Types*, and *Instructions* subsections of the *Core Specification*
    for the binary format correlate directly to the *Text Format* section. Each of
    these concepts is covered in the context of encoding. For example, according to
    the specification, the Integer types are encoded using the LEB128 variable-length
    integer encoding, in either unsigned or signed variant. These are important details
    to know if you wish to develop tooling for WebAssembly, but not necessary if you
    just plan on using it on your website.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制格式的*核心规范*的*值*、*类型*和*指令*子部分直接对应于*文本格式*部分。每个概念都在编码的上下文中进行了介绍。例如，根据规范，整数类型使用LEB128可变长度整数编码进行编码，可以是无符号或带符号的变体。如果您希望为WebAssembly开发工具，这些是重要的细节，但如果您只是计划在网站上使用它，则不是必需的。
- en: 'The *Structure*, *Binary Format*, and *Text Format* *(wat)* sections of the
    *Core Specification* have a *Module* subsection. We didn''t cover aspects of the
    module in the previous section because it''s more prudent to describe them in
    the context of a binary. The official WebAssembly site offers the following description
    for a module:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心规范*的*结构*、*二进制格式*和*文本格式*（wat）部分有一个*模块*子部分。我们之所以在上一个部分中没有涵盖模块的方面，是因为在二进制上下文中描述它们更为谨慎。官方WebAssembly网站为模块提供了以下描述：'
- en: '"The distributable, loadable, and executable unit of code in WebAssembly is
    called a **module**. At runtime, a module can be **instantiated** with a set of
    import values to produce an **instance**, which is an immutable tuple referencing
    all the state accessible to the running module."'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “在WebAssembly中，可分发、可加载和可执行的代码单元称为**模块**。在运行时，可以使用一组导入值**实例化**一个模块，生成一个**实例**，它是一个不可变的元组，引用了运行模块可访问的所有状态。”
- en: We will discuss how to interact with the module using the JavaScript and Web
    APIs later in this chapter, so let's establish some context to understand how
    the module elements map to the API methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论如何使用JavaScript和Web API与模块交互，因此让我们先建立一些背景知识，以便理解模块元素如何映射到API方法。
- en: Module sections
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块部分
- en: 'A module is made up of several sections, some of which you''ll be interacting
    with through the JavaScript API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 模块由几个部分组成，其中一些部分您将通过JavaScript API与之交互：
- en: 'Imports (`import`) are elements that can be accessed within the module and
    can be one of the following:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入（`import`）是模块内可以访问的元素，可以是以下之一：
- en: Function, which can be called inside the module using the `call` operator
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数，可以使用`call`操作符在模块内调用
- en: Global, which can be accessed inside the module via the `global` operators
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局（`global`），可以通过模块内的`global`操作符访问
- en: Linear Memory, which can be accessed inside the module via the `memory` operators
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性内存，可以通过模块内的`memory`操作符访问
- en: Table, which can be accessed inside the module using `call_indirect`
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表，可以使用`call_indirect`在模块内访问
- en: Exports (`export`) are elements that can be accessed by the consuming API (that
    is, called by a JavaScript function)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出（`export`）是可以由消费API（即由JavaScript函数调用）访问的元素
- en: Module start function (`start`) is called after the module instance is initialized
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块启动函数（`start`）在模块实例初始化后调用
- en: Global (`global`) contains the internal definition of global variables
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局（`global`）包含全局变量的内部定义
- en: Linear memory (`memory`) contains the internal definition of linear memory with
    an initial memory size and optional maximum size
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性内存（`memory`）包含具有初始内存大小和可选最大大小的线性内存的内部定义
- en: Data (`data`) contains an array of data segments which specify the initial contents
    of fixed ranges of a given memory
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据（`data`）包含数据段数组，指定给定内存固定范围的初始内容
- en: 'Table (`table`) is a linear memory whose elements are opaque values of a particular
    table element type:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表（`table`）是一个线性内存，其元素是特定表元素类型的不可见值：
- en: In the MVP, its primary purpose is to implement indirect function calls in C/C++
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MVP中，其主要目的是在C/C++中实现间接函数调用
- en: Elements (`elements`) is a section that allows a module to initialize the elements
    of any import or internally defined table with any other definition in the module
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素（`elements`）是一个部分，允许模块使用模块中的任何其他定义初始化任何导入或内部定义的表元素
- en: 'Function and code:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和代码：
- en: The function section declares the signatures of each internal function defined
    in the module
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数部分声明了模块中定义的每个内部函数的签名
- en: The code section contains the function body of each function declared by the
    function section
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码部分包含函数部分声明的每个函数的函数体
- en: Some of the keywords (`import`, `export`, and so on) should look familiar; they're
    present in the contents of the Wat file in the previous section. WebAssembly's
    components follow a logical mapping that directly correspond to the APIs  (for
    example, you pass a `memory` and `table` instance into JavaScript's `WebAssembly.instantiate()`
    function). Your primary interaction with a module in binary format will be through
    these APIs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关键字（如 `import`、`export` 等）应该看起来很熟悉；它们出现在前一个章节 Wat 文件的内容中。WebAssembly 的组件遵循一种逻辑映射，直接对应于
    API（例如，你将 `memory` 和 `table` 实例传递给 JavaScript 的 `WebAssembly.instantiate()` 函数）。你与二进制格式模块的主要交互将通过这些
    API 进行。
- en: The JavaScript and Web APIs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 和 Web API
- en: 'In addition to the *WebAssembly Core Specification*, there are two API specifications
    for interacting with WebAssembly modules: the *WebAssembly JavaScript Interface* (JavaScript
    API) and the *WebAssembly Web API*. In the previous sections, we covered pertinent
    aspects of the *Core Specification* to become familiar with the underlying technology.
    If you never read the *Core Specification* (or if you skipped the first few sections
    of this chapter), it wouldn''t inhibit the use of WebAssembly in your application.
    That is not the case for the APIs, as they describe the methods and interface
    required to instantiate and interact with your compiled Wasm module. In this section,
    we will review the Web and JavaScript APIs and describe how to load and communicate
    with a Wasm module using JavaScript.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 *WebAssembly 核心规范* 之外，还有两个 API 规范用于与 WebAssembly 模块交互：*WebAssembly JavaScript
    接口*（JavaScript API）和 *WebAssembly Web API*。在前面的章节中，我们介绍了 *核心规范* 的相关方面，以便熟悉底层技术。如果你从未阅读过
    *核心规范*（或者如果你跳过了本章的前几节），这不会妨碍你在应用程序中使用 WebAssembly。对于 API 来说并非如此，因为它们描述了实例化和与编译的
    Wasm 模块交互所需的方法和接口。在本节中，我们将回顾 Web 和 JavaScript API，并描述如何使用 JavaScript 加载和与 Wasm
    模块通信。
- en: WebAssembly store and object caches
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 存储和对象缓存
- en: 'Before digging into interactions, let''s discuss the relationship between JavaScript
    and WebAssembly in the context of execution. The *Core Specification* contains
    the following description in the *Execution* section:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入交互之前，让我们讨论在执行上下文中 JavaScript 和 WebAssembly 之间的关系。*核心规范* 在 *执行* 部分包含以下描述：
- en: '"WebAssembly code is executed when instantiating a module or invoking an exported
    function on the resulting module instance.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '"当实例化模块或在生成的模块实例上调用导出的函数时执行 WebAssembly 代码。'
- en: Execution behavior is defined in terms of an abstract machine that models the
    program state. It includes a stack, which records operand values and control constructs,
    and an abstract store containing global state."
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行行为是用一个抽象机器来定义的，该机器模拟程序状态。它包括一个栈，用于记录操作数值和控制结构，以及包含全局状态的抽象存储。
- en: 'Under the hood, JavaScript uses something called **agents** to manage execution.
    The *store* being referred to in the definition is contained within an agent.
    The following diagram represents a JavaScript agent:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，JavaScript 使用称为 **代理** 的东西来管理执行。定义中提到的 *存储* 包含在一个代理中。以下图表示一个 JavaScript
    代理：
- en: '![](img/d01b7a99-69fe-4b97-b7f2-b4fed202aff1.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d01b7a99-69fe-4b97-b7f2-b4fed202aff1.png)'
- en: JavaScript agent elements
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代理元素
- en: The store represents the state of the abstract machine. WebAssembly operations
    take a store and return an updated store. Each agent is associated with caches
    that map JavaScript objects to WebAssembly addresses. So why is this important?
    It represents the underlying method of interaction between WebAssembly modules
    and JavaScript. The JavaScript objects correspond to the WebAssembly namespace
    within the *JavaScript API*. With that in mind, let's dig into the interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 存储表示抽象机器的状态。WebAssembly 操作接受一个存储并返回一个更新后的存储。每个代理都与映射 JavaScript 对象到 WebAssembly
    地址的缓存相关联。那么这为什么很重要呢？它代表了 WebAssembly 模块与 JavaScript 之间的底层交互方法。JavaScript 对象对应于
    *JavaScript API* 中的 WebAssembly 命名空间。考虑到这一点，让我们深入了解接口。
- en: Loading a module and the WebAssembly namespace methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载模块和 WebAssembly 命名空间方法
- en: 'The *JavaScript API* covers the various objects available on the global `WebAssembly`
    object in the browser. Before we discuss those, we''ll start with the methods
    available on the `WebAssembly` object, with a brief overview of their intended
    purposes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript API* 覆盖了浏览器中全局 `WebAssembly` 对象上可用的各种对象。在我们讨论这些之前，我们将从 `WebAssembly`
    对象上可用的方法开始，简要概述它们的预期用途：'
- en: '`instantiate()` is the primary API for compiling and instantiating WebAssembly
    code'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instantiate()` 是编译和实例化 WebAssembly 代码的主要 API。'
- en: '`instantiateStreaming()` performs the same functionality as `instantiate()`,
    but it uses streaming to compile and instantiate the module, which eliminates
    an intermediate step'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instantiateStreaming()` 执行与 `instantiate()` 相同的功能，但它使用流式处理来编译和实例化模块，从而消除了一个中间步骤。'
- en: '`compile()` only compiles a WebAssembly module, but doesn''t instantiate it'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile()` 仅编译 WebAssembly 模块，但不实例化它。'
- en: '`compileStreaming()` also only compiles a WebAssembly module, but it uses streaming
    similar to `instantiateStreaming()`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compileStreaming()` 也仅编译 WebAssembly 模块，但使用类似于 `instantiateStreaming()` 的流式处理。'
- en: '`validate()` checks the WebAssembly binary code to ensure the bytes are valid
    and returns true if valid or false if not valid'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate()` 检查 WebAssembly 二进制代码以确保字节有效，如果有效则返回 true，否则返回 false。'
- en: The `instantiateStreaming()` and `compileStreaming()` methods are currently
    only present in the *Web API*. In fact, these two methods comprise the entire
    specification. The methods available on the `WebAssembly` object are focused primarily
    on compiling and instantiating modules. With that in mind, let's discuss how to
    fetch and instantiate a Wasm module.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`instantiateStreaming()` 和 `compileStreaming()` 方法目前仅在 *Web API* 中存在。实际上，这两个方法构成了整个规范。`WebAssembly`
    对象上的方法主要关注编译和实例化模块。考虑到这一点，让我们讨论如何获取和实例化 Wasm 模块。'
- en: When you perform a fetch call to get a module, it returns a Promise that resolves
    with the raw bytes of that module, which need to be loaded into an `ArrayBuffer`
    and instantiated. Going forward, we will refer to this process as loading a module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行获取模块的 fetch 调用时，它返回一个 Promise，该 Promise 解决为该模块的原始字节，这些字节需要被加载到 `ArrayBuffer`
    中并实例化。从现在开始，我们将此过程称为加载模块。
- en: 'The following diagram demonstrates this process:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了此过程：
- en: '![](img/368f1c3b-c24a-4265-967f-6347f5fa8b34.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/368f1c3b-c24a-4265-967f-6347f5fa8b34.png)'
- en: Fetching and loading a WebAssembly module
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和加载 WebAssembly 模块
- en: 'This process is actually quite simple using Promises. The following code demonstrates
    how a module is loaded. The `importObj` argument passes any data or functions
    to the Wasm module. You can disregard it for now, as we''ll be discussing it in
    greater detail in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Promise，这个过程实际上相当简单。以下代码演示了如何加载模块。`importObj` 参数传递任何数据或函数到 Wasm 模块。现在你可以忽略它，因为我们将在第
    5 章（51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml）中更详细地讨论它，*创建和加载 WebAssembly 模块*：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding example dictates the method for loading the module using the
    `instantiate()` method. The `instantiateStreaming()` method is a little different
    and simplifies the process even more by fetching, compiling, and instantiating
    a module in a single step. The following code achieves the same goal (loading
    a module) using this method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例说明了使用 `instantiate()` 方法加载模块的方法。`instantiateStreaming()` 方法略有不同，通过单一步骤获取、编译和实例化模块，进一步简化了过程。以下代码使用此方法（加载模块）达到相同的目的：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The instantiation methods return a Promise that resolves with an object containing
    a compiled `WebAssembly.Module` (`module`) and `WebAssembly.Instance` (`instance`),
    both of which will be covered later in this section. In most cases, you will use
    one of these methods to load a Wasm module on your site. The instance contains
    all of the exported WebAssembly functions that you can call from your JavaScript
    code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化方法返回一个 Promise，该 Promise 解决为一个包含编译后的 `WebAssembly.Module`（`module`）和 `WebAssembly.Instance`（`instance`）的对象，这两个对象将在本节稍后讨论。在大多数情况下，你将使用这些方法之一在你的网站上加载
    Wasm 模块。实例包含所有可以从你的 JavaScript 代码中调用的导出 WebAssembly 函数。
- en: The `compile()` and `compileStreaming()` methods return a Promise that only
    resolves with a compiled `WebAssembly.Module`. This is useful if you want to compile
    a module and instantiate it at a later time. **Mozilla Developer Network** (**MDN**),
    the web docs site managed by Mozilla, provides an example in which the compiled
    module is passed to a Web Worker.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile()` 和 `compileStreaming()` 方法返回一个仅当编译成功时才解决的 Promise，它包含一个编译后的 `WebAssembly.Module`。如果你想在稍后时间编译一个模块并实例化它，这非常有用。**Mozilla
    开发者网络**（**MDN**），由 Mozilla 管理的网站，提供了一个示例，其中编译后的模块被传递给一个 Web Worker。'
- en: As far as the `validate()` method is concerned, its only purpose is to test
    whether the typed array or `ArrayBuffer` passed in as a parameter is valid. This
    would be called after the raw bytes of the response are loaded into an `ArrayBuffer`.
    This method wasn't included in the code examples because attempting to instantiate
    or compile an invalid Wasm module will throw either a `TypeError` or one of the
    `Error` objects present on the `WebAssembly` object. We will cover these `Error`
    objects later in this section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就 `validate()` 方法而言，它的唯一目的是测试作为参数传入的类型数组或 `ArrayBuffer` 是否有效。这将在响应的原始字节被加载到
    `ArrayBuffer` 之后调用。由于尝试实例化或编译无效的 Wasm 模块将抛出 `TypeError` 或 `WebAssembly` 对象上存在的
    `Error` 对象之一，因此此方法未包含在代码示例中。我们将在本节稍后讨论这些 `Error` 对象。
- en: WebAssembly objects
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 对象
- en: 'In addition to the methods covered in the *Loading a module and the WebAssembly
    namespace methods* section, the global `WebAssembly` object has child objects
    that are used to interact with and troubleshoot WebAssembly. These objects correlate
    directly to the concepts we discussed in the sections on the WebAssembly binary
    and text formats. The following list contains these objects as well as their definitions
    taken from MDN:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 *加载模块和 WebAssembly 命名空间方法* 部分中介绍的方法之外，全局 `WebAssembly` 对象还有子对象，用于与 WebAssembly
    交互和故障排除。这些对象直接对应于我们在 WebAssembly 二进制和文本格式部分讨论的概念。以下列表包含这些对象以及从 MDN 夺取的定义：
- en: The `WebAssembly.Module` object contains stateless WebAssembly code that has
    already been compiled by the browser and can be efficiently shared with workers,
    cached in `IndexedDB`, and instantiated multiple times
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Module` 对象包含无状态的 WebAssembly 代码，这些代码已经被浏览器编译，并且可以高效地与工作线程共享，存储在
    `IndexedDB` 中，并且可以被实例化多次。'
- en: The `WebAssembly.Instance` object is a stateful, executable instance of a `WebAssembly.Module`
    which contains all of the exported WebAssembly functions that allow calling into
    WebAssembly code from JavaScript
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Instance` 对象是一个有状态的、可执行的 `WebAssembly.Module` 实例，它包含了所有导出的 WebAssembly
    函数，这些函数允许从 JavaScript 调用 WebAssembly 代码。'
- en: '`WebAssembly.Memory`, when called with the constructor, creates a new `Memory`
    object which is a resizable `ArrayBuffer` that holds the raw bytes of memory accessed
    by a WebAssembly `Instance`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用构造函数调用 `WebAssembly.Memory` 时，会创建一个新的 `Memory` 对象，它是一个可调整大小的 `ArrayBuffer`，用于存储
    WebAssembly `Instance` 访问的原始内存字节。
- en: '`WebAssembly.Table`, when called with the constructor, creates a new `Table`
    object of the given size and element type that represents a WebAssembly `Table`
    (which stores function references)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用构造函数调用 `WebAssembly.Table` 时，会创建一个新的 `Table` 对象，该对象具有给定的大小和元素类型，代表一个 WebAssembly
    `Table`（存储函数引用）。
- en: '`WebAssembly.CompileError`, when called with the constructor, creates an error
    which indicates that an issue occurred during WebAssembly decoding, or validation'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用构造函数调用 `WebAssembly.CompileError` 时，会创建一个错误，该错误指示在 WebAssembly 解码或验证过程中发生了问题。
- en: '`WebAssembly.LinkError`, when called with the constructor, creates an error
    which indicates that an issue occurred during module instantiation'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用构造函数调用 `WebAssembly.LinkError` 时，会创建一个错误，该错误指示在模块实例化过程中发生了问题。
- en: '`WebAssembly.RuntimeError`, when called with the constructor, creates an error
    which indicates that WebAssembly specified a trap (for example, stack overflow
    occurred)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用构造函数调用 `WebAssembly.RuntimeError` 时，会创建一个错误，该错误指示 WebAssembly 指定了一个陷阱（例如，发生了栈溢出）。
- en: Let's dig into each one individually, starting with the `WebAssembly.Module`
    object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一深入了解，从 `WebAssembly.Module` 对象开始。
- en: WebAssembly.Module
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Module
- en: The `WebAssembly.Module` object is the intermediate step between the `ArrayBuffer`
    and the instantiated module. The `compile()` and `instantiate()` methods (and
    their streaming counterparts) return a Promise that resolves with a module (module
    in lowercase represents the compiled `Module`). A module can also be created synchronously
    by passing a typed array or `ArrayBuffer` directly into the constructor, but this
    is discouraged for large modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Module` 对象位于 `ArrayBuffer` 和实例化模块之间的中间步骤。`compile()` 和 `instantiate()`
    方法（以及它们的流式处理对应方法）返回一个解析为模块的 Promise（小写的模块表示编译后的 `Module`）。模块也可以通过直接将类型数组或 `ArrayBuffer`
    传递给构造函数来同步创建，但对于大型模块来说，这不被推荐。'
- en: 'The `Module` object also has three static methods: `exports()`, `imports()`,
    and `customSections()`. All three take a module as a parameter, but `customSections()`
    takes a string representing the section name as its second parameter. Custom sections
    are described in the *Binary Format* section of the *Core Specification* and are
    intended to be used for debugging information or third-party extensions. In most
    cases, you won''t need to define these. The `exports()` function is useful if
    you''re using a Wasm module that you didn''t create, although you''ll only be
    able to see the name and kind (for example, `function`) of each export.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module` 对象也有三个静态方法：`exports()`、`imports()` 和 `customSections()`。这三个方法都接受一个模块作为参数，但
    `customSections()` 方法接受一个表示部分名称的字符串作为其第二个参数。自定义部分在 *核心规范* 的 *二进制格式* 部分中描述，旨在用于调试信息或第三方扩展。在大多数情况下，你不需要定义这些。如果你正在使用一个你未创建的
    Wasm 模块，`exports()` 函数非常有用，尽管你只能看到每个导出的名称和类型（例如，`function`）。'
- en: For simple use cases, you won't be dealing directly with the `Module` object
    or compiled module. Most of the interaction will take place with an `Instance`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的用例，你不会直接处理 `Module` 对象或编译后的模块。大部分交互将发生在 `Instance` 对象上。
- en: WebAssembly.Instance
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Instance
- en: The `WebAssembly.Instance` object is the instantiated WebAssembly module, which
    means you can call exported WebAssembly functions from it. Calling `instantiate()`
    or `instantiateStreaming()` returns a Promise that resolves with an object containing
    an instance. You call WebAssembly functions by referencing the name of the function
    on the instance's `export` property. For example, if a module contained an exported
    function named `sayHello()`, you'd call the function using `instance.exports.sayHello()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Instance` 对象是实例化的 WebAssembly 模块，这意味着你可以从中调用导出的 WebAssembly 函数。调用
    `instantiate()` 或 `instantiateStreaming()` 返回一个解析为包含实例的对象的 Promise。你通过引用实例的 `export`
    属性上的函数名称来调用 WebAssembly 函数。例如，如果一个模块包含一个名为 `sayHello()` 的导出函数，你会使用 `instance.exports.sayHello()`
    来调用该函数。'
- en: WebAssembly.Memory
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Memory
- en: The `WebAssembly.Memory` object holds the memory accessed by a WebAssembly `Instance`.
    This memory can be accessed and changed from both JavaScript and WebAssembly.
    To create a new instance of `Memory`, you need to pass an object with an `initial`
    and (optional) `maximum` value to the `WebAssembly.Memory()` constructor. These
    values are in units of WebAssembly pages, where one page is 64 KB. You increase
    the size of the memory instance by calling the `grow()` function with a single
    parameter that represents the number of WebAssembly pages to grow by. You can
    also access the current buffer contained in the memory instance through its `buffer`
    property.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Memory` 对象持有 WebAssembly `Instance` 访问的内存。此内存可以从 JavaScript 和
    WebAssembly 中访问和更改。要创建 `Memory` 的新实例，你需要将一个包含 `initial` 和（可选的）`maximum` 值的对象传递给
    `WebAssembly.Memory()` 构造函数。这些值以 WebAssembly 页为单位，其中一页是 64 KB。你可以通过调用 `grow()`
    函数并传递一个表示要增加的 WebAssembly 页数的单个参数来增加内存实例的大小。你还可以通过其 `buffer` 属性访问内存实例中包含的当前缓冲区。'
- en: MDN describes two ways to get to a `WebAssembly.Memory` object. The first way
    is to construct it from JavaScript (`var memory = new WebAssembly.Memory(...)`),
    while the second way is to have it exported by a WebAssembly module. The important
    takeaway is that memory can be passed easily between JavaScript and WebAssembly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MDN 描述了两种获取 `WebAssembly.Memory` 对象的方法。第一种方法是从 JavaScript 中构建它（`var memory =
    new WebAssembly.Memory(...)`），而第二种方法是由 WebAssembly 模块导出。重要的是要记住，内存可以在 JavaScript
    和 WebAssembly 之间轻松传递。
- en: WebAssembly.Table
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Table
- en: The `WebAssembly.Table` object is an array-like structure that is used to store
    function references. Just as with `WebAssembly.Memory`, a `Table` can be accessed
    and changed from both JavaScript and WebAssembly. As of the time of writing, tables
    can only store function references, but it's likely that, as the technology evolves,
    additional entities will be able to be stored in tables as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Table` 对象是一个类似数组的结构，用于存储函数引用。就像 `WebAssembly.Memory` 一样，`Table`
    可以从 JavaScript 和 WebAssembly 中访问和更改。截至编写本文时，表只能存储函数引用，但随着技术的演变，很可能会在表中存储其他实体。'
- en: To create a new `Table` instance, you need to pass an object with an `element`,
    `initial`, and (optional) `maximum` value. The `element` member is a string that
    represents the type of value stored in the table; currently the only valid value
    is `"anyfunc"` (for functions). The `initial` and `maximum` values represent the
    number of elements in the WebAssembly `Table`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 `Table` 实例，你需要传递一个包含 `element`、`initial` 和（可选的）`maximum` 值的对象。`element`
    成员是一个表示表中存储的值类型的字符串；目前唯一有效的值是 `"anyfunc"`（用于函数）。`initial` 和 `maximum` 值表示 WebAssembly
    `Table` 中的元素数量。
- en: You can access the number of elements in the `Table` instance using the `length`
    property. The instance also includes methods to manipulate and query elements
    in the table. The `get()` method allows you to access the element at the given
    index, which is passed in as a parameter. The `set()` method allows you to set
    an element at the index specified as the first parameter to the value specified
    as the second parameter (per the preceding note, only functions are supported).
    Finally, `grow()` allows you to increase the size of the `Table` instance (number
    of elements) by the number passed in as a parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `length` 属性访问 `Table` 实例中的元素数量。该实例还包括用于操作和查询表中元素的方法。`get()` 方法允许你访问作为参数传入的给定索引处的元素。`set()`
    方法允许你将第一个参数指定的索引处的元素设置为第二个参数指定的值（根据前面的说明，只支持函数）。最后，`grow()` 允许你通过传入作为参数的数字来增加
    `Table` 实例（元素数量）的大小。
- en: WebAssembly errors (CompileError, LinkError, RuntimeError)
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 错误（CompileError、LinkError、RuntimeError）
- en: The JavaScript API provides constructors to create instances of the `Error`
    objects specific to WebAssembly, but we won't spend too much time covering these
    objects. The object definition list at the beginning of this section describes
    the nature of each error, which may be raised if the specified condition is met.
    All three errors can be constructed with a message, filename, and line number
    parameter (all of which are optional), and has the same properties and methods
    as the standard JavaScript `Error` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript API 提供了创建特定于 WebAssembly 的 `Error` 对象实例的构造函数，但我们不会花太多时间介绍这些对象。本节开头对象定义列表描述了每个错误的性质，这些错误可能在满足指定条件时被引发。所有三个错误都可以使用消息、文件名和行号参数（所有这些都是可选的）来构建，并且具有与标准
    JavaScript `Error` 对象相同的属性和方法。
- en: Connecting the dots with WasmFiddle
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WasmFiddle 连接点
- en: We spent this chapter reviewing the various elements of WebAssembly and the
    corresponding JavaScript and Web APIs, but understanding how the pieces fit together
    can still be confusing. As we progress through the examples in this book and you're
    able to see how C/C++, WebAssembly, and JavaScript interact, these concepts will
    become clearer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章回顾了 WebAssembly 的各种元素以及相应的 JavaScript 和 Web API，但理解这些部分如何组合在一起仍然可能令人困惑。随着我们在这本书中的例子中前进，并且你能够看到
    C/C++、WebAssembly 和 JavaScript 之间的交互，这些概念将会变得更加清晰。
- en: That being said, a demonstration of this interaction may help in clearing up
    some of the confusion. In this section, we're going to use an online tool called
    WasmFiddle to demonstrate the relationship between these elements so you can see
    WebAssembly in action and get a high-level overview of the development workflow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这种交互的演示可能有助于消除一些困惑。在本节中，我们将使用一个名为 WasmFiddle 的在线工具来演示这些元素之间的关系，以便你可以看到
    WebAssembly 的实际应用，并获得开发工作流程的高级概述。
- en: What is WasmFiddle?
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 WasmFiddle？
- en: 'WasmFiddle, located at [https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/),
    is an online code editing tool that allows you to write some C or C++ code and
    convert it to Wat, compile it to Wasm, or interact with it directly using JavaScript.
    The C/C++ and JavaScript editors are minimal and aren''t intended to be used as
    your primary development environment, but it offers a valuable service in the
    Wasm compiler. In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up A Development Environment*, you''ll discover that going from square one to
    generating Wasm files requires a little bit of work—being able to paste your C
    code into the browser and hitting a couple of buttons makes things much more convenient.
    The following diagram gives a quick overview of the interface:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: WasmFiddle 位于 [https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/)，是一个在线代码编辑工具，允许你编写一些
    C 或 C++ 代码，并将其转换为 Wat，编译为 Wasm，或直接使用 JavaScript 与其交互。C/C++ 和 JavaScript 编辑器非常简单，并不打算用作你的主要开发环境，但它为
    Wasm 编译器提供了有价值的服务。在 [第 3 章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)，*设置开发环境*，你会发现从零开始生成
    Wasm 文件需要一点工作——能够将你的 C 代码粘贴到浏览器中并点击几个按钮会使事情变得更加方便。以下图表提供了界面的快速概述：
- en: '![](img/a30bacbd-3e98-45bf-a2af-c4c7b35c24ea.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a30bacbd-3e98-45bf-a2af-c4c7b35c24ea.png)'
- en: Components of the WasmFiddle user interface
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WasmFiddle 用户界面的组件
- en: As you can see, the interface is relatively simple. Let's try out some code!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，界面相对简单。让我们尝试一些代码！
- en: C code to Wat
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 代码转换为 Wat
- en: 'The upper-left pane in the following screenshot contains a simple C function
    that adds 2 to the number specified as a parameter. The lower-left pane contains
    the corresponding Wat:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图的左上角面板中包含了一个简单的 C 函数，该函数将参数指定的数字加 2。左下角面板包含相应的 Wat：
- en: '![](img/14cdb18b-d295-4891-a9a6-a4ab72246a22.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14cdb18b-d295-4891-a9a6-a4ab72246a22.png)'
- en: C function and the corresponding Wat
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C 函数和相应的 Wat
- en: If this looks familiar, it's because this same code was used for the explanation
    of Wat's s-expressions in the beginning of this chapter. Digging a little deeper,
    you can see how the C code corresponds to the Wat output. The `addTwo()` function
    is exported from the module as a string on line `5`. Line `5` also contains `(func
    $addTwo)`, which references the `$addTwo` function on line `6`. Line `6` specifies
    that a single parameter of type `i32` (an integer) can be passed in and the result
    returned is also an `i32`. Pressing the Build button in the upper-right corner
    (or above the C/C++ editor) will compile the C code into a Wasm file. The Wasm
    will be available for download or interaction with JavaScript once the build is
    completed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很熟悉，那是因为这段相同的代码在本书开头解释 Wat 的 s-expressions 时已经使用过了。深入挖掘，你可以看到 C 代码是如何对应
    Wat 输出的。`addTwo()` 函数作为字符串在行 `5` 中导出模块。行 `5` 也包含 `(func $addTwo)`，它引用了行 `6` 中的
    `$addTwo` 函数。行 `6` 指定可以传递一个类型为 `i32`（整数）的单个参数，返回的结果也是 `i32`。在右上角（或 C/C++ 编辑器上方）按下构建按钮（或构建按钮）将编译
    C 代码为 Wasm 文件。构建完成后，Wasm 将可用于下载或与 JavaScript 交互。
- en: Wasm to JavaScript
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wasm 转换为 JavaScript
- en: 'The upper-right pane in the following screenshot contains some JavaScript code
    to compile the Wasm that was generated in the previous step. The `wasmCode` was
    generated when the build finished, so it should be available automatically. Rather
    than use the `instantiate()` method, WasmFiddle creates a compiled `WebAssembly.Module`
    instance and passes that into the constructor of a new `WebAssembly.Instance`.
    The `wasmImports` object is currently empty, although we could pass in a `WebAssembly.Memory`
    and `WebAssembly.Table` instance if desired:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图的右上角面板中包含了一些用于编译上一步骤生成的 Wasm 的 JavaScript 代码。`wasmCode` 在构建完成后生成，因此应该可以自动获取。而不是使用
    `instantiate()` 方法，WasmFiddle 创建了一个编译后的 `WebAssembly.Module` 实例，并将其传递给新的 `WebAssembly.Instance`
    构造函数。`wasmImports` 对象目前为空，尽管如果我们想的话，可以传递一个 `WebAssembly.Memory` 和 `WebAssembly.Table`
    实例：
- en: '![](img/82dade82-c419-4ccb-85d2-89f58e525bcb.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82dade82-c419-4ccb-85d2-89f58e525bcb.png)'
- en: JavaScript code calling the C function from the compiled Wasm module
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 调用编译后的 Wasm 模块中 C 函数的 JavaScript 代码
- en: The final line of JavaScript prints the result of `addTwo()` to the output in
    the lower-right pane when passed the number `2`. The `log()` method is a custom
    function that ensures the output is printed to the lower-right pane (the number
    `4`). Note how the JavaScript code interacts with `wasmInstance`. The `addTwo()`
    function is called from the instance's `exports` object. Although this was a contrived
    example, it demonstrates the steps C or C++ code goes through before it can be
    used by JavaScript as a Wasm module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的最后一行将 `addTwo()` 函数的结果打印到右下角的输出面板中，当传入数字 `2` 时。`log()` 方法是一个自定义函数，确保输出被打印到右下角面板（数字
    `4`）。注意 JavaScript 代码如何与 `wasmInstance` 交互。`addTwo()` 函数是从实例的 `exports` 对象中调用的。尽管这是一个虚构的例子，但它演示了
    C 或 C++ 代码在可以作为 Wasm 模块被 JavaScript 使用之前需要经历的步骤。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the elements of WebAssembly and their relationship.
    The structure of the *Core Specification* was used to describe the mapping of
    the text and binary formats to a common abstract syntax. We highlighted aspects
    of the text format (Wat) that can be useful in the context of debugging and development,
    as well as why s-expressions are an excellent fit for the textual representation
    of the abstract syntax. We also reviewed details pertaining to the binary format
    and the various elements that make up a module. The methods and objects within
    the JavaScript and Web APIs were defined with descriptions of their roles with
    regard to WebAssembly interaction. Finally, a simple example of the relationship
    between source code, Wat, and JavaScript was presented using the WasmFiddle tool.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 WebAssembly 的元素及其关系。使用 *核心规范* 的结构来描述文本和二进制格式映射到公共抽象语法。我们强调了文本格式（Wat）在调试和开发环境中的有用方面，以及为什么
    s-表达式非常适合抽象语法的文本表示。我们还回顾了与二进制格式相关的细节以及构成模块的各种元素。JavaScript 和 Web API 中的方法和对象被定义为描述它们与
    WebAssembly 交互的角色。最后，使用 WasmFiddle 工具展示了源代码、Wat 和 JavaScript 之间关系的一个简单示例。
- en: In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting Up a Development
    Environment*, we'll install the development tooling we'll use to work effectively
    with WebAssembly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)，*设置开发环境*，我们将安装我们将用于有效工作与
    WebAssembly 一起使用的开发工具。
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What kind of data are s-expressions good at representing?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: s-表达式擅长表示哪种类型的数据？
- en: What are the four language concepts that are shared between the binary and text
    formats?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制和文本格式之间共享的四个语言概念是什么？
- en: What is one of the use cases for the text format?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本格式的一个用例是什么？
- en: What is the only element type that can be stored in a WebAssembly `Table`?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以存储在 WebAssembly `Table` 中的唯一元素类型是什么？
- en: What does the JavaScript engine use to manage execution?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 引擎使用什么来管理执行？
- en: Which method requires less code to instantiate a module, `instantiate()` or
    `instantiateStreaming()`?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化模块时哪种方法需要更少的代码，`instantiate()` 还是 `instantiateStreaming()`？
- en: What error objects are available on the `WebAssembly` JavaScript object and
    what event causes each one?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WebAssembly` JavaScript 对象上可用的错误对象有哪些？以及什么事件导致每个错误？
- en: Further reading
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: WebAssembly on MDN: [https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 在 MDN：[https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
- en: 'WasmFiddle: [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'WasmFiddle: [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle)'
- en: 'S-expressions on Wikipedia: [https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia 上的 s-表达式：[https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression)
- en: 'Examples of Trees: [http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html](http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的示例：[http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html](http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html)
