- en: Elements of WebAssembly - Wat, Wasm, and the JavaScript API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    described the history of WebAssembly and provided a high-level overview of the
    technology as well as the potential use cases and limitations. WebAssembly was
    described as being composed of multiple elements, not just the binary instruction
    format specified in the official definition.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dig into the elements that correspond to the official
    specifications created by the WebAssembly Working Group. We will examine the Wat
    and the binary format in greater detail to gain a better understanding of how
    they relate to modules. We will review the *JavaScript API* and *Web API* to ensure
    you're able to utilize the WebAssembly effectively in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal for this chapter is to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How the text and binary formats are related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Wat is and where it fits in to the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary format and module (Wasm) file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The components of the JavaScript and Web API and how they relate to the Wasm
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize WasmFiddle to evaluate the phases of WebAssembly (C/C++ > Wat
    > Wasm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common structure and abstract syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    we talked about how the binary and text formats of WebAssembly both map to a common
    structure in the form of an abstract syntax. Before getting into the nuts and
    bolts of these formats, it''s worth mentioning how these are related within the
    *Core Specification*. The following diagram is a visual representation of the
    table of contents (with some sections excluded for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24a8a8a0-7afd-4ffe-892c-bb162b09b784.png)*Core Specification* table
    of contents'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **Text Format** and **Binary Format** sections contain subsections
    for **Values**, **Types**, **Instructions**, and **Modules** that correlate with
    the **Structure** section. Consequently, much of what we cover in the next section
    for the text format have direct corollaries with the binary format. With that
    in mind, let's dive into the text format.
  prefs: []
  type: TYPE_NORMAL
- en: Wat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Text Format* section of the *Core Specification* provides technical descriptions
    for common language concepts such as values, types, and instructions. These are
    important concepts to know and understand if you're planning on building tooling
    for WebAssembly, but not necessary if you just plan on using it in your applications.
    That being said, the text format is an important part of WebAssembly, so there
    are concepts you should be aware of. In this section, we will dig into some of
    the details of the text format and highlight important points from the *Core Specification*.
  prefs: []
  type: TYPE_NORMAL
- en: Definitions and S-expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand Wat, let''s start with the first sentence of the description
    taken directly from the WebAssembly *Core Specification*:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The textual format for WebAssembly modules is a rendering of their abstract
    syntax into S-expressions."'
  prefs: []
  type: TYPE_NORMAL
- en: So what are **symbolic expressions** (**S-expressions**)? S-expressions are
    notations for nested list (tree-structured) data. Essentially, they provide a
    simple and elegant way to represent list-based data in textual form. To understand
    how textual representations of nested lists map to a tree structure, let's extrapolate
    the tree structure from an HTML page. The following example contains a simple
    HTML page and the corresponding tree structure diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding tree structure is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbdfac80-c6f7-45cb-beb9-5ebdc2ed8ffe.png)'
  prefs: []
  type: TYPE_IMG
- en: A tree structure diagram for an HTML page
  prefs: []
  type: TYPE_NORMAL
- en: Even if you've never seen a tree structure before, it's still clear to see how
    the HTML maps to the tree in terms of structure and hierarchy. Mapping HTML elements
    is relatively simple because it's a markup language with well-defined tags and
    no actual logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wat represents modules that can have multiple functions with varying parameters.
    To demonstrate the relationship between source code, Wat, and the corresponding
    tree structure, let''s start with a simple C function that adds 2 to the number
    that is passed in as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a C function that adds `2` to the `num` argument passed in and returns
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting the `addTwo` function to valid Wat produces this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    we talked about language concepts associated with the *Core Specification* (*Functions*,
    *Linear Memory*, *Tables*, and so on). Within that specification, the *Structure*
    section defines each of these concepts in the context of an abstract syntax. The
    *Text Format* section of the specification corresponds with these concepts as
    well, and you can see them defined by their keywords in the preceding snippet
    (`func`, `memory`, `table`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Tree Structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28fa4fdc-1b9e-4672-b752-8bb1a272e9e0.png)'
  prefs: []
  type: TYPE_IMG
- en: A tree structure diagram for Wat
  prefs: []
  type: TYPE_NORMAL
- en: The entire tree would be too large to fit on a page, so this diagram is limited
    to the first five lines of the Wat source text. Each filled-in dot represents
    a list node (or the contents of a set of parentheses). As you can see, code written
    in s-expressions can be clearly and concisely expressed in a tree structure, which
    is why s-expressions were chosen for WebAssembly's text format.
  prefs: []
  type: TYPE_NORMAL
- en: Values, types, and instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although detailed coverage of the *Text Format* section of the *Core Specification*
    is out of the scope of this text, it''s worth demonstrating how some of the language
    concepts map to the corresponding Wat. The following diagram demonstrates these
    mappings in a sample Wat snippet. The C code that this was compiled from represents
    a function that takes a word as a parameter and returns the square root of the
    character count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c3b4124-7f45-49c6-a933-de3bf3861864.png)'
  prefs: []
  type: TYPE_IMG
- en: Wat example with language concept details
  prefs: []
  type: TYPE_NORMAL
- en: If you intend on writing or editing Wat, note that it supports block and line
    comments. The instructions are split up into blocks and consist of setting and
    getting memory associated with variables with valid types. You are able to control
    the flow of logic using `if` statements and loops are supported using the `loop`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Role in the development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The text format allows for the representation of a binary Wasm module in textual
    form. This has some profound implications with regard to the ease of development
    and debugging. Having a textual representation of a WebAssembly module allows
    developers to view the source of a loaded module in a browser, which eliminates
    the black-box issues that inhibited the adoption of NaCl. It also allows for tooling
    to be built around troubleshooting modules. The official website describes the
    use cases that drove the design of the text format:'
  prefs: []
  type: TYPE_NORMAL
- en: • View Source on a WebAssembly module, thus fitting into the Web (where every
    source can be viewed) in a natural way.
  prefs: []
  type: TYPE_NORMAL
- en: • Presentation in browser development tools when source maps aren't present
    (which is necessarily the case with the Minimum Viable Product (MVP)).
  prefs: []
  type: TYPE_NORMAL
- en: • Writing WebAssembly code directly for reasons including pedagogical, experimental,
    debugging, optimization, and testing of the spec itself.
  prefs: []
  type: TYPE_NORMAL
- en: The last item in the list reflects that the text format isn't intended to be
    written by hand in the course of normal development, but rather generated from
    a tool like Emscripten. You probably won't see or manipulate any `.wat` files
    when you're generating modules, but you may be viewing them in a debugging context.
  prefs: []
  type: TYPE_NORMAL
- en: Not only is the text format valuable with regards to debugging, but having this
    intermediate format reduces the amount of reliance on a single tool for compilation.
    Several different tools currently exist to consume and emit this s-expression
    syntax, some of which are used by Emscripten to compile your code down to a `.wasm`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Binary format and the module file (Wasm)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Binary Format* section of the *Core Specification* provides the same level
    of detail with regard to language concepts as the *Text format* section. In this
    section, we will briefly cover some high-level details about the binary format
    and discuss the various sections that make up a Wasm module.
  prefs: []
  type: TYPE_NORMAL
- en: Definition and module overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binary format is defined as a dense linear encoding of the abstract syntax.
    Without getting too technical, that essentially means it's an efficient form of
    binary that allows for fast decoding, small file size, and reduced memory usage.
    The file representation of the binary format is a `.wasm` file, which will be
    the compilation output from Emscripten that we'll use for our examples.
  prefs: []
  type: TYPE_NORMAL
- en: The *Values*, *Types*, and *Instructions* subsections of the *Core Specification*
    for the binary format correlate directly to the *Text Format* section. Each of
    these concepts is covered in the context of encoding. For example, according to
    the specification, the Integer types are encoded using the LEB128 variable-length
    integer encoding, in either unsigned or signed variant. These are important details
    to know if you wish to develop tooling for WebAssembly, but not necessary if you
    just plan on using it on your website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Structure*, *Binary Format*, and *Text Format* *(wat)* sections of the
    *Core Specification* have a *Module* subsection. We didn''t cover aspects of the
    module in the previous section because it''s more prudent to describe them in
    the context of a binary. The official WebAssembly site offers the following description
    for a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The distributable, loadable, and executable unit of code in WebAssembly is
    called a **module**. At runtime, a module can be **instantiated** with a set of
    import values to produce an **instance**, which is an immutable tuple referencing
    all the state accessible to the running module."'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how to interact with the module using the JavaScript and Web
    APIs later in this chapter, so let's establish some context to understand how
    the module elements map to the API methods.
  prefs: []
  type: TYPE_NORMAL
- en: Module sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module is made up of several sections, some of which you''ll be interacting
    with through the JavaScript API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imports (`import`) are elements that can be accessed within the module and
    can be one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function, which can be called inside the module using the `call` operator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Global, which can be accessed inside the module via the `global` operators
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear Memory, which can be accessed inside the module via the `memory` operators
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Table, which can be accessed inside the module using `call_indirect`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exports (`export`) are elements that can be accessed by the consuming API (that
    is, called by a JavaScript function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module start function (`start`) is called after the module instance is initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global (`global`) contains the internal definition of global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear memory (`memory`) contains the internal definition of linear memory with
    an initial memory size and optional maximum size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data (`data`) contains an array of data segments which specify the initial contents
    of fixed ranges of a given memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table (`table`) is a linear memory whose elements are opaque values of a particular
    table element type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the MVP, its primary purpose is to implement indirect function calls in C/C++
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements (`elements`) is a section that allows a module to initialize the elements
    of any import or internally defined table with any other definition in the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function and code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function section declares the signatures of each internal function defined
    in the module
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The code section contains the function body of each function declared by the
    function section
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the keywords (`import`, `export`, and so on) should look familiar; they're
    present in the contents of the Wat file in the previous section. WebAssembly's
    components follow a logical mapping that directly correspond to the APIs  (for
    example, you pass a `memory` and `table` instance into JavaScript's `WebAssembly.instantiate()`
    function). Your primary interaction with a module in binary format will be through
    these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript and Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the *WebAssembly Core Specification*, there are two API specifications
    for interacting with WebAssembly modules: the *WebAssembly JavaScript Interface* (JavaScript
    API) and the *WebAssembly Web API*. In the previous sections, we covered pertinent
    aspects of the *Core Specification* to become familiar with the underlying technology.
    If you never read the *Core Specification* (or if you skipped the first few sections
    of this chapter), it wouldn''t inhibit the use of WebAssembly in your application.
    That is not the case for the APIs, as they describe the methods and interface
    required to instantiate and interact with your compiled Wasm module. In this section,
    we will review the Web and JavaScript APIs and describe how to load and communicate
    with a Wasm module using JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly store and object caches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before digging into interactions, let''s discuss the relationship between JavaScript
    and WebAssembly in the context of execution. The *Core Specification* contains
    the following description in the *Execution* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '"WebAssembly code is executed when instantiating a module or invoking an exported
    function on the resulting module instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Execution behavior is defined in terms of an abstract machine that models the
    program state. It includes a stack, which records operand values and control constructs,
    and an abstract store containing global state."
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, JavaScript uses something called **agents** to manage execution.
    The *store* being referred to in the definition is contained within an agent.
    The following diagram represents a JavaScript agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d01b7a99-69fe-4b97-b7f2-b4fed202aff1.png)'
  prefs: []
  type: TYPE_IMG
- en: JavaScript agent elements
  prefs: []
  type: TYPE_NORMAL
- en: The store represents the state of the abstract machine. WebAssembly operations
    take a store and return an updated store. Each agent is associated with caches
    that map JavaScript objects to WebAssembly addresses. So why is this important?
    It represents the underlying method of interaction between WebAssembly modules
    and JavaScript. The JavaScript objects correspond to the WebAssembly namespace
    within the *JavaScript API*. With that in mind, let's dig into the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a module and the WebAssembly namespace methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *JavaScript API* covers the various objects available on the global `WebAssembly`
    object in the browser. Before we discuss those, we''ll start with the methods
    available on the `WebAssembly` object, with a brief overview of their intended
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`instantiate()` is the primary API for compiling and instantiating WebAssembly
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instantiateStreaming()` performs the same functionality as `instantiate()`,
    but it uses streaming to compile and instantiate the module, which eliminates
    an intermediate step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compile()` only compiles a WebAssembly module, but doesn''t instantiate it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compileStreaming()` also only compiles a WebAssembly module, but it uses streaming
    similar to `instantiateStreaming()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate()` checks the WebAssembly binary code to ensure the bytes are valid
    and returns true if valid or false if not valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `instantiateStreaming()` and `compileStreaming()` methods are currently
    only present in the *Web API*. In fact, these two methods comprise the entire
    specification. The methods available on the `WebAssembly` object are focused primarily
    on compiling and instantiating modules. With that in mind, let's discuss how to
    fetch and instantiate a Wasm module.
  prefs: []
  type: TYPE_NORMAL
- en: When you perform a fetch call to get a module, it returns a Promise that resolves
    with the raw bytes of that module, which need to be loaded into an `ArrayBuffer`
    and instantiated. Going forward, we will refer to this process as loading a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/368f1c3b-c24a-4265-967f-6347f5fa8b34.png)'
  prefs: []
  type: TYPE_IMG
- en: Fetching and loading a WebAssembly module
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is actually quite simple using Promises. The following code demonstrates
    how a module is loaded. The `importObj` argument passes any data or functions
    to the Wasm module. You can disregard it for now, as we''ll be discussing it in
    greater detail in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example dictates the method for loading the module using the
    `instantiate()` method. The `instantiateStreaming()` method is a little different
    and simplifies the process even more by fetching, compiling, and instantiating
    a module in a single step. The following code achieves the same goal (loading
    a module) using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The instantiation methods return a Promise that resolves with an object containing
    a compiled `WebAssembly.Module` (`module`) and `WebAssembly.Instance` (`instance`),
    both of which will be covered later in this section. In most cases, you will use
    one of these methods to load a Wasm module on your site. The instance contains
    all of the exported WebAssembly functions that you can call from your JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The `compile()` and `compileStreaming()` methods return a Promise that only
    resolves with a compiled `WebAssembly.Module`. This is useful if you want to compile
    a module and instantiate it at a later time. **Mozilla Developer Network** (**MDN**),
    the web docs site managed by Mozilla, provides an example in which the compiled
    module is passed to a Web Worker.
  prefs: []
  type: TYPE_NORMAL
- en: As far as the `validate()` method is concerned, its only purpose is to test
    whether the typed array or `ArrayBuffer` passed in as a parameter is valid. This
    would be called after the raw bytes of the response are loaded into an `ArrayBuffer`.
    This method wasn't included in the code examples because attempting to instantiate
    or compile an invalid Wasm module will throw either a `TypeError` or one of the
    `Error` objects present on the `WebAssembly` object. We will cover these `Error`
    objects later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the methods covered in the *Loading a module and the WebAssembly
    namespace methods* section, the global `WebAssembly` object has child objects
    that are used to interact with and troubleshoot WebAssembly. These objects correlate
    directly to the concepts we discussed in the sections on the WebAssembly binary
    and text formats. The following list contains these objects as well as their definitions
    taken from MDN:'
  prefs: []
  type: TYPE_NORMAL
- en: The `WebAssembly.Module` object contains stateless WebAssembly code that has
    already been compiled by the browser and can be efficiently shared with workers,
    cached in `IndexedDB`, and instantiated multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `WebAssembly.Instance` object is a stateful, executable instance of a `WebAssembly.Module`
    which contains all of the exported WebAssembly functions that allow calling into
    WebAssembly code from JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebAssembly.Memory`, when called with the constructor, creates a new `Memory`
    object which is a resizable `ArrayBuffer` that holds the raw bytes of memory accessed
    by a WebAssembly `Instance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebAssembly.Table`, when called with the constructor, creates a new `Table`
    object of the given size and element type that represents a WebAssembly `Table`
    (which stores function references)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebAssembly.CompileError`, when called with the constructor, creates an error
    which indicates that an issue occurred during WebAssembly decoding, or validation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebAssembly.LinkError`, when called with the constructor, creates an error
    which indicates that an issue occurred during module instantiation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebAssembly.RuntimeError`, when called with the constructor, creates an error
    which indicates that WebAssembly specified a trap (for example, stack overflow
    occurred)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dig into each one individually, starting with the `WebAssembly.Module`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly.Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WebAssembly.Module` object is the intermediate step between the `ArrayBuffer`
    and the instantiated module. The `compile()` and `instantiate()` methods (and
    their streaming counterparts) return a Promise that resolves with a module (module
    in lowercase represents the compiled `Module`). A module can also be created synchronously
    by passing a typed array or `ArrayBuffer` directly into the constructor, but this
    is discouraged for large modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Module` object also has three static methods: `exports()`, `imports()`,
    and `customSections()`. All three take a module as a parameter, but `customSections()`
    takes a string representing the section name as its second parameter. Custom sections
    are described in the *Binary Format* section of the *Core Specification* and are
    intended to be used for debugging information or third-party extensions. In most
    cases, you won''t need to define these. The `exports()` function is useful if
    you''re using a Wasm module that you didn''t create, although you''ll only be
    able to see the name and kind (for example, `function`) of each export.'
  prefs: []
  type: TYPE_NORMAL
- en: For simple use cases, you won't be dealing directly with the `Module` object
    or compiled module. Most of the interaction will take place with an `Instance`.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly.Instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WebAssembly.Instance` object is the instantiated WebAssembly module, which
    means you can call exported WebAssembly functions from it. Calling `instantiate()`
    or `instantiateStreaming()` returns a Promise that resolves with an object containing
    an instance. You call WebAssembly functions by referencing the name of the function
    on the instance's `export` property. For example, if a module contained an exported
    function named `sayHello()`, you'd call the function using `instance.exports.sayHello()`.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly.Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WebAssembly.Memory` object holds the memory accessed by a WebAssembly `Instance`.
    This memory can be accessed and changed from both JavaScript and WebAssembly.
    To create a new instance of `Memory`, you need to pass an object with an `initial`
    and (optional) `maximum` value to the `WebAssembly.Memory()` constructor. These
    values are in units of WebAssembly pages, where one page is 64 KB. You increase
    the size of the memory instance by calling the `grow()` function with a single
    parameter that represents the number of WebAssembly pages to grow by. You can
    also access the current buffer contained in the memory instance through its `buffer`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: MDN describes two ways to get to a `WebAssembly.Memory` object. The first way
    is to construct it from JavaScript (`var memory = new WebAssembly.Memory(...)`),
    while the second way is to have it exported by a WebAssembly module. The important
    takeaway is that memory can be passed easily between JavaScript and WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly.Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WebAssembly.Table` object is an array-like structure that is used to store
    function references. Just as with `WebAssembly.Memory`, a `Table` can be accessed
    and changed from both JavaScript and WebAssembly. As of the time of writing, tables
    can only store function references, but it's likely that, as the technology evolves,
    additional entities will be able to be stored in tables as well.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new `Table` instance, you need to pass an object with an `element`,
    `initial`, and (optional) `maximum` value. The `element` member is a string that
    represents the type of value stored in the table; currently the only valid value
    is `"anyfunc"` (for functions). The `initial` and `maximum` values represent the
    number of elements in the WebAssembly `Table`.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the number of elements in the `Table` instance using the `length`
    property. The instance also includes methods to manipulate and query elements
    in the table. The `get()` method allows you to access the element at the given
    index, which is passed in as a parameter. The `set()` method allows you to set
    an element at the index specified as the first parameter to the value specified
    as the second parameter (per the preceding note, only functions are supported).
    Finally, `grow()` allows you to increase the size of the `Table` instance (number
    of elements) by the number passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly errors (CompileError, LinkError, RuntimeError)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript API provides constructors to create instances of the `Error`
    objects specific to WebAssembly, but we won't spend too much time covering these
    objects. The object definition list at the beginning of this section describes
    the nature of each error, which may be raised if the specified condition is met.
    All three errors can be constructed with a message, filename, and line number
    parameter (all of which are optional), and has the same properties and methods
    as the standard JavaScript `Error` object.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the dots with WasmFiddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spent this chapter reviewing the various elements of WebAssembly and the
    corresponding JavaScript and Web APIs, but understanding how the pieces fit together
    can still be confusing. As we progress through the examples in this book and you're
    able to see how C/C++, WebAssembly, and JavaScript interact, these concepts will
    become clearer.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, a demonstration of this interaction may help in clearing up
    some of the confusion. In this section, we're going to use an online tool called
    WasmFiddle to demonstrate the relationship between these elements so you can see
    WebAssembly in action and get a high-level overview of the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: What is WasmFiddle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WasmFiddle, located at [https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/),
    is an online code editing tool that allows you to write some C or C++ code and
    convert it to Wat, compile it to Wasm, or interact with it directly using JavaScript.
    The C/C++ and JavaScript editors are minimal and aren''t intended to be used as
    your primary development environment, but it offers a valuable service in the
    Wasm compiler. In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up A Development Environment*, you''ll discover that going from square one to
    generating Wasm files requires a little bit of work—being able to paste your C
    code into the browser and hitting a couple of buttons makes things much more convenient.
    The following diagram gives a quick overview of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a30bacbd-3e98-45bf-a2af-c4c7b35c24ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Components of the WasmFiddle user interface
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the interface is relatively simple. Let's try out some code!
  prefs: []
  type: TYPE_NORMAL
- en: C code to Wat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The upper-left pane in the following screenshot contains a simple C function
    that adds 2 to the number specified as a parameter. The lower-left pane contains
    the corresponding Wat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14cdb18b-d295-4891-a9a6-a4ab72246a22.png)'
  prefs: []
  type: TYPE_IMG
- en: C function and the corresponding Wat
  prefs: []
  type: TYPE_NORMAL
- en: If this looks familiar, it's because this same code was used for the explanation
    of Wat's s-expressions in the beginning of this chapter. Digging a little deeper,
    you can see how the C code corresponds to the Wat output. The `addTwo()` function
    is exported from the module as a string on line `5`. Line `5` also contains `(func
    $addTwo)`, which references the `$addTwo` function on line `6`. Line `6` specifies
    that a single parameter of type `i32` (an integer) can be passed in and the result
    returned is also an `i32`. Pressing the Build button in the upper-right corner
    (or above the C/C++ editor) will compile the C code into a Wasm file. The Wasm
    will be available for download or interaction with JavaScript once the build is
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: Wasm to JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The upper-right pane in the following screenshot contains some JavaScript code
    to compile the Wasm that was generated in the previous step. The `wasmCode` was
    generated when the build finished, so it should be available automatically. Rather
    than use the `instantiate()` method, WasmFiddle creates a compiled `WebAssembly.Module`
    instance and passes that into the constructor of a new `WebAssembly.Instance`.
    The `wasmImports` object is currently empty, although we could pass in a `WebAssembly.Memory`
    and `WebAssembly.Table` instance if desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82dade82-c419-4ccb-85d2-89f58e525bcb.png)'
  prefs: []
  type: TYPE_IMG
- en: JavaScript code calling the C function from the compiled Wasm module
  prefs: []
  type: TYPE_NORMAL
- en: The final line of JavaScript prints the result of `addTwo()` to the output in
    the lower-right pane when passed the number `2`. The `log()` method is a custom
    function that ensures the output is printed to the lower-right pane (the number
    `4`). Note how the JavaScript code interacts with `wasmInstance`. The `addTwo()`
    function is called from the instance's `exports` object. Although this was a contrived
    example, it demonstrates the steps C or C++ code goes through before it can be
    used by JavaScript as a Wasm module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the elements of WebAssembly and their relationship.
    The structure of the *Core Specification* was used to describe the mapping of
    the text and binary formats to a common abstract syntax. We highlighted aspects
    of the text format (Wat) that can be useful in the context of debugging and development,
    as well as why s-expressions are an excellent fit for the textual representation
    of the abstract syntax. We also reviewed details pertaining to the binary format
    and the various elements that make up a module. The methods and objects within
    the JavaScript and Web APIs were defined with descriptions of their roles with
    regard to WebAssembly interaction. Finally, a simple example of the relationship
    between source code, Wat, and JavaScript was presented using the WasmFiddle tool.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting Up a Development
    Environment*, we'll install the development tooling we'll use to work effectively
    with WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What kind of data are s-expressions good at representing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four language concepts that are shared between the binary and text
    formats?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one of the use cases for the text format?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the only element type that can be stored in a WebAssembly `Table`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the JavaScript engine use to manage execution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method requires less code to instantiate a module, `instantiate()` or
    `instantiateStreaming()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What error objects are available on the `WebAssembly` JavaScript object and
    what event causes each one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly on MDN: [https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WasmFiddle: [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S-expressions on Wikipedia: [https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of Trees: [http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html](http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
