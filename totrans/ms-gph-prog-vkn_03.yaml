- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Unlocking Multi-Threading
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解锁多线程
- en: In this chapter, we will talk about adding multi-threading to the Raptor Engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何将多线程添加到Raptor引擎中。
- en: This requires both a big change in the underlying architecture and some Vulkan-specific
    changes and synchronization work so that the different cores of the CPU and the
    GPU can cooperate in the most correct and the fastest way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要底层架构的巨大变化以及一些Vulkan特定的更改和同步工作，以便CPU和GPU的不同核心能够以最正确和最快的方式合作。
- en: '**Multi-threading** rendering is a topic covered many times over the years
    and a feature that most game engines have needed since the era of multi-core architectures
    exploded. Consoles such as the PlayStation 2 and the Sega Saturn already offered
    multi-threading support, and later generations continued the trend by providing
    an increasing number of cores that developers could take advantage of.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程**渲染是一个多年来多次讨论的话题，也是自从多核架构时代爆发以来大多数游戏引擎都需要的功能。PlayStation 2和Sega Saturn等游戏机已经提供了多线程支持，而后续的世代继续这一趋势，通过提供越来越多的核心供开发者利用。'
- en: The first trace of multi-threading rendering in a game engine is as far back
    as 2008 when Christer Ericson wrote a blog post ([https://realtimecollisiondetection.net/blog/?p=86](https://realtimecollisiondetection.net/blog/?p=86))
    and showed that it was possible to parallelize and optimize the generation of
    commands used to render objects on the screen.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎中多线程渲染的首次痕迹可以追溯到2008年，当时克里斯蒂尔·埃里克森撰写了一篇博客文章([https://realtimecollisiondetection.net/blog/?p=86](https://realtimecollisiondetection.net/blog/?p=86))，并展示了并行化和优化用于在屏幕上渲染对象的命令生成的可能性。
- en: Older APIs such as OpenGL and DirectX (up until version 11) did not have proper
    multi-threading support, especially because they were big state machines with
    a global context tracking down each change after each command. Still, the command
    generation across different objects could take a few milliseconds, so multi-threading
    was already a big save in performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的API，如OpenGL和DirectX（直到版本11），没有适当的并行多线程支持，尤其是因为它们是大型状态机，具有全局上下文，跟踪每个命令后的每个更改。尽管如此，不同对象之间的命令生成可能需要几毫秒，因此多线程在性能上已经是一个很大的提升。
- en: Luckily for us, Vulkan fully supports multi-threading command buffers natively,
    especially with the creation of the `VkCommandBuffer` class, from an architectural
    perspective of the Vulkan API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vulkan原生支持多线程命令缓冲区，尤其是在`VkCommandBuffer`类的创建后，从Vulkan API的架构角度来看。
- en: The Raptor Engine, up until now, was a single-threaded application and thus
    required some architectural changes to fully support multi-threading. In this
    chapter, we will see those changes, learn how to use a task-based multi-threading
    library called enkiTS, and then unlock both asynchronous resource loading and
    multi-threading command recording.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一直到如今，Raptor引擎都是一个单线程应用程序，因此需要一些架构上的更改以完全支持多线程。在本章中，我们将看到这些更改，学习如何使用名为enkiTS的基于任务的并行多线程库，然后解锁异步资源加载和多线程命令记录。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to use a task-based multi-threading library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基于任务的并行多线程库
- en: How to asynchronously load resources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何异步加载资源
- en: How to draw in parallel threads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在并行线程中绘图
- en: By the end of the chapter, we will know how to run concurrent tasks both for
    loading resources and drawing objects on the screen. By learning how to reason
    with a task-based multi-threading system, we will be able to perform other parallel
    tasks in future chapters as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将知道如何同时运行加载资源和在屏幕上绘制对象的并发任务。通过学习如何与基于任务的并行多线程系统进行推理，我们将在未来的章节中也能够执行其他并行任务。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter3](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter3).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下URL找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter3](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter3).
- en: Task-based multi-threading using enkiTS
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用enkiTS进行基于任务的并行多线程
- en: To achieve parallelism, we need to understand some basic concepts and choices
    that led to the architecture developed in this chapter. First, we should note
    that when we talk about parallelism in software engineering, we mean the act of
    executing chunks of code at the same time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现并行处理，我们需要了解一些基本概念和选择，这些概念和选择导致了本章中开发的架构。首先，我们应该注意，当我们谈论软件工程中的并行处理时，我们指的是同时执行代码块的行为。
- en: This is possible because modern hardware has different units that can be operated
    independently, and operating systems have dedicated execution units called **threads**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为现代硬件有不同的可以独立操作的单元，操作系统有专门的执行单元称为**线程**。
- en: A common way to achieve parallelism is to reason with tasks – small independent
    execution units that can run on any thread.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并行的一种常见方式是通过任务进行推理——这些是小型的独立执行单元，可以在任何线程上运行。
- en: Why task-based parallelism?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要基于任务的并行处理？
- en: Multi-threading is not a new subject, and since the early years of it being
    added to various game engines, there have been different ways of implementing
    it. Game engines are pieces of software that use all of the hardware available
    in the most efficient way, thus paving the way for more optimized software architectures.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程不是一个新主题，自从它在游戏引擎的早期年份被添加以来，就有不同的实现方式。游戏引擎是那些以最有效的方式使用所有可用硬件的软件组件，从而为更优化的软件架构铺平了道路。
- en: Therefore, we’ll take some ideas from game engines and gaming-related presentations.
    The initial implementations started by adding a thread with a single job to do
    – something specific, such as rendering a single thread, an asynchronous **input/output**
    (**I/O**) thread, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从游戏引擎和与游戏相关的演示中汲取一些想法。最初的实现是通过添加一个执行单一任务的线程开始的——比如渲染单个线程，异步的**输入/输出**（**I/O**）线程等。
- en: This helped add more granularity to what could be done in parallel, and it was
    perfect for the older CPUs (having two cores only), but it soon became limiting.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于增加并行执行可以做的事情的粒度，对于只有两个核心的旧CPU来说，这是完美的，但很快它就变得有限了。
- en: 'There was the need to use cores in a more agnostic way so that any type of
    job could be done by almost any core and to improve performance. This gave way
    to the emergence of two new architectures: **task-based** and **fiber-based**
    architectures.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要以更无关的方式使用核心，以便几乎任何核心都可以完成任何类型的工作，并提高性能。这导致了两种新架构的出现：**基于任务**和**基于纤维**的架构。
- en: Task-based parallelism is achieved by feeding multiple threads with different
    tasks and orchestrating them through dependencies. Tasks are inherently platform
    agnostic and cannot be interrupted, leading to a more straightforward capability
    to schedule and organize code to be executed with them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基于任务的并行处理是通过为多个线程提供不同的任务并通过依赖关系来协调它们来实现的。任务本质上是平台无关的，并且不能被中断，这导致了对调度和组织与它们一起执行的代码的更直接的能力。
- en: On the other hand, fibers are software constructs similar to tasks, but they
    rely heavily on the scheduler to interrupt their flow and resume when needed.
    This main difference makes it hard to write a proper fiber system and normally
    leads to a lot of subtle errors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，纤维是类似于任务的软件结构，但它们严重依赖于调度器来中断它们的流程并在需要时恢复。这种主要区别使得编写合适的纤维系统变得困难，通常会导致许多微妙的错误。
- en: For the simplicity of using tasks over fibers and the bigger availability of
    libraries implementing task-based parallelism, the enkiTS library was chosen to
    handle everything. For those curious about more in-depth explanations, there are
    a couple of great presentations about these architectures.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用任务而不是纤维的简单性以及实现基于任务并行处理的库的更大可用性，选择了enkiTS库来处理所有事情。对于那些对更深入的解释感兴趣的人，有一些关于这些架构的非常好的演示。
- en: A great example of a task-based engine is the one behind the Destiny franchise
    (with an in-depth architecture you can view at [https://www.gdcvault.com/play/1021926/Destiny-s-Multithreaded-Rendering](https://www.gdcvault.com/play/1021926/Destiny-s-Multithreaded-Rendering)),
    while a fiber-based one is used by the game studio Naughty Dog for their games
    (there is a presentation about it at [https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine](https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任务驱动引擎的一个很好的例子是《命运》系列游戏背后的引擎（你可以在[https://www.gdcvault.com/play/1021926/Destiny-s-Multithreaded-Rendering](https://www.gdcvault.com/play/1021926/Destiny-s-Multithreaded-Rendering)查看其深入架构），而基于纤程的引擎则被游戏工作室Naughty
    Dog用于他们的游戏（有关它的介绍可以在[https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine](https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine)找到）。
- en: Using the enkiTS (Task-Scheduler) library
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用enkiTS（任务调度器）库
- en: Task-based multi-threading is based on the concept of a task, defined as a *unit
    of independent work that can be executed on any core of* *a CPU*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于任务的线程多线程是基于任务的概念，定义为“可以在CPU的任何核心上执行的独立工作单元”。
- en: To do that, there is a need for a scheduler to coordinate different tasks and
    take care of the possible dependencies between them. Another interesting aspect
    of a task is that it could have one or more dependencies so that it could be scheduled
    to run only after certain tasks finish their execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，需要一个调度器来协调不同的任务并处理它们之间可能存在的依赖关系。任务的另一个有趣方面是，它可能有一个或多个依赖项，这样它就只能在某些任务执行完毕后才能调度运行。
- en: This means that tasks can be submitted to the scheduler at any time, and with
    proper dependencies, we create a graph-based execution of the engine. If done
    properly, each core can be utilized fully and results in optimal performance to
    the engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任务可以在任何时候提交给调度器，并且通过适当的依赖关系，我们创建了一个基于图的引擎执行。如果做得正确，每个核心都可以充分利用，从而实现引擎的最佳性能。
- en: 'The scheduler is the brain behind all the tasks: it checks dependencies and
    priorities, and schedules or removes tasks based on need, and it is a new system
    added to the Raptor Engine.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器是所有任务背后的大脑：它检查依赖和优先级，根据需要调度或删除任务，并且它是添加到Raptor引擎中的新系统。
- en: When initializing the scheduler, the library spawns a number of threads, each
    waiting to execute a task. When adding tasks to the scheduler, they are inserted
    into a queue. When the scheduler is told to execute pending tasks, each thread
    gets the next available task from the queue – according to dependency and priority
    – and executes it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化调度器时，库会生成一定数量的线程，每个线程都在等待执行一个任务。当向调度器添加任务时，它们会被插入到一个队列中。当调度器被告知执行挂起任务时，每个线程从队列中获取下一个可用的任务——根据依赖和优先级——并执行它。
- en: It’s important to note that running tasks can spawn other tasks. These tasks
    will be added to the thread’s local queue, but they are up for grabs if another
    thread is idle. This implementation is called a **work-stealing queue**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，运行任务可以生成其他任务。这些任务将被添加到线程的本地队列中，但如果另一个线程空闲，它们也可以被抢占。这种实现被称为**工作窃取队列**。
- en: 'Initializing the scheduler is as simple as creating a configuration and calling
    the `Initialize` method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化调度器就像创建一个配置并调用`Initialize`方法一样简单：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this code, we are telling the task scheduler to spawn four threads that
    it will use to perform its duties. enkiTS uses the `TaskSet` class as a unit of
    work, and it uses both inheritance and lambda functions to drive the execution
    of tasks in the scheduler:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们告诉任务调度器生成四个线程，它将使用这些线程来执行其任务。enkiTS使用`TaskSet`类作为工作单元，并且它使用继承和lambda函数来驱动调度器中任务的执行：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this simple snippet, we see how to create an empty `TaskSet` (as the name
    implies, a set of tasks) that defines how a task will execute the code, leaving
    the scheduler with the job of deciding how many of the tasks will be needed and
    which thread will be used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的代码片段中，我们看到如何创建一个空的`TaskSet`（正如其名所暗示的，一组任务），它定义了任务将如何执行代码，而将决定需要多少个任务以及哪个线程将被使用的任务留给了调度器。
- en: 'A more streamlined version of the previous code uses lambda functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的一个更简洁的版本使用了lambda函数：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This version can be easier when reading the code as it does break the flow less,
    but it is functionally equivalent to the previous one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本在阅读代码时可能更容易理解，因为它不会打断代码流，但它在功能上与上一个版本等效。
- en: Another feature of the enkiTS scheduler is the possibility to add pinned tasks
    – special tasks that will be bound to a thread and will always be executed there.
    We will see the use of pinned tasks in the next section to perform asynchronous
    I/O operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: enkiTS调度器的另一个特点是能够添加固定任务——这些特殊任务将被绑定到线程，并始终在那里执行。我们将在下一节中看到固定任务的使用，以执行异步I/O操作。
- en: In this section, we talked briefly about the different types of multi-threading
    so that we could express the reason for choosing to use task-based multi-threading.
    We then showed some simple examples of the enkiTS library and its usage, adding
    multi-threading capabilities to the Raptor Engine.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了不同类型的多线程，以便我们能够表达选择使用基于任务的线程的原因。然后我们展示了enkiTS库的一些简单示例及其用法，为Raptor引擎添加了多线程功能。
- en: In the next section, we will finally see a real use case in the engine, which
    is the asynchronous loading of resources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将最终看到在引擎中的真实用例，即资源的异步加载。
- en: Asynchronous loading
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步加载
- en: The loading of resources is one of the (if not *the*) slowest operations that
    can be done in any framework. This is because the files to be loaded are big,
    and they can come from different sources, such as optical units (DVD and Blu-ray),
    hard drives, and even the network.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的加载是任何框架中可以执行的最慢的操作之一（如果不是*最慢的*）。这是因为要加载的文件很大，它们可以来自不同的来源，例如光盘单元（DVD和蓝光），硬盘，甚至网络。
- en: 'It is another great topic, but the most important concept to understand is
    the inherent speed necessary to read the memory:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的话题，但最重要的概念是要理解读取内存的内在速度：
- en: '![Figure 3.1 – A memory hierarchy](img/B18395_03_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 内存层次结构](img/B18395_03_01.jpg)'
- en: Figure 3.1 – A memory hierarchy
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 内存层次结构
- en: 'As shown in the preceding diagram, the fastest memory is the registers memory.
    After registers follows the cache, with different levels and access speeds: both
    registers and caches are directly in the processing unit (both the CPU and GPU
    have registers and caches, even with different underlying architectures).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，最快的内存是寄存器内存。在寄存器之后是缓存，具有不同的级别和访问速度：寄存器和缓存都直接在处理单元中（CPU和GPU都有寄存器和缓存，尽管底层架构不同）。
- en: Main memory refers to the RAM, which is the area that is normally populated
    with the data used by the application. It is slower than the cache, but it is
    the target of the loading operations as the only one directly accessible from
    the code. Then there are magnetic disks (hard drives) and optical drives – much
    slower but with greater capacity. They normally contain the asset data that will
    be loaded into the main memory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 主存储器指的是RAM，这是通常填充应用程序使用的数据的区域。它的速度比缓存慢，但它是加载操作的目标，因为它是唯一可以从代码直接访问的。然后是磁盘（硬盘）和光盘驱动器——速度更慢，但容量更大。它们通常包含将要加载到主存储器中的资产数据。
- en: The final memory is in remote storage, such as from some servers, and it is
    the slowest. We will not deal with that here, but it can be used when working
    on applications that have some form of online service, such as multiplayer games.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的内存是在远程存储中，例如来自某些服务器，它是最慢的。我们在这里不会处理它，但可以在处理具有某种形式在线服务应用程序时使用，例如多人游戏。
- en: With the objective of optimizing the read access in an application, we want
    to transfer all the needed data into the main memory, as we can’t interact with
    caches and registers. To hide the slow speed of magnetic and optical disks, one
    of the most important things that can be done is to parallelize the loading of
    any resource coming from any medium so that the fluidity of the application is
    not slowed down.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化应用程序中的读取访问，我们希望将所有需要的数据传输到主存储器，因为我们不能与缓存和寄存器交互。为了隐藏磁性和光盘驱动器的慢速，可以做的事情之一是将任何来自任何介质的资源的加载并行化，这样就不会减慢应用程序的流畅性。
- en: The most common way of doing it, and one example of the thread-specialization
    architecture we talked briefly about before, is to have a separate thread that
    handles just the loading of resources and interacts with other systems to update
    the used resources in the engine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最常见的方式，也是我们之前简要提到的线程专用架构的一个例子，是有一个单独的线程来处理资源的加载，并与其他系统交互以更新引擎中使用的资源。
- en: In the following sections, we will talk about how to set up enkiTS and create
    tasks for parallelizing the Raptor Engine, as well as talk about Vulkan queues,
    which are necessary for parallel command submission. Finally, we will dwell on
    the actual code used for asynchronous loading.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论如何设置enkiTS并创建用于并行化Raptor引擎的任务，以及讨论Vulkan队列，这对于并行命令提交是必要的。最后，我们将深入探讨用于异步加载的实际代码。
- en: Creating the I/O thread and tasks
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建I/O线程和任务
- en: In the enkiTS library, there is a feature called **pinned-task** that associates
    a task to a specific thread so that it is continuously running there unless stopped
    by the user or a higher priority task is scheduled on that thread.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在enkiTS库中，有一个名为**固定任务**的功能，它将一个任务与一个特定的线程关联，以便它在那里持续运行，除非用户停止它或在该线程上调度了更高优先级的任务。
- en: 'To simplify things, we will add a new thread and avoid it being used by the
    application. This thread will be mostly idle, so the context switch should be
    low:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将添加一个新线程并避免它被应用程序使用。这个线程将大部分时间处于空闲状态，因此上下文切换应该很低：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then create a pinned task and associate it with a thread ID:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个固定任务并将其与一个线程ID关联：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, we can create the actual task responsible for asynchronous loading,
    associating it with the same thread as the pinned task:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以创建实际负责异步加载的任务，将其与固定任务相同的线程关联：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final piece of the puzzle is the actual code for these two tasks. First,
    let us have a look at the first pinned task:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是这两个任务的实际代码。首先，让我们看看第一个固定任务：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This task will wait for any other pinned task and run them when possible. We
    have added an `execute` flag to stop the execution when needed, for example, when
    exiting the application, but it could be used in general to suspend it in other
    situations (such as when the application is minimized).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务将等待任何其他固定任务，并在可能的情况下运行它们。我们已经添加了一个`execute`标志，以便在需要时停止执行，例如，当退出应用程序时，但它也可以在其他情况下（例如，当应用程序最小化时）用于暂停它。
- en: 'The other task is the one executing the asynchronous loading using the `AsynchronousLoader`
    class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个任务是使用`AsynchronousLoader`类执行异步加载：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The idea behind this task is to always be active and wait for requests for resource
    loading. The `while` loop ensures that the root pinned task never schedules other
    tasks on this thread, locking it to I/O as intended.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务背后的想法是始终保持活跃状态并等待资源加载的请求。`while`循环确保根固定任务永远不会在这个线程上调度其他任务，从而将其锁定到I/O，达到预期效果。
- en: Before moving on to look at the `AsynchronousLoader` class, we need to look
    at an important concept in Vulkan, namely queues, and why they are a great addition
    for asynchronous loading.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`AsynchronousLoader`类之前，我们需要查看Vulkan中的一个重要概念，即队列，以及为什么它们对于异步加载是一个很好的补充。
- en: Vulkan queues and the first parallel command generation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vulkan队列和首次并行命令生成
- en: The concept of a *queue* – which can be defined as the entry point to submit
    commands recorded in `VkCommandBuffers` to the GPU – is an addition to Vulkan
    compared to OpenGL and needs to be taken care of.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*的概念——可以定义为将记录在`VkCommandBuffers`中的命令提交到GPU的入口点——是Vulkan相对于OpenGL的一个新增功能，需要特别注意。'
- en: Submission using a queue is a single-threaded operation, and a costly operation
    that becomes a synchronization point between CPU and GPU to be aware of. Normally,
    there is the main queue to which the engine submits command buffers before presenting
    the frame. This will send the work to the GPU and create the rendered image intended.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用队列的提交是一个单线程操作，这是一个代价高昂的操作，成为CPU和GPU之间同步的一个点。通常，有一个主队列，在呈现帧之前，引擎将命令缓冲区提交到该队列。这将把工作发送到GPU并创建预期的渲染图像。
- en: But where there is one queue, there can be more. To enhance parallel execution,
    we can instead create different *queues* – and use them in different threads instead
    of the main one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一个队列，可以有更多。为了增强并行执行，我们可以创建不同的*队列*——并在不同的线程中使用它们而不是主线程。
- en: 'A more in-depth look at queues can be found at [https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/queues.adoc](https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/queues.adoc),
    but what we need to know is that each queue can submit certain types of commands,
    visible through a queue’s flag:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/queues.adoc](https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/queues.adoc)找到对队列的更深入探讨，但我们需要知道的是，每个队列可以提交某些类型的命令，这些命令可以通过队列的标志来查看：
- en: '`VK_QUEUE_GRAPHICS_BIT` can submit all `vkCmdDraw` commands'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_QUEUE_GRAPHICS_BIT`可以提交所有`vkCmdDraw`命令'
- en: '`VK_QUEUE_COMPUTE` can submit all `vkCmdDispatch` and `vkCmdTraceRays` (used
    for ray tracing)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_QUEUE_COMPUTE` 可以提交所有 `vkCmdDispatch` 和 `vkCmdTraceRays`（用于光线追踪）'
- en: '`VK_QUEUE_TRANSFER` can submit copy commands, such as `vkCmdCopyBuffer`, `vkCmdCopyBufferToImage`,
    and `vkCmdCopyImageToBuffer`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_QUEUE_TRANSFER` 可以提交复制命令，例如 `vkCmdCopyBuffer`、`vkCmdCopyBufferToImage`
    和 `vkCmdCopyImageToBuffer`'
- en: 'Each available queue is exposed through a queue family. Each queue family can
    have multiple capabilities and can expose multiple queues. Here is an example
    to clarify:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可用的队列都通过队列家族公开。每个队列家族可以有多个功能，并可以公开多个队列。以下是一个澄清的例子：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first queue exposes all capabilities, and we only have one of them. The
    next queue can be used for compute and transfer, and the third one for transfer
    (we’ll ignore the sparse feature for now). We have two queues for each of these
    families.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个队列公开所有功能，而我们只有一个。下一个队列可用于计算和传输，第三个队列用于传输（我们现在将忽略稀疏功能）。我们为这些家族中的每个家族都有两个队列。
- en: It is guaranteed that on a GPU there will always be at least one queue that
    can submit all types of commands, and that will be our main queue.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 保证在GPU上始终至少有一个队列可以提交所有类型的命令，并且那将是我们的主队列。
- en: In some GPUs, though, there can be specialized queues that have only the `VK_QUEUE_TRANSFE`R
    flag activated, which means that they can use **direct memory access** (**DMA**)
    to speed up the transfer of data between the CPU and the GPU.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些GPU中，可能有专门的队列，它们只激活了 `VK_QUEUE_TRANSFER` 标志，这意味着它们可以使用 **直接内存访问**（**DMA**）来加速CPU和GPU之间数据传输的速度。
- en: 'One last thing: the Vulkan logical device is responsible for creating and destroying
    queues – an operation normally done at the startup/shutdown of the application.
    Let us briefly see the code to query the support for different queues:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：Vulkan逻辑设备负责创建和销毁队列——这是一个通常在应用程序启动/关闭时进行的操作。让我们简要地看看查询不同队列支持的代码：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As can be seen in the preceding code, we get the list of all queues for the
    selected GPU, and we check the different bits that identify the types of commands
    that can be executed there.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们获取了所选GPU的所有队列列表，并检查了标识可以在此处执行命令类型的不同位。
- en: In our case, we will save the *main queue* and the *transfer queue*, if it is
    present on the GPU, and we will save the indices of the *queues* to retrieve the
    `VkQueue` after the device creation. Some devices don’t expose a separate transfer
    queue. In this case, we will use the main queue to perform transfer operations,
    and we need to make sure that access to the queue is correctly synchronized for
    upload and graphics submissions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将保存 *主队列* 和 *传输队列*（如果GPU上有），并将保存 *队列* 的索引以在设备创建后检索 `VkQueue`。某些设备不公开单独的传输队列。在这种情况下，我们将使用主队列来执行传输操作，并确保队列的访问在上传和图形提交时正确同步。
- en: 'Let’s see how to create the *queues*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建 *队列*：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As already mentioned, `vkCreateDevice` is the command that creates *queues*
    by adding `pQueueCreateInfos` in the `VkDeviceCreateInfo` struct.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`vkCreateDevice` 是通过在 `VkDeviceCreateInfo` 结构中添加 `pQueueCreateInfos` 来创建
    *队列* 的命令。
- en: 'Once the device is created, we can query for all the queues as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 设备创建后，我们可以查询所有队列，如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, we have both the main and the transfer queues ready to be used
    to submit work in parallel.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好了主队列和传输队列，可以用来并行提交工作。
- en: We had a look at how to submit parallel work to copy memory over the GPU without
    blocking either the GPU or the CPU, and we created a specific class to do that,
    `AsynchronousLoader`, which we will cover in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何提交并行工作以在GPU上复制内存，而不阻塞GPU或CPU，并创建了一个特定的类来完成这项工作，`AsynchronousLoader`，我们将在下一节中介绍。
- en: The AsynchronousLoader class
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步加载器类
- en: Here, we’ll finally see the code for the class that implements asynchronous
    loading.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将最终看到实现异步加载的类的代码。
- en: 'The `AsynchronousLoader` class has the following responsibilities:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronousLoader` 类有以下职责：'
- en: Process load from file requests
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理来自文件的请求负载
- en: Process GPU upload transfers
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理GPU上传传输
- en: Manage a staging buffer to handle a copy of the data
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理一个阶段缓冲区以处理数据的复制
- en: Enqueue the command buffers with copy commands
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将带有复制命令的命令缓冲区入队
- en: Signal to the renderer that a texture has finished a transfer
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向渲染器发出信号，表示纹理已完成传输
- en: Before focusing on the code that uploads data to the GPU, there is some Vulkan-specific
    code that is important to understand, relative to command pools, transfer queues,
    and using a staging buffer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在专注于上传数据到GPU的代码之前，有一些与命令池、传输队列和使用暂存缓冲区相关的特定于Vulkan的代码是重要的，需要理解。
- en: Creating command pools for the transfer queue
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为传输队列创建命令池
- en: 'In order to submit commands to the transfer queue, we need to create command
    pools that are linked to that queue:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将命令提交到传输队列，我们需要创建与该队列链接的命令池：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The important part is `queueFamilyIndex`, to link `CommandPool` to the transfer
    queue so that every command buffer allocated from this pool can be properly submitted
    to the transfer queue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是`queueFamilyIndex`，将`CommandPool`链接到传输队列，以便从这个池分配的每个命令缓冲区都可以正确提交到传输队列。
- en: 'Next, we will simply allocate the command buffers linked to the newly created
    pools:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简单地分配与新创建的池链接的命令缓冲区：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this setup, we are now ready to submit commands to the transfer queue using
    the command buffers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们现在可以使用命令缓冲区提交命令到传输队列。
- en: Next, we will have a look at the staging buffer – an addition to ensure that
    the transfer to the GPU is the fastest possible from the CPU.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看暂存缓冲区——这是一个附加功能，以确保从CPU到GPU的传输尽可能快。
- en: Creating the staging buffer
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建暂存缓冲区
- en: To optimally transfer data between the CPU and the GPU, there is the need to
    create an area of memory that can be used as a source to issue commands related
    to copying data to the GPU.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在CPU和GPU之间最优地传输数据，需要创建一个可以用于发出与复制数据到GPU相关的命令的内存区域。
- en: To achieve this, we will create a staging buffer, a persistent buffer that will
    serve this purpose. We will see both the Raptor wrapper and the Vulkan-specific
    code to create a persistent staging buffer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建一个暂存缓冲区，一个将为此目的服务的持久缓冲区。我们将看到用于创建持久暂存缓冲区的Raptor包装器和特定于Vulkan的代码。
- en: 'In the following code, we will allocate a persistently mapped buffer of 64
    MB:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将分配一个64MB的持久映射缓冲区：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This translates to the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于以下代码：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This buffer will be the source of the memory transfers, and the `VMA_ALLOCATION_CREATE_MAPPED_BIT`
    flag ensures that it will always be mapped.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缓冲区将是内存传输的来源，`VMA_ALLOCATION_CREATE_MAPPED_BIT`标志确保它始终被映射。
- en: 'We can retrieve and use the pointer to the allocated data from the `allocation_info`
    structure, filled by `vmaCreateBuffer`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`allocation_info`结构中检索并使用分配数据的指针，该结构由`vmaCreateBuffer`填充：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can now use the staging buffer for any operation to send data to the GPU,
    and if ever there is the need for a bigger allocation, we could recreate a new
    staging buffer with a bigger size.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用暂存缓冲区进行任何操作，将数据发送到GPU，如果需要更大的分配，我们可以创建一个新的更大尺寸的暂存缓冲区。
- en: Next, we need to see the code to create a semaphore and a fence used to submit
    and synchronize the CPU and GPU execution of commands.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要查看创建用于提交和同步CPU和GPU命令执行的信号量和栅栏的代码。
- en: Creating semaphores and fences for GPU synchronization
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为GPU同步创建信号量和栅栏
- en: 'The code here is straightforward; the only important part is the creation of
    a signaled fence because it will let the code start to process uploads:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码很简单；唯一重要的一部分是创建一个已标记的栅栏，因为它将允许代码开始处理上传：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we have now arrived at processing the requests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在已经到达了处理请求的阶段。
- en: Processing a file request
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理文件请求
- en: File requests are not specifically Vulkan-related, but it is useful to see how
    they are done.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文件请求不是特定于Vulkan的，但了解它们是如何完成的是有用的。
- en: 'We use the STB image library ([https://github.com/nothings/stb](https://github.com/nothings/stb))
    to load the texture into memory and then simply add the loaded memory and the
    associated texture to create an upload request. This will be responsible for copying
    the data from the memory to the GPU using the transfer queue:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用STB图像库([https://github.com/nothings/stb](https://github.com/nothings/stb))将纹理加载到内存中，然后简单地将加载的内存和相关的纹理添加到创建上传请求。这将负责使用传输队列将数据从内存复制到GPU：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we will see how to process an upload request.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何处理上传请求。
- en: Processing an upload request
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理上传请求
- en: This is the part that finally uploads the data to the GPU. First, we need to
    ensure that the fence is signaled to proceed, which is why we created it already
    signaled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终将数据上传到GPU的部分。首先，我们需要确保栅栏被标记为已信号，这就是为什么我们事先已经标记了它。
- en: 'If it is signaled, we can reset it so we can let the API signal it when the
    submission is done:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它已被信号，我们可以将其重置，以便在提交完成后让API对其进行信号：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then proceed to take a request, allocate memory from the staging buffer,
    and use a command buffer to upload the GPU:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续接收请求，从预演缓冲区分配内存，并使用命令缓冲区上传GPU：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `upload_texture_data` method is the one that takes care of uploading data
    and adding the needed barriers. This can be tricky, so we’ve included the code
    to show how it can be done.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload_texture_data`方法负责上传数据和添加所需的屏障。这可能很棘手，所以我们包括了代码以展示如何完成。'
- en: 'First, we need to copy the data to the staging buffer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将数据复制到预演缓冲区：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we can prepare a copy, in this case, from the staging buffer to an image.
    Here, it is important to specify the offset into the staging buffer:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以准备一个复制，在这种情况下，从预演缓冲区到图像。在这里，指定预演缓冲区中的偏移量很重要：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We then proceed with adding a precopy memory barrier to perform a layout transition
    and specify that the data is using the transfer queue.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续添加一个预复制内存屏障以执行布局转换，并指定数据正在使用传输队列。
- en: This uses the code suggested in the synchronization examples provided by the
    Khronos Group ([https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples](https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了Khronos Group提供的同步示例中建议的代码([https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples](https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples))。
- en: 'Once again, we show the raw Vulkan code that is simplified with some utility
    functions, highlighting the important lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次展示经过一些实用函数简化的原始Vulkan代码，突出显示重要的行：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The texture is now ready to be copied to the GPU:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理现在已准备好复制到GPU：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The texture is now on the GPU, but it is still not usable from the main queue.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理现在已在GPU上，但它仍然不能从主队列中使用。
- en: 'That is why we need another memory barrier that will also transfer ownership:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要另一个内存屏障，它也将转移所有权：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the ownership is transferred, a final barrier is needed to ensure that
    the transfer is complete and the texture can be read from the shaders, but this
    will be done by the renderer because it needs to use the main queue.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有权转移，需要一个最终的屏障来确保传输完成，并且纹理可以从着色器中读取，但这将由渲染器完成，因为它需要使用主队列。
- en: Signaling the renderer of the finished transfer
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知渲染器传输完成
- en: The signaling is implemented by simply adding the texture to a mutexed list
    of textures to update so that it is thread safe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是通过简单地将纹理添加到要更新的互斥纹理列表中实现的，以确保线程安全。
- en: At this point, we need to perform a final barrier for each transferred texture.
    We opted to add these barriers after all the rendering is done and before the
    present step, but it could also be done at the beginning of the frame.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要为每个传输的纹理执行一个最终的屏障。我们选择在所有渲染完成后和当前步骤之前添加这些屏障，但也可以在帧的开始时进行。
- en: 'As stated before, one last barrier is needed to signal that the newly updated
    image is ready to be read by shaders and that all the writing operations are done:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，需要一个最后的屏障来指示新更新的图像已准备好由着色器读取，并且所有写入操作都已完成：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are now ready to use the texture on the GPU in our shaders, and the asynchronous
    loading is working. A very similar path is created for uploading buffers and thus
    will be omitted from the book but present in the code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好在着色器中使用GPU上的纹理，异步加载正在工作。为上传缓冲区创建了一条非常相似的路径，但将在书中省略，但在代码中存在。
- en: In this section, we saw how to unlock the asynchronous loading of resources
    to the GPU by using a transfer queue and different command buffers. We also showed
    how to manage ownership transfer between queues. Then, we finally saw the first
    steps in setting up tasks with the task scheduler, which is used to add multi-threading
    capabilities to the Raptor Engine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何通过使用传输队列和不同的命令缓冲区来解锁资源到GPU的异步加载。我们还展示了如何管理队列之间的所有权转移。然后，我们最终看到了使用任务调度器设置任务的初步步骤，该调度器用于向Raptor引擎添加多线程功能。
- en: In the next section, we will use the acquired knowledge to add the parallel
    recording of commands to draw objects on the screen.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用所获得的知识来添加命令的并行记录，以在屏幕上绘制对象。
- en: Recording commands on multiple threads
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个线程上记录命令
- en: To record commands using multiple threads, it is necessary to use different
    command buffers, at least one on each thread, to record the commands and then
    submit them to the main queue. To be more precise, in Vulkan, any kind of pool
    needs to be externally synchronized by the user; thus, the best option is to have
    an association between a thread and a pool.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用多个线程记录命令，必须使用不同的命令缓冲区，至少每个线程一个，以记录命令然后将它们提交到主队列。更精确地说，在Vulkan中，任何类型的池都需要由用户外部同步；因此，最佳选项是将线程与池关联起来。
- en: In the case of command buffers, they are allocated from the associated pool
    and commands registered in it. Pools can be `CommandPools`, `DescriptorSetPools`,
    and `QueryPools` (for time and occlusion queries), and once associated with a
    thread, they can be used freely inside that thread of execution.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令缓冲区的情况下，它们是从关联的池中分配的，并在其中注册了命令。池可以是`CommandPools`、`DescriptorSetPools`和`QueryPools`（用于时间和遮挡查询），一旦与线程关联，就可以在执行线程内部自由使用。
- en: The execution order of the command buffers is based on the order of the array
    submitted to the main queue – thus, from a Vulkan perspective, sorting can be
    performed on a command buffer level.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区的执行顺序基于提交到主队列的数组的顺序——因此，从Vulkan的角度来看，可以在命令缓冲区级别进行排序。
- en: We will see how important the allocation strategy for command buffers is and
    how easy it is to draw in parallel once the allocation is in place. We will also
    talk about the different types of command buffers, a unique feature of Vulkan.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到命令缓冲区的分配策略有多么重要，以及一旦分配到位，并行绘制是多么容易。我们还将讨论不同类型的命令缓冲区，这是Vulkan的独特特性。
- en: The allocation strategy
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配策略
- en: The success in recording commands in parallel is achieved by taking into consideration
    both thread access and frame access. When creating command pools, not only does
    each thread need a unique pool to allocate command buffers and commands from,
    but it also needs to not be in flight in the GPU.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 并行记录命令的成功是通过考虑线程访问和帧访问来实现的。在创建命令池时，不仅每个线程需要一个唯一的池来分配命令缓冲区和命令，而且它还需要不在GPU上飞行。
- en: A simple allocation strategy is to decide the maximum number of threads (we
    will call them `T`) that will record commands and the max number of frames (we
    will call them `F`) that can be in flight, then allocate command pools that are
    `F *` `T`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的分配策略是决定将记录命令的最大线程数（我们将它们称为`T`）和可以飞行的最大帧数（我们将它们称为`F`），然后分配`F * T`的命令池。
- en: For each task that wants to render, using the pair frame-thread ID, we will
    guarantee that no pool will be either in flight or used by another thread.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个想要渲染的任务，使用帧-线程ID对，我们将保证没有任何池会处于飞行状态或被另一个线程使用。
- en: This is a very conservative approach and can lead to unbalanced command generations,
    but it can be a great starting point and, in our case, enough to provide support
    for parallel rendering to the Raptor Engine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常保守的方法，可能导致命令生成不平衡，但它可以是一个很好的起点，在我们的情况下，足以提供对Raptor引擎并行渲染的支持。
- en: In addition, we will allocate a maximum of five empty command buffers, two primary
    and three secondary, so that more tasks can execute chunks of rendering in parallel.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将分配最多五个空命令缓冲区，两个主缓冲区和三个次级缓冲区，以便更多任务可以并行执行渲染的片段。
- en: The class responsible for this is the `CommandBufferManager` class, accessible
    from the device, and it gives the user the possibility to request a command buffer
    through the `get_command_buffer` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 负责此功能的类是`CommandBufferManager`类，可以从设备访问，并且它通过`get_command_buffer`方法给用户提供了请求命令缓冲区的可能性。
- en: In the next section, we will see the difference between primary and secondary
    command buffers, which are necessary to decide the granularity of the tasks to
    draw the frame in parallel.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到主命令缓冲区和次级命令缓冲区之间的区别，这对于决定并行绘制帧的任务粒度是必要的。
- en: Command buffer recycling
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令缓冲区回收
- en: Linked to the allocation strategy is the recycling of the buffers. When a buffer
    has been executed, it can be reused to record new commands instead of always allocating
    new ones.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与分配策略相关的是缓冲区的回收。当一个缓冲区已被执行后，它可以被重新用于记录新的命令，而不是总是分配新的缓冲区。
- en: 'Thanks to the allocation strategy we chose, we associate a fixed amount of
    `CommandPools` to each frame, and thus to reuse the command buffers, we will reset
    its corresponding `CommandPool` instead of manually freeing buffers: this has
    been proven to be much more efficient on CPU time.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们选择的分配策略，我们将固定数量的`CommandPools`与每个帧关联起来，因此为了重用命令缓冲区，我们将重置其对应的`CommandPool`而不是手动释放缓冲区：这在CPU时间上已被证明效率更高。
- en: Note that we are not freeing the memory associated with the buffer, but we give
    `CommandPool` the freedom to reuse the total memory allocated between the command
    buffers that will be recorded, and it will reset all the states of all its command
    buffers to their initial state.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并没有释放与缓冲区关联的内存，而是给`CommandPool`自由使用在将被记录的命令缓冲区之间分配的总内存，并且它会将其所有命令缓冲区的所有状态重置到初始状态。
- en: 'At the beginning of each frame, we call a simple method to reset pools:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧的开始，我们调用一个简单的方法来重置池：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is a utility method to calculate the pool index, based on the thread and
    frame.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 基于线程和帧，有一个计算池索引的实用方法。
- en: After the reset of the pools, we can reuse the command buffers to record commands
    without needing to explicitly do so for each command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在重置池之后，我们可以重用命令缓冲区来记录命令，而无需为每个命令显式地这样做。
- en: We can finally have a look at the different types of command buffers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以查看不同类型的命令缓冲区。
- en: Primary versus secondary command buffers
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主命令缓冲区与辅助命令缓冲区的比较
- en: 'The Vulkan API has a unique difference in what command buffers can do: a command
    buffer can either be primary or secondary.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API在命令缓冲区可以做什么方面有一个独特差异：命令缓冲区可以是主缓冲区或辅助缓冲区。
- en: Primary command buffers are the most used ones and can perform any of the commands
    – drawing, compute, or copy commands, but their granularity is pretty coarse –
    at least one render pass must be used, and no pass can be further parallelized.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 主命令缓冲区是最常用的，可以执行任何命令——绘图、计算或复制命令，但它们的粒度相当粗糙——至少必须使用一个渲染通道，并且没有通道可以进一步并行化。
- en: Secondary command buffers are much more limited – they can actually only execute
    draw commands within a render pass – but they can be used to parallelize the rendering
    of render passes that contain many draw calls (such as a G-Buffer render pass).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助命令缓冲区功能更加有限——它们实际上只能在渲染通道内执行绘图命令——但它们可以用来并行化包含许多绘图调用（如G-Buffer渲染通道）的渲染通道的渲染。
- en: It is paramount then to make an informed decision about the granularity of the
    tasks, and especially important is to understand when to record using a primary
    or secondary buffer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，做出关于任务粒度的明智决策至关重要，特别是理解何时使用主缓冲区或辅助缓冲区进行记录尤为重要。
- en: In [*Chapter 4*](B18395_04.xhtml#_idTextAnchor064), *Implementing a Frame Graph*,
    we will see how a graph of the frame can give enough information to decide which
    command buffer type to use and how many objects and render passes should be used
    in a task.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18395_04.xhtml#_idTextAnchor064) *实现帧图*中，我们将看到帧图如何提供足够的信息来决定使用哪种类型的命令缓冲区以及在一个任务中应该使用多少对象和渲染通道。
- en: In the next section, we will see how to use both primary and secondary command
    buffers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用主命令缓冲区和辅助命令缓冲区。
- en: Drawing using primary command buffers
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用主命令缓冲区进行绘图
- en: Drawing using primary command buffers is the most common way of using Vulkan
    and also the simplest. A primary command buffer, as already stated before, can
    execute any kind of command with no limitation, and it is the only one that can
    be submitted to a queue to be executed on the GPU.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主命令缓冲区进行绘图是使用Vulkan最常见的方式，也是最简单的方式。正如之前所述，主命令缓冲区可以无限制地执行任何类型的命令，并且是唯一可以提交到队列以在GPU上执行的一个。
- en: Creating a primary command buffer is simply a matter of using `VK_COMMAND_BUFFER_LEVEL_PRIMARY`
    in the `VkCommandBufferAllocateInfo` structure passed to the `vkAllocateCommandBuffers`
    function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个主命令缓冲区只需在传递给`vkAllocateCommandBuffers`函数的`VkCommandBufferAllocateInfo`结构中使用`VK_COMMAND_BUFFER_LEVEL_PRIMARY`即可。
- en: Once created, at any time, we can begin the commands recording (with the `vkBeginCommandBuffer`
    function), bind passes and pipelines, and issue draw commands, copy commands,
    and compute ones.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，在任何时候，我们都可以开始命令记录（使用`vkBeginCommandBuffer`函数），绑定通道和管线，并发出绘图命令、复制命令和计算命令。
- en: 'Once the recording is finished, the `vkEndCommandBuffer` function must be used
    to signal the end of recording and prepare the buffer to be ready to be submitted
    to a queue:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦记录完成，必须使用`vkEndCommandBuffer`函数来表示记录结束并准备缓冲区以便提交到队列：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To record commands in parallel, there are only two conditions that must be
    respected by the recording threads:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了并行记录命令，记录线程必须遵守以下两个条件：
- en: Simultaneous recording on the same `CommandPool` is forbidden
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一`CommandPool`上同时记录是禁止的
- en: Commands relative to `RenderPass` can only be executed in one thread
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`RenderPass`相关的命令只能在单个线程中执行
- en: What happens if a pass (such as a Forward or G-Buffer typical pass) contains
    a lot of draw-calls, thus requiring parallel rendering? This is where secondary
    command buffers can be useful.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个传递（例如，典型的前向或G-Buffer传递）包含大量的绘制调用，从而需要并行渲染，会发生什么？这就是次级命令缓冲区可以发挥作用的地方。
- en: Drawing using secondary command buffers
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用次级命令缓冲区进行绘制
- en: Secondary command buffers have a very specific set of conditions to be used
    – they can record commands relative to only one render pass.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 次级命令缓冲区有一组非常具体的条件需要使用——它们只能记录与一个渲染传递相关的命令。
- en: 'That is why it is important to allow the user to record more than one secondary
    command buffer: it could be possible that more than one pass needs per-pass parallelism,
    and thus more than one secondary command buffer is needed.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么允许用户记录多个次级命令缓冲区很重要：可能需要多个传递的每传递并行性，因此可能需要多个次级命令缓冲区。
- en: 'Secondary buffers always need a primary buffer and can’t be submitted directly
    to any queue: they must be copied into the primary buffer and inherit only `RenderPass`
    and `FrameBuffers` set when beginning to record commands.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 次级缓冲区始终需要一个主缓冲区，并且不能直接提交到任何队列：它们必须被复制到主缓冲区，并且仅在开始记录命令时继承`RenderPass`和`FrameBuffers`。
- en: Let’s have a look at the different steps involving the usage of secondary command
    buffers. First, we need to have a primary command buffer that needs to set up
    a render pass and frame buffer to be rendered into, as this is absolutely necessary
    because no secondary command buffer can be submitted to a queue or set `RenderPass`
    or `FrameBuffer`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看涉及次级命令缓冲区使用的不同步骤。首先，我们需要有一个主命令缓冲区，该缓冲区需要设置一个渲染传递和要渲染的帧缓冲区，因为这是绝对必要的，因为没有次级命令缓冲区可以提交到队列或设置`RenderPass`或`FrameBuffer`。
- en: Those will be the only states inherited from the primary command buffer, thus,
    even when beginning to record commands, viewport and stencil states must be set
    again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是唯一从主命令缓冲区继承的状态，因此，即使在开始记录命令时，视口和模板状态也必须重新设置。
- en: 'Let’s start by showing a primary command buffer setup:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先展示一个主命令缓冲区的设置：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When beginning a render pass that will be split among one or more secondary
    command buffers, we need to add the `VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS`
    flag:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个将被分配给一个或多个次级命令缓冲区的渲染传递时，我们需要添加`VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS`标志：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can then pass the `inheritanceInfo` struct to the secondary buffer:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`inheritanceInfo`结构体传递给次级缓冲区：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And then we can begin the secondary command buffer:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以开始次级命令缓冲区：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The secondary command buffer is now ready to start issuing drawing commands:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 次级命令缓冲区现在已准备好开始发出绘制命令：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the scissor and viewport must always be set at the beginning, as no
    state is inherited outside of the bound render pass and frame buffer.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，必须在开始时设置裁剪和视口，因为没有状态在边界渲染传递和帧缓冲区之外被继承。
- en: 'Once we have finished recording the commands, we can call the `VkEndCommandBuffer`
    function and put the buffer into a copiable state in the primary command buffer.
    To copy the secondary command buffers into the primary one, there is a specific
    function, `vkCmdExecuteCommands`, that needs to be called:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成命令的记录，我们可以调用`VkEndCommandBuffer`函数并将缓冲区放入主命令缓冲区中的可复制状态。为了将次级命令缓冲区复制到主缓冲区，需要调用一个特定的函数，即`vkCmdExecuteCommands`。
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function accepts an array of secondary command buffers that will be sequentially
    copied into the primary one.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个次级命令缓冲区的数组，这些缓冲区将被顺序复制到主缓冲区中。
- en: To ensure a correct ordering of the commands recorded, not guaranteed by multi-threading
    (as threads can finish in any order), we can give each command buffer an execution
    index, put them all into an array, sort them, and then use this sorted array in
    the `vkCmdExecuteCommands` function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保记录的命令的正确顺序，多线程（因为线程可以以任何顺序完成）不能保证，我们可以给每个命令缓冲区一个执行索引，将它们全部放入一个数组中，排序它们，然后使用这个排序后的数组在`vkCmdExecuteCommands`函数中。
- en: At this point, the primary command buffer can record other commands or be submitted
    to the queue, as it contains all the commands copied from the secondary command
    buffers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，主命令缓冲区可以记录其他命令或提交到队列中，因为它包含了从辅助命令缓冲区复制过来的所有命令。
- en: Spawning multiple tasks to record command buffers
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动多个任务以记录命令缓冲区
- en: The last step is to create multiple tasks to record command buffers in parallel.
    We have decided to group multiple meshes per command buffer as an example, but
    usually, you would record separate command buffers per render pass.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建多个任务以并行记录命令缓冲区。我们决定将多个网格分组到每个命令缓冲区作为一个例子，但通常，你会在每个渲染通道中记录单独的命令缓冲区。
- en: 'Let’s take a look at the code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We add a task to the scheduler for each mesh group. Each task will record a
    command buffer for a range of meshes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个网格组添加一个任务到调度器中。每个任务将记录一系列网格的命令缓冲区。
- en: 'Once we have added all the tasks, we have to wait until they complete before
    adding the secondary command buffers for execution on the main command buffer:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了所有任务，我们必须等待它们完成，然后才能添加辅助命令缓冲区以在主命令缓冲区上执行：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We suggest reading the code for this chapter for more details on the implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议阅读本章的代码以获取更多关于实现的详细信息。
- en: In this section, we have described how to record multiple command buffers in
    parallel to optimize this operation on the CPU. We have detailed our allocation
    strategy for command buffers and how they can be reused across frames.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了如何并行记录多个命令缓冲区以优化CPU上的此操作。我们详细说明了命令缓冲区的分配策略以及它们如何在帧间重用。
- en: We have highlighted the differences between primary and secondary buffers and
    how they are used in our renderer. Finally, we have demonstrated how to record
    multiple command buffers in parallel.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出了主缓冲区和辅助缓冲区之间的差异，以及它们在我们渲染器中的使用方式。最后，我们展示了如何并行记录多个命令缓冲区。
- en: In the next chapter, we are going to introduce the frame graph, a system that
    allows us to define multiple render passes and that can take advantage of the
    task system we have described to record the command buffer for each render pass
    in parallel.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍帧图，这是一个允许我们定义多个渲染通道并可以利用我们描述的任务系统来并行记录每个渲染通道命令缓冲区的系统。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the concept of task-based parallelism and
    saw how using a library such as enkiTS can quickly add multi-threading capabilities
    to the Raptor Engine.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了基于任务并行性的概念，并看到了如何使用如enkiTS之类的库快速将多线程能力添加到Raptor引擎中。
- en: We then learned how to add support for loading data from files to the GPU using
    an asynchronous loader. We also focused on Vulkan-related code to have a second
    queue of execution that can run in parallel to the one responsible for drawing.
    We saw the difference between primary and secondary command buffers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何使用异步加载器将数据从文件加载到GPU上。我们还专注于与Vulkan相关的代码，以拥有一个可以与负责绘制的队列并行运行的第二个执行队列。我们看到了主命令缓冲区和辅助命令缓冲区之间的区别。
- en: We talked about the importance of the buffer’s allocation strategy to ensure
    safety when recording commands in parallel, especially taking into consideration
    command reuse between frames.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了缓冲区分配策略的重要性，以确保在并行记录命令时的安全性，特别是考虑到帧间命令的重用。
- en: Finally, we showed step by step how to use both types of command buffers, and
    this should be enough to add the desired level of parallelism to any application
    that decides to use Vulkan as its graphics API.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们逐步展示了如何使用两种类型的命令缓冲区，这应该足以向任何决定使用Vulkan作为其图形API的应用程序添加所需的并行级别。
- en: In the next chapter, we will work on a data structure called **Frame Graph**,
    which will give us enough information to automate some of the recording processes,
    including barriers, and will ease the decision making about the granularity of
    the tasks that will perform parallel rendering.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理一个名为**帧图**的数据结构，这将为我们提供足够的信息来自动化一些记录过程，包括屏障，并简化关于执行并行渲染的任务粒度的决策。
- en: Further reading
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Task-based systems have been in use for many years. [https://www.gdcvault.com/play/1012321/Task-based-Multithreading-How-to](https://www.gdcvault.com/play/1012321/Task-based-Multithreading-How-to)
    provides a good overview.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 基于任务的系统已经使用了多年。[https://www.gdcvault.com/play/1012321/Task-based-Multithreading-How-to](https://www.gdcvault.com/play/1012321/Task-based-Multithreading-How-to)
    提供了一个很好的概述。
- en: Many articles can be found that cover work-stealing queues at [https://blog.molecular-matters.com/2015/09/08/job-system-2-0-lock-free-work-stealing-part-2-a-specialized-allocator/](https://blog.molecular-matters.com/2015/09/08/job-system-2-0-lock-free-work-stealing-part-2-a-specialized-allocator/)
    and are a good starting point on the subject.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://blog.molecular-matters.com/2015/09/08/job-system-2-0-lock-free-work-stealing-part-2-a-specialized-allocator/](https://blog.molecular-matters.com/2015/09/08/job-system-2-0-lock-free-work-stealing-part-2-a-specialized-allocator/)
    找到许多关于工作窃取队列的文章，这些文章是该主题的良好起点。
- en: The PlayStation 3 and Xbox 360 use the Cell processor from IBM to provide more
    performance to developers through multiple cores. In particular, the PlayStation
    3 has several **synergistic processor units** (**SPUs**) that developers can use
    to offload work from the main processor.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: PlayStation 3 和 Xbox 360 使用 IBM 的 Cell 处理器，通过多个核心为开发者提供更多性能。特别是 PlayStation
    3 有几个**协同处理器单元**（**SPUs**），开发者可以使用它们从主处理器卸载工作。
- en: There are many presentations and articles that detail many clever ways developers
    have used these processors, for example, [https://www.gdcvault.com/play/1331/The-PlayStation-3-s-SPU](https://www.gdcvault.com/play/1331/The-PlayStation-3-s-SPU)
    and [https://gdcvault.com/play/1014356/Practical-Occlusion-Culling-on](https://gdcvault.com/play/1014356/Practical-Occlusion-Culling-on).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多演示文稿和文章详细介绍了开发者如何巧妙地使用这些处理器，例如，[https://www.gdcvault.com/play/1331/The-PlayStation-3-s-SPU](https://www.gdcvault.com/play/1331/The-PlayStation-3-s-SPU)
    和 [https://gdcvault.com/play/1014356/Practical-Occlusion-Culling-on](https://gdcvault.com/play/1014356/Practical-Occlusion-Culling-on)。
