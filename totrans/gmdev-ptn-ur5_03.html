<html><head></head><body>
<div id="_idContainer068">
<h1 class="chapter-number" id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.2.1">UE5 Patterns in Action – Double Buffer, Flyweight, and Spatial Partitioning</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Hopefully, you will have realized by now that Unreal Engine 5 is a really big engine. </span><span class="koboSpan" id="kobo.3.2">Behind the scenes, it already employs a lot of the patterns that we will cover in later chapters. </span><span class="koboSpan" id="kobo.3.3">This chapter will break down</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.4.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">double buffer</span></strong><span class="koboSpan" id="kobo.6.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">flyweight</span></strong><span class="koboSpan" id="kobo.8.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">spatial partitioning</span></strong><span class="koboSpan" id="kobo.10.1"> patterns. </span><span class="koboSpan" id="kobo.10.2">You don’t need to build these three patterns yourself as </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.11.1">Unreal already has good implementations, but knowledge of </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.12.1">their existence and how they have been created will help you build on top of them. </span><span class="koboSpan" id="kobo.12.2">This chapter will look into how Unreal implements each pattern into a system and what problems they are solving for you in the process. </span><span class="koboSpan" id="kobo.12.3">This should give you a roadmap to not only discover more about the engine but also some examples of good practice to reference </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">moving forward.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">main topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Double buffer</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Flyweight</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Spatial partitioning</span></span></li>
</ul>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, we are going to delve into three patterns that are important to how any commercial engine performs. </span><span class="koboSpan" id="kobo.20.2">There will be some use of </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Big O notation</span></strong><span class="koboSpan" id="kobo.22.1">, which is simply a low-resolution way of measuring the time efficiency </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.23.1">of an algorithm. </span><span class="koboSpan" id="kobo.23.2">The lower the resulting number when replacing the </span><em class="italic"><span class="koboSpan" id="kobo.24.1">n</span></em><span class="koboSpan" id="kobo.25.1"> with a large number, such as 1,000, the better the time efficiency. </span><span class="koboSpan" id="kobo.25.2">For example, an algorithm that compares each element of an array with every other element of the same array could be described as O(</span><em class="italic"><span class="koboSpan" id="kobo.26.1">n</span></em><span class="koboSpan" id="kobo.27.1">2). </span><span class="koboSpan" id="kobo.27.2">This comes from the idea that the algorithm is a couple of nested for loops that run for the length of the input data. </span><span class="koboSpan" id="kobo.27.3">Maybe then we improve efficiency, meaning we don’t need to recheck elements as we go through making the seconds for the loop shorter with each iteration. </span><span class="koboSpan" id="kobo.27.4">This would result in O(</span><em class="italic"><span class="koboSpan" id="kobo.28.1">n</span></em><span class="koboSpan" id="kobo.29.1"> log2</span><em class="italic"><span class="koboSpan" id="kobo.30.1">n</span></em><span class="koboSpan" id="kobo.31.1">). </span><span class="koboSpan" id="kobo.31.2">Looking at these values, you can tell that for large numbers, O(</span><em class="italic"><span class="koboSpan" id="kobo.32.1">n</span></em><span class="koboSpan" id="kobo.33.1">2) is far worse, giving an estimated cost of 1,000,000 executions for an array of size 1,000, whereas the same array put into O(</span><em class="italic"><span class="koboSpan" id="kobo.34.1">n</span></em><span class="koboSpan" id="kobo.35.1"> log2</span><em class="italic"><span class="koboSpan" id="kobo.36.1">n</span></em><span class="koboSpan" id="kobo.37.1"> ) costs only </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">9,965 executions.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Later in the chapter, we will once again make use of some example files. </span><span class="koboSpan" id="kobo.39.2">You can grab these from the </span><a href="B18297_03.xhtml#_idTextAnchor046"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.40.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.41.1"> branch on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">at </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03</span></span></a></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.44.1">Double buffer</span></h1>
<p><span class="koboSpan" id="kobo.45.1">For this</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.46.1"> pattern, we need to imagine a photocopier being operated by an artist. </span><span class="koboSpan" id="kobo.46.2">The artist has been commissioned to deliver at least two copies of every picture they draw, so they think smart and use a photocopier to copy their work. </span><span class="koboSpan" id="kobo.46.3">To save time moving artwork from the easel to the copier, they simply put their canvas straight onto the scanner. </span><span class="koboSpan" id="kobo.46.4">They then paint as fast as they can and hit </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Copy</span></em><span class="koboSpan" id="kobo.48.1"> at the same time. </span><span class="koboSpan" id="kobo.48.2">What follows is a race where the artist needs to paint each line fast enough to stay ahead of the scanning head. </span><span class="koboSpan" id="kobo.48.3">If they are successful, the artwork and the copy will look the same with no extra time taken. </span><span class="koboSpan" id="kobo.48.4">More than likely, the scanning head will get in front of the artist, which will result in a picture up until the point where the artist fell behind and a blank copy after that point. </span><span class="koboSpan" id="kobo.48.5">This is known </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.49.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">frame tearing</span></strong><span class="koboSpan" id="kobo.51.1">, the issue we are trying to solve. </span><span class="koboSpan" id="kobo.51.2">Frame tearing occurs when the frame buffer, our example artist’s canvas, has not been fully updated by the time the read pointer passes over it to draw to the display. </span><span class="koboSpan" id="kobo.51.3">This was a big problem back in the early days of graphics, where you only have 76 clock cycles to load the next row of pixels into the frame buffer before it was dispatched to the display. </span><span class="koboSpan" id="kobo.51.4">This perpetual race with the GPU, which immediately restarts once it finishes, creates a problem for graphics programmers. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.52.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.53.1">.1</span></em><span class="koboSpan" id="kobo.54.1"> shows how the artifacts created due to frame tearing can cause issues for the person viewing </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">the screen:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.56.1"><img alt="Figure 3.1 – Image showing visual artifacts created by screen tearing in two places" src="image/Figure_03.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.57.1">Figure 3.1 – Image showing visual artifacts created by screen tearing in two places</span></p>
<p><span class="koboSpan" id="kobo.58.1">If this issue occurs frequently in a game being played at a standard 60 frames per second, it can cause everything from dissatisfaction with the game </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">to nausea.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.60.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.61.1">.2</span></em><span class="koboSpan" id="kobo.62.1"> shows what </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.63.1">visually happens when the read pointer (red) starts behind the write pointer (green): in the middle column, the write pointer is overtaken by the read pointer, meaning from this point on, none of the work done by the write pointer will make it to the screen as the read pointer will have already read that pixel data. </span><span class="koboSpan" id="kobo.63.2">This will result in the screen looking like the right column, even though all the data was rendered to </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">the buffer:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 3.2 – Diagram showing how race conditions between the read (red) and write (green) pointers cause frame tearing" src="image/Figure_03.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 3.2 – Diagram showing how race conditions between the read (red) and write (green) pointers cause frame tearing</span></p>
<p><span class="koboSpan" id="kobo.67.1">This raises the question: how can we calculate all the shaders required to draw every visible object in this strict </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">time limit?</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">The </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.70.1">answer is to not try to. </span><span class="koboSpan" id="kobo.70.2">Instead of optimizing to beat the current situation, we can change the situation. </span><span class="koboSpan" id="kobo.70.3">Currently, the display is catching the write pointer mid-calculation; instead, we could draw our picture to a different buffer, a back buffer. </span><span class="koboSpan" id="kobo.70.4">This allows the GPU to calculate in peace with no fear that the half-finished image will be shoved in the face of an unsuspecting viewer. </span><span class="koboSpan" id="kobo.70.5">Once the new frame is calculated into the back buffer, a pointer changes to make this new picture the new active frame buffer. </span><span class="koboSpan" id="kobo.70.6">The next time the GPU needs to send data to the screen, we know the image is finished. </span><span class="koboSpan" id="kobo.70.7">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.71.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.72.1">.3</span></em><span class="koboSpan" id="kobo.73.1">, we can see that although the read pointer overtakes the write pointer in the middle column, because it is pulling from a buffer that is complete, no tear is rendered to </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">the screen:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.75.1"><img alt="Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer (middle) while the write pointer works on the back buffer (bottom)" src="image/Figure_03.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.76.1">Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer (middle) while the write pointer works on the back buffer (bottom)</span></p>
<p><span class="koboSpan" id="kobo.77.1">In slow calculations, this means that an</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.78.1"> old image will be displayed on the screen for maybe multiple calls, as the new image can’t be completed in good time, but it is better to have this stutter than a tear across the middle of </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">If the </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.81.1">opposite was true and we well outpaced the display frequency of the attached monitor, then we have a lot of wasted time where the GPU simply waits. </span><span class="koboSpan" id="kobo.81.2">The backup artwork is ready to ship and the main one has not been taken yet. </span><span class="koboSpan" id="kobo.81.3">Most gamers know this as a setting called </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">vertical synchronization</span></strong><span class="koboSpan" id="kobo.83.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.84.1">VSync</span></strong><span class="koboSpan" id="kobo.85.1">). </span><span class="koboSpan" id="kobo.85.2">With VSync off, as soon as the back buffer is</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.86.1"> full, the back and frame buffers are swapped, which can lead to situations where one frame has a sudden drop in performance and there is no back buffer sitting in reserve to fill the visual gap. </span><span class="koboSpan" id="kobo.86.2">This does lead to more responsiveness as the image being shown is technically more recent, but the difference in latency between having the setting on and off is negligible in comparison to the visual issue of a </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">screen tear.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Something we can do to increase our productivity during large VSync wait times is to use more buffers. </span><span class="koboSpan" id="kobo.88.2">This idea of a double buffer extends to infinity. </span><span class="koboSpan" id="kobo.88.3">Triple buffers would be efficient to implement if there is a chance that low refresh rate monitors will be used with high-end graphics cards. </span><span class="koboSpan" id="kobo.88.4">This way, once the first back buffer is full of data, the GPU can turn to another back buffer so as not to remain idle. </span><span class="koboSpan" id="kobo.88.5">When the display call comes through, the newest finished buffer becomes the frame buffer and all others, bar the one that is currently being filled, are wiped and sent to the back of the queue. </span><span class="koboSpan" id="kobo.88.6">This strategy is largely unnecessary with modern hardware, though, which is why Unreal only uses a </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">double-buffered system.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">It is not so easy to find the exact place where this pattern is used within the Unreal Engine source code, as it has a different implementation for each render pipeline. </span><span class="koboSpan" id="kobo.90.2">By default, Unreal launches </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.91.1">with </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">DirectX</span></strong><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">DirectX is a graphics pipeline designed for use on the Windows platform by Microsoft and has built-in methods for creating and managing frame buffers. </span><span class="koboSpan" id="kobo.93.3">DirectX calls the double buffer process the </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">swap chain</span></strong><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">This </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.96.1">particular implementation can be found by navigating to your Unreal Engine 5 install folder and heading to the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">following path:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">UE_5.0 folder&gt;\Engine\Source\Runtime\Windows\D3D11RHI\</span></strong></span></p>
<p><span class="koboSpan" id="kobo.100.1">This folder contains all the DirectX-specific files in the public and private folders. </span><span class="koboSpan" id="kobo.100.2">This includes files such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">D3D11Viewport.cpp</span></strong><span class="koboSpan" id="kobo.102.1">, which contains the editor implementation of a swap chain of buffers. </span><span class="koboSpan" id="kobo.102.2">These files are very dense DirectX code, and so won’t be covered in great detail here, but this is a good starting point to explore how Unreal deals with its </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.103.1">graphics pipeline. </span><span class="koboSpan" id="kobo.103.2">Keep in mind that Unreal Engine also supports </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">Vulkan</span></strong><span class="koboSpan" id="kobo.105.1">, and this has a </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">different implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">At this point, you </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.108.1">may be considering double buffers as a low-level tool. </span><span class="koboSpan" id="kobo.108.2">Primarily, they are, but you can use them for other high-level gameplay situations. </span><span class="koboSpan" id="kobo.108.3">Any time that data gathering and processing has been parallelized to run on multiple threads, a double buffer could be used to make sure processing is being done on cohesive data. </span><span class="koboSpan" id="kobo.108.4">This could take the form of heatmap analytics, keeping track of where players die on a level, or AI gathering data about its surroundings to </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">make decisions.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Let’s move from a system running under your code all the time to an automatic process within the engine that silently boosts your game efficiency: the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">flyweight pattern.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.112.1">Flyweight</span></h1>
<p><span class="koboSpan" id="kobo.113.1">The flyweight pattern</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.114.1"> is focused on reducing memory usage for large collections of objects and reducing the time spent loading them in. </span><span class="koboSpan" id="kobo.114.2">For the flyweight pattern, we first need to consider </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">three things:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.116.1">Intrinsic data</span></strong><span class="koboSpan" id="kobo.117.1"> – The </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.118.1">data values that are immutable and considered to always be true on </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">an object</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.120.1">Extrinsic data</span></strong><span class="koboSpan" id="kobo.121.1"> – The </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.122.1">data values that are mutable and considered to be changeable </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">per instance</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Memory costs</span></strong><span class="koboSpan" id="kobo.125.1"> – All</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.126.1"> data must be stored somewhere and for loaded objects, that means on </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">our RAM</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.128.1">With that in mind, let’s look at trees in the forest. </span><span class="koboSpan" id="kobo.128.2">Taking a simple approach, we could load in and store the model, texture, and transform data once for each tree. </span><span class="koboSpan" id="kobo.128.3">This would make our data storage look like </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.130.1">.4</span></em><span class="koboSpan" id="kobo.131.1">, with each tree connected to its own plot of memory, holding its copy of the data needed </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">for rendering:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.133.1"><img alt="Figure 3.4 – Diagram showing the data associated with each tree" src="image/Figure_03.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.134.1">Figure 3.4 – Diagram showing the data associated with each tree</span></p>
<p><span class="koboSpan" id="kobo.135.1">If we consider the</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.136.1"> memory cost of a </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">model</span></strong><span class="koboSpan" id="kobo.138.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">texture</span></strong><span class="koboSpan" id="kobo.140.1"> combined to be about 5 MB and the transform component to be 12 bytes of data per tree, then our memory footprint for three trees is a little over 15 MB. </span><span class="koboSpan" id="kobo.140.2">This may not seem like much, but it scales badly. </span><span class="koboSpan" id="kobo.140.3">Considering a forest of 100 trees, we would need a little over 500 MB of RAM to hold what is essentially set dressing. </span><span class="koboSpan" id="kobo.140.4">Something must be done, so let’s consider what data in the concept of a tree can be considered intrinsic, and what needs to remain extrinsic to each tree. </span><span class="koboSpan" id="kobo.140.5">As all our trees are identical to look at, all the data for visuals (model and texture data) can probably be safely made intrinsic. </span><span class="koboSpan" id="kobo.140.6">Great, we have a definite set of data that is each type; so what? </span><span class="koboSpan" id="kobo.140.7">Well, the flyweight pattern places all data we consider to be intrinsic in shared memory. </span><span class="koboSpan" id="kobo.140.8">In practice, this looks like </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.141.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.142.1">.5</span></em><span class="koboSpan" id="kobo.143.1">, where all intrinsic visual data that will be shared between all trees has been collected into a shared block and you can spatially visualize the difference in memory cost. </span><span class="koboSpan" id="kobo.143.2">Things like the objects transform still remain extrinsic, as each tree will at least have a different </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">position vector:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.145.1"><img alt="Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory with repeated objects spatially" src="image/Figure_03.05_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.146.1">Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory with repeated objects spatially</span></p>
<p><span class="koboSpan" id="kobo.147.1">In terms of </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.148.1">memory allocation, the implemented flyweight pattern has a fixed cost of 5 MB for the shared model and texture data and a variable cost of 12 bytes per tree. </span><span class="koboSpan" id="kobo.148.2">This means our forest of 100 trees now only takes up 5.1 MB, which is a far cry from the 500 MB we </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">needed previously.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">With the basics down, let’s investigate how our system might break. </span><span class="koboSpan" id="kobo.150.2">Well, we obviously get a benefit from sharing data, but what if we wanted two types of trees in our forest with different model and texture data? </span><span class="koboSpan" id="kobo.150.3">You’d think, based on the previous explanation, that this would make that data extrinsic and therefore not eligible for the flyweight pattern. </span><span class="koboSpan" id="kobo.150.4">However, you can invoke </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.151.1">the type object pattern, which we will discuss in greater detail in a later chapter. </span><span class="koboSpan" id="kobo.151.2">The type object pattern collects intrinsic data about a </span><em class="italic"><span class="koboSpan" id="kobo.152.1">type</span></em><span class="koboSpan" id="kobo.153.1"> and applies the same idea. </span><span class="koboSpan" id="kobo.153.2">This calculation for memory cost would then look like the amount of types you have multiplied by 5 MB, plus 12 bytes per object in the world. </span><span class="koboSpan" id="kobo.153.3">The type object pattern, of course, has some other benefits that we will look at in </span><a href="B18297_09.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.154.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.155.1">, but this is how it pairs with the flyweight pattern to give an expandable, </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">efficient system.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Unreal Engine applies the flyweight pattern by default to every asset loaded into a project. </span><span class="koboSpan" id="kobo.157.2">Assets are then referenced from a single place when needed and their data is shared across all references. </span><span class="koboSpan" id="kobo.157.3">If you need to make a change to a specific loaded version of an asset, you need to actively break the flyweight pattern to do so. </span><span class="koboSpan" id="kobo.157.4">An example of where this may be needed is in dynamic material instances. </span><span class="koboSpan" id="kobo.157.5">Some value may be needed to alter the appearance of only one object in the scene, so a copy of the intrinsic data for the material must </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">be made.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">The last </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.160.1">pattern for this chapter is less automatic and silent than the previous two. </span><span class="koboSpan" id="kobo.160.2">It is a subsystem designed around making</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.161.1"> vast worlds possible and performant to play in. </span><span class="koboSpan" id="kobo.161.2">In Unreal Engine, we call it </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">World Partition</span></strong><span class="koboSpan" id="kobo.163.1"> (based on the toolset available in the editor to manage how a large-scale world is split up), but more generally it is known as the spatial </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">partitioning pattern.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.165.1">Spatial partitioning</span></h1>
<p><span class="koboSpan" id="kobo.166.1">Imagine the Matrix is a real concept, and </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.167.1">we are living in a giant physics simulation. </span><span class="koboSpan" id="kobo.167.2">Anybody who has dabbled in physics simulations knows that you don’t need many interacting objects to make the simulation chug. </span><span class="koboSpan" id="kobo.167.3">The naïve solution is to check every object against every other object leading to an </span><em class="italic"><span class="koboSpan" id="kobo.168.1">O(n</span></em><em class="italic"><span class="koboSpan" id="kobo.169.1">2</span></em><em class="italic"><span class="koboSpan" id="kobo.170.1">-n)</span></em><span class="koboSpan" id="kobo.171.1"> solution, where you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.172.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.173.1">.6</span></em><span class="koboSpan" id="kobo.174.1"> that 4 objects have 12 </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">collision checks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.176.1"><img alt="Figure 3.6 – Diagram showing each collision check performed in an inefficient collision detection solution" src="image/Figure_03.06_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.177.1">Figure 3.6 – Diagram showing each collision check performed in an inefficient collision detection solution</span></p>
<p><span class="koboSpan" id="kobo.178.1">Improvements </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.179.1">can obviously be made to not repeat calculations that have already been made, bringing us down to </span><em class="italic"><span class="koboSpan" id="kobo.180.1">O(nLog2(n))</span></em><span class="koboSpan" id="kobo.181.1"> where those same four points use only six collision checks. </span><span class="koboSpan" id="kobo.181.2">This is better, but there is only so far we can go by checking every object against every other object. </span><span class="koboSpan" id="kobo.181.3">We could just not calculate some of them, but that would be like giving some people in our Matrix simulation wall hacks, allowing them to possibly phase through walls, or worse, </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">We could check the distance between objects before we check their collisions. </span><span class="koboSpan" id="kobo.183.2">This would mean objects far apart would not even try to collide. </span><span class="koboSpan" id="kobo.183.3">This may work for more complex collision geometries but realistically, if we are smart developers using only primitives for collision, we would just be adding to all the calculations. </span><span class="koboSpan" id="kobo.183.4">This would in the worst case lower the efficiency to </span><em class="italic"><span class="koboSpan" id="kobo.184.1">O(nLog2(n) + n)</span></em><span class="koboSpan" id="kobo.185.1">. </span><span class="koboSpan" id="kobo.185.2">The theory has merit, though, so instead of checking every object we should instead group them based on geography. </span><span class="koboSpan" id="kobo.185.3">The world needs to be divided into cells; we’ll call them chunks. </span><span class="koboSpan" id="kobo.185.4">Each cell knows the objects it fully encompasses and its position in the grid of cells. </span><span class="koboSpan" id="kobo.185.5">We need only then to check collisions between objects in neighboring cells. </span><span class="koboSpan" id="kobo.185.6">This is the basis of </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">spatial partitioning.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">What if an object is bigger than the cell it is centered on? </span><span class="koboSpan" id="kobo.187.2">We can group cells together into a bigger chunk and include any objects that cross the cell boundaries that the new cell group fully encompasses. </span><span class="koboSpan" id="kobo.187.3">This process is then repeated until the cell contains the whole world. </span><span class="koboSpan" id="kobo.187.4">This creates a tree structure of cells. </span><span class="koboSpan" id="kobo.187.5">To then check an object’s collision, only objects in the tree directly connected above and below need to be checked. </span><span class="koboSpan" id="kobo.187.6">This has the potential to cut out most checks we would have </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">otherwise done.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">One issue is </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.190.1">how we establish where each object is in the tree. </span><span class="koboSpan" id="kobo.190.2">This does have some overhead cost, meaning for small simulations, it is wild overkill. </span><span class="koboSpan" id="kobo.190.3">That said, if you are going to use this across your entire world and only update the tree positions of moving objects, you end up with massive efficiency gains. </span><span class="koboSpan" id="kobo.190.4">2D implementations might follow a structure </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.191.1">called a </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">quadtree</span></strong><span class="koboSpan" id="kobo.193.1"> (pictured in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.194.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed collision checks (green) to eight for these six objects (red) when they are in these positions" src="image/Figure_03.07_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed collision checks (green) to eight for these six objects (red) when they are in these positions</span></p>
<p><span class="koboSpan" id="kobo.199.1">Here, you can clearly see how objects in different cells (or quads) do not check collision with each other. </span><span class="koboSpan" id="kobo.199.2">As an object crosses a boundary, it starts existing in the cell a layer above and must check collision with all objects in child cells. </span><span class="koboSpan" id="kobo.199.3">Generally, this is not the case, and so with a large number of objects, there will always be a </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">performance improvement.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Unreal Engine 5 uses </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.202.1">the idea of a quadtree in three dimensions called </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.203.1">an </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">octree</span></strong><span class="koboSpan" id="kobo.205.1">. </span><span class="koboSpan" id="kobo.205.2">It is the same principle of dividing space in half along each axis, but because we are dealing with three axes, each cubic area divides into eight cells, hence the name octree. </span><span class="koboSpan" id="kobo.205.3">The octree in Unreal resides in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Fscene</span></strong><span class="koboSpan" id="kobo.207.1"> class and is used by the render thread to determine quickly whether an object exists in the light’s area of effect. </span><span class="koboSpan" id="kobo.207.2">This way, the number of lighting calculations is </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">drastically reduced:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.209.1"><img alt="Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file" src="image/Figure_03.08_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.210.1">Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.211.1">Extra note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.212.1">If you drill down through the struct and class definitions from the line pictured in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.213.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.214.1">.8</span></em><span class="koboSpan" id="kobo.215.1">, you will eventually find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">Toctree2</span></strong><span class="koboSpan" id="kobo.217.1"> class name (the first one has been deprecated). </span><span class="koboSpan" id="kobo.217.2">In this class, you can explore Epic’s implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the octree.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">That is not all. </span><span class="koboSpan" id="kobo.219.2">With Unreal Engine 5 comes the introduction of a system called World Partition. </span><span class="koboSpan" id="kobo.219.3">This is another implementation of a spatial partition, this time in two dimensions, that is used for a different purpose. </span><span class="koboSpan" id="kobo.219.4">As a developer, you must define what size cell Unreal should use, and unlike the tree variants, this is limited to a single layer of depth. </span><span class="koboSpan" id="kobo.219.5">That being said, it does provide a fast way of hooking up large worlds with </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">level of detail</span></strong><span class="koboSpan" id="kobo.221.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.222.1">LOD</span></strong><span class="koboSpan" id="kobo.223.1">) systems</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.224.1"> to affect everything from visuals to collision meshes. </span><span class="koboSpan" id="kobo.224.2">LOD systems are used to reduce how much detail is being rendered (in either a 3D mesh or texture) when the object being rendered appears smaller on the screen. </span><span class="koboSpan" id="kobo.224.3">So, an object further away from the screen will feature an LOD mesh that has a much lower triangle count than if the same object was drawn directly in front of </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the player.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">Let’s take a look at exploring World Partition by looking at an example map we’ve provided that uses an Open World level. </span><span class="koboSpan" id="kobo.226.2">We will begin by looking at how the example works, then change some variables to get different results to better understand how the system works. </span><span class="koboSpan" id="kobo.226.3">The example</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.227.1"> levels used for this section are available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">PatternsInAction</span></strong><span class="koboSpan" id="kobo.229.1"> project on GitHub that is linked at the start of the chapter. </span><span class="koboSpan" id="kobo.229.2">Unlike in </span><a href="B18297_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.230.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.231.1">, this time we have provided a full Unreal Project, and this time, you can extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">.zip</span></strong><span class="koboSpan" id="kobo.233.1"> contents and double-click on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">PatternsInAction.uproject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1"> file.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.236.1">Introducing World Partition</span></h2>
<p><span class="koboSpan" id="kobo.237.1">Firstly, open</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.238.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">WorldPartitionExample</span></strong><span class="koboSpan" id="kobo.240.1"> map file from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Content\Maps</span></strong><span class="koboSpan" id="kobo.242.1"> folder. </span><span class="koboSpan" id="kobo.242.2">This map should open by default when you launch the project but in case it doesn’t, navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">File</span></strong><span class="koboSpan" id="kobo.244.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">Open Level</span></strong><span class="koboSpan" id="kobo.246.1"> and select it from the directories. </span><span class="koboSpan" id="kobo.246.2">You should then see a world with a series of blueprint actors, all of which are displayed as </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">primitive shapes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.248.1"><img alt="Figure 3.9 – World Partition example map from the PatternsinAction project" src="image/Figure_03.09_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">Figure 3.9 – World Partition example map from the PatternsinAction project</span></p>
<p><span class="koboSpan" id="kobo.250.1">This level already has World Partition enabled and set up for the terrain. </span><span class="koboSpan" id="kobo.250.2">This is standard for the Open World </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">level template.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Let’s start by opening the World Partition setting tool so we can see how it works. </span><span class="koboSpan" id="kobo.252.2">If it hasn’t opened by default, go to </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">Window</span></strong><span class="koboSpan" id="kobo.254.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">World Partition</span></strong><span class="koboSpan" id="kobo.256.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">World </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.258.1">Partition Editor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.260.1"><img alt="Figure 3.10 – Accessing the World Partition Editor from the menus" src="image/Figure_03.10_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.261.1">Figure 3.10 – Accessing the World Partition Editor from the menus</span></p>
<p><span class="koboSpan" id="kobo.262.1">This should</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.263.1"> open </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">World Partition Editor</span></strong><span class="koboSpan" id="kobo.265.1"> in the same section of the user interface as the </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">Details</span></strong><span class="koboSpan" id="kobo.267.1"> tab; you can zoom in using your scroll wheel, after which you will eventually be able to see the grid reference system for the map (provided you have turned on </span><strong class="bold"><span class="koboSpan" id="kobo.268.1">Show Cell Coords</span></strong><span class="koboSpan" id="kobo.269.1"> in the top menu of the </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">World Partition</span></strong><span class="koboSpan" id="kobo.271.1"> editor). </span><span class="koboSpan" id="kobo.271.2">It’s worth noting that this grid does not directly relate to the cell grid produced by the World Partition system. </span><span class="koboSpan" id="kobo.271.3">Instead, it offers a grid based on an editor cell size which, by default, is set to 12,800 (128 square meters), half the size of the default World Partition cell, which is 25,600 (256 </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">square meters):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.273.1"><img alt="Figure 3.11 – World Partition editor tab, resized horizontally so the text on the left is visible (left) and then zoomed in with Show Grid Coords ON to show the grid reference system (right)" src="image/Figure_03.11_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 3.11 – World Partition editor tab, resized horizontally so the text on the left is visible (left) and then zoomed in with Show Grid Coords ON to show the grid reference system (right)</span></p>
<p><span class="koboSpan" id="kobo.275.1">World Partition splits (partitions) the world based on a cell grid, with each cell corresponding to a physical section of the level. </span><span class="koboSpan" id="kobo.275.2">If an actor’s bounding box is in that cell, it will be drawn (or hidden) depending on whether the cell is within a set distance of a </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">streaming source</span></strong><span class="koboSpan" id="kobo.277.1"> (an entity in the world that controls when World Partition cells are loaded), such as the </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.278.1">player character or an actor with a World Partition streaming source component. </span><span class="koboSpan" id="kobo.278.2">This allows Unreal to divide the map and only draw the required cells, making it possible for developers to build incredibly </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">large maps.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">To determine the</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.281.1"> distance from a streaming source that a cell must be within to be drawn, the engine uses the </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Loading Range</span></strong><span class="koboSpan" id="kobo.283.1"> variable, which can be found in </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">World Settings</span></strong><span class="koboSpan" id="kobo.285.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">World Partition</span></strong><span class="koboSpan" id="kobo.287.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">Runtime Settings</span></strong><span class="koboSpan" id="kobo.289.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">Grids</span></strong><span class="koboSpan" id="kobo.291.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">Index [0]</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">The value of </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">Loading Range</span></strong><span class="koboSpan" id="kobo.295.1"> sets the radius from the character that a cell needs to be within for it to be loaded and rendered. </span><span class="koboSpan" id="kobo.295.2">The default value for </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">Loading Range</span></strong><span class="koboSpan" id="kobo.297.1"> is 76,800, which is shown in </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">Unreal Units</span></strong><span class="koboSpan" id="kobo.299.1"> (uu). </span><span class="koboSpan" id="kobo.299.2">1 uu = 1 cm, so the default radius is the in-game equivalent of </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">768 m:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.301.1"><img alt="Figure 3.12 – World Partition rollout of the World Settings tab showing the grid settings" src="image/Figure_03.12_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.302.1">Figure 3.12 – World Partition rollout of the World Settings tab showing the grid settings</span></p>
<p><span class="koboSpan" id="kobo.303.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">Index [0]</span></strong><span class="koboSpan" id="kobo.305.1"> section of </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">World Settings</span></strong><span class="koboSpan" id="kobo.307.1"> also contains variables to determine the size of each cell on the grid. </span><span class="koboSpan" id="kobo.307.2">In a built-up city environment, where the visible distance is shortened due to the height of buildings, you could set a smaller </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">Cell Size</span></strong><span class="koboSpan" id="kobo.309.1"> value and </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">Loading Range</span></strong><span class="koboSpan" id="kobo.311.1"> value compared to an open landscape, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">a desert.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">While it may appear</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.314.1"> logical to significantly reduce the cell size and loading range, setting these too low will result in frame rate issues owing to a bottleneck caused by trying to load (and unload) too many cells at </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">one time.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">Now that we’ve had a look at how the cell grid is made up, we can start to look at how that cell grid controls when objects load and unload based on the position of </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">streaming sources.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.318.1">Understanding when objects are loaded</span></h2>
<p><span class="koboSpan" id="kobo.319.1">To get a better understanding of</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.320.1"> how World Partition works, we can change some of the </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Runtime Settings</span></strong><span class="koboSpan" id="kobo.322.1"> values in </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">Index [0]</span></strong><span class="koboSpan" id="kobo.324.1">. </span><span class="koboSpan" id="kobo.324.2">We will make changes to </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">Loading Range</span></strong><span class="koboSpan" id="kobo.326.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">Cell Size</span></strong><span class="koboSpan" id="kobo.328.1"> to control the way World Partition works within our example map. </span><span class="koboSpan" id="kobo.328.2">The changes we make will adjust when the blueprints in the map are loaded and unloaded. </span><span class="koboSpan" id="kobo.328.3">Observing the differences will help you to experience World Partition (and spatial partitioning) </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">in action.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">Before we make any changes, press the </span><em class="italic"><span class="koboSpan" id="kobo.331.1">Play</span></em><span class="koboSpan" id="kobo.332.1"> button to play the level in the editor viewport. </span><span class="koboSpan" id="kobo.332.2">You should notice a stream of print strings on the left side of the screen. </span><span class="koboSpan" id="kobo.332.3">This is because each of the blueprint actors have been set up to print a short message and their </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">display name.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Move around the map using typical first-person </span><em class="italic"><span class="koboSpan" id="kobo.335.1">W</span></em><span class="koboSpan" id="kobo.336.1">, </span><em class="italic"><span class="koboSpan" id="kobo.337.1">A</span></em><span class="koboSpan" id="kobo.338.1">, </span><em class="italic"><span class="koboSpan" id="kobo.339.1">S</span></em><span class="koboSpan" id="kobo.340.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.341.1">D</span></em><span class="koboSpan" id="kobo.342.1"> keys to control the character. </span><span class="koboSpan" id="kobo.342.2">You should notice that, if you move all the way to one side of the map, prints change as fewer objects are printing </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">their messages.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">Once you’ve seen this effect, try changing </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">Loading Range</span></strong><span class="koboSpan" id="kobo.346.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">76800</span></strong><span class="koboSpan" id="kobo.348.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">768</span></strong><span class="koboSpan" id="kobo.350.1">, making the radius that objects need to be within to load 100 times smaller than the default settings. </span><span class="koboSpan" id="kobo.350.2">This will cause a significantly different result. </span><span class="koboSpan" id="kobo.350.3">Now, try testing the level once again. </span><span class="koboSpan" id="kobo.350.4">You should notice that only two objects are visible: a tall rectangular box and a cone, both of which are in front of the character from the starting position. </span><span class="koboSpan" id="kobo.350.5">These are visible because a small section of each mesh is inside a partition cell that is within a 7.68 m radius of the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">player character.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Walking toward either object will eventually cause other objects to suddenly appear (you will need to get very close) as you get within range of the neighboring </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">partition cells.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">To further understand why we get this behavior, let’s change the </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">World Partition Editor Cell </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.356.1">Size</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1"> variable:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.358.1">Below the </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">Runtime Settings</span></strong><span class="koboSpan" id="kobo.360.1"> section we’ve used so far, expand the </span><strong class="bold"><span class="koboSpan" id="kobo.361.1">Advanced</span></strong><span class="koboSpan" id="kobo.362.1"> section by clicking the title or the arrow to </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the side.</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">World Partition Editor Cell Size</span></strong><span class="koboSpan" id="kobo.366.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">25600</span></strong><span class="koboSpan" id="kobo.368.1"> to match the </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">Cell Size</span></strong><span class="koboSpan" id="kobo.370.1"> value from the </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">Index [0]</span></strong><span class="koboSpan" id="kobo.372.1"> settings, ensuring our editor display matches the behavior we are experiencing when we play </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">the level.</span></span></li>
<li><span class="koboSpan" id="kobo.374.1">Once you have made the change, rebuild the Minimap by navigating to </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">Build</span></strong><span class="koboSpan" id="kobo.376.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">Build Minimap</span></strong><span class="koboSpan" id="kobo.378.1"> from the top menu. </span><span class="koboSpan" id="kobo.378.2">You will be asked to save the level and any modified assets, and then you will be shown a series of progress bars while the build </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">takes place.</span></span></li>
<li><span class="koboSpan" id="kobo.380.1">Switch back to the </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">World Partition</span></strong><span class="koboSpan" id="kobo.382.1"> editor tab; you should now see a lot fewer cells in the grid, as </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.383.1">shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.384.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.385.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.387.1"><img alt="Figure 3.13 – Updated editor cell display showing how the visible objects are partially inside the initially loaded cells (-1,0) and (0,0)" src="image/Figure_03.13_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.388.1">Figure 3.13 – Updated editor cell display showing how the visible objects are partially inside the initially loaded cells (-1,0) and (0,0)</span></p>
<p><span class="koboSpan" id="kobo.389.1">The grid should now show where each of the actors is positioned, with at least one of each of the object types (cone and cube) in a grid cell that the character starts within (or very close to). </span><span class="koboSpan" id="kobo.389.2">The second object of each pair sits in the neighboring grid cell, so will only appear once the player</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.390.1"> character is within 7.68 m of the cell, which is a very short distance when you consider each cell is 256 m x 256 m and the default loading range that we changed was originally a radius of 768 m. </span><span class="koboSpan" id="kobo.390.2">Based on the default values, when the character stands at the starting location at the origin of the grid, 36 of the cells are being loaded as opposed to the 4 that are loaded with the shortened range of 7.68 m, which would be inappropriate for use in a game but works as an extreme example of how the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">system works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.392.1"><img alt="Figure 3.14 – Visual representation of the overlapping area of a 768 m radius circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared to a radius of 7.68 m (inner circle) only overlapping 4" src="image/Figure_03.14_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.393.1">Figure 3.14 – Visual representation of the overlapping area of a 768 m radius circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared to a radius of 7.68 m (inner circle) only overlapping 4</span></p>
<p><span class="koboSpan" id="kobo.394.1">Now that we’ve set an extreme value, try some different values, such as setting </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">Loading Range</span></strong><span class="koboSpan" id="kobo.396.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">38400</span></strong><span class="koboSpan" id="kobo.398.1">, which will result in more objects being loaded at any one point. </span><span class="koboSpan" id="kobo.398.2">Standing at the center of the map will load a similar number of visible objects to the default setting, but you will see the objects disappear much sooner as you walk away from them. </span><span class="koboSpan" id="kobo.398.3">Remember, you can always return to the default value </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">76800</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">This shows how, with</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.403.1"> different loading ranges, we can control when parts of our 3D world appear. </span><span class="koboSpan" id="kobo.403.2">Getting the correct values for your game might require some testing and, in some cases, the inclusion of scalability settings to ensure your game runs on different hardware. </span><span class="koboSpan" id="kobo.403.3">For now, the key thing is understanding how to control when things load and unload based on streaming sources so that once you have a 3D world to control, you can make the most of </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">World Partition.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.405.1">Ensuring actors are loaded when required</span></h2>
<p><span class="koboSpan" id="kobo.406.1">There are two ways to ensure</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.407.1"> that actors are loaded and ready for the player. </span><span class="koboSpan" id="kobo.407.2">One option is to force an actor to always be loaded by preventing it from being loaded and unloaded by World Partition. </span><span class="koboSpan" id="kobo.407.3">This could be useful if you have managers in the world who are required to control aspects across the entire level, or if you have a monument that needs to be always visible. </span><span class="koboSpan" id="kobo.407.4">To do this, do </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.409.1">Select the chosen actor in </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">the level.</span></span></li>
<li><span class="koboSpan" id="kobo.411.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">Details</span></strong><span class="koboSpan" id="kobo.413.1"> panel, scroll down to the </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">World </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.415.1">Partition</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1"> section:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.417.1"><img alt="Figure 3.15 – World Partition settings in the Details panel with an actor selected" src="image/Figure_03.15_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.418.1">Figure 3.15 – World Partition settings in the Details panel with an actor selected</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.419.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Is Spatially Loaded</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.421.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">OFF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.424.1">The second </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.425.1">approach is to include actors in the world that have a World Partition streaming </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">source component.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">We’ve included a </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">BP_StreamingSourceActor</span></strong><span class="koboSpan" id="kobo.429.1"> blueprint, which has a World Partition streaming source component set up with the target grid already set up. </span><span class="koboSpan" id="kobo.429.2">To see it in action, do </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.431.1">Drag a </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">BP_StreamingSourceActor</span></strong><span class="koboSpan" id="kobo.433.1"> blueprint from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">Content Browser/Blueprints</span></strong><span class="koboSpan" id="kobo.435.1"> folder into the world between the two </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">cone actors.</span></span></li>
<li><span class="koboSpan" id="kobo.437.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">Loading Range</span></strong><span class="koboSpan" id="kobo.439.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">World Settings</span></strong><span class="koboSpan" id="kobo.441.1"> back to a small value such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">768</span></strong><span class="koboSpan" id="kobo.443.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">testing purposes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.445.1">When testing the level, you should now see that, unlike when we first set the loading range to </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">768</span></strong><span class="koboSpan" id="kobo.447.1">, both cone objects </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">are visible.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">You will, however, notice that after five seconds of gameplay, one of the cones (the furthest one from the player) will disappear. </span><span class="koboSpan" id="kobo.449.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">BP_StreamingSourceActor</span></strong><span class="koboSpan" id="kobo.451.1"> blueprint includes some crude code to toggle the streaming source on and off. </span><span class="koboSpan" id="kobo.451.2">This provides a nice insight into how a streaming source actor can be used to control loading cells ready for the player, in cases such as where the character will be teleported to a new location that needs to be fully loaded before the player </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">is relocated.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.454.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.455.1">.16</span></em><span class="koboSpan" id="kobo.456.1"> you </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.457.1">can see the logic within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">BP_StreamingSourceActor</span></strong><span class="koboSpan" id="kobo.459.1">’s </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">event graph.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.461.1"><img alt="Figure 3.16 – Crude blueprint setup that disables and enables the streaming source every five seconds using a timer" src="image/Figure_03.16_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.462.1">Figure 3.16 – Crude blueprint setup that disables and enables the streaming source every five seconds using a timer</span></p>
<p><span class="koboSpan" id="kobo.463.1">Now that we’ve explored World Partition, we will look at using it with levels that have been created </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">without it.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.465.1">Enabling World Partition on an existing level</span></h2>
<p><span class="koboSpan" id="kobo.466.1">To convert an</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.467.1"> existing level (that wasn’t created using the Open World starter map) to make use of World Partition, all you need to do is use the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">built-in tool:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.469.1">Ensure the level you want to convert to a World Partition-enabled level </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">is saved.</span></span></li>
<li><span class="koboSpan" id="kobo.471.1">Navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">Tools</span></strong><span class="koboSpan" id="kobo.473.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">Convert Level</span></strong><span class="koboSpan" id="kobo.475.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">top menu.</span></span></li>
<li><span class="koboSpan" id="kobo.477.1">From the popup, select the map you would like </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">to convert.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.479.1">Click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.480.1">OK</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.482.1">The tool will create a new version of the map with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">_WP</span></strong><span class="koboSpan" id="kobo.484.1"> suffix in the name unless you select </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">In Place</span></strong><span class="koboSpan" id="kobo.486.1"> from the final settings dialog, which will simply overwrite your </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">existing level.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.488.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.489.1">In this chapter, we have discussed a number of existing patterns that are present in Unreal Engine, focusing on double buffer, flyweight, and </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">spatial partitioning.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">We have taken a look at some of these systems, including exploring editor examples of spatial partitioning using the World Partition system, experimenting with different variables to control when objects are loaded and unloaded, and testing an actor with a World Partition streaming </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">source component.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">In the next chapter, we are going to explore some pre-made patterns in Unreal. </span><span class="koboSpan" id="kobo.493.2">We will be looking at creating components using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">update</span></strong><span class="koboSpan" id="kobo.495.1"> method, and creating a simple AI-controlled </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">Real-Time Strategy</span></strong><span class="koboSpan" id="kobo.497.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.498.1">RTS</span></strong><span class="koboSpan" id="kobo.499.1">) game unit using Unreal’s AI </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.500.1">Behavior Trees</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">.</span></span></p>
</div>
</body></html>