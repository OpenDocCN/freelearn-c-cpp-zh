<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-46"><a id="_idTextAnchor046"/>3</h1>
<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>UE5 Patterns in Action – Double Buffer, Flyweight, and Spatial Partitioning</h1>
<p>Hopefully, you will have realized by now that Unreal Engine 5 is a really big engine. Behind the scenes, it already employs a lot of the patterns that we will cover in later chapters. This chapter will break down<a id="_idIndexMarker088"/> the <strong class="bold">double buffer</strong>, <strong class="bold">flyweight</strong>, and <strong class="bold">spatial partitioning</strong> patterns. You don’t need to build these three patterns yourself as <a id="_idIndexMarker089"/>Unreal already has good implementations, but knowledge of <a id="_idIndexMarker090"/>their existence and how they have been created will help you build on top of them. This chapter will look into how Unreal implements each pattern into a system and what problems they are solving for you in the process. This should give you a roadmap to not only discover more about the engine but also some examples of good practice to reference moving forward.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Double buffer</li>
<li>Flyweight</li>
<li>Spatial partitioning</li>
</ul>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Technical requirements</h1>
<p>In this chapter, we are going to delve into three patterns that are important to how any commercial engine performs. There will be some use of <strong class="bold">Big O notation</strong>, which is simply a low-resolution way of measuring the time efficiency <a id="_idIndexMarker091"/>of an algorithm. The lower the resulting number when replacing the <em class="italic">n</em> with a large number, such as 1,000, the better the time efficiency. For example, an algorithm that compares each element of an array with every other element of the same array could be described as O(<em class="italic">n</em>2). This comes from the idea that the algorithm is a couple of nested for loops that run for the length of the input data. Maybe then we improve efficiency, meaning we don’t need to recheck elements as we go through making the seconds for the loop shorter with each iteration. This would result in O(<em class="italic">n</em> log2<em class="italic">n</em>). Looking at these values, you can tell that for large numbers, O(<em class="italic">n</em>2) is far worse, giving an estimated cost of 1,000,000 executions for an array of size 1,000, whereas the same array put into O(<em class="italic">n</em> log2<em class="italic">n</em> ) costs only 9,965 executions.</p>
<p>Later in the chapter, we will once again make use of some example files. You can grab these from the <a href="B18297_03.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a> branch on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03</a></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Double buffer</h1>
<p>For this<a id="_idIndexMarker092"/> pattern, we need to imagine a photocopier being operated by an artist. The artist has been commissioned to deliver at least two copies of every picture they draw, so they think smart and use a photocopier to copy their work. To save time moving artwork from the easel to the copier, they simply put their canvas straight onto the scanner. They then paint as fast as they can and hit <em class="italic">Copy</em> at the same time. What follows is a race where the artist needs to paint each line fast enough to stay ahead of the scanning head. If they are successful, the artwork and the copy will look the same with no extra time taken. More than likely, the scanning head will get in front of the artist, which will result in a picture up until the point where the artist fell behind and a blank copy after that point. This is known <a id="_idIndexMarker093"/>as <strong class="bold">frame tearing</strong>, the issue we are trying to solve. Frame tearing occurs when the frame buffer, our example artist’s canvas, has not been fully updated by the time the read pointer passes over it to draw to the display. This was a big problem back in the early days of graphics, where you only have 76 clock cycles to load the next row of pixels into the frame buffer before it was dispatched to the display. This perpetual race with the GPU, which immediately restarts once it finishes, creates a problem for graphics programmers. <em class="italic">Figure 3</em><em class="italic">.1</em> shows how the artifacts created due to frame tearing can cause issues for the person viewing the screen:</p>
<div><div><img alt="Figure 3.1 – Image showing visual artifacts created by screen tearing in two places" src="img/Figure_03.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Image showing visual artifacts created by screen tearing in two places</p>
<p>If this issue occurs frequently in a game being played at a standard 60 frames per second, it can cause everything from dissatisfaction with the game to nausea.</p>
<p><em class="italic">Figure 3</em><em class="italic">.2</em> shows what <a id="_idIndexMarker094"/>visually happens when the read pointer (red) starts behind the write pointer (green): in the middle column, the write pointer is overtaken by the read pointer, meaning from this point on, none of the work done by the write pointer will make it to the screen as the read pointer will have already read that pixel data. This will result in the screen looking like the right column, even though all the data was rendered to the buffer:</p>
<div><div><img alt="Figure 3.2 – Diagram showing how race conditions between the read (red) and write (green) pointers cause frame tearing" src="img/Figure_03.02_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Diagram showing how race conditions between the read (red) and write (green) pointers cause frame tearing</p>
<p>This raises the question: how can we calculate all the shaders required to draw every visible object in this strict time limit?</p>
<p>The <a id="_idIndexMarker095"/>answer is to not try to. Instead of optimizing to beat the current situation, we can change the situation. Currently, the display is catching the write pointer mid-calculation; instead, we could draw our picture to a different buffer, a back buffer. This allows the GPU to calculate in peace with no fear that the half-finished image will be shoved in the face of an unsuspecting viewer. Once the new frame is calculated into the back buffer, a pointer changes to make this new picture the new active frame buffer. The next time the GPU needs to send data to the screen, we know the image is finished. In <em class="italic">Figure 3</em><em class="italic">.3</em>, we can see that although the read pointer overtakes the write pointer in the middle column, because it is pulling from a buffer that is complete, no tear is rendered to the screen:</p>
<div><div><img alt="Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer (middle) while the write pointer works on the back buffer (bottom)" src="img/Figure_03.03_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer (middle) while the write pointer works on the back buffer (bottom)</p>
<p>In slow calculations, this means that an<a id="_idIndexMarker096"/> old image will be displayed on the screen for maybe multiple calls, as the new image can’t be completed in good time, but it is better to have this stutter than a tear across the middle of the screen.</p>
<p>If the <a id="_idIndexMarker097"/>opposite was true and we well outpaced the display frequency of the attached monitor, then we have a lot of wasted time where the GPU simply waits. The backup artwork is ready to ship and the main one has not been taken yet. Most gamers know this as a setting called <strong class="bold">vertical synchronization</strong> (<strong class="bold">VSync</strong>). With VSync off, as soon as the back buffer is<a id="_idIndexMarker098"/> full, the back and frame buffers are swapped, which can lead to situations where one frame has a sudden drop in performance and there is no back buffer sitting in reserve to fill the visual gap. This does lead to more responsiveness as the image being shown is technically more recent, but the difference in latency between having the setting on and off is negligible in comparison to the visual issue of a screen tear.</p>
<p>Something we can do to increase our productivity during large VSync wait times is to use more buffers. This idea of a double buffer extends to infinity. Triple buffers would be efficient to implement if there is a chance that low refresh rate monitors will be used with high-end graphics cards. This way, once the first back buffer is full of data, the GPU can turn to another back buffer so as not to remain idle. When the display call comes through, the newest finished buffer becomes the frame buffer and all others, bar the one that is currently being filled, are wiped and sent to the back of the queue. This strategy is largely unnecessary with modern hardware, though, which is why Unreal only uses a double-buffered system.</p>
<p>It is not so easy to find the exact place where this pattern is used within the Unreal Engine source code, as it has a different implementation for each render pipeline. By default, Unreal launches <a id="_idIndexMarker099"/>with <strong class="bold">DirectX</strong>. DirectX is a graphics pipeline designed for use on the Windows platform by Microsoft and has built-in methods for creating and managing frame buffers. DirectX calls the double buffer process the <strong class="bold">swap chain</strong>. This <a id="_idIndexMarker100"/>particular implementation can be found by navigating to your Unreal Engine 5 install folder and heading to the following path:</p>
<p><code>&lt;</code><code>UE_5.0 folder&gt;\Engine\Source\Runtime\Windows\D3D11RHI\</code></p>
<p>This folder contains all the DirectX-specific files in the public and private folders. This includes files such as <code>D3D11Viewport.cpp</code>, which contains the editor implementation of a swap chain of buffers. These files are very dense DirectX code, and so won’t be covered in great detail here, but this is a good starting point to explore how Unreal deals with its <a id="_idIndexMarker101"/>graphics pipeline. Keep in mind that Unreal Engine also supports <strong class="bold">Vulkan</strong>, and this has a different implementation.</p>
<p>At this point, you <a id="_idIndexMarker102"/>may be considering double buffers as a low-level tool. Primarily, they are, but you can use them for other high-level gameplay situations. Any time that data gathering and processing has been parallelized to run on multiple threads, a double buffer could be used to make sure processing is being done on cohesive data. This could take the form of heatmap analytics, keeping track of where players die on a level, or AI gathering data about its surroundings to make decisions.</p>
<p>Let’s move from a system running under your code all the time to an automatic process within the engine that silently boosts your game efficiency: the flyweight pattern.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Flyweight</h1>
<p>The flyweight pattern<a id="_idIndexMarker103"/> is focused on reducing memory usage for large collections of objects and reducing the time spent loading them in. For the flyweight pattern, we first need to consider three things:</p>
<ul>
<li><strong class="bold">Intrinsic data</strong> – The <a id="_idIndexMarker104"/>data values that are immutable and considered to always be true on an object</li>
<li><strong class="bold">Extrinsic data</strong> – The <a id="_idIndexMarker105"/>data values that are mutable and considered to be changeable per instance</li>
<li><strong class="bold">Memory costs</strong> – All<a id="_idIndexMarker106"/> data must be stored somewhere and for loaded objects, that means on our RAM</li>
</ul>
<p>With that in mind, let’s look at trees in the forest. Taking a simple approach, we could load in and store the model, texture, and transform data once for each tree. This would make our data storage look like <em class="italic">Figure 3</em><em class="italic">.4</em>, with each tree connected to its own plot of memory, holding its copy of the data needed for rendering:</p>
<div><div><img alt="Figure 3.4 – Diagram showing the data associated with each tree" src="img/Figure_03.04_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Diagram showing the data associated with each tree</p>
<p>If we consider the<a id="_idIndexMarker107"/> memory cost of a <strong class="bold">model</strong> and <strong class="bold">texture</strong> combined to be about 5 MB and the transform component to be 12 bytes of data per tree, then our memory footprint for three trees is a little over 15 MB. This may not seem like much, but it scales badly. Considering a forest of 100 trees, we would need a little over 500 MB of RAM to hold what is essentially set dressing. Something must be done, so let’s consider what data in the concept of a tree can be considered intrinsic, and what needs to remain extrinsic to each tree. As all our trees are identical to look at, all the data for visuals (model and texture data) can probably be safely made intrinsic. Great, we have a definite set of data that is each type; so what? Well, the flyweight pattern places all data we consider to be intrinsic in shared memory. In practice, this looks like <em class="italic">Figure 3</em><em class="italic">.5</em>, where all intrinsic visual data that will be shared between all trees has been collected into a shared block and you can spatially visualize the difference in memory cost. Things like the objects transform still remain extrinsic, as each tree will at least have a different position vector:</p>
<div><div><img alt="Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory with repeated objects spatially" src="img/Figure_03.05_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory with repeated objects spatially</p>
<p>In terms of <a id="_idIndexMarker108"/>memory allocation, the implemented flyweight pattern has a fixed cost of 5 MB for the shared model and texture data and a variable cost of 12 bytes per tree. This means our forest of 100 trees now only takes up 5.1 MB, which is a far cry from the 500 MB we needed previously.</p>
<p>With the basics down, let’s investigate how our system might break. Well, we obviously get a benefit from sharing data, but what if we wanted two types of trees in our forest with different model and texture data? You’d think, based on the previous explanation, that this would make that data extrinsic and therefore not eligible for the flyweight pattern. However, you can invoke <a id="_idIndexMarker109"/>the type object pattern, which we will discuss in greater detail in a later chapter. The type object pattern collects intrinsic data about a <em class="italic">type</em> and applies the same idea. This calculation for memory cost would then look like the amount of types you have multiplied by 5 MB, plus 12 bytes per object in the world. The type object pattern, of course, has some other benefits that we will look at in <a href="B18297_09.xhtml#_idTextAnchor130"><em class="italic">Chapter 9</em></a>, but this is how it pairs with the flyweight pattern to give an expandable, efficient system.</p>
<p>Unreal Engine applies the flyweight pattern by default to every asset loaded into a project. Assets are then referenced from a single place when needed and their data is shared across all references. If you need to make a change to a specific loaded version of an asset, you need to actively break the flyweight pattern to do so. An example of where this may be needed is in dynamic material instances. Some value may be needed to alter the appearance of only one object in the scene, so a copy of the intrinsic data for the material must be made.</p>
<p>The last <a id="_idIndexMarker110"/>pattern for this chapter is less automatic and silent than the previous two. It is a subsystem designed around making<a id="_idIndexMarker111"/> vast worlds possible and performant to play in. In Unreal Engine, we call it <strong class="bold">World Partition</strong> (based on the toolset available in the editor to manage how a large-scale world is split up), but more generally it is known as the spatial partitioning pattern.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Spatial partitioning</h1>
<p>Imagine the Matrix is a real concept, and <a id="_idIndexMarker112"/>we are living in a giant physics simulation. Anybody who has dabbled in physics simulations knows that you don’t need many interacting objects to make the simulation chug. The naïve solution is to check every object against every other object leading to an <em class="italic">O(n</em><em class="italic">2</em><em class="italic">-n)</em> solution, where you can see in <em class="italic">Figure 3</em><em class="italic">.6</em> that 4 objects have 12 collision checks:</p>
<div><div><img alt="Figure 3.6 – Diagram showing each collision check performed in an inefficient collision detection solution" src="img/Figure_03.06_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Diagram showing each collision check performed in an inefficient collision detection solution</p>
<p>Improvements <a id="_idIndexMarker113"/>can obviously be made to not repeat calculations that have already been made, bringing us down to <em class="italic">O(nLog2(n))</em> where those same four points use only six collision checks. This is better, but there is only so far we can go by checking every object against every other object. We could just not calculate some of them, but that would be like giving some people in our Matrix simulation wall hacks, allowing them to possibly phase through walls, or worse, each other.</p>
<p>We could check the distance between objects before we check their collisions. This would mean objects far apart would not even try to collide. This may work for more complex collision geometries but realistically, if we are smart developers using only primitives for collision, we would just be adding to all the calculations. This would in the worst case lower the efficiency to <em class="italic">O(nLog2(n) + n)</em>. The theory has merit, though, so instead of checking every object we should instead group them based on geography. The world needs to be divided into cells; we’ll call them chunks. Each cell knows the objects it fully encompasses and its position in the grid of cells. We need only then to check collisions between objects in neighboring cells. This is the basis of spatial partitioning.</p>
<p>What if an object is bigger than the cell it is centered on? We can group cells together into a bigger chunk and include any objects that cross the cell boundaries that the new cell group fully encompasses. This process is then repeated until the cell contains the whole world. This creates a tree structure of cells. To then check an object’s collision, only objects in the tree directly connected above and below need to be checked. This has the potential to cut out most checks we would have otherwise done.</p>
<p>One issue is <a id="_idIndexMarker114"/>how we establish where each object is in the tree. This does have some overhead cost, meaning for small simulations, it is wild overkill. That said, if you are going to use this across your entire world and only update the tree positions of moving objects, you end up with massive efficiency gains. 2D implementations might follow a structure <a id="_idIndexMarker115"/>called a <strong class="bold">quadtree</strong> (pictured in <em class="italic">Figure 3</em><em class="italic">.7</em>):</p>
<div><div><img alt="Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed collision checks (green) to eight for these six objects (red) when they are in these positions" src="img/Figure_03.07_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed collision checks (green) to eight for these six objects (red) when they are in these positions</p>
<p>Here, you can clearly see how objects in different cells (or quads) do not check collision with each other. As an object crosses a boundary, it starts existing in the cell a layer above and must check collision with all objects in child cells. Generally, this is not the case, and so with a large number of objects, there will always be a performance improvement.</p>
<p>Unreal Engine 5 uses <a id="_idIndexMarker116"/>the idea of a quadtree in three dimensions called <a id="_idIndexMarker117"/>an <code>Fscene</code> class and is used by the render thread to determine quickly whether an object exists in the light’s area of effect. This way, the number of lighting calculations is drastically reduced:</p>
<div><div><img alt="Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file" src="img/Figure_03.08_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file</p>
<p class="callout-heading">Extra note</p>
<p class="callout">If you drill down through the struct and class definitions from the line pictured in <em class="italic">Figure 3</em><em class="italic">.8</em>, you will eventually find a <code>Toctree2</code> class name (the first one has been deprecated). In this class, you can explore Epic’s implementation of the octree.</p>
<p>That is not all. With Unreal Engine 5 comes the introduction of a system called World Partition. This is another implementation of a spatial partition, this time in two dimensions, that is used for a different purpose. As a developer, you must define what size cell Unreal should use, and unlike the tree variants, this is limited to a single layer of depth. That being said, it does provide a fast way of hooking up large worlds with <strong class="bold">level of detail</strong> (<strong class="bold">LOD</strong>) systems<a id="_idIndexMarker118"/> to affect everything from visuals to collision meshes. LOD systems are used to reduce how much detail is being rendered (in either a 3D mesh or texture) when the object being rendered appears smaller on the screen. So, an object further away from the screen will feature an LOD mesh that has a much lower triangle count than if the same object was drawn directly in front of the player.</p>
<p>Let’s take a look at exploring World Partition by looking at an example map we’ve provided that uses an Open World level. We will begin by looking at how the example works, then change some variables to get different results to better understand how the system works. The example<a id="_idIndexMarker119"/> levels used for this section are available in the <code>PatternsInAction</code> project on GitHub that is linked at the start of the chapter. Unlike in <a href="B18297_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, this time we have provided a full Unreal Project, and this time, you can extract the <code>.zip</code> contents and double-click on the <code>PatternsInAction.uproject</code> file.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>Introducing World Partition</h2>
<p>Firstly, open<a id="_idIndexMarker120"/> the <code>WorldPartitionExample</code> map file from the <code>Content\Maps</code> folder. This map should open by default when you launch the project but in case it doesn’t, navigate to <strong class="bold">File</strong> | <strong class="bold">Open Level</strong> and select it from the directories. You should then see a world with a series of blueprint actors, all of which are displayed as primitive shapes:</p>
<div><div><img alt="Figure 3.9 – World Partition example map from the PatternsinAction project" src="img/Figure_03.09_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – World Partition example map from the PatternsinAction project</p>
<p>This level already has World Partition enabled and set up for the terrain. This is standard for the Open World level template.</p>
<p>Let’s start by opening the World Partition setting tool so we can see how it works. If it hasn’t opened by default, go to <strong class="bold">Window</strong> | <strong class="bold">World Partition</strong> | <strong class="bold">World </strong><strong class="bold">Partition Editor</strong>:</p>
<div><div><img alt="Figure 3.10 – Accessing the World Partition Editor from the menus" src="img/Figure_03.10_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Accessing the World Partition Editor from the menus</p>
<p>This should<a id="_idIndexMarker121"/> open <strong class="bold">World Partition Editor</strong> in the same section of the user interface as the <strong class="bold">Details</strong> tab; you can zoom in using your scroll wheel, after which you will eventually be able to see the grid reference system for the map (provided you have turned on <strong class="bold">Show Cell Coords</strong> in the top menu of the <strong class="bold">World Partition</strong> editor). It’s worth noting that this grid does not directly relate to the cell grid produced by the World Partition system. Instead, it offers a grid based on an editor cell size which, by default, is set to 12,800 (128 square meters), half the size of the default World Partition cell, which is 25,600 (256 square meters):</p>
<div><div><img alt="Figure 3.11 – World Partition editor tab, resized horizontally so the text on the left is visible (left) and then zoomed in with Show Grid Coords ON to show the grid reference system (right)" src="img/Figure_03.11_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – World Partition editor tab, resized horizontally so the text on the left is visible (left) and then zoomed in with Show Grid Coords ON to show the grid reference system (right)</p>
<p>World Partition splits (partitions) the world based on a cell grid, with each cell corresponding to a physical section of the level. If an actor’s bounding box is in that cell, it will be drawn (or hidden) depending on whether the cell is within a set distance of a <strong class="bold">streaming source</strong> (an entity in the world that controls when World Partition cells are loaded), such as the <a id="_idIndexMarker122"/>player character or an actor with a World Partition streaming source component. This allows Unreal to divide the map and only draw the required cells, making it possible for developers to build incredibly large maps.</p>
<p>To determine the<a id="_idIndexMarker123"/> distance from a streaming source that a cell must be within to be drawn, the engine uses the <strong class="bold">Loading Range</strong> variable, which can be found in <strong class="bold">World Settings</strong> | <strong class="bold">World Partition</strong> | <strong class="bold">Runtime Settings</strong> | <strong class="bold">Grids</strong> | <strong class="bold">Index [0]</strong>. The value of <strong class="bold">Loading Range</strong> sets the radius from the character that a cell needs to be within for it to be loaded and rendered. The default value for <strong class="bold">Loading Range</strong> is 76,800, which is shown in <strong class="bold">Unreal Units</strong> (uu). 1 uu = 1 cm, so the default radius is the in-game equivalent of 768 m:</p>
<div><div><img alt="Figure 3.12 – World Partition rollout of the World Settings tab showing the grid settings" src="img/Figure_03.12_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – World Partition rollout of the World Settings tab showing the grid settings</p>
<p>The <strong class="bold">Index [0]</strong> section of <strong class="bold">World Settings</strong> also contains variables to determine the size of each cell on the grid. In a built-up city environment, where the visible distance is shortened due to the height of buildings, you could set a smaller <strong class="bold">Cell Size</strong> value and <strong class="bold">Loading Range</strong> value compared to an open landscape, such as a desert.</p>
<p>While it may appear<a id="_idIndexMarker124"/> logical to significantly reduce the cell size and loading range, setting these too low will result in frame rate issues owing to a bottleneck caused by trying to load (and unload) too many cells at one time.</p>
<p>Now that we’ve had a look at how the cell grid is made up, we can start to look at how that cell grid controls when objects load and unload based on the position of streaming sources.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Understanding when objects are loaded</h2>
<p>To get a better understanding of<a id="_idIndexMarker125"/> how World Partition works, we can change some of the <strong class="bold">Runtime Settings</strong> values in <strong class="bold">Index [0]</strong>. We will make changes to <strong class="bold">Loading Range</strong> and <strong class="bold">Cell Size</strong> to control the way World Partition works within our example map. The changes we make will adjust when the blueprints in the map are loaded and unloaded. Observing the differences will help you to experience World Partition (and spatial partitioning) in action.</p>
<p>Before we make any changes, press the <em class="italic">Play</em> button to play the level in the editor viewport. You should notice a stream of print strings on the left side of the screen. This is because each of the blueprint actors have been set up to print a short message and their display name.</p>
<p>Move around the map using typical first-person <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys to control the character. You should notice that, if you move all the way to one side of the map, prints change as fewer objects are printing their messages.</p>
<p>Once you’ve seen this effect, try changing <code>76800</code> to <code>768</code>, making the radius that objects need to be within to load 100 times smaller than the default settings. This will cause a significantly different result. Now, try testing the level once again. You should notice that only two objects are visible: a tall rectangular box and a cone, both of which are in front of the character from the starting position. These are visible because a small section of each mesh is inside a partition cell that is within a 7.68 m radius of the player character.</p>
<p>Walking toward either object will eventually cause other objects to suddenly appear (you will need to get very close) as you get within range of the neighboring partition cells.</p>
<p>To further understand why we get this behavior, let’s change the <strong class="bold">World Partition Editor Cell </strong><strong class="bold">Size</strong> variable:</p>
<ol>
<li>Below the <strong class="bold">Runtime Settings</strong> section we’ve used so far, expand the <strong class="bold">Advanced</strong> section by clicking the title or the arrow to the side.</li>
<li>Set the <code>25600</code> to match the <strong class="bold">Cell Size</strong> value from the <strong class="bold">Index [0]</strong> settings, ensuring our editor display matches the behavior we are experiencing when we play the level.</li>
<li>Once you have made the change, rebuild the Minimap by navigating to <strong class="bold">Build</strong> | <strong class="bold">Build Minimap</strong> from the top menu. You will be asked to save the level and any modified assets, and then you will be shown a series of progress bars while the build takes place.</li>
<li>Switch back to the <strong class="bold">World Partition</strong> editor tab; you should now see a lot fewer cells in the grid, as <a id="_idIndexMarker126"/>shown in <em class="italic">Figure 3</em><em class="italic">.13</em>:</li>
</ol>
<div><div><img alt="Figure 3.13 – Updated editor cell display showing how the visible objects are partially inside the initially loaded cells (-1,0) and (0,0)" src="img/Figure_03.13_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Updated editor cell display showing how the visible objects are partially inside the initially loaded cells (-1,0) and (0,0)</p>
<p>The grid should now show where each of the actors is positioned, with at least one of each of the object types (cone and cube) in a grid cell that the character starts within (or very close to). The second object of each pair sits in the neighboring grid cell, so will only appear once the player<a id="_idIndexMarker127"/> character is within 7.68 m of the cell, which is a very short distance when you consider each cell is 256 m x 256 m and the default loading range that we changed was originally a radius of 768 m. Based on the default values, when the character stands at the starting location at the origin of the grid, 36 of the cells are being loaded as opposed to the 4 that are loaded with the shortened range of 7.68 m, which would be inappropriate for use in a game but works as an extreme example of how the system works:</p>
<div><div><img alt="Figure 3.14 – Visual representation of the overlapping area of a 768 m radius circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared to a radius of 7.68 m (inner circle) only overlapping 4" src="img/Figure_03.14_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Visual representation of the overlapping area of a 768 m radius circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared to a radius of 7.68 m (inner circle) only overlapping 4</p>
<p>Now that we’ve set an extreme value, try some different values, such as setting <code>38400</code>, which will result in more objects being loaded at any one point. Standing at the center of the map will load a similar number of visible objects to the default setting, but you will see the objects disappear much sooner as you walk away from them. Remember, you can always return to the default value of <code>76800</code>.</p>
<p>This shows how, with<a id="_idIndexMarker128"/> different loading ranges, we can control when parts of our 3D world appear. Getting the correct values for your game might require some testing and, in some cases, the inclusion of scalability settings to ensure your game runs on different hardware. For now, the key thing is understanding how to control when things load and unload based on streaming sources so that once you have a 3D world to control, you can make the most of World Partition.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>Ensuring actors are loaded when required</h2>
<p>There are two ways to ensure<a id="_idIndexMarker129"/> that actors are loaded and ready for the player. One option is to force an actor to always be loaded by preventing it from being loaded and unloaded by World Partition. This could be useful if you have managers in the world who are required to control aspects across the entire level, or if you have a monument that needs to be always visible. To do this, do the following:</p>
<ol>
<li>Select the chosen actor in the level.</li>
<li>In the <strong class="bold">Details</strong> panel, scroll down to the <strong class="bold">World </strong><strong class="bold">Partition</strong> section:</li>
</ol>
<div><div><img alt="Figure 3.15 – World Partition settings in the Details panel with an actor selected" src="img/Figure_03.15_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – World Partition settings in the Details panel with an actor selected</p>
<ol>
<li value="3">Set <code>OFF</code>.</li>
</ol>
<p>The second <a id="_idIndexMarker130"/>approach is to include actors in the world that have a World Partition streaming source component.</p>
<p>We’ve included a <code>BP_StreamingSourceActor</code> blueprint, which has a World Partition streaming source component set up with the target grid already set up. To see it in action, do the following:</p>
<ol>
<li>Drag a <code>BP_StreamingSourceActor</code> blueprint from the <code>Content Browser/Blueprints</code> folder into the world between the two cone actors.</li>
<li>Set <code>768</code> for testing purposes.</li>
</ol>
<p>When testing the level, you should now see that, unlike when we first set the loading range to <code>768</code>, both cone objects are visible.</p>
<p>You will, however, notice that after five seconds of gameplay, one of the cones (the furthest one from the player) will disappear. This is because the <code>BP_StreamingSourceActor</code> blueprint includes some crude code to toggle the streaming source on and off. This provides a nice insight into how a streaming source actor can be used to control loading cells ready for the player, in cases such as where the character will be teleported to a new location that needs to be fully loaded before the player is relocated.</p>
<p>In <em class="italic">Figure 3</em><em class="italic">.16</em> you <a id="_idIndexMarker131"/>can see the logic within the <code>BP_StreamingSourceActor</code>’s event graph.</p>
<div><div><img alt="Figure 3.16 – Crude blueprint setup that disables and enables the streaming source every five seconds using a timer" src="img/Figure_03.16_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – Crude blueprint setup that disables and enables the streaming source every five seconds using a timer</p>
<p>Now that we’ve explored World Partition, we will look at using it with levels that have been created without it.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Enabling World Partition on an existing level</h2>
<p>To convert an<a id="_idIndexMarker132"/> existing level (that wasn’t created using the Open World starter map) to make use of World Partition, all you need to do is use the built-in tool:</p>
<ol>
<li>Ensure the level you want to convert to a World Partition-enabled level is saved.</li>
<li>Navigate to <strong class="bold">Tools</strong> | <strong class="bold">Convert Level</strong> from the top menu.</li>
<li>From the popup, select the map you would like to convert.</li>
<li>Click <strong class="bold">OK</strong>.</li>
</ol>
<p>The tool will create a new version of the map with the <code>_WP</code> suffix in the name unless you select <strong class="bold">In Place</strong> from the final settings dialog, which will simply overwrite your existing level.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>Summary</h1>
<p>In this chapter, we have discussed a number of existing patterns that are present in Unreal Engine, focusing on double buffer, flyweight, and spatial partitioning.</p>
<p>We have taken a look at some of these systems, including exploring editor examples of spatial partitioning using the World Partition system, experimenting with different variables to control when objects are loaded and unloaded, and testing an actor with a World Partition streaming source component.</p>
<p>In the next chapter, we are going to explore some pre-made patterns in Unreal. We will be looking at creating components using the <code>update</code> method, and creating a simple AI-controlled <strong class="bold">Real-Time Strategy</strong> (<strong class="bold">RTS</strong>) game unit using Unreal’s AI <strong class="bold">Behavior Trees</strong>.</p>
</div>
</body></html>