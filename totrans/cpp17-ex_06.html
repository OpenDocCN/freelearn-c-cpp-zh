<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Enhancing the Qt Graphical Applications</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <span><em>Qt Graphical Applications</em>,</span> we developed graphical Qt applications involving an analog clock, a drawing program, and an editor. In this chapter, we will continue to work on the three graphical applications of <span> </span><a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>,</span> <span><em>Qt Graphical Applications</em></span>. However, we will make the following improvements:</p>
<ul>
<li><strong>Clock</strong>: We will add digits to the clock dial</li>
<li><strong>The drawing program</strong>: We will add the ability to move and modify figures, to cut and paste them, and to mark one or several figures</li>
<li><strong>The editor</strong>: We will add the ability to change font and alignment as well as to mark a text block</li>
</ul>
<p class="mce-root">In this chapter, we will continue to work with the Qt libraries:</p>
<ul>
<li class="mce-root">Windows and widgets</li>
<li class="mce-root">Menus and toolbars</li>
<li class="mce-root">Mouse and keyboard events</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving the clock</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will replace the<span> version of </span>clock dial markings with digits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Clock class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Clock</kbd> class definition is similar to the one in <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications</em></span>. The timer updates the window 10 times each second. The constructor initializes the clock and <kbd>paintEvent</kbd> is called every time the window needs to be repainted.</p>
<p><strong>Clock.h:</strong></p>
<pre style="padding-left: 60px">   #ifndef CLOCK_H 
   #define CLOCK_H 
 
   #include &lt;QWidget&gt; 
   #include &lt;QTimer&gt; 
 
   class Clock : public QWidget { 
     Q_OBJECT 
 
     public: 
       Clock(QWidget *parentWidget = nullptr); 
       void paintEvent(QPaintEvent *eventPtr);
 
     private: 
     QTimer m_timer; 
   }; 
 
   #endif // CLOCK_H </pre>
<p><strong>Clock.cpp:</strong></p>
<pre style="padding-left: 60px">   #include &lt;QtWidgets&gt; 
   #include "Clock.h" </pre>
<p>Similar to <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications</em></span>, the constructor sets the header of the window to <kbd>Clock Advanced</kbd>, the window size to <em>1000</em> x <em>500</em> pixels, initializes the timer to send a timeout message every <kbd>100</kbd> milliseconds, and connect the <kbd>timeout</kbd> message to the <kbd>update</kbd> method, which forces the window to be repainted for each timeout:</p>
<pre style="padding-left: 60px">    Clock::Clock(QWidget *parentWidget /*= nullptr*/) 
    :QWidget(parentWidget) { 
      setWindowTitle(tr("Clock Advanced")); 
      resize(1000, 500); 
 
      m_timer.setParent(this); 
      connect(&amp;m_timer, SIGNAL(timeout()), this, SLOT(update())); 
      m_timer.start(100); 
    } </pre>
<p>The <kbd>paintEvent</kbd> method is called every time the window needs to be repainted. We will start by calculating the side of the clock and obtaining the current time:</p>
<pre style="padding-left: 60px">    void Clock::paintEvent(QPaintEvent* /*event*/) { 
      int side = qMin(width(), height()); 
      QTime time = QTime::currentTime(); </pre>
<p>We then create and initialize a <kbd>QPainter</kbd> object. We call <kbd>translate</kbd> and <kbd>scale</kbd> to match the physical size (pixels) to the logical size of <em>200 x 200</em> units:</p>
<pre style="padding-left: 60px">    QPainter painter(this); 
    painter.setRenderHint(QPainter::Antialiasing); 
    painter.setRenderHint(QPainter::TextAntialiasing); 
    painter.translate(width() / 2, height() / 2); 
    painter.scale(side / 200.0, side / 200.0); </pre>
<p>As we write digits to the clock in this version of the chapter, we add the font <kbd>Times New Roman</kbd>, <kbd>12</kbd> points, to the painter:</p>
<pre style="padding-left: 60px">    painter.setFont(QFont(tr("Times New Roman"), 12)); </pre>
<p>We write the digits of the clock, <kbd>1</kbd> to <kbd>12</kbd>, as shown in the following code:</p>
<pre style="padding-left: 60px">     for (int hour = 1; hour &lt;= 12; ++hour) { 
       QString text; 
       text.setNum(hour); </pre>
<p>A whole leap is 360° and the angle between two consecutive digits is 30°, since 360 divided by 12 is 30:</p>
<pre style="padding-left: 60px">    double angle = (30.0 * hour) - 90; 
    double radius = 90.0; </pre>
<p>The <kbd>x</kbd> and <kbd>y</kbd> coordinates of the digits are calculated by the sine and cosine functions. However, first, we need to transform the degrees to radians since sine and cosine accept radians only. This is shown in the following code:</p>
<pre style="padding-left: 60px">    double x = radius * qCos(qDegreesToRadians(angle)), 
           y = radius * qSin(qDegreesToRadians(angle)); </pre>
<p>The <kbd>drawText</kbd> methods write the digit, as follows:</p>
<pre style="padding-left: 60px">     QRect rect(x - 100, y - 100, 200, 200); 
     painter.drawText(rect, Qt::AlignHCenter | 
                            Qt::AlignVCenter, text); 
     } </pre>
<p>When the digits have been written, we draw the <kbd>hour</kbd>, <kbd>minute</kbd>, and <kbd>second</kbd> hands in the same way as in <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications</em></span>:</p>
<pre style="padding-left: 60px">    double hours = time.hour(), minutes = time.minute(), 
      seconds = time.second(), milliseconds = time.msec(); 
 
    painter.setPen(Qt::black); 
    painter.setBrush(Qt::gray); 
 
    { static const QPoint hourHand[3] = 
       {QPoint(8, 8), QPoint(-8, 8), QPoint(0, -60)}; 
 
      painter.save(); 
      double hour = hours + (minutes / 60.0) + (seconds / 3600.0) + 
                  (milliseconds / 3600000.0); 
      painter.rotate(30.0 * hour); 
      painter.drawConvexPolygon(hourHand, 3); 
      painter.restore(); 
    } 
 
    { static const QPoint minuteHand[3] = 
      {QPoint(6, 8), QPoint(-6, 8), QPoint(0, -70)}; 
 
      painter.save(); 
      double minute = minutes + (seconds / 60.0) + 
                    (milliseconds / 60000.0); 
      painter.rotate(6.0 * minute); 
      painter.drawConvexPolygon(minuteHand, 3); 
      painter.restore(); 
    } 
 
    { static const QPoint secondHand[3] = 
       {QPoint(4, 8), QPoint(-4, 8), QPoint(0, -80)}; 
 
      painter.save(); 
      double second = seconds + (milliseconds / 1000); 
      painter.rotate(6.0 * second); 
      painter.drawConvexPolygon(secondHand, 3); 
      painter.restore(); 
    } 
 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main function</h1>
                </header>
            
            <article>
                
<p>The <kbd>main</kbd> function is similar to the one in <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications</em></span>. It creates an application object, initializes the clock, and executes the application.</p>
<p><strong>Main.cpp:</strong></p>
<pre style="padding-left: 60px">#include &lt;QApplication&gt; 
#include "Clock.h" 
 
int main(int argc, char *argv[]) { 
  QApplication application(argc, argv); 
  Clock Clock; 
  Clock.show(); 
  return application.exec(); 
} </pre>
<p><strong>Output</strong>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="212" src="assets/4fc9d538-a689-43c2-9e55-d697cc18342c.png" width="394"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving the drawing program</h1>
                </header>
            
            <article>
                
<p>The drawing program of this chapter is a more advanced version of the drawing program of<span> </span><a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications.</em></span> In this version, it is possible to modify a figure, to enclose one or more figures and then change their colors, and to cut and paste figures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Figure class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Figure</kbd> class is rather similar to the one in <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications</em></span>. However, <kbd>isInside</kbd>, <kbd>doubleClick</kbd>, <kbd>modify</kbd>, and <kbd>marked</kbd> have been added.</p>
<p><strong>Figure.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef FIGURE_H 
    #define FIGURE_H 
 
    enum FigureId {LineId, RectangleId, EllipseId}; 
 
    #include &lt;QtWidgets&gt; 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    class Figure { 
      public: 
      Figure(); </pre>
<p>In this version, the pure virtual <kbd>clone</kbd> method has been added. That is due to the cut and paste. When pasting a figure we want to create a copy of it, without actually knowing which class the object belongs to. We could not do that with the copy constructor only. This is actually the main point of this section: how to use pure virtual methods and how to take advantage of dynamic binding. We need <kbd>clone</kbd>, which calls the copy constructor of its class to return a pointer to the new object:</p>
<pre style="padding-left: 60px">    virtual Figure* clone() const = 0; 
 
    virtual FigureId getId() const = 0; 
    virtual void initializePoints(QPoint point) = 0; </pre>
<p>In this version of the drawing program, <kbd>onClick</kbd> sets fields to indicate whether the figure shall be modified or moved. If the user grabs one of the marked points of the figure (which varies between different kinds of figures), the figure shall be modified. Otherwise, it shall be moved. The <kbd>modify</kbd> method is called when the user grabs one of the corners of the figure. In that case, the figure shall be modified rather than moved:</p>
<pre style="padding-left: 60px">    virtual bool isClick(QPoint mousePoint) = 0; 
    virtual void modify(QSize distance) = 0; </pre>
<p>The <kbd>isInside</kbd> method returns <kbd>true</kbd> if the figure is completely enclosed in the area. It is called when the user encloses figures with the mouse:</p>
<pre style="padding-left: 60px">    virtual bool isInside(QRect area) = 0; </pre>
<p>The <kbd>doubleClick</kbd> method is called when the user double-clicks at the figure, each figure performs some suitable action:</p>
<pre style="padding-left: 60px">    virtual void doubleClick(QPoint mousePoint) = 0; 
 
    virtual void move(QSize distance) = 0; 
    virtual void draw(QPainter &amp;painter) const = 0; 
 
    virtual bool write(ofstream&amp; outStream) const; 
    virtual bool read(ifstream&amp; inStream); </pre>
<p>The <kbd>marked</kbd> methods return and set the <kbd>m_marked</kbd> field. When a figure is marked, it is annotated with small squares:</p>
<pre style="padding-left: 60px">    bool marked() const {return m_marked;} 
    bool&amp; marked() {return m_marked;} 
 
    const QColor&amp; color() const {return m_color;} 
    QColor&amp; color() {return m_color;} 
 
    virtual bool filled() const {return m_filled;} 
    virtual bool&amp; filled() {return m_filled;} 
 
    static const int Tolerance; 
 
    private: 
    QColor m_color; 
    bool m_marked = false, m_filled = false; 
    }; 
 
    #endif </pre>
<p><strong>Figure.cpp:</strong></p>
<pre style="padding-left: 60px">    #include "..\MainWindow\DocumentWidget.h" 
    #include "Figure.h" 
 
    const int Figure::Tolerance(6); 
 
    Figure::Figure() { 
       // Empty. 
    } </pre>
<p>The <kbd>write</kbd> and <kbd>read</kbd> methods write and read the color of the figure and whether it is filled. However, they do not write or read the marked status. A figure is always unmarked when written or read:</p>
<pre style="padding-left: 60px">    bool Figure::write(ofstream&amp; outStream) const { 
      writeColor(outStream, m_color); 
      outStream.write((char*) &amp;m_filled, sizeof m_filled); 
      return ((bool) outStream); 
    } 
 
    bool Figure::read(ifstream&amp; inStream) { 
      readColor(inStream, m_color); 
      inStream.read((char*) &amp;m_filled, sizeof m_filled); 
      return ((bool) inStream); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Line class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Line</kbd> class is a subclass of <kbd>Figure</kbd>.</p>
<p><strong>Line.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef LINE_H 
    #define LINE_H 
  
    #include &lt;FStream&gt; 
    using namespace std; 
 
    #include "Figure.h" 
 
    class Line : public Figure { 
      public: 
      Line(); 
      FigureId getId() const {return LineId;} 
      In addition to the  
      Line(const Line&amp; line); 
      Figure* clone() const; 
 
      void initializePoints(QPoint point); </pre>
<p>As mentioned in the preceding <kbd>Figure</kbd> section, <kbd>isClick</kbd> decided whether the line shall be modified or moved. If the user grabs one of its endpoints, only that endpoint shall be moved. If the user grabs the line between the endpoints, the line shall be moved. That is, both the endpoints of the line shall be moved:</p>
<pre style="padding-left: 60px">    bool isClick(QPoint mousePoint); </pre>
<p>The <kbd>isInside</kbd> method checks whether the line is completely enclosed by the area:</p>
<pre style="padding-left: 60px">    bool isInside(QRect area); </pre>
<p>The <kbd>doubleClick</kbd> method does nothing in the <kbd>Line</kbd> class. However, we still need to define it, since it is pure virtual in <kbd>Figure</kbd>. If we had not defined it, <kbd>Line</kbd> would have been abstract:</p>
<pre style="padding-left: 60px">    void doubleClick(QPoint /* mousePoint */) {/* Empty. */} </pre>
<p>The <kbd>modify</kbd> method modifies the line in accordance with the settings of the preceding <kbd>isClick</kbd>. If the user grabs one of the endpoints, that endpoint is moved. Otherwise, the whole line (both the endpoints) is moved:</p>
<pre style="padding-left: 60px">    void modify(QSize distance); 
    void move(QSize distance); </pre>
<p>The <kbd>area</kbd> method returns a slightly larger area if the line is marked, in order to include the marking squares:</p>
<pre style="padding-left: 60px">    QRect area() const; 
    void draw(QPainter&amp; painter) const; 
 
    bool write(ofstream&amp; outStream) const; 
    bool read(ifstream&amp; inStream); </pre>
<p>The <kbd>m_lineMode</kbd> field keeps track of the movement or modification of the line. When the line is created, <kbd>m_lineMode</kbd> is set to <kbd>LastPoint</kbd>. When the user grabs the first or last endpoint of the line, <kbd>m_lineMode</kbd> is set to <kbd>FirstPoint</kbd> or <kbd>LastPoint</kbd>. When the user grabs the line between the endpoints, <kbd>m_lineMode</kbd> is set to <kbd>MoveLine</kbd>:</p>
<pre style="padding-left: 60px">      private: 
         enum {FirstPoint, LastPoint, MoveLine} m_lineMode; 
         QPoint m_firstPoint, m_lastPoint; </pre>
<p>The <kbd>isPointInLine</kbd> method decides whether the user has clicked on the line, with some tolerance:</p>
<pre style="padding-left: 60px">    static bool isPointInLine(QPoint m_firstPoint, 
                              QPoint m_lastPoint, QPoint point); 
    }; 
 
    #endif </pre>
<p><strong>Line.cpp:</strong></p>
<pre style="padding-left: 60px">    #include "..\MainWindow\DocumentWidget.h" 
    #include "Line.h" </pre>
<p>When a line becomes created, the line mode is set to the last point. That means that the last point of the line will be changed when the user moves the mouse:</p>
<pre style="padding-left: 60px">    Line::Line() 
    :m_lineMode(LastPoint) { 
      // Empty. 
    } </pre>
<p>The <kbd>clone</kbd> method is called when a line is being pasted. The copy constructor of <kbd>Figure</kbd> is called to set the color of the figure. Note that we call the <kbd>Figure</kbd> constructor with a <kbd>Line</kbd> object as a parameter, even though it takes a reference to a <kbd>Figure</kbd> object as a parameter. We are allowed to do this since <kbd>Line</kbd> is a subclass of <kbd>Figure</kbd> and the <kbd>Line</kbd> object will be transformed into a <kbd>Figure</kbd> object during the call. Moreover, the first and last endpoints are copied. Note that we do need to copy the value <kbd>m_lineMode</kbd> since its value is set when the user creates, modifies, or moves the line only:</p>
<pre style="padding-left: 60px">    Line::Line(const Line&amp; line) 
     :Figure(line), 
       m_firstPoint(line.m_firstPoint), 
       m_lastPoint(line.m_lastPoint) { 
      // Empty. 
     } </pre>
<p>The <kbd>clone</kbd> method uses the copy constructor to create a new object, which is then returned:</p>
<pre style="padding-left: 60px">    Figure* Line::clone() const { 
      Line* linePtr = new Line(*this); 
      return linePtr; 
    } </pre>
<p>The <kbd>initializePoints</kbd> method is called shortly after the line is being created. The reason for this call is that we do not create a <kbd>Line</kbd> object directly. Instead, we create the line indirectly by calling <kbd>clone</kbd>. We then need to initialize the end-points by calling <kbd>initializePoints</kbd>:</p>
<pre style="padding-left: 60px">    void Line::initializePoints(QPoint point) { 
      m_firstPoint = point; 
      m_lastPoint = point; 
    } </pre>
<p>The <kbd>isClick</kbd> method is called when the user clicks with the mouse. First, we check whether they have clicked at the first endpoint. We use the <kbd>Tolerance</kbd> field to create a small square, with the first endpoint in its center. If the user clicks on the square, <kbd>m_lineMode</kbd> is set to <kbd>FirstPoint</kbd> and <kbd>true</kbd> is returned:</p>
<pre style="padding-left: 60px">    bool Line::isClick(QPoint mousePoint) { 
      QRect firstSquare(makeRect(m_firstPoint, Tolerance)); 
 
     if (firstSquare.contains(mousePoint)) { 
       m_lineMode = FirstPoint; 
       return true; 
     } </pre>
<p>In the same way, we create a small square with the last endpoint in its center. If the user clicks at the square, <kbd>m_lineMode</kbd> is set to <kbd>LastPoint</kbd> and <kbd>true</kbd> is returned:</p>
<pre style="padding-left: 60px">    QRect lastSquare(makeRect(m_lastPoint, Tolerance)); 
 
    if (lastSquare.contains(mousePoint)) { 
      m_lineMode = LastPoint; 
      return true; 
    } </pre>
<p>If the user does not click on either of the endpoints, we check if they click on the line itself. If they do, <kbd>m_lineMode</kbd> is set to <kbd>ModeLine</kbd> and <kbd>true</kbd> is returned:</p>
<pre style="padding-left: 60px">    if (isPointInLine(m_firstPoint, m_lastPoint, mousePoint)) { 
      m_lineMode = MoveLine; 
      return true; 
    } </pre>
<p>Finally, if the user does not click on one of the endpoints or the line itself, they missed the line altogether and <kbd>false</kbd> is returned:</p>
<pre style="padding-left: 60px">    return false; 
    } </pre>
<p>The <kbd>isInside</kbd> method returns <kbd>true</kbd> if the line is completely enclosed by the area. It is quite easy, we just check whether the two end-points are located inside the area:</p>
<pre style="padding-left: 60px">    bool Line::isInside(QRect area) { 
     return area.contains(m_firstPoint) &amp;&amp; 
       area.contains(m_lastPoint); 
    } </pre>
<p>The <kbd>isPointInLine</kbd> method is identical to <kbd>isClick</kbd> in the version of <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Application</em><em>s</em>:</p>
<pre style="padding-left: 30px">    bool Line::isPointInLine(QPoint m_firstPoint, QPoint m_lastPoint,<br/>                         QPoint point) {<br/>  if (m_firstPoint.x() == m_lastPoint.x()) {<br/>    QRect lineRect(m_firstPoint, m_lastPoint);<br/>    lineRect.normalized();<br/>    lineRect += Tolerance;<br/>    return lineRect.contains(point);<br/>  }<br/>  else {<br/>    QPoint leftPoint = (m_firstPoint.x() &lt; m_lastPoint.x())<br/>                       ? m_firstPoint : m_lastPoint,<br/>           rightPoint = (m_firstPoint.x() &lt; m_lastPoint.x())<br/>                       ? m_lastPoint : m_firstPoint;<br/><br/>    if ((leftPoint.x() &lt;= point.x()) &amp;&amp;<br/>        (point.x() &lt;= rightPoint.x())) {<br/>      int lineWidth = rightPoint.x() - leftPoint.x(),<br/>          lineHeight = rightPoint.y() - leftPoint.y();<br/><br/>      int diffWidth = point.x() - leftPoint.x(),<br/>          diffHeight = point.y() - leftPoint.y();<br/><br/>      double delta = fabs(diffHeight -<br/>               (diffWidth * ((double) lineHeight) / lineWidth));<br/>      return (delta &lt;= Tolerance);<br/>    }<br/><br/>    return false;<br/>  }<br/>}</pre>
<p>The <kbd>modify</kbd> method moves the first or last endpoint, or both of them, depending on the settings of <kbd>m_lineMode</kbd> in the preceding <kbd>isClick</kbd> method:</p>
<pre style="padding-left: 60px">    void Line::modify(QSize distance) { 
      switch (m_lineMode) { 
        case FirstPoint: 
        m_firstPoint += distance; 
        break; 
 
        case LastPoint: 
        m_lastPoint += distance; 
        break; 
 
        case MoveLine: 
        move(distance); 
        break; 
      } 
    } </pre>
<p>The <kbd>move</kbd> method simply moves both the end-points of the line:</p>
<pre style="padding-left: 60px">    void Line::move(QSize distance) { 
      m_firstPoint += distance; 
      m_lastPoint += distance; 
    } </pre>
<p>The <kbd>draw</kbd> method draws the line. The difference between this version and the version of <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <span><em>Qt Graphical Applications</em>, </span>is that it also draws the squares at the end-points of the line if it is marked:</p>
<pre style="padding-left: 60px">    void Line::draw(QPainter&amp; painter) const { 
      painter.setPen(color()); 
      painter.drawLine(m_firstPoint, m_lastPoint); 
 
      if (marked()) { 
        painter.fillRect(makeRect(m_firstPoint, Tolerance), 
                     Qt::black); 
        painter.fillRect(makeRect(m_lastPoint, Tolerance), 
                     Qt::black); 
      } 
    } </pre>
<p>The <kbd>area</kbd> method returns the area covering the line. If the line is marked, the area is slightly expanded in order to cover the squares marking the endpoints:</p>
<pre style="padding-left: 60px">    QRect Line::area() const { 
      QRect lineArea(m_firstPoint, m_lastPoint); 
      lineArea.normalized(); 
 
      if (marked()) { 
         lineArea += Tolerance; 
      } 
 
      return lineArea; 
    } </pre>
<p>Similar to the version of <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications</em></span>, <kbd>write</kbd> and <kbd>read</kbd> call their counterparts in <kbd>Figure</kbd> and then write and read the two endpoints of the line:</p>
<pre style="padding-left: 60px">    bool Line::write(ofstream&amp; outStream) const { 
      Figure::write(outStream); 
      writePoint(outStream, m_firstPoint); 
      writePoint(outStream, m_lastPoint); 
      return ((bool) outStream); 
    } 
 
    bool Line::read(ifstream&amp; inStream) { 
      Figure::read(inStream); 
      readPoint(inStream, m_firstPoint); 
      readPoint(inStream, m_lastPoint); 
      return ((bool) inStream); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Rectangle class</h1>
                </header>
            
            <article>
                
<p><kbd>RectangleX</kbd> is a subclass of <kbd>Figure</kbd>. It is an expanded version of the version of <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><span><em>Qt Graphical Applications</em></span>. The <kbd>isClick</kbd> method has been modified, <kbd>doubleClick</kbd> and <kbd>modify</kbd> have been added.</p>
<p><strong>Rectangle.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef RECTANGLE_H 
    #define RECTANGLE_H 
 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    #include "Figure.h" 
 
    class RectangleX : public Figure { 
      public: 
      RectangleX(); 
      virtual FigureId getId() const {return RectangleId;} 
 
      RectangleX(const RectangleX&amp; rectangle); 
      Figure* clone() const; 
 
      virtual void initializePoints(QPoint point); 
 
      virtual bool isClick(QPoint mousePoint); 
      virtual void modify(QSize distance); 
 
      virtual bool isInside(QRect area); 
      virtual void doubleClick(QPoint mousePoint); 
 
      virtual void move(QSize distance); 
      virtual QRect area() const; 
      virtual void draw(QPainter&amp; painter) const; 
 
      virtual bool write(ofstream&amp; outStream) const; 
      virtual bool read(ifstream&amp; inStream); 
 
      private: 
        enum {TopLeftPoint, TopRightPoint, BottomRightPoint,  
            BottomLeftPoint, MoveRectangle} m_rectangleMode; 
 
      protected: 
        QPoint m_topLeft, m_bottomRight; 
    }; 
 
    #endif </pre>
<p><strong>Rectangle.cpp:</strong></p>
<pre style="padding-left: 60px">    #include &lt;CAssert&gt; 
    #include "..\MainWindow\DocumentWidget.h" 
    #include "Rectangle.h" </pre>
<p>When a rectangle is added by the user, its mode is <kbd>BottomRightPoint</kbd>. That means that the bottom-right corner of the rectangle will be moved when the user moves the mouse:</p>
<pre style="padding-left: 60px">    RectangleX::RectangleX() 
    :m_rectangleMode(BottomRightPoint) { 
      // Empty. 
    } </pre>
<p>The copy constructor copies the rectangle. More specifically, first it calls the copy constructor of the <kbd>Figure</kbd> class, then it copies the top-left and bottom-right corner. Note that it does not copy the <kbd>m_rectangleMode</kbd> field, since it is used when the user moves the mouse only:</p>
<pre style="padding-left: 60px">    RectangleX::RectangleX(const RectangleX&amp; rectangle) 
    :Figure(rectangle), 
      m_topLeft(rectangle.m_topLeft), 
      m_bottomRight(rectangle.m_bottomRight) { 
      // Empty. 
    } </pre>
<p>The <kbd>clone</kbd> method creates and returns a pointer to a new object by calling the copy constructor:</p>
<pre style="padding-left: 60px">    Figure* RectangleX::clone() const { 
      RectangleX* rectanglePtr = new RectangleX(*this); 
      return rectanglePtr; 
    } 
 
    void RectangleX::initializePoints(QPoint point) { 
      m_topLeft = point; 
      m_bottomRight = point; 
    } </pre>
<p>The <kbd>isClick</kbd> method is called when the user clicks with the mouse. Similar to the preceding bool <kbd>Line</kbd>, we start by checking whether they have clicked at any of the corners. If they have not, we check whether they have clicked on the rectangle border or inside the rectangle, depending on whether it is filled.</p>
<p>We start by defining a small square covering the top-left corner. If the user clicks on it, we set the <kbd>m_rectangleMode</kbd> field to <kbd>TopLeftPoint</kbd> and return <kbd>true</kbd>:</p>
<pre style="padding-left: 60px">    bool RectangleX::isClick(QPoint mousePoint) { 
      QRect topLeftRect(makeRect(m_topLeft, Tolerance)); 
 
      if (topLeftRect.contains(mousePoint)) { 
        m_rectangleMode = TopLeftPoint; 
        return true; 
      } </pre>
<p>We continue by defining a square covering the top-right corner. If the user clicks on it, we set <kbd>m_rectangleMode</kbd> to <kbd>TopRightPoint</kbd> and return <kbd>true</kbd>:</p>
<pre style="padding-left: 60px">     QPoint topRightPoint(m_bottomRight.x(), m_topLeft.y()); 
     QRect topRectRight(makeRect(topRightPoint, Tolerance)); 
 
     if (topRectRight.contains(mousePoint)) { 
       m_rectangleMode = TopRightPoint; 
       return true; 
     } </pre>
<p>If the user clicks at the square covering the bottom-right corner, we set <kbd>m_rectangleMode</kbd> to <kbd>BottomRightPoint</kbd> and return <kbd>true</kbd>:</p>
<pre style="padding-left: 60px">     QRect m_bottomRightRect(makeRect(m_bottomRight, Tolerance)); 
  
     if (m_bottomRightRect.contains(mousePoint)) { 
       m_rectangleMode = BottomRightPoint; 
       return true; 
     } </pre>
<p>If the user clicks at the square covering the bottom-left corner, we set <kbd>m_rectangleMode</kbd> to <kbd>BottomLeftPoint</kbd> and return <kbd>true</kbd>:</p>
<pre style="padding-left: 60px">    QPoint bottomLeftPoint(m_topLeft.x(), m_bottomRight.y()); 
    QRect bottomLeftRect(makeRect(bottomLeftPoint, Tolerance)); 
 
    if (bottomLeftRect.contains(mousePoint)) { 
      m_rectangleMode = BottomLeftPoint; 
      return true; 
    } </pre>
<p>If the user does not click at any of the corners of the rectangle, we check the rectangle itself. If it is filled, we check whether the mouse pointer is located inside the rectangle itself. If it is, we set <kbd>m_rectangleMode</kbd> to <kbd>MoveRectangle</kbd> and return <kbd>true</kbd>:</p>
<pre style="padding-left: 60px">  QRect areaRect(m_topLeft, m_bottomRight); 
 
  if (filled()) { 
    if (areaRect.contains(mousePoint)) { 
      m_rectangleMode = MoveRectangle; 
      return true; 
    } 
  } </pre>
<p>If the rectangle is not filled, we define slightly larger and smaller rectangles. If the mouse click is located inside the larger rectangle, but not in the smaller one, we set <kbd>m_rectangleMode</kbd> to <kbd>MoveRectangle</kbd> and return <kbd>true</kbd>:</p>
<pre style="padding-left: 60px">     else { 
       QRect largeAreaRect(areaRect), smallAreaRect(areaRect); 
 
      largeAreaRect += Tolerance; 
      smallAreaRect -= Tolerance; 
 
      if (largeAreaRect.contains(mousePoint) &amp;&amp; 
         !smallAreaRect.contains(mousePoint)) { 
           m_rectangleMode = MoveRectangle; 
           return true; 
        } 
     } </pre>
<p>Finally, if the user does not click at one of the corners or the rectangle itself, they missed the rectangle and we return <kbd>false</kbd>:</p>
<pre style="padding-left: 60px">      return false; 
    } </pre>
<p>The <kbd>isInside</kbd> method is quite simple. We simply check if the top-left and bottom-right corners are located inside the rectangle:</p>
<pre style="padding-left: 60px">     bool RectangleX::isInside(QRect area) { 
       return area.contains(m_topLeft) &amp;&amp; 
         area.contains(m_bottomRight); 
     } </pre>
<p>The <kbd>doubleClick</kbd> method is called when the user double-clicks with the mouse. If the call to <kbd>onClick</kbd> returns <kbd>true</kbd>, <kbd>doubleClick</kbd> is called. In the rectangle case, the filled status is changed—a filled rectangle becomes unfilled and an unfilled rectangle becomes filled:</p>
<pre style="padding-left: 60px">     void RectangleX::doubleClick(QPoint mousePoint) { 
       if (isClick(mousePoint)) { </pre>
<p>The first call to <kbd>filled</kbd> is a call to the version that returns a reference to the <kbd>m_filled</kbd> field, which allows us to change the returned value:</p>
<pre style="padding-left: 60px">     filled() = !filled(); 
    } 
  } </pre>
<p>The <kbd>modify</kbd> method modifies the rectangle in accordance with the <kbd>m_rectangleMode</kbd> field, which was set by the preceding <kbd>isClick</kbd>. If it is set to one of the four corners, we modify that corner. If not, we move the whole rectangle:</p>
<pre style="padding-left: 60px">   void RectangleX::modify(QSize distance) { 
     switch (m_rectangleMode) { 
       case TopLeftPoint: 
       m_topLeft += distance; 
       break; 
 
       case TopRightPoint: 
       m_topLeft.setY(m_topLeft.y() + distance.height()); 
       m_bottomRight.setX(m_bottomRight.x() + distance.width()); 
       break; 
 
       case BottomRightPoint: 
       m_bottomRight += distance; 
       break; 
 
       case BottomLeftPoint: 
       m_topLeft.setX(m_topLeft.x() + distance.width()); 
       m_bottomRight.setY(m_bottomRight.y() + distance.height()); 
       break; 
 
       case MoveRectangle: 
       move(distance); 
       break; 
      } 
   } </pre>
<p>The <kbd>move</kbd> method is quite simple. It just changes the top-left and bottom-right corners:</p>
<pre style="padding-left: 60px">    void RectangleX::move(QSize distance) { 
      m_topLeft += distance; 
      m_bottomRight += distance; 
    } </pre>
<p>The <kbd>area</kbd> method returns the area covering the rectangle. If it is marked, we slightly expand the area in order for it to cover the marking squares:</p>
<pre style="padding-left: 60px">    QRect RectangleX::area() const { 
      QRect areaRect(m_topLeft, m_bottomRight); 
      areaRect.normalized(); 
 
      if (marked()) { 
        areaRect += Tolerance; 
      } 
 
      return areaRect; 
    } </pre>
<p>The <kbd>draw</kbd> method draws the rectangle; with a full brush it is filled and with a hollow brush if it is unfilled:</p>
<pre style="padding-left: 60px">    void RectangleX::draw(QPainter&amp; painter) const { 
      painter.setPen(color()); 
 
      if (filled()) { 
        painter.fillRect(QRect(m_topLeft, m_bottomRight), color()); 
      } 
      else { 
        painter.setBrush(Qt::NoBrush); 
        painter.drawRect(QRect(m_topLeft, m_bottomRight)); 
      } </pre>
<p>If the rectangle is marked, the four squares covering the corners of the rectangle are also drawn:</p>
<pre style="padding-left: 60px">    if (marked()) { 
      painter.fillRect(makeRect(m_topLeft, Tolerance), Qt::black); 
      QPoint topRight(m_bottomRight.x(), m_topLeft.y()); 
      painter.fillRect(makeRect(topRight, Tolerance), Qt::black); 
      painter.fillRect(makeRect(m_bottomRight, Tolerance), 
                     Qt::black); 
      QPoint bottomLeft(m_topLeft.x(), m_bottomRight.y()); 
      painter.fillRect(makeRect(bottomLeft, Tolerance), Qt::black); 
    } 
  } </pre>
<p>The <kbd>write</kbd> and <kbd>read</kbd> methods first call their counterparts in <kbd>Figure</kbd> in order to write and read the color of the rectangle. Then it writes and reads the top-left and bottom-right corners:</p>
<pre style="padding-left: 60px">    bool RectangleX::write(ofstream&amp; outStream) const { 
     Figure::write(outStream); 
     writePoint(outStream, m_topLeft); 
     writePoint(outStream, m_bottomRight); 
     return ((bool) outStream); 
    } 
  
    bool RectangleX::read (ifstream&amp; inStream) { 
      Figure::read(inStream); 
      readPoint(inStream, m_topLeft); 
      readPoint(inStream, m_bottomRight); 
      return ((bool) inStream); 
 } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Ellipse class</h1>
                </header>
            
            <article>
                
<p><kbd>EllipseX</kbd> is a direct sub class of <kbd>RectangleX</kbd> and an indirect subclass of <kbd>Figure</kbd> that draws a filled or unfilled ellipse:</p>
<p><strong>EllipseX.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef ELLIPSE_H 
    #define ELLIPSE_H 
 
    #include "Rectangle.h" 
 
    class EllipseX : public RectangleX { 
      public: 
      EllipseX(); 
      FigureId getId() const {return EllipseId;} 
 
      EllipseX(const EllipseX&amp; ellipse); 
      Figure* clone() const; </pre>
<p>Similar to the preceding rectangle case, <kbd>isClick</kbd> checks whether the user grabs the ellipse in one of its four corners, or if the ellipse itself shall be moved:</p>
<pre style="padding-left: 60px">    bool isClick(QPoint mousePoint); </pre>
<p>The <kbd>modify</kbd> method modifies the ellipse in accordance with the settings of following <kbd>m_ellipseMode</kbd> in preceding <kbd>isClick</kbd>:</p>
<pre style="padding-left: 60px">    void modify(QSize distance); 
    void draw(QPainter&amp; painter) const; </pre>
<p>While the preceding rectangle could be grabbed by its four corners, the ellipse can be grabbed by its left, top, right, and bottom points. Therefore, we need to add the <kbd>CreateEllipse</kbd> enumeration value, which modifies the bottom-right corner of the area covering the ellipse:</p>
<pre style="padding-left: 60px">     private: 
       enum {CreateEllipse, LeftPoint, TopPoint, RightPoint, 
           BottomPoint, MoveEllipse} m_ellipseMode; 
       }; 
 
       #endif </pre>
<p><strong>EllipseX.cpp:</strong></p>
<pre style="padding-left: 60px">    #include &lt;CAssert&gt; 
    #include "..\MainWindow\DocumentWidget.h" 
    #include "Ellipse.h" </pre>
<p>In contrast to the preceding line and rectangle cases, we set the <kbd>m_ellipseMode</kbd> field to <kbd>CreateEllipse</kbd>, which is valid when the ellipse is being created only:</p>
<pre style="padding-left: 60px">     EllipseX::EllipseX() 
      :m_ellipseMode(CreateEllipse) { 
      // Empty. 
     } </pre>
<p>The copy constructor does not need to set the <kbd>m_topLeft</kbd> and <kbd>m_bottomRight</kbd> fields, since it is taken care of by the copy constructor of <kbd>RectangleX</kbd>, which is being called by the copy constructor of <kbd>EllipseX</kbd>:</p>
<pre style="padding-left: 60px">    EllipseX::EllipseX(const EllipseX&amp; ellipse) 
    :RectangleX(ellipse) { 
      // Empty. 
    } 
 
    Figure* EllipseX::clone() const { 
      EllipseX* ellipsePtr = new EllipseX(*this); 
      return ellipsePtr; 
    } </pre>
<p>Similar to the preceding rectangle case, <kbd>isClick</kbd> checks whether the user grabs the ellipse by one of its four points. However, in the ellipse case, we do not check the corners of the rectangle. Instead, we check the left, top, right, and bottom position of the ellipse. We create a small square for each of those positions and check whether the user clicks on them. If they do, we set the <kbd>m_ellipseMode</kbd> field to an appropriate value and return <kbd>true</kbd>:</p>
<pre style="padding-left: 60px">    bool EllipseX::isClick(QPoint mousePoint) { 
      QPoint leftPoint(m_topLeft.x(), 
                   (m_topLeft.y() + m_bottomRight.y()) / 2); 
      QRect leftRect(makeRect(leftPoint, Tolerance)); 
 
      if (leftRect.contains(mousePoint)) { 
        m_ellipseMode = LeftPoint; 
        return true; 
      } 
 
      QPoint topPoint((m_topLeft.x() + m_bottomRight.x()) / 2, 
                  m_topLeft.y()); 
      QRect topRect(makeRect(topPoint, Tolerance)); 
  
      if (topRect.contains(mousePoint)) { 
        m_ellipseMode = TopPoint; 
        return true; 
      } 
 
      QPoint rightPoint(m_bottomRight.x(), 
                    (m_topLeft.y() + m_bottomRight.y()) / 2); 
      QRect rightRect(makeRect(rightPoint, Tolerance)); 
 
      if (rightRect.contains(mousePoint)) { 
        m_ellipseMode = RightPoint; 
        return true; 
      } 
 
      QPoint bottomPoint((m_topLeft.x() + m_bottomRight.x()) / 2, 
                     m_bottomRight.y()); 
      QRect bottomRect(makeRect(bottomPoint, Tolerance)); 
 
      if (bottomRect.contains(mousePoint)) { 
        m_ellipseMode = BottomPoint; 
        return true; 
      } </pre>
<p>If the user does not click on any of the four positions, we check whether they click on the ellipse itself. If it is filled, we use the Qt <kbd>QRegion</kbd> class to create an elliptic region and we check whether the mouse point is located inside the region:</p>
<pre style="padding-left: 60px">    QRect normalRect(m_topLeft, m_bottomRight); 
    normalRect.normalized(); 
 
    if (filled()) { 
      QRegion normalEllipse(normalRect, QRegion::Ellipse); 
 
      if (normalEllipse.contains(mousePoint)) { 
        m_ellipseMode = MoveEllipse; 
        return true; 
      } 
    } </pre>
<p>If the ellipse is unfilled, we create slightly larger and smaller elliptic regions and then check whether the mouse point is located inside the larger region, and also inside the smaller one:</p>
<pre style="padding-left: 60px">     else { 
       QRect largeRect(normalRect), smallRect(normalRect); 
       largeRect += Tolerance; 
       smallRect -= Tolerance; 
 
       QRegion largeEllipse(largeRect, QRegion::Ellipse), 
            smallEllipse(smallRect, QRegion::Ellipse); 
 
       if (largeEllipse.contains(mousePoint) &amp;&amp; 
           !smallEllipse.contains(mousePoint)) { 
         m_ellipseMode = MoveEllipse; 
         return true; 
       } 
     } </pre>
<p>Finally, if the user does not click at any of the grabbing positions or the ellipse itself, we return <kbd>false</kbd>:</p>
<pre style="padding-left: 60px">      return false; 
   } </pre>
<p>The <kbd>modify</kbd> method modifies the ellipse in accordance with the settings of <kbd>m_ellipseMode</kbd> in <kbd>onClick</kbd>:</p>
<pre style="padding-left: 60px">    void EllipseX::modify(QSize distance) { 
      switch (m_ellipseMode) { 
        case CreateEllipse: 
        m_bottomRight += distance; 
        break; 
 
        case LeftPoint: 
        m_topLeft.setX(m_topLeft.x() + distance.width()); 
        break; 
 
        case RightPoint: 
        m_bottomRight.setX(m_bottomRight.x() + distance.width()); 
        break; 
 
        case TopPoint: 
        m_topLeft.setY(m_topLeft.y() + distance.height()); 
        break; 
 
        case BottomPoint: 
        m_bottomRight.setY(m_bottomRight.y() + distance.height()); 
        break; 
 
        case MoveEllipse: 
        move(distance); 
        break; 
      } 
    } </pre>
<p>The <kbd>draw</kbd> method draws the ellipse with a solid brush if it is filled, and with a hollow brush if it is unfilled:</p>
<pre style="padding-left: 60px">    void EllipseX::draw(QPainter&amp; painter) const { 
      painter.setPen(color()); 
  
      if (filled()) { 
        painter.setBrush(color()); 
        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); 
      } 
      else { 
        painter.setBrush(Qt::NoBrush); 
        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); 
      } </pre>
<p>If the ellipse is marked, the four squares covering the top, left, right, and bottom points of the ellipse are also drawn:</p>
<pre style="padding-left: 60px">   if (marked()) {<br/>    QPoint leftPoint(m_topLeft.x(),<br/>                     (m_topLeft.y() + m_bottomRight.y())/2);<br/>    painter.fillRect(makeRect(leftPoint, Tolerance), Qt::black);<br/><br/>    QPoint topPoint((m_topLeft.x() + m_bottomRight.x()) / 2,<br/>                    m_topLeft.y());<br/>    painter.fillRect(makeRect(topPoint, Tolerance), Qt::black);<br/><br/>    QPoint rightPoint(m_bottomRight.x(),<br/>                      (m_topLeft.y() + m_bottomRight.y()) / 2);<br/>    painter.fillRect(makeRect(rightPoint, Tolerance), Qt::black);<br/><br/>    QPoint bottomPoint((m_topLeft.x() + m_bottomRight.x()) / 2,<br/>                       m_bottomRight.y());<br/>    painter.fillRect(makeRect(bottomPoint, Tolerance), Qt::black);<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DrawingWindow class</h1>
                </header>
            
            <article>
                
<p>The <kbd>DrawingWindow</kbd> class is similar to the version of the previous chapter. It overrides the <kbd>closeEvent</kbd> method.</p>
<p><strong>DrawingWindow.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef DRAWINGWINDOW_H 
    #define DRAWINGWINDOW_H 
 
    #include &lt;QMainWindow&gt; 
    #include &lt;QActionGroup&gt; 
 
    #include "..\MainWindow\MainWindow.h" 
    #include "DrawingWidget.h" 
 
    class DrawingWindow : public MainWindow { 
      Q_OBJECT 
 
      public: 
      DrawingWindow(QWidget *parentWidget = nullptr); 
      ~DrawingWindow(); 
 
      public: 
      void closeEvent(QCloseEvent *eventPtr) 
           { m_drawingWidgetPtr-&gt;closeEvent(eventPtr); } 
 
      private: 
       DrawingWidget* m_drawingWidgetPtr; 
       QActionGroup* m_figureGroupPtr; 
    }; 
 
    #endif // DRAWINGWINDOW_H </pre>
<p><strong>DrawingWindow.cpp:</strong></p>
<pre style="padding-left: 60px">    #include "..\MainWindow\DocumentWidget.h" 
    #include "DrawingWindow.h" </pre>
<p>The constructor initializes the window size to <em>1000</em> x <em>500</em> pixels, puts the drawing widget in the middle of the window, adds the standard <span class="packt_screen">File</span> and <span class="packt_screen">Edit</span> menus, and adds the application-specific <span class="packt_screen">Format</span> and Figure menus:</p>
<pre style="padding-left: 60px">DrawingWindow::DrawingWindow(QWidget *parentWidget /*= nullptr*/)<br/> :MainWindow(parentWidget) {<br/>  resize(1000, 500);<br/><br/>  m_drawingWidgetPtr = new DrawingWidget(this);<br/>  setCentralWidget(m_drawingWidgetPtr);<br/>  addFileMenu();<br/>  addEditMenu();</pre>
<p>The <span class="packt_screen">Format</span> menu holds the <kbd>Color</kbd>, <kbd>Fill</kbd>, and <kbd>Modify</kbd> items as well as the Figure submenu:</p>
<pre style="padding-left: 60px">    { QMenu* formatMenuPtr = menuBar()-&gt;addMenu(tr("F&amp;ormat")); 
       connect(formatMenuPtr, SIGNAL(aboutToShow()), 
            this, SLOT(onMenuShow())); 
 
      addAction(formatMenuPtr, tr("&amp;Color"), 
              SLOT(onColor()), QKeySequence(Qt::ALT + Qt::Key_C), 
              QString(), nullptr, tr("Figure Color")); 
 
      addAction(formatMenuPtr, tr("&amp;Fill"), 
              SLOT(onFill()), QKeySequence(Qt::CTRL + Qt::Key_F), 
              QString(), nullptr, tr("Figure Fill"), 
              LISTENER(isFillEnabled)); </pre>
<p>The user selects the <span class="packt_screen">Modify</span> item when they want to mark or modify existing figures instead of adding new figures:</p>
<pre style="padding-left: 60px">     m_figureGroupPtr = new QActionGroup(this); 
     addAction(formatMenuPtr, tr("&amp;Modify"), 
              SLOT(onModify()), 
              QKeySequence(Qt::CTRL + Qt::Key_M), 
              QString(), nullptr, tr("Modify Figure"), nullptr, 
              LISTENER(isModifyChecked), m_figureGroupPtr); </pre>
<p>The Figure menu is a submenu holding the <kbd>Line</kbd>, <kbd>Rectangle</kbd>, and <kbd>Ellipse</kbd> items. It becomes a submenu when we add it to the <span class="packt_screen">Format</span> menu:</p>
<pre style="padding-left: 60px">    { QMenu* figureMenuPtr = 
               formatMenuPtr-&gt;addMenu(tr("&amp;Figure")); 
      connect(figureMenuPtr, SIGNAL(aboutToShow()), 
              this, SLOT(onMenuShow())); 
 
      addAction(figureMenuPtr, tr("&amp;Line"), 
                SLOT(onLine()), 
                QKeySequence(Qt::CTRL + Qt::Key_L), 
                QString(), nullptr, tr("Line Figure"), nullptr, 
                LISTENER(isLineChecked), m_figureGroupPtr); 
 
      addAction(figureMenuPtr, tr("&amp;Rectangle"), 
                SLOT(onRectangle()), 
                QKeySequence(Qt::CTRL + Qt::Key_R), 
                QString(), nullptr, tr("Rectangle Figure"), 
                nullptr, LISTENER(isRectangleChecked), 
                m_figureGroupPtr); 
 
      addAction(figureMenuPtr, tr("&amp;Ellipse"), 
                SLOT(onEllipse()), 
                QKeySequence(Qt::CTRL + Qt::Key_E), 
                QString(), nullptr, tr("Ellipse Figure"), nullptr, 
                LISTENER(isEllipseChecked), m_figureGroupPtr); 
    } 
  } 
} 
 
DrawingWindow::~DrawingWindow() { 
  delete m_figureGroupPtr; 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DrawingWidget class</h1>
                </header>
            
            <article>
                
<p>The <kbd>DrawingWidget</kbd> class is the main class of the application. It catches the mouse and paint events. It also catches the menu item selections of the <span class="packt_screen">File</span>, <span class="packt_screen">Edit</span>, and Figure menus.</p>
<p><strong>DrawingWidget.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef DRAWINGWIDGET_H 
    #define DRAWINGWIDGET_H 
 
    #include "..\MainWindow\MainWindow.h" 
    #include "..\MainWindow\DocumentWidget.h" 
    #include "Figure.h" 
 
    class DrawingWidget : public DocumentWidget { 
      Q_OBJECT 
 
      public: 
      DrawingWidget(QWidget* parentWidget); 
      ~DrawingWidget(); 
  
      public: 
      void mousePressEvent(QMouseEvent *eventPtr); 
      void mouseMoveEvent(QMouseEvent *eventPtr); 
      void mouseReleaseEvent(QMouseEvent *eventPtr); 
      void mouseDoubleClickEvent(QMouseEvent *eventPtr); 
      void paintEvent(QPaintEvent *eventPtr); 
 
      private: 
      void newDocument(void); 
      bool writeFile(const QString&amp; filePath); 
      bool readFile(const QString&amp; filePath); 
      Figure* createFigure(FigureId figureId); </pre>
<p>Unlike the version of <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em>, this version overrides the cut and copy event methods:</p>
<pre style="padding-left: 60px">     public slots: 
       bool isCopyEnabled(); 
       void onCopy(void); 
       bool isPasteEnabled(); 
       void onPaste(void); 
       void onDelete(void); 
       void onColor(void); 
 
       DEFINE_LISTENER(DrawingWidget, isFillEnabled); 
       void onFill(void); 
   
       DEFINE_LISTENER(DrawingWidget, isModifyChecked); 
       void onModify(void); 
 
       DEFINE_LISTENER(DrawingWidget, isLineChecked); 
       void onLine(void); 
 
       DEFINE_LISTENER(DrawingWidget, isRectangleChecked); 
       void onRectangle(void); 
 
       DEFINE_LISTENER(DrawingWidget, isEllipseChecked); 
       void onEllipse(void); </pre>
<p>The <kbd>m_applicationMode</kbd> field holds the values <kbd>Idle</kbd>, <kbd>ModifySingle</kbd>, or <kbd>ModifyRectangle</kbd>. The <kbd>Idle</kbd> mode is active when the user is not pressing the mouse. The <kbd>ModifySingle</kbd> mode becomes active when the user grabs a figure and modifies or moves it (depending on which part of the figure the user grabs). Finally, the <kbd>ModifyRectangle</kbd> mode becomes active when the user clicks at the window without hitting a figure. In that case, a rectangle is shown, and every figure enclosed by the rectangle becomes marked when the user releases the mouse button. The user can delete or cut and paste the marked figure, or change their color or the filled status. When the user releases the mouse button, the <kbd>Application</kbd> mode again becomes <kbd>Idle</kbd>:</p>
<pre style="padding-left: 60px">  private: 
    enum ApplicationMode {Idle, ModifySingle, ModifyRectangle}; 
    ApplicationMode m_applicationMode = Idle; 
    void setApplicationMode(ApplicationMode mode);</pre>
<p>The <kbd>m_actionMode</kbd> field holds the values <kbd>Modify</kbd> or <kbd>Add</kbd>. In <kbd>Modify</kbd> mode, when the user clicks with the mouse, <kbd>m_applicationMode</kbd> is set to <kbd>ModifySingle</kbd> or <kbd>ModifyRectangle</kbd>, depending on whether they hit a figure. In <kbd>Add</kbd> mode, a new figure is added, regardless of whether the user hits a figure. The kind of figure to be added is set by <kbd>m_addFigureId</kbd>, which holds the values <kbd>LineId</kbd>, <kbd>RectangleId</kbd>, or <kbd>EllipseId</kbd>:</p>
<pre style="padding-left: 60px">    enum ActionMode {Modify, Add}; 
    ActionMode m_actionMode = Add; 
    FigureId m_addFigureId = LineId; </pre>
<p>The color of the next figure to be added to the drawing is initialized to black, and the filled status is initialized to false (unfilled). In both cases, it can later be changed by the user:</p>
<pre style="padding-left: 60px">    QColor m_nextColor = Qt::black; 
    bool m_nextFilled = false; </pre>
<p>We need to save the latest mouse point in order to calculate distances between mouse movements:</p>
<pre style="padding-left: 60px">    QPoint m_mousePoint; </pre>
<p>Pointers to the figures of the drawing are stored in <kbd>m_figurePtrList</kbd>. The top-most figure is stored at the end of the list. When the user cuts or copies one or several figures, the figures are copied and the pointers to the copies are stored in <kbd>m_copyPtrList</kbd>:</p>
<pre style="padding-left: 60px">    QList&lt;Figure*&gt; m_figurePtrList, m_copyPtrList; </pre>
<p>When <kbd>m_actionMode</kbd> holds <kbd>Modify</kbd> and the user presses the mouse button without hitting a figure, a rectangle becomes visible in the window. That rectangle is stored in <kbd>m_insideRectangle</kbd>:</p>
<pre style="padding-left: 60px">     QRect m_insideRectangle; 
   }; 
 
   #endif // DRAWINGWIDGET_H </pre>
<p><strong>DrawingWidget.cpp:</strong></p>
<pre style="padding-left: 60px">    #include &lt;CAssert&gt; 
    #include "..\MainWindow\DocumentWidget.h" 
 
    #include "DrawingWidget.h" 
    #include "Line.h" 
    #include "Rectangle.h" 
    #include "Ellipse.h" </pre>
<p>The constructor calls the constructor of the base class <kbd>DocumentWidget</kbd> to set the header of the window to <kbd>Drawing Advanced</kbd>, and to set the file suffix of the drawing files to <kbd>drw</kbd>:</p>
<pre style="padding-left: 60px">    DrawingWidget::DrawingWidget(QWidget* parentWidget) 
    :DocumentWidget(tr("Drawing Advanced"), 
                 tr("Drawing files (*.drw)"), 
                 parentWidget) { 
       // Empty. 
    }  </pre>
<p>The destructor does nothing, it has been included for the sake of completeness only:</p>
<pre style="padding-left: 60px">    DrawingWidget::~DrawingWidget() { 
       // Empty. 
    } </pre>
<p>The <kbd>setApplicationMode</kbd> method sets the application mode and calls <kbd>onMenuShow</kbd> in the main window for the toolbar icons to be correctly enabled:</p>
<pre style="padding-left: 60px">    void DrawingWidget::setApplicationMode(ApplicationMode mode) { 
      m_applicationMode = mode; 
      ((MainWindow*) parent())-&gt;onMenuShow(); 
} </pre>
<p>The <kbd>newDocument</kbd> method is called when the user selects the <kbd>New</kbd> menu item. We start by deallocating every figure in the figure and copy pointer lists, and they clear the list themselves:</p>
<pre style="padding-left: 60px">    void DrawingWidget::newDocument(void) { 
      for (Figure* figurePtr : m_figurePtrList) { 
      delete figurePtr; 
    } 
 
    for (Figure* copyPtr : m_copyPtrList) { 
      delete copyPtr; 
    } 
 
    m_figurePtrList.clear(); 
    m_copyPtrList.clear(); </pre>
<p>The current color and filled status are set to black and false (unfilled). The action mode is set to <kbd>Add</kbd> and the add figure identity is set to <kbd>LineId</kbd>, which means that when the user presses the mouse button a black line is added to the drawing:</p>
<pre style="padding-left: 60px">      m_nextColor = Qt::black; 
      m_nextFilled = false; 
      m_actionMode = Add; 
      m_addFigureId = LineId; 
    } </pre>
<p>The <kbd>writeFile</kbd> method is called when the user selects the <kbd>Save</kbd> or <kbd>Save As</kbd> menu items:</p>
<pre style="padding-left: 60px">    bool DrawingWidget::writeFile(const QString&amp; filePath) { 
      ofstream outStream(filePath.toStdString()); </pre>
<p>If the file was successfully opened, we start by writing the next color and filled status:</p>
<pre style="padding-left: 60px">  if (outStream) { 
    writeColor(outStream, m_nextColor); 
    outStream.write((char*) &amp;m_nextFilled, sizeof m_nextFilled); </pre>
<p>We then write the number of figures in the drawing, and then we write the figures themselves:</p>
<pre style="padding-left: 60px">      int size = m_figurePtrList.size(); 
      outStream.write((char*) &amp;size, sizeof size); </pre>
<p>For each figure, first we write its identity value, we then write the figure itself by calling <kbd>write</kbd> on its pointer. Note that we do not know which class the figure pointer points at. We do not need to know that, since <kbd>write</kbd> is a pure virtual method in the base class <kbd>Figure</kbd>:</p>
<pre style="padding-left: 60px">    for (Figure* figurePtr : m_figurePtrList) { 
      FigureId figureId = figurePtr-&gt;getId(); 
      outStream.write((char*) &amp;figureId, sizeof figureId); 
      figurePtr-&gt;write(outStream); 
    } </pre>
<p>We return the output stream converted to <kbd>bool</kbd>, which is true if the writing was successful:</p>
<pre style="padding-left: 60px">    return ((bool) outStream); 
  } </pre>
<p>If the file was not successfully opened, we return <kbd>false</kbd>:</p>
<pre style="padding-left: 60px">   return false; 
  } </pre>
<p>The <kbd>readFile</kbd> method is called when the user selects the <span class="packt_screen">Open</span> menu item. We read the parts of the file in the same order as we wrote them in the preceding <kbd>writeFile</kbd>:</p>
<pre style="padding-left: 60px">    bool DrawingWidget::readFile(const QString&amp; filePath) { 
      ifstream inStream(filePath.toStdString()); </pre>
<p>If the file was successfully opened, we start by reading the next color and filled status:</p>
<pre style="padding-left: 60px">    if (inStream) { 
      readColor(inStream, m_nextColor); 
      inStream.read((char*) &amp;m_nextFilled, sizeof m_nextFilled);</pre>
<p>We then write the number of figures in the drawing, and then we write the figures themselves:</p>
<pre style="padding-left: 60px">    int size; 
    inStream.read((char*) &amp;size, sizeof size); </pre>
<p>For each figure, first we read its identity value, we then create a figure of the class indicated by the identity value by calling <kbd>createFigure</kbd>. Finally, we read the figure itself by calling <kbd>write</kbd> on its pointer:</p>
<pre style="padding-left: 60px">    for (int count = 0; count &lt; size; ++count) { 
      FigureId figureId = (FigureId) 0; 
      inStream.read((char*) &amp;figureId, sizeof figureId); 
      Figure* figurePtr = createFigure(figureId); 
      figurePtr-&gt;read(inStream); 
      m_figurePtrList.push_back(figurePtr); 
    } </pre>
<p>We return the input stream converted to <kbd>bool</kbd>, which is true if the reading was successful:</p>
<pre style="padding-left: 60px">     return ((bool) inStream); 
   } </pre>
<p>If the file was not successfully opened, we return <kbd>false</kbd>:</p>
<pre style="padding-left: 60px">  return false; 
} </pre>
<p>The <kbd>createFigure</kbd> method dynamically creates an object of the <kbd>Line</kbd>, <kbd>RectangleX</kbd>, or <kbd>EllipseX</kbd> class, depending on the value of the <kbd>figureId</kbd> parameter:</p>
<pre style="padding-left: 60px">    Figure* DrawingWidget::createFigure(FigureId figureId) { 
      Figure* figurePtr = nullptr; 
 
      switch (figureId) { 
        case LineId: 
         figurePtr = new Line(); 
         break; 
 
         case RectangleId: 
         figurePtr = new RectangleX(); 
         break; 
 
         case EllipseId: 
         figurePtr = new EllipseX(); 
         break; 
      } 
 
      return figurePtr; 
    } </pre>
<p>The <kbd>isCopyEnable</kbd> method is called before the <span class="packt_screen">Edit</span> menu becomes visible in order to enable the Copy item. It is also called by the framework in order to enable the Copy toolbar icon. It returns <kbd>true</kbd> if at least one figure is marked, and by then it is ready to be copied. If it returns <kbd>true</kbd>, the Copy item and toolbar icon become enabled:</p>
<pre style="padding-left: 60px">    bool DrawingWidget::isCopyEnabled() { 
      for (Figure* figurePtr : m_figurePtrList) { 
        if (figurePtr-&gt;marked()) { 
          return true; 
        } 
      } 
 
      return false; 
    } </pre>
<p>The <kbd>onCopy</kbd> method is called when the user selects the <span class="packt_screen">Copy</span> menu item. To start with, it deallocates every figure in the copy pointer list and clears the list itself:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onCopy(void) { 
      for (Figure* copyPtr : m_copyPtrList) { 
         delete copyPtr; 
      } 
  
      m_copyPtrList.clear(); </pre>
<p>Then, we iterate through the figure pointer list and add the pointer to a copy of each marked figure to the copy pointer list. We call <kbd>clone</kbd> on each figure pointer to provide us with the copy:</p>
<pre style="padding-left: 60px">   for (Figure* figurePtr : m_figurePtrList) { 
     if (figurePtr-&gt;marked()) { 
       m_copyPtrList.push_back(figurePtr-&gt;clone()); 
     } 
   } 
} </pre>
<p>The <kbd>isPasteEnabled</kbd> method is called before the <span class="packt_screen">Edit</span> menu becomes visible to enable the Paste item. It is also called by the framework to enable the paste toolbar icon. If the copy pointer list is not empty, it returns <kbd>true</kbd>, and thereby enables the Paste item and image. That is, it returns <kbd>true</kbd> if there are figures ready to be pasted:</p>
<pre style="padding-left: 60px">   bool DrawingWidget::isPasteEnabled() { 
      return !m_copyPtrList.isEmpty(); 
   } </pre>
<p>The <kbd>onPaste</kbd> method is called when the user selects the <span class="packt_screen">Paste</span> item in the <span class="packt_screen">Edit</span> menu, or when they select the paste image in the edit toolbar. We iterate through the copy pointer list and add a copy (which we obtain by calling <kbd>clone</kbd>) of the figure to the figure pointer list, after we have moved it 10 pixels downwards and to the right:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onPaste(void) { 
      for (Figure* copyPtr : m_copyPtrList) { 
        Figure* pastePtr = copyPtr-&gt;clone(); 
        pastePtr-&gt;move(QSize(10, 10)); 
        m_figurePtrList.push_back(pastePtr); 
      } </pre>
<p>Finally, when the figures have been added to the list, we force an eventual call to the <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">     update(); 
  } </pre>
<p>The <kbd>onDelete</kbd> method is called every time the user selects the <span class="packt_screen">Delete</span> menu item or toolbar icon. We iterate through the figure pointer list and remove every marked figure:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onDelete(void) { 
       for (Figure* figurePtr : m_figurePtrList) { 
         if (figurePtr-&gt;marked()) { 
         m_figurePtrList.removeOne(figurePtr); 
         delete figurePtr; 
       } 
     } </pre>
<p>Also, in this case, we force an eventual call to <kbd>paintEvent</kbd> by calling the <kbd>update</kbd> method, after the figures have been deleted:</p>
<pre style="padding-left: 60px">     update(); 
  } </pre>
<p>The <kbd>onColor</kbd> method is called every time the user selects the <kbd>Color</kbd> item in the <span class="packt_screen">Format</span> menu. We start by obtaining the new color by calling the static method <kbd>getColor</kbd> in the Qt <kbd>QColorDialog</kbd> class:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onColor(void) { 
      QColor newColor = QColorDialog::getColor(m_nextColor, this); </pre>
<p>If the color is valid, which it is if the user has closed the dialog by pressing the <span class="packt_screen">Ok</span> button rather than the <span class="packt_screen">Cancel</span> button, and if they have chosen a new color, we set the next color to the new color and set the modified flag. We also iterate through the figure pointer list and, for each marked figure, set the color of the figure:</p>
<pre style="padding-left: 60px">    if (newColor.isValid() &amp;&amp; (m_nextColor != newColor)) { 
      m_nextColor = newColor; 
      setModifiedFlag(true); 
 
      for (Figure* figurePtr : m_figurePtrList) { 
        if (figurePtr-&gt;marked()) { 
          figurePtr-&gt;color() = m_nextColor; </pre>
<p>If at least one figure is marked, we force an eventual call to <kbd>paintEvent</kbd> by calling update:</p>
<pre style="padding-left: 60px">          update(); 
         } 
       } 
     } 
   } </pre>
<p>The <kbd>isFillEnabled</kbd> method is called before the <kbd>Fill</kbd> item in the <span class="packt_screen">Format</span> menu becomes visible:</p>
<pre style="padding-left: 60px">    bool DrawingWidget::isFillEnabled(void) { 
      switch (m_actionMode) { </pre>
<p>In <kbd>Modify</kbd> mode, we iterate through the figure pointer list. If at least one rectangle or ellipse is marked, we return <kbd>true</kbd> and the item becomes enabled:</p>
<pre style="padding-left: 60px">    case Modify: 
      for (Figure* figurePtr : m_figurePtrList) { 
        if (figurePtr-&gt;marked() &amp;&amp; 
            ((figurePtr-&gt;getId() == RectangleId) || 
             (figurePtr-&gt;getId() == EllipseId))) { 
          return true; 
        } 
      } </pre>
<p>If no rectangle or ellipse is marked, we return <kbd>false</kbd> and the item becomes disabled:</p>
<pre style="padding-left: 60px">      return false; </pre>
<p>In the <kbd>Add</kbd> mode, we return <kbd>true</kbd> if the next figure to be added by the user is a rectangle or an ellipse:</p>
<pre style="padding-left: 60px">    case Add: 
      return (m_addFigureId == RectangleId) || 
             (m_addFigureId == EllipseId); 
    } </pre>
<p>We are not supposed to reach this point. The <kbd>assert</kbd> macro call is for debugging purposes only. However, we still must return a value at the end of the method:</p>
<pre style="padding-left: 60px">    assert(false); 
    return true; 
   } </pre>
<p>The <kbd>onFill</kbd> method is called when the user selects the <kbd>Fill</kbd> item in the <span class="packt_screen">Format</span> menu:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onFill(void) { 
      switch (m_actionMode) { </pre>
<p>In the <kbd>Modify</kbd> mode, we iterate through the figure pointer list and invert the filled status of all marked figures. If at least one figure changes, we force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">    case Modify: 
      for (Figure* figurePtr : m_figurePtrList) { 
        if (figurePtr-&gt;marked()) { 
          figurePtr-&gt;filled() = !figurePtr-&gt;filled(); 
          update(); 
        } 
      } </pre>
<p>We also invert the filled status of the next figure to be added:</p>
<pre style="padding-left: 60px">      m_nextFilled = !m_nextFilled; 
      break; </pre>
<p>In the <kbd>Add</kbd> mode, we invert the filled status of the next figure to be added by the user:</p>
<pre style="padding-left: 60px">    case Add: 
       m_nextFilled = !m_nextFilled; 
       break; 
    } 
  } </pre>
<p>The <kbd>isModifyChecked</kbd> method is called before the <kbd>Modify</kbd> item in the <span class="packt_screen">Format</span> menu becomes visible. In <kbd>Modify</kbd> mode, it returns <kbd>true</kbd> and enables the item:</p>
<pre style="padding-left: 60px">    bool DrawingWidget::isModifyChecked(void) { 
      return (m_actionMode == Modify); 
    } </pre>
<p>The <kbd>onModify</kbd> method is called when the user selects the <kbd>Modify</kbd> item in the <span class="packt_screen">Format</span> menu. It sets the action mode to <kbd>Modify</kbd>:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onModify(void) { 
      m_actionMode = Modify; 
    } </pre>
<p>The <kbd>isLineChecked</kbd> method is called before the <kbd>Line</kbd> item in the <kbd>Add</kbd> submenu becomes visible. It returns <kbd>true</kbd>, and the item becomes checked (with a radio button, since the item belongs to a group) in case of add action mode, and the next figure to be added is a line:</p>
<pre style="padding-left: 60px">    bool DrawingWidget::isLineChecked(void) { 
      return (m_actionMode == Add) &amp;&amp; (m_addFigureId == LineId); 
    } </pre>
<p>The <kbd>onLine</kbd> method is called when the user selects the <kbd>Line</kbd> item in the <kbd>Add</kbd> submenu. It set the action mode to <kbd>Add</kbd> and the next figure to be added by the user to a line:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onLine(void) { 
      m_actionMode = Add; 
      m_addFigureId = LineId; 
    } </pre>
<p>The <kbd>isRectangleChecked</kbd> method is called before the <kbd>Rectangle</kbd> item in the <kbd>Add</kbd> submenu becomes visible. It returns <kbd>true</kbd> in case of <kbd>Add</kbd> action mode and if the next figure to be added is a rectangle:</p>
<pre style="padding-left: 30px">    bool DrawingWidget::isRectangleChecked(void) { 
      return (m_actionMode == Add) &amp;&amp; (m_addFigureId == RectangleId); 
    } </pre>
<p>The <kbd>onRectangle</kbd> method is called when the user selects the <kbd>Rectangle</kbd> item. It sets the action mode to <kbd>Add</kbd> and the next figure to be added by the user to a rectangle:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onRectangle(void) { 
      m_actionMode = Add; 
      m_addFigureId = RectangleId; 
    } </pre>
<p>The <kbd>isEllipseChecked</kbd> method is called before the <kbd>Ellipse</kbd> item in the <kbd>Add</kbd> submenu becomes visible. It returns <kbd>true</kbd> in case of <kbd>Add</kbd> action mode and if the next figure to be added is an ellipse:</p>
<pre style="padding-left: 60px">    bool DrawingWidget::isEllipseEnabled(void) { 
      return !isEllipseChecked(); 
    } </pre>
<p>The <kbd>onEllipse</kbd> method is called when the user selects the <kbd>Ellipse</kbd> item. It sets the action mode to <kbd>Add</kbd> and the next figure to be added by the user to an ellipse:</p>
<pre style="padding-left: 60px">    void DrawingWidget::onEllipse(void) { 
      m_actionMode = Add; 
      m_addFigureId = EllipseId; 
    }  </pre>
<p>The <kbd>mousePressEvent</kbd> method is called when the user presses one of the mouse buttons. We store the mouse point in <kbd>m_mousePoint</kbd>, to be used in <kbd>mouseMoveEvent</kbd> as follows:</p>
<pre style="padding-left: 60px">    void DrawingWidget::mousePressEvent(QMouseEvent* eventPtr) { 
       if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
       m_mousePoint = eventPtr-&gt;pos(); </pre>
<p>In case of <kbd>Modify</kbd> mode, we first iterate through the figure pointer list and unmark every figure:</p>
<pre style="padding-left: 60px">    switch (m_actionMode) { 
      case Modify: { 
          for (Figure* figurePtr : m_figurePtrList) { 
           figurePtr-&gt;marked() = false; 
          } </pre>
<p>We then iterate through the list again, to find if the user has hit a figure. Since the top-most figure is placed at the end of the list, we need to iterate through the list backward. We do so by using the <kbd>reverse_iterator</kbd> type of the Qt <kbd>QList</kbd> class:</p>
<pre style="padding-left: 60px">     m_clickedFigurePtr = nullptr; 
     for (QList&lt;Figure*&gt;::reverse_iterator iterator = 
         m_figurePtrList.rbegin(); 
     iterator != m_figurePtrList.rend(); ++iterator) { 
        Figure* figurePtr = *iterator; </pre>
<p>If we found out (by calling <kbd>isClick</kbd> on the figure) that a figure has been hit by the user's mouse click, we set the application mode to <kbd>ModifySingle</kbd> and mark the figure. We also remove it from the list and add it to the end of the list, to make it appear top-most in the drawing. Finally, we break the loop since we have found a figure:</p>
<pre style="padding-left: 60px">    if (figurePtr-&gt;isClick(m_mousePoint)) { 
      setApplicationMode(ModifySingle); 
      m_clickedFigurePtr = figurePtr; 
      figurePtr-&gt;marked() = true; 
      m_figurePtrList.removeOne(figurePtr); 
      m_figurePtrList.push_back(figurePtr); 
      break; 
    } 
  } </pre>
<p>If we have not found a figure, we set the application mode to <kbd>ModifyRectangle</kbd> and initialize the top-most and bottom-right corners of the enclosing rectangle to the mouse point:</p>
<pre style="padding-left: 60px">    if (m_clickedFigurePtr == nullptr) { 
      setApplicationMode(ModifyRectangle); 
      m_insideRectangle = QRect(m_mousePoint, m_mousePoint); 
    } 
    } 
    break; </pre>
<p>In case of <kbd>Add</kbd> action mode, we create a new figure by calling <kbd>createFigure</kbd> with the identity of the next figure to be added by the user as a parameter. We then set the color, filled status of the new figure, and initialize its endpoints:</p>
<pre style="padding-left: 60px">      case Add: { 
          Figure* newFigurePtr = createFigure(m_addFigureId); 
          newFigurePtr-&gt;color() = m_nextColor; 
          newFigurePtr-&gt;filled() = m_nextFilled; 
          newFigurePtr-&gt;initializePoints(m_mousePoint); </pre>
<p>When the new figure has been created and initialized, we add it at the end of the figure pointer list and set the application mode to <kbd>ModifySingle</kbd>, since the <kbd>mouseMoveEvent</kbd> method will continue to modify the last figure in the list, just as if the user had hit a figure in the <kbd>Modify</kbd> mode. We also set the modified flag since we have added a figure to the drawing:</p>
<pre style="padding-left: 60px">      m_figurePtrList.push_back(newFigurePtr); 
      setApplicationMode(ModifySingle); 
      setModifiedFlag(true); 
      } 
      break; 
    } </pre>
<p>Finally, we force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">        update(); 
      } 
    } </pre>
<p>The <kbd>mouseMoveEvent</kbd> method is called when the user moves the mouse. If they also press the left mouse button, we save the mouse point to future calls to <kbd>mouseMoveEvent</kbd> and calculate the distance since the last call to <kbd>mousePressEvent</kbd> or <kbd>mouseMoveEvent</kbd>:</p>
<pre style="padding-left: 60px">    void DrawingWidget::mouseMoveEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
        QPoint newMousePoint = eventPtr-&gt;pos(); 
        QSize distance(newMousePoint.x() - m_mousePoint.x(), 
                       newMousePoint.y() - m_mousePoint.y()); 
        m_mousePoint = newMousePoint; </pre>
<p>In the <kbd>Modify</kbd> mode, we modify the current figure (the figure placed at the end of the figure pointer list) by calling <kbd>modify</kbd>. Remember that the figure can be either modified or moved, depending on the settings in the call to <kbd>isClick</kbd> in <kbd>onMousePress</kbd> previously. We also set the modified flag since the figure has been altered:</p>
<pre style="padding-left: 60px">    switch (m_applicationMode) { 
      case ModifySingle: 
        m_figurePtrList.back()-&gt;modify(distance); 
        setModifiedFlag(true); 
        break; </pre>
<p>In case of the enclosing rectangle, we just update its bottom-right corner. Note that we do not set the modified flag since no figure has yet been altered:</p>
<pre style="padding-left: 60px">    case ModifyRectangle: 
      m_insideRectangle.setBottomRight(m_mousePoint); 
      break; 
    } </pre>
<p>Finally, we force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">        update(); 
      } 
   } </pre>
<p>The <kbd>mouseReleaseEvent</kbd> method is called when the user releases a mouse button. If it is the left mouse button, we check the application mode. The only mode we actually are interested in is the enclosing rectangle mode:</p>
<pre style="padding-left: 60px">     void DrawingWidget::mouseReleaseEvent(QMouseEvent* eventPtr) { 
       if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
         switch (m_applicationMode) { 
           case ModifyRectangle: { 
             QList&lt;Figure*&gt; insidePtrList; </pre>
<p>We iterate through the figure pointer list and call <kbd>isInside</kbd> on each figure. Each figure that is completely enclosed by the rectangle becomes marked, removed from the list, and added to <kbd>insidePtrList</kbd> to be later added at the end of the figure pointer list:</p>
<pre style="padding-left: 60px">    for (Figure* figurePtr : m_figurePtrList) { 
      if (figurePtr-&gt;isInside(m_insideRectangle)) { 
        figurePtr-&gt;marked() = true; 
        m_figurePtrList.removeOne(figurePtr); 
        insidePtrList.push_back(figurePtr); 
      } 
    } </pre>
<p>Each figure which is completely enclosed by the rectangle is removed from the figure pointer list:</p>
<pre style="padding-left: 60px">    for (Figure* figurePtr : insidePtrList) { 
      m_figurePtrList.removeOne(figurePtr); 
    } </pre>
<p>Finally, all enclosed figures are added at the end of the list in order to appear top-most in the drawing:</p>
<pre style="padding-left: 60px">    m_figurePtrList.append(insidePtrList); 
    } 
    break; 
    } </pre>
<p>When the user has released the mouse button, the application mode is set to idle, and we force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">       setApplicationMode(Idle); 
       update(); 
      } 
    } </pre>
<p>The <kbd>mouseDoubleClick</kbd> method is called when the user double-clicks one of the buttons. However, <kbd>mouseClickEvent</kbd> is always called before <kbd>mouseDoubleClickEvent</kbd>. If the preceding call to <kbd>mouseClickEvent</kbd> has made <kbd>m_clickedFigurePtr</kbd> point at the clicked figure, we call <kbd>doubleClick</kbd> on that figure. This may cause some change in the figure, depending on which kind of figure it is:</p>
<pre style="padding-left: 60px">    void DrawingWidget::mouseDoubleClickEvent(QMouseEvent <br/>       *eventPtr) { 
      if ((eventPtr-&gt;buttons() == Qt::LeftButton) &amp;&amp; 
          (m_clickedFigurePtr != nullptr)) { 
        m_clickedFigurePtr-&gt;doubleClick(eventPtr-&gt;pos()); 
        update(); 
      } 
    } </pre>
<p>Finally, <kbd>paintEvent</kbd> is called when the content of the window needs to be repainted. Before the call, the framework clears the window:</p>
<pre style="padding-left: 60px">    void DrawingWidget::paintEvent(QPaintEvent* /* <br/>       eventPtr */) { 
     QPainter painter(this); 
     painter.setRenderHint(QPainter::Antialiasing); 
     painter.setRenderHint(QPainter::TextAntialiasing); </pre>
<p>We iterate through the figure pointer list and draw every figure. The last figure in the list is placed at the end of the list, to appear at the top of the drawing:</p>
<pre style="padding-left: 60px">     for (Figure* figurePtr : m_figurePtrList) { 
       figurePtr-&gt;draw(painter); 
     } </pre>
<p>In case of enclosing rectangle mode, we draw a hollow rectangle with a light-gray border:</p>
<pre style="padding-left: 60px">    if (m_applicationMode == ModifyRectangle) { 
      painter.setPen(Qt::lightGray); 
      painter.setBrush(Qt::NoBrush); 
      painter.drawRect(m_insideRectangle); 
    } 
  } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main function</h1>
                </header>
            
            <article>
                
<p>The <kbd>main</kbd> function is similar to the <kbd>main</kbd> function of the previous applications—it creates an application, shows the drawing window, and starts the execution of the application.</p>
<p><strong>Main.cpp:</strong></p>
<pre style="padding-left: 60px">    #include "DrawingWindow.h" 
    #include &lt;QApplication&gt; 
 
    int main(int argc, char *argv[]) { 
      QApplication application(argc, argv); 
      DrawingWindow drawingWindow; 
      drawingWindow.show(); 
      return application.exec(); 
    } </pre>
<p>The output is shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e32d6956-fb1d-4513-bb7f-b7b7529a3466.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving the editor</h1>
                </header>
            
            <article>
                
<p>The editor of this chapter is a more advanced version of the editor of <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em>. In this version, it is possible to change the font and alignment of the text, to mark text, and to cut and paste text.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The EditorWindow class</h1>
                </header>
            
            <article>
                
<p>The <kbd>EditorWindow</kbd> class of this chapter is similar to the class of <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&amp;action=edit#post_67" target="_blank">Chapter 5</a><span>, </span><em>Qt Graphical Applications</em>. It catches the key pressing event and the window closing event.</p>
<p><strong>EditorWindow.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef EDITORWINDOW_H 
    #define EDITORWINDOW_H 
 
    #include &lt;QMainWindow&gt; 
    #include &lt;QActionGroup&gt; 
    #include &lt;QPair&gt; 
    #include &lt;QMap&gt; 
 
    #include "..\MainWindow\MainWindow.h" 
    #include "EditorWidget.h" 
 
    class EditorWindow : public MainWindow { 
      Q_OBJECT 
 
      public: 
      EditorWindow(QWidget *parentWidgetPtr = nullptr); 
      ~EditorWindow(); 
 
      protected: 
      void keyPressEvent(QKeyEvent* eventPtr); 
      void closeEvent(QCloseEvent* eventPtr); 
 
      private: 
      EditorWidget* m_editorWidgetPtr; 
      QActionGroup* m_alignmentGroupPtr; 
    }; 
 
    #endif // EDITORWINDOW_H </pre>
<p><strong>EditorWindow.cpp:</strong></p>
<pre style="padding-left: 60px">#include "EditorWindow.h" 
#include &lt;QtWidgets&gt; </pre>
<p>The constructor initializes the editor window. It sets the size of the window to <em>1000 x 500</em> pixels. It also dynamically creates an editor widget and adds the standard <span class="packt_screen">File</span> and <span class="packt_screen">Edit</span> menus:</p>
<pre style="padding-left: 60px">EditorWindow::EditorWindow(QWidget *parentWidgetPtr /*= nullptr*/)<br/> :MainWindow(parentWidgetPtr) {<br/>  resize(1000, 500);<br/><br/>  m_editorWidgetPtr = new EditorWidget(this);<br/>  setCentralWidget(m_editorWidgetPtr);<br/>  addFileMenu();<br/>  addEditMenu();</pre>
<p>The Figure menu is different, compared to <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em>. We add the item <kbd>Font</kbd> and the submenu Alignment, to which, in turn, we add the three items: left, center, and right:</p>
<pre style="padding-left: 60px">      { QMenu* formatMenuPtr = menuBar()-&gt;addMenu(tr("F&amp;ormat")); 
       connect(formatMenuPtr, SIGNAL(aboutToShow()), this, 
            SLOT(onMenuShow())); 
       addAction(formatMenuPtr, tr("&amp;Font"), SLOT(onFont()), 
              0, QString(), nullptr, QString(), 
              LISTENER(isFontEnabled)); 
 
       { QMenu* alignmentMenuPtr = 
             formatMenuPtr-&gt;addMenu(tr("&amp;Alignment")); 
        connect(alignmentMenuPtr, SIGNAL(aboutToShow()), 
              this, SLOT(onMenuShow())); </pre>
<p>We also add a toolbar for the <kbd>Alignment</kbd> menu:</p>
<pre style="padding-left: 60px">       QToolBar* alignmentToolBarPtr = addToolBar(tr("Alignment")); 
       m_alignmentGroupPtr = new QActionGroup(this); 
 
       addAction(alignmentMenuPtr, tr("&amp;Left"), SLOT(onLeft()), 
                QKeySequence(Qt::ALT + Qt::Key_L), tr("left"), 
                alignmentToolBarPtr, tr("Left-aligned text"), 
                nullptr, LISTENER(isLeftChecked)); 
       addAction(alignmentMenuPtr, tr("&amp;Center"), 
                SLOT(onCenter()), 
                QKeySequence(Qt::ALT + Qt::Key_C), 
                tr("center"), alignmentToolBarPtr, 
                tr("Center-aligned text"), nullptr, 
                LISTENER(isCenterChecked)); 
       addAction(alignmentMenuPtr, tr("&amp;Right"), 
                SLOT(onRight()), 
                QKeySequence(Qt::ALT + Qt::Key_R), 
                tr("right"), alignmentToolBarPtr, 
                tr("Right-aligned text"), nullptr, 
                LISTENER(isRightChecked)); 
       } 
     } 
 
     m_editorWidgetPtr-&gt;setModifiedFlag(false); 
    } 
 
    EditorWindow::~EditorWindow() { 
     delete m_alignmentGroupPtr; 
    } </pre>
<p>The key pressing event and the window closing event are passed on to the editor widget:</p>
<pre style="padding-left: 60px">    void EditorWindow::keyPressEvent(QKeyEvent* eventPtr) { 
      m_editorWidgetPtr-&gt;keyPressEvent(eventPtr); 
    }</pre>
<pre style="padding-left: 60px"> 
    void EditorWindow::closeEvent(QCloseEvent* eventPtr) { 
      m_editorWidgetPtr-&gt;closeEvent(eventPtr); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The EditorWidget class</h1>
                </header>
            
            <article>
                
<p>The <kbd>EditorWidget</kbd> class is similar to the version of <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em>. However, methods and listeners to handle the font and alignment have been added.</p>
<p><strong>EditorWidget.h:</strong></p>
<pre style="padding-left: 60px">    #ifndef EDITORWIDGET_H 
    #define EDITORWIDGET_H 
 
    #include &lt;QWidget&gt; 
    #include &lt;QMap&gt; 
    #include &lt;QMenu&gt; 
    #include &lt;QToolBar&gt; 
    #include &lt;QPair&gt; 
    #include "Caret.h" 
 
    #include "..\MainWindow\Listener.h" 
    #include "..\MainWindow\DocumentWidget.h" 
 
    class EditorWidget : public DocumentWidget { 
      Q_OBJECT 
 
      public: 
      EditorWidget(QWidget* parentWidgetPtr); 
      void keyPressEvent(QKeyEvent* eventPtr); 
 
      private: 
      void keyEditPressEvent(QKeyEvent* eventPtr); 
      void keyMarkPressEvent(QKeyEvent* eventPtr); </pre>
<p>The <kbd>mousePresseEvent</kbd>, <kbd>mouseMoveEvent</kbd>, and <kbd>mouseReleaseEvent</kbd> are called when the user presses a mouse button, moves the mouse, and releases the mouse button:</p>
<pre style="padding-left: 60px">    public: 
      void mousePressEvent(QMouseEvent* eventPtr); 
      void mouseMoveEvent(QMouseEvent* eventPtr); 
      void mouseReleaseEvent(QMouseEvent* eventPtr); 
 
    private: 
      int mouseToIndex(QPoint point); 
 
    public: 
      void paintEvent(QPaintEvent* eventPtr); 
      void resizeEvent(QResizeEvent* eventPtr); </pre>
<p>The <kbd>newDocument</kbd> method is called when the user selects the <span class="packt_screen">New</span> menu item, <kbd>writeFile</kbd> is called when they select <span class="packt_screen">Save</span> or <span class="packt_screen">Save As</span>, and <kbd>readFile</kbd> is called when they select the <span class="packt_screen">Open</span> menu item:</p>
<pre style="padding-left: 60px">    private: 
      void newDocument(void); 
      bool writeFile(const QString&amp; filePath); 
      bool readFile(const QString&amp; filePath); 
 
    public slots: 
      bool isCopyEnabled(); 
      void onCopy(void); 
      bool isPasteEnabled(); 
      void onPaste(void); 
      void onDelete(void); 
 
      DEFINE_LISTENER(EditorWidget, isFontEnabled); 
      void onFont(void); </pre>
<p>The <kbd>isLeftChecked</kbd>, <kbd>isCenterChecked</kbd>, and <kbd>isRightChecked</kbd> methods are called before the <kbd>Alignment</kbd> submenu becomes visible. They then annotate a radio button to the selected alignment:</p>
<pre style="padding-left: 60px">    DEFINE_LISTENER(EditorWidget, isLeftChecked); 
    DEFINE_LISTENER(EditorWidget, isCenterChecked); 
    DEFINE_LISTENER(EditorWidget, isRightChecked); </pre>
<p>The <kbd>onLeft</kbd>, <kbd>onCenter</kbd>, and <kbd>onRight</kbd> methods are called when the user selects one of the items of the Alignment submenu:</p>
<pre style="padding-left: 60px">      void onLeft(void); 
      void onCenter(void); 
      void onRight(void); 
 
      private: 
       void setCaret(); 
       void simulateMouseClick(int x, int y); </pre>
<p>In this version of the editor, we have two modes—edit and mark. The edit mark is active when the user inputs text or moves the caret with the arrow key, while the mark mode is active when the user has marked a block of the code with the mouse. The caret is visible in edit mode, but not in mark mode:</p>
<pre style="padding-left: 60px">    private: 
      enum Mode {Edit, Mark} m_mode; </pre>
<p>The text can be aligned in the left, center, and right direction:</p>
<pre style="padding-left: 60px">     enum Alignment {Left, Center, Right} m_alignment; </pre>
<p>In edit mode, <kbd>m_editIndex</kbd> holds the index to place the next character to be input by the user, which also is the position of the caret. In mark mode, <kbd>m_firstIndex</kbd> and <kbd>m_lastIndex</kbd> hold the indexes of the first and last marked character:</p>
<pre style="padding-left: 60px">    int m_editIndex, m_firstIndex, m_lastIndex; </pre>
<p>The <kbd>m_caret</kbd> object holds the caret of the editor. The caret is visible in edit mode, but not in mark mode:</p>
<pre style="padding-left: 60px">    Caret m_caret; </pre>
<p>The <kbd>m_editorText</kbd> field holds the text of the editor, and <kbd>m_copyText</kbd> holds the text which is cut or pasted by the user:</p>
<pre style="padding-left: 60px">     QString m_editorText, m_copyText; </pre>
<p>The text of the editor is divided into lines; the index of the first and last character of each line is stored in <kbd>m_lineList</kbd>:</p>
<pre style="padding-left: 60px">    QList&lt;QPair&lt;int,int&gt;&gt; m_lineList; </pre>
<p>The current font of the text is stored in <kbd>m_textFont</kbd>. The height in pixels of a character of the current font is stored in <kbd>m_fontHeight</kbd>:</p>
<pre style="padding-left: 60px">    QFont m_textFont; 
    int m_fontHeight; </pre>
<p>The <kbd>mousePressEvent</kbd> and <kbd>mouseMoveEvent</kbd> methods store the last mouse point in order to calculate the distance between mouse events:</p>
<pre style="padding-left: 60px">    Qt::MouseButton m_button; </pre>
<p>Similar to the method of <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em>, <kbd>calculate</kbd> is an auxiliary method that calculates the enclosing rectangle of each character of the text. However, the version of this chapter is more complicated since it has to take into consideration whether the text is left, center, or right-aligned:</p>
<pre style="padding-left: 60px">    void calculate(); </pre>
<p>The enclosing rectangles are stored in <kbd>m_rectList</kbd>, and then used by the caret and <kbd>paintEvent</kbd>:</p>
<pre style="padding-left: 60px">     QList&lt;QRect&gt; m_rectList; 
    }; 
 
    #endif // EDITORWIDGET_H </pre>
<p><strong>EditorWidget.cpp:</strong></p>
<pre style="padding-left: 60px">    #include "EditorWidget.h" 
    #include &lt;QtWidgets&gt; 
    #include &lt;CAssert&gt; 
    using namespace std; </pre>
<p>The constructor sets the window header to <kbd>Editor Advanced</kbd> and the file suffix to <kbd>edi</kbd>:</p>
<pre style="padding-left: 60px">    EditorWidget::EditorWidget(QWidget* parentWidgetPtr) 
     :DocumentWidget(tr("Editor Advanced"), 
         tr("Editor files (*.edi)"), parentWidgetPtr), </pre>
<p>The text font is initialized to <kbd>12</kbd> point <kbd>Times New Roman</kbd>. The application mode is set to edit, the index of the next character to be input by the user is set to zero, and the text is left- aligned from the beginning:</p>
<pre style="padding-left: 60px">      m_textFont(tr("Times New Roman"), 12), 
        m_mode(Edit), 
        m_editIndex(0), 
        m_alignment(Left), 
        m_caret(this) { </pre>
<p>The rectangles enclosing the characters are calculated by <kbd>calculate</kbd>, the caret is initialized and shown since the application holds edit mode from the beginning:</p>
<pre style="padding-left: 60px">     calculate(); 
     setCaret(); 
     m_caret.show(); 
   } </pre>
<p>The <kbd>newDocument</kbd> method is called when the user selects the <span class="packt_screen">New</span> menu item. We start by setting the application mode to edit and the edit index to zero. The text font is set to <kbd>12</kbd> point Times New Roman. The text of the editor is cleared, the rectangles enclosing the characters are calculated by <kbd>calculate</kbd>, and the caret is set:</p>
<pre style="padding-left: 60px">    void EditorWidget::newDocument(void) { 
      m_mode = Edit; 
      m_editIndex = 0; 
      m_textFont = QFont(tr("Times New Roman"), 12); 
      m_editorText.clear(); 
      calculate(); 
      setCaret(); 
    } </pre>
<p>The <kbd>writeFile</kbd> method is called when the user selects the <span class="packt_screen">Save</span> or <span class="packt_screen">Save As</span> menu items. The file format is quite simple: we write the font on the first line, and then the text of the editor on the following lines:</p>
<pre style="padding-left: 60px">    bool EditorWidget::writeFile(const QString&amp; filePath) { 
      QFile file(filePath); 
      if (file.open(QIODevice::WriteOnly | QIODevice::Text)) { 
      QTextStream outStream(&amp;file); 
      outStream &lt;&lt; m_textFont.toString() &lt;&lt; endl &lt;&lt; m_editorText; </pre>
<p>We use the <kbd>Ok</kbd> field of the input stream to decide if the writing was successful:</p>
<pre style="padding-left: 60px">     return ((bool) outStream.Ok); 
   } </pre>
<p>If we could not open the file for writing, we return <kbd>false</kbd>:</p>
<pre style="padding-left: 60px">     return false; 
   } </pre>
<p>The <kbd>readFile</kbd> method is called when the user selects the <span class="packt_screen">Open</span> menu items. Similar to <kbd>writeFile</kbd> previously, we read the first line and initialize the text font with the text. We then read the editor text:</p>
<pre style="padding-left: 60px">    bool EditorWidget::readFile(const QString&amp; filePath) { 
      QFile file(filePath); 
 
      if (file.open(QIODevice::ReadOnly | QIODevice::Text)) { 
        QTextStream inStream(&amp;file); 
        m_textFont.fromString(inStream.readLine()); 
        m_editorText = inStream.readAll(); </pre>
<p>When the text is read, we call <kbd>calculate</kbd> to calculate the rectangles enclosing the characters of the text. We then set the caret and return <kbd>true</kbd>, since the reading was successful:</p>
<pre style="padding-left: 60px">      calculate(); 
      setCaret(); </pre>
<p>We use the <kbd>Ok</kbd> field of the input stream to decide if the reading was successful:</p>
<pre style="padding-left: 60px">     return ((bool) inStream.Ok); 
    } </pre>
<p>If we could not open the file for reading, we <kbd>return false</kbd>:</p>
<pre style="padding-left: 60px">    return false; 
   } </pre>
<p>The <kbd>isCopyEnabled</kbd> method is called before the <span class="packt_screen">Edit</span> menu becomes visible. It is also called by the framework to decide whether the copy toolbar icon shall be enabled. It returns true (and the item becomes enabled) if the application holds mark mode, which means that the user has marked a part of the text, which can be copied:</p>
<pre style="padding-left: 60px">    bool EditorWidget::isCopyEnabled() { 
      return (m_mode == Mark); 
    } </pre>
<p>The <kbd>onCopy</kbd> method is called when the user selects the <span class="packt_screen">Copy</span> item. We copy the marked text into <kbd>m_EditorText</kbd>:</p>
<pre style="padding-left: 60px">    void EditorWidget::onCopy(void) { 
      int minIndex = qMin(m_firstIndex, m_lastIndex), 
      maxIndex = qMax(m_firstIndex, m_lastIndex); 
 
      m_copyText = 
        m_editorText.mid(minIndex, maxIndex - minIndex + 1); 
    } </pre>
<p>The <kbd>isPasteEnabled</kbd> method is also called before the <span class="packt_screen">Edit</span> menu becomes visible. It returns <kbd>true</kbd> (and the item becomes visible) if the copy text is not empty. That is, if there is a block of text that has been copied and is ready to be pasted:</p>
<pre style="padding-left: 60px">    bool EditorWidget::isPasteEnabled() { 
      return !m_copyText.isEmpty(); 
    } </pre>
<p>The <kbd>onPaste</kbd> method is called when the user selects the Paste menu item. In mark mode, we call <kbd>onDelete</kbd>, which causes the marked text to be deleted:</p>
<pre style="padding-left: 60px">    void EditorWidget::onPaste(void) { 
      if (m_mode == Mark) { 
         onDelete(); 
      } </pre>
<p>We then insert the copied text into the editor text. We also update <kbd>m_editIndex</kbd>, since the edit index after the text has been copied shall be the position after the inserted text:</p>
<pre style="padding-left: 60px">     m_editorText.insert(m_editIndex, m_copyText); 
     m_editIndex += m_copyText.size(); </pre>
<p>Finally, we calculate the rectangles enclosing the characters of the text, set the caret to the new index, set the modified flag since the text has been altered, and call <kbd>update</kbd> to force an eventual call to <kbd>paintEvent</kbd> in order to display the new text:</p>
<pre style="padding-left: 60px">     calculate(); 
     setCaret(); 
     setModifiedFlag(true); 
     update(); 
     } </pre>
<p>The <kbd>onDelete</kbd> method is called when the user selects the <span class="packt_screen">Delete</span> menu item or the <span class="packt_screen">Delete</span> toolbar icon. The effect is similar to the event when the user presses the <em>Delete</em> key. Therefore, we prepare a keypress event with the <em>Delete</em> key, which we use as a parameter in the call to <kbd>keyPressEvent</kbd>.</p>
<p>Note that there is no <kbd>isDeleteEnabled</kbd> method because the user can always use the <span class="packt_screen">Delete</span> item. In edit mode, the next character is deleted. In mark mode, the marked text is deleted:</p>
<pre style="padding-left: 60px">    void EditorWidget::onDelete(void) { 
      QKeyEvent event(QEvent::KeyPress, Qt::Key_Delete, 
                  Qt::NoModifier); 
      keyPressEvent(&amp;event); 
    } </pre>
<p><kbd>isCopyEnabled</kbd> is called before the <span class="packt_screen">Format</span> menu becomes visible. It returns <kbd>true</kbd> in edit mode, since it would be illogical to change the font on all characters when a subset of them is marked:</p>
<pre style="padding-left: 60px">    bool EditorWidget::isFontEnabled() { 
      return (m_mode == Edit); 
    } </pre>
<p>The <kbd>onFont</kbd> method is called when the user selects the <kbd>Font</kbd> menu item. We let the user select the new font with the Qt <kbd>QFontDialog</kbd> class:</p>
<pre style="padding-left: 60px">     void EditorWidget::onFont(void) { 
       bool pressedOkButton; 
       QFont newFont = 
         QFontDialog::getFont(&amp;pressedOkButton, m_textFont, this); </pre>
<p>If the user closes the dialog by pressing the <span class="packt_screen">Ok</span> button, we set the font of the editor (<kbd>m_textFont</kbd>) field and the modified flag:</p>
<pre style="padding-left: 60px">      if (pressedOkButton) { 
        m_textFont = newFont; 
        setModifiedFlag(true); </pre>
<p>We calculate the newly enclosed rectangles by calling <kbd>calculate</kbd>, set the caret, and force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">      calculate(); 
      m_caret.set(m_rectList[m_editIndex]); 
      update(); 
     } 
   } </pre>
<p>The <kbd>isLeftChecked</kbd>, <kbd>isCenterChecked</kbd>, and <kbd>isRightChecked</kbd> methods are called before the alignment submenu becomes visible. They return <kbd>true</kbd> to the current alignment:</p>
<pre style="padding-left: 60px">    bool EditorWidget::isLeftChecked(void) { 
      return (m_alignment == Left); 
    } 
 
    bool EditorWidget::isCenterChecked(void) { 
      return (m_alignment == Center); 
    } 
 
    bool EditorWidget::isRightChecked(void) { 
      return (m_alignment == Right); 
    } </pre>
<p>The <kbd>onLeft</kbd>, <kbd>onCenter</kbd>, and <kbd>onRight</kbd> methods are called when the user selects the <kbd>Left</kbd>, <kbd>Center</kbd>, and <kbd>Right</kbd> menu item. They set the alignment and the modified flag.</p>
<p>They also calculate the new enclosing rectangles, set the caret, and force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">    void EditorWidget::onLeft(void) { 
      m_alignment = Left; 
      setModifiedFlag(true); 
      calculate(); 
      setCaret(); 
      update(); 
    } 
 
    void EditorWidget::onCenter(void) { 
      m_alignment = Center; 
      setModifiedFlag(true); 
      calculate(); 
      setCaret(); 
      update(); 
    } 
 
    void EditorWidget::onRight(void) { 
      m_alignment = Right; 
      setModifiedFlag(true); 
      calculate(); 
      setCaret(); 
      update(); 
    } </pre>
<p>The <kbd>mousePressEvent</kbd> method is called when the user presses one of the mouse buttons. We call <kbd>mouseToIndex</kbd> to find the character index the user clicked on. For the time being, both the first and last mark index is set to the mouse index. The last index may later be changed by a call to <kbd>mouseMoveEvent</kbd> in the following snippet. Finally, the mode is set to mark, and the caret is hidden:</p>
<pre style="padding-left: 30px">    void EditorWidget::mousePressEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
         m_firstIndex = m_lastIndex = mouseToIndex(eventPtr-&gt;pos()); 
         m_mode = Mark; 
         m_caret.hide(); 
       } 
    } </pre>
<p>The <kbd>mouseMoveEvent</kbd> method is called when the user moves the mouse. We set the last mark index to the mouse index and force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">    void EditorWidget::mouseMoveEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
         m_lastIndex = mouseToIndex(eventPtr-&gt;pos()); 
         update(); 
      } 
    } </pre>
<p>The <kbd>mouseReleaseEvent</kbd> method is called when the user releases the mouse button. If the user has moved the mouse to the original start position of the mouse movement, there is nothing to mark and we set the application in edit mode. In that case, we set the edit index to the first mark index, and set and show the caret (since it shall be visible in edit mode). Finally, we force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">    void EditorWidget::mouseReleaseEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
        if (m_firstIndex == m_lastIndex) { 
          m_mode = Edit; 
          m_editIndex = m_firstIndex; 
          setCaret(); 
          m_caret.show(); 
          update(); 
        } 
      } 
    } </pre>
<p><kbd>keyPressEvent</kbd> is called when the user presses a key on the keyboard. Depending on the application mode (edit or mark), we call <kbd>keyEditPressEvent</kbd> or the following <kbd>keyMarkPressEvent</kbd> to further process the key event:</p>
<pre style="padding-left: 60px">     void EditorWidget::keyPressEvent(QKeyEvent* eventPtr) { 
       switch (m_mode) { 
         case Edit: 
         keyEditPressEvent(eventPtr); 
         break; 
 
         case Mark: 
         keyMarkPressEvent(eventPtr); 
         break; 
       } 
     }</pre>
<p><kbd>keyEditPressEvent</kbd> handles the key press in edit mode. First, we check if the key is an arrow key, page up or down, <em>Delete</em>, <em>Backspace</em>, or return key:</p>
<pre style="padding-left: 60px">    void EditorWidget::keyEditPressEvent(QKeyEvent* eventPtr) { 
      switch (eventPtr-&gt;key()) { </pre>
<p>In the case of the left-arrow key, we move the edit index one step backward, unless it is already at the beginning of the text:</p>
<pre style="padding-left: 60px">     case Qt::Key_Left: 
       if (m_editIndex &gt; 0) { 
          --m_editIndex; 
       } 
       break; </pre>
<p>In the case of the right-arrow key, we mode the edit index one step forward, unless it is already at the end of the text:</p>
<pre style="padding-left: 60px">    case Qt::Key_Right: 
      if (m_editIndex &lt; m_editorText.size()) { 
        ++m_editIndex; 
      } 
      break; </pre>
<p>In the case of the up-arrow key, we calculate the appropriate <kbd>x</kbd> and <kbd>y</kbd> position for the character on the previous line, unless it is already on top of the text. We then call <kbd>simulateMouseClick</kbd>, which has the same effect as if the user has clicked on the character above the line:</p>
<pre style="padding-left: 60px">     case Qt::Key_Up: { 
       QRect charRect = m_rectList[m_editIndex]; 
 
       if (charRect.top() &gt; 0) { 
         int x = charRect.left() + (charRect.width() / 2), 
             y = charRect.top() - 1; 
         simulateMouseClick(x, y); 
       } 
     } 
     break; </pre>
<p>In the same way, in the case of the down-arrow key, we move the edit index one line downwards unless it is already at the bottom of the text.</p>
<p>We calculate the appropriate <kbd>x</kbd> and <kbd>y</kbd> position for the character on the line below and call <kbd>simulateMouseClick</kbd>, which has the same effect as if the user has clicked at the point:</p>
<pre style="padding-left: 60px">     case Qt::Key_Down: { 
       QRect charRect = m_rectList[m_editIndex]; 
       int x = charRect.left() + (charRect.width() / 2), 
           y = charRect.bottom() + 1; 
       simulateMouseClick(x, y); 
     } 
     break; </pre>
<p>In the case of the <em>Delete</em> key, we remove the current key, unless we are at the end of the text. That is, if we are one step beyond the last character:</p>
<pre style="padding-left: 60px">    case Qt::Key_Delete: 
      if (m_editIndex &lt; m_editorText.size()) { 
        m_editorText.remove(m_editIndex, 1); 
        setModifiedFlag(true); 
      } 
      break; </pre>
<p>In the case of the backspace key, we move the edit index one step backward, unless it already is at the beginning of the text, and call <kbd>onDelete</kbd>. In this way, we remove the previous character and move the edit index one step backward:</p>
<pre style="padding-left: 60px">     case Qt::Key_Backspace: 
     if (m_editIndex &gt; 0) { 
       --m_editIndex; 
       onDelete(); 
     } 
     break; </pre>
<p>In the case of the return key, we simply insert the new line character to the text:</p>
<pre style="padding-left: 60px">    case Qt::Key_Return: 
      m_editorText.insert(m_editIndex++, 'n'); 
      setModifiedFlag(true); 
      break; </pre>
<p>If the key is not a special key, we check whether it is a regular character by calling <kbd>text</kbd> on the key event pointer. If the text is not empty, add its first character to the text:</p>
<pre style="padding-left: 60px">     default: { 
        QString text = eventPtr-&gt;text(); 
 
        if (!text.isEmpty()) { 
          m_editorText.insert(m_editIndex++, text[0]); 
          setModifiedFlag(true); 
        } 
     } 
     break; 
    } </pre>
<p>Finally, we calculate the enclosing rectangles, set the caret, and force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">    calculate(); 
    setCaret(); 
    update(); 
  } </pre>
<p><kbd>keyMarkPressEvent</kbd> is called when the user presses a key in mark mode:</p>
<pre style="padding-left: 60px">    void EditorWidget::keyMarkPressEvent(QKeyEvent* eventPtr) { 
      switch (eventPtr-&gt;key()) { </pre>
<p>In case of the left-arrow key, we set the application to edit mode and the edit index to the minimum of the first and last marked index. However, if the minimum index is located at the beginning of the text, we do nothing:</p>
<pre style="padding-left: 60px">    case Qt::Key_Left: { 
        int minIndex = qMin(m_firstIndex, m_lastIndex); 
 
        if (minIndex &gt; 0) { 
          m_mode = Edit; 
          m_caret.show(); 
          m_editIndex = minIndex; 
        } 
      } 
      break; </pre>
<p>On the other hand, in the case of the right-arrow key, we set the application to edit mode and the edit index to the maximum of the first and last marked index. However, if the maximum index is located at the end of the text, we do nothing:</p>
<pre style="padding-left: 60px">    case Qt::Key_Right: { 
      int maxIndex = qMax(m_firstIndex, m_lastIndex); 
 
      if (maxIndex &lt; m_editorText.size()) { 
        m_mode = Edit; 
        m_caret.show(); 
        m_editIndex = maxIndex;</pre>
<pre style="padding-left: 60px">      } 
    } 
    break; </pre>
<p>In case of the up and down arrows, we simulate a mouse click one line above or below the current line, just as in the previous edit case:</p>
<pre style="padding-left: 60px">     case Qt::Key_Up: { 
       QRect charRect = m_rectList[m_editIndex]; 
 
       if (charRect.top() &gt; 0) { 
         int x = charRect.left() + (charRect.width() / 2), 
             y = charRect.top() - 1; 
         simulateMouseClick(x, y); 
       } 
     } 
     break; 
 
     case Qt::Key_Down: { 
        QRect charRect = m_rectList[m_editIndex]; 
        int x = charRect.left() + (charRect.width() / 2), 
            y = charRect.bottom() + 1; 
        simulateMouseClick(x, y); 
      } 
      break; </pre>
<p>In the mark mode, the delete and backspace keys perform the same task—they delete the marked text:</p>
<pre style="padding-left: 60px">    case Qt::Key_Delete: 
    case Qt::Key_Backspace: { 
        int minIndex = qMin(m_firstIndex, m_lastIndex), 
            maxIndex = qMax(m_firstIndex, m_lastIndex); </pre>
<p>We remove the marked text from the edit text, set the modified flag, set the application to edit mode, set the edit index to the minimum of the first and last marked index, and show the caret:</p>
<pre style="padding-left: 60px">        m_editorText.remove(minIndex, maxIndex - minIndex); 
        setModifiedFlag(true); 
        m_mode = Edit; 
        m_editIndex = minIndex; 
        m_caret.show(); 
      } 
      break; </pre>
<p>The return key case is similar to the previous edit mode case, with the difference that we first delete the marked text. We then add a new line to the editor text:</p>
<pre style="padding-left: 60px">     case Qt::Key_Return: 
       onDelete(); 
       m_editorText.insert(m_editIndex++, 'n'); 
       setModifiedFlag(true); 
       break; </pre>
<p>If the key is not a special key, we check if it is a regular key by calling <kbd>text</kbd> on the key event pointer. If the text is not empty, the user has printed a regular key, and we insert the first character in the editor text:</p>
<pre style="padding-left: 60px">    default: { 
       QString text = eventPtr-&gt;text(); 
 
       if (!text.isEmpty()) { 
         onDelete(); 
         m_editorText.insert(m_editIndex++, text[0]); 
         setModifiedFlag(true); 
       } 
    } 
    break; 
    } </pre>
<p>Finally, we calculate the new rectangles enclosing the characters, set the caret, and force an eventual call to <kbd>paintEvent</kbd> by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">     calculate(); 
     setCaret(); 
     update(); 
    } </pre>
<p>The <kbd>simulateMouseClick</kbd> method is called when the user moves the caret up or down. It simulates a mouse click by calling <kbd>mousePressEvent</kbd> and <kbd>mouseReleaseEvent</kbd>, with suitably prepared event objects:</p>
<pre style="padding-left: 30px">    void EditorWidget::simulateMouseClick(int x, int y) { 
      QMouseEvent pressEvent(QEvent::MouseButtonPress, QPointF(x, y), 
          Qt::LeftButton, Qt::NoButton, Qt::NoModifier); 
      mousePressEvent(&amp;pressEvent); 
      QMouseEvent releaseEvent(QEvent::MouseButtonRelease, 
                     QPointF(x, y), Qt::LeftButton, 
                     Qt::NoButton, Qt::NoModifier); 
      mousePressEvent(&amp;releaseEvent); 
    } </pre>
<p>The <kbd>setCaret</kbd> method sets the caret to the appropriate size and position in edit mode. Firstly, we use <kbd>m_editIndex</kbd> to find the rectangle of the correct character. We then create a new rectangle that is of only one-pixel width, in order for the caret to appear as a thin vertical line:</p>
<pre style="padding-left: 60px">    void EditorWidget::setCaret() { 
      QRect charRect = m_rectList[m_editIndex]; 
      QRect caretRect(charRect.left(), charRect.top(), 
                  1, charRect.height()); 
      m_caret.set(caretRect); 
    } </pre>
<p>The <kbd>mouseToIndex</kbd> method takes a mouse point and returns the index of the character at that point. Unlike the version of <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em>, we need to take into consideration that the text may be center or right-aligned:</p>
<pre style="padding-left: 60px">    int EditorWidget::mouseToIndex(QPoint point) { 
       int x = point.x(), y = point.y(); </pre>
<p>If the mouse point is below the text of the editor, the index of the last character is returned:</p>
<pre style="padding-left: 60px">    if (y &gt; (m_fontHeight * m_lineList.size())) { 
      return m_editorText.size(); 
    } </pre>
<p>Otherwise, we start by finding the line of the mouse point, and obtain the indexes of the first and last character on the line:</p>
<pre style="padding-left: 60px">    else { 
      int lineIndex = y / m_fontHeight; 
      QPair&lt;int,int&gt; lineInfo = m_lineList[lineIndex]; 
      int firstIndex = lineInfo.first, lastIndex = lineInfo.second; </pre>
<p>If the mouse point is located to the left of the first character on the line (which it may be if the text is center or right-aligned), we return the index of the first character of the line:</p>
<pre style="padding-left: 60px">     if (x &lt; m_rectList[firstIndex].left()) { 
        return firstIndex; 
     } </pre>
<p>If the mouse point, on the other hand, is located to the right of the line, we return the index of the character next to the last character of the line:</p>
<pre style="padding-left: 60px">    else if (x &gt;= m_rectList[lastIndex].right()) { 
      return (lastIndex + 1); 
    } </pre>
<p>Otherwise, we iterate through the character on the line and, for each character, we check whether the mouse point is located inside the character's enclosing rectangle:</p>
<pre style="padding-left: 60px">     else { 
       for (int charIndex = firstIndex + 1; 
           charIndex &lt;= lastIndex; ++charIndex){ 
           int left = m_rectList[charIndex].left(); </pre>
<p>If the mouse point is located inside the rectangle, we check if it is closest to the left or right border of the rectangle. If it is closest to the left border, we return the index of the character. If it is closest to the right border, we instead return the index of the next character:</p>
<pre style="padding-left: 60px">        if (x &lt; left) { 
          int last = m_rectList[charIndex - 1].left(); 
          int leftSize = x - last, rightSize = left - x; 
          return (leftSize &lt; rightSize) ? (charIndex - 1) 
                                        : charIndex; 
          } 
        } 
      } 
    } </pre>
<p>We are not supposed to reach this point. The <kbd>assert</kbd> macro is added for debugging purposes only:</p>
<pre style="padding-left: 60px">      assert(false); 
      return 0; 
   } </pre>
<p>The <kbd>resizeEvent</kbd> method is called when the user resizes the window. We calculate the rectangles enclosing the characters, since the width of the window may have changed, which may cause the lines to hold fewer or more characters:</p>
<pre style="padding-left: 60px">    void EditorWidget::resizeEvent(QResizeEvent* eventPtr) { 
      calculate(); 
      DocumentWidget::resizeEvent(eventPtr); 
    } </pre>
<p>The <kbd>calculate</kbd> method divides the text into lines, and calculates the rectangles enclosing every character of the text. The indexes of the first and last character of each line are stored in <kbd>m_lineList</kbd>, and the enclosing rectangles are stored in <kbd>m_rectList</kbd>:</p>
<pre style="padding-left: 60px">    void EditorWidget::calculate() { 
      m_lineList.clear(); 
      m_rectList.clear(); </pre>
<p>We use the Qt <kbd>QFontMetrics</kbd> class to obtain the height of a character of the editor font. The height is stored in <kbd>m_fontHeight</kbd>. The <kbd>width</kbd> method gives the width of the window content, in pixels:</p>
<pre style="padding-left: 60px">      QFontMetrics metrics(m_textFont); 
      m_fontHeight = metrics.height(); 
      QList&lt;int&gt; charWidthList, lineWidthList; 
      int windowWidth = width(); </pre>
<p>We start by iterating through the editor text in order to divide the text into lines:</p>
<pre style="padding-left: 60px">     { int firstIndex = 0, lineWidth = 0; 
        for (int charIndex = 0; charIndex &lt; m_editorText.size(); 
           ++charIndex) { 
          QChar c = m_editorText[charIndex]; </pre>
<p>When we encounter a new line, we add the first and last index of the current line to <kbd>m_lineList</kbd>:</p>
<pre style="padding-left: 60px">      if (c == 'n') { 
        charWidthList.push_back(1); 
        lineWidthList.push_back(lineWidth); 
        m_lineList.push_back 
                   (QPair&lt;int,int&gt;(firstIndex, charIndex)); 
        firstIndex = charIndex + 1; 
        lineWidth = 0; 
      } </pre>
<p>Otherwise, we call the <kbd>width</kbd> method of the Qt <kbd>QMetrics</kbd> object to obtain the width of the character, in pixels:</p>
<pre style="padding-left: 60px">      else { 
        int charWidth = metrics.width(c); 
        charWidthList.push_back(charWidth); </pre>
<p>If the character makes the width of the line exceed the width of the window content, we add the first and last index to <kbd>m_lineList</kbd> and start a new line.</p>
<p>However, we have two different cases to consider. If the current character is the first character of the line, we have the (rather unlikely) situation that the width of that character exceeds the width of the window content. In that case, we add the index of that character as both the first and last index to <kbd>m_lineList</kbd>. The first index of the next line is the character next to that character:</p>
<pre style="padding-left: 60px">    if ((lineWidth + charWidth) &gt; windowWidth) { 
       if (firstIndex == charIndex) { 
         lineWidthList.push_back(windowWidth); 
         m_lineList.push_back 
              (QPair&lt;int,int&gt;(firstIndex, charIndex)); 
         firstIndex = charIndex + 1; 
       } </pre>
<p>If the current character is not the first character of the line, we add the indexes of the first character and the character preceding the current character to <kbd>m_lineList</kbd>. The index of the next line becomes the index of the current character:</p>
<pre style="padding-left: 60px">       else { 
          lineWidthList.push_back(lineWidth); 
          m_lineList.push_back(QPair&lt;int,int&gt;(firstIndex, 
              charIndex - 1)); 
          firstIndex = charIndex; 
       } 
       lineWidth = 0; 
    } </pre>
<p>If the character does not make the width of the line exceed the width of the window content, we simply add the width of the character to the width of the line:</p>
<pre style="padding-left: 60px">    else { 
          lineWidth += charWidth; 
         } 
    } 
  } </pre>
<p>Finally, we need to add the last line to <kbd>m_lineList</kbd>:</p>
<pre style="padding-left: 60px">      m_lineList.push_back(QPair&lt;int,int&gt;(firstIndex, 
           m_editorText.size() - 1)); 
      lineWidthList.push_back(lineWidth); 
    } </pre>
<p>When we have divided the text into lines, we continue to calculate the enclosing rectangles of the individual characters. We start by setting <kbd>top</kbd> to zero, since it holds the top position of the line. It will be increased by the line height for each line:</p>
<pre style="padding-left: 60px">     { int top = 0, left; 
        for (int lineIndex = 0; lineIndex &lt; m_lineList.size(); 
           ++lineIndex) { 
        QPair&lt;int,int&gt; lineInfo = m_lineList[lineIndex]; 
        int lineWidth = lineWidthList[lineIndex]; 
        int firstIndex = lineInfo.first, 
           lastIndex = lineInfo.second; </pre>
<p>Depending on the alignment of the text, we need to decide where the line starts. In the case of left alignment, we set the left position of the line to zero:</p>
<pre style="padding-left: 60px">      switch (m_alignment) { 
        case Left: 
          left = 0; 
          break; </pre>
<p>In case of center alignment, we set the left position to half of the difference between the width of the window content and the line. In this way, the line will appear at the center of the window:</p>
<pre style="padding-left: 60px">        case Center: 
          left = (windowWidth - lineWidth) / 2; 
          break; </pre>
<p>In case of right alignment, we set the left position to the difference between the width of the window content and the line. In this way, the line will appear to the right in the window:</p>
<pre style="padding-left: 60px">       case Right: 
          left = windowWidth - lineWidth; 
          break; 
       } </pre>
<p>Finally, when we have decided the starting left position of the line and the width of each individual character of the text, we iterate through the line and calculate the enclosing rectangle for each character:</p>
<pre style="padding-left: 60px">     for (int charIndex = firstIndex; 
           charIndex &lt;= lastIndex;++charIndex){ 
        int charWidth = charWidthList[charIndex]; 
        QRect charRect(left, top, charWidth, m_fontHeight); 
        m_rectList.push_back(charRect); 
        left += charWidth; 
     } </pre>
<p>For the very last line of the text, we add a rectangle holding the position beyond the last character:</p>
<pre style="padding-left: 60px">      if (lastIndex == (m_editorText.size() - 1)) { 
        QRect lastRect(left, top, 1, m_fontHeight); 
        m_rectList.push_back(lastRect); 
      } </pre>
<p>The top field is increased by the height of the line for each new line:</p>
<pre style="padding-left: 60px">          top += m_fontHeight; 
        } 
      } 
    } </pre>
<p>The <kbd>paintEvent</kbd> method is called by the framework every time the window needs to be repainted, or when we force a repainting by calling <kbd>update</kbd>. The framework clears the content of the window before the call to <kbd>paintEvent</kbd>:</p>
<p>First, we create a <kbd>QPinter</kbd> object that we then use to write on. We set some rendering and the font of the text:</p>
<pre style="padding-left: 60px">     void EditorWidget::paintEvent(QPaintEvent* /* eventPtr */) { 
       QPainter painter(this); 
       painter.setRenderHint(QPainter::Antialiasing); 
       painter.setRenderHint(QPainter::TextAntialiasing); 
       painter.setFont(m_textFont); </pre>
<p>We calculate the minimum and maximum index of the marked text (even though we do not yet know if the application holds mark mode):</p>
<pre style="padding-left: 60px">    int minIndex = qMin(m_firstIndex, m_lastIndex), 
       maxIndex = qMax(m_firstIndex, m_lastIndex); </pre>
<p>We iterate through the text of the editor. We write every character except a new line:</p>
<pre style="padding-left: 60px">     for (int index = 0; index &lt; m_editorText.length(); ++index) { 
       QChar c = m_editorText[index]; </pre>
<p>If the character is marked, we write it with white text on a black background:</p>
<pre style="padding-left: 60px">    if (c != 'n') { 
      if ((m_mode == Mark) &amp;&amp; 
          (index &gt;= minIndex) &amp;&amp; (index &lt; maxIndex)) { 
        painter.setPen(Qt::white); 
        painter.setBackground(Qt::black); 
      } </pre>
<p>If the character is not marked, we write it with black text on a white background:</p>
<pre style="padding-left: 60px">      else { 
        painter.setPen(Qt::black); 
        painter.setBrush(Qt::white); 
      } </pre>
<p>When the colors of the text and background have been set, we look up the rectangle enclosing the character and write the character itself:</p>
<pre style="padding-left: 60px">      QRect rect = m_rectList[index]; 
      painter.drawText(rect, c); 
    } 
  } </pre>
<p>Finally, we also paint the caret:</p>
<pre style="padding-left: 60px">      m_caret.paint(&amp;painter); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main function</h1>
                </header>
            
            <article>
                
<p>The <kbd>main</kbd> function is similar to the main function of the previous applications: it creates an application, shows the drawing window, and starts the execution of the application.</p>
<p><strong>Main.cpp:</strong></p>
<pre style="padding-left: 60px">#include "EditorWindow.h" 
#include &lt;QApplication&gt; 
 
int main(int argc, char *argv[]) { 
  QApplication application(argc, argv); 
  EditorWindow editorWindow; 
  editorWindow.show(); 
  return application.exec(); 
} </pre>
<p>The output is shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="315" src="assets/4191c0b5-fcd6-4a9e-a3e4-540323edcd89.png" width="586"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have developed more advanced versions of the analog clock, the drawing program, and the editor. The clock shows the current hour, minute, and second. The drawing program, allows the user to draw lines, rectangles, and ellipses. The editor allows the user to input and edit text. The clock face has digits instead of lines. In the drawing program we can mark, modify, and cut and paste figures, and in the editor, we can change font and alignment and mark a text block.</p>
<p>In <a href="1ce9af28-ea17-439f-945d-2353f6097157.xhtml" target="_blank">Chapter 7</a>, <em>The Games</em>, we will start developing the games Othello and Nought and Crosses.</p>


            </article>

            
        </section>
    </body></html>