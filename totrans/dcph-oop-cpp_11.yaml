- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will begin our quest to expand your C++ programming repertoire
    beyond OOP concepts, with the goal of enabling you to write more robust and extensible
    code. We will begin this endeavor by exploring exception handling in C++. Adding
    language-prescribed methods in our code to handle errors will allow us to achieve
    less buggy and more reliable programs. By using the formal exception handling
    mechanisms *built into the language*, we can achieve a uniform handling of errors,
    which leads to more easily maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding exception handling basics – `try`, `throw`, and `catch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring exception handling mechanics – trying code that may raise exceptions,
    raising (throwing), catching, and handling exceptions using several variations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing exception hierarchies with standard exception objects or by creating
    customized exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to utilize exception handling
    in C++. You will see how to identify an error to raise an exception, transfer
    control of the program to a designated area by throwing an exception, and then
    handle the error by catching the exception and hopefully repairing the problem
    at hand.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to utilize standard exceptions from the C++ Standard
    Library, as well as create customized exception objects. A hierarchy of exception
    classes can be designed to add robust error detection and handling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our understanding of C++ by expanding our programming repertoire
    by exploring the built-in language mechanisms of exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter11`
    in a file named `Chp11-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3QZi638](https://bit.ly/3QZi638).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error conditions may occur within an application that would prevent a program
    from continuing correctly. Such error conditions may include data values that
    exceed application limits, necessary input files or databases have become unavailable,
    heap memory has become exhausted, or any other imaginable issue. C++ exceptions
    provide a uniform, language-supported manner for handling program anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the introduction of language supported exception handling mechanisms,
    each programmer would handle errors in their own manner, and sometimes not at
    all. Program errors and exceptions that are not handled imply that somewhere further
    in the application, an unexpected result will occur and the application will most
    often terminate abnormally. These potential outcomes are certainly undesirable!
  prefs: []
  type: TYPE_NORMAL
- en: C++ **exception handling** provides a language supported mechanism to detect
    and correct program anomalies so that an application can remain running, rather
    than ending abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the mechanics, starting with the language supported keywords
    `try`, `throw`, and `catch`, which comprise exception handling in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing exception handling with try, throw, and catch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Exception handling** detects a program anomaly, as defined by the programmer
    or by a class library, and passes control to another portion of the application
    where the specific problem may be handled. Only as a last resort will it be necessary
    to exit an application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by taking a look at the keywords that support exception handling.
    The keywords are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`: Allows programmers to *try* a portion of code that might cause an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw`: Once an error is found, `throw` raises the exception. This will cause
    a jump to the catch block below the associated try block; `throw` will allow an
    argument to be returned to the associated catch block. The argument thrown may
    be of any standard or user defined type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch`: Designates a block of code designed to seek exceptions that have been
    thrown, to attempt to correct the situation. Each catch block in the same scope
    will handle an exception of a different type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When utilizing exception handling, it is useful to review the idea of backtracking.
    When a sequence of functions is called, we build up, on the stack, state information
    applicable to each successive function call (parameters, local variables, and
    return value space), as well as the return address for each function. When an
    exception is thrown, we may need to unwind the stack to the point of origination
    where this sequence of function calls (or try blocks) began, resetting the stack
    pointer as well. This process is known as **backtracking** and allows a program
    to return to an earlier sequence in the code. Backtracking applies not only to
    function calls but to nested blocks including nested try blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to illustrate basic exception handling syntax and
    usage. Though portions of the code are not shown to save space, the complete example
    can be found in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragment, we can see the keywords `try`, `throw`, and `catch`
    in action. First, let’s notice the `Student::Validate()` member function. Imagine,
    in this virtual method, we verify that a `Student` meets admission standards.
    If so, the function ends normally. If not, an exception is thrown. In this example,
    a simple `string` is thrown encapsulating the message `"Does not meet prerequisites"`.
  prefs: []
  type: TYPE_NORMAL
- en: In our `main()` function, we first instantiate a `Student`, namely `s1`. Then,
    we nest our call to `s1.Validate()` within a try block. We are literally saying
    that we’d like to *try* this block of code. Should `Student::Validate()` work
    as expected, error-free, our program completes the try block, skips the catch
    block(s) below the try block, and merely continues with the code below any catch
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: However, should `Student::Validate()` throw an exception, we will skip any remaining
    code in our try block and seek an exception matching the type of `const string
    &` in a subsequently defined catch block. Here, in the matching catch block, our
    goal is to correct the error if at all possible. If we are successful, our program
    will continue with the code below the catcher. If not, our job is to end the program
    gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let us summarize the overall flow of exception handling with the following
    logistics:'
  prefs: []
  type: TYPE_NORMAL
- en: When a program completes a try block without encountering any thrown exceptions,
    the code sequence continues with the statement following the catch block. Multiple
    catch blocks (with different argument types) may follow a try block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an exception is thrown, the program must backtrack and return to the try
    block containing the originating function call. The program may have to backtrack
    past multiple functions. When backtracking occurs, the objects encountered on
    the stack will be popped off, and hence destructed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a program (with an exception raised) backtracks to the function where the
    try block was executed, the program will continue with the catch block (following
    the try block) whose signature matches the type of the exception that was thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type conversion (with the exception of upcasting objects related through public
    inheritance) will not be done to match potential catch blocks. However, a catch
    block with ellipses (`…`) may be used as the most general type of catch block
    and can catch any type of exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a matching catch block does not exist, the program will call `terminate()`
    from the C++ Standard Library. Note that `terminate()` will call `abort()`; however,
    the programmer may instead register another function for `terminate()` to call
    via the `set_terminate()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s see how to register a function with `set_terminate()`. Though we
    only show key portions of the code here, the complete program can be found in
    our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragment, we define our own `AppSpecificTerminate()` function.
    This is the function we wish to have the `terminate()` function call rather than
    its default behavior of calling `abort()`. Perhaps we use `AppSpecificTerminate()`
    to end our application a bit more gracefully, saving key data structures or database
    values. Of course, we would also then `exit()` (or `abort()`) ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In `main()`, we merely call `set_terminate(AppSpecificTerminate)` to register
    our terminate function with `set_terminate()`. Now, when `abort()` would otherwise
    be called, our function will be called instead.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that `set_terminate()` returns a function pointer
    to the previously installed `terminate_handler` (which upon its first call will
    be a pointer to `abort()`). Should we choose to save this value, we can use it
    to reinstate previously registered terminate handlers. Notice that we have not
    opted to save this function pointer in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the output would look like for an uncaught exception using the
    aforementioned code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that functions such as `terminate()`, `abort()`, and `set_terminate()`
    are from the Standard Library. Though we may precede their names with the library
    name using the scope resolution operator, such as `std::terminate()`, this is
    not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling is not meant to take the place of simple programmer error
    checking; exception handling has greater overhead. Exception handling should be
    reserved to handle more severe programmatic errors in a uniform manner and in
    a common location.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the basic mechanics for exception handling, let’s take
    a look at slightly more complex exception handling examples.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring exception handling mechanics with typical variations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception handling can be more sophisticated and flexible than the basic mechanics
    previously illustrated. Let’s take a look at various combinations and variations
    of exception handling basics, as each may be applicable to different programming
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: Passing exceptions to outer handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caught exceptions may be passed up to outer handlers for processing. Alternatively,
    exceptions may be partially handled and then thrown to outer scopes for further
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build on our previous example to demonstrate this principle. The full
    program can be seen in the following GitHub directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code, let’s assume that we have our usual header files
    included and the usual class definition for `Student` defined. We will now augment
    the `Student` class by adding the `Student::Validate()` method (virtual, so that
    it may be overridden) and the `Student::TakePrerequisites()` method (not virtual,
    descendants should use it as-is).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `Student::Validate()` method throws an exception, which is merely
    a string literal containing a message indicating the issue at hand. We can imagine
    the complete implementation of the `Student::TakePrerequisites()` method verifies
    that the `Student` has met the appropriate prerequisites, and returns a boolean
    value of `true` or `false` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In our `main()` function, we now notice a set of nested try blocks. The purpose
    here is to illustrate an inner try block that may call a method, such as `s1.Validate()`,
    which may raise an exception. Notice that the same level handler as the inner
    try block catches this exception. Ideally, an exception is handled at the level
    equal to the try block from which it originates, so let’s assume that the catcher
    in this scope tries to do so. For example, our innermost catch block presumably
    tries to correct the error and tests whether the correction has been made using
    a call to `s1.TakePrerequisites()`.
  prefs: []
  type: TYPE_NORMAL
- en: But perhaps this catcher is only able to process the exception partially. Perhaps
    there is the knowledge that an outer level handler knows how to do the remaining
    corrections. In such cases, it is acceptable to re-throw this exception to an
    outer (nested) level. Our simple `throw;` statement in the innermost catch block
    does just this. Notice that there is a catcher at the outer level. Should the
    thrown exception match, type-wise, this outer level will now have the opportunity
    to further handle the exception and hopefully correct the problem so that the
    application can continue. Only if this outer catch block is unable to correct
    the error should the application be exited. In our example, each catcher prints
    out the string representing the error message; therefore, this message occurs
    twice in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to use nested try and catch blocks, let us move forward
    to see how a variety of thrown types and a variety of catch blocks can be used
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an assortment of handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, a variety of exceptions may be raised from an inner scope, creating
    the necessity to craft handlers for a variety of data types. Exception handlers
    (that is, catch blocks) can receive an exception of any data type. We can minimize
    the number of catchers we introduce by utilizing catch blocks with base class
    types; we know that derived class objects (related through public inheritance)
    can always be upcast to their base class type. We can also use the ellipses (`…`)
    in a catch block to allow us to catch anything not previously specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build on our initial example to illustrate assorted handlers in action.
    Though abbreviated, our full program example can be found in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned segment of code, we first examine the `Student::Graduate()`
    member function. Here, we can imagine that this method runs through many graduation
    requirements, and as such, can potentially raise a variety of different types
    of exceptions. For example, should the `Student` instance have too low of a `gpa`,
    a float is thrown as the exception, indicating the student’s poor `gpa`. Should
    the `Student` have too few credits, an integer is thrown, indicating how many
    credits the `Student` still needs to earn their degree.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most interesting potential error that `Student::Graduate()` might
    raise would be if a required `Course` is missing from a student’s graduation requirements.
    In this scenario, `Student::Graduate()` would instantiate a new `Course` object,
    filling it with the `Course` name and number via construction. This anonymous
    object would then be thrown from `Student::Graduate()`, much as an anonymous `string`
    object may be alternatively thrown in this method. The handler may then catch
    the `Course` (or `string`) object by reference.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main()` function, we merely wrap the call to `Student::Graduate()` within
    a try block, as this statement may raise an exception. A sequence of catchers
    follows the try block – one `catch` statement per type of object that may be thrown.
    The last catch block in this sequence uses ellipses (`…`), indicating that this
    catcher will handle any other type of exception thrown by `Student::Graduate()`
    that has not been caught by the other catchers.
  prefs: []
  type: TYPE_NORMAL
- en: The catch block that is actually engaged is the one in which a `Course` is caught
    using `const Course &err`. With the `const` qualifier, we may not modify the `Course`
    in the handler, so we may only apply `const` member functions to this object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that though each earlier catcher shown merely prints out an error and then
    exits, ideally, a catcher would try to correct the error so that the application
    would not need to terminate, allowing code below the catch blocks to continue
    onward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen a variety of thrown types and a variety of catch blocks,
    let us move forward to understand what we should group together within a single
    try block.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping together dependent items within a try block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to remember that when a line of code in a try block encounters
    an exception, the remainder of the try block is ignored. Instead, the program
    continues with a matching catcher (or calls `terminate()` if no suitable catcher
    exists). Then, if the error is repaired, the code beyond the catcher commences.
    Note that we never return to complete the remainder of the initial try block.
    The implication of this behavior is that you should only group together elements
    within a try block that go together. That is, if one item causes an exception,
    it is no longer important to complete the other item in that grouping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the goal of a catcher is to correct an error if at all possible.
    This means that the program may continue forward after the applicable catch block.
    You may ask: Is it now acceptable that an item was skipped in the associated try
    block? Should the answer be no, then rewrite your code. For example, you may want
    to add a loop around the `try`-`catch` grouping such that if an error is corrected
    by a catcher, the whole enterprise is retried starting with the initial try block.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, make smaller, successive `try`-`catch` groupings. That is, *try*
    only one important task in its own try block (followed by applicable catchers).
    Then *try* the next task in its own try block with its associated catchers and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at a way to include in a function’s prototype the type
    of exceptions it may throw.
  prefs: []
  type: TYPE_NORMAL
- en: Examining exception specifications in function prototypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can optionally specify the types of exceptions a C++ function may throw by
    extending the signature of that function to include the object types of what may
    be thrown. However, because a function may throw more than one type of exception
    (or none at all), checking which type is actually thrown must be done at runtime.
    For this reason, these augmented specifiers in the function prototype are also
    known as `noexcept` specifier, which we’ll see shortly. Uses of dynamic exceptions
    also occur in existing code bases and libraries, so let’s briefly examine its
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example using exception types in the extended signature of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code fragment, we see two member functions of `Student`.
    `Student::Graduate()` includes the `throw` keyword after its parameter list and
    then, as part of this method’s extended signature, includes the types of objects
    that may be thrown from this function. Notice that the `Student::Enroll()` method
    merely has an empty list following `throw()` in its extended signature. This means
    that `Student::Enroll()` might throw any type of exception.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, by adding the `throw()` keyword with optional data types to the
    signature, we are providing a means to announce to the user of this function what
    types of objects might be thrown. We are then asking programmers to include any
    calls to this method within a try block followed by appropriate catchers.
  prefs: []
  type: TYPE_NORMAL
- en: We will see that though the idea of an extended signature seems very helpful,
    it has unfavorable issues in practice. For this reason, dynamic exception specifications
    have been *deprecated*. Because you may still see these specifications used in
    existing code, including Standard Library prototypes (such as with exceptions),
    this deprecated feature is still supported by compilers, and you will need to
    understand their usage.
  prefs: []
  type: TYPE_NORMAL
- en: Though dynamic exceptions (extended function signatures as previously described)
    have been deprecated, a specifier with a similar purpose has been added to the
    language, the `noexcept` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specifier can be added after the extended signature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Nonetheless, let’s investigate why unfavorable issues exist relating to dynamic
    exceptions by looking at what happens when our application throws exceptions that
    are not part of a function’s extended signature.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with unexpected types of dynamic exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Should an exception be thrown of a type other than that specified in the extended
    function prototype, `unexpected()`, from the C++ Standard Library, will be called.
    You can register your own function with `unexpected()`, much as we registered
    our own function with `set_terminate()` earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can allow your `AppSpecificUnexpected()` function to rethrow an exception
    of the type that the originating function should have thrown; however, if that
    does not occur, `terminate()` will then be called. Furthermore, if no possible
    matching catcher exists to handle what is correctly thrown from the originating
    function (or rethrown by `AppSpecificUnexpected()`), then `terminate()` will be
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to use `set_unexpected()` with our own function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Registering our own function with `set_unexpected()` is very simple, as illustrated
    in the aforementioned code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, one motivating reason for employing exception specification in
    a function’s extended signature was to provide a documentative effect. That is,
    you could see which exceptions a function might possibly throw simply by examining
    its signature. You could then plan to enclose that function call within a try
    block and provide appropriate catchers to handle any potential situation.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, regarding dynamic exceptions, it is useful to note that compilers
    do not check that the types of exceptions *actually* thrown in a function body
    match the types specified in the function’s extended signature. It is up to the
    programmer to ensure that they are in sync. Therefore, this deprecated feature
    can be error-prone and, overall, less useful than its original intention.
  prefs: []
  type: TYPE_NORMAL
- en: Though well intended, dynamic exceptions are currently unused, except in large
    quantities of library code such as the Standard C++ Library. Since you will inevitably
    utilize these libraries, it is important to understand these anachronisms.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic exception specifications (that is, the ability to specify exception
    types in a method’s extended signature) have been *deprecated* in C++. This is
    because compilers are not able to validate their use, which must then be delayed
    until runtime. Their use, though still supported (many libraries have such specifications),
    is now deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen an assortment of exception handling detection, raising,
    catching, and (hopefully) correction schemes, let’s take a look at how we might
    create a hierarchy of exception classes to add sophistication to our error handling
    abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing exception hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a class to encapsulate the details relating to a program error seems
    like a useful endeavor. In fact, the C++ Standard Library has created one such
    generic class, `exception`, to provide the basis for building an entire hierarchy
    of useful exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the `exception` class with its Standard Library descendants,
    and then how we may extend `exception` with our own classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard exception objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `<exception>` header. The `exception` class includes virtual functions
    with the following signatures: `virtual const char *what() const noexcept` and
    `virtual const char *what() const throw()`. These signatures indicate that derived
    classes should redefine `what()` to return a `const char *` with a description
    of the error at hand. The `const` keyword after `what()` indicates that these
    are `const` member functions; they will not change any members of the derived
    class. The `noexcept` usage in the first prototype indicates that `what()` is
    non-throwing. The `throw()` in the extended signature of the second prototype
    indicates that this function may throw any type. The usage of `throw()` in the
    second signature is a deprecated anachronism and should not be used in new code.'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::exception` class is the base class of a variety of predefined C++
    exception classes, including `bad_alloc`, `bad_cast`, `bad_exception`, `bad_function_call`,
    `bad_typeid`, `bad_weak_ptr`, `logic_error`, `runtime_error`, and nested class
    `ios_base::failure`. Many of these derived classes have descendants themselves,
    adding additional standard exceptions to the predefined hierarchy of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Should a function throw any of the aforementioned exceptions, these exceptions
    may be caught by either catching the base class type, `exception`, or by catching
    an individual derived class type. Depending on what course of action your handler
    will take, you can decide whether you wish to catch one such exception as its
    generalized base class type or as its specific type.
  prefs: []
  type: TYPE_NORMAL
- en: Just as the Standard Library has set up a hierarchy of classes based on the
    `exception` class, so may you. Let’s next take a look at how we might do just
    this!
  prefs: []
  type: TYPE_NORMAL
- en: Creating customized exception classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a programmer, you may decide that it is advantageous to establish your own
    specialized exception types. Each type can pack useful information into an object
    detailing just what went wrong with the application. Additionally, you may be
    able to pack clues into the object (which will be thrown) as to how to correct
    the error at hand. Simply derive your class from the Standard Library `exception`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how easily this may be done by examining the critical
    portions of our next example, which can be found as a full program in our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a few minutes to examine the previous segment of code. Foremost,
    notice that we define our own exception class, `StudentException`. It is a derived
    class from the C++ Standard Library `exception` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `StudentException` class contains data members to hold an error code as
    well as alphanumeric details describing the error condition using data members
    `errCode` and `details`, respectively. We have two simple access functions, `StudentException::GetCode()`
    and `StudentException::GetDetails()`, to easily retrieve these values. As these
    methods do not modify the object, they are `const` member functions.
  prefs: []
  type: TYPE_NORMAL
- en: We notice that the `StudentException` constructor initializes the two data members
    – one through the member initialization list and one in the body of the constructor.
    We also override the `virtual const char *what() const noexcept` method (as introduced
    by the `exception` class) in our `StudentException` class to return the string
    of characters `"Student Exception"`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s examine our `Student::Graduate()` method. This method may throw
    a `StudentException`. If an exception must be thrown, we instantiate one, constructing
    it with diagnostic data, and then `throw` the `StudentException` from this function.
    Note that the object thrown has no local identifier in this method – there’s no
    need, as any such local variable name would soon be popped off the stack after
    the throw occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In our `main()` function, we wrap our call to `s1.Graduate()` within a try block,
    and it is followed by a catch block that accepts a reference (`&`) to a `StudentException`,
    which we treat as `const`. Here, we first call our overridden `what()` method
    and then print out the diagnostic details from within the exception, `e`. Ideally,
    we would use this information to try to correct the error at hand and only exit
    the application if truly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Though the most usual way to create a customized exception class is to derive
    a class from the Standard `exception` class, you may also wish to utilize a different
    technique, that of an embedded exception class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a nested exception class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an alternative implementation, exception handling may be embedded into a
    class by adding a nested class definition in the public access region for a particular
    outer class. The inner class will represent the customized exception class.
  prefs: []
  type: TYPE_NORMAL
- en: Objects of nested, user defined types may be created and thrown to catchers
    anticipating such types. These nested classes are built into the public access
    region of the outer class, making them easily available for derived class usage
    and specialization. In general, exception classes built into an outer class must
    be public so that the instances of nested types thrown can be caught and handled
    outside the scope of the outer class (that is, in the scope where the primary,
    outer instance exists).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this alternate implementation of an exception class by
    examining key segments of code, which can be found as a full program in our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragments, we expanded our `Student` class to include a
    private, nested class called `StudentException`. Though the class shown is overly
    simplified, the nested class ideally should define a means to catalog the error
    in question as well as collect any useful diagnostic information.
  prefs: []
  type: TYPE_NORMAL
- en: In our `main()` function, we instantiate a `Student`, namely `s1`. In a try
    block, we then call `s1.Graduate();`. Our `Student::Graduate()` method presumably
    checks that the `Student` has met graduation requirements, and if not, throws
    an exception of the nested class type, `Student::StudentException` (which will
    be instantiated as needed).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our corresponding catch block utilizes scope resolution to specify
    the inner class type for `err`, the referenced object (that is, `const Student::StudentException
    &err`). Though we ideally would like to correct the program error within the handler,
    if we cannot, we simply print a message and `exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Understanding how to create our own exception class (both as a nested class
    or derived from `std::exception`) is useful. We may additionally wish to create
    a hierarchy of application-specific exceptions. Let’s move ahead to see how to
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: Creating hierarchies of user defined exception types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An application may wish to define a series of classes that support exception
    handling to raise specific errors, and hopefully, also provide a means to collect
    diagnostics for an error so that the error may be addressed in an appropriate
    segment of the code.
  prefs: []
  type: TYPE_NORMAL
- en: You may wish to create a subhierarchy, derived from the C++ Standard Library
    `exception`, of your own exception classes. Be sure to use public inheritance.
    When utilizing these classes, you will instantiate an object of your desired exception
    type (filling it with valuable diagnostic information), and then throw that object.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you create a hierarchy of exception types, your catchers can catch
    specific derived class types or more general base class types. The option is yours,
    depending on how you will plan to handle the exception. Keep in mind, however,
    that if you have a catcher for both the base and derived class types, place the
    derived class types first – otherwise your thrown object will first match to the
    base class type catcher without realizing that a more appropriate derived class
    match is available.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen both the hierarchy of C++ Standard Library exception classes,
    as well as how to create and utilize your own exception classes. Let’s now briefly
    recap the exception features we’ve learned in this chapter, before moving forward
    to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have begun expanding our C++ programming repertoire beyond
    OOP language features to include features that will enable us to write more robust
    programs. User code can inevitably be error-prone by nature; using language supported
    exception handling can help us achieve less buggy and more reliable code.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to utilize the core exception handling features with `try`,
    `throw`, and `catch`. We’ve seen a variety of uses of these keywords – throwing
    exceptions to outer handlers, using an assortment of handlers featuring various
    types, and selectively grouping program elements together within a single try
    block, for example. We have seen how to register our own functions with `set_terminate()`
    and `set_unexpected()`. We have seen how to utilize the existing C++ Standard
    Library `exception` hierarchy. We have additionally explored defining our own
    exception classes to extend this hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: We have added key features to our C++ skills by exploring exception handling
    mechanisms. We are now ready to move forward to [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526),
    *Friends and Operator Overloading*, so that we can continue expanding our C++
    programming repertoire with useful language features that will make us better
    programmers. Let’s move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add exception handling to your previous `Student` / `University` exercise from
    [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing Association, Aggregation,
    and Composition*, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should a `Student` try to enroll in more than the `MAX` defined number of allowable
    courses per `Student`, throw a `TooFullSchedule` exception. This class may be
    derived from the Standard Library `exception` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Should a `Student` try to enroll in a `Course` that is already full, have the
    `Course::AddStudent(Student *)` method throw a `CourseFull` exception. This class
    may be derived from the Standard Library `exception` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many other areas in the `Student` / `University` application that
    could utilize exception handling. Decide which areas should employ simple error
    checking and which are worthy of exception handling.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
