<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer468">
<h1 class="chapter-number" id="_idParaDest-270"><a id="_idTextAnchor298"/>14</h1>
<h1 id="_idParaDest-271"><a id="_idTextAnchor299"/>Spawning the Player Projectile</h1>
<p>In the previous chapter, you made great progress with the enemy character’s AI by creating a behavior tree that would allow the enemy to randomly select points from the <strong class="source-inline">BP_AIPoints</strong> actor you created. This gave the <strong class="source-inline">SuperSideScroller</strong> game more life as you can now have multiple enemies moving around your game world. Additionally, you learned about the different tools available in <strong class="bold">Unreal Engine 5</strong> (<strong class="bold">UE5</strong>) that are used together to make AI of various degrees of complexity. These tools included the Navigation Mesh, behavior trees, and Blackboards. </p>
<p>Now that you have enemies running around your level, you need to allow the player to defeat these enemies with the player projectile you started to create at the end of the previous chapter. Our goal for this chapter is to use a custom <strong class="source-inline">UAnimNotify</strong> class that we will implement within our <strong class="source-inline">Throw</strong> Animation Montage to spawn the <strong class="source-inline">Player Projectile</strong>. Additionally, we will add polish elements to the projectile such as Particle Systems and Sound Cues.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to use the <strong class="source-inline">UAnimNotify</strong> class to spawn the player projectile during the <strong class="source-inline">Throw</strong> Animation Montage.</li>
<li>Creating a new <strong class="source-inline">Socket</strong> for the main character skeleton from which the projectile will spawn.</li>
<li>Learn how to use Particle Systems and Soundcues to add a layer of visual and audio polish to the game.</li>
</ul>
<p>By the end of this chapter, you will be able to play Animation Montages in both Blueprints and C++ and know how to spawn objects into the game world using C++ and the <strong class="source-inline">UWorld</strong> class. These elements of the game will be given audio and visual components as an added layer of polish, and your <strong class="source-inline">SuperSideScroller</strong> player character will be able to throw projectiles that destroy enemies.</p>
<p>Technical requirements</p>
<p>For this chapter, you will need the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
<li>Unreal Engine 4.27 installed</li>
</ul>
<p>The project for this chapter can be found in the <strong class="source-inline">Chapter14</strong> folder of the code bundle for this book, which can be downloaded here:</p>
<p><a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a></p>
<p>Let’s begin this chapter by learning about <strong class="bold">Anim Notifies</strong> and <strong class="bold">Anim Notify States</strong>. After that, you’ll get your hands dirty by creating a <strong class="source-inline">UAnimNotify</strong> class so that you can spawn the player projectile during the <strong class="source-inline">Throw</strong> Animation Montage.</p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor300"/>Anim Notifies and Anim Notify States</h1>
<p>When it comes to creating polished and complex animations, there needs to be a way for animators and <a id="_idIndexMarker1156"/>programmers to add custom events within the animation that will allow for additional effects, layers, and functionality to occur. The solution in <a id="_idIndexMarker1157"/>UE5 is to use <strong class="bold">Anim Notifies</strong> and <strong class="bold">Anim Notify States</strong>. </p>
<p>The main difference <a id="_idIndexMarker1158"/>between <strong class="bold">Anim Notify</strong> and <strong class="bold">Anim Notify State</strong> is that <strong class="bold">Anim Notify State</strong> possesses three distinct events that <strong class="bold">Anim Notify</strong> does not. These events are <strong class="bold">Notify Begin</strong>, <strong class="bold">Notify End</strong>, and <strong class="bold">Notify Tick</strong>, all of which can be used in Blueprints or C++. When it comes to these events, UE5 secures the following behaviors:</p>
<ul>
<li><strong class="bold">Notify State</strong> will always start with <strong class="bold">Notify Begin Event</strong></li>
<li><strong class="bold">Notify State</strong> will always finish with <strong class="bold">Notify End Event</strong></li>
<li><strong class="bold">Notify Tick Event</strong> will always take place between the <strong class="bold">Notify Begin</strong> and <strong class="bold">Notify End</strong> events</li>
</ul>
<p><strong class="bold">Anim Notify</strong>, however, is a much more simplified version that uses just a single function, <strong class="source-inline">Notify()</strong>, to allow programmers to add functionality to the notify itself. It works with the mindset of <em class="italic">fire and forget</em>, meaning you don’t need to worry about what happens at the start, end, or anywhere in-between the <strong class="source-inline">Notify()</strong> event. It is due to this simplicity of <strong class="bold">Anim Notify</strong>, and because we <a id="_idIndexMarker1159"/>do not need the events included with <strong class="bold">Anim Notify State</strong>, that we will use <strong class="bold">Anim Notify</strong> to spawn the player projectile for the <strong class="source-inline">SuperSideScroller</strong> game.</p>
<p>Before moving on to the<a id="_idIndexMarker1160"/> following exercise, where you will create a custom <strong class="bold">Anim Notify</strong> in C++, let’s briefly discuss some examples of existing Anim Notifies that UE5 provides by default. A full list of default <strong class="bold">Anim Notify</strong> states can be seen in the following screenshot: </p>
<div>
<div class="IMG---Figure" id="_idContainer434">
<img alt="Figure 14.1 – The full list of default Anim Notifies provided in UE5 " height="279" src="image/Figure_14.01_B18531.jpg" width="439"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The full list of default Anim Notifies provided in UE5</p>
<p>There are two <strong class="bold">Anim Notifies</strong> that you will be using later in this chapter: <strong class="bold">Play Particle Effect</strong> and <strong class="bold">Play Sound</strong>. Let’s discuss these two in more detail so that you are familiar with them by the time you use them:</p>
<ul>
<li><strong class="bold">Play Particle Effect</strong>: The <strong class="bold">Play Particle Effect</strong> notify, as its name suggests, allows you to spawn and play a <a id="_idIndexMarker1161"/>Particle System at a certain frame of your animation. As shown in the following screenshot, you have options to change the <strong class="bold">visual effects</strong> (<strong class="bold">VFX</strong>) that are being used, such as updating the <strong class="bold">Location Offset</strong>, <strong class="bold">Rotation Offset</strong>, and <strong class="bold">Scale</strong> settings of the particle. You can even attach the particle to a specified <strong class="bold">Socket Name</strong> if you so choose: </li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer435">
<img alt="Figure 14.2 – The Details panel of the Play Particle Effect notify " height="287" src="image/Figure_14.02_B18531.jpg" width="391"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – The Details panel of the Play Particle Effect notify</p>
<p class="callout-heading">Note</p>
<p class="callout">Visual effects, or VFX for short, are crucial elements for any game. VFX, in UE5, are created using a tool called <strong class="bold">Niagara</strong> inside the editor. Niagara has been around since Unreal Engine 4 version 4.20, as a free plugin to improve the<a id="_idIndexMarker1162"/> quality and pipeline for how VFX are made. <strong class="bold">Cascade</strong>, the previous VFX tool, will become deprecated in a later version of UE5. You can learn more about Niagara here: <a href="https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml">https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml</a>.</p>
<p>A very common example <a id="_idIndexMarker1163"/>that’s used in games is to use this type of notify to spawn dirt or other effects underneath the player’s feet while they walk or run. Having the ability to specify at which frame of the animation these effects spawn is very powerful and allows you to create convincing effects for your character.</p>
<ul>
<li><strong class="bold">Play Sound</strong>: The <strong class="bold">Play Sound</strong> notify allows you to play a <strong class="bold">Soundcue</strong> or <strong class="bold">Soundwave</strong> at a certain frame of <a id="_idIndexMarker1164"/>your animation. As shown in the following screenshot, you have options for changing the sound being used, updating its <strong class="bold">Volume Multiplier</strong> and <strong class="bold">Pitch Multiplier</strong> values, and even having the sound follow the owner of the sound by attaching it to a specified <strong class="bold">Attach Name</strong>:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer436">
<img alt="Figure 14.3 – The Details panel of the Play Sound notify " height="350" src="image/Figure_14.03_B18531.jpg" width="394"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – The Details panel of the Play Sound notify</p>
<p>Much like the example given for the <strong class="bold">Play Particle Effect</strong> notify, the <strong class="bold">Play Sound</strong> notify can also be commonly used to play the sounds of footsteps while the character is moving. By having control of exactly where on the animation timeline you can play a sound, it is possible to create believable sound effects.</p>
<p>Although you will not be using an <strong class="bold">Anim Notify State</strong>, it is still important to at least know the options that are<a id="_idIndexMarker1165"/> available to you by default, as shown in the following screenshot: </p>
<div>
<div class="IMG---Figure" id="_idContainer437">
<img alt="Figure 14.4 – The full list of default Anim Notify States provided to you in UE5 " height="243" src="image/Figure_14.04_B18531.jpg" width="458"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – The full list of default Anim Notify States provided to you in UE5</p>
<p class="callout-heading">Note</p>
<p class="callout">The two Notify states that are not available in Animation Sequences are the <strong class="bold">Montage Notify Window</strong> and <strong class="bold">Disable Root Motion</strong> states, as shown in the preceding screenshot. For more information regarding notifies, please refer to the following documentation: <a href="http://docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.xhtml">docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.xhtml</a>.</p>
<p>Now that you are more familiar with <strong class="bold">Anim Notify</strong> and <strong class="bold">Anim Notify State</strong>, let’s move on to the first exercise, where you will create a custom <strong class="bold">Anim Notify</strong> in C++ that you will use to spawn the player projectile.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor301"/>Exercise 14.01 – creating a UAnimNotify class</h2>
<p>The main offensive ability that the<a id="_idIndexMarker1166"/> player character will have in the <strong class="source-inline">SuperSideScroller</strong> game is the projectile that the player can throw at enemies. In the previous chapter, you set up the framework and base functionality of the projectile, but right now, there is no way for the player to use it. To make spawning, or throwing, the projectile convincing to the eye, you need to create a custom <strong class="bold">Anim Notify</strong> that you will then add to the <strong class="bold">Throw</strong> Animation Montage. This <strong class="bold">Anim Notify</strong> will let the player know it’s time to spawn the projectile.</p>
<p>Follow these steps to create the new <strong class="source-inline">UAnimNotify</strong> class:</p>
<ol>
<li>Inside UE5, navigate to the <strong class="bold">Tools</strong> option and <em class="italic">left-click</em> on the <strong class="bold">New C++ Class</strong> option.</li>
<li>From the <strong class="bold">Choose Parent Class</strong> dialog window, search for <strong class="source-inline">Anim Notify</strong> and <em class="italic">left-click</em> the <strong class="bold">AnimNotify</strong> option. Then, <em class="italic">left-click</em> the <strong class="bold">Next</strong> option to name the new class.</li>
<li>Name this new class <strong class="source-inline">Anim_ProjectileNotify</strong>. Once it's been named, <em class="italic">left-click</em> the <strong class="bold">Create Class</strong> option so that UE5 recompiles and hot-reloads the new class in Visual Studio. Once Visual Studio opens, you will have both the header file, <strong class="source-inline">Anim_ProjectileNotify.h</strong>, and the source file, <strong class="source-inline">Anim_ProjectileNotify.cpp</strong>, available to you.</li>
<li>The <strong class="source-inline">UAnimNotify</strong> base class has one function that needs to be implemented inside your class:<p class="source-code">virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference&amp; EventReference); </p></li>
</ol>
<p>This function is <a id="_idIndexMarker1167"/>called automatically when the notify is hit on the timeline it is being used in. By overriding this function, you will be able to add logic to the notify. This function also gives you access to both the <strong class="source-inline">Skeletal Mesh</strong> component of the owning notify and the Animation Sequence currently being played. </p>
<ol>
<li value="5">Next, let’s add the override declaration of this function to the header file. In the <strong class="source-inline">Anim_ProjectileNotify.h</strong> header file, add the following code underneath <strong class="source-inline">GENERATED_BODY()</strong>:<p class="source-code">public:   virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference&amp; EventReference) override;</p></li>
</ol>
<p>Now that you’ve added the function to the header file, it is time to define the function inside the <strong class="source-inline">Anim_ProjectileNotify</strong> source file.</p>
<ol>
<li value="6">Inside the <strong class="source-inline">Anim_ProjectileNotify.cpp</strong> source file, define the function and add a <strong class="source-inline">UE_LOG()</strong> call that <a id="_idIndexMarker1168"/>prints the text <strong class="source-inline">"Throw Notify"</strong>, as shown in the following code:<p class="source-code"> void UAnim_ProjectileNotify::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference&amp; EventReference)</p><p class="source-code">{</p><p class="source-code">   Super::Notify(MeshComp, Animation, EventReference);</p><p class="source-code">   UE_LOG(LogTemp, Warning, TEXT("Throw Notify"));</p><p class="source-code">}</p></li>
</ol>
<p>For now, you will just use this <strong class="source-inline">UE_LOG()</strong> debugging tool to know that this function is being called correctly when you add this notify to the <strong class="bold">Throw</strong> Animation Montage in the next exercise.</p>
<p>In this exercise, you created the groundwork necessary to implement your own <strong class="source-inline">Anim Notify</strong> class by adding the following function:</p>
<p class="source-code"> Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference&amp; EventReference)</p>
<p>Inside this function, you are using <strong class="source-inline">UE_LOG()</strong> to print the custom text <strong class="source-inline">"Throw Notify"</strong> in the output log so that you know that this notify is working correctly.</p>
<p>Later in this chapter, you will update this function so that it calls logic that will spawn the player projectile, but first, let’s add the new notify to the <strong class="bold">Throw</strong> Animation montage.</p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor302"/>Exercise 14.02 – adding the new notify to the Throw Animation Montage</h2>
<p>Now that you have your <strong class="source-inline">Anim_ProjectileNotify</strong> notify, it is time to add it to the <strong class="bold">Throw</strong> Animation Montage so that it can<a id="_idIndexMarker1169"/> be of use to you.</p>
<p>In this exercise, you will add <strong class="source-inline">Anim_ProjectileNotify</strong> to the timeline of the <strong class="bold">Throw</strong> Animation Montage at the exact frame of the animation that you’d expect the projectile to spawn.</p>
<p>Follow these steps to achieve this:</p>
<ol>
<li value="1">Back inside UE5, navigate to the <strong class="bold">Content Drawer</strong> interface and go to the <strong class="source-inline">/MainCharacter/Animation/</strong> directory. Inside this directory, <em class="italic">double-click</em> the <strong class="source-inline">AM_Throw</strong> asset to open the <strong class="bold">Animation Montage</strong> editor.</li>
</ol>
<p>At the very bottom of the <strong class="bold">Animation Montage</strong> editor, you will find the timeline for the animation. By default, you will observe that the <em class="italic">red-colored bar</em> will be moving along the timeline as the animation plays.</p>
<ol>
<li value="2"><em class="italic">Left-click</em> this red bar and manually move it to the 22nd frame, as close as you can, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer438">
<img alt="Figure 14.5 – The red-colored bar allows you to manually position notifies anywhere on the timeline " height="363" src="image/Figure_14.05_B18531.jpg" width="1050"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – The red-colored bar allows you to manually position notifies anywhere on the timeline</p>
<p>The 22nd frame of the <strong class="bold">Throw</strong> animation is the exact moment in the throw that you would expect a projectile to spawn and be thrown by the player. The following screenshot shows the frame of the <strong class="bold">Throw</strong> animation, as seen inside the editor within <strong class="bold">Persona</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer439">
<img alt="Figure 14.6 – The exact moment the player projectile should spawn " height="548" src="image/Figure_14.06_B18531.jpg" width="1044"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – The exact moment the player projectile should spawn</p>
<ol>
<li value="3">Now that you know the position on<a id="_idIndexMarker1170"/> the timeline that the notify should be played, you can <em class="italic">right-click</em> on the thin red line within the <strong class="bold">Notifies</strong> timeline.</li>
</ol>
<p>A popup will appear where you can add a <strong class="bold">Notify</strong> or a <strong class="bold">Notify State</strong>. In some cases, the <strong class="bold">Notifies</strong> timeline may be collapsed and hard to find; simply left-click on the word <strong class="bold">Notifies</strong> to toggle between collapsed and expanded.</p>
<ol>
<li value="4">Select <strong class="bold">Add Notify</strong> and, from the options provided, find and select <strong class="bold">Anim Projectile Notify</strong>. </li>
<li>After adding <strong class="bold">Anim Projectile Notify</strong> to the <strong class="bold">Notifies</strong> timeline, you will see the following:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer440">
<img alt="Figure 14.7 – Anim_ProjectileNotify successfully added to the Throw Animation Montage " height="100" src="image/Figure_14.07_B18531.jpg" width="1043"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – Anim_ProjectileNotify successfully added to the Throw Animation Montage</p>
<ol>
<li value="6">With the <strong class="source-inline">Anim_ProjectileNotify</strong> notify in place on the <strong class="bold">Throw</strong> Animation Montage timeline, save the montage.</li>
<li>If the <strong class="bold">Output Log</strong> window is not visible, please re-enable the window by navigating to the <strong class="bold">Window</strong> option and<a id="_idIndexMarker1171"/> hovering over it to find the option for <strong class="bold">Output Log</strong>. Then, <em class="italic">left-click</em> to enable it.</li>
<li>Now, use <strong class="source-inline">PIE</strong> and, once in-game, use the <em class="italic">left mouse button</em> to start playing the <strong class="bold">Throw</strong> montage.</li>
</ol>
<p>At the point in the animation where you added the notify, you will now see the <strong class="source-inline">Throw Notify</strong> debugging log text appear in the output log. </p>
<p>As you may recall from <a href="B18531_12.xhtml#_idTextAnchor247"><em class="italic">Chapter 12</em></a>, <em class="italic">Animation Blending and Montages</em>, you added the <strong class="source-inline">Play Montage</strong> function to the player character Blueprint – that is, <strong class="source-inline">BP_SuperSideScroller_MainCharacter</strong>. For the sake of learning C++ in the context of UE5, you will be moving this logic from Blueprint to C++ in the upcoming exercises. This is so that we don’t rely too heavily on Blueprint scripts for the base behavior of the player character.</p>
<p>With this exercise complete, you have successfully added your custom <strong class="source-inline">Anim Notify</strong> class, <strong class="source-inline">Anim_ProjectileNotify</strong>, to the <strong class="bold">Throw</strong> Animation Montage. This notify was added at the precise frame in which you expect a projectile to be thrown from the player’s hand. Since you added the Blueprint logic to the player character in <a href="B18531_12.xhtml#_idTextAnchor247"><em class="italic">Chapter 12</em></a>, <em class="italic">Animation Blending and Montages</em>, you can play this <strong class="bold">Throw</strong> Animation Montage when the <strong class="source-inline">EnhancedInputAction</strong> event, <strong class="source-inline">ThrowProjectile</strong>, is called when using the <em class="italic">left mouse button</em>. Before making the transition from playing the <strong class="bold">Throw</strong> Animation Montage in Blueprints to playing it in C++, let’s discuss playing Animation Montages some more.</p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor303"/>Playing Animation Montages</h1>
<p>As you learned in <a href="B18531_12.xhtml#_idTextAnchor247"><em class="italic">Chapter 12</em></a>, <em class="italic">Animation Blending and Montages</em>, these assets are useful for allowing animators to combine individual Animation Sequences into one complete montage. By splitting<a id="_idIndexMarker1172"/> the montage into unique sections and adding notifies for particles and sound, animators and animation programmers can make complex sets of montages that handle all the different aspects of the animation.</p>
<p>But once the Animation Montage is ready, how do we play it on a character? You are already familiar with the first method, which is via Blueprints.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor304"/>Playing Animation Montages in Blueprints</h2>
<p>In Blueprints, the <strong class="bold">Play Montage</strong> function can be used, as<a id="_idIndexMarker1173"/> shown in the<a id="_idIndexMarker1174"/> following screenshot: </p>
<div>
<div class="IMG---Figure" id="_idContainer441">
<img alt="Figure 14.8 – The Play Montage function in Blueprints " height="258" src="image/Figure_14.08_B18531.jpg" width="365"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – The Play Montage function in Blueprints</p>
<p>You have already used the <strong class="source-inline">Play Montage</strong> function to play the <strong class="source-inline">AM_Throw</strong> Animation Montage. This function requires the <strong class="bold">Skeletal Mesh</strong> component that the montage must be played on, and it requires the Animation Montage to play.</p>
<p>The remaining parameters are <a id="_idIndexMarker1175"/>optional, depending on how your montage will work. Let’s have a quick look at these parameters:</p>
<ul>
<li><strong class="bold">Play Rate</strong>: The <strong class="bold">Play Rate</strong> parameter allows you to increase or decrease the playback speed of the Animation Montage. For faster playback, you would increase this value; otherwise, you would decrease it.</li>
<li><strong class="bold">Starting Position</strong>: The <strong class="bold">Starting Position</strong> parameter allows you to set the starting position, in seconds, along the <a id="_idIndexMarker1176"/>montage timeline from which the montage will start playing. For example, in an Animation Montage that has a 3-second timeline, you could choose to have the montage start at the <strong class="source-inline">1.0f</strong> position instead of at <strong class="source-inline">0.0f</strong>.</li>
<li><strong class="bold">Starting Section</strong>: The <strong class="bold">Starting Section</strong> parameter allows you to tell the Animation Montage to start at a specific section. Depending on how your montage is set up, you could have multiple sections created for different parts of the montage. For example, a shotgun weapon-reloading Animation Montage would include a section for the initial movement for reloading, a looped section for the actual bullet reload, and a final section for re-equipping the weapon so that it is ready to fire again.</li>
</ul>
<p>When it comes to the outputs of the <strong class="bold">Play Montage</strong> function, you have a few different options:</p>
<ul>
<li><strong class="bold">On Completed</strong>: The <strong class="bold">On Completed</strong> output is called when the Animation Montage has finished playing and has been fully blended out.</li>
<li><strong class="bold">On Blend Out</strong>: The <strong class="bold">On Blend Out</strong> output is called when the Animation Montage begins to blend out. This can occur during <strong class="bold">Blend Out Trigger Time</strong>, or if the montage ends prematurely.</li>
<li><strong class="bold">On Interrupted</strong>: The <strong class="bold">On Interrupted</strong> output is called when the montage begins to blend out due to it being interrupted by another montage that is trying to play on the same skeleton.</li>
<li><strong class="bold">On Notify Begin</strong> and <strong class="bold">On Notify End</strong>: Both the <strong class="bold">On Notify Begin</strong> and <strong class="bold">On Notify End</strong> outputs are called if you are using the <strong class="bold">Montage Notify</strong> option under the <strong class="bold">Notifies</strong> category<a id="_idIndexMarker1177"/> in the Animation Montage. The name that’s given to <strong class="bold">Montage Notify</strong> is returned via the <strong class="bold">Notify Name</strong> parameter.</li>
</ul>
<p>Now that we have a better understanding<a id="_idIndexMarker1178"/> of the Blueprint implementation of the <strong class="bold">Play Montage</strong> function, let’s take a look at how to play animations in C++.</p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor305"/>Playing Animation Montages in C++</h2>
<p>On the C++ side, there is only one<a id="_idIndexMarker1179"/> thing you need to know about, and that is the <strong class="source-inline">UAnimInstance::Montage_Play()</strong> function. This function requires the<a id="_idIndexMarker1180"/> Animation Montage to play, the play rate in which to play back the montage, a value of the <strong class="source-inline">EMontagePlayReturnType</strong> type, a <strong class="source-inline">float</strong> value for determining the start position to play the montage, and a <strong class="source-inline">Boolean</strong> value for determining whether playing this montage should stop or interrupt all montages.</p>
<p>Although you will not be changing the default parameter of <strong class="source-inline">EMontagePlayReturnType</strong>, which is <strong class="source-inline">EMontagePlayReturnType::MontageLength</strong>, it is still important to know the two values that exist for this enumerator:</p>
<ul>
<li><strong class="source-inline">Montage</strong> <strong class="source-inline">Length</strong>: The <strong class="source-inline">Montage</strong> <strong class="source-inline">Length</strong> value returns the length of the montage itself, in seconds.</li>
<li><strong class="source-inline">Duration</strong>: The <strong class="source-inline">Duration</strong> value returns the play duration of the montage, which is equal to the length of the montage, divided by the play rate.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more details regarding the <strong class="source-inline">UAnimMontage</strong> class, please refer to the following documentation: <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.xhtml</a>.</p>
<p>You will learn more<a id="_idIndexMarker1181"/> about the C++ implementation of <a id="_idIndexMarker1182"/>playing an Animation Montage in the next exercise.</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor306"/>Exercise 14.03 – playing the Throw animation in C++</h2>
<p>Now that you have a better <a id="_idIndexMarker1183"/>understanding of how to play Animation Montages in UE5, both via Blueprints and C++, it is time to migrate the logic for playing the <strong class="bold">Throw</strong> Animation Montage from Blueprints to C++. The reason behind this change is that <a id="_idIndexMarker1184"/>the Blueprint logic was put into place as a placeholder method so that you could preview the <strong class="bold">Throw</strong> montage. This book is a more heavily focused C++ guide to game development, and as such, it is important to learn how to implement this logic in code.</p>
<p>Let’s begin by removing the logic from Blueprints, and then move on to recreating the logic in C++ inside the player character class.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Navigate to the player character Blueprint, <strong class="source-inline">BP_SuperSideScroller_MainCharacter</strong>, which can be found in the <strong class="source-inline">/MainCharacter/Blueprints/</strong> directory. <em class="italic">Double-click</em> this asset to open it.</li>
<li>Inside this Blueprint, you will find the <strong class="bold">EnhancedInputAction IA_Throw</strong> event and the <strong class="bold">Play Montage</strong> function that you created to preview the <strong class="bold">Throw</strong> Animation Montage, as shown in the following screenshot. Delete this logic and then recompile and save the player character Blueprint:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer442">
<img alt="Figure 14.9 – You no longer need this placeholder logic inside the player character Blueprint " height="276" src="image/Figure_14.09_B18531.jpg" width="878"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – You no longer need this placeholder logic inside the player character Blueprint</p>
<ol>
<li value="3">Now, use <strong class="source-inline">PIE</strong> and attempt to throw with the player character by using the <em class="italic">left mouse button</em>. You will <a id="_idIndexMarker1185"/>observe that the player character no longer plays the <strong class="bold">Throw</strong> Animation Montage. Let’s fix this by adding the required<a id="_idIndexMarker1186"/> logic in C++.</li>
<li>Open the header file for the player character in Visual Studio – that is, <strong class="source-inline">SuperSideScroller_Player.h</strong>.</li>
<li>The first thing you need to do is create a new variable for the player character that will be used for the <strong class="bold">Throw</strong> animation. Add the following code under the <strong class="source-inline">Private</strong> access modifier:<p class="source-code">UPROPERTY(EditAnywhere)</p><p class="source-code">class UAnimMontage* ThrowMontage;</p></li>
</ol>
<p>Now that you have a variable that will represent the <strong class="bold">Throw</strong> Animation Montage, it is time to add the logic for playing the montage inside the <strong class="source-inline">SuperSideScroller_Player.cpp</strong> file.</p>
<ol>
<li value="6">Before you can make the call to <strong class="source-inline">UAnimInstance::Montage_Play()</strong>, you need to add the following <strong class="source-inline">include</strong> directory to the existing list at the top of the source file to have access to this function:<p class="source-code">#include "Animation/AnimInstance.h"</p></li>
</ol>
<p>As we know from <a href="B18531_09.xhtml#_idTextAnchor183"><em class="italic">Chapter 9</em></a>, <em class="italic">Adding Audio-Visual Elements</em>, the player character already has a function called <strong class="source-inline">ThrowProjectile</strong> that is called whenever the <em class="italic">left mouse button</em> is pressed. As a reminder, this is where the binding occurs in C++:</p>
<p class="source-code"> </p>
<p class="source-code">//Bind the pressed action Throw to your ThrowProjectile function</p>
<p class="source-code">EnhancedPlayerInput-&gt;BindAction(IA_Throw, ETriggerEvent::Triggered, this, &amp;ASuperSideScroller_Player::ThrowProjectile);</p>
<ol>
<li value="7">Update <strong class="source-inline">ThrowProjectile</strong> so that it plays <strong class="source-inline">ThrowMontage</strong>, which you set up earlier in this exercise. Add the<a id="_idIndexMarker1187"/> following <a id="_idIndexMarker1188"/>code to the <strong class="source-inline">ThrowProjectile()</strong> function. Then, we can discuss what is happening here:<p class="source-code">void ASuperSideScroller_Player::ThrowProjectile()</p><p class="source-code">{</p><p class="source-code">  if (ThrowMontage)</p><p class="source-code">  {</p><p class="source-code">    const bool bIsMontagePlaying = GetMesh()</p><p class="source-code">    -&gt;GetAnimInstance()-&gt;</p><p class="source-code">      Montage_IsPlaying(ThrowMontage);</p><p class="source-code">    if (!bIsMontagePlaying)</p><p class="source-code">    {</p><p class="source-code">      GetMesh()-&gt;GetAnimInstance()</p><p class="source-code">      -&gt;Montage_Play(ThrowMontage, </p><p class="source-code">        1.0f);</p><p class="source-code">    }</p><p class="source-code">    }    }</p></li>
</ol>
<p>The first line is checking if <strong class="source-inline">ThrowMontage</strong> is valid; if we don’t have a valid Animation Montage assigned, there is no point in continuing the logic. It can also be dangerous to use a <strong class="source-inline">NULL</strong> object in further function calls as it could result in a crash. Next, we are declaring a new Boolean variable, called <strong class="source-inline">bIsMontagePlaying</strong>, that determines whether <strong class="source-inline">ThrowMontage</strong> is already playing on the player <a id="_idIndexMarker1189"/>character’s skeletal mesh. This check is made because the <strong class="bold">Throw</strong> Animation Montage should not be played while it is already playing; this will cause the animation to break if the player repeatedly <a id="_idIndexMarker1190"/>presses the <em class="italic">left mouse button</em>.</p>
<p>So long as the preceding conditions are met, it is safe to move on and play the Animation Montage.</p>
<ol>
<li value="8">Inside the <strong class="source-inline">If</strong> statement, you are telling the player’s skeletal mesh to play <strong class="source-inline">ThrowMontage</strong> with a play rate of <strong class="source-inline">1.0f</strong>. This value is used so that the Animation Montage plays back at the speed it is intended to. Values larger than <strong class="source-inline">1.0f</strong> will make the montage play back faster, while values lower than <strong class="source-inline">1.0f</strong> will make the montage play back slower. The other parameters that you learned about, such as the start position or the <strong class="source-inline">EMontagePlayReturnType</strong> parameter, can be left at their defaults. Back inside the UE5 editor, perform a recompile of the code, as you have done in the past.</li>
<li>After the code recompiles successfully, navigate back to the player character Blueprint, <strong class="source-inline">BP_SuperSideScroller_MainCharacter</strong>, which can be found in the <strong class="source-inline">/MainCharacter/Blueprints/</strong> directory. <em class="italic">Double-click</em> this asset to open it.</li>
<li>In the <strong class="bold">Details</strong> panel of the player character, you will now see the <strong class="source-inline">Throw Montage</strong> parameter that you added.</li>
<li><em class="italic">Left-click</em> on the drop-down menu for the <strong class="source-inline">Throw Montage</strong> parameter to find the <strong class="source-inline">AM_Throw</strong> montage. <em class="italic">Left-click</em> again on the <strong class="source-inline">AM_Throw</strong> montage to select it for this parameter. Please refer to the following screenshot to see how the variable should be set up:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer443">
<img alt="Figure 14.10 – The Throw montage has been assigned the AM_Throw montage " height="91" src="image/Figure_14.10_B18531.jpg" width="567"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – The Throw montage has been assigned the AM_Throw montage</p>
<ol>
<li value="12">Recompile and <a id="_idIndexMarker1191"/>save the player character Blueprint. Then, use <strong class="source-inline">PIE</strong> to spawn<a id="_idIndexMarker1192"/> the player character and use the <em class="italic">left mouse button</em> to play <strong class="source-inline">Throw Montage</strong>. The following screenshot shows this in action:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer444">
<img alt="Figure 14.11 – The player character is now able to perform the Throw animation again " height="411" src="image/Figure_14.11_B18531.jpg" width="630"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – The player character is now able to perform the Throw animation again</p>
<p>By completing this exercise, you have learned how to add an <strong class="source-inline">Animation Montage</strong> parameter to the player character, as well as how to play the montage in C++. In addition to playing the <strong class="bold">Throw</strong> Animation Montage in C++, you added the ability to control how often the <strong class="bold">Throw</strong> animation <a id="_idIndexMarker1193"/>can be played by adding a check for <a id="_idIndexMarker1194"/>whether the montage is already playing. By doing this, you have prevented the player from spamming the <strong class="source-inline">Throw</strong> input and causing the animation to break or not play entirely.</p>
<p class="callout-heading">Note</p>
<p class="callout">Try setting the play rate of <strong class="source-inline">Animation Montage</strong> from <strong class="source-inline">1.0f</strong> to <strong class="source-inline">2.0f</strong> and recompile the code. Observe how increasing the play rate of the animation affects how the animation looks and feels for the player.</p>
<p>Before moving on to spawning the player projectile, let’s set up the <strong class="source-inline">Socket</strong> location in the player character’s <strong class="bold">Skeleton</strong> so that the projectile can spawn from the <em class="italic">player’s hand</em> during the <strong class="bold">Throw</strong> animation.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor307"/>Exercise 14.04 – creating the projectile spawn socket</h2>
<p>To spawn the player projectile, you <a id="_idIndexMarker1195"/>need to determine the <strong class="bold">Transform</strong> properties in which the projectile will spawn while primarily focusing on <strong class="bold">Location</strong> and <strong class="bold">Rotation</strong>, rather than <strong class="bold">Scale</strong>.</p>
<p>In this exercise, you will create a new <strong class="bold">Socket</strong> on the player character’s <strong class="bold">Skeleton</strong> that you can then reference in code to obtain the transform from which to spawn the projectile.</p>
<p>Let’s get started:</p>
<ol>
<li value="1">Inside UE5, navigate to the <strong class="bold">Content Drawer</strong> interface and find the <strong class="source-inline">/MainCharacter/Mesh/</strong> directory.</li>
<li>In this directory, find the <strong class="bold">Skeleton</strong> asset; that is, <strong class="source-inline">MainCharacter_Skeleton.uasset</strong>. <em class="italic">Double-click</em> to open this <strong class="bold">Skeleton</strong>.</li>
</ol>
<p>To determine the best position for where the projectile should spawn, we need to add the <strong class="bold">Throw</strong> Animation Montage as the preview animation for the skeleton.</p>
<ol>
<li value="3">In the <strong class="bold">Preview Scene Settings</strong> panel, under the <strong class="bold">Animation</strong> category, find the <strong class="source-inline">Preview Controller</strong> parameter and select the <strong class="bold">Use Specific Animation</strong> option.</li>
<li>Next, <em class="italic">left-click</em> on the drop-down menu to find and select the <strong class="bold">AM_Throw</strong> Animation Montage from the list of available animations.</li>
</ol>
<p>Now, the player <a id="_idIndexMarker1196"/>character’s <strong class="bold">Skeleton</strong> will start previewing the <strong class="bold">Throw</strong> Animation Montage, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer445">
<img alt="Figure 14.12 – The player character previewing the Throw Animation Montage " height="624" src="image/Figure_14.12_B18531.jpg" width="536"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – The player character previewing the Throw Animation Montage</p>
<p>As you may recall from <em class="italic">Exercise 14.02 – adding the notify to the Throw montage</em>, you added <strong class="source-inline">Anim_ProjectileNotify</strong> at the 22nd frame of the <strong class="bold">Throw</strong> animation.</p>
<ol>
<li value="5">Using the timeline at the bottom of the <strong class="bold">Skeleton</strong> editor, move the red bar to as close to the 22nd frame as you can. Please refer to the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer446">
<img alt="Figure 14.13 – The same 22nd frame in which you added Anim_ProjectileNotify earlier " height="59" src="image/Figure_14.13_B18531.jpg" width="397"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13 – The same 22nd frame in which you added Anim_ProjectileNotify earlier</p>
<p>At the 22nd frame <a id="_idIndexMarker1197"/>of the <strong class="bold">Throw</strong> animation, the player character should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer447">
<img alt="Figure 14.14 – The character’s hand in position to release a projectile " height="432" src="image/Figure_14.14_B18531.jpg" width="292"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.14 – The character’s hand in position to release a projectile</p>
<p>As shown in the preceding screenshot, at the 22nd frame of the <strong class="bold">Throw</strong> Animation Montage, the character’s hand is in position to release a projectile.</p>
<p>As you can see, the player character will be throwing the projectile from their <em class="italic">right hand</em>, so the new <strong class="source-inline">Socket</strong> should be attached to it. Let’s take a look at the skeletal hierarchy of the player character, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer448">
<img alt="Figure 14.15 – The RightHand bone within the hierarchy of the player character’s skeleton " height="336" src="image/Figure_14.15_B18531.jpg" width="222"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.15 – The RightHand bone within the hierarchy of the player character’s skeleton</p>
<ol>
<li value="6">From the skeletal hierarchy, find the <strong class="bold">RightHand</strong> bone. This can be found underneath the <strong class="bold">RightShoulder</strong> bone hierarchy structure.</li>
<li><em class="italic">Right-click</em> on the <strong class="bold">RightHand</strong> bone and <em class="italic">left-click</em> the <strong class="bold">Add Socket</strong> option from the list of options that appears. Name this socket <strong class="bold">ProjectileSocket</strong>.</li>
</ol>
<p>Also, when adding<a id="_idIndexMarker1198"/> a new <strong class="source-inline">Socket</strong>, the hierarchy of the entire <strong class="bold">RightHand</strong> will expand and the new socket will appear at the bottom. </p>
<ol>
<li value="8">With <strong class="bold">ProjectileSocket</strong> selected, use the <strong class="bold">Transform</strong> widget gizmo to position this <strong class="source-inline">Socket </strong>at the following location:<p class="source-code">Location = (X=30.145807,Y=36.805481,Z=-10.23186)</p></li>
</ol>
<p>The final result should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer449">
<img alt="Figure 14.16 – The final position of ProjectileSocket at the 22nd frame of the Throw animation in world space " height="558" src="image/Figure_14.16_B18531.jpg" width="653"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.16 – The final position of ProjectileSocket at the 22nd frame of the Throw animation in world space</p>
<p>If your gizmo looks a<a id="_idIndexMarker1199"/> bit different, that is because the preceding screenshot shows the socket location in world space, not local space.</p>
<ol>
<li value="9">Now that <strong class="bold">ProjectileSocket</strong> is positioned where you want it, save the <strong class="source-inline">MainCharacter_Skeleton</strong> asset.</li>
</ol>
<p>With this exercise complete, you now know the location that the player projectile will spawn from. Since you used the <strong class="bold">Throw</strong> Animation Montage in the preview and used the same 22nd frame of the animation, you know this position will be correct based on when <strong class="source-inline">Anim_ProjectileNotify</strong> will fire.</p>
<p>Now, let’s spawn the player projectile in C++.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor308"/>Exercise 14.05 – preparing the SpawnProjectile() Function</h2>
<p>Now that you have <strong class="bold">ProjectileSocket</strong> in place and there is a location from which to spawn the player <a id="_idIndexMarker1200"/>projectile, let’s add the code necessary to spawn the player projectile.</p>
<p>By the end of this exercise, you will have the function ready to spawn the projectile and it will be ready to call from the <strong class="source-inline">Anim_ProjectileNotify</strong> class.</p>
<p>Follow these steps:</p>
<ol>
<li value="1">From Visual Studio, navigate to the <strong class="source-inline">SuperSideScroller_Player.h</strong> header file.</li>
<li>You need a class reference variable for the <strong class="source-inline">PlayerProjectile</strong> class. You can do this using the <strong class="source-inline">TsubclassOf</strong> variable template class type. Add the following code to the header file, under the <strong class="source-inline">Private</strong> access modifier:<p class="source-code">UPROPERTY(EditAnywhere)</p><p class="source-code">TSubclassOf&lt;class APlayerProjectile&gt; PlayerProjectile;</p></li>
</ol>
<p>Now that you have the variable ready, it is time to declare the function you will use to spawn the projectile.</p>
<ol>
<li value="3">Add the following function declaration under the declaration of the void <strong class="source-inline">ThrowProjectile()</strong> function and the <strong class="source-inline">Public</strong> access modifier:<p class="source-code">void SpawnProjectile();</p></li>
<li>Before preparing the definition of the <strong class="source-inline">SpawnProjectile()</strong> function, add the following <strong class="source-inline">include</strong> directories to the list of includes in the <strong class="source-inline">SuperSideScroller_Player.cpp</strong> source file:<p class="source-code">#include "PlayerProjectile.h"</p><p class="source-code">#include "Engine/World.h"</p><p class="source-code">#include "Components/SphereComponent.h"</p></li>
</ol>
<p>You need to include <strong class="source-inline">PlayerProjectile.h</strong> because it is required to reference the collision component of the projectile class. Next, you must use the <strong class="source-inline">Engine/World.h</strong> include to use the <strong class="source-inline">SpawnActor()</strong> function and access the <strong class="source-inline">FActorSpawnParameters</strong> struct. Lastly, you need to use the <strong class="source-inline">Components/SphereComponent.h</strong> include to update the collision component of the player projectile so that it will ignore the player.</p>
<ol>
<li value="5">Next, create the definition of the <strong class="source-inline">SpawnProjectile()</strong> function at the bottom of the <strong class="source-inline">SuperSideScroller_Player.cpp</strong> source file, as shown here:<p class="source-code">void ASuperSideScroller_Player::SpawnProjectile()</p><p class="source-code">{</p><p class="source-code">}</p></li>
</ol>
<p>The first thing this function needs to do is check whether the <strong class="source-inline">PlayerProjectile</strong> class variable is <a id="_idIndexMarker1201"/>valid. If this object is not valid, there is no point in continuing to try and spawn it.</p>
<ol>
<li value="6">Update the <strong class="source-inline">SpawnProjectile()</strong> function so that it looks as follows:<p class="source-code">void ASuperSideScroller_Player::SpawnProjectile()</p><p class="source-code">{</p><p class="source-code">  if(PlayerProjectile)</p><p class="source-code">    {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Now, if the <strong class="source-inline">PlayerProjectile</strong> object is valid, you’ll want to obtain the <strong class="source-inline">UWorld</strong> object that the player currently exists in and ensure that this world is valid before continuing.</p>
<ol>
<li value="7">Update the <strong class="source-inline">SpawnProjectile()</strong> function to the following:<p class="source-code">void ASuperSideScroller_Player::SpawnProjectile()</p><p class="source-code">{</p><p class="source-code">  if(PlayerProjectile)</p><p class="source-code">    {</p><p class="source-code">      UWorld* World = GetWorld();</p><p class="source-code">      if (World)</p><p class="source-code">        {</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>At this point, you have made safety checks to ensure that both <strong class="source-inline">PlayerProjectile</strong> and <strong class="source-inline">UWorld</strong> are valid, so now, it is safe to attempt to spawn the projectile. The first thing you must do is declare a new variable of the <strong class="source-inline">FactorSpawnParameters</strong> type and assign the player as the owner.</p>
<ol>
<li value="8">Add the following code within<a id="_idIndexMarker1202"/> the most recent <strong class="source-inline">if</strong> statement so that the <strong class="source-inline">SpawnProjectile()</strong> function looks like this:<p class="source-code">void ASuperSideScroller_Player::SpawnProjectile()</p><p class="source-code">{</p><p class="source-code">  if(PlayerProjectile)</p><p class="source-code">    {</p><p class="source-code">      UWorld* World = GetWorld();</p><p class="source-code">      if (World)</p><p class="source-code">        {</p><p class="source-code">          FActorSpawnParameters SpawnParams;</p><p class="source-code">          SpawnParams.Owner = this;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>As you learned previously, the <strong class="source-inline">SpawnActor()</strong> function call from the <strong class="source-inline">UWorld</strong> object will require the <strong class="source-inline">FActorSpawnParameters</strong> struct as part of the spawned object’s initialization. In the case of the player projectile, you can use the <strong class="source-inline">this</strong> keyword as a reference to the player character class for the owner of the projectile. </p>
<ol>
<li value="9">Next, you need to handle the <strong class="source-inline">Location</strong> and <strong class="source-inline">Rotation</strong> parameters of the <strong class="source-inline">SpawnActor()</strong> function. Add the following lines under the latest line – that is, <strong class="source-inline">SpawnParams.Owner = this</strong>:<p class="source-code">const FVector SpawnLocation = this-&gt;GetMesh()-</p><p class="source-code">  &gt;GetSocketLocation(FName("ProjectileSocket"));</p><p class="source-code">const FRotator Rotation = GetActorForwardVector().Rotation();</p></li>
</ol>
<p>In the first line, you declare a new <strong class="source-inline">FVector</strong> variable called <strong class="source-inline">SpawnLocation</strong>. This vector <a id="_idIndexMarker1203"/>uses the <strong class="source-inline">Socket</strong> location of the <strong class="source-inline">ProjectileSocket</strong> socket that you created in the previous exercise. The <strong class="source-inline">Skeletal Mesh</strong> component returned from the <strong class="source-inline">GetMesh()</strong> function contains a function called <strong class="source-inline">GetSocketLocation()</strong> that will return the location of the socket with the <strong class="source-inline">FName</strong> property that is passed in – in this case, <strong class="source-inline">ProjectileSocket</strong>.</p>
<p>In the second line, you are declaring a new <strong class="source-inline">FRotator</strong> variable called <strong class="source-inline">Rotation</strong>. This value is set to the player’s forward vector and converted into a <strong class="source-inline">Rotator</strong> container. This will ensure that the rotation – or in other words, the direction in which the player projectile will spawn – will be in front of the player, and it will move away from the player.</p>
<p>Now, all of the parameters required to spawn the projectile are ready.</p>
<ol>
<li value="10">Add the following line underneath the code from the previous step:<p class="source-code">APlayerProjectile* Projectile = World-</p><p class="source-code">  &gt;SpawnActor&lt;APlayerProjectile&gt;(PlayerProjectile, </p><p class="source-code">  SpawnLocation, </p><p class="source-code">  Rotation, SpawnParams);</p></li>
</ol>
<p>The <strong class="source-inline">World-&gt;SpawnActor()</strong> function will return an object of the class you are attempting to spawn in – in this case, <strong class="source-inline">APlayerProjectile</strong>. This is why you are adding <strong class="source-inline">APlayerProjectile* Projectile</strong> before the actual spawning occurs. Then, you are passing in the <strong class="source-inline">SpawnLocation</strong>, <strong class="source-inline">Rotation</strong>, and <strong class="source-inline">SpawnParams</strong> parameters to ensure that the projectile is spawning where and how you want.</p>
<ol>
<li value="11">Return to the editor to recompile the newly added code. After the code compiles successfully, this exercise is complete.</li>
</ol>
<p>With this exercise complete, you now have a function that will spawn the player projectile class that is assigned inside<a id="_idIndexMarker1204"/> the player character. By adding safety checks for the validity of both the projectile and the world, you can ensure that if an object is spawned, it is a valid object inside a valid world.</p>
<p>You set up the appropriate <strong class="source-inline">location</strong>, <strong class="source-inline">rotation</strong>, and <strong class="source-inline">FActorSpawnParameters</strong> parameters for the <strong class="source-inline">UWorld SpawnActor()</strong> function to ensure that the player projectile spawns at the right location, based on the socket location from the previous exercise, with the appropriate direction so that it moves away from the player, and with the player character as its owner.</p>
<p>Now, it is time to update the <strong class="source-inline">Anim_ProjectileNotify</strong> source file so that it spawns the projectile.</p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor309"/>Exercise 14.06 – updating the Anim_ProjectileNotify class</h2>
<p>The function that allows the<a id="_idIndexMarker1205"/> player projectile to spawn is ready, but you aren’t calling this function anywhere yet. Back in <em class="italic">Exercise 14.01 – creating a UAnim Notify class</em>, you created the <strong class="source-inline">Anim_ProjectileNotify</strong> class, while in <em class="italic">Exercise 14.02 – adding the notify to the Throw montage</em>, you added this notify to the <strong class="bold">Throw</strong> Animation Montage.</p>
<p>Now, it is time to update the <strong class="source-inline">UanimNotify</strong> class so that it calls the <strong class="source-inline">SpawnProjectile()</strong> function.</p>
<p>Follow these steps:</p>
<ol>
<li value="1">In Visual Studio, open the <strong class="source-inline">Anim_ProjectileNotify.cpp</strong> source file.</li>
</ol>
<p>In the source file, you have the following code:</p>
<p class="source-code"> #include "Anim_ProjectileNotify.h"</p>
<p class="source-code">void UAnim_ProjectileNotify::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference&amp; EventReference)</p>
<p class="source-code">{</p>
<p class="source-code">   Super::Notify(MeshComp, Animation, EventReference);</p>
<p class="source-code">   UE_LOG(LogTemp, Warning, TEXT("Throw Notify"));</p>
<p class="source-code">}</p>
<ol>
<li value="2">Remove the <strong class="source-inline">UE_LOG()</strong> line from the <strong class="source-inline">Notify()</strong> function.</li>
<li>Next, add the following <strong class="source-inline">include</strong> lines underneath <strong class="source-inline">Anim_ProjectileNotify.h</strong>:<p class="source-code">#include "Components/SkeletalMeshComponent.h"</p><p class="source-code">#include "SuperSideScroller/SuperSideScroller_Player.h"</p></li>
</ol>
<p>You need to include the <strong class="source-inline">SuperSideScroller_Player.h</strong> header file because it is<a id="_idIndexMarker1206"/> required to call the <strong class="source-inline">SpawnProjectile()</strong> function you created in the previous exercise. We also included <strong class="source-inline">SkeletalMeshComponent.h</strong> because we will reference this component inside the <strong class="source-inline">Notify()</strong> function, so it’s best to include it here too.</p>
<p>The <strong class="source-inline">Notify()</strong> function passes in a reference to the owning <strong class="source-inline">Skeletal Mesh</strong>, labeled <strong class="source-inline">MeshComp</strong>. You can use this skeletal mesh to get a reference to the player character by using the <strong class="source-inline">GetOwner()</strong> function and casting the returned actor to your <strong class="source-inline">SuperSideScroller_Player</strong> class. We’ll do this next.</p>
<ol>
<li value="4">Inside the <strong class="source-inline">Notify()</strong> function, add<a id="_idIndexMarker1207"/> the following line of code:<p class="source-code">ASuperSideScroller_Player* Player = </p><p class="source-code">  Cast&lt;ASuperSideScroller_Player&gt;(</p><p class="source-code">  MeshComp-&gt;GetOwner());</p></li>
<li>Now that you have a reference to the player, you need to add a validity check for the <strong class="source-inline">Player</strong> variable before making a call to the <strong class="source-inline">SpawnProjectile()</strong> function. Add the following lines of code after the line from the previous step:<p class="source-code">if (Player)</p><p class="source-code">{</p><p class="source-code">  Player-&gt;SpawnProjectile();</p><p class="source-code">}</p></li>
<li>Now that the <strong class="source-inline">SpawnProjectile()</strong> function is being called from the <strong class="source-inline">Notify()</strong> function, return to the editor to recompile and hot-reload the code changes you have made.</li>
</ol>
<p>Before you can use <strong class="source-inline">PIE</strong> to run around and throw the player projectile, you need to assign the <strong class="source-inline">Player Projectile</strong> variable from the previous exercise. </p>
<ol>
<li value="7">Inside the <strong class="bold">Content Drawer</strong> interface, navigate to the <strong class="source-inline">/MainCharacter/Blueprints</strong> directory to find the <strong class="source-inline">BP_SuperSideScroller_MainCharacter</strong> Blueprint. <em class="italic">Double-click</em> to open the Blueprint.</li>
<li>In the <strong class="bold">Details</strong> panel, underneath the <strong class="source-inline">Throw Montage</strong> parameter, you will find the <strong class="source-inline">Player Projectile</strong> parameter. <em class="italic">Left-click</em> the drop-down option for this parameter and find <strong class="source-inline">BP_PlayerProjectile</strong>. <em class="italic">Left-click</em> on this option to assign it to the <strong class="source-inline">Player Projectile</strong> variable.</li>
<li>Recompile and save the <strong class="source-inline">BP_SuperSideScroller_MainCharacter</strong> Blueprint. </li>
<li>Now, use <strong class="source-inline">PIE</strong> and use the <em class="italic">left mouse button</em>. The player character will play the <strong class="bold">Throw</strong> animation and the player projectile will spawn.</li>
</ol>
<p>Notice that the<a id="_idIndexMarker1208"/> projectile is spawned from the <strong class="source-inline">ProjectileSocket</strong> function you created and that it moves away from the player. The following screenshot shows this in action:</p>
<div>
<div class="IMG---Figure" id="_idContainer450">
<img alt="Figure 14.17 – The player can now throw the player projectile " height="490" src="image/Figure_14.17_B18531.jpg" width="768"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.17 – The player can now throw the player projectile</p>
<p>With this exercise complete, the player can now throw the player projectile. The player projectile, in its current state, is ineffective against enemies and just flies through the air. It took a lot of moving parts between the <strong class="bold">Throw</strong> Animation Montage, the <strong class="source-inline">Anim_ProjectileNotify</strong> class, and the player character to get the player to throw the projectile.</p>
<p>In the upcoming section and<a id="_idIndexMarker1209"/> exercises, you will update the player projectile so that it destroys enemies and play additional effects such as particles and sound.</p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor310"/>Destroying actors</h1>
<p>So far in this chapter, we have put a lot<a id="_idIndexMarker1210"/> of focus on spawning, or creating, actors inside the game world; the player character uses the <strong class="source-inline">UWorld</strong> class to spawn the projectile. UE5 and its base <strong class="source-inline">Actor</strong> class come with a default function that you can use to destroy, or remove, an actor from the game world:</p>
<p class="source-code">bool AActor::Destroy( bool bNetForce, bool bShouldModifyLevel )</p>
<p>You can find the full implementation of this function in Visual Studio by finding the <strong class="source-inline">Actor.cpp</strong> source file in the <strong class="source-inline">/Source/Runtime/Engine/Actor.cpp</strong> directory. This function exists in all the classes that extend from the <strong class="source-inline">Actor</strong> class, and in the case of UE5, it exists in all classes that can be spawned, or placed, inside the game world. To be more explicit, both the <strong class="source-inline">EnemyBase</strong> and <strong class="source-inline">PlayerProjectile</strong> classes are <em class="italic">children</em> of the <strong class="source-inline">Actor</strong> class, so they can be destroyed.</p>
<p>Looking further into the <strong class="source-inline">AActor::Destroy()</strong> function, you will find the following line:</p>
<p class="source-code">World-&gt;DestroyActor( this, bNetForce, bShouldModifyLevel );</p>
<p>We won’t be going into further detail about what exactly the <strong class="source-inline">UWorld</strong> class does to destroy an actor, but it is important to emphasize the fact that the <strong class="source-inline">UWorld</strong> class is responsible for both creating and destroying actors inside the world. Feel free to dig deeper into the source engine code to find more information about how the <strong class="source-inline">UWorld</strong> class handles destroying and spawning actors.</p>
<p>Now that you have more context regarding how UE5 handles destroying and removing actors from the game world, we’ll implement this ourselves for the enemy character.</p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor311"/>Exercise 14.07 – creating the DestroyEnemy() function</h2>
<p>The main part of the gameplay for the <strong class="source-inline">Super</strong> <strong class="source-inline">SideScroller</strong> game is for the player to move around the level and use the projectile to destroy enemies. At this point in the project, you have handled the player <a id="_idIndexMarker1211"/>movement and spawning the player projectile. However, the projectile does not destroy enemies yet.</p>
<p>To get this functionality in place, we’ll start by adding some logic to the <strong class="source-inline">EnemyBase</strong> class so that it knows how to handle its destruction and remove it from the game once it collides with the player projectile.</p>
<p>Follow these steps to achieve this:</p>
<ol>
<li value="1">First, navigate to Visual Studio and open the <strong class="source-inline">EnemyBase.h</strong> header file.</li>
<li>In the header file, create the declaration of a new function called <strong class="source-inline">DestroyEnemy()</strong> under the <strong class="source-inline">Public</strong> access modifier, as shown here:<p class="source-code">public:</p><p class="source-code">  void DestroyEnemy();</p></li>
</ol>
<p>Make sure this function definition is written underneath <strong class="source-inline">GENERATED_BODY()</strong>, within the class definition.</p>
<ol>
<li value="3">Save these changes to the header file and open the <strong class="source-inline">EnemyBase.cpp</strong> source file to add the implementation of this function.</li>
<li>Below the <strong class="source-inline">#include</strong> lines, add the following function definition:<p class="source-code">void AEnemyBase::DestroyEnemy()</p><p class="source-code">{</p><p class="source-code">}</p></li>
</ol>
<p>For now, this function will be very simple. All you need to do is call the inherited <strong class="source-inline">Destroy()</strong> function from the base <strong class="source-inline">Actor</strong> class.</p>
<ol>
<li value="5">Update the <strong class="source-inline">DestroyEnemy()</strong> function so that it looks like this:<p class="source-code">void AEnemyBase::DestroyEnemy()</p><p class="source-code">{</p><p class="source-code">  Destroy();</p><p class="source-code">}</p></li>
<li>With this function complete, save the source file and return to the editor so that you can recompile and hot-reload the code.</li>
</ol>
<p>With this exercise complete, the enemy character now has a function that can easily handle the destruction of the actor whenever you choose. The <strong class="source-inline">DestroyEnemy()</strong> function is publicly accessible so that it can be called by other classes, which will come in handy later when you <a id="_idIndexMarker1212"/>handle the destruction of the player projectile.</p>
<p>The reason you’re creating a unique function to destroy the enemy actor is that you will use this function later in this chapter to add VFX and SFX to the enemy when they are destroyed by the player projectile. </p>
<p>Before polishing the elements of the enemy’s destruction, let’s implement a similar function inside the player projectile class so that it can also be destroyed.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor312"/>Exercise 14.08 – destroying projectiles</h2>
<p>Now that the enemy characters <a id="_idIndexMarker1213"/>can handle being destroyed through the new <strong class="source-inline">DestroyEnemy()</strong> function you implemented in the previous exercise, it is time to do the same for the player projectile.</p>
<p>By the end of this exercise, the player projectile will have a unique function to handle it being destroyed and removed from the game world.</p>
<p>Let’s get started:</p>
<ol>
<li value="1">In Visual Studio, open the header file for the player projectile – that is, <strong class="source-inline">PlayerProjectile.h</strong>.</li>
<li>Under the <strong class="source-inline">Public</strong> access modifier, add the following function declaration:<p class="source-code">void ExplodeProjectile();</p></li>
<li>Next, open the source file for the player projectile – that is, <strong class="source-inline">PlayerProjectile.cpp</strong>.</li>
<li>Underneath the void <strong class="source-inline">APlayerProjectile::OnHit</strong> function, add the definition of the <strong class="source-inline">ExplodeProjectile()</strong> function:<p class="source-code">void APlayerProjectile::ExplodeProjectile()</p><p class="source-code">{</p><p class="source-code">}</p></li>
</ol>
<p>For now, this function will work<a id="_idIndexMarker1214"/> identically to the <strong class="source-inline">DestroyEnemy()</strong> function from the previous exercise.</p>
<ol>
<li value="5">Add the inherited <strong class="source-inline">Destroy()</strong> function to the new <strong class="source-inline">ExplodeProjectile()</strong> function, like so:<p class="source-code">void APlayerProjectile::ExplodeProjectile()</p><p class="source-code">{</p><p class="source-code">  Destroy();</p><p class="source-code">}</p></li>
<li>With this function complete, save the source file and return to the editor so that you can recompile and hot-reload the code.</li>
</ol>
<p>With this exercise complete, the player projectile now has a function that can easily handle the destruction of the actor whenever you choose. The reason you need to create a unique function to handle destroying the player projectile actor is the same reason you created the <strong class="source-inline">DestroyEnemy()</strong> function – you will use this function later in this chapter to add VFX and SFX to the player projectile when it collides with another actor.</p>
<p>Now that you have experience with implementing the <strong class="source-inline">Destroy()</strong> function inside both the player projectile and the enemy character, it is time to put these two elements together.</p>
<p>In the next activity, you will enable the player projectile to destroy the enemy character when they collide.</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor313"/>Activity 14.01 – Allow the projectile to destroy enemies</h2>
<p>Now that both the player projectile and the enemy character can handle being destroyed, it is time <a id="_idIndexMarker1215"/>to go the extra mile and allow the player projectile to destroy the enemy character when they collide.</p>
<p>Follow these steps to achieve this:</p>
<ol>
<li value="1">Add the <strong class="source-inline">#include</strong> statement for the <strong class="source-inline">EnemyBase.h</strong> header file toward the top of the <strong class="source-inline">PlayerProjectile.cpp</strong> source file.</li>
<li>Within the void <strong class="source-inline">APlayerProjectile::OnHit()</strong> function, create a new variable of the <strong class="source-inline">AEnemyBase*</strong> type and call this variable <strong class="source-inline">Enemy</strong>.</li>
<li>Cast the <strong class="source-inline">OtherActor</strong> parameter of the <strong class="source-inline">APlayerProjectile::OnHit()</strong> function to the <strong class="source-inline">AEnemyBase*</strong> class and set the <strong class="source-inline">Enemy</strong> variable to the result of this cast.</li>
<li>Use an <strong class="source-inline">if()</strong> statement to check the validity of the <strong class="source-inline">Enemy</strong> variable.</li>
<li>If the <strong class="source-inline">Enemy</strong> variable is valid, call the <strong class="source-inline">DestroyEnemy()</strong> function from this <strong class="source-inline">Enemy</strong>.</li>
<li>After the <strong class="source-inline">if()</strong> block, make a call to the <strong class="source-inline">ExplodeProjectile()</strong> function.</li>
<li>Save the changes to the source file and return to the UE5 editor.</li>
<li>Use <strong class="source-inline">PIE</strong> and then use the player projectile against an enemy to observe the results.</li>
</ol>
<p>The expected output is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer451">
<img alt="Figure 14.18 – The player throwing the projectile " height="463" src="image/Figure_14.18_B18531.jpg" width="700"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.18 – The player throwing the projectile</p>
<p>When the projectile<a id="_idIndexMarker1216"/> hits the enemy, the enemy character is destroyed, as shown here:</p>
<div>
<div class="IMG---Figure" id="_idContainer452">
<img alt="Figure 14.19 – The projectile and enemy have been destroyed " height="422" src="image/Figure_14.19_B18531.jpg" width="765"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.19 – The projectile and enemy have been destroyed</p>
<p>With this activity complete, the player projectile and the enemy character can be destroyed when they collide with each other. Additionally, the player projectile will be destroyed whenever another actor triggers its <strong class="source-inline">APlayerProjectile::OnHit()</strong> function.</p>
<p>With that, a major element of the <strong class="source-inline">Super</strong> <strong class="source-inline">SideScroller</strong> game has been completed: the player projectile <a id="_idIndexMarker1217"/>spawning and the enemies being destroyed when they collide with the projectile. You can observe that destroying these actors is very simple and not very interesting to the player.</p>
<p>This is why, in the upcoming exercises in this chapter, you will learn more about <strong class="bold">visual effects</strong> and <strong class="bold">audio effects</strong>, or <strong class="bold">VFX</strong> and <strong class="bold">SFX</strong>, respectively. You will also implement these elements for the enemy character and player projectile.</p>
<p>Now that both the enemy character and the player projectile can be destroyed, let’s briefly discuss what VFX and SFX are, and how they will impact the project.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor314"/>Understanding and implementing visual and audio effects</h1>
<p>VFX such as Particle Systems <a id="_idIndexMarker1218"/>and sound effects such as sound cues play an important role in video games. They add a level of polish on top of systems, game mechanics, and even basic actions that make these elements more interesting or more pleasing to perform.</p>
<p>Let’s start by understanding VFX, followed by SFX.</p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor315"/>VFX</h2>
<p>VFX, in the context of UE5, are <a id="_idIndexMarker1219"/>made up of what’s called <strong class="bold">particle systems</strong>. Particle Systems are made up of emitters, and emitters consist of modules. In these modules, you can control the<a id="_idIndexMarker1220"/> appearance and behavior of the emitter using materials, meshes, and mathematical modules. The result can be anything from a fire torch or snow falling to rain, dust, and so on.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more here: <a href="https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.xhtml">https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.xhtml</a>.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor316"/>Audio effects (SFX)</h2>
<p>SFX, in the context of UE5, are made up of a <a id="_idIndexMarker1221"/>combination of sound waves and sound cues:</p>
<ul>
<li>Sound waves are <strong class="source-inline">.wav</strong> audio format files that <a id="_idIndexMarker1222"/>can be imported into UE5.</li>
<li>Sound cues combine sound wave audio files with other nodes such as <strong class="bold">Oscillator</strong>, <strong class="bold">Modulator</strong>, and <strong class="bold">Concatenator</strong> to create unique and complex sounds for your game.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more here: <a href="https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.xhtml">https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.xhtml</a>.</p>
<p>In the context of UE5, VFX <a id="_idIndexMarker1223"/>were created using a tool called <strong class="bold">Cascade</strong>, where artists could combine the use of <strong class="bold">materials</strong>, <strong class="bold">static meshes</strong>, and <strong class="bold">math</strong> to create interesting and convincing effects for the game world. This book will not dive into how this tool works, but you<a id="_idIndexMarker1224"/> can find information about Cascade here: <a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/ParticleSystems/">https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/ParticleSystems/</a>.</p>
<p>In more recent versions of the engine, starting in the 4.20 update, there is a plugin called <strong class="bold">Niagara</strong> that can be enabled to create VFX. Niagara, unlike<a id="_idIndexMarker1225"/> Cascade, uses a system similar to Blueprints, where you can visually script the behaviors of the effect rather than use <a id="_idIndexMarker1226"/>preset modules with predefined behavior. You can find more information about Niagara here: <a href="https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml">https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml</a>. Furthermore, Cascade will be deprecated in new versions of UE5 and Niagara will be used. For the sake of this book, we will still use Cascade particle effects.</p>
<p>In <a href="B18531_09.xhtml#_idTextAnchor183"><em class="italic">Chapter 9</em></a>, <em class="italic">Adding</em> <em class="italic">Audio-Visual Elements</em>, you learned more about audio and how audio is handled inside UE5. All you need to know right now is that UE5 uses the <strong class="source-inline">.wav</strong> file format to import audio into the engine. From there, you can use the <strong class="source-inline">.wav</strong> file directly, referred to as sound waves in the editor, or you can convert these assets into sound cues, which allow you to add <a id="_idIndexMarker1227"/>audio effects on top of the sound wave.</p>
<p>Lastly, there is one important class to know about that you will be referencing in the upcoming exercises, and this class is called <strong class="source-inline">UGameplayStatics</strong>. This is a static class in UE5 that can be used from both C++ and Blueprints, and it offers a variety of useful gameplay-related functions. The two functions you will be working with in the upcoming exercise are as follows:</p>
<p class="source-code">UGameplayStatics::SpawnEmitterAtLocation</p>
<p class="source-code">UGameplayStatics:SpawnSoundAtLocation</p>
<p>These two functions work in very similar ways; they both require a <strong class="source-inline">World</strong> context object in which to spawn the effect, the Particle System or audio to spawn, and the location in which to spawn the effect. You will be using these functions to spawn the destroy effects for the enemy in the next exercise.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor317"/>Exercise 14.09 – adding effects when the enemy is destroyed</h2>
<p>In this exercise, you will add <a id="_idIndexMarker1228"/>new content to the project that comes included with this chapter and exercise. This includes theVFX andSFX, and all of their required assets. Then, you will update the <strong class="source-inline">EnemyBase</strong> class so that it can use audio and Particle System parameters to add the layer of polish needed when the enemy is destroyed by the player projectile.</p>
<p>By the end of this exercise, you will have an enemy that is visually and audibly destroyed when it collides with the player projectile.</p>
<p>Let’s get started:</p>
<ol>
<li value="1">To begin, we need to migrate specific assets from the <strong class="bold">Action RPG</strong> project, which can be found in the <strong class="bold">Learn</strong> tab of <strong class="bold">Unreal Engine Launcher</strong>.</li>
<li>From <strong class="bold">Epic Games Launcher</strong>, navigate to the <strong class="bold">Samples</strong> tab and, in the <strong class="bold">UE Legacy Samples</strong> category, you will find <strong class="bold">Action RPG</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer453">
<img alt="Figure 14.20 – The Action RPG sample project " height="463" src="image/Figure_14.20_B18531.jpg" width="1433"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.20 – The Action RPG sample project</p>
<p class="callout-heading">Note</p>
<p class="callout">You will be taking additional assets from the <strong class="bold">Action RPG</strong> project in later exercises of this chapter, so you should keep this project open to avoid redundantly opening the project. The assets for this exercise can be downloaded from <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter14/Exercise14.09">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter14/Exercise14.09</a>.</p>
<ol>
<li value="3">Left-click the <strong class="bold">Action RPG</strong> game project and then left-click the <strong class="bold">Create Project</strong> option.</li>
<li>From here, select engine version 4.27 and choose <a id="_idIndexMarker1229"/>which directory to download the project to. Then, <em class="italic">left-click</em> the <strong class="bold">Create</strong> button to start installing the project.</li>
<li>Once the <strong class="bold">Action RPG</strong> project has finished downloading, navigate to the <strong class="bold">Library</strong> tab of <strong class="bold">Epic Games Launcher</strong> to find <strong class="bold">ActionRPG</strong> under the <strong class="bold">My Projects</strong> section.</li>
<li><em class="italic">Double-click</em> the <strong class="bold">ActionRPG</strong> project to open it in the UE5 editor.</li>
<li>In the editor, find the <strong class="bold">A_Guardian_Death_Cue</strong> audio asset in the <strong class="bold">Content Browser</strong> interface. <em class="italic">Right-click</em> this asset and select <strong class="bold">Asset Actions</strong> and then <strong class="bold">Migrate</strong>.</li>
<li>After selecting <strong class="bold">Migrate</strong>, you will be presented with all the assets that are referenced in <strong class="bold">A_Guardian_Death_Cue</strong>. This includes all audio classes and sound wave files. Choose <strong class="bold">OK</strong> from the <strong class="bold">Asset Report</strong> dialog window.</li>
<li>Next, you will need to navigate to the <strong class="source-inline">Content</strong> folder for your <strong class="source-inline">Super SideScroller</strong> project and <em class="italic">left-click</em> <strong class="bold">Select Folder</strong>.</li>
<li>Once the migration process is complete, you will see a notification in the editor stating that the migration was completed successfully.</li>
<li>Do the same migration steps for the <strong class="source-inline">P_Goblin_Death</strong> VFX asset. The two primary assets you will be adding to the project are as follows:<p class="source-code">A_Guardian_Death_Cue</p><p class="source-code">P_Goblin_Death</p></li>
</ol>
<p>The <strong class="source-inline">P_Goblin_Death</strong> Particle System asset references additional assets such as materials and textures that are<a id="_idIndexMarker1230"/> included in the <strong class="source-inline">Effects</strong> directory, while <strong class="source-inline">A_Guardian_Death_Cue</strong> references additional sound wave assets included in the <strong class="source-inline">Assets</strong> directory.</p>
<ol>
<li value="12">After migrating these folders into your <strong class="source-inline">Content</strong> directory, open the UE5 editor for your <strong class="source-inline">SuperSideScroller</strong> project to find the new folders included in your project’s <strong class="bold">Content Drawer</strong>. </li>
</ol>
<p>The particle you will be using for the enemy character’s destruction is called <strong class="source-inline">P_Goblin_Death</strong> and can be found in the <strong class="source-inline">/Effects/FX_Particle/</strong> directory. The sound you will be using for the enemy character’s destruction is called <strong class="source-inline">A_Guardian_Death_Cue</strong> and can be found in the <strong class="source-inline">/Assets/Sounds/Creatures/Guardian/</strong> directory. Now that the assets you need have been imported into the editor, let’s move on to the code. </p>
<ol>
<li value="13">Open Visual Studio and navigate to the header file for the enemy base class – that is, <strong class="source-inline">EnemyBase.h</strong>.</li>
<li>Add the following <strong class="source-inline">UPROPERTY()</strong> variable. This will represent the Particle System for when the enemy is destroyed. Make sure this is declared under the <strong class="source-inline">Public</strong> access modifier:<p class="source-code">UPROPERTY(EditAnywhere, BlueprintReadOnly)</p><p class="source-code">class UParticleSystem* DeathEffect;</p></li>
<li>Add the following <strong class="source-inline">UPROPERTY()</strong> variable. This will represent the sound for when the enemy is destroyed. Make sure this is declared under the <strong class="source-inline">Public</strong> access modifier:<p class="source-code">UPROPERTY(EditAnywhere, BlueprintReadOnly)</p><p class="source-code">class USoundBase* DeathSound;</p></li>
</ol>
<p>With these two properties defined, let’s move on and add the logic required to spawn and use these effects for when the enemy is destroyed.</p>
<ol>
<li value="16">Inside the source file for<a id="_idIndexMarker1231"/> the enemy base class, <strong class="source-inline">EnemyBase.cpp</strong>, add the following includes for the <strong class="source-inline">UGameplayStatics</strong> and <strong class="source-inline">UWorld</strong> classes:<p class="source-code">#include "Kismet/GameplayStatics.h"</p><p class="source-code">#include "Engine/World.h"</p></li>
</ol>
<p>You will be using the <strong class="source-inline">UGameplayStatics</strong> and <strong class="source-inline">UWorld</strong> classes to spawn the sound and Particle System into the world when the enemy is destroyed.</p>
<ol>
<li value="17">Within the <strong class="source-inline">AEnemyBase::DestroyEnemy()</strong> function, you have one line of code:<p class="source-code">Destroy();</p></li>
<li>Add the following line of code above the <strong class="source-inline">Destroy()</strong> function call:<p class="source-code">UWorld* World = GetWorld();</p></li>
</ol>
<p>It is necessary to define the <strong class="source-inline">UWorld</strong> object before attempting to spawn a Particle System or sound because a <strong class="source-inline">World</strong> context object is required.</p>
<ol>
<li value="19">Next, use an <strong class="source-inline">if()</strong> statement to check the validity of the <strong class="source-inline">World</strong> object you just defined:<p class="source-code">if(World)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Within the <strong class="source-inline">if()</strong> block, add the following code to check the validity of the <strong class="source-inline">DeathEffect</strong> property, and then spawn this effect using the <strong class="source-inline">SpawnEmitterAtLocation</strong> function from <strong class="source-inline">UGameplayStatics</strong>:<p class="source-code">if(DeathEffect)</p><p class="source-code">{</p><p class="source-code">    UGameplayStatics::SpawnEmitterAtLocation(World, </p><p class="source-code">      DeathEffect, GetActorTransform());</p><p class="source-code">}</p></li>
</ol>
<p>It cannot be emphasized<a id="_idIndexMarker1232"/> enough that you should ensure an object is valid before attempting to spawn or manipulate the object. By doing so, you can avoid engine crashes.</p>
<ol>
<li value="21">After the <strong class="source-inline">if(DeathEffect)</strong> block, perform the same validity check of the <strong class="source-inline">DeathSound</strong> property and then spawn the sound using the <strong class="source-inline">UGameplayStatics::SpawnSoundAtLocation</strong> function:<p class="source-code">if(DeathSound)</p><p class="source-code">{</p><p class="source-code">    UGameplayStatics::SpawnSoundAtLocation(World, </p><p class="source-code">      DeathSound, GetActorLocation());</p><p class="source-code">}</p></li>
</ol>
<p>Before calling the <strong class="source-inline">Destroy()</strong> function, you need to make checks regarding whether both the <strong class="source-inline">DeathEffect</strong> and <strong class="source-inline">DeathSound</strong> properties are valid, and if so, spawn those effects using the proper <strong class="source-inline">UGameplayStatics</strong> function. This ensures that regardless of whether either property is valid, the enemy character will still be destroyed.</p>
<ol>
<li value="22">Now that the <strong class="source-inline">AEnemyBase::DestroyEnemy()</strong> function has been updated to spawn these effects, return to the UE5 editor to compile and hot-reload these code changes.</li>
<li>Within the <strong class="bold">Content Drawer</strong> interface, navigate to the <strong class="source-inline">/Enemy/Blueprints/</strong> directory. <em class="italic">Double-click</em> the <strong class="source-inline">BP_Enemy</strong> asset to open it.</li>
<li>In the <strong class="bold">Details</strong> panel of the enemy Blueprint, you will find the <strong class="source-inline">Death Effect</strong> and <strong class="source-inline">Death Sound</strong> properties. <em class="italic">Left-click</em> on the drop-down list for the <strong class="source-inline">Death Effect</strong> property and find the <strong class="source-inline">P_Goblin_Death</strong> Particle System.</li>
<li>Next, underneath the <strong class="source-inline">Death Effect</strong> parameter, <em class="italic">left-click</em> on the drop-down list for the <strong class="source-inline">Death Sound</strong> property and find the <strong class="bold">A_Guardian_Death_Cue</strong> sound cue.</li>
<li>Now that these parameters <a id="_idIndexMarker1233"/>have been updated and assigned the correct effect, compile and save the enemy Blueprint.</li>
<li>Using <strong class="source-inline">PIE</strong>, spawn the player character and throw a player projectile at an enemy. If an enemy is not present in your level, please add one. When the player projectile collides with the enemy, the VFX and SFX you added will play, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer454">
<img alt="Figure 14.21 – Now, the enemy explodes and gets destroyed in a blaze of glory " height="431" src="image/Figure_14.21_B18531.jpg" width="815"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.21 – Now, the enemy explodes and gets destroyed in a blaze of glory</p>
<p>With this exercise complete, the <a id="_idIndexMarker1234"/>enemy character now plays a Particle System and a sound cue when it is destroyed by the player projectile. This adds a nice layer of polish to the game, and it makes it more satisfying to destroy the enemies.</p>
<p>In the next exercise, you will add a new Particle System and audio components to the player projectile so that it looks and sounds more interesting while it flies through the air.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor318"/>Exercise 14.10 – adding effects to the player projectile</h2>
<p>In its current state, the player<a id="_idIndexMarker1235"/> projectile functions the way it is intended to; it flies through the air, collides with objects in the game world, and is destroyed. However, visually, the player projectile is just a ball with a plain white texture.</p>
<p>In this exercise, you will add a layer of polish to the player projectile by adding both a Particle System and an audio component so that the projectile is more enjoyable to use.</p>
<p>Follow these steps to achieve this:</p>
<ol>
<li value="1">Much like the previous exercises, we will need to migrate assets from the <strong class="bold">Action RPG</strong> project to our <strong class="bold">SuperSideScroller</strong> project. Please refer to <em class="italic">Exercise 14.09 – adding effects when the enemy is destroyed</em>, on how to install and migrate assets from the <strong class="bold">Action RPG</strong> project.</li>
</ol>
<p>The two primary assets you will be adding to the project are as follows:</p>
<p class="source-code">P_Env_Fire_Grate_01</p>
<p class="source-code">A_Ambient_Fire01_Cue</p>
<p>The <strong class="source-inline">P_Env_Fire_Grate_01</strong> Particle System asset references additional assets, such as materials and textures, that are included in the <strong class="source-inline">Effects</strong> directory, while <strong class="source-inline">A_Ambient_Fire01_Cue</strong> references additional sound wave and sound attenuation assets included in the <strong class="source-inline">Assets</strong> directory.</p>
<p>The particle you will be using for the player projectile is called <strong class="source-inline">P_Env_Fire_Grate_01</strong> and can be found in the <strong class="source-inline">/Effects/FX_Particle/</strong> directory. This is the same directory that’s used by the <strong class="source-inline">P_Goblin_Death</strong> VFX from the previous exercise. The sound you will be using for the player projectile is called <strong class="source-inline">A_Ambient_Fire01_Cue</strong> and can be found in the <strong class="source-inline">/Assets/Sounds/Ambient/</strong> directory.</p>
<ol>
<li value="2"><em class="italic">Right-click</em> on each of these assets in the <strong class="bold">Content Browser</strong> interface of the <strong class="bold">Action RPG</strong> project and select <strong class="bold">Asset Actions</strong> and then <strong class="bold">Migrate</strong>.</li>
<li>Make sure that you choose the<a id="_idIndexMarker1236"/> directory of the <strong class="bold">Content</strong> folder for your <strong class="bold">SuperSideScroller</strong> project before confirming the migration.</li>
</ol>
<p>Now that the required assets have been migrated to our project, let’s continue creating the player projectile class.</p>
<ol>
<li value="4">Open Visual Studio and navigate to the header file for the player projectile class – that is, <strong class="source-inline">PlayerProjectile.h</strong>.</li>
<li>Under the <strong class="source-inline">Private</strong> access modifier, underneath the declaration of the <strong class="source-inline">UStaticMeshComponent* MeshComp</strong> class component, add the following code to declare a new audio component for the player projectile:<p class="source-code">UPROPERTY(VisibleDefaultsOnly, Category = Sound)</p><p class="source-code">class UAudioComponent* ProjectileMovementSound;</p></li>
<li>Next, add the following code underneath the declaration of the audio component to declare a new Particle System component:<p class="source-code">UPROPERTY(VisibleDefaultsOnly, Category = Projectile)</p><p class="source-code">class UParticleSystemComponent* ProjectileEffect;</p></li>
</ol>
<p>Instead of using properties that can be defined within the Blueprint, such as in the enemy character class, these effects will be components of the player projectile. This is because these effects should be attached to the collision component of the projectile so that they move with the projectile as it travels across the level when thrown.</p>
<ol>
<li value="7">With these two components <a id="_idIndexMarker1237"/>declared in the header file, open the source file for the player projectile and add the following includes to the list of <strong class="source-inline">include</strong> lines at the top of the file:<p class="source-code">#include "Components/AudioComponent.h"</p><p class="source-code">#include "Engine/Classes/Particles/ParticleSystemComponent.h"</p></li>
</ol>
<p>You need a reference to both the audio component and the Particle System classes to create these subobjects using the <strong class="source-inline">CreateDefaultSubobject</strong> function, as well as to attach these components to <strong class="bold">RootComponent</strong>.</p>
<ol>
<li value="8">Add the following lines to create the default subobject of the <strong class="source-inline">ProjectileMovementSound</strong> component, and to attach this component to <strong class="bold">RootComponent</strong>:<p class="source-code">ProjectileMovementSound = CreateDefaultSubobject&lt;UAudioComponent&gt;</p><p class="source-code">  (TEXT("ProjectileMovementSound"));</p><p class="source-code">  ProjectileMovementSound</p><p class="source-code">  -&gt;AttachToComponent(RootComponent, </p><p class="source-code">  FAttachmentTransformRules::KeepWorldTransform);</p></li>
<li>Next, add the following lines to create the default subobject for the <strong class="source-inline">ProjectileEffect</strong> component, and to attach this component to <strong class="bold">RootComponent</strong>:<p class="source-code">ProjectileEffect = CreateDefaultSubobject&lt;UParticle SystemComponent&gt;(TEXT("Projectile</p><p class="source-code">  Effect"));</p><p class="source-code">ProjectileEffect-&gt;AttachToComponent(RootComponent, </p><p class="source-code">  FAttachmentTransformRules::KeepWorldTransform);</p></li>
<li>Now that you have created, initialized, and attached these two components to <strong class="bold">RootComponent</strong>, return to the UE5 editor to recompile and hot-reload these code changes.</li>
<li>From the <strong class="source-inline">Content Drawer</strong> interface, navigate to the <strong class="source-inline">/MainCharacter/Projectile/</strong> directory. Find the <strong class="source-inline">BP_PlayerProjectile</strong> asset and <em class="italic">double-click</em> it to open the Blueprint.</li>
</ol>
<p>In the <strong class="bold">Components</strong> tab, you<a id="_idIndexMarker1238"/> will find the two new components you added using the preceding code. Observe that these components are attached to the <strong class="bold">CollisionComp</strong> component, also known as <strong class="bold">RootComponent</strong>.</p>
<ol>
<li value="12"><em class="italic">Left-click</em> to select the <strong class="bold">ProjectileEffect</strong> component and, within the <strong class="bold">Details</strong> panel, assign the <strong class="source-inline">P_Env_Fire_Grate_01</strong> VFX asset to this parameter, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer455">
<img alt="Figure 14.22 – Assigning the VFX to the particle system component " height="303" src="image/Figure_14.22_B18531.jpg" width="564"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.22 – Assigning the VFX to the particle system component</p>
<ol>
<li value="13">Before assigning the audio<a id="_idIndexMarker1239"/> component, let’s adjust the <strong class="bold">Transform</strong> property of the <strong class="source-inline">ProjectileEffect</strong> VFX asset. Update the <strong class="bold">Rotation</strong> and <strong class="bold">Scale</strong> values of the <strong class="bold">Transform</strong> property for the VFX so that they match what is shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer456">
<img alt="Figure 14.23 – The updated Transform of the Particle System component so that it fits better with the projectile " height="110" src="image/Figure_14.23_B18531.jpg" width="554"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.23 – The updated Transform of the Particle System component so that it fits better with the projectile</p>
<ol>
<li value="14">Navigate to the <strong class="source-inline">Viewport</strong> tab within the Blueprint to view these changes to the <strong class="bold">Transform</strong> property. <strong class="source-inline">ProjectileEffect</strong> should look as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer457">
<img alt="Figure 14.24 – Now, the fire VFX has been scaled and rotated appropriately " height="424" src="image/Figure_14.24_B18531.jpg" width="724"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.24 – Now, the fire VFX has been scaled and rotated appropriately</p>
<ol>
<li value="15">Now that the VFX has been set up, <em class="italic">left-click</em> the <strong class="source-inline">ProjectileMovementSound</strong> component and assign <strong class="source-inline">A_Ambient_Fire01_Cue</strong> to it.</li>
<li>Save and<a id="_idIndexMarker1240"/> recompile the <strong class="source-inline">BP_PlayerProjectile</strong> Blueprint. Use <strong class="source-inline">PIE</strong> and observe that when you throw the projectile, it now shows the VFX asset and plays the assigned sound:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer458">
<img alt="Figure 14.25 – The player projectile now has a VFX and an SFX as it flies through the air " height="514" src="image/Figure_14.25_B18531.jpg" width="864"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.25 – The player projectile now has a VFX and an SFX as it flies through the air</p>
<p>With this exercise complete, the player projectile now has a VFX and an SFX that play together while it flies<a id="_idIndexMarker1241"/> through the air. These elements bring the projectile to life and make the projectile much more interesting to use.</p>
<p>Since the VFX and SFX have been created as components of the projectile, they are also destroyed when the projectile is destroyed.</p>
<p>In the next exercise, you will add a particle notify and a sound notify to the <strong class="bold">Throw</strong> Animation Montage to provide more of an impact when the player throws the player projectile.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor319"/>Exercise 14.11 – adding VFX and SFX notifies</h2>
<p>So far, you have been implementing polish<a id="_idIndexMarker1242"/> elements to the game via C++, which is a valid means of<a id="_idIndexMarker1243"/> implementation. To give variety, and expand your knowledge of the UE5 toolset, this exercise will walk you through how to use notifies in Animation Montages to add Particle Systems and audio within the animation. Let’s get started!</p>
<p>Much like the previous exercises, we will need to migrate assets from the <strong class="source-inline">Action RPG</strong> project to our <strong class="bold">SuperSideScroller</strong> project. Please refer to <em class="italic">Exercise 14.09 – adding effects when the enemy is destroyed</em>, to learn how to install and migrate assets from the <strong class="bold">Action RPG</strong> project. </p>
<p>Follow these steps:</p>
<ol>
<li value="1">Open the <strong class="bold">ActionRPG</strong> project and navigate to the <strong class="bold">Content Browser</strong> interface.</li>
</ol>
<p>The two primary assets you will be adding to the project are as follows:</p>
<p class="source-code">P_Skill_001</p>
<p class="source-code">A_Ability_FireballCast_Cue</p>
<p>The <strong class="source-inline">P_Skill_001</strong> Particle System asset references additional assets such as <em class="italic">materials</em> and <em class="italic">textures</em> that are included in the <strong class="source-inline">Effects</strong> directory, while <strong class="source-inline">A_Ability_FireballCast_Cue</strong> references additional <em class="italic">sound wave</em> assets included in the <strong class="source-inline">Assets</strong> directory.</p>
<p>The particle you will be using for the player when the projectile is thrown is called <strong class="source-inline">P_Skill_001</strong> and can be<a id="_idIndexMarker1244"/> found in the <strong class="source-inline">/Effects/FX_Particle/</strong> directory. This is<a id="_idIndexMarker1245"/> the same directory that was used by the <strong class="source-inline">P_Goblin_Death</strong> and <strong class="source-inline">P_Env_Fire_Grate_01</strong> VFX assets in the previous exercises. The sound you will be using for the enemy character destruction is called <strong class="source-inline">A_Ambient_Fire01_Cue</strong> and can be found in the <strong class="source-inline">/Assets/Sounds/Ambient/</strong> directory.</p>
<ol>
<li value="2"><em class="italic">Right-click</em> on each of these assets in the <strong class="bold">Content Browser</strong> interface of the <strong class="bold">Action RPG</strong> project and select <strong class="bold">Asset Actions</strong> and then <strong class="bold">Migrate</strong>.</li>
<li>Make sure that you choose the directory of the <strong class="source-inline">Content</strong> folder for your <strong class="bold">SuperSideScroller</strong> project before confirming the migration.</li>
</ol>
<p>Now that the assets you need have been migrated into your project, let’s move on to adding the required notifies to the <strong class="source-inline">AM_Throw</strong> asset. Make sure that you return to your <strong class="bold">SuperSideScroller</strong> project before continuing with this exercise.</p>
<ol>
<li value="4">From the <strong class="bold">Content Drawer</strong> interface, navigate to the <strong class="source-inline">/MainCharacter/Animation/</strong> directory. Find the <strong class="source-inline">AM_Throw</strong> asset and <em class="italic">double-click</em> it to open it.</li>
<li>Underneath the preview window in the center of the <strong class="bold">Animation Montage</strong> editor, find the <strong class="bold">Notifies</strong> section. This is the same section where you added <strong class="source-inline">Anim_ProjectileNotify</strong> earlier in this chapter.</li>
<li>To the left of the <strong class="bold">Notifies</strong> track, you <a id="_idIndexMarker1246"/>will find a <strong class="bold">▼</strong> sign that allows you to<a id="_idIndexMarker1247"/> use additional notify tracks. <em class="italic">Left-click</em> to add a new notify track, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer459">
<img alt="Figure 14.26 – Adding a new notify track " height="179" src="image/Figure_14.26_B18531.jpg" width="385"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.26 – Adding a new notify track</p>
<p>It is useful to add multiple tracks to the timeline to keep things organized when adding multiple notifies.</p>
<ol>
<li value="7">In the same frame as <strong class="source-inline">Anim_ProjectileNotify</strong>, <em class="italic">right-click</em> within the new track you created in the previous step. From the <strong class="bold">Add Notify</strong> list, <em class="italic">left-click</em> to select <strong class="source-inline">Play Particle Effect</strong>.</li>
<li>Once created, <em class="italic">left-click</em> to select the new notify and access its <strong class="bold">Details</strong> panel. In <strong class="bold">Details</strong>, add the <strong class="source-inline">P_Skill_001</strong> VFX asset to the <strong class="source-inline">Particle System</strong> parameter.</li>
</ol>
<p>Once you’ve added this new VFX, you <a id="_idIndexMarker1248"/>will notice that the VFX is placed almost toward the <a id="_idIndexMarker1249"/>bottom, where the player character’s feet are, but not exactly where you want it. This VFX should be placed directly on the floor, or at the base of the character. The following screenshot demonstrates this location:</p>
<div>
<div class="IMG---Figure" id="_idContainer460">
<img alt="Figure 14.27 – The location of the particle notify is not on the ground " height="468" src="image/Figure_14.27_B18531.jpg" width="670"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.27 – The location of the particle notify is not on the ground</p>
<p>To fix this, you need to add a new <strong class="source-inline">Socket</strong> to the player character’s skeleton.</p>
<ol>
<li value="9">Navigate to the <strong class="source-inline">/MainCharacter/Mesh/</strong> directory. <em class="italic">Double-click</em> the <strong class="source-inline">MainCharacter_Skeleton</strong> asset to open it.</li>
<li>From the <strong class="bold">Skeleton</strong> bone hierarchy on the left-hand side, <em class="italic">right-click</em> on the <strong class="bold">Hips</strong> bone and <em class="italic">right-click</em> to select the <strong class="bold">Add Socket</strong> option. Name this new socket <strong class="source-inline">EffectSocket</strong>.</li>
<li><em class="italic">Left-click</em> this socket from<a id="_idIndexMarker1250"/> the hierarchy of bones to view its current location. By<a id="_idIndexMarker1251"/> default, its location is set to the same position as the <strong class="bold">Hips</strong> bone. The following screenshot shows this location:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer461">
<img alt="Figure 14.28 – The default location of this socket is in the center of the player’s skeleton " height="664" src="image/Figure_14.28_B18531.jpg" width="697"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.28 – The default location of this socket is in the center of the player’s skeleton</p>
<p>Using the <strong class="bold">Transform</strong> gizmo widget, move the position of <strong class="source-inline">EffectSocket</strong> so that its position is set to the following:</p>
<p class="source-code">(X=0.000000,Y=100.000000,Z=0.000000)</p>
<p>This position will be closer to the ground and the player character’s feet. The final location can be seen in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer462">
<img alt="Figure 14.29 – Moving the socket’s location to the base of the player skeleton " height="598" src="image/Figure_14.29_B18531.jpg" width="642"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.29 – Moving the socket’s location to the base of the player skeleton</p>
<ol>
<li value="12">Now that you have a location<a id="_idIndexMarker1252"/> for the particle notify, return to the <strong class="source-inline">AM_Throw</strong> Animation<a id="_idIndexMarker1253"/> Montage.</li>
<li>Within the <strong class="bold">Details</strong> panel of the <strong class="bold">Play Particle Effect</strong> notify, there is the <strong class="source-inline">Socket Name</strong> parameter. Name it <strong class="source-inline">EffectSocket</strong>.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">If <strong class="source-inline">EffectSocket</strong> does not appear via the autocomplete, close and reopen the Animation Montage. Once it's reopened, the <strong class="source-inline">EffectSocket</strong> option should appear for you.</p>
<ol>
<li value="14">Lastly, the scale of the particle effect is a little too big, so adjust the scale of the projectile so that its value is as follows:<p class="source-code">(X=0.500000,Y=0.500000,Z=0.500000)</p></li>
</ol>
<p>Now, when the particle effect is played via this notify, its position and scale will be correct, as shown here:</p>
<div>
<div class="IMG---Figure" id="_idContainer463">
<img alt="Figure 14.30 – The particle now plays at the base of the player character’s skeleton " height="454" src="image/Figure_14.30_B18531.jpg" width="408"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.30 – The particle now plays at the base of the player character’s skeleton</p>
<ol>
<li value="15">To add the <strong class="source-inline">Play Sound</strong> notify, add<a id="_idIndexMarker1254"/> a new track to the <strong class="bold">Notifies</strong> timeline section; you should have three in total.</li>
<li>On this new track, and at the same<a id="_idIndexMarker1255"/> frame position as both the <strong class="source-inline">Play Particle Effect</strong> and <strong class="source-inline">Anim_ProjectileNotify</strong> notifies, <em class="italic">right-click</em> and select the <strong class="bold">Play Sound</strong> notify from the <strong class="bold">Add Notify</strong> selection. The following screenshot shows where this notify can be found:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer464">
<img alt="Figure 14.31 – The Play Sound notify that you learned about earlier in this chapter " height="340" src="image/Figure_14.31_B18531.jpg" width="468"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.31 – The Play Sound notify that you learned about earlier in this chapter</p>
<ol>
<li value="17">Next, <em class="italic">left-click</em> to select<a id="_idIndexMarker1256"/> the <strong class="bold">Play Sound</strong> notify and access its <strong class="bold">Details</strong> panel.</li>
<li>From the <strong class="bold">Details</strong> panel, find<a id="_idIndexMarker1257"/> the <strong class="bold">Sound</strong> parameter and assign <strong class="source-inline">A_Ability_FireballCast_Cue</strong>.</li>
</ol>
<p>With the sound assigned, when the <strong class="bold">Throw</strong> animation is played back, you will see the VFX play and you will hear the sound. The <strong class="bold">Notifies</strong> tracks should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer465">
<img alt="Figure 14.32 – The final notify set up on the Throw Animation Montage timeline " height="136" src="image/Figure_14.32_B18531.jpg" width="1046"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.32 – The final notify set up on the Throw Animation Montage timeline</p>
<ol>
<li value="19">Save the <strong class="source-inline">AM_Throw</strong> asset and use <strong class="source-inline">PIE</strong> to throw the player projectile.</li>
<li>Now, when you throw the projectile, you will see the particle notify play the <strong class="source-inline">P_Skill_001</strong> VFX and you will hear the <strong class="source-inline">A_Ability_FireballCast_Cue</strong> SFX. The result will look as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer466">
<img alt="Figure 14.33 – Now, when the player throws the projectile, powerful VFX and SFX are played " height="443" src="image/Figure_14.33_B18531.jpg" width="476"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.33 – Now, when the player throws the projectile, powerful VFX and SFX are played</p>
<p>With this final exercise complete, the <a id="_idIndexMarker1258"/>player now plays powerful VFX and SFX when the player <a id="_idIndexMarker1259"/>projectile is thrown. This gives the throw animation more power and it feels like the player character is using a lot of energy to throw the projectile.</p>
<p>In the final activity, you will use the knowledge you’ve gained from the last few exercises to add VFX and SFX to the player projectile when it is destroyed.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor320"/>Activity 14.02 – adding effects for when the projectile is destroyed</h2>
<p>In this final activity, you will use the<a id="_idIndexMarker1260"/> knowledge that you’ve gained from adding VFX and SFX elements to the player projectile and the enemy character to create an explosion effect for when the projectile collides with an object instead. The reason we’re adding this additional explosion effect is to add a level of polish on top of destroying the projectile when it collides with environmental objects. It would look awkward and out of place if the player projectile were to <a id="_idIndexMarker1261"/>hit an object and disappear without any audio or visual feedback from the player.</p>
<p>You will add both a Particle System and sound cue parameters to the player projectile and spawn these elements when the projectile collides with an object.</p>
<p>Follow these steps to achieve the expected output:</p>
<ol>
<li value="1">Inside the <strong class="source-inline">PlayerProjectile.h</strong> header file, add a new Particle System variable and a new sound base variable.</li>
<li>Name the Particle System variable <strong class="source-inline">DestroyEffect</strong> and name the sound base variable <strong class="source-inline">DestroySound</strong>.</li>
<li>In the <strong class="source-inline">PlayerProjectile.cpp</strong> source file, add the include for <strong class="source-inline">UGameplayStatics</strong> to the list of includes.</li>
<li>Update the <strong class="source-inline">APlayerProjectile::ExplodeProjectile()</strong> function so that it now spawns both the <strong class="source-inline">DestroyEffect</strong> and <strong class="source-inline">DestroySound</strong> objects. Return to the UE5 editor and recompile the new C++ code. Inside the <strong class="source-inline">BP_PlayerProjectile</strong> Blueprint, assign the <strong class="source-inline">P_Explosion</strong> VFX, which is already included in your project by default, to the <strong class="source-inline">Destroy Effect</strong> parameter of the projectile.</li>
<li>Assign the <strong class="source-inline">Explosion_Cue</strong> SFX, which is already included in your project by default, to the <strong class="source-inline">Destroy Sound</strong> parameter of the projectile.</li>
<li>Save and compile the player projectile Blueprint.</li>
<li>Use <strong class="source-inline">PIE</strong> to observe the new player projectile’s destruction VFX and SFX.</li>
</ol>
<p>The expected output is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer467">
<img alt="Figure 14.34 – Projectile VFX and SFX " height="573" src="image/Figure_14.34_B18531.jpg" width="872"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.34 – Projectile VFX and SFX</p>
<p>With this activity complete, you <a id="_idIndexMarker1262"/>now have experience with adding polished elements to the game. Not only have you added these elements through C++ code, but you’ve added elements through other tools from UE5. At this point, you have enough experience to add Particle Systems and audio to your game without having to worry about how to implement these features. </p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor321"/>Summary</h1>
<p>In this chapter, you learned about the importance of VFX and SFX in the world of game development. Using a combination of C++ code and notifies, you were able to bring gameplay functionality to the player projectile and the enemy character colliding, as well as a layer of polish to this functionality by adding VFX and SFX. On top of this, you learned about how objects are spawned and destroyed in UE5.</p>
<p>Moreover, you learned about how Animation Montages are played, both from Blueprints and through C++. By migrating the logic of playing the <strong class="bold">Throw</strong> Animation Montage from Blueprint to C++, you learned how both methods work and how to use both implementations for your game.</p>
<p>By adding a new Animation Notify using C++, you were able to add this notify to the <strong class="bold">Throw</strong> Animation Montage, which allows the player to spawn the player projectile you created in the previous chapter. By using the <strong class="source-inline">UWorld-&gt;SpawnActor()</strong> function and adding a new socket to the player skeleton, you were able to spawn the player projectile at the exact frame of the <strong class="bold">Throw</strong> animation, and at the exact position that you wanted to.</p>
<p>Lastly, you learned how to use the <strong class="bold">Play Particle Effect</strong> and <strong class="bold">Play Sound</strong> notifies within the <strong class="bold">Throw</strong> Animation Montage to add VFX and SFX to the throw of the player projectile. This chapter taught you about the different methods that exist inside UE5 when it comes to using VFX and SFX for your game.</p>
<p>Now that the player projectile can be thrown and destroy enemy characters, it is time to implement the final set of mechanics for the game. In the next chapter, you will create the collectibles that the player can collect, and you will also create a powerup for the player that will improve the player’s movement mechanics for a short period.</p>
</div>
</div></body></html>