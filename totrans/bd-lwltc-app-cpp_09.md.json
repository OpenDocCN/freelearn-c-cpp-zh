["```cpp\n  inline constexpr auto sideToIndex(Side side) noexcept {\n    return static_cast<size_t>(side) + 1;\n  }\n```", "```cpp\n  inline constexpr auto sideToValue(Side side) noexcept {\n    return static_cast<int>(side);\n  }\n```", "```cpp\n#pragma once\n#include \"common/macros.h\"\n#include \"common/logging.h\"\nusing namespace Common;\nnamespace Trading {\n  constexpr auto Feature_INVALID =\n    std::numeric_limits<double>::quiet_NaN();\n```", "```cpp\n  class FeatureEngine {\n  private:\n    std::string time_str_;\n    Common::Logger *logger_ = nullptr;\n    double mkt_price_ = Feature_INVALID,\n      agg_trade_qty_ratio_ = Feature_INVALID;\n  };\n```", "```cpp\n    FeatureEngine(Common::Logger *logger)\n        : logger_(logger) {\n    }\n```", "```cpp\n    auto getMktPrice() const noexcept {\n      return mkt_price_;\n    }\n    auto getAggTradeQtyRatio() const noexcept {\n      return agg_trade_qty_ratio_;\n    }\n```", "```cpp\n    auto onOrderBookUpdate(TickerId ticker_id, Price price,\n      Side side, MarketOrderBook* book) noexcept -> void {\n      const auto bbo = book->getBBO();\n      if(LIKELY(bbo->bid_price_ != Price_INVALID && bbo-\n        >ask_price_ != Price_INVALID)) {\n        mkt_price_ = (bbo->bid_price_ * bbo->ask_qty_ +\n          bbo->ask_price_ * bbo->bid_qty_) /\n            static_cast<double>(bbo->bid_qty_ + bbo->\n              ask_qty_);\n      }\n      logger_->log(\"%:% %() % ticker:% price:% side:% mkt-\n        price:% agg-trade-ratio:%\\n\", __FILE__, __LINE__,\n          __FUNCTION__,\n                   Common::getCurrentTimeStr(&time_str_),\n                     ticker_id, Common::priceToString\n                       (price).c_str(),\n                   Common::sideToString(side).c_str(),\n                     mkt_price_, agg_trade_qty_ratio_);\n    }\n```", "```cpp\n    auto onTradeUpdate(const Exchange::MEMarketUpdate\n      *market_update, MarketOrderBook* book) noexcept -> void {\n      const auto bbo = book->getBBO();\n      if(LIKELY(bbo->bid_price_ != Price_INVALID && bbo->\n        ask_price_ != Price_INVALID)) {\n        agg_trade_qty_ratio_ = static_cast<double>\n          (market_update->qty_) / (market_update->side_ ==\n            Side::BUY ? bbo->ask_qty_ : bbo->bid_qty_);\n      }\n      logger_->log(\"%:% %() % % mkt-price:% agg-trade-ratio\n        :%\\n\", __FILE__, __LINE__, __FUNCTION__,\n                   Common::getCurrentTimeStr(&time_str_),\n                   market_update->toString().c_str(),\n                     mkt_price_, agg_trade_qty_ratio_);\n    }\n```", "```cpp\n#pragma once\n#include \"common/macros.h\"\n#include \"common/types.h\"\n#include \"common/logging.h\"\n#include \"exchange/order_server/client_response.h\"\n#include \"market_order_book.h\"\nusing namespace Common;\n```", "```cpp\nnamespace Trading {\n  struct PositionInfo {\n    int32_t position_ = 0;\n    double real_pnl_ = 0, unreal_pnl_ = 0, total_pnl_ = 0;\n    std::array<double, sideToIndex(Side::MAX) + 1>\n      open_vwap_;\n    Qty volume_ = 0;\n    const BBO *bbo_ = nullptr;\n```", "```cpp\n    auto toString() const {\n       std::stringstream ss;\n       ss << \"Position{\"\n          << \"pos:\" << position_\n          << \" u-pnl:\" << unreal_pnl_\n          << \" r-pnl:\" << real_pnl_\n          << \" t-pnl:\" << total_pnl_\n          << \" vol:\" << qtyToString(volume_)\n          << \" vwaps:[\" << (position_ ? open_vwap_\n            .at(sideToIndex(Side::BUY)) / std::abs\n              (position_) : 0)\n          << \"X\" << (position_ ? open_vwap_\n            .at(sideToIndex(Side::SELL)) / std::abs\n               (position_) : 0)\n         << \"] \"\n         << (bbo_ ? bbo_->toString() : \"\") << \"}\";\n       return ss.str();\n    }\n```", "```cpp\n    auto addFill(const Exchange::MEClientResponse\n      *client_response, Logger *logger) noexcept {\n      const auto old_position = position_;\n      const auto side_index = sideToIndex(client_response->\n        side_);\n      const auto opp_side_index = sideToIndex\n        (client_response->side_ == Side::BUY ? Side::SELL :\n          Side::BUY);\n      const auto side_value = sideToValue(client_response->\n        side_);\n```", "```cpp\n      position_ += client_response->exec_qty_ * side_value;\n      volume_ += client_response->exec_qty_;\n```", "```cpp\n      if (old_position * sideToValue(client_response->\n        side_) >= 0) { // opened / increased position.\n        open_vwap_[side_index] += (client_response->price_\n          * client_response->exec_qty_);\n      }\n```", "```cpp\n        else { // decreased position.\n        const auto opp_side_vwap = open_vwap_\n          [opp_side_index] / std::abs(old_position);\n        open_vwap_[opp_side_index] = opp_side_vwap * std::\n          abs(position_);\n        real_pnl_ += std::min\n          (static_cast<int32_t>(client_response->\n            exec_qty_), std::abs(old_position)) *\n                     (opp_side_vwap - client_response->\n                        price_) * sideToValue\n                          (client_response->side_);\n```", "```cpp\n        if (position_ * old_position < 0) { // flipped\n          position to opposite sign.\n          open_vwap_[side_index] = (client_response->price_\n            * std::abs(position_));\n          open_vwap_[opp_side_index] = 0;\n        }\n      }\n```", "```cpp\n      if (!position_) { // flat\n        open_vwap_[sideToIndex(Side::BUY)] = open_vwap_\n          [sideToIndex(Side::SELL)] = 0;\n        unreal_pnl_ = 0;\n      }\n```", "```cpp\n        else {\n        if (position_ > 0)\n          unreal_pnl_ =\n              (client_response->price_ - open_vwap_\n                [sideToIndex(Side::BUY)] / std::abs\n                  (position_)) *\n              std::abs(position_);\n        else\n          unreal_pnl_ =\n              (open_vwap_[sideToIndex(Side::SELL)] / std::\n                abs(position_) - client_response->price_) *\n              std::abs(position_);\n      }\n```", "```cpp\n      total_pnl_ = unreal_pnl_ + real_pnl_;\n      std::string time_str;\n      logger->log(\"%:% %() % % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::getCurrentTimeStr(&time_str),\n                  toString(), client_response->\n                    toString().c_str());\n    }\n```", "```cpp\n    auto updateBBO(const BBO *bbo, Logger *logger) noexcept {\n      std::string time_str;\n      bbo_ = bbo;\n      if (position_ && bbo->bid_price_ != Price_INVALID &&\n        bbo->ask_price_ != Price_INVALID) {\n```", "```cpp\n        const auto mid_price = (bbo->bid_price_ + bbo->\n          ask_price_) * 0.5;\n```", "```cpp\n        if (position_ > 0)\n          unreal_pnl_ =\n              (mid_price – open_vwap_\n                [sideToIndex(Side::BUY)] / std::\n                  abs(position_)) *\n              std::abs(position_);\n        else\n          unreal_pnl_ =\n              (open_vwap_[sideToIndex(Side::SELL)] / std::\n                 abs(position_) – mid_price) *\n              std::abs(position_);\n```", "```cpp\n        const auto old_total_pnl = total_pnl_;\n        total_pnl_ = unreal_pnl_ + real_pnl_;\n        if (total_pnl_ != old_total_pnl)\n          logger->log(\"%:% %() % % %\\n\", __FILE__, __LINE__\n            , __FUNCTION__, Common::\n               getCurrentTimeStr(&time_str),\n                      toString(), bbo_->toString());\n      }\n    }\n```", "```cpp\n  class PositionKeeper {\n  private:\n    std::string time_str_;\n    Common::Logger *logger_ = nullptr;\n    std::array<PositionInfo, ME_MAX_TICKERS>\n      ticker_position_;\n  };\n```", "```cpp\n    auto getPositionInfo(TickerId ticker_id) const noexcept {\n      return &(ticker_position_.at(ticker_id));\n    }\n```", "```cpp\n    auto toString() const {\n      double total_pnl = 0;\n      Qty total_vol = 0;\n      std::stringstream ss;\n      for(TickerId i = 0; i < ticker_position_.size(); ++i) {\n        ss << \"TickerId:\" << tickerIdToString(i) << \" \" <<\n          ticker_position_.at(i).toString() << \"\\n\";\n        total_pnl += ticker_position_.at(i).total_pnl_;\n        total_vol += ticker_position_.at(i).volume_;\n      }\n      ss << \"Total PnL:\" << total_pnl << \" Vol:\" <<\n        total_vol << \"\\n\";\n      return ss.str();\n    }\n```", "```cpp\n    PositionKeeper(Common::Logger *logger)\n        : logger_(logger) {\n    }\n```", "```cpp\n    auto addFill(const Exchange::MEClientResponse\n      *client_response) noexcept {\n      ticker_position_.at(client_response->\n        ticker_id_).addFill(client_response, logger_);\n    }\n```", "```cpp\n    auto updateBBO(TickerId ticker_id, const BBO *bbo)\n      noexcept {\n      ticker_position_.at(ticker_id).updateBBO(bbo,\n        logger_);\n    }\n```", "```cpp\n#pragma once\n#include <array>\n#include <sstream>\n#include \"common/types.h\"\nusing namespace Common;\nnamespace Trading {\n```", "```cpp\n  enum class OMOrderState : int8_t {\n    INVALID = 0,\n    PENDING_NEW = 1,\n    LIVE = 2,\n    PENDING_CANCEL = 3,\n    DEAD = 4\n  };\n```", "```cpp\n  inline auto OMOrderStateToString(OMOrderState side) ->\n    std::string {\n    switch (side) {\n      case OMOrderState::PENDING_NEW:\n        return \"PENDING_NEW\";\n      case OMOrderState::LIVE:\n        return \"LIVE\";\n      case OMOrderState::PENDING_CANCEL:\n        return \"PENDING_CANCEL\";\n      case OMOrderState::DEAD:\n        return \"DEAD\";\n      case OMOrderState::INVALID:\n        return \"INVALID\";\n    }\n    return \"UNKNOWN\";\n  }\n```", "```cpp\n  struct OMOrder {\n    TickerId ticker_id_ = TickerId_INVALID;\n    OrderId order_id_ = OrderId_INVALID;\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    Qty qty_ = Qty_INVALID;\n    OMOrderState order_state_ = OMOrderState::INVALID;\n```", "```cpp\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"OMOrder\" << \"[\"\n         << \"tid:\" << tickerIdToString(ticker_id_) << \" \"\n         << \"oid:\" << orderIdToString(order_id_) << \" \"\n         << \"side:\" << sideToString(side_) << \" \"\n         << \"price:\" << priceToString(price_) << \" \"\n         << \"qty:\" << qtyToString(qty_) << \" \"\n         << \"state:\" << OMOrderStateToString(order_state_)\n         << \"]\";\n      return ss.str();\n    }\n  };\n```", "```cpp\n  typedef std::array<OMOrder, sideToIndex(Side::MAX) + 1>\n    OMOrderSideHashMap;\n```", "```cpp\n  typedef std::array<OMOrderSideHashMap, ME_MAX_TICKERS>\n    OMOrderTickerSideHashMap;\n```", "```cpp\n#pragma once\n#include \"common/macros.h\"\n#include \"common/logging.h\"\n#include \"exchange/order_server/client_response.h\"\n#include \"om_order.h\"\n#include \"risk_manager.h\"\nusing namespace Common;\nnamespace Trading {\n  class TradeEngine;\n```", "```cpp\n  class OrderManager {\n  private:\n    TradeEngine *trade_engine_ = nullptr;\n    const RiskManager& risk_manager_;\n    std::string time_str_;\n    Common::Logger *logger_ = nullptr;\n    OMOrderTickerSideHashMap ticker_side_order_;\n    OrderId next_order_id_ = 1;\n  };\n}\n```", "```cpp\n    OrderManager(Common::Logger *logger, TradeEngine\n      *trade_engine, RiskManager& risk_manager)\n        : trade_engine_(trade_engine),\n          risk_manager_(risk_manager), logger_(logger) {\n    }\n```", "```cpp\n    auto getOMOrderSideHashMap(TickerId ticker_id) const {\n      return &(ticker_side_order_.at(ticker_id));\n    }\n```", "```cpp\n  auto OrderManager::newOrder(OMOrder *order, TickerId\n    ticker_id, Price price, Side side, Qty qty) noexcept -> void {\n```", "```cpp\n    const Exchange::MEClientRequest\n      new_request{Exchange::ClientRequestType::NEW,\n        trade_engine_->clientId(), ticker_id,\n         next_order_id_, side, price, qty};\n    trade_engine_->sendClientRequest(&new_request);\n```", "```cpp\n    *order = {ticker_id, next_order_id_, side, price, qty,\n      OMOrderState::PENDING_NEW};\n    ++next_order_id_;\n    logger_->log(\"%:% %() % Sent new order % for %\\n\",\n      __FILE__, __LINE__, __FUNCTION__,\n                 Common::getCurrentTimeStr(&time_str_),\n                 new_request.toString().c_str(), order->\n                   toString().c_str());\n  }\n```", "```cpp\n  auto OrderManager::cancelOrder(OMOrder *order) noexcept\n    -> void {\n```", "```cpp\n    const Exchange::MEClientRequest cancel_request\n      {Exchange::ClientRequestType::CANCEL, trade_engine_->\n        clientId(),\n     order->ticker_id_, order->order_id_, order->side_,\n       order->price_,\n     order->qty_};\n    trade_engine_->sendClientRequest(&cancel_request);\n```", "```cpp\n    order->order_state_ = OMOrderState::PENDING_CANCEL;\n    logger_->log(\"%:% %() % Sent cancel % for %\\n\",\n      __FILE__, __LINE__, __FUNCTION__,\n                 Common::getCurrentTimeStr(&time_str_),\n                 cancel_request.toString().c_str(), order->\n                   toString().c_str());\n  }\n```", "```cpp\n    auto moveOrder(OMOrder *order, TickerId ticker_id,\n      Price price, Side side, Qty qty) noexcept {\n```", "```cpp\n      switch (order->order_state_) {\n        case OMOrderState::LIVE: {\n          if(order->price_ != price || order->qty_ != qty)\n            cancelOrder(order);\n        }\n          break;\n```", "```cpp\n        case OMOrderState::INVALID:\n        case OMOrderState::DEAD: {\n          if(LIKELY(price != Price_INVALID)) {\n            const auto risk_result = risk_manager_\n              .checkPreTradeRisk(ticker_id, side, qty);\n            if(LIKELY(risk_result == RiskCheckResult\n              ::ALLOWED))\n              newOrder(order, ticker_id, price, side, qty);\n            else\n              logger_->log(\"%:% %() % Ticker:% Side:% Qty:%\n                RiskCheckResult:%\\n\", __FILE__, __LINE__,\n                   __FUNCTION__,\n                           Common::getCurrentTimeStr(&time_\n                             str_),\n                           tickerIdToString(ticker_id),\n                             sideToString(side),\n                               qtyToString(qty),\n                           riskCheckResultToString\n                             (risk_result));\n          }\n        }\n          break;\n```", "```cpp\n        case OMOrderState::PENDING_NEW:\n        case OMOrderState::PENDING_CANCEL:\n          break;\n      }\n    }\n```", "```cpp\n    auto moveOrders(TickerId ticker_id, Price bid_price,\n      Price ask_price, Qty clip) noexcept {\n      auto bid_order =\n        &(ticker_side_order_.at(ticker_id)\n          .at(sideToIndex(Side::BUY)));\n      moveOrder(bid_order, ticker_id, bid_price, Side::BUY,\n        clip);\n      auto ask_order = &(ticker_side_order_\n        .at(ticker_id).at(sideToIndex(Side::SELL)));\n      moveOrder(ask_order, ticker_id, ask_price, Side::\n        SELL, clip);\n    }\n```", "```cpp\n    auto onOrderUpdate(const Exchange::MEClientResponse\n      *client_response) noexcept -> void {\n      logger_->log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n          getCurrentTimeStr(&time_str_),\n                   client_response->toString().c_str());\n```", "```cpp\n      auto order = &(ticker_side_order_.at(client_response\n        ->ticker_id_).at(sideToIndex(client_response\n          ->side_)));\n      logger_->log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n          getCurrentTimeStr(&time_str_),\n                   order->toString().c_str());\n```", "```cpp\n      switch (client_response->type_) {\n        case Exchange::ClientResponseType::ACCEPTED: {\n          order->order_state_ = OMOrderState::LIVE;\n        }\n          break;\n```", "```cpp\n        case Exchange::ClientResponseType::CANCELED: {\n          order->order_state_ = OMOrderState::DEAD;\n        }\n          break;\n```", "```cpp\n        case Exchange::ClientResponseType::FILLED: {\n          order->qty_ = client_response->leaves_qty_;\n          if(!order->qty_)\n            order->order_state_ = OMOrderState::DEAD;\n        }\n          break;\n```", "```cpp\n        case Exchange::ClientResponseType::CANCEL_REJECTED:\n        case Exchange::ClientResponseType::INVALID: {\n        }\n          break;\n      }\n    }\n```", "```cpp\n  struct RiskCfg {\n    Qty max_order_size_ = 0;\n    Qty max_position_ = 0;\n    double max_loss_ = 0;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"RiskCfg{\"\n         << \"max-order-size:\" <<\n           qtyToString(max_order_size_) << \" \"\n         << \"max-position:\" << qtyToString(max_position_)\n         << \" \"\n         << \"max-loss:\" << max_loss_\n         << \"}\";\n      return ss.str();\n    }\n  };\n```", "```cpp\n  struct TradeEngineCfg {\n    Qty clip_ = 0;\n    double threshold_ = 0;\n    RiskCfg risk_cfg_;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"TradeEngineCfg{\"\n         << \"clip:\" << qtyToString(clip_) << \" \"\n         << \"thresh:\" << threshold_ << \" \"\n         << \"risk:\" << risk_cfg_.toString()\n         << \"}\";\n      return ss.str();\n    }\n  };\n```", "```cpp\n  typedef std::array<TradeEngineCfg, ME_MAX_TICKERS>\n    TradeEngineCfgHashMap;\n```", "```cpp\n#pragma once\n#include \"common/macros.h\"\n#include \"common/logging.h\"\n#include \"position_keeper.h\"\n#include \"om_order.h\"\nusing namespace Common;\nnamespace Trading {\n  class OrderManager;\n```", "```cpp\n  enum class RiskCheckResult : int8_t {\n    INVALID = 0,\n    ORDER_TOO_LARGE = 1,\n    POSITION_TOO_LARGE = 2,\n    LOSS_TOO_LARGE = 3,\n    ALLOWED = 4\n  };\n```", "```cpp\n  inline auto riskCheckResultToString(RiskCheckResult\n    result) {\n    switch (result) {\n      case RiskCheckResult::INVALID:\n        return \"INVALID\";\n      case RiskCheckResult::ORDER_TOO_LARGE:\n        return \"ORDER_TOO_LARGE\";\n      case RiskCheckResult::POSITION_TOO_LARGE:\n        return \"POSITION_TOO_LARGE\";\n      case RiskCheckResult::LOSS_TOO_LARGE:\n        return \"LOSS_TOO_LARGE\";\n      case RiskCheckResult::ALLOWED:\n        return \"ALLOWED\";\n    }\n    return \"\";\n  }\n```", "```cpp\n  struct RiskInfo {\n    const PositionInfo *position_info_ = nullptr;\n    RiskCfg risk_cfg_;\n```", "```cpp\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"RiskInfo\" << \"[\"\n         << \"pos:\" << position_info_->toString() << \" \"\n         << risk_cfg_.toString()\n         << \"]\";\n      return ss.str();\n    }\n```", "```cpp\n  typedef std::array<RiskInfo, ME_MAX_TICKERS>\n    TickerRiskInfoHashMap;\n```", "```cpp\n    auto checkPreTradeRisk(Side side, Qty qty) const\n      noexcept {\n```", "```cpp\n      if (UNLIKELY(qty > risk_cfg_.max_order_size_))\n        return RiskCheckResult::ORDER_TOO_LARGE;\n```", "```cpp\n      if (UNLIKELY(std::abs(position_info_->position_ +\n        sideToValue(side) * static_cast<int32_t>(qty)) >\n          static_cast<int32_t>(risk_cfg_.max_position_)))\n        return RiskCheckResult::POSITION_TOO_LARGE;\n```", "```cpp\n      if (UNLIKELY(position_info_->total_pnl_ <\n        risk_cfg_.max_loss_))\n        return RiskCheckResult::LOSS_TOO_LARGE;\n```", "```cpp\n      return RiskCheckResult::ALLOWED;\n    }\n```", "```cpp\n  class RiskManager {\n  private:\n    std::string time_str_;\n    Common::Logger *logger_ = nullptr;\n    TickerRiskInfoHashMap ticker_risk_;\n  };\n```", "```cpp\n  RiskManager::RiskManager(Common::Logger *logger, const\n    PositionKeeper *position_keeper, const\n      TradeEngineCfgHashMap &ticker_cfg)\n      : logger_(logger) {\n    for (TickerId i = 0; i < ME_MAX_TICKERS; ++i) {\n      ticker_risk_.at(i).position_info_ = position_keeper\n        ->getPositionInfo(i);\n      ticker_risk_.at(i).risk_cfg_ =\n        ticker_cfg[i].risk_cfg_;\n    }\n  }\n```", "```cpp\n    auto checkPreTradeRisk(TickerId ticker_id, Side side,\n      Qty qty) const noexcept {\n      return ticker_risk_.at(ticker_id)\n        .checkPreTradeRisk(side, qty);\n    }\n```"]