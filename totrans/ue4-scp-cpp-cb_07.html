<html><head></head><body>
        

                            
                    <h1 class="header-title">Communication Between Classes and Interfaces: Part I</h1>
                
            
            
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Creating a UInterface</li>
<li>Implementing a UInterface on an object</li>
<li>Checking if a class implements a UInterface</li>
<li>Casting to a UInterface implemented in native code</li>
<li>Calling native UInterface functions from C++</li>
<li>Inheriting UInterfaces from one another</li>
<li>Overriding UInterface functions in C++</li>
<li>Implementing a simple interaction system with UInterfaces</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This chapter shows you how to write your own UInterfaces, and demonstrates how to take advantage of them within C++ to minimize class coupling and help keep your code clean.</p>
<p>In your game projects, you will sometimes require a series of potentially disparate objects to share a common functionality, but it would be inappropriate to use inheritance because there is no <em>is-a</em> relationship between the different objects in question. Languages such as C++ tend to use multiple inheritance to solve this issue.</p>
<p>However, in Unreal, if you wanted functions from both parent classes to be accessible to Blueprint, you would need to make both of them <kbd>UCLASS</kbd>. This is a problem for two reasons. Inheriting from <kbd>UClass</kbd> twice in the same object would break the concept that <kbd>UObject</kbd> should form a neatly traversable hierarchy. It also means that there are two instances of the <kbd>UClass</kbd> methods on the object, and they would have to be explicitly differentiated between within the code. The Unreal codebase solves this issue by borrowing a concept from C#: that of an explicit Interface type.</p>
<p>The reason for using this approach, instead of composition, is that Components are only available on Actors, not on UObjects in general. Interfaces can be applied to any <kbd>UObject</kbd>. Furthermore, it means that we are no longer modeling an <em>is-a</em> relationship between the object and the component; instead, it would only be able to represent <em>has-a</em> relationships.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml"/><a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>, of this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a UInterface</h1>
                
            
            
                
<p>UInterfaces are pairs of classes that work together to enable classes to exhibit polymorphic behavior among multiple class hierarchies. This recipe shows you the basic steps involved in creating a UInterface purely in code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From the Content Browser, go to Add New | New C++ Class. From the menu that pops up, scroll down all the way until you see the Unreal Interface selection and select it. Afterward, click on the Next button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6dca5f4f-671b-4279-91c2-4ec127cda935.png" style="width:48.33em;height:29.17em;"/></p>
<ol start="2">
<li>From there, verify that the Name of the class is <kbd>MyInterface</kbd> and then click on the Create Class button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c611d729-5476-4d87-8324-0052c4d67e5c.png"/></p>
<ol start="3">
<li>Add the following code to the header file:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/>#include "MyInterface.generated.h"<br/><br/>// This class does not need to be modified.<br/>UINTERFACE(MinimalAPI)<br/>class UMyInterface : public UInterface<br/>{<br/>  GENERATED_BODY()<br/>};<br/><br/>class CHAPTER_07_API IMyInterface<br/>{<br/>  GENERATED_BODY()<br/><br/>  // Add interface functions to this class. This is the class that   <br/>  //will be inherited to implement this interface.<br/><br/>public:<br/>    <strong>virtual FString GetTestName();</strong><br/>};</pre>
<ol start="4">
<li>Implement the class with this code in the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "MyInterface.h"<br/><br/>// Add default functionality here for any IMyInterface functions that are not pure virtual.<br/><strong>FString IMyInterface::GetTestName()</strong><br/><strong>{</strong><br/><strong>    unimplemented();</strong><br/><strong>    return FString();</strong><br/><strong>}</strong></pre>
<ol start="5">
<li>Compile your project to verify that the code was written without errors.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>UInterfaces are implemented as pairs of classes that are declared in the interface's header.</p>
<p>As always, because we are leveraging Unreal's reflection system, we need to include our generated header file. Refer to the <em>Handling events implemented via virtual functions</em> recipe in <a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml">Chapter 5</a>, <em>Handling Events and Delegates</em>, for more information.</p>
<p>As with classes that inherit from <kbd>UObject</kbd>, which uses <kbd>UCLASS</kbd>, we need to use the <kbd>UINTERFACE</kbd> macro to declare our new <kbd>UInterface</kbd>. Passing in the class specifier of <kbd>MinimalAPI</kbd> causes only the class's type information to be exported for use by other modules. </p>
<p>For more information on this and other class specifiers, check out: <a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers">https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers</a>.</p>
<p>The class is tagged as <kbd>UE4COOKBOOK_API</kbd> to help with exporting library symbols.</p>
<p>The base class for the <kbd>UObject</kbd> portion of the interface is <kbd>UInterface</kbd>.</p>
<p>Just like <kbd>UCLASS</kbd> types, we require a macro to be placed inside the body of our class so that the auto-generated code is inserted into it. That macro is <kbd>GENERATED_BODY()</kbd> for UInterfaces. The macro must be placed at the very start of the class body.</p>
<p>The second class is also tagged as <kbd>UE4COOKBOOK_API</kbd>, and is named in a specific way.</p>
<p>Note that the <kbd>UInterface</kbd> derived class and the standard class have the same name but a different prefix. The <kbd>UInterface</kbd> derived class has the prefix <kbd>U</kbd>, and the standard class has the prefix <kbd>I</kbd>. This is important as this is how the Unreal Header Tool expects classes to be named for the code it generates to work properly.</p>
<p>The plain native Interface class requires its own autogenerated content, which we include using the <kbd>GENERATED_BODY()</kbd> macro.</p>
<p>We declare functions that classes inheriting the interface should implement inside <kbd>IInterface</kbd>.</p>
<p>Within the implementation file, we implement the constructor for our <kbd>UInterface</kbd>, as it is declared by the Unreal Header Tool and requires an implementation.</p>
<p>We also create a default implementation for our <kbd>GetTestName()</kbd> function. Without this, the linking phase in the compilation will fail. This default implementation uses the <kbd>unimplemented()</kbd> macro, which will issue a debug assert when the line of code is executed.</p>
<p>For more information on creating interfaces, check out the following link: <a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces">https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to the <em>Passing payload data with a delegate binding</em> recipe in <a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml">Chapter 5</a>, <em>Handling Events and Delegates</em>; the first recipe, in particular, explains some of the principles that we've applied here</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a UInterface on an object</h1>
                
            
            
                
<p>Now that we have created a UInterface, we can say that an object has all of the functions defined or implements them. In this recipe, we will see exactly how to do that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Ensure that you've followed the previous recipe so that you have a <kbd>UInterface</kbd> ready to be implemented.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>Actor</kbd> class using the Unreal Wizard, called <kbd>SingleInterfaceActor</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7e99dfee-3068-4773-a9e3-442b78c69dc1.png"/></p>
<ol start="2">
<li>Add <kbd>IInterface</kbd>—in this case, <kbd>IMyInterface</kbd>—to the public inheritance list for our new <kbd>Actor</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "MyInterface.h"</strong><br/>#include "SingleInterfaceActor.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API ASingleInterfaceActor : public AActor<strong>, public IMyInterface</strong><br/>{<br/>  GENERATED_BODY()</pre>
<ol start="3">
<li>Add an <kbd>override</kbd> declaration to the class for the <kbd>IInterface</kbd> function(s) that we wish to override:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_07_API ASingleInterfaceActor : public AActor, public IMyInterface<br/>{<br/>  GENERATED_BODY()<br/>  <br/>public: <br/>  // Sets default values for this actor's properties<br/>  ASingleInterfaceActor();<br/><br/>protected:<br/>  // Called when the game starts or when spawned<br/>  virtual void BeginPlay() override;<br/><br/>public: <br/>  // Called every frame<br/>  virtual void Tick(float DeltaTime) override;<br/><br/>    <strong>FString GetTestName() override;</strong><br/><br/>};</pre>
<ol start="4">
<li>Implement the overridden function in the implementation file by adding the following code:</li>
</ol>
<pre style="padding-left: 60px">FString ASingleInterfaceActor::GetTestName()<br/>{<br/>    return IMyInterface::GetTestName();<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>C++ uses multiple inheritance in the way it implements interfaces, so we leverage that mechanism here with the declaration of our <kbd>SingleInterfaceActor</kbd> class, where we add <kbd>public IMyInterface</kbd>.</p>
<p>We inherit from <kbd>IInterface</kbd> rather than <kbd>UInterface</kbd> to prevent <kbd>SingleInterfaceActor</kbd> from inheriting two copies of <kbd>UObject</kbd>.</p>
<p>Given that the interface declares a <kbd>virtual</kbd> function, we need to redeclare that function with the override specifier if we wish to implement it ourselves.</p>
<p>In our implementation file, we implement our overridden <kbd>virtual</kbd> function.</p>
<p>Inside our function override, for demonstration purposes, we call the base <kbd>IInterface</kbd> implementation of the function. Alternatively, we could write our own implementation and avoid calling the base class one altogether.</p>
<p>We use <kbd>IInterface:: specifier</kbd> rather than <kbd>Super</kbd>, because <kbd>Super</kbd> refers to the <kbd>UClass</kbd> that is the parent of our class, and <kbd>IInterfaces</kbd> aren't UClasses (hence there's no <kbd>U</kbd> prefix).</p>
<p>You can implement a second, or multiple, <kbd>IInterfaces</kbd> on your object, as needed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking if a class implements a UInterface</h1>
                
            
            
                
<p>When writing C++ code, it's always a good idea to make sure that something exists before using it. In this recipe, we will see how we can check whether a particular object implements a specific <kbd>UInterface</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Follow the first two recipes so that you have a <kbd>UInterface</kbd> we can check for, and a class implementing the interface that can be tested against.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Inside your Game Mode implementation, add the following code to the <kbd>BeginPlay</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">void AChapter_07GameModeBase::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    // Spawn a new actor using the ASingleInterfaceActor class at <br/>    //the default location<br/>    FTransform SpawnLocation;<br/>    ASingleInterfaceActor* SpawnedActor = <br/>GetWorld()-&gt;SpawnActor&lt;ASingleInterfaceActor&gt;(  <br/>                                  ASingleInterfaceActor::StaticClass(), <br/>                                             SpawnLocation); <br/>    <br/>    // Get a reference to the class the actor has<br/>    UClass* ActorClass = SpawnedActor-&gt;GetClass();<br/><br/>    // If the class implements the interface, display a message<br/>    if (ActorClass-<br/>    &gt;ImplementsInterface(UMyInterface::StaticClass()))<br/>    {<br/>        GEngine-&gt;AddOnScreenDebugMessage(-1, 10, FColor::Red, <br/>                          TEXT("Spawned actor implements <br/>                               interface!"));<br/>    }<br/>}</pre>
<ol start="2">
<li>Given that we are referencing both <kbd>ASingleInterfaceActor</kbd> and <kbd>IMyInterface</kbd>, we need to <kbd>#include</kbd> both <kbd>MyInterface.h</kbd> and <kbd>SingleInterfaceActor.h</kbd> in our source file:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_07GameModeBase.h"<br/><strong>#include "MyInterface.h"</strong><br/><strong>#include "SingleInterfaceActor.h"</strong></pre>
<ol start="3">
<li>Save your script and compile your code. Afterward, from the World Settings menu, set the GameMode Override property to your <kbd>GameModeBase</kbd> class and play the game. If all went well, you should see a message stating that you've implemented the interface:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/422edfd8-62f6-48ff-ab9e-71064b5d6b52.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Inside <kbd>BeginPlay</kbd>, we create an empty <kbd>FTransform</kbd> object, which has the default value of <kbd>0</kbd> for all translation and rotation components, so we don't need to explicitly set any of them.</p>
<p>We then use the <kbd>SpawnActor</kbd> function from <kbd>UWorld</kbd> so that we can create an instance of our <kbd>SingleActorInterface</kbd>, storing the pointer to the instance into a temporary variable.</p>
<p>We then use <kbd>GetClass()</kbd> on our instance to get a reference to its associated <kbd>UClass</kbd>. We need a reference to <kbd>UClass</kbd> because that object is the one that holds all of the reflection data for the object.</p>
<p>Reflection data includes the names and types of all <kbd>UPROPERTY</kbd> on the object, the inheritance hierarchy for the object, and a list of all the interfaces that it implements.</p>
<p>As a result, we can call <kbd>ImplementsInterface()</kbd> on <kbd>UClass</kbd>, and it will return <kbd>true</kbd> if the object implements the <kbd>UInterface</kbd> in question.</p>
<p>If the object implements the interface, and therefore returns <kbd>true</kbd> from <kbd>ImplementsInterface</kbd>, we then print a message to the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml">Chapter 4</a>, Actors and Components, has a number of recipes relating to the spawning of actors (such as Instantiating an Actor using SpawnActor)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Casting to a UInterface implemented in native code</h1>
                
            
            
                
<p>One advantage that UInterfaces provide you with as a developer is the ability to treat a collection of heterogeneous objects that implement a common interface as a collection of the same object, using <kbd>Cast&lt; &gt;</kbd> to handle the conversion.</p>
<p>Please note that this won't work if your class implements the interface through a Blueprint.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You should have a <kbd>UInterface</kbd> and an <kbd>Actor</kbd> implementing the interface ready for this recipe.</p>
<p>Create a new game mode using the wizard within Unreal, or reuse a project and <kbd>GameMode</kbd> from a previous recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your game mode's declaration and add a new property to the class:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_07_API AChapter_07GameModeBase : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/>    virtual void BeginPlay() override;<br/><br/><strong>    TArray&lt;IMyInterface*&gt; MyInterfaceInstances;</strong><br/>};</pre>
<ol start="2">
<li>Add <kbd>#include "MyInterface.h"</kbd> to the header's include section:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/><strong>#include "MyInterface.h"</strong><br/>#include "Chapter_07GameModeBase.generated.h"</pre>
<ol start="3">
<li>Add the following within the game mode's <kbd>BeginPlay</kbd> implementation:</li>
</ol>
<pre style="padding-left: 60px">for (TActorIterator&lt;AActor&gt; It(GetWorld(), AActor::StaticClass()); <br/>     It; <br/>     ++It)<br/>{<br/>    AActor* Actor = *It;<br/><br/>    IMyInterface* MyInterfaceInstance = Cast&lt;IMyInterface&gt;(Actor);<br/><br/>    // If the pointer is valid, add it to the list<br/>    if (MyInterfaceInstance)<br/>    {<br/>        MyInterfaceInstances.Add(MyInterfaceInstance);<br/>    }<br/>}<br/><br/>// Print out how many objects implement the interface<br/>FString Message = FString::Printf(TEXT("%d actors implement the <br/>                              interface"), MyInterfaceInstances.Num());<br/><br/>GEngine-&gt;AddOnScreenDebugMessage(-1, 10, FColor::Red, Message);</pre>
<ol start="4">
<li>Since we are using the <kbd>TActorIterator</kbd> class, we will need to add the following <kbd>#include</kbd> to the top of our <kbd>GameModeBase</kbd> class' implementation file:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_07GameModeBase.h"<br/>#include "MyInterface.h"<br/>#include "SingleInterfaceActor.h"<br/><strong>#include "EngineUtils.h" // TActorIterator</strong></pre>
<ol start="5">
<li>If you haven't done so already, set the level's game mode override to your game mode, then drag a few instances of your custom Interface-implementing actor into the level.</li>
<li>When you play your level, a message should be printed on screen that indicates the number of instances of the interface that have been implemented in Actors in the level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a8cdda5-261c-4524-9d5f-bf81e434fb90.png" style="width:26.33em;height:16.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We create an array of pointers to <kbd>MyInterface</kbd> implementations.</p>
<p>Inside <kbd>BeginPlay</kbd>, we use <kbd>TActorIterator&lt;AActor&gt;</kbd> to get all of the <kbd>Actor</kbd> instances in our level.</p>
<p><kbd>TActorIterator</kbd> has the following constructor:</p>
<pre>explicit TActorIterator( UWorld* InWorld, <br/> TSubclassOf&lt;ActorType&gt;InClass = ActorType::StaticClass() ) 
: Super(InWorld, InClass ) </pre>
<p><kbd>TActorIterator</kbd> expects a world to act on, as well as a <kbd>UClass</kbd> instance to specify what types of Actor we are interested in.</p>
<p><kbd>ActorIterator</kbd> is an iterator like the STL iterator type. This means that we can write a <kbd>for</kbd> loop in the following form:</p>
<pre>for (iterator-constructor;iterator;++iterator) </pre>
<p>Inside the loop, we dereference the iterator to get an <kbd>Actor</kbd> pointer.</p>
<p>We then attempt to cast it to our interface; this will return a pointer to the interface if it does implement it, otherwise it will return <kbd>nullptr</kbd>.</p>
<p>As a result, we can check if the interface pointer is <kbd>null</kbd>, and if not, we can add the interface pointer reference to our array.</p>
<p>Finally, once we've iterated through all the actors in <kbd>TActorIterator</kbd>, we can display a message on the screen that displays the count of items that implemented the interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling native UInterface functions from C++</h1>
                
            
            
                
<p>We can use C++ to call native <kbd>UInterface</kbd> functions from other classes as well. For example, in this recipe, we will make a volume call a function on an object if it implements a particular interface. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Follow the previous recipe to get an understanding of casting an <kbd>Actor</kbd> pointer to an Interface pointer.</p>
<p>Note that as this recipe relies on the casting technique we used in the previous recipe, it will only work with objects that implement the interface using C++ rather than Blueprint. This is because Blueprint classes are not available at compile time, and so, technically, don't inherit the interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>Actor</kbd> class using the editor wizard. Call it <kbd>AntiGravityVolume</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/792cb6e1-aada-45b7-91cb-a91759eec844.png"/></p>
<ol start="2">
<li>Update the header file to add a <kbd>BoxComponent</kbd> to the new <kbd>Actor</kbd> and two virtual functions:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Components/BoxComponent.h"</strong><br/>#include "AntiGravityVolume.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API AAntiGravityVolume : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    AAntiGravityVolume();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UBoxComponent* CollisionComponent;</strong><br/><br/><strong>    virtual void NotifyActorBeginOverlap(AActor* OtherActor) override;</strong><br/><strong>    virtual void NotifyActorEndOverlap(AActor* OtherActor) override;</strong><br/><br/><br/>};</pre>
<ol start="3">
<li>Create an implementation within your source file, as follows:</li>
</ol>
<pre style="padding-left: 60px">void AAntiGravityVolume::NotifyActorBeginOverlap(AActor* OtherActor)<br/>{<br/>    IGravityObject* GravityObject = Cast&lt;IGravityObject&gt;(OtherActor);<br/><br/>    if (GravityObject != nullptr)<br/>    {<br/>        GravityObject-&gt;DisableGravity();<br/>    }<br/>}<br/><br/>void AAntiGravityVolume::NotifyActorEndOverlap(AActor* OtherActor)<br/>{<br/>    IGravityObject* GravityObject = Cast&lt;IGravityObject&gt;(OtherActor);<br/><br/>    if (GravityObject != nullptr)<br/>    {<br/>        GravityObject-&gt;EnableGravity();<br/>    }<br/>}</pre>
<ol start="4">
<li>Initialize the <kbd>BoxComponent</kbd> in your constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AAntiGravityVolume::AAntiGravityVolume()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn this off <br/>    // to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    CollisionComponent = <br/>           CreateDefaultSubobject&lt;UBoxComponent&gt;("CollisionComponent");<br/><br/>    CollisionComponent-&gt;SetBoxExtent(FVector(200, 200, 400));<br/>    RootComponent = CollisionComponent;<br/>}</pre>
<p style="padding-left: 60px">The script will not compile since <kbd>GravityObject</kbd> doesn't exist. Let's fix that:</p>
<ol start="5">
<li>Create an interface called <kbd>GravityObject</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f70de395-ca21-4083-ba93-20a4bfc9d5e3.png"/></p>
<ol start="6">
<li>Add the following <kbd>virtual</kbd> functions to <kbd>IGravityObject</kbd>:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_07_API IGravityObject<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the class that <br/>    // will be inherited to implement this interface.<br/>public:<br/><strong>    virtual void EnableGravity();</strong><br/><strong>    virtual void DisableGravity();</strong><br/>};<br/><br/></pre>
<ol start="7">
<li>Create the default implementation of the <kbd>virtual</kbd> functions inside the <kbd>IGravityObject</kbd> implementation file:</li>
</ol>
<pre style="padding-left: 60px">#include "GravityObject.h"<br/><br/>// Add default functionality here for any IGravityObject functions that are not pure virtual.<br/><strong>void IGravityObject::EnableGravity()</strong><br/><strong>{</strong><br/><strong>    AActor* ThisAsActor = Cast&lt;AActor&gt;(this);</strong><br/><strong>    if (ThisAsActor != nullptr)</strong><br/><strong>    {</strong><br/><strong>        TArray&lt;UPrimitiveComponent*&gt; PrimitiveComponents;</strong><br/><br/><strong>        ThisAsActor-&gt;GetComponents(PrimitiveComponents);</strong><br/><br/><strong>        for (UPrimitiveComponent* Component : PrimitiveComponents)</strong><br/><strong>        {</strong><br/><strong>            Component-&gt;SetEnableGravity(true);</strong><br/><strong>        }</strong><br/><br/><strong>        GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, <br/>        TEXT("Enabling Gravity"));</strong><br/><strong>    }</strong><br/><strong>}</strong><br/><br/><strong>void IGravityObject::DisableGravity()</strong><br/><strong>{</strong><br/><strong>    AActor* ThisAsActor = Cast&lt;AActor&gt;(this);</strong><br/><strong>    if (ThisAsActor != nullptr)</strong><br/><strong>    {</strong><br/><strong>        TArray&lt;UPrimitiveComponent*&gt; PrimitiveComponents;</strong><br/><br/><strong>        ThisAsActor-&gt;GetComponents(PrimitiveComponents);</strong><br/><br/><strong>        for (UPrimitiveComponent* Component : PrimitiveComponents)</strong><br/><strong>        {</strong><br/><strong>            Component-&gt;SetEnableGravity(false);</strong><br/><strong>        }</strong><br/><br/><strong>        GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, <br/>        TEXT("Disabling Gravity"));</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<ol start="8">
<li>Afterward, go back to the <kbd>AntiGravityVolume.cpp</kbd> file and add the following <kbd>#include</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "AntiGravityVolume.h"<br/><strong>#include "GravityObject.h"</strong></pre>
<p style="padding-left: 60px">At this point, our code will compile, but there's nothing using the interface. Let's add a new class that will.</p>
<ol start="9">
<li>Create a subclass of <kbd>Actor</kbd> called <kbd>PhysicsCube</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9d05909d-0f15-4f7f-be62-c37bbe5a0822.png"/></p>
<ol start="10">
<li>Add a static mesh property to the header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Components/StaticMeshComponent.h"</strong><br/>#include "PhysicsCube.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API APhysicsCube : public AActor<br/>{<br/>  GENERATED_BODY()<br/>  <br/>public: <br/>  // Sets default values for this actor's properties<br/>  APhysicsCube();<br/><br/>protected:<br/>  // Called when the game starts or when spawned<br/>  virtual void BeginPlay() override;<br/><br/>public: <br/>  // Called every frame<br/>  virtual void Tick(float DeltaTime) override;<br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UStaticMeshComponent* MyMesh;</strong><br/><br/>};</pre>
<ol start="11">
<li>Initialize the component in your constructor:</li>
</ol>
<pre style="padding-left: 60px">#include "PhysicsCube.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/>// Sets default values<br/>APhysicsCube::APhysicsCube()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn this <br/>   //off <br/>   // to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    MyMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("MyMesh");</strong><br/><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>    (TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));</strong><br/><br/><strong>    if (MeshAsset.Object != nullptr)</strong><br/><strong>    {</strong><br/><strong>        MyMesh-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>    }</strong><br/><br/><strong>    MyMesh-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><strong>    MyMesh-&gt;SetSimulatePhysics(true);</strong><br/><strong>    SetActorEnableCollision(true);</strong><br/>}</pre>
<ol start="12">
<li>To have <kbd>PhysicsCube</kbd> implement <kbd>GravityObject</kbd>, first <kbd>#include "GravityObject.h"</kbd> in the header file, then modify the class declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "Components/StaticMeshComponent.h"<br/><strong>#include "GravityObject.h"</strong><br/>#include "PhysicsCube.generated.h"<br/><br/><br/>UCLASS()<br/>class CHAPTER_07_API APhysicsCube : public AActor, <strong>public IGravityObject</strong></pre>
<ol start="13">
<li>Compile your project.</li>
<li>Create a new level and place an instance of our gravity volume in the scene.</li>
<li>Place an instance of <kbd>PhysicsCube</kbd> above the gravity volume, then rotate it slightly so that it has one corner lower than the others, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/104ff00e-4823-4862-b609-48373dbda8a8.png"/></p>
<ol start="16">
<li>Verify that the gravity is turned off on the object when it enters the volume and then turns back on again:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a8a01273-e5e5-42c6-97b6-e47dc0aeeb6a.png" style="width:33.17em;height:21.08em;"/></p>
<p>Note that the gravity volume doesn't need to know anything about your <kbd>PhysicsCube</kbd> actor, just the <kbd>GravityObject</kbd> interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We create a new <kbd>Actor</kbd> class and add a box component to give the actor something that will collide with the character. Alternatively, you could subclass <kbd>AVolume</kbd> if you wanted to use the <strong>Binary Space Partitioning</strong> (<strong>BSP</strong>) functionality to define the volume's shape (found under Geometry in the Place section of the Modes tab).</p>
<p><kbd>NotifyActorBeginOverlap</kbd> and <kbd>NotifyActorEndOverlap</kbd> are overridden so that we can perform an operation when an object enters or leaves the <kbd>AntiGravityVolume</kbd> area.</p>
<p>Inside the <kbd>NotifyActorBeginOverlap</kbd> implementation, we attempt to cast the object that overlapped us into an <kbd>IGravityObject</kbd> pointer. This tests whether the object in question implements the interface. If the pointer is valid, then the object does implement the interface, so it is safe to use the interface pointer to call Interface methods on the object.</p>
<p>Given that we are inside <kbd>NotifyActorBeginOverlap</kbd>, we want to disable gravity on the object, so we call <kbd>DisableGravity()</kbd>. Inside <kbd>NotifyActorEndOverlap</kbd>, we perform the same check, but we re-enable gravity on the object. Within the default implementation of <kbd>DisableGravity</kbd>, we cast our own pointer (the <kbd>this</kbd> pointer) to <kbd>AActor</kbd>. This allows us to confirm that the interface has been implemented only on the <kbd>Actor</kbd> subclasses, and to call methods defined in <kbd>AActor</kbd>.</p>
<p>If the pointer is valid, we know we are an <kbd>Actor</kbd>, so we can use <kbd>GetComponents&lt;class ComponentType&gt;()</kbd> to get a <kbd>TArray</kbd> of all components of a specific type from ourselves. <kbd>GetComponents</kbd> is a <kbd>template</kbd> function. It expects some template parameters, as follows:</p>
<pre>template&lt;class T, class AllocatorType&gt;<br/> voidGetComponents(TArray&lt;T*, AllocatorType&gt;&amp;OutComponents)<br/> const</pre>
<p>Since the 2014 version of the standard, C++ supports compile-time deduction of template parameters. This means that we don't need to actually specify the template parameters when we call the function if the compiler can work them out from the normal function parameters that we provide.</p>
<p>The default implementation of <kbd>TArray</kbd> is <kbd>template&lt;typename T, typename Allocator = FDefaultAllocator&gt; class TArray;</kbd>. This means that we don't need to specify an allocator by default, so we just use <kbd>TArray&lt;UPrimitiveComponent*&gt;</kbd> when we declare the array.</p>
<p>When <kbd>TArray</kbd> is passed into the <kbd>GetComponents</kbd> function, the compiler knows it is actually <kbd>TArray&lt;UPrimitiveComponent*, FDefaultAllocator&gt;</kbd>, and it is able to fill in the template parameters <kbd>T</kbd> and <kbd>AllocatorType</kbd> with <kbd>UPrimitiveComponent</kbd> and <kbd>FDefaultAllocator</kbd>, so neither of those are required as template parameters for the function's invocation.</p>
<p><kbd>GetComponents</kbd> iterates through the components that <kbd>Actor</kbd> has, and any components that inherit from <kbd>typename T</kbd> have pointers to them stored inside the <kbd>PrimitiveComponents</kbd> array.</p>
<p>Using a range-based <kbd>for</kbd> loop, another new feature of C++, we can iterate over the components that the function placed into our <kbd>TArray</kbd> without needing to use the traditional <kbd>for</kbd> loop structure.</p>
<p>Each of the components has <kbd>SetEnableGravity(false)</kbd> called on them, which disables gravity.</p>
<p>Likewise, the <kbd>EnableGravity</kbd> function iterates over all the primitive components contained in the actor, and enables gravity with <kbd>SetEnableGravity(true)</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Look at <a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml">Chapter 4</a>, <em>Actors and Components,</em> for extensive discussions on Actors and Components</li>
<li><a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml">Chapter 5</a>, <em>Handling Events and Delegates,</em> discusses events such as <kbd>NotifyActorOverlap</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Inheriting UInterfaces from one another</h1>
                
            
            
                
<p>Sometimes, you may need to create a <kbd>UInterface</kbd> that specializes on a more general <kbd>UInterface</kbd>. This recipe shows you how to use inheritance with UInterfaces to specialize a <kbd>Killable</kbd> interface with an <kbd>Undead</kbd> interface that cannot be killed by normal means.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a <kbd>UInterface</kbd>/<kbd>IInterface</kbd> called <kbd>Killable</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/20054dc1-f6a5-4b7e-aec6-a85686630416.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Add <kbd>UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))</kbd> to the <kbd>UInterface</kbd> declaration:</li>
</ol>
<pre style="padding-left: 60px">// This class does not need to be modified.<br/>UINTERFACE(<strong>meta = (CannotImplementInterfaceInBlueprint)</strong>)<br/>class UKillable : public UInterface<br/>{<br/>  GENERATED_BODY()<br/>};</pre>
<ol start="3">
<li>Add the following functions to the header file under the <kbd>IKillable</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_07_API IKillable<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the class that <br/>    // will be inherited to implement this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintCallable, Category = Killable)</strong><br/><strong>    virtual bool IsDead();</strong><br/><strong>    UFUNCTION(BlueprintCallable, Category = Killable)</strong><br/><strong>    virtual void Die();</strong><br/>};</pre>
<ol start="4">
<li>Provide default implementations for the interface inside the implementation file:</li>
</ol>
<pre style="padding-left: 60px">#include "Killable.h"<br/><br/>// Add default functionality here for any IKillable functions that are <br/>// not pure virtual.<br/><strong>bool IKillable::IsDead()</strong><br/><strong>{</strong><br/><strong>    return false;</strong><br/><strong>}</strong><br/><br/><strong>void IKillable::Die()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "Arrrgh");</strong><br/><br/><strong>    AActor* Me = Cast&lt;AActor&gt;(this);</strong><br/><br/><strong>    if (Me)</strong><br/><strong>    {</strong><br/><strong>        Me-&gt;Destroy();</strong><br/><strong>    }</strong><br/><br/><strong>}</strong></pre>
<ol start="5">
<li>Create a new <kbd>UINTERFACE</kbd>/<kbd>IInterface</kbd> called <kbd>Undead</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/10841280-bffb-4867-a944-d463288ade74.png"/></p>
<ol start="6">
<li>Modify them so they inherit from <kbd>UKillable</kbd>/<kbd>IKillable</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/><strong>#include "Killable.h"</strong><br/>#include "Undead.generated.h"<br/><br/>// This class does not need to be modified.<br/>UINTERFACE(MinimalAPI)<br/>class UUndead : public <strong>UKillable</strong><br/>{<br/>  GENERATED_BODY()<br/>};<br/><br/>/**<br/> * <br/> */<br/>class CHAPTER_07_API IUndead : public <strong>IKillable</strong><br/>{<br/>  GENERATED_BODY()<br/><br/>  // Add interface functions to this class. This is the class that will <br/>  // be inherited to implement this interface.<br/>public:<br/>};</pre>
<p style="padding-left: 60px">Ensure that you include the header defining the <kbd>Killable</kbd> interface.</p>
<ol start="7">
<li>Add some overrides and new method declarations to the new interface:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_07_API IUndead : public IKillable<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the class that <br/>    // will be inherited to implement this interface.<br/>public:<br/><strong>    virtual bool IsDead() override;</strong><br/><strong>    virtual void Die() override;</strong><br/><strong>    virtual void Turn();</strong><br/><strong>    virtual void Banish();</strong><br/>};</pre>
<ol start="8">
<li>Create implementations for the functions:</li>
</ol>
<pre style="padding-left: 60px">#include "Undead.h"<br/><br/>// Add default functionality here for any IUndead functions that are <br/>// not pure virtual.<br/><strong>bool IUndead::IsDead()</strong><br/><strong>{</strong><br/><strong>    return true;</strong><br/><strong>}</strong><br/><br/><strong>void IUndead::Die()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "You can't kill what is already dead. Mwahaha");</strong><br/><strong>}</strong><br/><br/><strong>void IUndead::Turn()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "I'm fleeing!");</strong><br/><br/><strong>}</strong><br/><br/><strong>void IUndead::Banish()</strong><br/><strong>{</strong><br/><strong>    AActor* Me = Cast&lt;AActor&gt;(this);</strong><br/><strong>    if (Me)</strong><br/><strong>    {</strong><br/><strong>        Me-&gt;Destroy();</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<ol start="9">
<li>Create two new <kbd>Actor</kbd> classes in C++: one called <kbd>Snail</kbd>, and another called <kbd>Zombie</kbd>.</li>
<li>Set the <kbd>Snail</kbd> class to implement the <kbd>IKillable</kbd> interface, and add the appropriate header file, <kbd>#include</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Killable.h"</strong><br/>#include "Snail.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API ASnail : public AActor<strong>, public IKillable</strong></pre>
<ol start="11">
<li>Likewise, set the <kbd>Zombie</kbd> class to implement <kbd>IUndead</kbd>, and <kbd>#include "Undead.h"</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Undead.h"</strong><br/>#include "Zombie.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API AZombie : public AActor<strong>, public IUndead</strong></pre>
<ol start="12">
<li>Compile your project and drag an instance of both <kbd>Zombie</kbd> and <kbd>Snail</kbd> into your level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/131d2208-a1c8-45cd-ab64-d2bb2dfc2f2c.png"/></p>
<ol start="13">
<li>Open the Level Blueprint by going to Blueprints | Level Blueprint. Afterward, add references to each of the newly created objects in the Level Blueprint by dragging and dropping them from the World Outliner into the Level Blueprint and releasing them, one at a time:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/266bfc76-5685-4a63-872c-59b39aea216a.png"/></p>
<ol start="14">
<li>Afterward, call <kbd>Die (Interface Call)</kbd> on each reference:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/48189563-55b8-4d89-9964-44ff7b73676d.png"/></p>
<ol start="15">
<li>Connect the execution pins of the two message calls, then wire it up to <kbd>Event BeginPlay</kbd>. Run the game, and then verify that the <kbd>Zombie</kbd> is disdainful of your efforts to kill it, but the <kbd>Snail</kbd> groans and then dies (it is removed from the world outliner):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/64dc17b9-ed35-4104-bfec-cd739c40da78.jpg" style="width:27.42em;height:7.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>To make it possible to test this recipe in the Level Blueprint, we need to make the interface functions callable via Blueprint, so we need the <kbd>BlueprintCallable</kbd> specifier on our <kbd>UFUNCTION</kbd>.</p>
<p>However, in a <kbd>UInterface</kbd>, the compiler expects the interface to be implementable via both C++ and Blueprint by default. This conflicts with <kbd>BlueprintCallable</kbd>, which is merely saying that the function can be invoked from Blueprint, not that it can be overridden in it.</p>
<p>We can resolve this conflict by marking the interface as <kbd>CannotImplementInterfaceInBlueprint</kbd>. This enables the use of <kbd>BlueprintCallable</kbd> as our <kbd>UFUNCTION</kbd> specifier, rather than <kbd>BlueprintImplementableEvent</kbd> (which has extra overhead due to the extra code allowing for the function to be overridden via Blueprint).</p>
<p>We define <kbd>IsDead</kbd> and <kbd>Die</kbd> as <kbd>virtual</kbd> to allow them to be overridden in another C++ class that inherits this one. In our default interface implementation, <kbd>IsDead</kbd> always returns <kbd>false</kbd>. The default implementation of <kbd>Die</kbd> prints a death message to the screen, and then destroys the object implementing this interface if it is an <kbd>Actor</kbd>.</p>
<p>We can now create a second interface called <kbd>Undead</kbd>, which inherits from <kbd>Killable</kbd>. We use <kbd>public UKillable</kbd>/<kbd>public IKillable</kbd> in the class declarations to express this.</p>
<p>Of course, as a result, we need to include the header file that defines the <kbd>Killable</kbd> interface. Our new interface overrides the two functions that <kbd>Killable</kbd> defines to provide more appropriate definitions of <kbd>IsDead</kbd>/<kbd>Die</kbd> for <kbd>Undead</kbd>. Our overridden definitions have <kbd>Undead</kbd> already dead by returning <kbd>true</kbd> from <kbd>IsDead</kbd>. When <kbd>Die</kbd> is called on <kbd>Undead</kbd>, we simply print a message with <kbd>Undead</kbd> laughing at our feeble attempt to kill it again, and do nothing.</p>
<p>We can also specify default implementations for our Undead-specific functions, namely <kbd>Turn()</kbd> and <kbd>Banish()</kbd>. When the <kbd>Undead</kbd> are Turned, they flee, and for demonstration purposes, we print a message to the screen. If an <kbd>Undead</kbd> is Banished, however, they are annihilated and destroyed without a trace.</p>
<p>To test our implementation, we create two <kbd>Actors</kbd> that each inherit from one of the two interfaces. After we add an instance of each actor to our level, we use the Level Blueprint to access the level's <kbd>BeginPlay</kbd> event. When the level begins to play, we use a message call to try and call the <kbd>Die</kbd> function on our instances.</p>
<p>The messages that print out are different and correspond to the two function implementations, showing that the Zombie's implementation of <kbd>Die</kbd> is different, and has overridden the Snail's.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overriding UInterface functions in C++</h1>
                
            
            
                
<p>One side-effect of UInterfaces allowing inheritance in C++ is that we can override default implementations in subclasses as well as in Blueprint. This recipe shows you how to do so.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Follow the <em>Calling native UInterface functions from C++</em> recipe in which a Physics Cube has already been created so that you have the class ready.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new Interface called <kbd>Selectable</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cf51461a-92cc-42bb-b53b-83914ce680dd.png"/></p>
<ol start="2">
<li>Define the following functions inside <kbd>ISelectable</kbd>:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_07_API ISelectable<br/>{<br/>  GENERATED_BODY()<br/><br/>  // Add interface functions to this class. This is the class that will <br/>  // be inherited to implement this interface.<br/>public:<br/><strong>    virtual bool IsSelectable();</strong><br/><strong>    virtual bool TrySelect();</strong><br/><strong>    virtual void Deselect();</strong><br/>};</pre>
<ol start="3">
<li>Provide a default implementation for the functions, like so:</li>
</ol>
<pre style="padding-left: 60px">#include "Selectable.h"<br/><br/>// Add default functionality here for any ISelectable functions that are not pure virtual.<br/>bool ISelectable::IsSelectable()<br/>{<br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "Selectable");<br/>    return true;<br/>}<br/><br/>bool ISelectable::TrySelect()<br/>{<br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "Accepting Selection");<br/>    return true;<br/>}<br/><br/>void ISelectable::Deselect()<br/>{<br/>    unimplemented();<br/>}</pre>
<ol start="4">
<li>Create a class based on <kbd>APhysicsCube</kbd> by right-clicking on the Physics Cube script from the Content Browser and selecting Create C++ class derived from PhysicsCube:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/705a33b1-bc34-4cab-83ef-5eb9f2f739c2.png" style="width:41.67em;height:21.17em;"/></p>
<ol start="5">
<li>Once you're done, change the Name of the new cube to <kbd>SelectableCube</kbd> and click on the Create Class option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/76752a9d-e70c-4fae-a2e7-faa8ab5cb57b.png"/></p>
<ol start="6">
<li>Add <kbd>#include "Selectable.h"</kbd> inside the <kbd>SelectableCube</kbd> class' header.</li>
<li>Modify the <kbd>ASelectableCube</kbd> declaration, like so:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "PhysicsCube.h"<br/><strong>#include "Selectable.h"</strong><br/>#include "SelectableCube.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API ASelectableCube : public APhysicsCube<strong>, public ISelectable</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="8">
<li>Add the following functions to the header:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_07_API ASelectableCube : public APhysicsCube, public ISelectable<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    ASelectableCube();</strong><br/><strong>    virtual void NotifyHit(class UPrimitiveComponent* MyComp, </strong><br/><strong>                           AActor* Other, </strong><br/><strong>                           class UPrimitiveComponent* OtherComp, </strong><br/><strong>                           bool bSelfMoved, FVector HitLocation, </strong><br/><strong>                           FVector HitNormal, FVector NormalImpulse, </strong><br/><strong>                           const FHitResult&amp; Hit) override;</strong><br/><br/>};<br/><br/></pre>
<ol start="9">
<li>Implement the functions:</li>
</ol>
<pre style="padding-left: 60px">#include "SelectableCube.h"<br/><br/><strong>ASelectableCube::ASelectableCube() : Super()</strong><br/><strong>{</strong><br/><strong>    MyMesh-&gt;SetNotifyRigidBodyCollision(true);</strong><br/><strong>}</strong><br/><br/><strong>void ASelectableCube::NotifyHit(class UPrimitiveComponent* MyComp, </strong><br/><strong>                                AActor* Other, </strong><br/><strong>                                class UPrimitiveComponent* OtherComp, </strong><br/><strong>                                bool bSelfMoved, FVector HitLocation, </strong><br/><strong>                                FVector HitNormal, </strong><br/><strong>                                FVector NormalImpulse, </strong><br/><strong>                                const FHitResult&amp; Hit)</strong><br/><strong>{</strong><br/><strong>    if (ISelectable::IsSelectable())</strong><br/><strong>    {</strong><br/><strong>        TrySelect();</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<p class="mce-root"/>
<ol start="10">
<li>Create a new class called <kbd>NonSelectableCube</kbd>, which inherits from <kbd>SelectableCube</kbd>, in the same manner that we did with the <kbd>Physics Cube</kbd> to create the <kbd>SelectableCube</kbd> class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/604d9703-5f99-44c1-8cea-36ab7a22d846.png" style="width:54.00em;height:23.58em;"/></p>
<ol start="11">
<li><kbd>NonSelectableCube</kbd> should override the functions from <kbd>SelectableInterface</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "SelectableCube.h"<br/>#include "NonSelectableCube.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API ANonSelectableCube : public ASelectableCube<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    virtual bool IsSelectable() override;</strong><br/><strong>    virtual bool TrySelect() override;</strong><br/><strong>    virtual void Deselect() override;</strong><br/>};<br/><br/></pre>
<ol start="12">
<li>The implementation file should be altered to include the following:</li>
</ol>
<pre style="padding-left: 60px">#include "NonSelectableCube.h"<br/><br/><strong>bool ANonSelectableCube::IsSelectable()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "Not Selectable"); </strong><br/><strong>    return false;</strong><br/><strong>}</strong><br/><br/><strong>bool ANonSelectableCube::TrySelect()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "Refusing Selection");</strong><br/><strong>    return false;</strong><br/><strong>}</strong><br/><br/><strong>void ANonSelectableCube::Deselect()</strong><br/><strong>{</strong><br/><strong>    unimplemented();</strong><br/><strong>}</strong></pre>
<ol start="13">
<li>Place an instance of <kbd>SelectableCube</kbd> into the level at a certain range above the ground, and then play your game. You should get messages verifying that the actor is selectable, and that it has accepted the selection when the cube hits the ground:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d514b9e7-96d1-4b54-963e-3a1f72546c67.jpg" style="width:53.42em;height:27.75em;"/></p>
<ol start="14">
<li>Remove <kbd>SelectableCube</kbd> and replace it with an instance of <kbd>NonSelectableCube</kbd> to see the alternative messages indicating that this actor isn't selectable and has refused selection.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We create three functions inside the <kbd>Selectable</kbd> interface. <kbd>IsSelectable</kbd> returns a Boolean to indicate whether the object is selectable. You could avoid this and simply use <kbd>TrySelect</kbd>, given that it returns a Boolean value to indicate success, but, for example, you might want to know if the object inside your UI is a valid selection without having to actually try it.</p>
<p><kbd>TrySelect</kbd> actually attempts to select the object. There's no explicit contract forcing users to respect <kbd>IsSelectable</kbd> when trying to select the object, so <kbd>TrySelect</kbd> is named to communicates that the selection may not always succeed.</p>
<p>Lastly, <kbd>Deselect</kbd> is a function that's added to allow objects to handle losing the player selection. This could involve changing the UI elements, halting sounds or other visual effects, or simply removing a selection outline from around the unit.</p>
<p>The default implementations of the functions return <kbd>true</kbd> for <kbd>IsSelectable</kbd> (the default is for any object to be selectable), <kbd>true</kbd> for <kbd>TrySelect</kbd> (selection attempts always succeed), and issue a debug assert if <kbd>Deselect</kbd> is called without being implemented by the class.</p>
<p>You could also implement <kbd>Deselect</kbd> as a pure <kbd>virtual</kbd> function if you wish. <kbd>SelectableCube</kbd> is a new class inheriting from <kbd>PhysicsCube</kbd>, but also implementing the <kbd>ISelectable</kbd> interface. It also overrides <kbd>NotifyHit</kbd>, a <kbd>virtual</kbd> function defined in <kbd>AActor</kbd> that triggers when the actor undergoes a <strong>RigidBody</strong> collision.</p>
<p>We call the constructor from <kbd>PhysicsCube</kbd> with the <kbd>Super()</kbd> constructor call inside the implementation of <kbd>SelectableCube</kbd>. We then add our own implementation, which calls <kbd>SetNotifyRigidBodyCollision(true)</kbd> on our static mesh instance. This is necessary, because by default, <kbd>RigidBodies</kbd> (such as <kbd>PrimitiveComponents</kbd> with a collision) don't trigger <kbd>Hit</kbd> events as a performance optimization. As a result, our overridden <kbd>NotifyHit</kbd> function would never be called.</p>
<p>Within the implementation of <kbd>NotifyHit</kbd>, we call some of the <kbd>ISelectable</kbd> interface functions on ourselves. Given that we know we are an object that inherits from <kbd>ISelectable</kbd>, we don't need to cast to an <kbd>ISelectable*</kbd> to call them.</p>
<p>We check to see if the object is selectable with <kbd>IsSelectable</kbd> and, if so, we try to actually perform the selection using <kbd>TrySelect</kbd>. <kbd>NonSelectableCube</kbd> inherits from <kbd>SelectableCube</kbd>, so we can force the object to never be selectable.</p>
<p>We accomplish this by overriding the <kbd>ISelectable</kbd> interface functions again. Within <kbd>ANonSelectableCube::IsSelectable()</kbd>, we print a message to the screen so that we can verify that the function is being called, and then return <kbd>false</kbd> to indicate that the object isn't selectable at all.</p>
<p>In case the user doesn't respect <kbd>IsSelectable()</kbd>, <kbd>ANonSelectableCube::TrySelect()</kbd> always returns <kbd>false</kbd> to indicate that the selection wasn't successful.</p>
<p>Given that it is impossible for <kbd>NonSelectableCube</kbd> to be selected, <kbd>Deselect()</kbd> calls <kbd>unimplemented()</kbd>, which throws an assert warning that the function was not implemented.</p>
<p>Now, when playing your scene, each time <kbd>SelectableCube</kbd>/<kbd>NonSelectableCube</kbd> hits another object, causing a RigidBody collision, the actor in question will attempt to select itself, and print messages to the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to <a href="613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml">Chapter 6</a>, <em>Input and Collision, and</em> the <em>Mouse UI input handling</em> recipe, which shows you how to <strong>Raycast</strong> from the mouse cursor into the game world to determine what is being clicked on. This could be used to extend this recipe to allow the player to click on items to select them.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a simple interaction system with UInterfaces</h1>
                
            
            
                
<p>This recipe will show you how to combine a number of other recipes in this chapter to demonstrate a simple interaction system, and a door with an interactable doorbell to cause the door to open.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready...</h1>
                
            
            
                
<p>This recipe requires the use of Action bindings. If you are unfamiliar with creating Action mappings, please refer to <a href="613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml">Chapter 6</a>, <em>Input and Collision</em>, before continuing with this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new interface called <kbd>Interactable</kbd>.</li>
<li>Add the following functions to the <kbd>IInteractable</kbd> class declaration:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_07_API IInteractable<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the class that <br/>    // will be inherited to implement this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Interactable)</strong><br/><strong>    bool CanInteract();<br/></strong><br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Interactable)</strong><br/><strong>    void PerformInteract();</strong><br/><br/>};</pre>
<ol start="3">
<li>Create a second interface, <kbd>Openable</kbd>.</li>
<li>Add this function to its declaration:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_07_API IOpenable<br/>{<br/>  GENERATED_BODY()<br/><br/>  // Add interface functions to this class. This is the class that <br/>    // will be inherited to implement this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Openable)</strong><br/><strong>    void Open();</strong><br/>};</pre>
<ol start="5">
<li>Create a new class, based on <kbd>StaticMeshActor</kbd>, called <kbd>DoorBell</kbd>.</li>
<li>Add <kbd>#include "Interactable.h"</kbd> in <kbd>DoorBell.h</kbd>, and add the following functions to the class declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/><strong>#include "Interactable.h"</strong><br/>#include "DoorBell.generated.h"<br/><br/><br/>UCLASS()<br/>class CHAPTER_07_API ADoorBell : public AStaticMeshActor<strong>, public IInteractable</strong><br/>{<br/>  GENERATED_BODY()<br/>  <br/><strong>public:</strong><br/><strong>    ADoorBell();</strong><br/><br/><strong>    virtual bool CanInteract_Implementation() override;</strong><br/><strong>    virtual void PerformInteract_Implementation() override;</strong><br/><br/><strong>    UPROPERTY(BlueprintReadWrite, EditAnywhere)</strong><br/><strong>    AActor* DoorToOpen;</strong><br/><br/><strong>private:</strong><br/><strong>    bool HasBeenPushed;</strong><br/>};</pre>
<ol start="7">
<li>In the <kbd>.cpp</kbd> file for <kbd>DoorBell</kbd>, add <kbd>#include "Openable.h"</kbd>.</li>
<li>Load a static mesh for our <kbd>DoorBell</kbd> in the constructor:</li>
</ol>
<pre style="padding-left: 60px">ADoorBell::ADoorBell()<br/>{<br/>    HasBeenPushed = false;<br/><br/>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));<br/><br/>    UStaticMeshComponent * SM = GetStaticMeshComponent();<br/><br/>    if (SM != nullptr)<br/>    {<br/>        if (MeshAsset.Object != nullptr)<br/>        {<br/>            SM-&gt;SetStaticMesh(MeshAsset.Object);<br/>            SM-&gt;SetGenerateOverlapEvents(true);<br/>        }<br/><br/>        SM-&gt;SetMobility(EComponentMobility::Movable);<br/>        SM-&gt;SetWorldScale3D(FVector(0.5, 0.5, 0.5));<br/>    }<br/><br/>    SetActorEnableCollision(true);<br/><br/>    SetActorEnableCollision(true);<br/><br/>    DoorToOpen = nullptr;<br/>} </pre>
<ol start="9">
<li>Add the following function implementations to implement the <kbd>Interactable</kbd> interface on our <kbd>DoorBell</kbd>:</li>
</ol>
<pre style="padding-left: 60px">bool ADoorBell::CanInteract_Implementation()<br/>{<br/>    return !HasBeenPushed;<br/>}<br/><br/>void ADoorBell::PerformInteract_Implementation()<br/>{<br/>    HasBeenPushed = true;<br/>    if (DoorToOpen-&gt;GetClass()-&gt;ImplementsInterface( <br/>                                             UOpenable::StaticClass()))<br/>    {<br/>        IOpenable::Execute_Open(DoorToOpen);<br/>    }<br/>}</pre>
<ol start="10">
<li>Now create a new StaticMeshActor-based class called <kbd>Door</kbd>.</li>
<li><kbd>#include</kbd> the <kbd>Openable</kbd> and <kbd>Interactable</kbd> interfaces into the class header, and then modify Door's declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/><strong>#include "Interactable.h"</strong><br/><strong>#include "Openable.h"</strong><br/>#include "Door.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_07_API ADoor : public AStaticMeshActor<strong>, public IInteractable, public IOpenable</strong><br/>{<br/>    GENERATED_BODY()<br/>    <br/>};</pre>
<ol start="12">
<li>Add interface functions and a constructor to <kbd>Door</kbd>:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_07_API ADoor : public AStaticMeshActor, public IInteractable, public IOpenable<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    ADoor();</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    virtual bool CanInteract_Implementation() override;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    virtual void PerformInteract_Implementation() override;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    virtual void Open_Implementation() override;</strong><br/>};</pre>
<ol start="13">
<li>As with <kbd>DoorBell</kbd>, in the <kbd>Door</kbd> constructor, initialize our mesh component and load a model in it:</li>
</ol>
<pre style="padding-left: 60px">ADoor::ADoor()<br/>{<br/>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));<br/><br/>    UStaticMeshComponent * SM = GetStaticMeshComponent();<br/><br/>    if (SM != nullptr)<br/>    {<br/>        if (MeshAsset.Object != nullptr)<br/>        {<br/>            SM-&gt;SetStaticMesh(MeshAsset.Object);<br/>            SM-&gt;SetGenerateOverlapEvents(true);<br/>        }<br/><br/>        SM-&gt;SetMobility(EComponentMobility::Movable);<br/>        SM-&gt;SetWorldScale3D(FVector(0.3, 2, 3));<br/>    }<br/><br/>    SetActorEnableCollision(true);<br/>}</pre>
<p class="mce-root"/>
<ol start="14">
<li>Implement interface functions:</li>
</ol>
<pre style="padding-left: 60px">bool ADoor::CanInteract_Implementation()<br/>{<br/>    return true;<br/>}<br/><br/>void ADoor::PerformInteract_Implementation()<br/>{<br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Red, TEXT("The door refuses to budge. Perhaps there is a hidden switch nearby ? ")); <br/>}<br/><br/>void ADoor::Open_Implementation()<br/>{<br/>    AddActorLocalOffset(FVector(0, 0, 200));<br/>}</pre>
<ol start="15">
<li>Create a new DefaultPawn-based class called <kbd>InteractingPawn</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7461c8ae-8fcd-4088-9b81-11ef24f01cad.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="16">
<li>Add the following functions to the <kbd>Pawn</kbd> class header:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_07_API AInteractingPawn : public ADefaultPawn<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    void TryInteract();</strong><br/><br/><strong>private:</strong><br/><strong>    virtual void SetupPlayerInputComponent( UInputComponent* <br/>                                            InInputComponent) override;</strong><br/>};</pre>
<ol start="17">
<li>Inside the implementation file for the <kbd>Pawn</kbd>, add <kbd>#include "Interactable.h"</kbd>, and then provide implementations for both functions from the header:</li>
</ol>
<pre style="padding-left: 60px">#include "InteractingPawn.h"<br/>#include "Interactable.h"<br/>#include "Camera/PlayerCameraManager.h"<br/>#include "CollisionQueryParams.h"<br/>#include "WorldCollision.h"<br/><br/>void AInteractingPawn::TryInteract()<br/>{<br/>    APlayerController* MyController = Cast&lt;APlayerController&gt;( <br/>                                                           Controller);<br/><br/>    if (MyController)<br/>    {<br/>        APlayerCameraManager* MyCameraManager = <br/>                                     MyController-&gt;PlayerCameraManager;<br/><br/>        auto StartLocation = MyCameraManager-&gt;GetCameraLocation();<br/>        auto EndLocation = StartLocation + <br/>                      (MyCameraManager-&gt;GetActorForwardVector() * <br/>                       100);<br/><br/>        FCollisionObjectQueryParams Params;<br/>        FHitResult HitResult;<br/><br/>        GetWorld()-&gt;SweepSingleByObjectType(HitResult, StartLocation, <br/>                                            EndLocation, <br/>                                            FQuat::Identity,<br/> FCollisionObjectQueryParams(FCollisionObjectQueryParams::AllObjects), <br/>                                       FCollisionShape::MakeSphere(25),<br/>              FCollisionQueryParams(FName("Interaction"), true, this));<br/><br/>        if (HitResult.Actor != nullptr)<br/>        {<br/>            auto Class = HitResult.Actor-&gt;GetClass();<br/>            if (Class-&gt;ImplementsInterface( <br/>                                         UInteractable::StaticClass()))<br/>            {<br/>                if (IInteractable::Execute_CanInteract( <br/>                                                HitResult.Actor.Get()))<br/>                {<br/>                    IInteractable::Execute_PerformInteract( <br/>                                                HitResult.Actor.Get());<br/>                }<br/>            }<br/>        }<br/><br/>    }<br/><br/><br/>}<br/><br/>void AInteractingPawn::SetupPlayerInputComponent(UInputComponent* <br/>                                                      InInputComponent)<br/>{<br/>    Super::SetupPlayerInputComponent(InInputComponent);<br/>    InInputComponent-&gt;BindAction("Interact", IE_Released, this, <br/>                                       &amp;AInteractingPawn::TryInteract);<br/>}</pre>
<ol start="18">
<li>Now, create a new <kbd>GameMode</kbd> in either C++ or Blueprint, and set <kbd>InteractingPawn</kbd> as our default <kbd>Pawn</kbd> class.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/69d62766-4048-48e4-9aeb-2f953a73ba43.png" style="width:33.75em;height:27.08em;"/></p>
<ol start="19">
<li>Drag a copy of both <kbd>Door</kbd> and <kbd>Doorbell</kbd> into the level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7942f20f-0d64-45fd-9d08-35eac82a5dd1.png"/></p>
<ol start="20">
<li>Use the eyedropper beside doorbell's Door to Open, as shown in the following screenshot, then click on the door actor instance in your level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9423df93-c5d2-4666-bf2c-1a97fef82dc0.jpg" style="width:25.25em;height:9.75em;"/></p>
<p style="padding-left: 60px">Once you select the actor, you should see something similar to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e2c5d6d5-100e-42b4-87fa-9225736a8849.jpg" style="width:23.92em;height:9.08em;"/></p>
<ol start="21">
<li>Create a new Action binding in the editor called <kbd>Interact</kbd> and bind it to a key of your choice:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3e619bc5-fa62-4306-a5b7-44f79c468adc.jpg" style="width:35.50em;height:13.33em;"/></p>
<ol start="22">
<li>Play your level and walk up to the doorbell. Look at it, and press whatever key you bound <kbd>Interact</kbd> with. Verify that the door moves once. Refer to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3d3015cb-4993-4264-a6aa-5cfa33f45a0a.png" style="width:30.92em;height:21.67em;"/></p>
<ol start="23">
<li>You can also interact with the door directly to receive some information about it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c417b020-3dc8-450b-8f4f-d185d61d75a1.png" style="width:41.25em;height:29.00em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As in previous recipes, we mark <kbd>UFUNCTION</kbd> as <kbd>BlueprintNativeEvent</kbd> and <kbd>BlueprintCallable</kbd> to allow the <kbd>UInterface</kbd> to be implemented in either native code or Blueprint, and allow the functions to be called with either method.</p>
<p>We create <kbd>DoorBell</kbd> based on <kbd>StaticMeshActor</kbd> for convenience, and have <kbd>DoorBell</kbd> implement the <kbd>Interactable</kbd> interface. Inside the constructor for <kbd>DoorBell</kbd>, we initialize <kbd>HasBeenPushed</kbd> and <kbd>DoorToOpen</kbd> to the default safe values.</p>
<p>Within the implementation for <kbd>CanInteract</kbd>, we return the inverse of <kbd>HasBeenPushed</kbd> so that once the button has been pushed, it can't be interacted with.</p>
<p>Inside <kbd>PerformInteract</kbd>, we check if we have a reference to a door object to open. If we have a valid reference, we verify that the door actor implements <kbd>Openable</kbd>, and then we invoke the <kbd>Open</kbd> function on our door. Within <kbd>Door</kbd>, we implement both <kbd>Interactable</kbd> and <kbd>Openable</kbd>, and override the functions from each.</p>
<p>We define the <kbd>Door</kbd> implementation of <kbd>CanInteract</kbd> to be the same as the default. Within <kbd>PerformInteract</kbd>, we display a message to the user. Inside <kbd>Open</kbd>, we use <kbd>AddActorLocalOffset</kbd> to move the door a certain distance away. With Timeline in Blueprint or a linear interpolation, we could make this transition smooth rather than a teleport.</p>
<p>Lastly, we create a new <kbd>Pawn</kbd> so that the player can actually interact with objects. We create a <kbd>TryInteract</kbd> function, which we bind to the <kbd>Interact</kbd> input action in the overridden <kbd>SetupPlayerInputComponent</kbd> function.</p>
<p>This means that when the player performs the input that is bound to <kbd>Interact</kbd>, our <kbd>TryInteract</kbd> function will run. <kbd>TryInteract</kbd> gets a reference to <kbd>PlayerController</kbd>, casting the generic controller reference that all Pawns have.</p>
<p><kbd>PlayerCameraManager</kbd> is retrieved through <kbd>PlayerController</kbd>, so we can access the current location and rotation of the player camera. We create start and end points using the camera's location, then 100 units in the forward direction away from the camera's location, and pass those into <kbd>GetWorld::SweepSingleByObjectType</kbd>. This function takes in a number of parameters. <kbd>HitResult</kbd> is a variable that allows the function to return information about any object hit by the trace. <kbd>CollisionObjectQueryParams</kbd> allows us to specify whether we are interested in dynamic, static items, or both.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We accomplish a sphere trace by passing the shape in using the <kbd>MakeSphere</kbd> function. Sphere traces allow for slightly more human error by defining a cylinder to check for objects rather than a straight line. Given that the players might not look directly at your object, you can tweak the sphere's radius as appropriate.</p>
<p>The final parameter, <kbd>SweepSingleByObjectType</kbd>, is a struct that gives the trace a name, lets us specify whether we are colliding against a complex collision geometry, and most importantly, allows us to specify that we want to ignore the object that is initiating the trace.</p>
<p>If <kbd>HitResult</kbd> contains an actor after the trace is done, we check whether the actor implements our interface, then attempt to call <kbd>CanInteract</kbd> on it. If the actor indicates yes, it can be interacted with, so we then tell it to actually perform the interaction.</p>


            

            
        
    </body></html>