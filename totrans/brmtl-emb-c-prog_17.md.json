["```cpp\n#include \"adc_dma.h\"\n#define GPIOAEN            (1U<<0)\n#define ADC1EN            (1U<<8)\n#define CR1_SCAN        (1U<<8)\n#define CR2_DMA            (1U<<8)\n#define CR2_DDS            (1U<<9)\n#define CR2_CONT        (1U<<1)\n#define CR2_ADCON        (1U<<0)\n#define CR2_SWSTART        (1U<<30)\n#define DMA2EN                (1U<<22)\n#define DMA_SCR_EN          (1U<<0)\n#define DMA_SCR_MINC        (1U<<10)\n#define DMA_SCR_PINC        (1U<<9)\n#define DMA_SCR_CIRC        (1U<<8)\n#define DMA_SCR_TCIE        (1U<<4)\n#define DMA_SCR_TEIE        (1U<<2)\n#define DMA_SFCR_DMDIS        (1U<<2)\nuint16_t adc_raw_data[NUM_OF_CHANNELS];\nvoid adc_dma_init(void)\n{\n    /************GPIO Configuration**********/\n    /*Enable clock access to ADC GPIO Pin's Port*/\n    RCC->AHB1ENR |= GPIOAEN;\n    /*Set PA0 and PA1 mode to analog mode*/\n    GPIOA->MODER |= (1U<<0);\n    GPIOA->MODER |= (1U<<1);\n    GPIOA->MODER |= (1U<<2);\n    GPIOA->MODER |= (1U<<3);\n    /************ADC Configuration**********/\n    /*Enable clock access to ADC*/\n    RCC->APB2ENR |= ADC1EN;\n    /*Set sequence length*/\n    ADC1->SQR1 |= (1U<<20);\n    ADC1->SQR1 &= ~(1U<<21);\n    ADC1->SQR1 &= ~(1U<<22);\n    ADC1->SQR1 &= ~(1U<<23);\n    /*Set sequence*/\n    ADC1->SQR3 = (0U<<0) | (1U<<5);\n    /*Enable scan mode*/\n    ADC1->CR1 = CR1_SCAN;\n    /*Select to use DMA*/\n    ADC1->CR2 |=CR2_CONT |CR2_DMA|CR2_DDS;\n    /************DMA Configuration**********/\n    /*Enable clock access to DMA*/\n    RCC->AHB1ENR |=DMA2EN;\n    /*Disable DMA stream*/\n    DMA2_Stream0->CR &=~DMA_SCR_EN;\n    /*Wait till DMA is disabled*/\n    while((DMA2_Stream0->CR & DMA_SCR_EN)){}\n    /*Enable Circular mode*/\n    DMA2_Stream0->CR |=DMA_SCR_CIRC;\n    /*Set MSIZE i.e Memory data size to half-word*/\n    DMA2_Stream0->CR |= (1U<<13);\n    DMA2_Stream0->CR &= ~(1U<<14);\n    /*Set PSIZE i.e Peripheral data size to half-word*/\n    DMA2_Stream0->CR |= (1U<<11);\n    DMA2_Stream0->CR &= ~(1U<<12);\n    /*Enable memory addr increment*/\n    DMA2_Stream0->CR |=DMA_SCR_MINC;\n    /*Set periph address*/\n    DMA2_Stream0->PAR = (uint32_t)(&(ADC1->DR));\n    /*Set mem address*/\n    DMA2_Stream0->M0AR = (uint32_t)(&adc_raw_data);\n    /*Set number of transfer*/\n    DMA2_Stream0->NDTR = (uint16_t)NUM_OF_CHANNELS;\n    /*Enable DMA stream*/\n    DMA2_Stream0->CR |= DMA_SCR_EN;\n    /************ADC Configuration**********/\n    /*Enable ADC*/\n    ADC1->CR2 |=CR2_ADCON;\n    /*Start ADC*/\n    ADC1->CR2 |=CR2_SWSTART;\n}\n```", "```cpp\n#ifndef ADC_DMA_H__\n#define ADC_DMA_H__\n#include <stdint.h>\n#include \"stm32f4xx.h\"\nvoid adc_dma_init(void);\n#define NUM_OF_CHANNELS        2\nmain.c file. Update your main.c file, as shown here:\n\n```", "```cpp\n\n\t\t\tThis code initializes the UART for debugging, and it sets up the ADC with DMA to continuously read sensor data from ADC channels connected to GPIO pins. In the main function, we start by initializing the UART for communication, and then we call the `adc_dma_init` function to configure the ADC and DMA for data transfers. In the infinite loop, we repeatedly print the values from two sensors stored in the `adc_raw_data` array to the console.\n\t\t\tTo test the project, follow the steps we outlined in [*Chapter 11*](B21914_11.xhtml#_idTextAnchor303). Let’s proceed by developing the UART DMA driver.\n\t\t\tDeveloping the UART DMA driver\n\t\t\tCreate a copy of your previous project in your IDE. Rename this copied project `UART_DMA`. Next, create a new file named `uart_dma.c` in the `Src` folder and another file named `uart_dma.h` in the `Inc` folder. Update your `uart_dma.c` file, as shown here:\n\n```", "```cpp\n\n\t\t\tNext, we have the initialization function:\n\n```", "```cpp\n\n\t\t\tAnd then, the function for configuring the `rx` stream:\n\n```", "```cpp\n\n\t\t\tAnd then, the one for the `tx` stream\n\n```", "```cpp\n\n\t\t\tNext, the function for computing the baudrate value for the UART:\n\n```", "```cpp\n\n\t\t\tAnd then, the function for writing the baudrate value to the baudrate register:\n\n```", "```cpp\n\n\t\t\tNext, we have the interrupt handler for `Stream6`:\n\n```", "```cpp\n\n\t\t\tAnd then, the interrupt handler for `Stream5`:\n\n```", "```cpp\n\n\t\t\tLet’s go through each part of the code step by step.\n\t\t\tUART initialization\n\t\t\tIn the `uart2_rx_tx_init` function, we start by configuring the GPIO pins for UART2 communication. We enable the clock for GPIOA, ensuring that the `PA2` and `PA3` pins can be used. Setting PA2 and PA3 to alternate function mode allows them to serve as `UART2_TX` and `UART2_RX`, respectively. We further specify the alternate function type to `AF7`, which is the type for UART2 operations.\n\t\t\tWith the GPIO configuration complete, we proceed to enable the clock for UART2\\. We set the baud rate using the `uart_set_baudrate` function. By enabling DMA for both transmission and reception, we offload data handling from the CPU, allowing for more efficient data transfers. We set the transfer direction to both transmit and receive, clear any pending transmission complete flags, and enable the transmission complete interrupt. Finally, we enable the UART module and configure the NVIC to handle UART2 interrupts, ensuring that the system can respond to UART events promptly.\n\t\t\tDMA initialization\n\t\t\tHere, we start by enabling the clock for `DMA1`, ensuring that the DMA controller is powered and ready for configuration. Additionally, we enable the **DMA Stream6** interrupt in the NVIC, preparing the system to handle DMA-related interrupts efficiently.\n\t\t\tDMA configuration for UART reception\n\t\t\tIn `dma1_stream5_uart_rx_config`, we configure `USART2-DR`) and the memory address to our `uart_data_buffer`, where incoming data will be stored.\n\t\t\tWe specify the number of data items to transfer and select the appropriate DMA channel. Enabling memory address increment mode ensures that the data buffer is filled sequentially. Circular mode is enabled to allow continuous data reception, and the transfer direction is set **from peripheral to memory**. We enable the DMA stream and configure the NVIC to handle Stream5 interrupts, ensuring that the system is prepared for DMA events.\n\t\t\tDMA configuration for UART transmission\n\t\t\tThe `dma1_stream6_uart_tx_config` function configures DMA1 Stream6 to transmit data via UART2\\. Similar to the reception configuration, we start by disabling the DMA stream and clearing any existing interrupt flags. We set the peripheral address to the UART2 data register and the memory address to the data buffer that will be transmitted.\n\t\t\tWe specify the number of data items to transfer and select the appropriate DMA channel. Memory address increment mode is enabled to ensure that data is transmitted sequentially from the buffer. We set the transfer direction **from memory to peripheral** and enable the transfer complete interrupt. Finally, we enable the DMA stream to start the data transmission process.\n\t\t\tHelper functions\n\t\t\tThe `compute_uart_bd` function calculates the UART baud rate setting based on the peripheral clock and desired baud rate. The `uart_set_baudrate` function uses this computed value to set the baud rate in the UART’s `BRR` register, ensuring that UART communication occurs at the correct speed.\n\t\t\tInterrupt handlers\n\t\t\tLet’s break down the interrupt handlers:\n\n\t\t\t\t*   `DMA1_Stream6_IRQHandler`: This handler responds to DMA Stream6 interrupts. When a transfer completes, it sets the `g_tx_cmplt` flag and clears the interrupt flag, ensuring that the system is aware that the transmission is complete.\n\t\t\t\t*   `DMA1_Stream5_IRQHandler`: This handler responds to DMA Stream5 interrupts. When a transfer completes, it sets the `g_rx_cmplt` flag and clears the interrupt flag, indicating that new data has been received.\n\t\t\t\t*   `USART2_IRQHandler`: This handler manages UART2 interrupts. It sets the `g_uart_cmplt` flag when a UART event occurs and clears the transmission complete flag, maintaining the proper flow of UART communication.\n\n\t\t\tNext, we populate the `uart_dma.h` file. Here is the code:\n\n```", "```cpp\n#include <stdio.h>\n#include <string.h>\n#include \"uart.h\"\n#include \"uart_dma.h\"\nextern uint8_t g_rx_cmplt;\nextern uint8_t g_uart_cmplt;\nextern uint8_t g_tx_cmplt;\nextern char uart_data_buffer[UART_DATA_BUFF_SIZE];\nchar msg_buff[150] ={'\\0'};\nint main(void)\n{\n    uart2_rx_tx_init();\n    dma1_init();\n    dma1_stream5_uart_rx_config();\n    sprintf(msg_buff,\"Initialization...cmplt\\n\\r\");\n    dma1_stream6_uart_tx_config((uint32_t)msg_buff,strlen(msg_buff));\n    while(!g_tx_cmplt){}\n    while(1)\n    {\n        if(g_rx_cmplt)\n        {\n            sprintf(msg_buff, \"Message received : %s \\r\\n\",uart_data_\n            buffer);\n            g_rx_cmplt = 0;\n            g_tx_cmplt = 0;\n            g_uart_cmplt = 0;\n            dma1_stream6_uart_tx_config((uint32_t)msg_buff,strlen(msg_\n            buff));\n            while(!g_tx_cmplt){}\n        }\n    }\n}\n```", "```cpp\n#include \"dma.h\"\n#define DMA2EN                (1U<<22)\n#define DMA_SCR_EN          (1U<<0)\n#define DMA_SCR_MINC        (1U<<10)\n#define DMA_SCR_PINC        (1U<<9)\n#define DMA_SCR_TCIE        (1U<<4)\n#define DMA_SCR_TEIE        (1U<<2)\n#define DMA_SFCR_DMDIS        (1U<<2)\nvoid dma2_mem2mem_config(void)\n{\n    /*Enable clock access to the dma module*/\n    RCC->AHB1ENR |= DMA2EN;\n    /*Disable dma stream*/\n    DMA2_Stream0->CR = 0;\n    /*Wait until stream is disabled*/\n    while((DMA2_Stream0->CR & DMA_SCR_EN)){}\n    /*Configure dma parameters*/\n    /*Set MSIZE i.e Memory data size to half-word*/\n    DMA2_Stream0->CR |= (1U<<13);\n    DMA2_Stream0->CR &= ~(1U<<14);\n    /*Set PSIZE i.e Peripheral data size to half-word*/\n    DMA2_Stream0->CR |= (1U<<11);\n    DMA2_Stream0->CR &= ~(1U<<12);\n    /*Enable memory addr increment*/\n    DMA2_Stream0->CR |=DMA_SCR_MINC;\n    /*Enable peripheral addr increment*/\n    DMA2_Stream0->CR |=DMA_SCR_PINC;\n    /*Select mem-to-mem transfer*/\n    DMA2_Stream0->CR &= ~(1U<<6);\n    DMA2_Stream0->CR |= (1U<<7);\n    /*Enable transfer complete interrupt*/\n    DMA2_Stream0->CR |= DMA_SCR_TCIE;\n    /*Enable transfer error interrupt*/\n    DMA2_Stream0->CR |= DMA_SCR_TEIE;\n    /*Disable direct mode*/\n    DMA2_Stream0->FCR |=DMA_SFCR_DMDIS;\n    /*Set DMA FIFO threshold*/\n    DMA2_Stream0->FCR |=(1U<<0);\n    DMA2_Stream0->FCR |=(1U<<1);\n    /*Enable DMA interrupt in NVIC*/\n    NVIC_EnableIRQ(DMA2_Stream0_IRQn);\n}\n```", "```cpp\nvoid dma_transfer_start(uint32_t src_buff, uint32_t dest_buff, uint32_t len)\n{\n    /*Set peripheral address*/\n    DMA2_Stream0->PAR = src_buff;\n    /*Set memory address*/\n    DMA2_Stream0->M0AR = dest_buff;\n    /*Set transfer length*/\n    DMA2_Stream0->NDTR = len;\n    /*Enable dma stream*/\n    DMA2_Stream0->CR |= DMA_SCR_EN;\n}\n```", "```cpp\n#ifndef DMA_H__\n#define DMA_H__\n#include <stdint.h>\n#include \"stm32f4xx.h\"\n#define LISR_TCIF0        (1U<<5)\n#define LIFCR_CTCIF0        (1U<<5)\n#define LISR_TEIF0        (1U<<3)\n#define LIFCR_CTEIF0        (1U<<3)\nvoid dma2_mem2mem_config(void);\nvoid dma_transfer_start(uint32_t src_buff, uint32_t dest_buff, uint32_t len);\nmain.c file:\n\n```", "```cpp\n\n\t\t\tThe `main` function sets up and initiates a memory-to-memory DMA transfer, transferring data from the globally declared and initialized `sensor_data_arr` to the uninitialized `temp_data_arr`. It starts by initializing the transfer complete flag, `g_transfer_cmplt`, to `0`, ensuring that we can monitor the transfer status. The function then initializes UART for debugging purposes and configures the DMA using `dma2_mem2mem_config`. The DMA transfer is started by calling `dma_transfer_start`, specifying the source (`sensor_data_arr`), destination (`temp_data_arr`), and the length of the transfer (`BUFFER_SIZE`). The function then enters a loop, waiting until the transfer is complete, indicated by `g_transfer_cmplt` being set to `1`. Once the transfer is complete, it prints the contents of the `temp_data_arr` to the console, confirming that the data has been successfully transferred.\n\t\t\tOur `main.c` file also contains the DMA stream’s IRQHandler:\n\n```", "```cpp\n\n\t\t\tThe handler manages both transfer completion and error events. The function first checks whether the transfer complete interrupt flag (`TCIF0`) is set in the low interrupt status register (`LISR`). If this flag is set, it indicates that the DMA transfer has successfully finished. The function then sets the `g_transfer_cmplt` flag to `1` to signal to the main function that the transfer is complete, and it clears the interrupt flag by writing to the low interrupt flag clear register (`LIFCR`). Additionally, the function checks for a transfer error interrupt (`TEIF0`). If a transfer error is detected, it performs any necessary error handling and clears the error flag in `LIFCR`. This interrupt handler ensures smooth operation by promptly handling the completion of data transfers and addressing any errors that might occur during the process.\n\t\t\tNow, it’s time to test the project. To test the project, compile the code and upload it to your microcontroller. Open RealTerm or another serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. You should see the sensor values printed, indicating that the values have been successfully copied from `sensor_data_arr` to `temp_data_arr`, as our code only prints the contents of `temp_data_arr`.\n\t\t\tSummary\n\t\t\tIn this chapter, we learned about DMA, an important feature in microcontrollers for enhancing data throughput and offloading the CPU from routine data transfer tasks. We began by discussing the basic principles of DMA, emphasizing its role in high-performance embedded systems. We explored how DMA works and its significance in improving system efficiency, by allowing peripherals to transfer data directly to and from memory without continuous CPU intervention.\n\t\t\tThen, we focused on the STM32F4 implementation of the DMA controller, examining its key features and configuration options. We detailed the structure of the DMA controller, including its channels, streams, and key registers, such as the Stream Configuration Register (`DMA_SxCR`), Stream Number of Data Register (`DMA_SxNDTR`), Stream Peripheral Address Register (`DMA_SxPAR`), and Stream Memory Address Registers (`DMA_SxM0AR` and `DMA_SxM1AR`). This provided a comprehensive understanding of how to configure and control DMA for various data transfer operations.\n\t\t\tWe provided practical examples to solidify our understanding, including the development of DMA drivers for different use cases, such as ADC data transfers, UART communications, and memory-to-memory transfers. These examples involved initializing DMA, setting up the necessary parameters, and implementing functions to handle data transfers efficiently.\n\t\t\tIn the next chapter, we will learn about power management energy efficiency techniques in embedded systems.\n\n```", "```cpp\n\n```"]