- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries and Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the C++ standard library offers a vast array of containers and algorithms,
    certain aspects – such as dynamic memory allocation – can pose challenges in constrained
    environments. In [*Chapter 2*](Chapter_02.xhtml), we explored some of these issues
    and ways to address them. However, specialized libraries, like the **Embedded
    Template Library** (**ETL**), offer deterministic behavior and fixed memory footprints,
    making them well suited for embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded applications depend on **Hardware Abstraction Layers** (**HALs**) provided
    by vendors as C libraries. In [*Chapter 12*](Chapter_12.xhtml), we examined how
    to use interfaces to decouple application-level C++ code from the underlying C-based
    hardware interactions. Wrapping entire HALs in C++ is a lot of work, but luckily,
    there are projects such as Google’s Pigweed that are tackling exactly that, while
    offering additional functionality and flexibility for embedded development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 11*](Chapter_11.xhtml), we explored how C++ can perform computations
    at compile time, reducing memory footprint. In [*Chapter 15*](Chapter_15.xhtml),
    we learned about the Observer pattern and examined its compile-time implementation.
    Intel’s **Compile-time Initialization and Build** (**CIB**) elevates these ideas
    even further, enabling a declarative approach to configuring firmware applications
    at compile time. In this chapter, we will go through the following C++ libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded template library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pigweed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile-time Initialization and Build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can try the examples from this chapter in the Renode simulator in the Docker
    container you set up in [*Chapter 4*](Chapter_04.xhtml). Make sure that the Docker
    container is running.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the files for this chapter on GitHub at [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17).
  prefs: []
  type: TYPE_NORMAL
- en: Standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ standard defines two types of standard library implementation – hosted
    and freestanding:'
  prefs: []
  type: TYPE_NORMAL
- en: A freestanding implementation is designed to run without relying on services
    typically provided by an OS, such as filesystem access or multi-threading support.
    As a result, the C++ standard specifies only a limited subset of standard library
    headers that must be provided by a freestanding implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hosted implementation requires a globally defined main function, and the environment
    is responsible for invoking this function at startup. In a freestanding implementation,
    the startup routines and the entry point of the program are implementation-defined,
    allowing developers greater flexibility in specifying the initialization and execution
    flow of their applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the standard makes a clear distinction between hosted and freestanding
    implementation in terms of the globally defined main function, the configuration
    in some examples in this book blurs the line between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Freestanding and hosted implementations in GCC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though we operate in a freestanding environment (no OS), some examples
    in this book use components from the C++ standard library (e.g., `std::function`),
    which are typically associated with hosted implementations. This is possible because:'
  prefs: []
  type: TYPE_NORMAL
- en: As we observed in [*Chapter 4*](Chapter_04.xhtml), we set the program entry
    point in the linker script to `Reset_Handler`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reset_Handler`, implemented in the assembler startup script, performs low-level
    initialization and explicitly calls `main`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use nano specs ([*Chapter 7*](Chapter_07.xhtml)), linking against a size-optimized
    subset of the C++ standard library. This allows limited use of hosted features
    like `std::function` while avoiding dependencies on an OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This hybrid approach leverages GCC’s flexibility to combine freestanding execution
    (custom entry point, no OS) with hosted library features (standard headers, utilities)
    in a bare-metal environment.
  prefs: []
  type: TYPE_NORMAL
- en: To explicitly request GCC to use a freestanding implementation of the standard
    library, the compiler flag `-ffreestanding` should be used. The C++ standard library
    provides many components that are “pay only for what you use” and can be very
    useful even in resource‐constrained environments. In previous chapters, you’ve
    already worked with many parts of the standard library, so you have a solid understanding
    of its capabilities. Here, we’ll provide an overview of the parts that are best
    suited for resource‐constrained environments and point out which ones should be
    used with caution or avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric and math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embedded systems are often employed in automation and process control, requiring
    precise control over numeric types, their ranges, and math operations. The C++
    standard library provides the `<cstdint>`, `<limits>`, and `<cmath>` headers to
    define fixed-width integers, query numeric limits, and perform mathematical computations,
    helping ensure predictable behavior, portability, and efficiency in resource-constrained
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: <cstdint>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<cstdint>` header provides fixed-width integer types such as `std::int8_t`,
    `std::uint32_t`, and other well-known C types defined in `stdint.h`. These types
    are useful in embedded contexts where integer size and bit width are important
    for direct hardware register access, predictable overflow behavior, and memory
    usage considerations. By using them, you explicitly document your intention for
    a variable’s size, thereby improving code portability and preventing potential
    surprises when moving between platforms with different native integer widths.
  prefs: []
  type: TYPE_NORMAL
- en: <limits>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The header provides the `std::numeric_limits` template, which describes properties
    of fundamental numeric types (like minimum and maximum values, sign, and precision).
    This is especially useful in embedded contexts for handling overflow. Typical
    usage occurs at compile-time or through trivial inlining by the compiler, resulting
    in minimal runtime overhead. By using functions like `std::numeric_limits::max()`,
    you avoid scattering magic constants or architecture-specific assumptions, aiding
    portability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: <cmath>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<cmath>` header provides standard math functions such as `std::sin`, `std::cos`,
    `std::sqrt`, and more. In embedded environments, especially those without floating-point
    hardware, these functions can be relatively expensive in terms of both runtime
    performance and code size. Carefully consider whether you really need floating-point
    math, and if so, whether approximations or fixed-point routines might be sufficient
    and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embedded systems often manage structured data and require efficient ways to
    process it under tight resource constraints. The C++ standard library offers container
    and algorithm headers such as `<array>`, `<span>`, and `<algorithm>` to organize
    data and perform common operations like searching, sorting, and transforming,
    enabling more readable and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: std::array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only fixed-size container in the standard library that avoids dynamic allocation
    is `std::array`. We covered it in [*Chapter 1*](Chapter_01.xhtml), when we discussed
    generic types. In the same chapter, we based the ring buffer implementation on
    `std::array`, which allowed us to create ring buffers of different types and sizes
    using the same generic code.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::array` is typically implemented as a wrapper around a C-style array.
    Besides being a generic type, it also offers the `at` method for index-based access
    with runtime bounds checking, making it a safer alternative to raw arrays. If
    an out-of-bounds index is requested, the `at` method will throw an exception.
    If exceptions are disabled, it may call `std::terminate` or `std::abort`, depending
    on the library implementation. These behaviors should be handled according to
    your system requirements by implementing appropriate terminate and signal handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'std:: priority_queue'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::priority_queue` is a container adapter that provides priority queue functionality.
    By default, it uses `std::vector` as the underlying container. However, as shown
    in [*Chapter 14*](Chapter_14.xhtml), you can substitute it with `etl::vector`
    from ETL, avoiding issues with dynamic memory allocation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'std:: span'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As shown in [*Chapter 9*](Chapter_09.xhtml), `std::span` is a lightweight, non-owning
    wrapper around a contiguous sequence of objects, where the first element is at
    position 0\. It provides essential functionality such as the `size()` method,
    `operator[]` for element access, and the `begin()` and `end()` iterators, allowing
    it to integrate seamlessly with standard library algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::span` can be constructed from C-style arrays as well as containers like
    `std::array` and `std::vector` or `etl::vector`. This makes it a practical alternative
    to using separate pointer and size parameters, which is especially useful when
    interfacing C++ code with C libraries such as those used in HAL.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Iterators are abstractions that act like generalized pointers, providing a uniform
    way to traverse and access elements within a container. For example, standard
    library containers implement the `begin()` and `end()` methods, which return iterators
    marking the start and one-past-the-end of their sequence. This consistent interface
    allows algorithms to work generically over different container types, enhancing
    code reusability and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us go through the following example using `std::array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates how to use iterators with a standard library container:'
  prefs: []
  type: TYPE_NORMAL
- en: The iterator `start` is explicitly declared as `std::array<int, 5>::iterator`
    to illustrate the full type name, while the iterator `finish` is declared using
    `auto` for conciseness, allowing the compiler to deduce its type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::sort` algorithm is applied using the iterators `start` and `finish`,
    obtained from `arr.begin()` and `arr.end()`, to sort the array in ascending order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop uses `auto` to declare the iterator `it`, which makes the code more
    concise. The loop traverses the sorted array, and `printf` is used to print each
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators are used to traverse containers. They not only promote generic programming
    but also make it easy to switch container types without changing the algorithmic
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Algorithms from the standard library offer a consistent way to solve common
    problems across different containers, making the code more expressive and easier
    to maintain. They allow you to perform operations like searching, sorting, copying,
    and accumulating data using a uniform interface. Some of the most used algorithms
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort`: Sorts a range of elements in ascending order by default, using
    the less-than operator for comparison. It can also accept a custom comparator
    to sort based on different criteria, such as descending order or a specific object
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::find`: Searches for the first occurrence of a given value in a range
    and returns an iterator to it. If the value is not found, it returns the end iterator,
    signaling that the search failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::for_each`: Applies a specified function or lambda to each element in
    a range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::copy`: Copies the elements of one range into another destination range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::copy_if`: Copies only elements that satisfy a specified predicate, making
    it useful for filtering data as you copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::min` and `std::max`: Return the smaller or larger of two values, respectively,
    using the less-than operator by default (or a provided comparison function). They’re
    handy for quick comparisons where you just need the minimum or maximum of two
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::min_element` and `std::max_element`: Return an iterator to the smallest
    or largest element in a range. These are useful when you need to find the position
    of an extreme value in a container (instead of comparing just two values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::accumulate`: Iterates over a range and combines the elements with an
    initial value using a binary operation (default is addition). This allows for
    summing values, computing products, or performing any custom aggregation you define.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template metaprogramming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 8*](Chapter_08.xhtml), C++ type traits are compile-time
    predicates and transformations that allow the compiler to enforce constraints
    based on a type’s properties. They are used for writing generic, robust code without
    incurring runtime overhead. In [*Chapter 12*](Chapter_12.xhtml), we used type
    traits to create type-safe register access, preventing invalid type usage at compile
    time and reducing the risk of subtle errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some concrete type traits we’ve utilized in the chapters mentioned
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::enable_if`: Enables or disables function templates based on a Boolean
    compile-time expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_same`: Checks if two types are exactly the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_enum`: Checks if a type is an enumeration type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::underlying_type`: Retrieves the underlying integer type of an enum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_arithmetic`: Checks if a type is an arithmetic type (integral or floating-point)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_integral`: Checks if a type is an integral type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_floating_point`: Checks if a type is a floating-point type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parts of the standard library to avoid in embedded applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many containers from the standard library, such as `std::vector`, `std::list`,
    and `std::string`, use dynamic memory allocation. If dynamic memory allocation
    is not allowed in your embedded application, these should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: The `iostream` library, included with header `<iostream>,` requires significant
    memory resources and also relies on dynamic allocation. That’s why we used the
    `<cstdio>` header and the `printf` function for console output.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](Chapter_10.xhtml), we covered `std::function` from the `<functional>`
    header. There, we outlined that in some scenarios, `std::function` can use dynamic
    memory allocation, meaning if used, it should be used with caution. Note that
    `std::function` is not available in a freestanding implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will give a short overview of ETL that compliments the standard library
    in the context of restricted embedded environments.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded template library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](Chapter_02.xhtml), we saw that `std::vector` uses dynamic
    memory allocation by default. We also saw that we can use `std:: polymorphic_allocator`
    and a monotonic buffer to make it use statically allocated memory. This approach
    is still not bulletproof as `std::vector` in some cases can resort to dynamic
    memory allocation even with this approach.'
  prefs: []
  type: TYPE_NORMAL
- en: To address some of the challenges posed by the standard library in embedded
    contexts, ETL provides a set of templated containers and algorithms that closely
    mimic the interfaces of standard library counterparts but are tailored for systems
    with limited resources.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed-size containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary advantages of ETL is that its containers (such as `etl::vector`,
    `etl::list`, `etl::string`, and others) allow you to specify a fixed maximum size
    at compile time. Container implementations ensure that no dynamic memory allocation
    is performed at runtime as memory is reserved up front as atomic or static storage.
  prefs: []
  type: TYPE_NORMAL
- en: As ETL containers are designed to mimic standard library containers, and they
    implement iterators, they can be used with most algorithms and container adapters
    from the standard library. This allows us to leverage components from the standard
    library without worrying about dynamic allocation.
  prefs: []
  type: TYPE_NORMAL
- en: ETL also offers `etl::array` for platforms that do not support C++11, since
    `std::array` was introduced in C++11.
  prefs: []
  type: TYPE_NORMAL
- en: Storing a callable with etl::delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in [*Chapter 14*](Chapter_14.xhtml), you can use `etl::delegate` instead
    of `std::function` to store a callable. However, `etl::delegate` is non-owning,
    so you must handle potential dangling references carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Other utilities provided by ETL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides fixed-size containers and `etl::delegate`, ETL also provides utilities
    such as a messaging framework – a collection of messages, message routers, message
    buses, and finite state machines. It also offers CRC calculations, checksums,
    and hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: ETL allows you to configure error handling. It can be configured to throw exceptions
    or send errors to the user-defined handler. This allows greater flexibility and
    project-based configuration depending on system requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about ETL at the website [https://www.etlcpp.com/](https://www.etlcpp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss Pigweed – a collection of lightweight, modular C++ libraries
    for embedded systems, developed by Google, offering components like logging, assertions,
    and Bluetooth connectivity to simplify development and improve code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Pigweed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest challenges in embedded systems development is portability.
    For code to be truly portable, it must depend on interfaces. To run it on different
    hardware targets, someone needs to implement those interfaces on different targets.
    Maintaining consistent interfaces across various projects and devices can be difficult.
    Google’s Pigweed project aims to solve this by providing software modules for
    embedded applications, with hardware interfaces already implemented for many targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pigweed is intended for complex projects and large-scale teams. Besides the
    hardware interfaces, it also:'
  prefs: []
  type: TYPE_NORMAL
- en: Packs software modules built on top of them, such as logging, serial communication
    (SPI, I2C, and UART), Bluetooth **Host Controller Interface** (**HCI**), interactive
    console, **Remote Procedure Call** (**RPC**) system, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provides embedding-friendly alternatives to standard library components: fixed-size
    strings and containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages the entire toolchain out of the box and simplifies setting up your development
    environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides an entire framework – `pw_system` – which pulls together many modules
    across Pigweed to construct a working system with RPC, logging, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, Pigweed is not only a library – it is an entire development
    ecosystem. It can be used as a framework, but you can also cherry-pick individual
    modules that suit your needs. As stated on the documentation website – [https://pigweed.dev/](https://pigweed.dev/)
    – Pigweed is still in its early stages; some modules are still in development
    stages, while some are stable and used on devices that are already on the market.
    As with any library, you need to evaluate it for potential use in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go through Pigweed’s Sense tutorial to demonstrate some of its capabilities
    – mainly the interactive console and **RPC** system.
  prefs: []
  type: TYPE_NORMAL
- en: Pigweed’s Sense tutorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Sense project is a demo project that utilizes many Pigweed components and
    shows how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sense is a simplified version of an air quality sensor that only includes some
    of the functions of a full product. The goal is to give you practical experience
    with working with Pigweed by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure the Docker daemon is running. Start a Docker image in network
    host mode and attach it to Bash. You can use the following commands in a Linux
    environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the Windows-based host, use the following command to forward the ports
    needed to run the tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, clone the Sense repo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, start Visual Studio Code, attach to the running container, and open the
    `/workspace/sense` folder. If you see a pop-up message in **Visual Studio Code**
    recommending the installation of the Pigweed extension, accept it; otherwise,
    go to **Extensions**, search for `Pigweed`, and install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Visual Studio Code extension](img/B22402_17_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – Visual Studio Code extension
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17**.1* depicts the Visual Studio Code Pigweed extension.'
  prefs: []
  type: TYPE_NORMAL
- en: After the installation of the extension, go to Explorer view and expand the
    **BAZEL BUILD TARGETS** node. Click on the **Refresh Target List** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.2 – BAZEL BUILD TARGETS node](img/B22402_17_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – BAZEL BUILD TARGETS node
  prefs: []
  type: TYPE_NORMAL
- en: 'Refreshing the target list can take between 30 seconds and a couple of minutes.
    Pigweed uses Bazel for build automation. The refreshed target list should look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – BAZEL BUILD TARGETS](img/B22402_17_3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – BAZEL BUILD TARGETS
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17**.3* depicts Bazel build targets.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, expand the **//apps/blinky** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.4 – //apps/blinky targets](img/B22402_17_4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.4 – //apps/blinky targets
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will build a version of the app that runs on the host. Right-click
    **simulator_blinky (host_device_simulator_binary)** and then click **Build Target**.
    The build can take around 10 minutes. When completed, you should see a message
    similar to this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.5 – Successful build](img/B22402_17_5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.5 – Successful build
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful build, we will start the app. Right-click **simulator_blinky
    (host_device_simulator_binary)** and then **Run Target**. If successful, you should
    see the following message in the terminal: **Awaiting connection on port 33000**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, right-click **simulator_console (native_binary)** and then **Run Target**.
    This will build a console and connect it to the running simulator. If successful,
    you should see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.6 – Interactive console running in terminal view](img/B22402_17_6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.6 – Interactive console running in terminal view
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 17**.6*, you can see the interactive console running in the terminal
    view in Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the console easier to work with, right-click on **Run //apps/blinky:simulator_console**
    and select **Move Terminal into New Window**. This will move the console into
    a separate window, as shown in this image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.7 – Interactive console running in a separate window](img/B22402_17_7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.7 – Interactive console running in a separate window
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 17**.7*, in the top-right pane, **Device Logs**, we can see logs
    coming from the simulated device (app running on the host). It sends **LED blinking**
    messages every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will send a message to the device using the RPC protocol, to retrieve
    the temperature measured by the device. Enter the following command in the bottom-left
    pane – **Python Repl**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, send a message that will toggle the LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This call will make the LED blink three times at a 200 ms interval and afterward
    stop the **LED blinking** messages. This shows us that we can also provide arguments
    to RPC calls.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go through Pigweed’s RPC in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: RPC and Protocol Buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pigweed’s RPC system is based on Protocol Buffers – a platform-neutral mechanism
    used for data serialization. Protocol Buffers is a language with its own syntax,
    which can be compiled into a targeted language such as C++ on our Sense device
    and the Python code we used in the Python **Read Eval Print Loop** (**REPL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why use an extra layer of abstraction, such as Protocol Buffers, in an
    embedded application? There are a couple of benefits a standardized serialization
    brings to your projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Compact binary messages – they add very little overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A precise contract (a `.proto` file) between different parts of a system, ensuring
    that all parties agree on the structure and meaning of the exchanged data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates to the communication protocol can be managed by modifying a proto file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, instead of writing serialization and deserialization code in multiple
    code bases (C++ and Python) and maintaining it as such, you write the communication
    protocol in a proto file and use the Protocol Buffers compiler to generate C++
    and Python code used for serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine a part of the `modules/blinky/blinky.proto` file describing
    the Blinky service used in the *Pigweed’s Sense tutorial* section to blink the
    LED three times at 200 ms intervals in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This proto file defines a service called `Blinky` for controlling an LED, using
    Protocol Buffers version 3 (`syntax = "proto3"`). It imports a `common` proto
    file and defines two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ToggleLed`: A simple method that switches the LED on or off, using an empty
    request and response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blink`: A method that blinks the LED with a configurable `interval_ms` and
    `optional blink_count` (members of `BlinkRequest`). The use of the `optional`
    keyword means this parameter can be omitted when calling the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a short explanation of the blinky.proto file. A more thorough guide
    to Protocol Buffers can be found at the following website: [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each service in a `blinky` proto file, Pigweed’s code generator will generate
    a corresponding C++ class. The generated `Blinky` class resides in a dedicated
    `pw_rpc::nanopb` sub-namespace within the file’s package: `blinky::pw_rpc::nanopb::Blinky::Service`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated class serves as a base class that must be inherited to implement
    the service’s methods. It is templated on the derived class. The `BlinkyService`
    class implements the base class. The following code is part of its definition
    from the `modules/blinky/service.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`BlinkyService` bridges the generated RPC interface with the concrete implementation
    for controlling the LED. It has a private object, `blinky_`, of type `Blinky`,
    which is used to control an LED, as shown in the implementation of the `ToggleLed`
    and `Blink` methods in the following code block from the `modules/blinky/service.cc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the methods `ToggleLed` and `Blink` use the `blinky_` object to
    control the LED. When binary proto messages for the `blinky` service are received
    over a transport layer, they are converted into actual calls to the code used
    to control hardware, which is the essence of RPC.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, expand the `blinky` service by adding the `BlinkTwice` method.
    You already know the files where you need to make changes – the proto file and
    the `BlinkyService` implementation files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pigweed uses **nanopb** ([https://github.com/nanopb/nanopb](https://github.com/nanopb/nanopb))
    to compile proto files in C files and then wrap them in C++. There is a pure C++
    implementation of Protocol Buffers designed especially for microcontrollers –
    Embedded Proto. It is an object-oriented implementation that only uses static
    memory allocation. It has been developed using the MISRA C++ guidelines. These
    traits together make Embedded Proto suitable for applications with a wide range
    of requirements, from low memory usage to safety concerns. You can find more about
    it on the GitHub page: [https://github.com/Embedded-AMS/EmbeddedProto](https://github.com/Embedded-AMS/EmbeddedProto).'
  prefs: []
  type: TYPE_NORMAL
- en: Pigweed has a steep learning curve and should be carefully evaluated based on
    your system requirements. It is better suited for larger, more complex projects
    due to the learning overhead. Additionally, evaluate the hardware support and
    take into consideration the memory overhead some modules may introduce.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to Pigweed, Intel’s **CIB** library leverages C++ compile-time capabilities.
    This approach minimizes memory overhead while enhancing flexibility and expressiveness.
    Next, we will cover the CIB library.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time Initialization and Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of C++’s major advantages in embedded systems is its ability to perform
    compile-time computation. In most cases, we have significant knowledge about the
    application beforehand, allowing us to configure it at compile time. Intel’s CIB
    library provides a declarative interface for configuring firmware components during
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [*Chapter 15*](Chapter_15.xhtml), the Observer design pattern
    is commonly used in event-driven systems to decouple the source of events (publisher)
    from the entities that react to those events (observers or subscribers). By using
    a subscriber interface, observers can register themselves with the event source,
    which then notifies them of changes or events without needing to know details
    about the observers’ implementations.
  prefs: []
  type: TYPE_NORMAL
- en: This decoupling allows for greater flexibility and modularity in system design,
    as components can be added, removed, or modified without tightly coupling them
    to the event generator. This property is leveraged by the CIB library, which implements
    a compile-time observer pattern to provide a declarative interface for configuring
    firmware applications. By resolving dependencies and establishing event-driven
    relationships at compile time, CIB eliminates runtime overhead while keeping components
    loosely coupled and efficiently interconnected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start exploring the CIB library on a simple example of a temperature
    publisher. The entire example is available at [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib).
    You can run it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can use `app/src/main.cpp` to follow through the example, as CIB, at the
    time of writing, is not available as a library in Compiler Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Using CIB in a temperature publisher example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to declare a service (publisher) as an empty struct that inherits
    from `callback::service`, a variadic class template, provided with types that
    will be accepted by subscribers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the subscribers (also called components in the context
    of the CIB library) `display_temperature_component` and `data_sender_component`,
    as shown in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code defines two components, which do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide handlers for the `send_temperature` service in the `constexpr` lambdas
    `display_temperature` and `send_temp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `constexpr static auto config` member through which they extend the
    service (subscribe to the events).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Config members are instances of variadic template class `cib::config`, and
    they are used by the CIB library to wire the application at compile time, that
    is, to connect services (event generators, publishers) with software components
    that extend those services (observers). Compile-time initialization and the build
    process are performed by `cib::nexus`, which needs to be supplied with the project
    configuration. Here is the code for configuration for this simple project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This project configuration is a simple struct, `my_project`, with the `constexpr`
    member config, which is provided with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cib::exports<send_temperature>`: Used to declare services (publishers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cib::components<display_temperature_component, data_sender_component>`: Used
    to declare software components that can extend services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s see how we use all of this in a firmware application in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code, we perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cib::nexus<my_project> nexus{};`: Create an instance of the class template
    `cib::nexus` provided by the project configuration `my_project`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nexus.init();`: Initialize Nexus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nexus.service<send_temperature>(42.0f);`: Access the service and provide it
    with the float argument (temperature). This will trigger calls to lambdas in components
    that extend the `send_temperature` service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the temperature publisher example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will extend this simple example with two components – a dummy temperature
    sensor and I2C components that we will name `temperature_sensor_component` and
    `i2c`. We will also introduce two new services – `runtime_init` and `main_loop`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with defining new services in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we define two services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`runtime_init`: Derives from the variadic class template `flow::service`, allowing
    us to sequence actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main_loop`: Derives from `callback::service`, which will be called in the
    main `while` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will move now to implementations of I2C components, as shown in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code defines a new component – `i2c` – as a struct with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constexpr static auto init`: A lambda wrapped in `flow::action` that implements
    the initialization of the I2C peripheral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constexpr static auto config`: Adds the above action to the `runtime_init`
    flow service. The `*` operator explicitly adds an action to the flow. Without
    it, the action is referenced but never added, causing a compile-time error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s go through the temperature sensor component shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code shows the struct `temperature_sensor_component` with the
    following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constexpr static auto init`: A `flow_action` that implements the initialization
    of the temperature sensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constexpr static auto read_temperature`: A lambda that implements periodic
    readings of a temperature sensor and uses `cib::service<read_temperature>` to
    publish the read value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constexpr static auto config`: Extends the `main_loop` service with the `read_temperature`
    lambda and the `runtime_init` flow with `i2c::init >> *init`, indicating that
    `i2c::init` precedes `init`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to modify the `my_project` struct to export new services and
    add new components, as shown in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code, we simply added:'
  prefs: []
  type: TYPE_NORMAL
- en: The `runtime_init` and `main_loop` services to `cib::exports`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2c` and `temperature_sensor_component` to `cib::components`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, let us see the new `main` function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As previously, we first create a `cib::nexus` instance and initialize it. Then,
    we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nexus.service<runtime_init>()`: This will run all actions in the flow `runtime_init`
    and ensure the specified order of actions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nexus.service<main_loop>()`: This is a call in the main loop executing all
    lambdas that are extending this service.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This structure is typical for many firmware applications: initialize all components
    (including hardware peripherals), then repeatedly call relevant services in the
    main loop. Any changes to the application are done in the `my_project` struct
    in a declarative way – by extending services and adding or removing components.
    All initialization is performed in the components themselves, meaning the main
    function does not need to know the details of individual components and their
    dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CIB library also includes logging, interrupt, message, and string constant
    libraries – all leveraging C++’s compile-time computation. You can find more information
    about CIB on GitHub: [https://github.com/intel/compile-time-init-build](https://github.com/intel/compile-time-init-build).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the full CIB example in Renode. Start Visual Studio Code, attach
    it to the running container, open the `Chapter17/cib` project, as described in
    [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the above example will generate the output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the usage of the CIB library in an event-driven system
    with loosely coupled components, where some generate events and others react to
    them. The wiring of publishers and subscribers happens at compile time, minimizing
    the memory footprint and reducing runtime overhead, while the declarative project
    configuration improves readability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw an overview of the libraries used throughout this book
    – the C++ standard library and ETL. You also got an insight into Google’s Pigweed
    library and its capabilities and Intel’s CIB library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through cross-platform development.
  prefs: []
  type: TYPE_NORMAL
