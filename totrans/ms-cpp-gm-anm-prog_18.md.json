["```cpp\n void setMusicVolume(int volume);\n    int getMusicVolume(); \n```", "```cpp\n int mMusicVolume = 64; \n```", "```cpp\n**#****include****\"****AudioManager.h\"**\n...\n **AudioManager mAudioManager{};** \n```", "```cpp\n if (!mAudioManager.init()) {\n    Logger::log(1, \"%s error: unable to init audio,\n      skipping\\n\", __FUNCTION__);\n  } \n```", "```cpp\n if (mAudioManager.isInitialized()) {\n    mAudioManager.loadMusicFromFolder(\"assets/music\", \"mp3\"));\n  } \n```", "```cpp\nvoid Window::cleanup() {\n  mRenderer->cleanup();\n **mAudioManager.****cleanup****();**\n...\n} \n```", "```cpp\nusing playMusicTitleCallback =\n  std::function<void(std::string)>; \n```", "```cpp\n playMusicTitleCallback micPlayMusicTitleCallbackFunction; \n```", "```cpp\n ModelInstanceCamData& rendererMICData =\n    mRenderer->getModInstCamData();\n    RendererMICData.micPlayMusicTitleCallbackFunction =\n    [this](std::string title) {\n      mAudioManager.playTitle(title);\n    }; \n```", "```cpp\nsudo apt install libsdl2-dev libsdl2-mixer-dev \n```", "```cpp\nsudo pacman â€“S sdl2 sdl2_mixer \n```", "```cpp\n#include <SDL.h>\n#include <`SDL_mixer`.h> \n```", "```cpp\nstd::unordered_map<std::string, Mix_Music*> mMusicTitles{};\nMix_Chunk* mWalkFootsteps; \n```", "```cpp\n if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n    return false;\n  } \n```", "```cpp\nif (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 8192) < 0) {  return false;\n} \n```", "```cpp\n Mix_CloseAudio();\n  Mix_Quit();\n  SDL_Quit(); \n```", "```cpp\n Mix_Music* music = Mix_LoadMUS(fileName.c_str()); \n```", "```cpp\n Mix_FreeMusic(music); \n```", "```cpp\n Mix_PlayMusic(music, 0); \n```", "```cpp\n Mix_HaltMusic(); \n```", "```cpp\n Mix_PauseMusic();\n  Mix_ResumeMusic(); \n```", "```cpp\n Mix_VolumeMusic(volume); \n```", "```cpp\n static AudioManager* mCurrentManager;\n    static void staticMusicFinshedCallback();\n    void musicFinishedCallback(); \n```", "```cpp\n mCurrentManager = this;\n  Mix_HookMusicFinished(staticMusicFinshedCallback); \n```", "```cpp\n if (mCurrentManager)  {\n    mCurrentManager->musicFinishedCallback();\n  } \n```", "```cpp\n if (mMusicPlaying) {\n    playNextTitle();\n  } \n```", "```cpp\n Mix_AllocateChannels(1); \n```", "```cpp\n Mix_Chunk* mWalkFootsteps;\n  mWalkFootsteps = Mix_LoadWAV(fileName.c_str()); \n```", "```cpp\nMix_FreeChunk(mWalkFootsteps); \n```", "```cpp\n mSoundChannel = Mix_PlayChannel(-1, mRunFootsteps, 0); \n```", "```cpp\n Mix_HaltChannel(mSoundChannel); \n```", "```cpp\n Mix_Volume(mSoundChannel, volume); \n```", "```cpp\n if (currentInstance->getAnimState() ==\n    animationState::playIdleWalkRun) { \n```", "```cpp\n switch (state) {\n    case moveState::run:\n      mModelInstCamData.\n        micPlayRunFootstepCallbackFunction();\n      break;\n    case moveState::walk:\n      mModelInstCamData.\n        micPlayWalkFootstepCallbackFunction();\n      break; \n```", "```cpp\n default:\n      mModelInstCamData.\n        micStopFootstepCallbackFunction();\n      break;\n    } \n```", "```cpp\n } else {\n    mModelInstCamData.\n      micStopFootstepCallbackFunction();\n  } \n```", "```cpp\nstruct OGLSkyboxVertex {\n  glm::vec4 position = glm::vec4(0.0f);\n};\n struct OGLSkyboxMesh {\n  std::vector<OGLSkyboxVertex> vertices{};\n}; \n```", "```cpp\n glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE,\n    sizeof(OGLSkyboxVertex),\n   (void*) offsetof(OGLSkyboxVertex, position));\n  glEnableVertexAttribArray(0); \n```", "```cpp\nlayout (location = 0) out vec3 texCoord; \n```", "```cpp\n mat4 inverseProjection = inverse(projection);\n  mat3 inverseView = transpose(mat3(view)); \n```", "```cpp\n texCoord = inverseView * (inverseProjection * aPos).xyz; \n```", "```cpp\n gl_Position = aPos.xyww; \n```", "```cpp\nlayout (location = 0) in vec3 texCoord;\nlayout (location = 0) out vec4 FragColor;\nuniform samplerCube tex;\nvoid main() {\n  FragColor = texture(tex, texCoord);\n} \n```", "```cpp\n glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, GL_SRGB8_ALPHA8, cubeFaceWidth, cubeFaceHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, subImage.data()); \n```", "```cpp\n mSkyboxModel.init();\n  OGLSkyboxMesh skyboxMesh = mSkyboxModel.getVertexData();\n  mSkyboxBuffer.uploadData(skyboxMesh.vertices); \n```", "```cpp\n mSkyboxShader.use();\n  mSkyboxTexture.bindCubemap();\n  mSkyboxBuffer.bindAndDraw();\n  mSkyboxTexture.unbindCubemap(); \n```", "```cpp\nlayout (std140, binding = 0) uniform Matrices {\n  ...\n**vec4** **lightPos;**\n**vec4** **lightColor;**\n}; \n```", "```cpp\n glm::mat4 lightMatrix = glm::mat4(lightPos, lightColor,\n    glm::vec4(), glm::vec4());\n  matrixData.emplace_back(lightMatrix); \n```", "```cpp\n float ambientStrength = 0.1;\n  vec3 ambient = ambientStrength * max(vec3(lightColor),\n    vec3(0.05, 0.05, 0.05)); \n```", "```cpp\n vec3 norm = normalize(vec3(normal));\n  vec3 lightDir = normalize(vec3(lightPos));\n  float diff = max(dot(norm, lightDir), 0.0);\n  vec3 diffuse = diff * vec3(lightColor); \n```", "```cpp\n FragColor = vec4(min(ambient + diffuse, vec3(1.0)), 1.0)*\n    texture(tex, texCoord) * color; \n```"]