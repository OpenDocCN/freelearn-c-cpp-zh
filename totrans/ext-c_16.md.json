["```cpp\n#include <stdio.h>\n#include <stdlib.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\n// The mutex object used to synchronize the access to\n// the shared state.\npthread_mutex_t mtx;\nvoid* thread_body_1(void* arg) {\n  // Obtain a pointer to the shared variable\n  int* shared_var_ptr = (int*)arg;\n  // Critical section\n  pthread_mutex_lock(&mtx);\n  (*shared_var_ptr)++;\n  printf(\"%d\\n\", *shared_var_ptr);\n  pthread_mutex_unlock(&mtx);\n  return NULL;\n}\nvoid* thread_body_2(void* arg) {\n  int* shared_var_ptr = (int*)arg;\n  // Critical section\n  pthread_mutex_lock(&mtx);\n  *shared_var_ptr += 2;\n  printf(\"%d\\n\", *shared_var_ptr);\n  pthread_mutex_unlock(&mtx);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The shared variable\n  int shared_var = 0;\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n  // Initialize the mutex and its underlying resources\n  pthread_mutex_init(&mtx, NULL);\n  // Create new threads\n  int result1 = pthread_create(&thread1, NULL,\n          thread_body_1, &shared_var);\n  int result2 = pthread_create(&thread2, NULL,\n          thread_body_2, &shared_var);\n  if (result1 || result2) {\n    printf(\"The threads could not be created.\\n\");\n    exit(1);\n  }\n  // Wait for the threads to finish\n  result1 = pthread_join(thread1, NULL);\n  result2 = pthread_join(thread2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be joined.\\n\");\n    exit(2);\n  }\n  pthread_mutex_destroy(&mtx);\n  return 0;\n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\n#define TRUE  1\n#define FALSE 0\ntypedef unsigned int bool_t;\n// A structure for keeping all the variables related\n// to a shared state\ntypedef struct {\n  // The flag which indicates whether 'A' has been printed or not\n  bool_t          done;\n  // The mutex object protecting the critical sections\n  pthread_mutex_t mtx;\n  // The condition variable used to synchronize two threads\n  pthread_cond_t  cv;\n} shared_state_t;\n// Initializes the members of a shared_state_t object\nvoid shared_state_init(shared_state_t *shared_state) {\n  shared_state->done = FALSE;\n  pthread_mutex_init(&shared_state->mtx, NULL);\n  pthread_cond_init(&shared_state->cv, NULL);\n}\n// Destroy the members of a shared_state_t object\nvoid shared_state_destroy(shared_state_t *shared_state) {\n  pthread_mutex_destroy(&shared_state->mtx);\n  pthread_cond_destroy(&shared_state->cv);\n}\nvoid* thread_body_1(void* arg) {\n  shared_state_t* ss = (shared_state_t*)arg;\n  pthread_mutex_lock(&ss->mtx);\n  printf(\"A\\n\");\n  ss->done = TRUE;\n  // Signal the threads waiting on the condition variable\n  pthread_cond_signal(&ss->cv);\n  pthread_mutex_unlock(&ss->mtx);\n  return NULL;\n}\nvoid* thread_body_2(void* arg) {\n  shared_state_t* ss = (shared_state_t*)arg;\n  pthread_mutex_lock(&ss->mtx);\n  // Wait until the flag becomes TRUE\n  while (!ss->done) {\n    // Wait on the condition variable\n    pthread_cond_wait(&ss->cv, &ss->mtx);\n  }\n  printf(\"B\\n\");\n  pthread_mutex_unlock(&ss->mtx);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The shared state\n  shared_state_t shared_state;\n  // Initialize the shared state\n  shared_state_init(&shared_state);\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n  // Create new threads\n  int result1 =\n    pthread_create(&thread1, NULL, thread_body_1, &shared_state);\n  int result2 =\n    pthread_create(&thread2, NULL, thread_body_2, &shared_state);\n  if (result1 || result2) {\n    printf(\"The threads could not be created.\\n\");\n    exit(1);\n  }\n  // Wait for the threads to finish\n  result1 = pthread_join(thread1, NULL);\n  result2 = pthread_join(thread2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be joined.\\n\");\n    exit(2);\n  }\n  // Destroy the shared state and release the mutex\n  // and condition variable objects\n  shared_state_destroy(&shared_state);\n  return 0;\n}\n```", "```cpp\ntypedef struct {\n  bool_t          done;\n  pthread_mutex_t mtx;\n  pthread_cond_t  cv;\n} shared_state_t;\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n// The barrier object\npthread_barrier_t barrier;\nvoid* thread_body_1(void* arg) {\n  printf(\"A\\n\");\n  // Wait for the other thread to join\n  pthread_barrier_wait(&barrier);\n  return NULL;\n}\nvoid* thread_body_2(void* arg) {\n  // Wait for the other thread to join\n  pthread_barrier_wait(&barrier);\n  printf(\"B\\n\");\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // Initialize the barrier object\n  pthread_barrier_init(&barrier, NULL, 2);\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n  // Create new threads\n  int result1 = pthread_create(&thread1, NULL,\n          thread_body_1, NULL);\n  int result2 = pthread_create(&thread2, NULL,\n          thread_body_2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be created.\\n\");\n    exit(1);\n  }\n  // Wait for the threads to finish\n  result1 = pthread_join(thread1, NULL);\n  result2 = pthread_join(thread2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be joined.\\n\");\n    exit(2);\n  }\n  // Destroy the barrier object\n  pthread_barrier_destroy(&barrier);\n  return 0;\n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\n// The semaphores are not exposed through pthread.h\n#include <semaphore.h>\n// The main pointer addressing a semaphore object used\n// to synchronize the access to the shared state.\nsem_t *semaphore;\nvoid* thread_body_1(void* arg) {\n  // Obtain a pointer to the shared variable\n  int* shared_var_ptr = (int*)arg;\n  // Waiting for the semaphore\n  sem_wait(semaphore);\n  // Increment the shared variable by 1 by writing directly\n  // to its memory address\n  (*shared_var_ptr)++;\n  printf(\"%d\\n\", *shared_var_ptr);\n  // Release the semaphore\n  sem_post(semaphore);\n  return NULL;\n}\nvoid* thread_body_2(void* arg) {\n  // Obtain a pointer to the shared variable\n  int* shared_var_ptr = (int*)arg;\n  // Waiting for the semaphore\n  sem_wait(semaphore);\n  // Increment the shared variable by 1 by writing directly\n  // to its memory address\n  (*shared_var_ptr) += 2;\n  printf(\"%d\\n\", *shared_var_ptr);\n  // Release the semaphore\n  sem_post(semaphore);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The shared variable\n  int shared_var = 0;\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n#ifdef __APPLE__\n  // Unnamed semaphores are not supported in OS/X. Therefore\n  // we need to initialize the semaphore like a named one using\n  // sem_open function.\n  semaphore = sem_open(\"sem0\", O_CREAT | O_EXCL, 0644, 1);\n#else\n  sem_t local_semaphore;\n  semaphore = &local_semaphore;\n  // Initiliaze the semaphore as a mutex (binary semaphore)\n  sem_init(semaphore, 0, 1);\n#endif\n  // Create new threads\n  int result1 = pthread_create(&thread1, NULL,\n          thread_body_1, &shared_var);\n  int result2 = pthread_create(&thread2, NULL,\n          thread_body_2, &shared_var);\n  if (result1 || result2) {\n    printf(\"The threads could not be created.\\n\");\n    exit(1);\n  }\n  // Wait for the threads to finish\n  result1 = pthread_join(thread1, NULL);\n  result2 = pthread_join(thread2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be joined.\\n\");\n    exit(2);\n  }\n#ifdef __APPLE__\n  sem_close(semaphore);\n#else\n  sem_destroy(semaphore);\n#endif\n  return 0;\n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h> // For errno and strerror function\n// The POSIX standard header for using pthread library\n#include <pthread.h>\n// Semaphores are not exposed through pthread.h\n#include <semaphore.h>\n#ifdef __APPLE__\n// In Apple systems, we have to simulate the barrier functionality.\npthread_mutex_t barrier_mutex;\npthread_cond_t  barrier_cv;\nunsigned int    barrier_thread_count;\nunsigned int    barrier_round;\nunsigned int    barrier_thread_limit;\nvoid barrier_wait() {\n  pthread_mutex_lock(&barrier_mutex);\n  barrier_thread_count++;\n  if (barrier_thread_count >= barrier_thread_limit) {\n    barrier_thread_count = 0;\n    barrier_round++;\n    pthread_cond_broadcast(&barrier_cv);\n  } else {\n    unsigned int my_round = barrier_round;\n    do {\n      pthread_cond_wait(&barrier_cv, &barrier_mutex);\n    } while (my_round == barrier_round);\n  }\n  pthread_mutex_unlock(&barrier_mutex);\n}\n#else\n// A barrier to make hydrogen and oxygen threads synchronized\npthread_barrier_t water_barrier;\n#endif\n// A mutex in order to synchronize oxygen threads\npthread_mutex_t   oxygen_mutex;\n// A general semaphore to make hydrogen threads synchronized\nsem_t*            hydrogen_sem;\n// A shared integer counting the number of made water molecules\nunsigned int      num_of_water_molecules;\nvoid* hydrogen_thread_body(void* arg) {\n  // Two hydrogen threads can enter this critical section\n  sem_wait(hydrogen_sem);\n  // Wait for the other hydrogen thread to join\n#ifdef __APPLE__\n  barrier_wait();\n#else\n  pthread_barrier_wait(&water_barrier);\n#endif\n  sem_post(hydrogen_sem);\n  return NULL;\n}\nvoid* oxygen_thread_body(void* arg) {\n  pthread_mutex_lock(&oxygen_mutex);\n  // Wait for the hydrogen threads to join\n#ifdef __APPLE__\n  barrier_wait();\n#else\n  pthread_barrier_wait(&water_barrier);\n#endif\n  num_of_water_molecules++;\n  pthread_mutex_unlock(&oxygen_mutex);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  num_of_water_molecules = 0;\n  // Initialize oxygen mutex\n  pthread_mutex_init(&oxygen_mutex, NULL);\n  // Initialize hydrogen semaphore\n#ifdef __APPLE__\n  hydrogen_sem = sem_open(\"hydrogen_sem\",\n          O_CREAT | O_EXCL, 0644, 2);\n#else\n  sem_t local_sem;\n  hydrogen_sem = &local_sem;\n  sem_init(hydrogen_sem, 0, 2);\n#endif\n  // Initialize water barrier\n#ifdef __APPLE__\n  pthread_mutex_init(&barrier_mutex, NULL);\n  pthread_cond_init(&barrier_cv, NULL);\n  barrier_thread_count = 0;\n  barrier_thread_limit = 0;\n  barrier_round = 0;\n#else\n  pthread_barrier_init(&water_barrier, NULL, 3);\n#endif\n  // For creating 50 water molecules, we need 50 oxygen atoms and\n  // 100 hydrogen atoms\n  pthread_t thread[150];\n  // Create oxygen threads\n  for (int i = 0; i < 50; i++) {\n    if (pthread_create(thread + i, NULL,\n                oxygen_thread_body, NULL)) {\n      printf(\"Couldn't create an oxygen thread.\\n\");\n      exit(1);\n    }\n  }\n  // Create hydrogen threads\n  for (int i = 50; i < 150; i++) {\n    if (pthread_create(thread + i, NULL,\n                hydrogen_thread_body, NULL)) {\n      printf(\"Couldn't create an hydrogen thread.\\n\");\n      exit(2);\n    }\n  }\n  printf(\"Waiting for hydrogen and oxygen atoms to react ...\\n\");\n  // Wait for all threads to finish\n  for (int i = 0; i < 150; i++) {\n    if (pthread_join(thread[i], NULL)) {\n      printf(\"The thread could not be joined.\\n\");\n      exit(3);\n    }\n  }\n  printf(\"Number of made water molecules: %d\\n\",\n          num_of_water_molecules);\n#ifdef __APPLE__\n  sem_close(hydrogen_sem);\n#else\n  sem_destroy(hydrogen_sem);\n#endif\n  return 0;\n}\n```", "```cpp\n$ ulimit -s\n8192\n$\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <pthread.h>\nvoid* thread_body_1(void* arg) {\n  int local_var = 0;\n  printf(\"Thread1 > Stack Address: %p\\n\", (void*)&local_var);\n  return 0;\n}\nvoid* thread_body_2(void* arg) {\n  int local_var = 0;\n  printf(\"Thread2 > Stack Address: %p\\n\", (void*)&local_var);\n  return 0;\n}\nint main(int argc, char** argv) {\n  size_t buffer_len = PTHREAD_STACK_MIN + 100;\n  // The buffer allocated from heap to be used as\n  // the thread's stack region\n  char *buffer = (char*)malloc(buffer_len * sizeof(char));\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n  // Create a new thread with default attributes\n  int result1 = pthread_create(&thread1, NULL,\n          thread_body_1, NULL);\n  // Create a new thread with a custom stack region\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  // Set the stack address and size\n  if (pthread_attr_setstack(&attr, buffer, buffer_len)) {\n    printf(\"Failed while setting the stack attributes.\\n\");\n    exit(1);\n  }\n  int result2 = pthread_create(&thread2, &attr,\n          thread_body_2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be created.\\n\");\n    exit(2);\n  }\n  printf(\"Main Thread > Heap Address: %p\\n\", (void*)buffer);\n  printf(\"Main Thread > Stack Address: %p\\n\", (void*)&buffer_len);\n  // Wait for the threads to finish\n  result1 = pthread_join(thread1, NULL);\n  result2 = pthread_join(thread2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be joined.\\n\");\n    exit(3);\n  }\n  free(buffer);\n  return 0;\n}\n```", "```cpp\n$ gcc ExtremeC_examples_chapter16_3.c -o ex16_3.out -lpthread\n$ ./ex16_3.out\nMain Thread > Heap Address: 0x55a86a251260\nMain Thread > Stack Address: 0x7ffcb5794d50\nThread2 > Stack Address: 0x55a86a2541a4\nThread1 > Stack Address: 0x7fa3e9216ee4\n$\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\nint* shared_int;\nvoid* t1_body(void* arg) {\n  int local_var = 100;\n  shared_int = &local_var;\n  // Wait for the other thread to print the shared integer\n  usleep(10);\n  return NULL;\n}\nvoid* t2_body(void* arg) {\n  printf(\"%d\\n\", *shared_int);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  shared_int = NULL;\n  pthread_t t1;\n  pthread_t t2;\n  pthread_create(&t1, NULL, t1_body, NULL);\n  pthread_create(&t2, NULL, t2_body, NULL);\n  pthread_join(t1, NULL);\n  pthread_join(t2, NULL);\n  return 0;\n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#define CHECK_RESULT(result) \\\nif (result) { \\\n  printf(\"A pthread error happened.\\n\"); \\\n  exit(1); \\\n}\nint TRUE = 1;\nint FALSE = 0;\n// The pointer to the shared array\nchar* shared_array;\n// The size of the shared array\nunsigned int shared_array_len;\nvoid* alloc_thread_body(void* arg) {\n  shared_array_len = 20;\n  shared_array = (char*)malloc(shared_array_len * sizeof(char*));\n  return NULL;\n}\nvoid* filler_thread_body(void* arg) {\n  int even = *((int*)arg);\n  char c = 'a';\n  size_t start_index = 1;\n  if (even) {\n    c = 'Z';\n    start_index = 0;\n  }\n  for (size_t i = start_index; i < shared_array_len; i += 2) {\n    shared_array[i] = even ? c-- : c++;\n  }\n  shared_array[shared_array_len - 1] = '\\0';\n  return NULL;\n}\nvoid* printer_thread_body(void* arg) {\n  printf(\">> %s\\n\", shared_array);\n  return NULL;\n}\nvoid* dealloc_thread_body(void* arg) {\n  free(shared_array);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  â€¦ Create threads ...\n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#define CHECK_RESULT(result) \\\nif (result) { \\\n  printf(\"A pthread error happened.\\n\"); \\\n  exit(1); \\\n}\nint TRUE = 1;\nint FALSE = 0;\n// The pointer to the shared array\nchar* shared_array;\n// The size of the shared array\nsize_t shared_array_len;\npthread_barrier_t alloc_barrier;\npthread_barrier_t fill_barrier;\npthread_barrier_t done_barrier;\nvoid* alloc_thread_body(void* arg) {\n  shared_array_len = 20;\n  shared_array = (char*)malloc(shared_array_len * sizeof(char*));\n  pthread_barrier_wait(&alloc_barrier);\n  return NULL;\n}\nvoid* filler_thread_body(void* arg) {\n  pthread_barrier_wait(&alloc_barrier);\n  int even = *((int*)arg);\n  char c = 'a';\n  size_t start_index = 1;\n  if (even) {\n    c = 'Z';\n    start_index = 0;\n  }\n  for (size_t i = start_index; i < shared_array_len; i += 2) {\n    shared_array[i] = even ? c-- : c++;\n  }\n  shared_array[shared_array_len - 1] = '\\0';\n  pthread_barrier_wait(&fill_barrier);\n  return NULL;\n}\nvoid* printer_thread_body(void* arg) {\n  pthread_barrier_wait(&fill_barrier);\n  printf(\">> %s\\n\", shared_array);\n  pthread_barrier_wait(&done_barrier);\n  return NULL;\n}\nvoid* dealloc_thread_body(void* arg) {\n  pthread_barrier_wait(&done_barrier);\n  free(shared_array);\n  pthread_barrier_destroy(&alloc_barrier);\n  pthread_barrier_destroy(&fill_barrier);\n  pthread_barrier_destroy(&done_barrier);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  shared_array = NULL;\n  pthread_barrier_init(&alloc_barrier, NULL, 3);\n  pthread_barrier_init(&fill_barrier, NULL, 3);\n  pthread_barrier_init(&done_barrier, NULL, 2);\n  pthread_t alloc_thread;\n  pthread_t even_filler_thread;\n  pthread_t odd_filler_thread;\n  pthread_t printer_thread;\n  pthread_t dealloc_thread;\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  int res = pthread_attr_setdetachstate(&attr,\n          PTHREAD_CREATE_DETACHED);\n  CHECK_RESULT(res);\n  res = pthread_create(&alloc_thread, &attr,\n          alloc_thread_body, NULL);\n  CHECK_RESULT(res);\n  res = pthread_create(&even_filler_thread,\n          &attr, filler_thread_body, &TRUE);\n  CHECK_RESULT(res);\n  res = pthread_create(&odd_filler_thread,\n          &attr, filler_thread_body, &FALSE);\n  CHECK_RESULT(res);\n  res = pthread_create(&printer_thread, &attr,\n          printer_thread_body, NULL);\n  CHECK_RESULT(res);\n  res = pthread_create(&dealloc_thread, &attr,\n          dealloc_thread_body, NULL);\n  CHECK_RESULT(res);\n  pthread_exit(NULL);\n  return 0;\n}\n```", "```cpp\n$ gcc ExtremeC_examples_chapter16_5.c -o ex16_5 -lpthread\n$ ./ex16_5\n>> ZaYbXcWdVeUfTgShRiQ\n$ ./ex16_5\n>> ZaYbXcWdVeUfTgShRiQ\n$\n```", "```cpp\nvolatile int number;\n```"]