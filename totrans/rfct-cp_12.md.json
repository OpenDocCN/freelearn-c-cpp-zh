["```cpp\ngit submodule add https://github.com/google/googletest.git external/googletest\n```", "```cpp\n# Minimum version of CMake\ncmake_minimum_required(VERSION 3.14)\nproject(MyProject)\n# GoogleTest requires at least C++14\nset(CMAKE_CXX_STANDARD 14)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n# Enable testing capabilities\nenable_testing()\n# Add GoogleTest to the project\nadd_subdirectory(external/googletest)\n# Include GoogleTest and GoogleMock headers\ninclude_directories(${gtest_SOURCE_DIR}/include ${gmock_SOURCE_DIR}/include)\n# Define your test executable\nadd_executable(my_tests test1.cpp test2.cpp)\n# Link GoogleTest and GoogleMock to your test executable\ntarget_link_libraries(my_tests gtest gtest_main gmock gmock_main)\n```", "```cpp\ncmake_minimum_required(VERSION 3.14)\nproject(MyProject)\n# GoogleTest requires at least C++14\nset(CMAKE_CXX_STANDARD 14)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\ninclude(FetchContent)\nFetchContent_Declare(\n  googletest\n  URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip\n)\n# For Windows: Prevent overriding the parent project’s compiler/linker settings\nset(gtest_force_shared_crt ON CACHE BOOL “” FORCE)\nFetchContent_MakeAvailable(googletest)\n```", "```cpp\n#include <gtest/gtest.h>\nint add(int a, int b) {\n    return a + b;\n}\nTEST(AdditionTest, HandlesPositiveNumbers) {\n    EXPECT_EQ(5, add(2, 3));\n}\n```", "```cpp\nclass CalculatorTest : public ::testing::Test {\nprotected:\n    void SetUp() override {\n        // Code here will be called immediately before each test\n        calculator.reset(new Calculator());\n    }\n    void TearDown() override {\n        // Code here will be called immediately after each test\n        calculator.reset();\n    }\n    std::unique_ptr<Calculator> calculator;\n};\nTEST_F(CalculatorTest, CanAddPositiveNumbers) {\n    EXPECT_EQ(5, calculator->add(2, 3));\n}\nTEST_F(CalculatorTest, CanAddNegativeNumbers) {\n    EXPECT_EQ(-5, calculator->add(-2, -3));\n}\n```", "```cpp\n#include <gtest/gtest.h>\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n$ cd path/to/build\n[==========] Running 4 tests from 2 test suites.\n[----------] Global test environment set-up.\n[----------] 2 tests from AdditionTests\n[ RUN      ] AdditionTests.HandlesZeroInput\n[       OK ] AdditionTests.HandlesZeroInput (0 ms)\n[ RUN      ] AdditionTests.HandlesPositiveInput\n[       OK ] AdditionTests.HandlesPositiveInput (0 ms)\n[----------] 2 tests from AdditionTests (0 ms total)\n[----------] 2 tests from SubtractionTests\n[ RUN      ] SubtractionTests.HandlesZeroInput\n[       OK ] SubtractionTests.HandlesZeroInput (0 ms)\n[ RUN      ] SubtractionTests.HandlesPositiveInput\n[       OK ] SubtractionTests.HandlesPositiveInput (0 ms)\n[----------] 2 tests from SubtractionTests (0 ms total)\n[----------] Global test environment tear-down\n[==========] 4 tests from 2 test suites ran. (1 ms total)\n[  PASSED  ] 4 tests.\n```", "```cpp\n$ ctest\nTest project /path/to/build\n    Start 1: AdditionTests.HandlesZeroInput\n1/4 Test #1: AdditionTests.HandlesZeroInput ......   Passed    0.01 sec\n    Start 2: AdditionTests.HandlesPositiveInput\n2/4 Test #2: AdditionTests.HandlesPositiveInput ...   Passed    0.01 sec\n    Start 3: SubtractionTests.HandlesZeroInput\n3/4 Test #3: SubtractionTests.HandlesZeroInput .....   Passed    0.01 sec\n    Start 4: SubtractionTests.HandlesPositiveInput\n4/4 Test #4: SubtractionTests.HandlesPositiveInput ..   Passed    0.01 sec\n100% tests passed, 0 tests failed out of 4\n```", "```cpp\nvoid risky_function(bool trigger) {\n    if (trigger) {\n        assert(false && “Triggered a fatal error”);\n    }\n}\nTEST(RiskyFunctionTest, TriggersAssertOnCondition) {\n    EXPECT_DEATH_IF_SUPPORTED(risky_function(true), “Triggered a fatal error”);\n}\n```", "```cpp\nclass Socket {\npublic:\n    // sends raw byte array of given size, returns number of bytes sent\n    // or -1 in case of error\n    virtual ssize_t send(void* data, size_t size) = 0;\n    // receives raw byte array of given size, returns number of bytes received\n    // or -1 in case of error\n    virtual ssize_t recv(void* data, size_t size) = 0;\n};\n```", "```cpp\nstruct DataSentParitally {};\nstruct ConnectionClosedByPeer {};\nstruct ConnectionError {};\n// Class under test\nclass DataSender {\n    static constexpr size_t RETRY_NUM = 2;\npublic:\n    DataSender(Socket* socket) : _socket{socket} {}\n    void send() {\n        auto data = std::array<int, 32>{};\n        auto bytesSent = 0;\n        for (size_t i = 0; i < RETRY_NUM && bytesSent != sizeof(data); ++i) {\n            bytesSent = _socket->send(&data, sizeof(data));\n            if (bytesSent < 0) {\n                throw ConnectionError{};\n            }\n            if (bytesSent == 0) {\n                throw ConnectionClosedByPeer{};\n            }\n        }\n        if (bytesSent != sizeof(data)) {\n            throw DataSentParitally{};\n        }\n    }\nprivate:\n    Socket* _socket;\n};\n```", "```cpp\nclass MockSocket : public Socket {\npublic:\n    MOCK_METHOD(ssize_t, send, (void* data, size_t size), (override));\n    MOCK_METHOD(ssize_t, recv, (void* data, size_t size), (override));\n};\n```", "```cpp\nTEST(DataSender, HappyPath) {\n    auto socket = MockSocket{};\n    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));\n    auto sender = DataSender(&socket);\n    sender.send();\n}\n```", "```cpp\nTEST(DataSender, SendSuccessfullyOnSecondAttempt) {\n    auto socket = MockSocket{};\n    EXPECT_CALL(socket, send(_, _)).Times(2)\n                                   .WillOnce(Return(2 * sizeof(int)))\n                                   .WillOnce(Return(32 * sizeof(int)));\n    auto sender = DataSender(&socket);\n    sender.send();\n}\n```", "```cpp\n TEST(DataSender, DataSentParitally) {\n     auto socket = MockSocket{};\n     EXPECT_CALL(socket, send(_, _)).Times(2)\n                                    .WillRepeatedly(Return(2 * sizeof(int)));\n     auto sender = DataSender(&socket);\n     EXPECT_THROW(sender.send(), DataSentParitally);\n }\n TEST(DataSender, ConnectionClosedByPeer) {\n     auto socket = MockSocket{};\n     EXPECT_CALL(socket, send(_, _)).Times(1)\n                                    .WillRepeatedly(Return(0 * sizeof(int)));\n     auto sender = DataSender(&socket);\n     EXPECT_THROW(sender.send(), ConnectionClosedByPeer);\n }\n TEST(DataSender, ConnectionError) {\n     auto socket = MockSocket{};\n     EXPECT_CALL(socket, send(_, _)).Times(1)\n                                    .WillRepeatedly(Return(-1 * sizeof(int)));\n     auto sender = DataSender(&socket);\n     EXPECT_THROW(sender.send(), ConnectionError);\n }\n```", "```cpp\n[==========] Running 5 tests from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 5 tests from DataSender\n[ RUN      ] DataSender.HappyPath\n[       OK ] DataSender.HappyPath (0 ms)\n[ RUN      ] DataSender.SendSuccessfullyOnSecondAttempt\n[       OK ] DataSender.SendSuccessfullyOnSecondAttempt (0 ms)\n[ RUN      ] DataSender.DataSentPartially\n[       OK ] DataSender.DataSentPartially (1 ms)\n[ RUN      ] DataSender.ConnectionClosedByPeer\n[       OK ] DataSender.ConnectionClosedByPeer (0 ms)\n[ RUN      ] DataSender.ConnectionError\n[       OK ] DataSender.ConnectionError (0 ms)\n[----------] 5 tests from DataSender (1 ms total)\n[----------] Global test environment tear-down\n[==========] 5 tests from 1 test suite ran. (1 ms total)\n[  PASSED  ] 5 tests.\n```", "```cpp\nclass Socket {\npublic:\n    // sends raw byte array of given size, returns number of bytes sent\n    // or -1 in case of error\n    ssize_t send(void* data, size_t size);\n    // receives raw byte array of given size, returns number of bytes received\n    // or -1 in case of error\n    ssize_t recv(void* data, size_t size);\n};\n```", "```cpp\ntemplate<typename SocketType>\nclass DataSender {\n    static constexpr size_t RETRY_NUM = 2;\npublic:\n    DataSender(SocketType* socket) : _socket{socket} {}\n    void send() {\n        auto data = std::array<int, 32>{};\n        auto bytesSent = 0;\n        for (size_t i = 0; i < RETRY_NUM && bytesSent != sizeof(data); ++i) {\n            bytesSent = _socket->send(&data, sizeof(data));\n            if (bytesSent < 0) {\n                throw ConnectionError{};\n            }\n            if (bytesSent == 0) {\n                throw ConnectionClosedByPeer{};\n            }\n        }\n        if (bytesSent != sizeof(data)) {\n            throw DataSentPartially{};\n        }\n    }\nprivate:\n    SocketType* _socket;\n};\n```", "```cpp\nclass MockSocket {\npublic:\n    MOCK_METHOD(ssize_t, send, (void* data, size_t size), ());\n    MOCK_METHOD(ssize_t, recv, (void* data, size_t size), ());\n};\n```", "```cpp\nTEST(DataSender, HappyPath) {\n    MockSocket socket;\n    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));\n    DataSender<MockSocket> sender(&socket);\n    sender.send();\n}\n```", "```cpp\nclass Database {\npublic:\n    std::vector<std::string> query(uint32_t id) const {\n        return {};\n    }\n    static Database& getInstance() {\n        static Database db;\n        return db;\n    }\nprivate:\n    Database() = default;\n};\n```", "```cpp\nclass DataHandler {\npublic:\n    DataHandler() {}\n    void doSomething() {\n        auto& db = Database::getInstance();\n        auto result = db.query(42);\n    }\n};\n```", "```cpp\ntemplate<typename Db>\nclass DataHandler1 {\npublic:\n    DataHandler1() {}\n    std::vector<std::string> doSomething() {\n        auto& db = Db::getInstance();\n        auto result = db.query(42);\n        return result;\n    }\n};\n```", "```cpp\nclass MockDatabase {\npublic:\n    std::vector<std::string> query(uint32_t id) const {\n        return {“AAA”};\n    }\n    static MockDatabase& getInstance() {\n        static MockDatabase db;\n        return db;\n    }\n};\n```", "```cpp\nTEST(DataHandler, check) {\n    auto dh = DataHandler1<MockDatabase>{};\n    EXPECT_EQ(dh.doSomething(), std::vector<std::string>{“AAA”});\n}\n```", "```cpp\nTEST(DataSender, Naggy) {\n    auto socket = MockSocket{};\n    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));\n    auto sender = DataSender(&socket);\n    sender.send();\n}\n```", "```cpp\nTEST(DataSender, Nice) {\n    auto socket = NiceMock<MockSocket>{};\n    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));\n    auto sender = DataSender(&socket);\n    sender.send();\n}\n```", "```cpp\nTEST(DataSender, Strict) {\n    auto socket = StrictMock<MockSocket>{};\n    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));\n    auto sender = DataSender(&socket);\n    sender.send();\n}\n```", "```cpp\nProgram returned: 1\nProgram stdout\n[==========] Running 3 tests from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 3 tests from DataSender\n[ RUN      ] DataSender.Naggy\nGMOCK WARNING:\nUninteresting mock function call - returning default value.\n    Function call: recv(0x7ffd4aae23f0, 128)\n          Returns: 0\nNOTE: You can safely ignore the above warning unless this call should not happen.  Do not suppress it by blindly adding an EXPECT_CALL() if you don’t mean to enforce the call.  See https://github.com/google/googletest/blob/master/googlemock/docs/cook_book.md#knowing-when-to-expect for details.\n[       OK ] DataSender.Naggy (0 ms)\n[ RUN      ] DataSender.Nice\n[       OK ] DataSender.Nice (0 ms)\n[ RUN      ] DataSender.Strict\nunknown file: Failure\nUninteresting mock function call - returning default value.\n    Function call: recv(0x7ffd4aae23f0, 128)\n          Returns: 0\n[  FAILED  ] DataSender.Strict (0 ms)\n[----------] 3 tests from DataSender (0 ms total)\n[----------] Global test environment tear-down\n[==========] 3 tests from 1 test suite ran. (0 ms total)\n[  PASSED  ] 2 tests.\n[  FAILED  ] 1 test, listed below:\n[  FAILED  ] DataSender.Strict\n 1 FAILED TEST\n```", "```cpp\ng++ -fprofile-arcs -ftest-coverage file1.cpp file2.cpp -o testExecutable\n```", "```cpp\nFile ‘example.cpp’\nLines executed:90.00% of 100\nBranches executed:85.00% of 40\nFunctions executed:95.00% of 20\n```", "```cpp\n-:    0:Source:example.cpp\n-:    0:Graph:example.gcno\n-:    0:Data:example.gcda\n-:    0:Runs:3\n-:    0:Programs:1\n3:    1:int main() {\n-:    2:  // Some comment\n2:    3:  bool condition = checkCondition();\n1:    4:  if (condition) {\n1:    5:    performAction();\n    ...\n```", "```cpp\nexample.cpp:\nint main() {\n    |  3|  // Some comment\n    |  2|  bool condition = checkCondition();\n    |  1|  if (condition) {\n    |  1|    performAction();\n    ...\n```"]