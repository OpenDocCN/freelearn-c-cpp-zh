- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing IR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM uses a series of passes to optimize the IR. A pass operates on a unit of
    IR, such as a function or a module. The operation can be a transformation, which
    changes the IR in a defined way, or an analysis, which collects information such
    as dependencies. This series of passes is called the **pass pipeline**. The pass
    manager executes the pass pipeline on the IR, which our compiler produces. Therefore,
    you need to know what the pass manager does and how to construct a pass pipeline.
    The semantics of a programming language may require the development of new passes,
    and we must add these passes to the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to leverage the LLVM pass manager to implement passes within LLVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement an instrumentation pass, as an example, within the LLVM project,
    as well as a separate plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In using the ppprofiler pass with LLVM tools, you will learn how to use a pass
    plugin with `opt` and `clang`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In adding an optimization pipeline to your compiler, you will extend the `tinylang`
    compiler with an optimization pipeline based on the new pass manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to develop a new pass and how
    you can add it to a pass pipeline. You will also be able to set up the pass pipeline
    in your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: The LLVM pass manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LLVM core libraries optimize the IR that your compiler creates and turn
    it into object code. This giant task is broken down into separate steps called
    **passes**. These passes need to be executed in the right order, which is the
    objective of the pass manager.
  prefs: []
  type: TYPE_NORMAL
- en: Why not hard-code the order of the passes? The user of your compiler usually
    expects your compiler to provide a different level of optimization. Developers
    prefer fast compilation speed over optimization during development time. The final
    application should run as fast as possible, and your compiler should be able to
    perform sophisticated optimizations, with longer a compilation time being accepted.
    A different level of optimization means a different number of optimization passes
    that need to be executed. Thus, as a compiler writer, you may want to provide
    your own passes to take advantage of your knowledge of your source language. For
    example, you may want to replace well-known library functions with inlined IR
    or even with the precomputed result. For C, such a pass is part of the LLVM libraries,
    but for other languages, you will need to provide it yourself. After introducing
    your own passes, you may need to re-order or add some passes. For example, if
    you know that the operation of your pass leaves some IR code unreachable, then
    you want to run the dead code removal pass additionally after your pass. The pass
    manager helps organize these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pass is often categorized by the scope on which it works:'
  prefs: []
  type: TYPE_NORMAL
- en: A *module pass* takes a whole module as input. Such a pass performs its work
    on the given module and can be used for intra-procedure operations inside this
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *call graph* pass operates on the **strongly connected components** (**SCCs**)
    of a call graph. It traverses the components in bottom-up order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *function pass* takes a single function as input and performs its work on
    this function only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *loop pass* works on a loop inside a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the IR code, a pass may also require, update, or invalidate some analysis
    results. A lot of different analyses are performed, for example, alias analysis
    or the construction of a dominator tree. If a pass requires such analyses, then
    it can request it from an analyses manager. If the information is already computed,
    then the cached result will be returned. Otherwise, the information will be computed.
    If a pass changes the IR code, then it needs to announce which analysis results
    are preserved so that the cached analysis information can be invalidated if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, the pass manager ensures the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis results are shared among passes. This requires keeping track of which
    pass requires which analysis and the state of each analysis. The goal is to avoid
    needless precomputation of analysis and to free up memory held by analysis results
    as soon as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The passes are executed in a pipeline fashion. For example, if several function
    passes should be executed in sequence, then the pass manager runs each of these
    function passes on the first function. Then, it will run all function passes on
    the second function, and so on. The underlying idea here is to improve the cache
    behavior as the compiler only performs transformations on a limited set of data
    (one IR function) and then moves on to the next limited set of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s implement a new IR transformation pass and explore how to add it to the
    optimization pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a new pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pass can perform arbitrary complex transformations on the LLVM IR. To illustrate
    the mechanics of adding a new pass, we add a pass that performs a simple instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: To investigate the performance of a program, it is interesting to know how often
    functions are called, and how long they run. One way to collect this data is to
    insert counters into each function. This process is called `ppprofiler`. We will
    develop the new pass so that it can be used as a standalone plugin or added as
    a plugin to the LLVM source tree. After that, we’ll look at how the passes that
    come with LLVM are integrated into the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the ppprofiler pass as a plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll look at creating a new pass as a plugin out of the LLVM
    tree. The goal of the new pass is to insert a call to the `__ppp_enter()` function
    at the entry of a function, and a call to the `__ppp_exit()` function before each
    return instruction. Only the name of the current function is passed as a parameter.
    The implementation of these functions can then count the number of calls and measure
    the elapsed time. We will implement this runtime support at the end of this chapter.
    We’ll examine how to develop the pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll store the source in the `PPProfiler.cpp` file. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s include some files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To shorten the source, we’ll tell the compiler that we’re using the `llvm`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The built-in debug infrastructure of LLVM requires that we define a debug type,
    which is a string. This string is later shown in the printed statistic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll define one counter variable with the `ALWAYS_ENABLED_STATISTIC`
    macro. The first parameter is the name of the counter variable, while the second
    parameter is the text that will be printed in the statistic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Two macros can be used to define a counter variable. If you use the `STATISTIC`
    macro, then the statistic value will only be collected in a debug build if assertions
    are enabled, or if `LLVM_FORCE_ENABLE_STATS` is set to `ON` on the CMake command
    line. If you use the `ALWAYS_ENABLED_STATISTIC` macro instead, then the statistic
    value is always collected. However, printing the statistics using the`–stats`
    command-line option only works with the former methods. If needed, you can print
    the collected statistics by calling the `llvm::PrintStatistics(llvm::raw_ostream)`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must declare the pass class in an anonymous namespace. The class inherits
    from the `PassInfoMixin` template. This template only adds some boilerplate code,
    such as a `name()` method. It is not used to determine the type of the pass. The
    `run()` method is called by LLVM when the pass is executed. We also need a helper
    method called `instrument()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define how a function is instrumented. Besides the function to instrument,
    the functions to call are passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the function, we update the statistic counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To easily insert IR code, we need an instance of the `IRBuilder` class. We
    will set it to the first basic block, which is the entry block of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the builder, we can insert a global constant that holds the
    name of the function we wish to instrument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will insert a call to the `__ppp_enter()` function, passing the name
    as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To call the `__ppp_exit()` function, we have to locate all return instructions.
    Conveniently, the insertion point that’s set by the calling `SetInsertionPoint()`
    function is before the instruction that’s passed as a parameter, so we can just
    insert the call at that point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will implement the `run()` method. LLVM passes in the module our pass
    works on and an analysis manager from which we can request analysis results if
    needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is a slight annoyance here: if the runtime module that contains the implementation
    of the `__ppp_enter()` and `__ppp_exit()` functions are instrumented, then we
    run into trouble because we create an infinite recursion. To avoid this, we must
    simply do nothing if one of those functions is defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are ready to declare the functions. There is nothing unusual here:
    first, the function type is created, followed by the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All we need to do now is loop over all the functions of the module and instrument
    the found functions by calling our `instrument()` method. Of course, we need to
    ignore function declarations, which are just prototypes. There can also be functions
    without a name, which does not work well with our approach. We’ll filter out those
    functions too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we must declare that we did not preserve any analysis. This is most
    likely too pessimistic but we are on the safe side by doing so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The functionality of our new pass is now implemented. To be able to use our
    pass, we need to register it with the `PassBuilder` object. This can happen in
    two ways: statically or dynamically. If the plugin is statically linked, then
    it needs to provide a function called `get<Plugin-Name>PluginInfo()`. To use dynamic
    linking, the `llvmGetPassPluginInfo()` function needs to be provided. In both
    cases, an instance of the `PassPluginLibraryInfo` struct is returned, which provides
    some basic information about a plugin. Most importantly, this structure contains
    a pointer to the function that registers the pass. Let’s add this to our source.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `RegisterCB()` function, we register a Lambda function that is called
    when a pass pipeline string is parsed. If the name of the pass is `ppprofiler`,
    then we add our pass to the module pass manager. These callbacks will be expanded
    upon in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `getPPProfilerPluginInfo()` function is called when the plugin is statically
    linked. It returns some basic information about the plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, if the plugin is dynamically linked, then the `llvmGetPassPluginInfo()`
    function is called when the plugin is loaded. However, when linking this code
    statically into a tool, you might end up with linker errors because that function
    could be defined in several source files. The solution is to guard the function
    with a macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve implemented the pass plugin. Before we look at how to use the
    new plugin, let’s examine what needs to be changed if we want to add the pass
    plugin to the LLVM source tree.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the pass to the LLVM source tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing a new pass as a plugin is useful if you plan to use it with a precompiled
    clang, for example. On the other hand, if you write your own compiler, then there
    can be good reasons to add your new passes directly to the LLVM source tree. There
    are two different ways you can do this – as a plugin and as a fully integrated
    pass. The plugin approach requires fewer changes.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the plugin mechanisms inside the LLVM source tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source of passes that perform transformations on LLVM IR is located in the
    `llvm-project/llvm/lib/Transforms` directory. Inside this directory, create a
    new directory called `PPProfiler` and copy the source file, `PPProfiler.cpp`,
    into it. You do not need to make any source changes!
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate the new plugin into the build system, create a file called `CMakeLists.txt`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `CmakeLists.txt` file in the parent directory, you need to
    include the new source directory by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now ready to build LLVM with `PPProfiler` added. Change into the build
    directory of LLVM and manually run Ninja:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake will detect a change in the build description and rerun the configuration
    step. You will see an additional line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This tells you that the plugin was detected and has been built as a shared library.
    After the installation step, you will find that shared library, `PPProfiler.so`,
    in the `<install` `directory>/lib` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, the only difference to the pass plugin from the previous section is
    that the shared library is installed as part of LLVM. But you can also statically
    link the new plugin to the LLVM tools. To do this, you need to rerun the CMake
    configuration and add the `-DLLVM_PPPROFILER_LINK_INTO_TOOLS=ON` option on the
    command line. Look for this information from CMake to confirm the changed build
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling and installing LLVM again, the following has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: The plugin is compiled into the static library, `libPPProfiler.a`, and that
    library is installed in the `<install` `directory>/lib` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LLVM tools, such as **opt**, are linked against that library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plugin is registered as an extension. You can check that the `<install
    directory>/include/llvm/Support/Extension.def` file now contains the following
    line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition, all tools that support this extension mechanism pick up the new
    pass. In the *Creating an optimization pipeline* section, you will learn how to
    do this in your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works well because the new source files reside in a separate directory,
    and only one existing file was changed. This minimizes the probability of merge
    conflicts if you try to keep your modified LLVM source tree in sync with the main
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: There are also situations where adding the new pass as a plugin is not the best
    way. The passes that LLVM provides use a different way for registration. If you
    develop a new pass and propose to add it to LLVM, and the LLVM community accepts
    your contribution, then you will want to use the same registration mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Fully integrating the pass into the pass registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To fully integrate the new pass into LLVM, the source of the plugin needs to
    be structured slightly differently. The main reason for this is that the constructor
    of the pass class is called from the pass registry, which requires the class interface
    to be put into a header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like before, you must put the new pass into the `Transforms` component of LLVM.
    Begin the implementation by creating the `llvm-project/llvm/include/llvm/Transforms/PPProfiler/PPProfiler.h`
    header file. The content of that file is the class definition; put it into the
    `llvm` namespace. No other changes are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy the source file of the pass plugin, `PPProfiler.cpp`, into the new
    directory, `llvm-project/llvm/lib/Transforms/PPProfiler`. This file needs to be
    updated in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the class definition is now in a header file, you must remove the class
    definition from this file. At the top, add the `#include` directive for the header
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `llvmGetPassPluginInfo()` function must be removed because the pass wasn’t
    built into a shared library of its own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As before, you also need to provide a `CMakeLists.txt` file for the build.
    You must declare the new pass as a new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After, like in the previous section, you need to include the new source directory
    by adding the following line to the `CMakeLists.txt` file in the parent directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside LLVM, the available passes are kept in the `llvm/lib/Passes/ PassRegistry.def`
    database file. You need to update this file. The new pass is a module pass, so
    we need to search inside the file for the section in which module passes are defined,
    for example, by searching for the `MODULE_PASS` macro. Inside this section, add
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This database file is used in the `llvm/lib/Passes/PassBuilder.cpp` class.
    This file needs to include your new header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These are all required source changes based on the plugin version of the new
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you created a new LLVM component, it is also necessary to add a link
    dependency in the `llvm/lib/Passes/CMakeLists.txt` file. Under the `LINK_COMPONENTS`
    keyword, you need to add a line with the name of the new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Et voilà – you are ready to build and install LLVM. The new pass, `ppprofiler`,
    is now available to all LLVM tools. It has been compiled into the `libLLVMPPProfiler.a`
    library and available in the build system as the `PPProfiler` component.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have talked about how to create a new pass. In the next section,
    we will examine how to use the `ppprofiler` pass.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ppprofiler pass with LLVM tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall the ppprofiler pass that we developed as a plugin out of the LLVM tree
    in the *Developing the ppprofiler pass as a plugin* section. Here, we’ll learn
    how to use this pass with LLVM tools, such as `opt` and `clang`, as they can load
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at `opt` first.
  prefs: []
  type: TYPE_NORMAL
- en: Run the pass plugin in opt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To play around with the new plugin, you need a file containing LLVM IR. The
    easiest way to do this is to translate a C program, such as a basic “Hello World”
    style program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile this file, `hello.c`, with `clang`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a very simple IR file called `hello.ll` that contains the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is enough to test the pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the pass, you have to provide a couple of arguments. First, you need
    to tell `opt` to load the shared library via the `--load-pass-plugin` option.
    To run a single pass, you must specify the`–-passes` option. Using the `hello.ll`
    file as input, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If statistic generation is enabled, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you will be informed that statistic collection is not enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The bitcode file, `hello_inst.bc`, is the result. You can turn this file into
    readable IR with the `llvm-dis` tool. As expected, you will see the calls to the
    `__ppp_enter()` and `__ppp_exit()` functions and a new constant for the name of
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This already looks good! It would be even better if we could turn this IR into
    an executable and run it. For this, you need to provide implementations for the
    called functions.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the runtime support for a feature is more complicated than adding that
    feature to the compiler itself. This is also true in this case. When the `__ppp_enter()`
    and `__ppp_exit()` functions are called, you can view this as an event. To analyze
    the data later, it is necessary to save the events. The basic data you would like
    to get is the event of the type, the name of the function and its address, and
    a timestamp. Without tricks, this is not as easy as it seems. Let’s give it a
    try.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `runtime.c` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need the file I/O, standard functions, and time support. This is provided
    by the following includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the file, a file descriptor is needed. Moreover, when the program finishes,
    that file descriptor should be closed properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To simplify the runtime, only a fixed name for the output is used. If the file
    is not open, then open the file and register the `cleanup` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can call the `clock_gettime()` function to get a timestamp. The `CLOCK_PROCESS_CPUTIME_ID`
    parameter returns the time consumed by this process. Please note that not all
    systems support this parameter. You can use one of the other clocks, such as `CLOCK_REALTIME`,
    if necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it is easy to define the `__ppp_enter()` function. Just make sure the
    file is open, get the timestamp, and write the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `__ppp_exit()` function only differs in terms of the event type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That concludes a very simple implementation for runtime support. Before we try
    it, some remarks should be made about the implementation as it should be obvious
    that there are several problematic parts.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the implementation is not thread-safe since there is only one
    file descriptor, and access to it is not protected. Trying to use this runtime
    implementation with a multithreaded program will most likely lead to disturbed
    data in the output file.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we omitted checking the return value of the I/O-related functions,
    which can result in data loss.
  prefs: []
  type: TYPE_NORMAL
- en: But most importantly, the timestamp of the event is not precise. Calling a function
    already adds overhead, but performing I/O operations in that function makes it
    even worse. In principle, you can match the enter and exit events for a function
    and calculate the runtime of the function. However, this value is inherently flawed
    because it may include the time required for I/O. In summary, do not trust the
    times recorded here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite all the flaws, this small runtime file allows us to produce some output.
    Compile the bitcode of the instrumented file together with the file containing
    the runtime code and run the resulting executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a new file called `ppprofile.csv` in the directory that contains
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Cool – the new pass and the runtime seem to work!
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a pass pipeline
  prefs: []
  type: TYPE_NORMAL
- en: With the `–-passes` option, you can not only name a single pass but you can
    also describe a whole pipeline. For example, the default pipeline for optimization
    level 2 is named `default<O2>`. You can run the `ppprofile` pass before the default
    pipeline with the`–-passes="ppprofile,default<O2>"` argument. Please note that
    the pass names in such a pipeline description must be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s turn to using the new pass with `clang`.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging the new pass into clang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you learned how you can run a single pass using `opt`.
    This is useful if you need to debug a pass but for a real compiler, the steps
    should not be that involved.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve the best result, a compiler needs to run the optimization passes
    in a certain order. The LLVM pass manager has a default order for pass execution.
    This is also called the `opt`, you can specify a different pass pipeline with
    the `–passes` option. This is flexible but also complicated for the user. It also
    turns out that most of the time, you just want to add a new pass at very specific
    points, such as before optimization passes are run or at the end of the loop optimization
    processes. These points are called `PassBuilder` class allows you to register
    a pass at an extension point. For example, you can call the `registerPipelineStartEPCallback()`
    method to add a pass to the beginning of the optimization pipeline. This is exactly
    the place we need for the `ppprofiler` pass. During optimization, functions may
    be inlined, and the pass will miss those inline functions. Instead, running the
    pass before the optimization passes guarantees that all functions are instrumented.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this approach, you need to extend the `RegisterCB()` function in the
    pass plugin. Add the following code to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the pass manager populates the default pass pipeline, it calls all
    the callbacks for the extension points. We simply add the new pass here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the plugin into `clang`, you can use the `-fpass-plugin` option. Creating
    the instrumented executable of the `hello.c` file now becomes almost trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Please run the executable and verify that the run creates the `ppprofiler.csv`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `runtime.c` file is not instrumented because the pass checks that the special
    functions are not yet declared in a module.
  prefs: []
  type: TYPE_NORMAL
- en: This already looks better, but does it scale to larger programs? Let’s assume
    you want to build an instrumented binary of the `tinylang` compiler for [*Chapter
    5*](B19561_05.xhtml#_idTextAnchor091). How would you do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass compiler and linker flags on the CMake command line, which is
    exactly what we need. The flags for the C++ compiler are given in the `CMAKE_CXX_FLAGS`
    variable. Thus, specifying the following on the CMake command line adds the new
    pass to all compiler runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Please replace `<PluginPath>` with the absolute path to the shared library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, specifying the following adds the `runtime.o` file to each linker
    invocation. Again, please replace `<RuntimePath>` with the absolute path to a
    compiled version of `runtime.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this requires `clang` as the build compiler. The fastest way to
    make sure `clang` is used as the build compiler is to set the `CC` and `CXX` environment
    variables accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With these additional options, the CMake configuration from [*Chapter 5*](B19561_05.xhtml#_idTextAnchor091)
    should run as usual.
  prefs: []
  type: TYPE_NORMAL
- en: After building the `tinylang` executable, you can run it with the example `Gcd.mod`
    file. The `ppprofile.csv` file will also be written, this time with more than
    44,000 lines!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, having such a dataset raises the question of if you can get something
    useful out of it. For example, getting a list of the 10 most often called functions,
    together with the call count and the time spent in the function, would be useful
    information. Luckily, on a Unix system, you have a couple of tools that can help.
    Let’s build a short pipeline that matches enter events with exit events, counts
    the functions, and displays the top 10 functions. The `awk` Unix tool helps with
    most of these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To match an enter event with an exit event, the enter event must be stored
    in the `record` associative map. When an exit event is matched, the stored enter
    event is looked up, and the new record is written. The emitted line contains the
    timestamp from the enter event, the timestamp from the exit event, and the difference
    between both. We must put this into the `join.awk` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To count the function calls and the execution, two associative maps, `count`
    and `sum`, are used. In `count`, the function calls are counted, while in `sum`,
    the execution time is added. In the end, the maps are dumped. You can put this
    into the `avg.awk` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After running these two scripts, the result can be sorted in descending order,
    and then the top 10 lines can be taken from the file. However, we can still improve
    the function names, `__ppp_enter()` and `__ppp_exit()`, which are mangled and
    are therefore difficult to read. Using the `llvm-cxxfilt` tool, the names can
    be demangled. The `demangle.awk` script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the top 10 function calls, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some sample lines from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first number is the call count of the function, the second is the cumulated
    execution time, and the third number is the average execution time. As explained
    previously, do not trust the time values, though the call counts should be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve implemented a new instrumentation pass, either as a plugin or
    as an addition to LLVM, and we used it in some real-world scenarios. In the next
    section, we’ll explore how to set up an optimization pipeline in our compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an optimization pipeline to your compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tinylang` compiler we developed in the previous chapters performs no optimizations
    on the IR code. In the next few subsections, we’ll add an optimization pipeline
    to the compiler to achieve this accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an optimization pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PassBuilder` class is central to setting up the optimization pipeline.
    This class knows about all registered passes and can construct a pass pipeline
    from a textual description. We can use this class to either create the pass pipeline
    from a description given on the command line or use a default pipeline based on
    the requested optimization level. We also support the use of pass plugins, such
    as the `ppprofiler` pass plugin we discussed in the previous section. With this,
    we can mimic part of the functionality of the **opt** tool and also use similar
    names for the command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: The `PassBuilder` class populates an instance of a `ModulePassManager` class,
    which is the pass manager that holds the constructed pass pipeline and runs it.
    The code generation passes still use the old pass manager. Therefore, we have
    to retain the old pass manager for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the implementation, we will extend the `tools/driver/Driver.cpp` file from
    our `tinylang` compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use new classes, so we’ll begin with adding new include files. The `llvm/Passes/PassBuilder.h`
    file defines the `PassBuilder` class. The `llvm/Passes/PassPlugin.h` file is required
    for plugin support. Finally, the `llvm/Analysis/TargetTransformInfo.h` file provides
    a pass that connects IR-level transformations with target-specific information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use certain features of the new pass manager, we must add three command-line
    options, using the same names as the `opt` tool does. The `--passes` option allows
    the textual specification of the pass pipeline, while the `--load-pass-plugin`
    option allows the use of pass plugins. If the `--debug-pass-manager` option is
    given, then the pass manager prints out information about the executed passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The user influences the construction of the pass pipeline with the optimization
    level. The `PassBuilder` class supports six different optimization levels: no
    optimization, three levels for optimizing speed, and two levels for reducing size.
    We can capture all levels in one command-line option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The plugin mechanism of LLVM supports a plugin registry for statically linked
    plugins, which is created during the configuration of the project. To make use
    of this registry, we must include the `llvm/Support/Extension.def` database file
    to create the prototype for the functions that return the plugin information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must replace the existing `emit()` function with a new version. Additionally,
    we must declare the required `PassBuilder` instance at the top of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement the support for pass plugins given on the command line, we must
    loop through the list of plugin libraries given by the user and try to load the
    plugin. We’ll emit an error message if this fails; otherwise, we’ll register the
    passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The information from the static plugin registry is used in a similar way to
    register those plugins with our `PassBuilder` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to declare variables for the different analysis managers. The
    only parameter is the debug flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must populate the analysis managers with calls to the respective `register`
    method on the `PassBuilder` instance. Through this call, the analysis manager
    is populated with the default analysis passes and also runs registration callbacks.
    We must also make sure that the function analysis manager uses the default alias-analysis
    pipeline and that all analysis managers know about each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `MPM` module pass manager holds the pass pipeline that we constructed.
    The instance is initialized with the debug flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to implement two different ways to populate the module pass manager
    with the pass pipeline. If the user provided a pass pipeline on the command line
    – that is, they have used the `--passes` option – then we use this as the pass
    pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, we use the chosen optimization level to determine the pass pipeline
    to construct. The name of the default pass pipeline is `default`, and it takes
    the optimization level as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, the pass pipeline to run transformations on the IR code has been
    set up. After this step, we need an open file to write the result to. The system
    assembler and LLVM IR output are text-based, so we should set the `OF_Text` flag
    for them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the code generation process, we have to use the old pass manager. We must
    simply declare the `CodeGenPM` instances and add the pass, which makes target-specific
    information available at the IR transformation level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To output LLVM IR, we must add a pass that prints the IR into a stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, we must let the `TargetMachine` instance add the required code generation
    passes, directed by the `FileType` value we pass as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After all this preparation, we are now ready to execute the passes. First,
    we must run the optimization pipeline on the IR module. Next, the code generation
    passes are run. Of course, after all this work, we want to keep the output file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That was a lot of code, but the process was straightforward. Of course, we
    have to update the dependencies in the `tools/driver/CMakeLists.txt` build file
    too. Besides adding the target components, we must add all the transformation
    and code generation components from LLVM. The names roughly resemble the directory
    names where the source is located. The component name is translated into the link
    library name during the configuration process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our compiler driver supports plugins, and we must announce this support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As before, we have to link against our own libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are necessary additions to the source code and the build system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To build the extended compiler, you must change into your `build` directory
    and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Changes to the files of the build system are automatically detected, and `cmake`
    is run before compiling and linking our changed source. If you need to re-run
    the configuration step, please follow the instructions in [*Chapter 1*](B19561_01.xhtml#_idTextAnchor017),
    *Installing LLVM*, the *Compiling the tinylang* *application* section.
  prefs: []
  type: TYPE_NORMAL
- en: As we have used the options for the `opt` tool as a blueprint, you should try
    running `tinylang` with the options to load a pass plugin and run the pass, as
    we did in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: With the current implementation, we can either run a default pass pipeline or
    we can construct one ourselves. The latter is very flexible, but in almost all
    cases, it would be overkill. The default pipeline runs very well for C-like languages.
    However, what is missing is a way to extend the pass pipeline. We’ll look at how
    to implement this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the pass pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we used the `PassBuilder` class to create a pass pipeline,
    either from a user-provided description or a predefined name. Now, let’s look
    at another way to customize the pass pipeline: using extension points.'
  prefs: []
  type: TYPE_NORMAL
- en: 'During the construction of the pass pipeline, the pass builder allows passes
    contributed by the user to be added. These places are called **extension points**.
    A couple of extension points exist, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline start extension point, which allows us to add passes at the beginning
    of the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peephole extension point, which allows us to add passes after each instance
    of the instruction combiner pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other extension points exist too. To employ an extension point, you must register
    a callback. During the construction of the pass pipeline, your callback is run
    at the defined extension point and can add passes to the given pass manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register a callback for the pipeline start extension point, you must call
    the `registerPipelineStartEPCallback()` method of the `PassBuilder` class. For
    example, to add our `PPProfiler` pass to the beginning of the pipeline, you would
    adapt the pass to be used as a module pass with a call to the `createModuleToFunctionPassAdaptor()`
    template function and then add the pass to the module pass manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You can add this snippet in the pass pipeline setup code anywhere before the
    pipeline is created – that is, before the `parsePassPipeline()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very natural extension to what we did in the previous section is to let the
    user pass a pipeline description for an extension point on the command line. The
    `opt` tool allows this too. Let’s do this for the pipeline start extension point.
    Add the following code to the `tools/driver/Driver.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must a new command line for the user to specify the pipeline description.
    Again, we take the option name from the `opt` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using a Lambda function as a callback is the most convenient way to do this.
    To parse the pipeline description, we must call the `parsePassPipeline()` method
    of the `PassBuilder` instance. The passes are added to the `PM` pass manager and
    given as an argument to the Lambda function. If an error occurs, we only print
    an error message without stopping the application. You can add this snippet after
    the call to the `crossRegisterProxies()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To allow the user to add passes at every extension point, you need to add the
    preceding code snippet for each extension point.
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to try out the different `pass manager` options. With the
    `--debug-pass-manager` option, you can follow which passes are executed in which
    order. You can also print the IR before or after each pass, which is invoked with
    the `--print-before-all` and `--print-after-all` options. If you created your
    own pass pipeline, then you can insert the `print` pass in points of interest.
    For example, try the `--passes="print,inline,print"` option. Furthermore, to identify
    which pass changes the IR code, you can use the `--print-changed` option, which
    will only print the IR code if it has changed compared to the result from the
    pass before. The greatly reduced output makes it much easier to follow IR transformations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PassBuilder` class has a nested `OptimizationLevel` class to represent
    the six different optimization levels. Instead of using the `"default<O?>"` pipeline
    description as an argument to the `parsePassPipeline()` method, we can also call
    the `buildPerModuleDefaultPipeline()` method, which builds the default optimization
    pipeline for the request level – except for level `O0`. This optimization level
    means that no optimization is performed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consequently, no passes are added to the pass manager. If we still want to
    run a certain pass, then we can add it to the pass manager manually. A simple
    pass to run at this level is the `AlwaysInliner` pass, which inlines a function
    marked with the `always_inline` attribute into the caller. After translating the
    command-line option value for the optimization level into the corresponding member
    of the `OptimizationLevel` class, we can implement this as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, it is possible to add more than one pass to the pass manager in this
    fashion. `PassBuilder` also uses the `addPass()` method when constructing the
    pass pipeline.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running extension point callbacks
  prefs: []
  type: TYPE_NORMAL
- en: Because the pass pipeline is not populated for optimization level `O0`, the
    registered extension points are not called. If you use the extension points to
    register passes that should also run at `O0` level, this is problematic. You can
    call the `runRegisteredEPCallbacks()` method to run the registered extension point
    callbacks, resulting in a pass manager populated only with the passes that were
    registered through the extension points.
  prefs: []
  type: TYPE_NORMAL
- en: By adding the optimization pipeline to `tinylang`, you created an optimizing
    compiler similar to `clang`. The LLVM community works on improving the optimizations
    and the optimization pipeline with each release. Due to this, it is very seldom
    that the default pipeline is not used. Most often, new passes are added to implement
    certain semantics of the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a new pass for LLVM. You ran the
    pass using a pass pipeline description and an extension point. You extended your
    compiler with the construction and execution of a pass pipeline similar to `clang`,
    turning `tinylang` into an optimizing compiler. The pass pipeline allows the addition
    of passes at extension points, and you learned how you can register passes at
    these points. This allows you to extend the optimization pipeline with your developed
    passes or existing passes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn the basics of the `clang` to significantly
    reduce manual programming.
  prefs: []
  type: TYPE_NORMAL
