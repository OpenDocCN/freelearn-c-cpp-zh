- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Optimizing IR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化IR
- en: LLVM uses a series of passes to optimize the IR. A pass operates on a unit of
    IR, such as a function or a module. The operation can be a transformation, which
    changes the IR in a defined way, or an analysis, which collects information such
    as dependencies. This series of passes is called the **pass pipeline**. The pass
    manager executes the pass pipeline on the IR, which our compiler produces. Therefore,
    you need to know what the pass manager does and how to construct a pass pipeline.
    The semantics of a programming language may require the development of new passes,
    and we must add these passes to the pipeline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM使用一系列的passes来优化IR。一个pass操作于IR的一个单元，例如一个函数或一个模块。操作可以是转换，以定义的方式改变IR，或者分析，收集如依赖等信息。这个一系列的passes被称为**pass
    pipeline**。pass管理器在IR上执行pass pipeline，这是我们的编译器产生的。因此，你需要了解pass管理器做什么以及如何构建一个pass
    pipeline。编程语言的语义可能需要开发新的passes，我们必须将这些passes添加到管道中。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: How to leverage the LLVM pass manager to implement passes within LLVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用LLVM pass管理器在LLVM中实现passes
- en: How to implement an instrumentation pass, as an example, within the LLVM project,
    as well as a separate plugin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在LLVM项目中实现一个作为示例的instrumentation pass，以及一个独立的插件
- en: In using the ppprofiler pass with LLVM tools, you will learn how to use a pass
    plugin with `opt` and `clang`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用LLVM工具中的pprofiler pass时，你将学习如何使用`opt`和`clang`与pass插件一起使用
- en: In adding an optimization pipeline to your compiler, you will extend the `tinylang`
    compiler with an optimization pipeline based on the new pass manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向你的编译器添加优化pipeline时，你将使用基于新pass管理器的优化pipeline扩展`tinylang`编译器。
- en: By the end of this chapter, you will know how to develop a new pass and how
    you can add it to a pass pipeline. You will also be able to set up the pass pipeline
    in your compiler.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何开发一个新的pass，以及如何将其添加到pass管道中。你还将能够在你的编译器中设置pass管道。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07)找到。
- en: The LLVM pass manager
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM的Pass管理器
- en: The LLVM core libraries optimize the IR that your compiler creates and turn
    it into object code. This giant task is broken down into separate steps called
    **passes**. These passes need to be executed in the right order, which is the
    objective of the pass manager.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM核心库优化编译器创建的IR，并将其转换为对象代码。这个巨大的任务被分解为称为**passes**的单独步骤。这些pass需要按正确的顺序执行，这是pass管理器的目标。
- en: Why not hard-code the order of the passes? The user of your compiler usually
    expects your compiler to provide a different level of optimization. Developers
    prefer fast compilation speed over optimization during development time. The final
    application should run as fast as possible, and your compiler should be able to
    perform sophisticated optimizations, with longer a compilation time being accepted.
    A different level of optimization means a different number of optimization passes
    that need to be executed. Thus, as a compiler writer, you may want to provide
    your own passes to take advantage of your knowledge of your source language. For
    example, you may want to replace well-known library functions with inlined IR
    or even with the precomputed result. For C, such a pass is part of the LLVM libraries,
    but for other languages, you will need to provide it yourself. After introducing
    your own passes, you may need to re-order or add some passes. For example, if
    you know that the operation of your pass leaves some IR code unreachable, then
    you want to run the dead code removal pass additionally after your pass. The pass
    manager helps organize these requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接硬编码pass的顺序呢？你的编译器的用户通常期望编译器提供不同级别的优化。开发者更倾向于在开发时优先考虑快速的编译速度，而不是优化。最终的应用程序应该尽可能快地运行，并且你的编译器应该能够执行复杂的优化，接受更长的编译时间。不同级别的优化意味着需要执行不同数量的优化pass。因此，作为一个编译器编写者，你可能想利用你对源语言的知识来提供自己的pass。例如，你可能想用内联IR或预计算的結果来替换已知的库函数。对于C语言，这样的pass是LLVM库的一部分，但对于其他语言，你可能需要自己提供。在引入自己的pass之后，你可能需要重新排序或添加一些pass。例如，如果你知道你的pass操作会留下一些不可达的IR代码，那么你希望在你的pass之后额外运行死代码删除pass。pass管理器帮助组织这些需求。
- en: 'A pass is often categorized by the scope on which it works:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 流程通常根据其工作的范围进行分类：
- en: A *module pass* takes a whole module as input. Such a pass performs its work
    on the given module and can be used for intra-procedure operations inside this
    module.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *模块流程* 以整个模块作为输入。此类流程在其给定的模块上执行其工作，并可用于此模块内的过程内操作。
- en: A *call graph* pass operates on the **strongly connected components** (**SCCs**)
    of a call graph. It traverses the components in bottom-up order.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *调用图流程* 在调用图的 **强连通分量**（**SCCs**）上操作。它按自下而上的顺序遍历这些组件。
- en: A *function pass* takes a single function as input and performs its work on
    this function only.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *函数流程* 以单个函数作为输入，并且只在此函数上执行其工作。
- en: A *loop pass* works on a loop inside a function.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *循环流程* 在函数内的循环上工作。
- en: Besides the IR code, a pass may also require, update, or invalidate some analysis
    results. A lot of different analyses are performed, for example, alias analysis
    or the construction of a dominator tree. If a pass requires such analyses, then
    it can request it from an analyses manager. If the information is already computed,
    then the cached result will be returned. Otherwise, the information will be computed.
    If a pass changes the IR code, then it needs to announce which analysis results
    are preserved so that the cached analysis information can be invalidated if necessary.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 IR 代码之外，流程还可能需要、更新或使某些分析结果无效。执行了许多不同的分析，例如别名分析或构建支配树。如果流程需要此类分析，则可以从分析管理器请求它。如果信息已经计算，则将返回缓存的結果。否则，将计算信息。如果流程更改
    IR 代码，则需要宣布哪些分析结果是保留的，以便在必要时使缓存的分析信息无效。
- en: 'Under the hood, the pass manager ensures the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，流程管理器确保以下内容：
- en: Analysis results are shared among passes. This requires keeping track of which
    pass requires which analysis and the state of each analysis. The goal is to avoid
    needless precomputation of analysis and to free up memory held by analysis results
    as soon as possible.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析结果在流程之间共享。这需要跟踪哪个流程需要哪种分析以及每个分析的状态。目标是避免不必要的分析预计算，并尽快释放分析结果占用的内存。
- en: The passes are executed in a pipeline fashion. For example, if several function
    passes should be executed in sequence, then the pass manager runs each of these
    function passes on the first function. Then, it will run all function passes on
    the second function, and so on. The underlying idea here is to improve the cache
    behavior as the compiler only performs transformations on a limited set of data
    (one IR function) and then moves on to the next limited set of data.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程以管道方式执行。例如，如果应该按顺序执行多个函数流程，则流程管理器将每个这些函数流程运行在第一个函数上。然后，它将运行所有函数流程在第二个函数上，依此类推。这里的底层思想是改善缓存行为，因为编译器只对有限的数据集（一个
    IR 函数）执行转换，然后转到下一个有限的数据集。
- en: Let’s implement a new IR transformation pass and explore how to add it to the
    optimization pipeline.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个新的 IR 转换流程，并探索如何将其添加到优化流程中。
- en: Implementing a new pass
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个新的流程
- en: A pass can perform arbitrary complex transformations on the LLVM IR. To illustrate
    the mechanics of adding a new pass, we add a pass that performs a simple instrumentation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 流程可以对 LLVM IR 执行任意复杂的转换。为了说明添加新流程的机制，我们添加了一个执行简单仪表化的流程。
- en: To investigate the performance of a program, it is interesting to know how often
    functions are called, and how long they run. One way to collect this data is to
    insert counters into each function. This process is called `ppprofiler`. We will
    develop the new pass so that it can be used as a standalone plugin or added as
    a plugin to the LLVM source tree. After that, we’ll look at how the passes that
    come with LLVM are integrated into the framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查程序的性能，了解函数被调用的频率以及它们运行的时间很有趣。收集这些数据的一种方法是在每个函数中插入计数器。这个过程被称为 `ppprofiler`。我们将开发新的流程，使其可以作为独立插件使用，或者作为插件添加到
    LLVM 源树中。之后，我们将探讨随 LLVM 一起提供的流程如何集成到框架中。
- en: Developing the ppprofiler pass as a plugin
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ppprofiler 流程作为插件开发
- en: In this section, we’ll look at creating a new pass as a plugin out of the LLVM
    tree. The goal of the new pass is to insert a call to the `__ppp_enter()` function
    at the entry of a function, and a call to the `__ppp_exit()` function before each
    return instruction. Only the name of the current function is passed as a parameter.
    The implementation of these functions can then count the number of calls and measure
    the elapsed time. We will implement this runtime support at the end of this chapter.
    We’ll examine how to develop the pass.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll store the source in the `PPProfiler.cpp` file. Follow these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s include some files:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To shorten the source, we’ll tell the compiler that we’re using the `llvm`
    namespace:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The built-in debug infrastructure of LLVM requires that we define a debug type,
    which is a string. This string is later shown in the printed statistic:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’ll define one counter variable with the `ALWAYS_ENABLED_STATISTIC`
    macro. The first parameter is the name of the counter variable, while the second
    parameter is the text that will be printed in the statistic:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Two macros can be used to define a counter variable. If you use the `STATISTIC`
    macro, then the statistic value will only be collected in a debug build if assertions
    are enabled, or if `LLVM_FORCE_ENABLE_STATS` is set to `ON` on the CMake command
    line. If you use the `ALWAYS_ENABLED_STATISTIC` macro instead, then the statistic
    value is always collected. However, printing the statistics using the`–stats`
    command-line option only works with the former methods. If needed, you can print
    the collected statistics by calling the `llvm::PrintStatistics(llvm::raw_ostream)`
    function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must declare the pass class in an anonymous namespace. The class inherits
    from the `PassInfoMixin` template. This template only adds some boilerplate code,
    such as a `name()` method. It is not used to determine the type of the pass. The
    `run()` method is called by LLVM when the pass is executed. We also need a helper
    method called `instrument()`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s define how a function is instrumented. Besides the function to instrument,
    the functions to call are passed:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the function, we update the statistic counter:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To easily insert IR code, we need an instance of the `IRBuilder` class. We
    will set it to the first basic block, which is the entry block of the function:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have the builder, we can insert a global constant that holds the
    name of the function we wish to instrument:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will insert a call to the `__ppp_enter()` function, passing the name
    as an argument:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To call the `__ppp_exit()` function, we have to locate all return instructions.
    Conveniently, the insertion point that’s set by the calling `SetInsertionPoint()`
    function is before the instruction that’s passed as a parameter, so we can just
    insert the call at that point:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will implement the `run()` method. LLVM passes in the module our pass
    works on and an analysis manager from which we can request analysis results if
    needed:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `run()` 方法。LLVM 通过模块传递我们的通过，以及一个分析管理器，如果需要，我们可以从中请求分析结果：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is a slight annoyance here: if the runtime module that contains the implementation
    of the `__ppp_enter()` and `__ppp_exit()` functions are instrumented, then we
    run into trouble because we create an infinite recursion. To avoid this, we must
    simply do nothing if one of those functions is defined:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一点小麻烦：如果包含 `__ppp_enter()` 和 `__ppp_exit()` 函数实现的运行时模块被仪器化，那么我们会遇到麻烦，因为我们创建了一个无限递归。为了避免这种情况，如果这些函数中的任何一个被定义，我们必须简单地什么也不做：
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we are ready to declare the functions. There is nothing unusual here:
    first, the function type is created, followed by the functions:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备声明函数。这里没有什么不寻常的：首先创建函数类型，然后是函数：
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All we need to do now is loop over all the functions of the module and instrument
    the found functions by calling our `instrument()` method. Of course, we need to
    ignore function declarations, which are just prototypes. There can also be functions
    without a name, which does not work well with our approach. We’ll filter out those
    functions too:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是遍历模块中的所有函数，并通过调用我们的 `instrument()` 方法来对找到的函数进行仪器化。当然，我们需要忽略函数声明，因为它们只是原型。也可能存在没有名称的函数，这不适合我们的方法。我们也会过滤掉这些函数：
- en: '[PRE14]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, we must declare that we did not preserve any analysis. This is most
    likely too pessimistic but we are on the safe side by doing so:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须声明我们没有保留任何分析。这可能是过于悲观了，但通过这样做我们可以确保安全：
- en: '[PRE15]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The functionality of our new pass is now implemented. To be able to use our
    pass, we need to register it with the `PassBuilder` object. This can happen in
    two ways: statically or dynamically. If the plugin is statically linked, then
    it needs to provide a function called `get<Plugin-Name>PluginInfo()`. To use dynamic
    linking, the `llvmGetPassPluginInfo()` function needs to be provided. In both
    cases, an instance of the `PassPluginLibraryInfo` struct is returned, which provides
    some basic information about a plugin. Most importantly, this structure contains
    a pointer to the function that registers the pass. Let’s add this to our source.'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们新通过的功能现在已实现。为了能够使用我们的通过，我们需要将其注册到 `PassBuilder` 对象中。这可以通过两种方式实现：静态或动态。如果插件是静态链接的，那么它需要提供一个名为
    `get<Plugin-Name>PluginInfo()` 的函数。要使用动态链接，需要提供 `llvmGetPassPluginInfo()` 函数。在两种情况下，都会返回一个
    `PassPluginLibraryInfo` 结构体的实例，该结构体提供有关插件的一些基本信息。最重要的是，这个结构体包含一个指向注册通过函数的指针。让我们将其添加到我们的源代码中。
- en: 'In the `RegisterCB()` function, we register a Lambda function that is called
    when a pass pipeline string is parsed. If the name of the pass is `ppprofiler`,
    then we add our pass to the module pass manager. These callbacks will be expanded
    upon in the next section:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RegisterCB()` 函数中，我们注册了一个 Lambda 函数，该函数在解析通过管道字符串时被调用。如果通过的名称是 `ppprofiler`，那么我们将我们的通过添加到模块通过管理器中。这些回调将在下一节中进一步说明：
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `getPPProfilerPluginInfo()` function is called when the plugin is statically
    linked. It returns some basic information about the plugin:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当插件静态链接时，会调用 `getPPProfilerPluginInfo()` 函数。它返回有关插件的一些基本信息：
- en: '[PRE17]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, if the plugin is dynamically linked, then the `llvmGetPassPluginInfo()`
    function is called when the plugin is loaded. However, when linking this code
    statically into a tool, you might end up with linker errors because that function
    could be defined in several source files. The solution is to guard the function
    with a macro:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果插件是动态链接的，那么当插件被加载时将调用 `llvmGetPassPluginInfo()` 函数。然而，当将此代码静态链接到工具中时，可能会遇到链接器错误，因为该函数可能在多个源文件中定义。解决方案是使用宏来保护该函数：
- en: '[PRE18]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With that, we’ve implemented the pass plugin. Before we look at how to use the
    new plugin, let’s examine what needs to be changed if we want to add the pass
    plugin to the LLVM source tree.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就实现了通过插件。在我们查看如何使用新插件之前，让我们看看如果我们想将通过插件添加到 LLVM 源树中，需要做哪些更改。
- en: Adding the pass to the LLVM source tree
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将通过添加到 LLVM 源树中
- en: Implementing a new pass as a plugin is useful if you plan to use it with a precompiled
    clang, for example. On the other hand, if you write your own compiler, then there
    can be good reasons to add your new passes directly to the LLVM source tree. There
    are two different ways you can do this – as a plugin and as a fully integrated
    pass. The plugin approach requires fewer changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用预编译的 clang 等工具，将新转换作为插件实现是有用的。另一方面，如果你编写自己的编译器，那么将你的新转换直接添加到 LLVM 源树中可能有很好的理由。你可以以两种不同的方式这样做——作为插件和作为一个完全集成的转换。插件方法需要的更改较少。
- en: Utilizing the plugin mechanisms inside the LLVM source tree
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 LLVM 源树内部的插件机制
- en: The source of passes that perform transformations on LLVM IR is located in the
    `llvm-project/llvm/lib/Transforms` directory. Inside this directory, create a
    new directory called `PPProfiler` and copy the source file, `PPProfiler.cpp`,
    into it. You do not need to make any source changes!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行对 LLVM IR 进行转换的转换函数的源代码位于 `llvm-project/llvm/lib/Transforms` 目录中。在此目录内，创建一个名为
    `PPProfiler` 的新目录，并将源文件 `PPProfiler.cpp` 复制到其中。你不需要对源代码进行任何修改！
- en: 'To integrate the new plugin into the build system, create a file called `CMakeLists.txt`
    with the following content:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新插件集成到构建系统中，创建一个名为 `CMakeLists.txt` 的文件，并包含以下内容：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, in the `CmakeLists.txt` file in the parent directory, you need to
    include the new source directory by adding the following line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在父目录中的 `CmakeLists.txt` 文件中，你需要通过添加以下行来包含新的源目录：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You are now ready to build LLVM with `PPProfiler` added. Change into the build
    directory of LLVM and manually run Ninja:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以准备使用添加了 `PPProfiler` 的 LLVM 进行构建了。切换到 LLVM 的构建目录，并手动运行 Ninja：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'CMake will detect a change in the build description and rerun the configuration
    step. You will see an additional line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会检测构建描述的变化并重新运行配置步骤。你将看到额外的行：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells you that the plugin was detected and has been built as a shared library.
    After the installation step, you will find that shared library, `PPProfiler.so`,
    in the `<install` `directory>/lib` directory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明插件已被检测到，并已作为共享库构建。在安装步骤之后，你将在 `<install directory>/lib` 目录中找到该共享库，`PPProfiler.so`。
- en: 'So far, the only difference to the pass plugin from the previous section is
    that the shared library is installed as part of LLVM. But you can also statically
    link the new plugin to the LLVM tools. To do this, you need to rerun the CMake
    configuration and add the `-DLLVM_PPPROFILER_LINK_INTO_TOOLS=ON` option on the
    command line. Look for this information from CMake to confirm the changed build
    option:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与上一节中的转换插件相比，唯一的区别是共享库作为 LLVM 的一部分被安装。但你也可以将新的插件静态链接到 LLVM 工具。为此，你需要重新运行
    CMake 配置，并在命令行上添加 `-DLLVM_PPPROFILER_LINK_INTO_TOOLS=ON` 选项。从 CMake 中查找此信息以确认更改后的构建选项：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After compiling and installing LLVM again, the following has changed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译和安装 LLVM 后，以下内容发生了变化：
- en: The plugin is compiled into the static library, `libPPProfiler.a`, and that
    library is installed in the `<install` `directory>/lib` directory.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件被编译到静态库 `libPPProfiler.a` 中，并且该库被安装到 `<install directory>/lib` 目录中。
- en: The LLVM tools, such as **opt**, are linked against that library.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 工具，如 **opt**，都与该库链接。
- en: 'The plugin is registered as an extension. You can check that the `<install
    directory>/include/llvm/Support/Extension.def` file now contains the following
    line:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件被注册为扩展。你可以检查 `<install directory>/include/llvm/Support/Extension.def` 文件现在是否包含以下行：
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition, all tools that support this extension mechanism pick up the new
    pass. In the *Creating an optimization pipeline* section, you will learn how to
    do this in your compiler.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有支持此扩展机制的工具都会获取新的转换。在 *创建优化管道* 部分中，你将学习如何在你的编译器中实现这一点。
- en: This approach works well because the new source files reside in a separate directory,
    and only one existing file was changed. This minimizes the probability of merge
    conflicts if you try to keep your modified LLVM source tree in sync with the main
    repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法效果很好，因为新的源文件位于一个单独的目录中，并且只更改了一个现有文件。这最大限度地减少了如果你尝试保持修改后的 LLVM 源树与主仓库同步时的合并冲突概率。
- en: There are also situations where adding the new pass as a plugin is not the best
    way. The passes that LLVM provides use a different way for registration. If you
    develop a new pass and propose to add it to LLVM, and the LLVM community accepts
    your contribution, then you will want to use the same registration mechanism.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 也有情况，将新的pass作为插件添加并不是最佳方式。LLVM提供的pass使用不同的注册方式。如果您开发了一个新的pass并提议将其添加到LLVM中，并且LLVM社区接受了您的贡献，那么您将希望使用相同的注册机制。
- en: Fully integrating the pass into the pass registry
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全集成pass到pass注册表中
- en: To fully integrate the new pass into LLVM, the source of the plugin needs to
    be structured slightly differently. The main reason for this is that the constructor
    of the pass class is called from the pass registry, which requires the class interface
    to be put into a header file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全集成新的pass到LLVM中，插件的源代码需要稍微不同的结构。这样做的主要原因是因为pass类的构造函数是从pass注册表中调用的，这要求类接口被放入头文件中。
- en: 'Like before, you must put the new pass into the `Transforms` component of LLVM.
    Begin the implementation by creating the `llvm-project/llvm/include/llvm/Transforms/PPProfiler/PPProfiler.h`
    header file. The content of that file is the class definition; put it into the
    `llvm` namespace. No other changes are required:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，您必须将新的pass放入LLVM的`Transforms`组件中。通过创建`llvm-project/llvm/include/llvm/Transforms/PPProfiler/PPProfiler.h`头文件开始实现；该文件的内容是类定义；将其放入`llvm`命名空间。不需要其他更改：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, copy the source file of the pass plugin, `PPProfiler.cpp`, into the new
    directory, `llvm-project/llvm/lib/Transforms/PPProfiler`. This file needs to be
    updated in the following way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将pass插件的源文件`PPProfiler.cpp`复制到新目录`llvm-project/llvm/lib/Transforms/PPProfiler`中。此文件需要按以下方式更新：
- en: 'Since the class definition is now in a header file, you must remove the class
    definition from this file. At the top, add the `#include` directive for the header
    file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于类定义现在在头文件中，您必须从该文件中移除类定义。在顶部，添加对头文件的`#include`指令：
- en: '[PRE26]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `llvmGetPassPluginInfo()` function must be removed because the pass wasn’t
    built into a shared library of its own.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须删除`llvmGetPassPluginInfo()`函数，因为pass没有构建成它自己的共享库。
- en: 'As before, you also need to provide a `CMakeLists.txt` file for the build.
    You must declare the new pass as a new component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，您还需要提供一个`CMakeLists.txt`文件用于构建。您必须声明新的pass作为一个新组件：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After, like in the previous section, you need to include the new source directory
    by adding the following line to the `CMakeLists.txt` file in the parent directory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像在上一节中一样，您需要通过在父目录的`CMakeLists.txt`文件中添加以下行来包含新的源目录：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside LLVM, the available passes are kept in the `llvm/lib/Passes/ PassRegistry.def`
    database file. You need to update this file. The new pass is a module pass, so
    we need to search inside the file for the section in which module passes are defined,
    for example, by searching for the `MODULE_PASS` macro. Inside this section, add
    the following line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM内部，可用的passes被保存在`llvm/lib/Passes/PassRegistry.def`数据库文件中。您需要更新此文件。新的pass是一个模块pass，因此我们需要在文件中搜索定义模块passes的部分，例如，通过搜索`MODULE_PASS`宏。在此部分中，添加以下行：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This database file is used in the `llvm/lib/Passes/PassBuilder.cpp` class.
    This file needs to include your new header file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据库文件用于`llvm/lib/Passes/PassBuilder.cpp`类。此文件需要包含您的新头文件：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These are all required source changes based on the plugin version of the new
    pass.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是基于新pass插件版本所需的所有源代码更改。
- en: 'Since you created a new LLVM component, it is also necessary to add a link
    dependency in the `llvm/lib/Passes/CMakeLists.txt` file. Under the `LINK_COMPONENTS`
    keyword, you need to add a line with the name of the new component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您创建了一个新的LLVM组件，因此还需要在`llvm/lib/Passes/CMakeLists.txt`文件中添加一个链接依赖项。在`LINK_COMPONENTS`关键字下，您需要添加一行，包含新组件的名称：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Et voilà – you are ready to build and install LLVM. The new pass, `ppprofiler`,
    is now available to all LLVM tools. It has been compiled into the `libLLVMPPProfiler.a`
    library and available in the build system as the `PPProfiler` component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Et voilà – 您现在可以构建和安装LLVM。新的pass，`ppprofiler`，现在对所有LLVM工具都可用。它已被编译进`libLLVMPPProfiler.a`库，并在构建系统中作为`PPProfiler`组件可用。
- en: So far, we have talked about how to create a new pass. In the next section,
    we will examine how to use the `ppprofiler` pass.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何创建一个新的pass。在下一节中，我们将探讨如何使用`ppprofiler` pass。
- en: Using the ppprofiler pass with LLVM tools
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLVM工具的pprofiler pass
- en: Recall the ppprofiler pass that we developed as a plugin out of the LLVM tree
    in the *Developing the ppprofiler pass as a plugin* section. Here, we’ll learn
    how to use this pass with LLVM tools, such as `opt` and `clang`, as they can load
    plugins.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在 *Developing the ppprofiler pass as a plugin* 部分中从 LLVM 树中开发出来的 ppprofiler
    传递函数。在这里，我们将学习如何使用这个传递函数与 LLVM 工具一起使用，如 `opt` 和 `clang`，因为它们可以加载插件。
- en: Let’s look at `opt` first.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `opt`。
- en: Run the pass plugin in opt
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 opt 中运行传递插件
- en: 'To play around with the new plugin, you need a file containing LLVM IR. The
    easiest way to do this is to translate a C program, such as a basic “Hello World”
    style program:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试新的插件，你需要一个包含 LLVM IR 的文件。最简单的方法是将一个 C 程序翻译过来，例如一个基本的“Hello World”风格程序：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Compile this file, `hello.c`, with `clang`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `clang` 编译此文件，`hello.c`：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will get a very simple IR file called `hello.ll` that contains the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个非常简单的 IR 文件，名为 `hello.ll`，其中包含以下代码：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is enough to test the pass.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以测试传递函数。
- en: 'To run the pass, you have to provide a couple of arguments. First, you need
    to tell `opt` to load the shared library via the `--load-pass-plugin` option.
    To run a single pass, you must specify the`–-passes` option. Using the `hello.ll`
    file as input, you can run the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此传递函数，你必须提供一些参数。首先，你需要告诉 `opt` 通过 `--load-pass-plugin` 选项加载共享库。要运行单个传递函数，你必须指定
    `--passes` 选项。使用 `hello.ll` 文件作为输入，你可以运行以下命令：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If statistic generation is enabled, you will see the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了统计生成，你将看到以下输出：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Otherwise, you will be informed that statistic collection is not enabled:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你将被告知统计收集未启用：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The bitcode file, `hello_inst.bc`, is the result. You can turn this file into
    readable IR with the `llvm-dis` tool. As expected, you will see the calls to the
    `__ppp_enter()` and `__ppp_exit()` functions and a new constant for the name of
    the function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 位码文件 `hello_inst.bc` 是结果。你可以使用 `llvm-dis` 工具将此文件转换为可读的 IR。正如预期的那样，你会看到对 `__ppp_enter()`
    和 `__ppp_exit()` 函数的调用以及一个用于函数名称的新常量：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This already looks good! It would be even better if we could turn this IR into
    an executable and run it. For this, you need to provide implementations for the
    called functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经看起来不错了！如果我们可以将这个 IR 转换为可执行文件并运行它，那就更好了。为此，你需要为被调用的函数提供实现。
- en: Often, the runtime support for a feature is more complicated than adding that
    feature to the compiler itself. This is also true in this case. When the `__ppp_enter()`
    and `__ppp_exit()` functions are called, you can view this as an event. To analyze
    the data later, it is necessary to save the events. The basic data you would like
    to get is the event of the type, the name of the function and its address, and
    a timestamp. Without tricks, this is not as easy as it seems. Let’s give it a
    try.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对某个功能的运行时支持比将其添加到编译器本身更复杂。这种情况也是如此。当调用 `__ppp_enter()` 和 `__ppp_exit()` 函数时，你可以将其视为一个事件。为了稍后分析数据，有必要保存这些事件。你希望获取的基本数据是事件类型、函数名称及其地址，以及时间戳。没有技巧，这并不像看起来那么简单。让我们试试看。
- en: 'Create a file called `runtime.c` with the following content:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `runtime.c` 的文件，内容如下：
- en: 'You need the file I/O, standard functions, and time support. This is provided
    by the following includes:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要文件 I/O、标准函数和时间支持。这由以下包含提供：
- en: '[PRE39]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the file, a file descriptor is needed. Moreover, when the program finishes,
    that file descriptor should be closed properly:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于文件，需要一个文件描述符。此外，当程序结束时，应该正确关闭该文件描述符：
- en: '[PRE40]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To simplify the runtime, only a fixed name for the output is used. If the file
    is not open, then open the file and register the `cleanup` function:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化运行时，只使用一个固定的输出名称。如果文件未打开，则打开文件并注册 `cleanup` 函数：
- en: '[PRE41]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can call the `clock_gettime()` function to get a timestamp. The `CLOCK_PROCESS_CPUTIME_ID`
    parameter returns the time consumed by this process. Please note that not all
    systems support this parameter. You can use one of the other clocks, such as `CLOCK_REALTIME`,
    if necessary:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `clock_gettime()` 函数来获取时间戳。`CLOCK_PROCESS_CPUTIME_ID` 参数返回此进程消耗的时间。请注意，并非所有系统都支持此参数。如果需要，你可以使用其他时钟，例如
    `CLOCK_REALTIME`：
- en: '[PRE42]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, it is easy to define the `__ppp_enter()` function. Just make sure the
    file is open, get the timestamp, and write the event:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义 `__ppp_enter()` 函数很容易。只需确保文件已打开，获取时间戳，并写入事件：
- en: '[PRE43]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `__ppp_exit()` function only differs in terms of the event type:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__ppp_exit()` 函数仅在事件类型方面有所不同：'
- en: '[PRE44]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That concludes a very simple implementation for runtime support. Before we try
    it, some remarks should be made about the implementation as it should be obvious
    that there are several problematic parts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了对运行时支持的简单实现。在我们尝试之前，应该对实现进行一些说明，因为很明显，这里有几个问题部分。
- en: First of all, the implementation is not thread-safe since there is only one
    file descriptor, and access to it is not protected. Trying to use this runtime
    implementation with a multithreaded program will most likely lead to disturbed
    data in the output file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于只有一个文件描述符，并且对其访问没有保护，因此实现不是线程安全的。尝试使用此运行时实现与多线程程序一起使用，很可能会导致输出文件中的数据混乱。
- en: In addition, we omitted checking the return value of the I/O-related functions,
    which can result in data loss.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们忽略了检查与I/O相关的函数的返回值，这可能导致数据丢失。
- en: But most importantly, the timestamp of the event is not precise. Calling a function
    already adds overhead, but performing I/O operations in that function makes it
    even worse. In principle, you can match the enter and exit events for a function
    and calculate the runtime of the function. However, this value is inherently flawed
    because it may include the time required for I/O. In summary, do not trust the
    times recorded here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但最重要的是，事件的戳记并不精确。调用函数已经增加了开销，但在该函数中执行I/O操作使其变得更糟。原则上，你可以匹配函数的进入和退出事件并计算函数的运行时间。然而，这个值本身是有缺陷的，因为它可能包括I/O所需的时间。总之，不要相信这里记录的时间。
- en: 'Despite all the flaws, this small runtime file allows us to produce some output.
    Compile the bitcode of the instrumented file together with the file containing
    the runtime code and run the resulting executable:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在所有这些缺陷，这个小运行时文件仍允许我们生成一些输出。将带有运行时代码的文件的bitcode与编译器文件一起编译，并运行生成的可执行文件：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This results in a new file called `ppprofile.csv` in the directory that contains
    the following content:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这在包含以下内容的目录中生成一个名为`ppprofile.csv`的新文件：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Cool – the new pass and the runtime seem to work!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——新的pass和运行时似乎都工作得很好！
- en: Specifying a pass pipeline
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 指定pass pipeline
- en: With the `–-passes` option, you can not only name a single pass but you can
    also describe a whole pipeline. For example, the default pipeline for optimization
    level 2 is named `default<O2>`. You can run the `ppprofile` pass before the default
    pipeline with the`–-passes="ppprofile,default<O2>"` argument. Please note that
    the pass names in such a pipeline description must be of the same type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`–-passes`选项，你不仅可以命名单个pass，还可以描述整个pipeline。例如，优化级别2的默认pipeline命名为`default<O2>`。你可以使用`–-passes="ppprofile,default<O2>"`参数在默认pipeline之前运行`ppprofile`
    pass。请注意，此类pipeline描述中的pass名称必须是同一类型。
- en: Now, let’s turn to using the new pass with `clang`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向使用新的pass与`clang`。
- en: Plugging the new pass into clang
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将新的pass插入到clang中
- en: In the previous section, you learned how you can run a single pass using `opt`.
    This is useful if you need to debug a pass but for a real compiler, the steps
    should not be that involved.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何使用`opt`运行单个pass。如果你需要调试一个pass，这很有用，但对于真正的编译器，步骤不应该那么复杂。
- en: To achieve the best result, a compiler needs to run the optimization passes
    in a certain order. The LLVM pass manager has a default order for pass execution.
    This is also called the `opt`, you can specify a different pass pipeline with
    the `–passes` option. This is flexible but also complicated for the user. It also
    turns out that most of the time, you just want to add a new pass at very specific
    points, such as before optimization passes are run or at the end of the loop optimization
    processes. These points are called `PassBuilder` class allows you to register
    a pass at an extension point. For example, you can call the `registerPipelineStartEPCallback()`
    method to add a pass to the beginning of the optimization pipeline. This is exactly
    the place we need for the `ppprofiler` pass. During optimization, functions may
    be inlined, and the pass will miss those inline functions. Instead, running the
    pass before the optimization passes guarantees that all functions are instrumented.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到最佳效果，编译器需要按照一定的顺序运行优化通行。LLVM 通行管理器为通行执行提供了默认顺序。这也被称为 `opt`，您可以使用 `–passes`
    选项指定不同的通行管道。这很灵活，但对于用户来说也很复杂。实际上，大多数时候，您只想在非常具体的位置添加新的通行，例如在运行优化通行之前或循环优化过程结束时。这些位置被称为
    `PassBuilder` 类允许您在扩展点注册通行。例如，您可以通过调用 `registerPipelineStartEPCallback()` 方法将通行添加到优化管道的开始处。这正是我们需要的
    `ppprofiler` 通行的地方。在优化过程中，函数可能会被内联，而通行可能会错过这些内联函数。相反，在优化通行之前运行通行可以保证所有函数都被仪器化。
- en: 'To use this approach, you need to extend the `RegisterCB()` function in the
    pass plugin. Add the following code to the function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种方法，您需要扩展通行插件中的 `RegisterCB()` 函数。将以下代码添加到函数中：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Whenever the pass manager populates the default pass pipeline, it calls all
    the callbacks for the extension points. We simply add the new pass here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当通行管理器填充默认的通行管道时，它会调用所有扩展点的回调。我们只需在这里添加新的通行。
- en: 'To load the plugin into `clang`, you can use the `-fpass-plugin` option. Creating
    the instrumented executable of the `hello.c` file now becomes almost trivial:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要将插件加载到 `clang` 中，您可以使用 `-fpass-plugin` 选项。现在创建 `hello.c` 文件的仪器化可执行文件几乎变得微不足道：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Please run the executable and verify that the run creates the `ppprofiler.csv`
    file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请运行可执行文件并验证运行是否创建了 `ppprofiler.csv` 文件。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `runtime.c` file is not instrumented because the pass checks that the special
    functions are not yet declared in a module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通行检查特殊函数尚未在模块中声明，因此 `runtime.c` 文件没有被仪器化。
- en: This already looks better, but does it scale to larger programs? Let’s assume
    you want to build an instrumented binary of the `tinylang` compiler for [*Chapter
    5*](B19561_05.xhtml#_idTextAnchor091). How would you do this?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经看起来更好了，但它是否适用于更大的程序？让我们假设您想为 [*第五章*](B19561_05.xhtml#_idTextAnchor091) 构建
    `tinylang` 编译器的仪器化二进制文件。您将如何做？
- en: 'You can pass compiler and linker flags on the CMake command line, which is
    exactly what we need. The flags for the C++ compiler are given in the `CMAKE_CXX_FLAGS`
    variable. Thus, specifying the following on the CMake command line adds the new
    pass to all compiler runs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 CMake 命令行上传递编译器和链接器标志，这正是我们所需要的。C++ 编译器的标志在 `CMAKE_CXX_FLAGS` 变量中给出。因此，在
    CMake 命令行上指定以下内容会将新的通行添加到所有编译器运行中：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Please replace `<PluginPath>` with the absolute path to the shared library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请将 `<PluginPath>` 替换为共享库的绝对路径。
- en: 'Similarly, specifying the following adds the `runtime.o` file to each linker
    invocation. Again, please replace `<RuntimePath>` with the absolute path to a
    compiled version of `runtime.c`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，指定以下内容会将 `runtime.o` 文件添加到每个链接调用中。再次提醒，请将 `<RuntimePath>` 替换为 `runtime.c`
    编译版本的绝对路径：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Of course, this requires `clang` as the build compiler. The fastest way to
    make sure `clang` is used as the build compiler is to set the `CC` and `CXX` environment
    variables accordingly:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这需要使用 `clang` 作为构建编译器。确保 `clang` 作为构建编译器使用的最快方法是相应地设置 `CC` 和 `CXX` 环境变量：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With these additional options, the CMake configuration from [*Chapter 5*](B19561_05.xhtml#_idTextAnchor091)
    should run as usual.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些附加选项，[*第五章*](B19561_05.xhtml#_idTextAnchor091) 中的 CMake 配置应正常运行。
- en: After building the `tinylang` executable, you can run it with the example `Gcd.mod`
    file. The `ppprofile.csv` file will also be written, this time with more than
    44,000 lines!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 `tinylang` 可执行文件后，您可以使用示例 `Gcd.mod` 文件运行它。这次 `ppprofile.csv` 文件也将被写入，这次有超过
    44,000 行！
- en: Of course, having such a dataset raises the question of if you can get something
    useful out of it. For example, getting a list of the 10 most often called functions,
    together with the call count and the time spent in the function, would be useful
    information. Luckily, on a Unix system, you have a couple of tools that can help.
    Let’s build a short pipeline that matches enter events with exit events, counts
    the functions, and displays the top 10 functions. The `awk` Unix tool helps with
    most of these steps.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，拥有这样的数据集会引发一个问题：你是否能从中获得有用的信息。例如，获取最常调用的10个函数的列表，包括函数的调用次数和在该函数中花费的时间，将是有用的信息。幸运的是，在Unix系统中，你有一些工具可以帮助你。让我们构建一个简短的管道，匹配进入事件和退出事件，计算函数，并显示前10个函数。`awk`
    Unix工具帮助完成这些步骤中的大多数。
- en: 'To match an enter event with an exit event, the enter event must be stored
    in the `record` associative map. When an exit event is matched, the stored enter
    event is looked up, and the new record is written. The emitted line contains the
    timestamp from the enter event, the timestamp from the exit event, and the difference
    between both. We must put this into the `join.awk` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配进入事件和退出事件，进入事件必须存储在 `record` 关联映射中。当匹配到退出事件时，会查找存储的进入事件，并写入新的记录。发出的行包含进入事件的戳记，退出事件的戳记，以及两者之间的差异。我们必须将此放入
    `join.awk` 文件中：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To count the function calls and the execution, two associative maps, `count`
    and `sum`, are used. In `count`, the function calls are counted, while in `sum`,
    the execution time is added. In the end, the maps are dumped. You can put this
    into the `avg.awk` file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算函数调用和执行，使用了两个关联映射，`count` 和 `sum`。在 `count` 中，计算函数调用，而在 `sum` 中，添加执行时间。最后，映射被导出。你可以将此放入
    `avg.awk` 文件中：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After running these two scripts, the result can be sorted in descending order,
    and then the top 10 lines can be taken from the file. However, we can still improve
    the function names, `__ppp_enter()` and `__ppp_exit()`, which are mangled and
    are therefore difficult to read. Using the `llvm-cxxfilt` tool, the names can
    be demangled. The `demangle.awk` script is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这两个脚本后，结果可以按降序排序，然后可以从文件中取出前10行。然而，我们仍然可以改进函数名，`__ppp_enter()` 和 `__ppp_exit()`，它们是混淆的，因此难以阅读。使用
    `llvm-cxxfilt` 工具，可以取消混淆。以下是一个 `demangle.awk` 脚本：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To get the top 10 function calls, you can run the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取前10个函数调用，你可以运行以下命令：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here are some sample lines from the output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出的一些示例行：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first number is the call count of the function, the second is the cumulated
    execution time, and the third number is the average execution time. As explained
    previously, do not trust the time values, though the call counts should be accurate.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字是函数的调用次数，第二个是累计执行时间，第三个数字是平均执行时间。正如之前所解释的，尽管调用次数应该是准确的，但不要相信时间值。
- en: So far, we’ve implemented a new instrumentation pass, either as a plugin or
    as an addition to LLVM, and we used it in some real-world scenarios. In the next
    section, we’ll explore how to set up an optimization pipeline in our compiler.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一个新的仪器传递，要么作为插件，要么作为LLVM的补充，并在一些实际场景中使用了它。在下一节中，我们将探讨如何在我们的编译器中设置优化管道。
- en: Adding an optimization pipeline to your compiler
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向你的编译器添加优化管道
- en: The `tinylang` compiler we developed in the previous chapters performs no optimizations
    on the IR code. In the next few subsections, we’ll add an optimization pipeline
    to the compiler to achieve this accordingly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中我们开发的 `tinylang` 编译器对IR代码不进行优化。在接下来的几个小节中，我们将向编译器添加一个优化管道来实现这一点。
- en: Creating an optimization pipeline
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建优化管道
- en: The `PassBuilder` class is central to setting up the optimization pipeline.
    This class knows about all registered passes and can construct a pass pipeline
    from a textual description. We can use this class to either create the pass pipeline
    from a description given on the command line or use a default pipeline based on
    the requested optimization level. We also support the use of pass plugins, such
    as the `ppprofiler` pass plugin we discussed in the previous section. With this,
    we can mimic part of the functionality of the **opt** tool and also use similar
    names for the command-line options.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassBuilder`类对于设置优化管道至关重要。这个类了解所有已注册的pass，并可以从文本描述中构建pass管道。我们可以使用这个类从命令行上的描述创建pass管道，或者使用基于请求的优化级别的默认管道。我们还支持使用pass插件，例如我们在上一节中讨论的`ppprofiler`
    pass插件。有了这个，我们可以模拟**opt**工具的部分功能，并且也可以为命令行选项使用类似的名字。'
- en: The `PassBuilder` class populates an instance of a `ModulePassManager` class,
    which is the pass manager that holds the constructed pass pipeline and runs it.
    The code generation passes still use the old pass manager. Therefore, we have
    to retain the old pass manager for this purpose.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassBuilder`类填充了一个`ModulePassManager`类的实例，这是持有构建的pass管道并运行它的pass管理器。代码生成pass仍然使用旧的pass管理器。因此，我们必须保留旧的pass管理器用于此目的。'
- en: 'For the implementation, we will extend the `tools/driver/Driver.cpp` file from
    our `tinylang` compiler:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，我们将从我们的`tinylang`编译器扩展`tools/driver/Driver.cpp`文件：
- en: 'We’ll use new classes, so we’ll begin with adding new include files. The `llvm/Passes/PassBuilder.h`
    file defines the `PassBuilder` class. The `llvm/Passes/PassPlugin.h` file is required
    for plugin support. Finally, the `llvm/Analysis/TargetTransformInfo.h` file provides
    a pass that connects IR-level transformations with target-specific information:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用新的类，因此我们将从添加新的包含文件开始。`llvm/Passes/PassBuilder.h`文件定义了`PassBuilder`类。`llvm/Passes/PassPlugin.h`文件是插件支持所必需的。最后，`llvm/Analysis/TargetTransformInfo.h`文件提供了一个将IR级转换与特定目标信息连接的pass：
- en: '[PRE57]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To use certain features of the new pass manager, we must add three command-line
    options, using the same names as the `opt` tool does. The `--passes` option allows
    the textual specification of the pass pipeline, while the `--load-pass-plugin`
    option allows the use of pass plugins. If the `--debug-pass-manager` option is
    given, then the pass manager prints out information about the executed passes:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用新pass管理器的某些功能，我们必须添加三个命令行选项，使用与`opt`工具相同的名称。`--passes`选项允许以文本形式指定pass管道，而`--load-pass-plugin`选项允许使用pass插件。如果提供了`--debug-pass-manager`选项，则pass管理器将打印出有关已执行pass的信息：
- en: '[PRE58]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The user influences the construction of the pass pipeline with the optimization
    level. The `PassBuilder` class supports six different optimization levels: no
    optimization, three levels for optimizing speed, and two levels for reducing size.
    We can capture all levels in one command-line option:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过优化级别影响pass管道的构建。`PassBuilder`类支持六个不同的优化级别：无优化、三个优化速度的级别和两个减少大小的级别。我们可以通过一个命令行选项捕获所有级别：
- en: '[PRE59]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The plugin mechanism of LLVM supports a plugin registry for statically linked
    plugins, which is created during the configuration of the project. To make use
    of this registry, we must include the `llvm/Support/Extension.def` database file
    to create the prototype for the functions that return the plugin information:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM的插件机制支持静态链接插件的插件注册表，该注册表在项目配置期间创建。为了使用此注册表，我们必须包含`llvm/Support/Extension.def`数据库文件以创建返回插件信息的函数的原型：
- en: '[PRE60]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we must replace the existing `emit()` function with a new version. Additionally,
    we must declare the required `PassBuilder` instance at the top of the function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须用新版本替换现有的`emit()`函数。此外，我们必须在函数顶部声明所需的`PassBuilder`实例：
- en: '[PRE61]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To implement the support for pass plugins given on the command line, we must
    loop through the list of plugin libraries given by the user and try to load the
    plugin. We’ll emit an error message if this fails; otherwise, we’ll register the
    passes:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现命令行上提供的pass插件的支持，我们必须遍历用户提供的插件库列表，并尝试加载插件。如果失败，我们将发出错误消息；否则，我们将注册pass：
- en: '[PRE62]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The information from the static plugin registry is used in a similar way to
    register those plugins with our `PassBuilder` instance:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与静态插件注册表中的信息以类似的方式使用，将那些插件注册到我们的`PassBuilder`实例：
- en: '[PRE63]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we need to declare variables for the different analysis managers. The
    only parameter is the debug flag:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要声明不同分析管理器的变量。唯一的参数是调试标志：
- en: '[PRE64]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we must populate the analysis managers with calls to the respective `register`
    method on the `PassBuilder` instance. Through this call, the analysis manager
    is populated with the default analysis passes and also runs registration callbacks.
    We must also make sure that the function analysis manager uses the default alias-analysis
    pipeline and that all analysis managers know about each other:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须通过在 `PassBuilder` 实例上调用相应的 `register` 方法来填充分析管理器。通过这个调用，分析管理器被填充了默认的分析传递，并且也运行了注册回调。我们还必须确保函数分析管理器使用默认的别名分析管道，并且所有分析管理器都知道彼此：
- en: '[PRE65]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `MPM` module pass manager holds the pass pipeline that we constructed.
    The instance is initialized with the debug flag:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MPM` 模块传递管理器持有我们构建的传递管道。实例使用调试标志初始化：'
- en: '[PRE66]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we need to implement two different ways to populate the module pass manager
    with the pass pipeline. If the user provided a pass pipeline on the command line
    – that is, they have used the `--passes` option – then we use this as the pass
    pipeline:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实现两种不同的方法来用传递管道填充模块传递管理器。如果用户在命令行上提供了传递管道——也就是说，他们使用了 `--passes` 选项——那么我们就使用这个作为传递管道：
- en: '[PRE67]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Otherwise, we use the chosen optimization level to determine the pass pipeline
    to construct. The name of the default pass pipeline is `default`, and it takes
    the optimization level as a parameter:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们使用选择的优化级别来确定构建传递管道。默认传递管道的名称是 `default`，它接受优化级别作为参数：
- en: '[PRE68]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With that, the pass pipeline to run transformations on the IR code has been
    set up. After this step, we need an open file to write the result to. The system
    assembler and LLVM IR output are text-based, so we should set the `OF_Text` flag
    for them:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，对 IR 代码运行转换的传递管道已经设置好了。在此步骤之后，我们需要一个打开的文件来写入结果。系统汇编器和 LLVM IR 输出是基于文本的，因此我们应该为它们设置
    `OF_Text` 标志：
- en: '[PRE69]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For the code generation process, we have to use the old pass manager. We must
    simply declare the `CodeGenPM` instances and add the pass, which makes target-specific
    information available at the IR transformation level:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于代码生成过程，我们必须使用旧的传递管理器。我们只需声明 `CodeGenPM` 实例并添加传递，这样就可以在 IR 转换级别提供目标特定信息：
- en: '[PRE70]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To output LLVM IR, we must add a pass that prints the IR into a stream:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要输出 LLVM IR，我们必须添加一个传递，该传递将 IR 打印到流中：
- en: '[PRE71]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Otherwise, we must let the `TargetMachine` instance add the required code generation
    passes, directed by the `FileType` value we pass as an argument:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们必须让 `TargetMachine` 实例添加所需的代码生成传递，这些传递由我们传递的 `FileType` 值指导：
- en: '[PRE72]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After all this preparation, we are now ready to execute the passes. First,
    we must run the optimization pipeline on the IR module. Next, the code generation
    passes are run. Of course, after all this work, we want to keep the output file:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有这些准备工作之后，我们现在可以执行传递了。首先，我们必须在 IR 模块上运行优化管道。接下来，运行代码生成传递。当然，在所有这些工作之后，我们希望保留输出文件：
- en: '[PRE73]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'That was a lot of code, but the process was straightforward. Of course, we
    have to update the dependencies in the `tools/driver/CMakeLists.txt` build file
    too. Besides adding the target components, we must add all the transformation
    and code generation components from LLVM. The names roughly resemble the directory
    names where the source is located. The component name is translated into the link
    library name during the configuration process:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码很多，但过程很简单。当然，我们还需要更新 `tools/driver/CMakeLists.txt` 构建文件中的依赖项。除了添加目标组件之外，我们还必须添加来自
    LLVM 的所有转换和代码生成组件。组件名称大致类似于源代码所在的目录名称。在配置过程中，组件名称被转换为链接库名称：
- en: '[PRE74]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Our compiler driver supports plugins, and we must announce this support:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的编译器驱动程序支持插件，我们必须宣布这种支持：
- en: '[PRE75]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As before, we have to link against our own libraries:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们必须链接到我们自己的库：
- en: '[PRE76]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: These are necessary additions to the source code and the build system.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是对源代码和构建系统的必要补充。
- en: 'To build the extended compiler, you must change into your `build` directory
    and type the following:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建扩展编译器，你必须切换到你的 `build` 目录并输入以下命令：
- en: '[PRE77]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Changes to the files of the build system are automatically detected, and `cmake`
    is run before compiling and linking our changed source. If you need to re-run
    the configuration step, please follow the instructions in [*Chapter 1*](B19561_01.xhtml#_idTextAnchor017),
    *Installing LLVM*, the *Compiling the tinylang* *application* section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统文件的更改将被自动检测，并且在编译和链接我们的更改源之前将运行 `cmake`。如果您需要重新运行配置步骤，请按照 [*第1章*](B19561_01.xhtml#_idTextAnchor017)
    中 *安装 LLVM* 的 *编译 tinylang 应用程序* 部分的说明操作。
- en: As we have used the options for the `opt` tool as a blueprint, you should try
    running `tinylang` with the options to load a pass plugin and run the pass, as
    we did in the previous sections.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将`opt`工具的选项作为蓝图使用，你应该尝试使用选项来运行`tinylang`，以加载一个pass插件并运行该插件，就像我们在前面的章节中所做的那样。
- en: With the current implementation, we can either run a default pass pipeline or
    we can construct one ourselves. The latter is very flexible, but in almost all
    cases, it would be overkill. The default pipeline runs very well for C-like languages.
    However, what is missing is a way to extend the pass pipeline. We’ll look at how
    to implement this in the next section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前实现，我们可以运行默认的pass管道，或者我们可以自己构建一个。后者非常灵活，但在几乎所有情况下，这都会过于冗余。默认管道对C-like语言运行得非常好。然而，缺少的是扩展pass管道的方法。我们将在下一节中看看如何实现这一点。
- en: Extending the pass pipeline
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展pass管道
- en: 'In the previous section, we used the `PassBuilder` class to create a pass pipeline,
    either from a user-provided description or a predefined name. Now, let’s look
    at another way to customize the pass pipeline: using extension points.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了`PassBuilder`类来创建一个pass管道，无论是从用户提供的描述还是预定义的名称。现在，让我们看看另一种自定义pass管道的方法：使用扩展点。
- en: 'During the construction of the pass pipeline, the pass builder allows passes
    contributed by the user to be added. These places are called **extension points**.
    A couple of extension points exist, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建pass管道的过程中，pass构建器允许添加用户贡献的pass。这些位置被称为**扩展点**。存在几个扩展点，如下所示：
- en: The pipeline start extension point, which allows us to add passes at the beginning
    of the pipeline
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们在管道开始处添加pass的管道开始扩展点
- en: The peephole extension point, which allows us to add passes after each instance
    of the instruction combiner pass
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们在指令组合器pass的每个实例之后添加pass的peephole扩展点
- en: Other extension points exist too. To employ an extension point, you must register
    a callback. During the construction of the pass pipeline, your callback is run
    at the defined extension point and can add passes to the given pass manager.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在其他扩展点。要使用扩展点，你必须注册一个回调。在构建pass管道的过程中，你的回调将在定义的扩展点处运行，并可以向给定的pass管理器添加pass。
- en: 'To register a callback for the pipeline start extension point, you must call
    the `registerPipelineStartEPCallback()` method of the `PassBuilder` class. For
    example, to add our `PPProfiler` pass to the beginning of the pipeline, you would
    adapt the pass to be used as a module pass with a call to the `createModuleToFunctionPassAdaptor()`
    template function and then add the pass to the module pass manager:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要为管道开始扩展点注册一个回调，你必须调用`PassBuilder`类的`registerPipelineStartEPCallback()`方法。例如，要将我们的`PPProfiler`
    pass添加到管道的开始处，你需要将pass适配为模块pass，通过调用`createModuleToFunctionPassAdaptor()`模板函数，然后将pass添加到模块pass管理器：
- en: '[PRE78]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can add this snippet in the pass pipeline setup code anywhere before the
    pipeline is created – that is, before the `parsePassPipeline()` method is called.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在创建管道之前，在任何位置添加此代码片段，即在调用`parsePassPipeline()`方法之前。
- en: 'A very natural extension to what we did in the previous section is to let the
    user pass a pipeline description for an extension point on the command line. The
    `opt` tool allows this too. Let’s do this for the pipeline start extension point.
    Add the following code to the `tools/driver/Driver.cpp` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们在上一节中所做的事情的一个非常自然的扩展是让用户在命令行上传递一个扩展点的管道描述。`opt`工具也允许这样做。让我们为管道开始扩展点添加以下代码到`tools/driver/Driver.cpp`文件：
- en: 'First, we must a new command line for the user to specify the pipeline description.
    Again, we take the option name from the `opt` tool:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须为用户提供一个新的命令行来指定管道描述。再次，我们从`opt`工具中获取选项名称：
- en: '[PRE79]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Using a Lambda function as a callback is the most convenient way to do this.
    To parse the pipeline description, we must call the `parsePassPipeline()` method
    of the `PassBuilder` instance. The passes are added to the `PM` pass manager and
    given as an argument to the Lambda function. If an error occurs, we only print
    an error message without stopping the application. You can add this snippet after
    the call to the `crossRegisterProxies()` method:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Lambda函数作为回调是最方便的方法。为了解析管道描述，我们必须调用`PassBuilder`实例的`parsePassPipeline()`方法。将pass添加到`PM`
    pass管理器，并将其作为参数传递给Lambda函数。如果发生错误，我们只打印错误消息而不会停止应用程序。你可以在调用`crossRegisterProxies()`方法之后添加此代码片段：
- en: '[PRE80]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Tip
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To allow the user to add passes at every extension point, you need to add the
    preceding code snippet for each extension point.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户在每一个扩展点添加 passes，您需要为每个扩展点添加前面的代码片段。
- en: Now is a good time to try out the different `pass manager` options. With the
    `--debug-pass-manager` option, you can follow which passes are executed in which
    order. You can also print the IR before or after each pass, which is invoked with
    the `--print-before-all` and `--print-after-all` options. If you created your
    own pass pipeline, then you can insert the `print` pass in points of interest.
    For example, try the `--passes="print,inline,print"` option. Furthermore, to identify
    which pass changes the IR code, you can use the `--print-changed` option, which
    will only print the IR code if it has changed compared to the result from the
    pass before. The greatly reduced output makes it much easier to follow IR transformations.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是尝试不同的 `pass manager` 选项的好时机。使用 `--debug-pass-manager` 选项，您可以跟踪执行顺序中哪些 passes
    被执行。您还可以在每个 pass 之前或之后打印 IR，这可以通过 `--print-before-all` 和 `--print-after-all` 选项来实现。如果您创建了您自己的
    pass 管道，那么您可以在感兴趣的位置插入 `print` pass。例如，尝试 `--passes="print,inline,print"` 选项。此外，为了确定哪个
    pass 改变了 IR 代码，您可以使用 `--print-changed` 选项，该选项仅在 IR 代码与上一个 pass 的结果相比有变化时打印 IR
    代码。大大减少的输出使得跟踪 IR 转换变得容易得多。
- en: The `PassBuilder` class has a nested `OptimizationLevel` class to represent
    the six different optimization levels. Instead of using the `"default<O?>"` pipeline
    description as an argument to the `parsePassPipeline()` method, we can also call
    the `buildPerModuleDefaultPipeline()` method, which builds the default optimization
    pipeline for the request level – except for level `O0`. This optimization level
    means that no optimization is performed.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PassBuilder` 类有一个嵌套的 `OptimizationLevel` 类来表示六个不同的优化级别。我们不仅可以将 `"default<O?>"`
    管道描述作为 `parsePassPipeline()` 方法的参数，还可以调用 `buildPerModuleDefaultPipeline()` 方法，该方法为请求级别构建默认的优化管道——除了级别
    `O0`。这个优化级别意味着不执行任何优化。'
- en: 'Consequently, no passes are added to the pass manager. If we still want to
    run a certain pass, then we can add it to the pass manager manually. A simple
    pass to run at this level is the `AlwaysInliner` pass, which inlines a function
    marked with the `always_inline` attribute into the caller. After translating the
    command-line option value for the optimization level into the corresponding member
    of the `OptimizationLevel` class, we can implement this as follows:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，没有 passes 被添加到 pass manager 中。如果我们仍然想运行某个 pass，那么我们可以手动将其添加到 pass manager
    中。在这个级别上运行的一个简单 pass 是 `AlwaysInliner` pass，它将带有 `always_inline` 属性的函数内联到调用者中。在将优化级别的命令行选项值转换为
    `OptimizationLevel` 类的相应成员之后，我们可以这样实现：
- en: '[PRE81]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Of course, it is possible to add more than one pass to the pass manager in this
    fashion. `PassBuilder` also uses the `addPass()` method when constructing the
    pass pipeline.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，以这种方式可以向 pass manager 添加多个 passes。`PassBuilder` 在构建 pass 管道时也会使用 `addPass()`
    方法。
- en: Running extension point callbacks
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行扩展点回调
- en: Because the pass pipeline is not populated for optimization level `O0`, the
    registered extension points are not called. If you use the extension points to
    register passes that should also run at `O0` level, this is problematic. You can
    call the `runRegisteredEPCallbacks()` method to run the registered extension point
    callbacks, resulting in a pass manager populated only with the passes that were
    registered through the extension points.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于优化级别 `O0` 的 pass 管道没有被填充，因此注册的扩展点没有被调用。如果您使用扩展点注册应在 `O0` 级别运行的 passes，这会存在问题。您可以通过调用
    `runRegisteredEPCallbacks()` 方法来运行注册的扩展点回调，这将导致只包含通过扩展点注册的 passes 的 pass manager。
- en: By adding the optimization pipeline to `tinylang`, you created an optimizing
    compiler similar to `clang`. The LLVM community works on improving the optimizations
    and the optimization pipeline with each release. Due to this, it is very seldom
    that the default pipeline is not used. Most often, new passes are added to implement
    certain semantics of the programming language.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将优化管道添加到 `tinylang`，您创建了一个类似于 `clang` 的优化编译器。LLVM 社区在每个版本中都致力于改进优化和优化管道。因此，默认管道很少不被使用。通常，新
    passes 被添加来实现编程语言的某些语义。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a new pass for LLVM. You ran the
    pass using a pass pipeline description and an extension point. You extended your
    compiler with the construction and execution of a pass pipeline similar to `clang`,
    turning `tinylang` into an optimizing compiler. The pass pipeline allows the addition
    of passes at extension points, and you learned how you can register passes at
    these points. This allows you to extend the optimization pipeline with your developed
    passes or existing passes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何为LLVM创建一个新的Pass。你使用Pass管道描述和扩展点运行了该Pass。你通过构建和执行类似于`clang`的Pass管道，扩展了你的编译器，将`tinylang`转换成了一个优化编译器。Pass管道允许在扩展点添加Pass，你学习了如何在这些点上注册Pass。这允许你通过你开发的Pass或现有的Pass来扩展优化管道。
- en: In the next chapter, you will learn the basics of the `clang` to significantly
    reduce manual programming.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习`clang`的基础知识，以显著减少手动编程。
