<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Effects of lighting , Materials and Lightmaps</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we discussed how to apply transformations and projections to objects. We also created multiple cubes and a <kbd>Camera</kbd> class to clearly view and navigate around those objects. In this chapter, we're going to look at lighting. Firstly, we're going to discuss the basics of colors with respect to our objects and the source of light. We'll also discuss creating a vertex shader and a fragment shader, like we had in the previous chapters for our object box. We'll be creating a shader for an actual light source such as a lamp. You'll also learn how to apply materials to your object cube and you will observe the effect light has on those materials. </p>
<p class="mce-root">In this chapter we'll cover the following topics: </p>
<ul>
<li class="mce-root">The basics of colors in lighting and lighting effects on objects</li>
<li class="mce-root">Effect of light on a type of material</li>
<li>Exploring lightmaps to implement the real-world effects of light on different materials</li>
</ul>
<p class="mce-root">Lights... camera...action!! </p>
<div class="packt_infobox">You can refer to all the code files for this chapter in the <kbd>Chapter04</kbd> folder on GitHub. The GitHub link can be found in the preface of the book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding an object and a light source</h1>
                </header>
            
            <article>
                
<p>In this section, will discuss how to apply colors to your cube object. We'll also learn how to create shader files for light and for a source of light such as a lamp. And then we'll learn how to add the cube and the light source to our game world. </p>
<p>So, let's begin by creating new shader files for the light and the lamp.   </p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating  lighting and lamp shader files</h1>
                </header>
            
            <article>
                
<p class="mce-root">Here we'll learn how to create shader files for a light source and a lamp and explore the code that will go into the vertex shaders and the fragment shaders. Perform the following steps to learn how create these shader files: </p>
<ol>
<li>First of all, for rename <kbd>core.vs</kbd> and <kbd>core.frag</kbd> from the previous chapters to <kbd>lighting.vs</kbd> and <kbd>lighting.core</kbd>.</li>
<li>Now let's begin with the modifications to the code of these newly renamed files. First of all, we'll modify <kbd>lighting.vs</kbd>.  What we're going to do here is get rid of the texture coordinate because we're not going to render a texture in here, and we'll also get rid of the <kbd>out texture</kbd> variable. Take a look at the following code to understand the changes made in the vertex shader for lighting:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>layout (location = 0) in vec3 position;<br/><br/>uniform mat4 model;<br/>uniform mat4 view;<br/>uniform mat4 projection;<br/><br/>void main()<br/>{<br/> gl_Position = projection * view * model * vec4(position, 1.0f);<br/>}</pre>
<ol start="3">
<li>Next, we'll go to <kbd>lighting.frag</kbd> and carry out the modifications as in the following code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>out vec4 color;<br/><br/>uniform vec3 objectColor;<br/>uniform vec3 lightColor;<br/><br/>void main()<br/>{<br/>    color = vec4(lightColor * objectColor, 1.0f);<br/>}</pre>
<p style="padding-left: 60px">In the preceding code, <kbd>objectColor</kbd>, the variable that we have added, will contain the color of the object itself, which is the cube in our example.</p>
<ol start="4">
<li>Save both the files, and now we'll create shader files for our lamp.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating shader files for the lamp</h1>
                </header>
            
            <article>
                
<p>Take a look at the following steps to see how to create lamp shaders:</p>
<ol>
<li>Duplicate the files that we've updated in the preceding steps and rename them <kbd>lamp.vs</kbd> and <kbd>lamp.frag</kbd>, and we'll need to modify some code in these new files to create our light source.</li>
<li>We won't be making any modifications to <kbd>lamp.vs</kbd> as we need the updated code as it is.</li>
<li>We need to make some modifications to <kbd>lamp.frag</kbd>, so take a look at the highlighted terms in the following code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>out vec4 color;<br/><br/>void main()<br/>{<br/>    color = vec4(1.0f); // Set all 4 vector values to 1.0f<br/>}</pre>
<p>The reason we have passed the value to <kbd>vec4</kbd> as <kbd>1.0f </kbd> is so that all the vector values should be set to <kbd>1.0f</kbd>, which is red, green, blue, and alpha at high intensity. So, it'll be fully on. If you have full red, full green, and full blue, you get white. Thus, our lamp will emit white light.  </p>
<p>You might have done an experiment in high school where you get all the different colors of the rainbow on a circle, and if you spin it fast enough, the combined color looks white. It's a pretty cool experiment, and you probably could do that at home. It's worth checking that out, just in general, it's a fun thing to do.</p>
<p>So, now that we've got our shader files all set up for lighting and lamp we'll move on to our main code in the <kbd>main.cpp</kbd> file to add an object and light source to our game world.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying the main code to implement a cube and a light source </h1>
                </header>
            
            <article>
                
<p>Now that we have created new shader files for our project we'll next work on our main code and add a colored cube and a light source to our game world. In this section, we'll also take a look at how to reference our newly created shader files in the code. Here, we'll work on the code from the previous chapter and make modifications to it. Perform the following steps to understand the changes made to the code:  </p>
<ol>
<li>The first thing that we're going to do, before our <kbd>int main()</kbd>, is add <kbd>glm::vec3 lightPos();</kbd>. So, this is going to be the position of the source of light in our world. We'll pass following coordinates to the function  <kbd>lightpos()</kbd>: <kbd>1.2f</kbd>, <kbd>1.0f</kbd>, and <kbd>2.0f</kbd>. The way this works is you have light emitting from a particular location, for example, if you load in a light bulb as a source and you place it at the defined location. The light bulb itself is a light source for our world. </li>
<li>Next,  we'll go to the section where we've defined our shader. As we've added new shaders to our project, we'll have to reference them in the code. </li>
<li>Now that we've got a couple of shaders, what we're going to do is duplicate the <kbd>Shader ourShader(  );</kbd> function present in our code and rename it <kbd>lightingShader</kbd> and <kbd>lampShader</kbd>. Obviously, we'll need to update the path mentioned so as to reference our lighting and lamp shader files. Have a look at the following highlighted code:</li>
</ol>
<pre style="padding-left: 60px">  Shader <strong>lightingShader</strong>( <strong>"res/shaders/lighting.vs"</strong>,<br/>  <strong>"res/shaders/lighting.frag"</strong> );<br/>  Shader <strong>lampShader</strong>( <strong>"res/shaders/lamp.vs"</strong>, <strong>"res/shaders/lamp.frag"</strong> );</pre>
<ol start="4">
<li>Next, for the vertices, what we're going to do is remove all the texture coordinates <span>present in our array. A</span>s we're not rendering any texture in this code and we only need the x, y, and z coordinates to describe our cube.  You can refer to the updated vertices in the <kbd>main.cpp</kbd> file present in the <kbd>colours</kbd> folder in the <kbd>Chapter04</kbd> folder.   </li>
</ol>
<ol start="5">
<li>Then we'll get rid of the <kbd>cubePositions []</kbd> array as we're going to be rendering a single cube in our world. This will make it easier for us to understand the effect of light on our object.  </li>
<li>Next, in the code, where we've defined our vertex buffer objects and vertex array objects, we'll make the following modifications to it:</li>
</ol>
<pre style="padding-left: 60px"> // First, set the container's VAO (and VBO)<br/>    GLuint VBO, boxVAO;<br/>    glGenVertexArrays( 1, &amp;boxVAO );<br/>    glGenBuffers( 1, &amp;VBO );</pre>
<p style="padding-left: 60px">The reason we made this modification is we're going to have a vertex buffer object that we'll just reuse, but for the vertex array object, there'll be a different one for each individual shader and the box.</p>
<ol start="7">
<li>Now, in the position attribute, we'll update the <kbd>5 * sizeof()</kbd> to <kbd>3 * size of()</kbd> as we no longer have five pieces of information in a row in the vertex array, which were the 3:  <em>x</em>, <em>y</em>, and <em>z</em> coordinates and the two texture coordinates. Now, as we are no longer using texture cooordinates we only have <em>x</em>, <em>y</em>, and <em>z</em> coordinates in the array. </li>
<li>Next,  we'll get rid of the texture coordinate attribute because we're no longer loading textures in our code.</li>
<li>Then what we're going to do is duplicate the vertex defining code, vertex binding code, and the position attribute code and paste in below the position attribute code. And in these duplicated lines of  code we'll make the following highlighted changes to add the light vertex array object to our main code:</li>
</ol>
<pre style="padding-left: 60px">// Then, we set the light's VAO (VBO stays the same. After all, the vertices are the same for the light object (also a 3D cube))<br/>    <br/>GLuint <strong>lightVAO</strong>;<br/>glGenVertexArrays( 1, <strong>&amp;lightVAO</strong> );<br/>glBindVertexArray( <strong>lightVAO</strong> );<br/>   <br/> // We only need to bind to the VBO (to link it with glVertexAttribPointer), no need to fill it; the VBO's data already contains all we need.<br/>   <br/> glBindBuffer( GL_ARRAY_BUFFER, VBO );<br/>    <br/>// Set the vertex attributes (only position data for the lamp)<br/><br/>glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof( GLfloat ), ( GLvoid * )0 );<br/>glEnableVertexAttribArray( 0 );<br/>glBindVertexArray( 0 );</pre>
<ol start="10">
<li>The next thing that we're going to do is get rid of the entire create and load texture code.</li>
<li>In the previous chapter, we had added the projection matrix within the loop and it was declared every single time the loop ran. Now, <span>because we're getting the field of view using GetZoom</span> we can't place the projection matrix in the loop. So, as a result, we might as well just get the projection matrix code out of the loop and paste it at start of the while loop.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifications to the while loop</h1>
                </header>
            
            <article>
                
<p>There's a few things that we need to change inside the while loop, so let's take a look: </p>
<ol>
<li>First of all, we're going to change the background color so we have a darker background so that the lighting that we are trying to implement will have more of effect on our object. So, we'll make the following modifications to the <kbd>glClearColor ()</kbd> function: </li>
</ol>
<pre style="padding-left: 60px">glClearColor( <strong>0.1f, 0.1f, 0.1f, 1.0f</strong>  );</pre>
<ol start="2">
<li>What we're going to do next is get rid of all the code from the point where we defined our bind texture code to the point where we define our draw container code and add the fresh code. </li>
<li>So, what we're going to do is use the corresponding shader to set the uniform objects and draw the object's code. First of all, what we're going to add <kbd>lightingShader.Use();</kbd> as we're handling the lighting shader of the box. Then we're going to create a <kbd>GLuint</kbd> variable, <kbd> objectColorLoc</kbd>, and to this we'll assign the value of function <kbd>glGetUniformLocation ()</kbd>, which will consists of parameter such as <kbd>lightingShader.Program</kbd> and <kbd>"objectColor"</kbd></li>
</ol>
<div class="packt_infobox">As usual, if you would like to know more details about what we're discussing, you can check out <a href="http://learnopengl.com">learnopengl.com</a> and <a href="http://open.gl">open.gl</a>.  They've got some well-written tutorials on there and they've got images to accompany those tutorials, and it's a great way of learning on top of these chapters.</div>
<ol start="4">
<li>Next, we're going to duplicate the preceding line of code and make the highlighted modifications to it: </li>
</ol>
<pre style="padding-left: 60px">lightingShader.Use( );<br/>GLint objectColorLoc = glGetUniformLocation( lightingShader.Program, "objectColor" );<br/>GLint <strong>lightColorLoc</strong>  = glGetUniformLocation( <strong>lightingShader.Program</strong>, <strong>"lightColor"</strong> );</pre>
<ol start="5">
<li>Then we're going to add function <kbd>glUniform3f()</kbd>and to that we're uniforming the object color location. So, we'll pass the parameters as  <kbd>objectColorLoc</kbd>  and <kbd>1.0f</kbd>, <kbd>0.5f</kbd>, <kbd>0.31f</kbd>.<br/>
These are obviously just arbitrary values that we have been determined, and they actually work well. Obviously in your future projects, when you're not following the chapter, you can try experimenting with the values. We'll just duplicate the preceding line of code and make the following highlighted changes to it:</li>
</ol>
<pre style="padding-left: 60px">glUniform3f( objectColorLoc, 1.0f, 0.5f, 0.31f );<br/>glUniform3f(<strong> lightColorLoc</strong>,<strong>  1.0f, 0.5f, 1.0f </strong>);</pre>
<ol start="6">
<li> And now we're going to create a camera transformation. So, we'll add the view matrix<kbd>glm::mat4 view;</kbd> to our code and then type <kbd>view = camera.GetViewMatrix</kbd>.</li>
<li>Next, we're going to get the uniform location for the model, view, and projection matrix. So, we're going to type <kbd>GLint modelLoc = glGetUniformLocation();</kbd> . And in there, we are going to pass <kbd>lightingShader.Program</kbd> and <kbd>model</kbd>.<br/>
We'll just duplicate this preceding code a couple of times and make the highlighted changes to it, as follows:</li>
</ol>
<pre style="padding-left: 60px">// Create camera transformations<br/>glm::mat4 view;<br/>view = camera.GetViewMatrix( );<br/><br/>// Get the uniform locations<br/>GLint modelLoc = glGetUniformLocation( lightingShader.Program,"model");<br/><strong>GLint viewLoc = glGetUniformLocation( lightingShader.Program,"view");</strong><br/><strong>GLint projLoc = glGetUniformLocation( lightingShader.Program, "projection" );</strong></pre>
<ol start="8">
<li>And now we're going to pass the matrices to the shader. So now, we just need to add <kbd>glUniformMatrix4fv();</kbd>.  And to this function, we'll pass <kbd>viewLoc</kbd>, <kbd>1</kbd>, <kbd>GL_FALSE</kbd>,  <kbd>glm::value_ptr()</kbd> and for the value pointer function, you just specify our 4x4 view matrix.</li>
<li>Duplicate the preceding line of code, as we need to do the same for projection matrix. Check out the following code and the highlighted terms in it: </li>
</ol>
<pre style="padding-left: 60px">// Pass the matrices to the shader<br/>glUniformMatrix4fv( viewLoc, 1, GL_FALSE, glm::value_ptr( view ) );<br/>glUniformMatrix4fv( <strong>projLoc, 1, GL_FALSE, glm::value_ptr( projection )</strong> );</pre>
<ol start="10">
<li>Now what we're going to do is draw the container using the container's vertex attributes, simple stuff, we've covered this in previous chapters. If you want to review them, feel free. Take a look at the following code: </li>
</ol>
<pre style="padding-left: 60px">// Draw the container (using container's vertex attributes)<br/>glBindVertexArray( boxVAO );<br/>glm::mat4 model;<br/>glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );<br/>glDrawArrays( GL_TRIANGLES, 0, 36 );<br/>glBindVertexArray( 0 );</pre>
<p style="padding-left: 60px"><span>In the preceding code, we put 36. The reason for this is, as there are a total of 36 vertices, 6 per side, and there are 6 sides to a cube, so we passed 36 in the function <kbd>glDrawArrays()</kbd>.</span></p>
<ol start="11">
<li>Next, what we'll do is duplicate the code that we have described in the previous steps and paste it below the preceding code. Then we'll carry out the following highlighted changes for the lamp shader:</li>
</ol>
<pre style="padding-left: 60px">// Also draw the lamp object, again binding the appropriate shader<br/><strong>lampShader.Use( )</strong>;<br/>        <br/>// Get location objects for the matrices on the lamp shader (these could be different on a different shader)<br/>modelLoc = glGetUniformLocation( <strong>lampShader.Program</strong>, "model" );<br/>viewLoc = glGetUniformLocation( <strong>lampShader.Program</strong>, "view" );<br/>projLoc = glGetUniformLocation( <strong>lampShader.Program</strong>, "projection" );<br/>        <br/>// Set matrices<br/>glUniformMatrix4fv( viewLoc, 1, GL_FALSE, glm::value_ptr( view ) );<br/>glUniformMatrix4fv( projLoc, 1, GL_FALSE, glm::value_ptr( projection ) );<br/>model = glm::mat4( );<br/>model = glm::translate( model, lightPos );<br/>model = glm::scale( model, glm::vec3( 0.2f ) ); // Make it a smaller cube<br/>glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );<br/>        <br/>// Draw the light object (using light's vertex attributes)<br/>glBindVertexArray( lightVAO );<br/>glDrawArrays( GL_TRIANGLES, 0, 36 );<br/>glBindVertexArray( 0 );</pre>
<p style="padding-left: 60px">In the preceding code, in <kbd>glm::vec3( 0.2f )</kbd> we added 0.2f as we wanted to scale it by <kbd>0.2f</kbd> on every axis. The reason we're scaling it is because we don't want our light source, our lamp, to be the same size as our cube. It's just the way we perceive the world. Generally speaking, a bulb is smaller than most things in the room that we perceive.</p>
<ol start="12">
<li>And now, the only thing we need to do is update <kbd>glDeleteVertexArrays()</kbd>. We'll update that as follows:</li>
</ol>
<pre style="padding-left: 60px">glDeleteVertexArrays( 1, <strong>&amp;boxVAO</strong> );<br/>glDeleteVertexArrays( 1, <strong>&amp;lightVAO</strong> );<br/>glDeleteBuffers( 1, &amp;VBO );</pre>
<p>We're now ready to run and see our masterpiece. Check the output on your window: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-358 image-border" src="assets/5d15334a-f35e-41fa-8437-e5ee6ce04d6f.png" style=""/></div>
<p>We've got this sort of red-looking box and we've got our white light source. It doesn't look like it's really emitting any light, but this is just the basics. But this is a nice precursor to future sections, and just the future of creating really cool lighting effects.</p>
<p>In the next section, we're going to look at some really cool basic lighting that will make this look a lot better. So, we recommend you do an extra task in the code: figure out where you can change the color of our object and the light emitting object. So, that's it for just basic colors in lighting within modern OpenGL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lighting up objects </h1>
                </header>
            
            <article>
                
<p>In this section, we'll be looking at basics of lighting because so far, if you look at the results from our previous section, which just discussed colors, what we've got is the cube and the light source. At the moment, the entire color in the cube output just looks uniform. It almost doesn't look like a cube, a six-sided shape figure, and the lighting doesn't look very realistic too. Because realistically, in our example, the light source doesn't emit light onto our cube and there is no effect of light and shadow on the cube. So, in this section we'll discuss the basics of lighting and effect on the cube. We'll focus on improving the lighting system so we can have a more realistic effect.</p>
<p>So, let's get started. As usual, we'll begin making modifications to our shader files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the shaders</h1>
                </header>
            
            <article>
                
<p>Check out the following steps to understand the changes made to the shaders:</p>
<ol>
<li>We're not going to be changing anything in the lamp shader files because we're happy with the actual light that's being emitted.</li>
<li>Next, what you want to do is go to your lighting vertex shader and, essentially, change the way our cube perceives the light, and that will make the object look different. So, if you go to our lighting vertex shader, this doesn't require many changes. Take a look at the following highlighted code: </li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>layout (location = 0) in vec3 position;<br/>layout (location = 1) in vec3 normal;<br/><br/>out vec3 Normal;<br/>out vec3 FragPos;<br/><br/>uniform mat4 model;<br/>uniform mat4 view;<br/>uniform mat4 projection;<br/><br/>void main()<br/>{<br/>    gl_Position = projection * view *  model * vec4(position,<br/>    1.0f);<br/>    FragPos = vec3(model * vec4(position, 1.0f));<br/>    Normal = mat3(transpose(inverse(model))) * normal;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are normals ?</h1>
                </header>
            
            <article>
                
<p>So, let's first understand what <span>normals </span>are. So, normals are basically a direction. They're perpendicular to a particular surface: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-359 image-border" src="assets/7d405d0c-d251-4523-a882-b91bc7c8613e.png" style=""/></div>
<p>So, as you can see in the preceding diagram, the normals are at 90 degrees to the surface, and this is useful when calculating lighting because it determines the way light bounces off the surface, the way the surface reacts to light, and as a result, it looks a certain way. A powerful technique is to change the direction of the normals, which you can do (we'll be covering that in later sections) and that allows you to change the way that the light reacts to it, which makes the object look different. And what we can even do is have, let's say, a flat object, or a relatively flat object with a very low polygon count and by changing the normals, we can add the illusion of depth to it. That's the reason why when you play a game sometimes and you see some sort of object, especially when it's on a wall, it's relatively flat, but it looks like it has a bit of depth to it. If you're quite far away from it, it looks like it's got depth. When you go close, and especially when you look at it from an angle, it doesn't have depth anymore, or it has very little depth. And that's the limitation of this system. Obviously, if you want to get around that, you need to use some sort of tessellation technique that actually has real geometry. That's obviously a lot more expensive in terms of processing power. This is a lot cheaper in terms of processing power, so this is really preferred in the gaming industry, simply because you're not just drawing one sort of simple shape. You're drawing a whole heap of polygons, which this technique will allow you to reserve some processing power.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the lighting.frag shader</h1>
                </header>
            
            <article>
                
<p>Let's follow the below mentioned steps: </p>
<ol start="1">
<li>So now that we've done this, we go to the lighting fragment shader and make the following highlighted changes to it:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>out vec4 color;<br/>in vec3 FragPos;<br/>in vec3 Normal;</pre>
<p style="padding-left: 60px">In the preceding code, we added <kbd>FragPos</kbd>, as those are going to be the fragment positions that we were sending out from the vertex shader.</p>
<ol start="2">
<li>Then we created uniform vector variables as follow: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px">uniform vec3 lightPos;<br/>uniform vec3 viewPos;<br/>uniform vec3 lightColor;<br/>uniform vec3 objectColor;</pre>
<p style="padding-left: 60px">In the preceding code, we added <kbd>lightPos</kbd> as we needed a vector for the light position because we are factoring the light position and the lighting will vary depending on what part of the surface you're looking at.</p>
<p>And in our main function there are three types of lighting techniques that we'll be using as shading techniques, and they will be ambient, diffuse, and specular. We'll discuss them in detail and also understand how to define them in our code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> Ambient lighting</h1>
                </header>
            
            <article>
                
<p>The first one, which is ambient lighting, is just like the general lighting that's in a scene. It's not like the light from the sun, but it's general light that is always bouncing around the room. It doesn't have a particular origin or a position or direction.  So that allows it to provide some basic sort of color, some basic property to your object. On top of that, you add diffuse lighting and specular lighting to make the object a unique and interesting object to make it look more like what it would in the real world. </p>
<p>We'll begin by adding <kbd>float ambientStrength</kbd>, and to that we will add value of <kbd>0.1f</kbd>. Feel free to change that value and see what happens, see the limitations of the variables as well. And then we're going to add <kbd>vec3</kbd> for the ambient lighting. That variable is going to equal to <kbd>ambientStrength * lightColor</kbd>:</p>
<pre class="mce-root">void main()<br/>{<br/> // Ambient<br/> float ambientStrength = 0.1f;<br/> vec3 ambient = ambientStrength * lightColor;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diffuse lighting</h1>
                </header>
            
            <article>
                
<p>Now we're going to do diffuse lighting. Diffuse lighting takes into account the direction and the normal of the light. For example, imagine our cube, the corner which is nearer to the light source will be brighter compared to the corner that is furthest away. Essentially, what <span>is </span>diffuse lighting? It adjusts the actual position and the angle as well. It's to do with the angle as well, so if you were to have a light source at 90 degrees, that would emit more light than, let's say, one at 5 degrees, and 90 degrees would be shinier. That's essentially what diffuse is. You don't generally just have ambient, diffuse, or specular lighting. You have all three combined, at different intensities and different strengths, and that allows you to create a realistic effect called combined lighting, and this effect is very often known as Phong shading. You can read about it on the internet. Take a look at the following code for diffuse light:</p>
<pre class="mce-root">// Diffuse<br/> vec3 norm = normalize(Normal);<br/> vec3 lightDir = normalize(lightPos - FragPos);<br/> float diff = max(dot(norm, lightDir), 0.0);<br/> vec3 diffuse = diff * lightColor;</pre>
<p class="mce-root">In the preceding code, we added <kbd>lightPos - FragPos</kbd>. The difference between these will tell you the direction in which the light is pointing. At the end of code we're always going to be factoring in the <kbd>lightColor</kbd> because at the end of the day, if we have a white light shining on something, we don't want it to be blue or red. It has to be what the light is. Obviously, it will vary depending on the actual material that is applied and the sort of properties of that object, but the actual light itself should be a light color. </p>
<p class="mce-root">Now that we've done diffuse lighting, we can go on to specular lighting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specular lighting</h1>
                </header>
            
            <article>
                
<p class="mce-root">To talk about specular lighting, imagine a snooker ball or a pool ball, for example, which has a little circle of light shining on it, it's always that little shiny light on an object. Let's take a look at the code:</p>
<pre class="mce-root">     // Specular <br/>     float specularStrength = 0.5f;<br/>     vec3 viewDir = normalize(viewPos - FragPos);<br/>     vec3 reflectDir = reflect(-lightDir, norm);<br/>     float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);<br/>     vec3 specular = specularStrength * spec * lightColor;<br/> <br/>     vec3 result = (ambient + diffuse + specular) * objectColor;<br/>     color = vec4(result, 1.0f);<br/>}</pre>
<p>Now that we're done updating the shader files, we need to make a minor change in our <kbd>Camera.h</kbd> file. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Minor change in Camera.h </h1>
                </header>
            
            <article>
                
<p>In the <kbd>Camera.h</kbd> file, we don't have any sort of method to get the position of the camera. So, what we'll do is, below <kbd>glfloat GetZoom()</kbd>, we'll add the <kbd>glm::vec3 GetPosition ()</kbd> <span>method </span>and its simply going to return the position. Have a look at the following code: </p>
<pre><span>glm::vec3 GetPosition ()</span><br/>{<br/>    return this -&gt;position<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making changes to the main code</h1>
                </header>
            
            <article>
                
<p>Now we just need to go to our <kbd>main.cpp</kbd> file and make modifications to our code. Take a look at the following steps:  </p>
<ol>
<li>In there, the first thing that we need to modify is this vertices array. At the moment, we have x, y, and z values for each of the vertices, and what we also need to include is the normal. You can refer to the updated vertices in the <kbd>main.cpp</kbd> file present in the <kbd>Basic Lighting</kbd> folder. For reference, just take a look at the vertices of one side of cube: </li>
</ol>
<pre>     //Position             //Normal    <br/>     -0.5f, -0.5f, -0.5f,   0.0f, 0.0f, -1.0f,<br/>      0.5f, -0.5f, -0.5f,   0.0f, 0.0f, -1.0f,<br/>      0.5f, 0.5f, -0.5f,    0.0f, 0.0f, -1.0f,<br/>      0.5f, 0.5f, -0.5f,    0.0f, 0.0f, -1.0f,<br/>     -0.5f, 0.5f, -0.5f,    0.0f, 0.0f, -1.0f,<br/>     -0.5f, -0.5f, -0.5f,   0.0f, 0.0f, -1.0f,</pre>
<p style="padding-left: 60px">The three extra values that we have got in the preceding array are the direction of the normals. The normals will stay the same for every single face.</p>
<div class="packt_infobox">Extra task: Try figuring out which face each one of these normals applies to, and what is the direction once you've rendered it. Modify them, see what happens. <span>Change some of these values, but keep some of them the same. See what happens.</span></div>
<ol start="2">
<li>Once we've got all of that sorted, we just need to change a few things where we have defined our <kbd>VBO</kbd> and <kbd>boxVAO</kbd>. Wherever we have mentioned <kbd>boxVAO</kbd> we'll replace it with <kbd>containerVAO</kbd>:</li>
</ol>
<pre style="padding-left: 60px"> GLuint VBO, <strong>containerVAO</strong>;<br/> glGenVertexArrays( 1, &amp;<strong>containerVAO</strong> );<br/> glGenBuffers( 1, &amp;VBO );<br/> <br/> glBindBuffer( GL_ARRAY_BUFFER, VBO );<br/> glBufferData( GL_ARRAY_BUFFER, sizeof( vertices ), vertices, GL_STATIC_DRAW );<br/> <br/> glBindVertexArray( <strong>containerVAO</strong> );</pre>
<ol start="3">
<li>In the position attribute we will make the following highlighted changes, and similarly, we'll also create our normal attribute. Take a look at the following highlighted code: </li>
</ol>
<pre style="padding-left: 60px">// Position attribute<br/> glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, <strong>6</strong> * sizeof( GLfloat ), ( GLvoid * )0 );<br/> glEnableVertexAttribArray( 0 );<br/> <br/> // Normal attribute<br/><strong> glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );</strong><br/><strong> glEnableVertexAttribArray( 1 );</strong><br/> glBindVertexArray( 0 );   </pre>
<p style="padding-left: 60px">As we've got six different pieces of value on each row of the vertices array, which is the reason why we updated 6 in our code. You will updated the similar value of <kbd>6</kbd> in the <kbd>lightVAO</kbd> position attribute too.</p>
<ol start="4">
<li>Where we are defining our lighting shader in the code, we're using the object color location and the light color location. Now, what we also need to do is add the lighting position location and assign that to our shader program, and also add the view position location. So, what we're going to do is duplicate the whole <kbd>GLint lightColorLoc</kbd> code twice and make the following updates to add the light position location and the view position location. We need to do a similar thing for  <kbd>gluniform3f();</kbd> too. Take a look at the following highlighted code: </li>
</ol>
<pre style="padding-left: 60px">lightingShader.Use( );<br/> GLint objectColorLoc = glGetUniformLocation( lightingShader.Program, "objectColor" );<br/> GLint lightColorLoc = glGetUniformLocation( lightingShader.Program, "lightColor" );<br/><strong> GLint lightPosLoc = glGetUniformLocation( lightingShader.Program, "lightPos" );</strong><br/><strong> GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, "viewPos" );</strong><br/> glUniform3f( objectColorLoc, 1.0f, 0.5f, 0.31f );<br/> glUniform3f( lightColorLoc, 1.0f,<strong> 1.0f</strong>, 1.0f );<br/> <strong>glUniform3f( lightPosLoc, lightPos.x, lightPos.y, lightPos.z );</strong><br/><strong> glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z )</strong></pre>
<p>Once we have got all of this updated, we'll leave rest of the code as it. As we don't have to make any modifications to it.</p>
<p>We should actually be ready to run the code, but remember what it looked like in the previous section. The output that you got on your screen should look some what similar to this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-360 image-border" src="assets/eda92d9c-4f80-46b6-bf1d-34621f6429c9.png" style=""/></div>
<p>As you may have noticed in the preceding image, the top-left side, by the top-left corner, looks a little brighter than the bottom left, and that's because that's where the light source is. And it's definitely evident on the other sides of the cube and on the top. Just take a look at the top compared to other sides. Those sides are darker as they have hardly any light on their surfaces. You can check that out in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-361 image-border" src="assets/7f22e1fe-fc8f-4de7-8686-f660c811c153.png" style=""/></div>
<p>It's just, it's a lot more realistic than it was before. You'll also notice as you move across it, you will get to see the beautiful dynamic shading on our cube.</p>
<p>So what we're going to do now is go to the lighting fragment shader and change the <kbd>specularStrength</kbd> to <kbd>2.0f</kbd>. Just modify this stuff up, and just observe the output that will have, take a look at the following screenshot: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-362 image-border" src="assets/97f65da2-3a9e-497b-831a-e3425a5c72ec.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign">You can already see the sort of impact that change of value in the code had on the intensity of light. Look at that shine. That's the sort of shine that you get on a pool ball. Try experimenting with the value. If you change the value of <kbd>ambientStrength</kbd> to <kbd>0.5f</kbd> you'll see a brighter cube: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-363 image-border" src="assets/277ac086-96de-454a-9f26-3d2003c91835.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign">This is almost looking more like a uniform color now, but it looks quite cool as well. Try experimenting by changing the values in your shader files and the main code. </p>
<p class="CDPAlignLeft CDPAlign">One last thing that we'll try doing is to move the light position so you can actually sort of see what effect it has on our object. So, in our main code, at the start of while loop, we'll add <kbd>lightPos.x -= 0.01f</kbd>, and we're going to do the same for the z position:</p>
<pre>lightPos.x -= 0.01f<br/><span>lightPos.z -= 0.01f</span></pre>
<p class="CDPAlignLeft CDPAlign">We're not going to modify the y position because we sort of only want the light source to move along the horizon. You could make it move along the y axis as well; we recommend you do that. Try and make a circle around it. Save the changes and run the code. You'll observe the following output on your screen: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-364 image-border" src="assets/ebea6b88-3895-4fbb-a98d-d842141e63f4.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign">As you can see, we've got a light and as it's getting further away, the top side is getting dark because it's at a really obscure angle. As it's getting further and further away, you will observe that the top side gets darker and darker: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-365 image-border" src="assets/95c803f5-cbf7-4e45-acc2-1c05c3425228.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign">As an extra task, we recommend trying to move the light as far as you can and observe the effect. It would be fantastic if you could get it to rotate around the object itself and try adding multiple lights. That will create an awesome effect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Materials</h1>
                </header>
            
            <article>
                
<p>We're going to discuss materials in this section. So, let's first understand what a material is and why would you use it. In the real world, you have objects that are made out of different materials. You have objects that are made out of metals, wood, plastic, and other stuff. As a result, these materials, these objects, react differently to light depending on what they're made out of. Generally speaking, something that's made out of metal will be shinier than something that's made out of wood. Wood generally isn't shiny. Obviously, it is if you apply some sort of varnish to it, but again, that would be an additional layer to the object that's not wood. It'd be something more than wood that is applied on top of it that provides some sort of shine to it. You have glossy materials, and you have some more matte materials. Simply put, materials in OpenGL will allow us to create objects that react differently to light, and as a result, create more realistic and varied effects in our game or application. And that's why you would use it, to get a more varied and realistic representation of the objects you are trying to create.</p>
<p>So, let's get started...</p>
<p>As few prerequisites. This section is using the source code from the previous section, which was covering basic lighting. If you haven't got the code for that, feel free to check out the GitHub link in the preface for the code files. The other thing we want to mention is that these chapters are based on the work of learnopengl.com and open.gl. They're using a fantastic illustrations to explain what we're doing. Also, feel free to check out their pages because they've got some great information. They go into really great depth into the code that we have discussed in all the chapters. So, it's just a great way of enhancing the knowledge you already know.</p>
<p>What we're going to do in this section is make the cube cycle through various different materials. We'll begin by updating the shader files. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating shader files for Materials</h1>
                </header>
            
            <article>
                
<p> Take a look at the following steps</p>
<ol>
<li>We won't make any changes to the vertex shader, that is, <kbd>lighting.vs</kbd>.</li>
<li>Next, we'll move onto the lighting fragment shader and in here, right at the top, we're going to create a data type <kbd>struct</kbd> called <kbd>Material</kbd>. In there, we're going to have three varibles <kbd>vec3</kbd>, which are going to be the <kbd>ambient</kbd>, the <kbd>diffuse</kbd>, the <kbd>specular</kbd>, and the <kbd>shininess</kbd> <span>float</span>, so we can easily change the intensity of the specular light. Take a look at the following code:  </li>
</ol>
<pre style="padding-left: 60px"><strong>struct Material</strong><br/><strong>{</strong><br/><strong>     vec3 ambient;</strong><br/><strong>     vec3 diffuse;</strong><br/><strong>     vec3 specular;</strong><br/><strong>     float shininess;</strong><br/><strong>};</strong></pre>
<ol start="3">
<li>Next, we're going to create a datatype struct for Light. This is going to have a <kbd>vec3</kbd> of position and it's going to have three more <kbd>vec3</kbd> for ambient, diffuse, and specular:</li>
</ol>
<pre style="padding-left: 60px"><strong>struct Light</strong><br/><strong>{</strong><br/><strong>     vec3 position;</strong><br/> <br/><strong>     vec3 ambient;</strong><br/><strong>     vec3 diffuse;</strong><br/><strong>     vec3 specular;</strong><br/><strong>};</strong></pre>
<div class="packt_infobox">If you want to know a bit more about what ambient, diffuse, and specular are, feel free to check out the previous the sections. Or, feel free to go to learnopengl.com and open.gl. These sites provide a lot of information.</div>
<ol start="4">
<li>Then, we'll get rid of the <kbd>lightPos</kbd> because we have it within the preceding struct. We don't want <kbd>objectColor</kbd>, and also we don't want <kbd>lightColor</kbd> as well, because again, we've got it all within our struct. Then we'll add <kbd>uniform Material material</kbd> and we also add <kbd>uniform Light light</kbd>:</li>
</ol>
<pre style="padding-left: 60px">uniform vec3 viewPos;<br/><strong>uniform Material material;</strong><br/><strong>uniform Light light;</strong></pre>
<ol start="5">
<li>And now, in <kbd>void main()</kbd>, what are we going to do ? For the ambient light, we'll get rid of the <kbd>ambientStrength</kbd> and we'll modify it as <kbd>Vec3 ambient = light.ambient * material.ambient</kbd>.</li>
<li>And for the diffuse light, <kbd>vec3 lightDir</kbd><span>, we need to change that up a bit. Take a look at the highlighted terms: </span></li>
</ol>
<pre style="padding-left: 60px">vec3 lightDir = normalize(<strong>light.position</strong> - FragPos);</pre>
<ol start="7">
<li>And for the final diffuse calculation, all we need to do is change it up slightly. We need to add <kbd>light.diffuse</kbd> multiplied by <kbd>diff</kbd>, which was calculated here in the float variable, and <kbd>diff</kbd> multiplied by <kbd>material.diffuse</kbd>. We are factoring in material in every single part of our lighting, our shading, simply because that's what's important. That's the way that our actual object will look, or that part of the object, because we have different materials applied.</li>
<li>In specular, we can get rid of <kbd>specularStrength</kbd> because we've got that in the previous code. Then we'll update <kbd>float spec</kbd> for the shininess; we'll add <kbd>material.shininess</kbd>. For <kbd>vec3 specular</kbd>, we are changing that up slightly. We're going to add <kbd>light.specular * (spec * material.specular)</kbd>. And for the result, we'll modify that as highlighted in the following code: </li>
</ol>
<pre style="padding-left: 60px">void main()<br/>{<br/> // Ambient<br/> vec3 ambient = light.ambient * material.ambient;<br/> <br/> // Diffuse<br/> vec3 norm = normalize(Normal);<br/> vec3 lightDir = normalize(light.position - FragPos);<br/> float diff = max(dot(norm, lightDir), 0.0);<br/> vec3 diffuse = light.diffuse * (diff * material.diffuse);<br/> <br/> // Specular<br/> vec3 viewDir = normalize(viewPos - FragPos);<br/> vec3 reflectDir = reflect(-lightDir, norm);<br/> float spec = pow(max(dot(viewDir, reflectDir), 0.0), <strong>material.shininess</strong>);<br/> vec3 specular = <strong>light.specular * (spec * material.specular)</strong>;<br/> <br/> vec3 result = <strong>ambient + diffuse + specular</strong>;<br/> color = vec4(result, 1.0f);<br/>}</pre>
<p>Save these changes, and now we are done updating the fragment shader. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making changes to the main code to add materials to our object</h1>
                </header>
            
            <article>
                
<p>Follow the below mentioned steps to add materials to our object and observe the effects of light on it: </p>
<ol>
<li>If you go to <kbd>main.cpp</kbd>, what you want to do is actually go straight to the while loop, because everything outside of that should is fine and doesn't need any modification. </li>
<li>So, in lines of code below <kbd>lightingShader.Use();</kbd>, we'll get rid of <kbd>objectColorLoc</kbd> and <kbd>lightColorLoc</kbd>. We want <kbd>lightPosLoc</kbd>, but a parameter in it needs to be changed to <kbd>light.position</kbd> because we've updated that in our fragment shader.</li>
<li>In <kbd>gluniform3f</kbd> you can get rid of <kbd>objectColorLoc</kbd> and <kbd>lightColorLoc</kbd>.</li>
</ol>
<ol start="4">
<li>Now we need to also set the light's properties. For that, we'll add <kbd>glm::vec3 lightColor;</kbd> and we'll add <kbd>lightColor.r = sin();</kbd>, and for <kbd>sin()</kbd>, this is where we're going to have some framework-specific code. We're just going to be pass <kbd>glfwGetTime()</kbd>, which just gets the amount of time that has passed since GLFW was initialized. We'll just multiply<span> </span><kbd>glfwGetTime()</kbd> by <kbd>2.0f</kbd><span>. We'll duplicate this line of code, paste it below, and make the following highlighted modification to it: </span></li>
</ol>
<pre style="padding-left: 60px">// Set lights properties<br/> glm::vec3 lightColor;<br/> lightColor.r = sin( glfwGetTime( ) * 2.0f );<br/> <strong>lightColor.g = sin( glfwGetTime( ) * 0.7f );</strong><br/><strong> lightColor.b = sin( glfwGetTime( ) * 1.3f );</strong></pre>
<ol start="5">
<li>So now that <span>we've set the light's properties, we need to actually do the diffuse color and the ambient color. So, we're going to add <kbd>glm::vec3 diffuseColor = lightColor * glm::vec3();</kbd>. And for <kbd>ver3()</kbd>, we're just going to provide a value of <kbd>0.5f</kbd></span>. T<span>his is just going to decrease the influence of the diffuse color.</span></li>
<li><span>Next, we're going to add </span><kbd>glm::vec3 ambientColor = diffuseColor * glm::vec3();</kbd> and over here, <kbd>vec3</kbd> is going to be <span><kbd>0.2f</kbd>, as this is just a low-intensity one. So try some experimenting by modifying these values and see what you come up.</span></li>
<li><span>Then, what we need to add is <kbd>glUniform3f()</kbd> function and to that, we'll pass <kbd>glGetUniformLocation()</kbd></span> function a<span>nd for this function now we're going to</span> specify<span> <kbd>lightingShader.Program </kbd>and </span><kbd>"light.ambient"</kbd><span>. Then we're going to pass <kbd>ambientColor.r</kbd> and similarly, we'll pass  <span><kbd>ambientColor.g</kbd> and <kbd>ambientColor.b</kbd></span>.</span></li>
<li><span>Next, what we'll do is just duplicate the previously described code and make the following highlighted changes to it:</span></li>
</ol>
<pre style="padding-left: 60px">glm::vec3 diffuseColor = lightColor * glm::vec3( 0.5f ); // Decrease the influence<br/>glm::vec3 ambientColor = diffuseColor * glm::vec3( 0.2f ); // Low influence<br/>glUniform3f( glGetUniformLocation( lightingShader.Program, "light.ambient" ), ambientColor.r, ambientColor.g, ambientColor.b );<br/><strong>glUniform3f( glGetUniformLocation( lightingShader.Program, "light.diffuse" ), diffuseColor.r, diffuseColor.g, diffuseColor.b);</strong><br/><strong>glUniform3f( glGetUniformLocation( lightingShader.Program, "light.specular" ), 1.0f, 1.0f, 1.0f );</strong></pre>
<p class="mce-root"/>
<ol start="9">
<li><span>Now we're going to set the material properties, and to do that, we're going to do the ambient, the diffuse, the specular, and the shininess of the material. So, you want to add <kbd>glUniform3f(); </kbd>and to that, we'll pass <kbd>glGetUniformLocation()</kbd></span>, <span>and to this function, we'll specify <kbd>lightingShader.Program</kbd> and the selected <kbd>material.ambient</kbd>. Then we'll pass some values. We're going to just put some explicit values as <kbd>1.0f</kbd>, <kbd>0.5f</kbd>, and <kbd>0.31f</kbd>.</span></li>
<li><span>Just copy and paste the previous code several times and make the following modifications as highlighted in the following code: </span></li>
</ol>
<pre style="padding-left: 60px">// Set material properties<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "material.ambient" ), 1.0f, 0.5f, 0.31f );<br/> <strong>glUniform3f( glGetUniformLocation( lightingShader.Program, "material.diffuse"), 1.0f, 0.5f, 0.31f );</strong><br/><strong> glUniform3f(glGetUniformLocation( lightingShader.Program, "material.specular" ), 0.5f, 0.5f, 0.5f ); // Specular doesn't have full effect on this object's material</strong><br/><strong> glUniform1f(glGetUniformLocation( lightingShader.Program, "material.shininess" ), 32.0f );</strong></pre>
<p><span>In the preceding code, while defining shininess we have added just  1 float value in <kbd>glUniform1f()</kbd> because the shininess wasn't a vector or an array, or anything like that.</span></p>
<p>Now we are all set with the code. So let's run this code and check the output that we get on our screen. You might get a similar output on your window:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-366 image-border" src="assets/79a6f756-ddd5-49dd-8106-7c41159bf02c.png" style=""/></div>
<p>You'll observe a color changing cube on your screen. <span>It looks exactly the way we want, just beautiful. Try moving the light and observe the shadow effect on the surface of the cube:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-367 image-border" src="assets/857c756f-b5d4-4227-b71b-9928afee774b.png" style="width:19.83em;height:20.92em;"/>  </p>
<p>So that it's for using materials in OpenGL to add effects to our object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lightmaps</h1>
                </header>
            
            <article>
                
<p>Let's discuss lightmaps in this section. But first, let's try to understand what a lighting map <span>is.</span> Well, in the real world, if you have, let's say, a crate that is partly metal and  partly wood, similar to the following screenshot: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/95dea043-fbfc-4160-a359-6d21283a2528.png" style=""/></div>
<p>The wooden parts of it will react differently to the light compared to the metal parts. It might sound obvious, but OpenGL (or any other sort of 3D graphics API) doesn't have a concept of wood or metal or plastic, or anything else and as a result, we need to program that in. We need to use other techniques to help illustrate that visually as the wood should be less shiny than the metal parts of the crate. If you search on lighting maps, you'll get a bunch of information. You can create them in various tools. You can use Maya or Photoshop to create them. So, without further ado, let's get down to the coding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making modifications to shader files</h1>
                </header>
            
            <article>
                
<p>Follow the below mentioned steps:  </p>
<ol>
<li>So, what you want to do is go to the lighting vertex shader. We need to make a few modifications to this because we removed the ability to apply textures, and we didn't do that in the last couple of sections. So, we need to add that again. Take a look at the following modification to understand the changes made to the code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>layout (location = 0) in vec3 position;<br/>layout (location = 1) in vec3 normal;<br/><strong>layout (location = 2) in vec2 texCoords;<br/></strong><br/>out vec3 Normal;<br/>out vec3 FragPos;<br/><strong>out vec2 TexCoords;<br/></strong><br/>uniform mat4 model;<br/>uniform mat4 view;<br/>uniform mat4 projection;<br/><br/>void main() <br/>{<br/>     gl_Position = projection * view * model * vec4(position,<br/>     1.0f);<br/>     FragPos = vec3(model * vec4(position, 1.0f));<br/>     Normal = mat3(transpose(inverse(model))) * normal;<br/>  <strong>   TexCoords = texCoords;</strong><br/>}</pre>
<p style="padding-left: 60px">Save these changes, and now we need to do a modification to the fragment shader. </p>
<ol start="2">
<li>In <kbd>lighting. frag</kbd>, we'll make the following changes to the code:  We'll get rid of all the code from the struct material and add fresh code to it. We'll add <kbd> sampler2D diffuse</kbd> and <kbd>sampler2D specular</kbd>, and this is that specular lightmap that had the light part and the dark part on it. Then we'll add <kbd>float shininess</kbd>. Shininess is always important:</li>
</ol>
<pre style="padding-left: 60px">struct Material<br/>{<br/>     sampler2D diffuse;<br/>     sampler2D specular;<br/>     float shininess;<br/>};  </pre>
<ol start="3">
<li> For the input, we also need the texture coordinate. So we'll add <kbd>in vec2 TexCoords</kbd>:</li>
</ol>
<pre style="padding-left: 60px">struct Light<br/>{<br/>     vec3 position;<br/> <br/>     vec3 ambient;<br/>     vec3 diffuse;<br/>     vec3 specular;<br/>};<br/><br/>in vec3 FragPos;<br/>in vec3 Normal;<br/><strong>in vec2 TexCoords;<br/><br/></strong>out vec4 color;<br/><br/>uniform vec3 viewPos;<br/>uniform Material material;<br/>uniform Light light;</pre>
<ol start="4">
<li>Now, <kbd>void main ()</kbd> in vec3 ambient needs to change slightly because we are using a texture. So, what we need to do is just get rid of <kbd>material.ambient</kbd> and add <kbd>vec3()</kbd> and inside that, we want to specify <kbd>texture()</kbd>. Inside this method, we're going to pass <kbd>material.diffuse </kbd> and <kbd>TexCoords</kbd>.</li>
</ol>
<ol start="5">
<li>Now, for the diffuse light in the final calculation, <kbd>(diff * material.diffuse)</kbd> needs to change slightly, as we are using textures now. So, what we're going to do is just get rid of the preceding term and add <kbd>light.diffuse * diff *  vec3()</kbd>. To that, we'll pass <kbd>texture()</kbd>, and in that, we'll specify <kbd>material.diffuse</kbd> and  <kbd>TexCoords</kbd>. The rest all is good. Let's go down to specular now. In the final step, we just need to change it in a similar way to the previous one because we are using a texture now. Take a look at the following code to understand the description: </li>
</ol>
<pre style="padding-left: 60px">void main()<br/>{<br/>     // Ambient<br/>     vec3 ambient = light.ambient * vec3(texture(material.diffuse,<br/>    TexCoords));<br/> <br/>     // Diffuse<br/>     vec3 norm = normalize(Normal);<br/>     vec3 lightDir = normalize(light.position - FragPos);<br/>     float diff = max(dot(norm, lightDir), 0.0);<br/>     vec3 diffuse = light.diffuse * diff *<br/>     vec3(texture(material.diffuse, TexCoords));<br/> <br/>     // Specular<br/>     vec3 viewDir = normalize(viewPos - FragPos);<br/>     vec3 reflectDir = reflect(-lightDir, norm);<br/>     float spec = pow(max(dot(viewDir, reflectDir), 0.0),<br/>     material.shininess);<br/>     vec3 specular = light.specular * spec * <br/>     vec3(texture(material.specular, TexCoords));<br/> <br/>     color = vec4(ambient + diffuse + specular, 1.0f);<br/>}</pre>
<p>So, we're all done with the shaders now. We can actually get to main.cpp.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changes to the main code to implement lightmaps</h1>
                </header>
            
            <article>
                
<p>Let's follow the below mentioned steps to implement the lightmaps:  </p>
<ol>
<li>In the main code, the first thing you'll need to change is the vertices, because at the moment we've got position and we've got the normals as well. We also need to specify the texture coordinates because we now are using a texture. You can refer to the updated vertices in the <kbd>main.cpp</kbd> file inside the <kbd>Lighting Maps</kbd> folder. Copy and paste the updated vertices to our main code.</li>
<li>Next, go to the location where we're binding the vertex and creating the vertex pointers. As we have added a texture system to our code, we need to modify the <span>vertex pointer and the normal attribute </span>slightly. As we've got eight pieces of information in our vertices array, we'll replace the 6 with 8. We also need to duplicate the Normal attribute code, paste it, and modify it for the texture attribute. Take a look at the following code to understand the modifications made:   </li>
</ol>
<pre style="padding-left: 60px"> glBindVertexArray( containerVAO );<br/> glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, <strong>8</strong> * sizeof(<br/> GLfloat ), ( GLvoid * )0 );<br/> glEnableVertexAttribArray( 0 );<br/> glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE,<strong> 8</strong> * sizeof(<br/> GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );<br/> glEnableVertexAttribArray( 1 );<br/> <strong>glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(<br/> GLfloat ), ( GLvoid * )( 6 * sizeof( GLfloat ) ) );</strong><br/><strong> glEnableVertexAttribArray( 2 );</strong></pre>
<ol start="3">
<li>Now let's take a look at the lighting array. In the position attribute, change the 6 to 8 for a similar reason as mentioned in the previous code. </li>
<li>You don't have to necessarily do this before we do the projection, but we are going to. We're just going to load the textures before we define our projection matrix. We're going to create the diffuse and the specular maps as well, since you just load in two different textures. We've covered this before. So, we'll add <kbd>GLuint</kbd>, <kbd>diffuseMap</kbd>, and <kbd>specularMap</kbd>. Then we're adding  <kbd>glGenTextures();</kbd>. And to that, we'll pass the parameters for the <kbd>size</kbd> as <kbd>1</kbd>, and for the <kbd>pointer</kbd> we're going to add <kbd>&amp;diffuseMap</kbd> and copy and paste this code to save some time. W<span>e'll make the following changes </span>to the copied code: </li>
</ol>
<pre style="padding-left: 60px">// Load textures<br/> GLuint diffuseMap, specularMap;<br/> glGenTextures( 1, &amp;diffuseMap );<br/><strong> glGenTextures( 1, &amp;specularMap );</strong></pre>
<ol start="5">
<li>Now we need to create an int for the texture width and height.</li>
<li><span>Then we are going to add <kbd>unsigned char *image</kbd>. This is essentially going to be the data of our image, because if you ever try to open up an image in some sort of text editor, you just get a bunch of characters. This is essentially what this is going to be storing:</span></li>
</ol>
<pre style="padding-left: 60px">int textureWidth, textureHeight;<br/>unsigned char *image;</pre>
<ol start="7">
<li><span>So, now we're going to add the diffuse map. We'll begin by adding <kbd>image = SOIL_LOAD_IMAGE();</kbd>. To this, first of all, we need to specify the file path of the image, which is <kbd>res/images/container2.png</kbd>. For the width and the height parameters, we just specify the <kbd>&amp;textureWidth</kbd> and <kbd>&amp;textureHeight</kbd></span> <span>that we created before, because this is passing it in a reference, and it'll actually modify the original variable right here. For channels, put 0. For <kbd>force_channels</kbd>, just put <kbd>SOIL_LOAD_RGB</kbd>.</span></li>
<li>And in the next line, we need to add <kbd>glBindTexture();</kbd>. The parameter we'll pass for the target is just <kbd>GL_TEXTURE_2D</kbd> and for the texture, we just specify <kbd>diffuseMap</kbd>, because that's the one we're using at the moment.</li>
<li>Now, on the next line we need to add <kbd>glTexImage2D();</kbd>. The parameter we'll pass for the target is just <kbd>GL_TEXTURE_2D</kbd>. For the level, put <kbd>0</kbd>. For the internal format, this is just <kbd>Gl_RGB</kbd> <span>because it's got no alpha. For the width, you just put <kbd>textureWidth</kbd> then <kbd>textureHeight</kbd>. For the border, put <kbd>0</kbd>. For the format, put <kbd>GL_RGB</kbd>. For the type, we're going to put <kbd>GL_UNSIGNED_BYTE</kbd>. For the <kbd>pixels</kbd>, just specify the</span> <span>image</span> <span>data, which is <kbd>image</kbd>.</span></li>
<li><span>Next, we're just going to generate the mipmap, so add  <kbd>glGenerateMipmap();</kbd></span><span>, </span><span>and to that, we're going to pass <kbd>GL_TEXTURE_2D</kbd>.</span></li>
<li><span>Then add <kbd>SOIL_free_image_data()</kbd>. Here, we'll just specify the image that we want to free.</span></li>
<li><span>Next, we just need to specify the texture parameters in terms of the wrapping and the filtering. So, we'll add <kbd>glTextParameteri();</kbd>. For this, we'll pass the target parameter as <kbd>GL_TEXTURE_2D</kbd>. For the <kbd>name</kbd>, for what we're modifying, it is the wrap for now, so pass <kbd>GL_TEXTURE_WRAP_S a</kbd> and then pass  <kbd>GL_REPEAT</kbd>.</span></li>
<li><span>Let's just duplicate this code and paste it below. Check out the following code to understand the modifications we need to make:  </span></li>
</ol>
<pre style="padding-left: 60px"> // Diffuse map<br/> image = SOIL_load_image( "res/images/container2.png", &amp;textureWidth, &amp;textureHeight, 0, SOIL_LOAD_RGB );<br/> glBindTexture( GL_TEXTURE_2D, diffuseMap );<br/> glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image );<br/> glGenerateMipmap( GL_TEXTURE_2D );<br/> SOIL_free_image_data( image );<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );<br/> <strong>glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );</strong><br/><strong> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );</strong><br/><strong> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST_MIPMAP_NEAREST );</strong></pre>
<ol start="14">
<li>And now we're done with defining the diffuse map. What we're going to do next is actually just duplicate all this code for the specular map because it'll be a lot easier and because a lot of it's going to stay the same. Take look at the following highlighted terms to understand the changes:</li>
</ol>
<pre style="padding-left: 60px"><span>// Specular map<br/> image = SOIL_load_image( "<strong>res/images/container2_specular.png</strong>", &amp;textureWidth, &amp;textureHeight, 0, SOIL_LOAD_RGB );<br/> glBindTexture( GL_TEXTURE_2D, <strong>specularMap</strong> );<br/> glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image );<br/> glGenerateMipmap( GL_TEXTURE_2D );<br/> SOIL_free_image_data( image );<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST_MIPMAP_NEAREST );<br/><strong> glBindTexture( GL_TEXTURE_2D, 0 ); </strong></span></pre>
<p style="padding-left: 60px">In the preceding code, at the end we unbound texture by defining<span><kbd>glBindTexture( GL_TEXTURE_2D, 0 );</kbd></span>.</p>
<ol start="15">
<li>And now, we just need to set the <span>texture units for the lighting shader. So, we're going to add <kbd>lightingShader.Use();</kbd>and on the next line we are going to add <kbd>glUniform1i</kbd>, and we're going to specify <kbd>glGetUniformLocation lightingShader.Program</kbd>. And we just need to pass <kbd>material.diffuse</kbd></span> and <kbd>o</kbd>  <span>This is all stuff that we did in the shader, so feel free to look at that again if you just need a quick reminder. We're all good now:</span></li>
</ol>
<pre style="padding-left: 60px">// Set texture units<br/> lightingShader.Use( );<br/> glUniform1i( glGetUniformLocation( lightingShader.Program, "material.diffuse" ), 0 );<br/><strong> glUniform1i( glGetUniformLocation( lightingShader.Program, "material.specular" ), 1 );</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying while loop</h1>
                </header>
            
            <article>
                
<p><span>We can actually start coding stuff within the while loop:</span></p>
<ol>
<li><span>We're going to set the light's properties. So, what we're going to do is just get rid of all of the <kbd>lightColor</kbd> code and we're going to add <kbd>glUniform3f();</kbd>. To that, we'll pass <kbd>glGetUniformLocation()</kbd>, and to this, we'll specify <kbd>lightingShader.Program </kbd>and we just need to specify the first aspect that we're modifying, which is <kbd>light. ambient</kbd>, and we're just going to put some hardcoded values in here: <kbd>0.2f</kbd>, <kbd>0.2f</kbd>, and <kbd>0.2f</kbd>.</span></li>
<li><span>Let's duplicate this so we've got three instances of it and make following modifications to it:</span></li>
</ol>
<pre style="padding-left: 60px"> // Set lights properties<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "light.ambient" ), 0.2f, 0.2f, 0.2f );<br/> <strong>glUniform3f( glGetUniformLocation( lightingShader.Program, "light.diffuse" ), 0.5f, 0.5f, 0.5f );</strong><br/><strong> glUniform3f( glGetUniformLocation( lightingShader.Program, "light.specular" ), 1.0f, 1.0f, 1.0f );</strong></pre>
<ol start="3">
<li><span>So now,</span> let's set the material properties as follows:<span> </span></li>
</ol>
<pre style="padding-left: 60px"> // Set material properties<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "material.shininess"), 32.0f );</pre>
<ol start="4">
<li>Now we need to actually activate our te<span>xtures, and bind them. So below  <kbd>glUniformMatrix4fv();</kbd></span> we'll add following code:</li>
</ol>
<pre style="padding-left: 60px">// Bind diffuse map<br/>    glActiveTexture( GL_TEXTURE0 );<br/>    glBindTexture( GL_TEXTURE_2D, diffuseMap );</pre>
<ol start="5">
<li>And you can copy and paste this for the binding <span>of the specular texture map:</span></li>
</ol>
<pre style="padding-left: 60px">// Bind specular map<br/>     glActiveTexture( GL_TEXTURE1 );<br/>     glBindTexture( GL_TEXTURE_2D, specularMap ); </pre>
<p><span>And now we are now ready to run it. You might observe the following output on your screen: </span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-368 image-border" src="assets/81ddc49a-458e-435e-90ed-e656ad019ca9.png" style=""/></div>
<p><span>Move around the cube; you will see that as we're moving, the lighting affects the shape in a different way because when we were looking at it head on, there wasn't much of a shine. There's a bit towards the top right; that's when we're moving. It's realistically affecting our object. As you move the light around you can see that only the metal part of it is shining:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-369 image-border" src="assets/937b2fdf-d5c8-4934-8c62-653474d0363c.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>Obviously, it depends on what sort of angle you're looking at the object from, because that's how it is in real life. So, that's it for lighting maps.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p> In this chapter, we learned to apply colors to our objects and create a light source such as a lamp in our game world. We then looked at the effects of light on the materials. We also understood the different types of lighting techniques: ambient, diffused, specular lighting. We explored the various materials and observed the effects of light on the materials. We concluded by learning about lightmaps in this chapter.<br/>
<br/>
In the next chapter, we'll discuss about the different sources of light such as directional light, point light and spot light and how to combine those in our game world.   </p>


            </article>

            
        </section>
    </body></html>