["```cpp\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 color;\nlayout (location = 2) in vec2 texCoord;\nout vec3 ourColor;\nout vec2 TexCoord; \n\nuniform mat4 transform;\n\nvoid main()\n{\n gl_Position = transform * vec4(position, 1.0f);\n ourColor = color;\n TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);\n}\n```", "```cpp\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n```", "```cpp\n// Create transformations\n glm::mat4 transform;\n transform = glm::translate( transform, glm::vec3( 0.5f, -0.5f, 0.0f ) );\ntransform = glm::rotate( transform, ( GLfloat)glfwGetTime( ) * -5.0f, glm::vec3( 0.0f, 0.0f, 1.0f ) );   \n```", "```cpp\n// Get matrix's uniform location and set matrix\n GLint transformLocation = glGetUniformLocation( ourShader.Program, \"transform\" );\n glUniformMatrix4fv( transformLocation, 1, GL_FALSE, glm::value_ptr( transform ) );\n```", "```cpp\ntransform = glm::rotate( transform, ( GLfloat)glfwGetTime( ) * -5.0f, glm::vec3( 0.0f, 0.0f, 1.0f ) );\n```", "```cpp\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 2) in vec2 texCoord;\nout vec2 TexCoord;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nvoid main()\n{\n gl_Position = projection * view * model * vec4(position, 1.0f);\n TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);\n}\n```", "```cpp\n // Positions            //Texture Coordinates    \n-0.5f, -0.5f, -0.5f,     0.0f, 0.0f,\n 0.5f, -0.5f, -0.5f,     1.0f, 0.0f,\n 0.5f,  0.5f, -0.5f,     1.0f, 1.0f,\n 0.5f,  0.5f, -0.5f,     1.0f, 1.0f,\n-0.5f,  0.5f, -0.5f,     0.0f, 1.0f,\n-0.5f, -0.5f, -0.5f,     0.0f, 0.0f,\n```", "```cpp\n// Position attribute\n glVertexAttribPointer( 0, 3, GL_FLOAT , GL_FALSE, 5 * sizeof( GLfloat ), ( GLvoid * )0 );\n glEnableVertexAttribArray( 0 );\n\n// TexCoord attribute\n glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 5 * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 2 );\n```", "```cpp\n// Unbind texture when done,so we won't accidentily mess up our texture.\nglBindTexture( GL_TEXTURE_2D, 0 ); \n\n glm::mat4 projection;\n projection = glm::perspective( 45.0f, ( GLfloat )screenWidth / ( GLfloat )screenHeight, 0.1f, 100.0f );\n```", "```cpp\n// Activate shader\n ourShader.Use( );\n\n // Create transformations\n glm::mat4 model;\n glm::mat4 view;\n model = glm::rotate( model, ( GLfloat)glfwGetTime( ) * 1.0f, glm::vec3( 0.5f, 1.0f, 0.0f ) ); // use with perspective projection\n\n//model = glm::rotate( model, 0.5f, glm::vec3( 1.0f, 0.0f, 0.0f ) ); // use to compare orthographic and perspective projection\n //view = glm::translate( view, glm::vec3( screenWidth / 2, screenHeight / 2, -700.0f ) ); // use with orthographic projection\n\nview = glm::translate( view, glm::vec3( 0.0f, 0.0f, -3.0f ) ); // use with perspective projection\n```", "```cpp\n// Create transformations\nview = glm::translate( view, glm::vec3( 0.0f, 0.0f, -3.0f ) ); // use with perspective projection\n```", "```cpp\n// Get their uniform location\n GLint modelLoc = glGetUniformLocation( ourShader.Program, \"model\" );\n GLint viewLoc = glGetUniformLocation( ourShader.Program, \"view\" );\n GLint projLoc = glGetUniformLocation( ourShader.Program, \"projection\" );\n // Pass them to the shaders\n glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );\n glUniformMatrix4fv( viewLoc, 1, GL_FALSE, glm::value_ptr( view ) );\n glUniformMatrix4fv( projLoc, 1, GL_FALSE, glm::value_ptr( projection ) );\n```", "```cpp\n // Draw container\n glBindVertexArray( VAO );\n glDrawArrays( GL_TRIANGLES, 0, 36 );\n glBindVertexArray( 0 );\n```", "```cpp\nprojection = glm::ortho(0.0f, ( GLfloat )screenWidth, 0.0f, ( GLfloat )screenHeight, 0.1f, 1000.0f);\n```", "```cpp\nmodel = glm::rotate( model, 0.5f, glm::vec3( 1.0f, 0.0f, 0.0f ) ); \n// use to compare orthographic and perspective projection\n\nview = glm::translate( view, glm::vec3( screenWidth / 2, screenHeight / 2, -700.0f ) ); \n// use with orthographic projection\n```", "```cpp\n#pragma once\n// Std. Includes\n#include <vector>\n// GL Includes\n#define GLEW_STATIC\n#include <GL/glew.h>\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n\n// Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methods\nenum Camera_Movement\n{\n    FORWARD,\n    BACKWARD,\n    LEFT,\n    RIGHT\n};\n\n// Default camera values\nconst GLfloat YAW        = -90.0f;\nconst GLfloat PITCH      =  0.0f;\nconst GLfloat SPEED      =  6.0f;\nconst GLfloat SENSITIVTY =  0.25f;  \nconst GLfloat ZOOM       =  45.0f;\n```", "```cpp\n//Constructor with vectors\nCamera( glm::vec3 position = glm::vec3( 0.0f, 0.0f, 0.0f ), glm::vec3 up = glm::vec3( 0.0f, 1.0f, 0.0f ), GLfloat yaw = YAW, GLfloat pitch = PITCH ) : front( glm::vec3( 0.0f, 0.0f, -1.0f ) ), movementSpeed( SPEED ), mouseSensitivity( SENSITIVTY ), zoom( ZOOM )\n```", "```cpp\n{\n     this->position = position;\n     this->worldUp = up;\n     this->yaw = yaw;\n     this->pitch = pitch;\n     this->updateCameraVectors( );\n}\n```", "```cpp\n// Constructor with scalar values\n    Camera( GLfloat posX, GLfloat posY, GLfloat posZ, GLfloat upX, GLfloat upY, GLfloat upZ, GLfloat yaw, GLfloat pitch ) : front( glm::vec3( 0.0f, 0.0f, -1.0f ) ), movementSpeed( SPEED ), mouseSensitivity( SENSITIVTY ), zoom( ZOOM )\n    {\n        this->position = glm::vec3( posX, posY, posZ );\n        this->worldUp = glm::vec3( upX, upY, upZ );\n        this->yaw = yaw;\n        this->pitch = pitch;\n        this->updateCameraVectors( );\n    }\n```", "```cpp\n// Returns the view matrix calculated using Eular Angles and the LookAt Matrix\n    glm::mat4 GetViewMatrix( )\n    {\n        return glm::lookAt( this->position, this->position + this->front, this->up );\n    }\n```", "```cpp\nvoid ProcessKeyboard( Camera_Movement direction, GLfloat deltaTime )     {\n```", "```cpp\n// Processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)\n    void ProcessKeyboard( Camera_Movement direction, GLfloat deltaTime )\n    {\n        GLfloat velocity = this->movementSpeed * deltaTime;\n\n        if ( direction == FORWARD )\n        {\n            this->position += this->front * velocity;\n        }\n\n        if ( direction == BACKWARD )\n        {\n            this->position -= this->front * velocity;\n        }\n\n        if ( direction == LEFT )\n        {\n            this->position -= this->right * velocity;\n        }\n\n        if ( direction == RIGHT )\n        {\n            this->position += this->right * velocity;\n        }\n    }\n```", "```cpp\n       xOffset *= this->mouseSensitivity;\n       yOffset *= this->mouseSensitivity;\n\n        this->yaw   += xOffset;\n        this->pitch += yOffset;\n```", "```cpp\n// Processes input received from a mouse input system. Expects the offset value in both the x and y direction.\n    void ProcessMouseMovement( GLfloat xOffset, GLfloat yOffset, GLboolean constrainPitch = true )\n    {\n        xOffset *= this->mouseSensitivity;\n        yOffset *= this->mouseSensitivity;\n\n        this->yaw   += xOffset;\n        this->pitch += yOffset;\n\n        // Make sure that when pitch is out of bounds, screen doesn't get flipped\n        if ( constrainPitch )\n        {\n            if ( this->pitch > 89.0f )\n            {\n                this->pitch = 89.0f;\n            }\n            if ( this->pitch < -89.0f )\n            {\n                this->pitch = -89.0f;\n            }\n        }\n\n        // Update Front, Right and Up Vectors using the updated Eular angles\n        this->updateCameraVectors( );\n    }\n```", "```cpp\nif ( this->zoom >= 1.0f && this->zoom <= 45.0f )\n        {\n\n            this->zoom -= yOffset;\n        }\n\n        if ( this->zoom <= 1.0f )\n        {\n            this->zoom = 1.0f;\n        }\n\n        if ( this->zoom >= 45.0f )\n        {\n            this->zoom = 45.0f;\n        }\n```", "```cpp\nGLfloat GetZoom( )\n    {\n        return this->zoom;\n    }\n```", "```cpp\nprivate:\n    // Camera Attributes\n    glm::vec3 position;\n    glm::vec3 front;\n    glm::vec3 up;\n    glm::vec3 right;\n    glm::vec3 worldUp;\n```", "```cpp\n// Eular Angles\n    GLfloat yaw;\n    GLfloat pitch;\n```", "```cpp\n// Camera options\n    GLfloat movementSpeed;\n    GLfloat mouseSensitivity;\n    GLfloat zoom;\n```", "```cpp\nvoid updateCameraVectors( )\n    {\n        // Calculate the new Front vector\n        glm::vec3 front;\n        front.x = cos( glm::radians( this->yaw ) ) * cos( glm::radians( this->pitch ) );\n        front.y = sin( glm::radians( this->pitch ) );\n        front.z = sin( glm::radians( this->yaw ) ) * cos( glm::radians( this->pitch ) );\n        this->front = glm::normalize( front );\n        // Also re-calculate the Right and Up vector        this->right = glm::normalize( glm::cross( this->front, this->worldUp ) );  // Normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.\n        this->up = glm::normalize( glm::cross( this->right, this->front ) );\n    }\n```", "```cpp\nconst GLuint WIDTH = 800, HEIGHT = 600;\nint SCREEN_WIDTH, SCREEN_HEIGHT;\n```", "```cpp\n// Function prototypes\nvoid KeyCallback( GLFWwindow *window, int key, int scancode, int action, int mode );\nvoid ScrollCallback( GLFWwindow *window, double xOffset, double yOffset );\nvoid MouseCallback( GLFWwindow *window, double xPos, double yPos );\nvoid DoMovement( );\n```", "```cpp\n// Camera\nCamera  camera(glm::vec3( 0.0f, 0.0f, 3.0f ) );\nGLfloat lastX = WIDTH / 2.0;\nGLfloat lastY = HEIGHT / 2.0;\n```", "```cpp\nbool keys[1024];\nbool firstMouse = true;\n```", "```cpp\nGLfloat deltaTime = 0.0f;\nGLfloat lastFrame = 0.0f;\n```", "```cpp\n// Set the required callback functions\nglfwSetKeyCallback( window, KeyCallback );\nglfwSetCursorPosCallback( window, MouseCallback );\nglfwSetScrollCallback( window, ScrollCallback );\n```", "```cpp\n// Options, removes the mouse cursor for a more immersive experience     glfwSetInputMode( window, GLFW_CURSOR, GLFW_CURSOR_DISABLED );\n```", "```cpp\n// Draw our first triangle\n\n   ourShader.Use( );\n\n   // Bind Textures using texture units\n   glActiveTexture( GL_TEXTURE0 );\n   glBindTexture( GL_TEXTURE_2D, texture );\n   glUniform1i( glGetUniformLocation( ourShader.Program, \"ourTexture1\" ), 0 );\n\n   glm::mat4 projection;\n   projection = glm::perspective(camera.GetZoom( ), (GLfloat)SCREEN_WIDTH/(GLfloat)SCREEN_HEIGHT, 0.1f, 1000.0f);\n```", "```cpp\nwhile( !glfwWindowShouldClose( window ) )\n    {\n\n        // Set frame time        \n        GLfloat currentFrame = glfwGetTime( );\n        deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;  \n```", "```cpp\n// Create camera transformation\n        glm::mat4 view;\n        view = camera.GetViewMatrix( );\n```", "```cpp\nfor( GLuint i = 0; i < 10; i++ )\n        {\n            // Calculate the model matrix for each object and pass it to shader before drawing\n glm::mat4 model;\n model = glm::translate( model, cubePositions[i] );\n GLfloat angle = 20.0f * i;\n model = glm::rotate(model, angle, glm::vec3( 1.0f, 0.3f, 0.5f ) );\n glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );\n\n glDrawArrays( GL_TRIANGLES, 0, 36 );\n        }\n```", "```cpp\n// Moves/alters the camera positions based on user input\nvoid DoMovement( )\n{\n    // Camera controls\n    if( keys[GLFW_KEY_W] || keys[GLFW_KEY_UP] )\n    {\n        camera.ProcessKeyboard( FORWARD, deltaTime );\n    }\n\n    if( keys[GLFW_KEY_S] || keys[GLFW_KEY_DOWN] )\n {\n camera.ProcessKeyboard( BACKWARD, deltaTime );\n }\n\n if( keys[GLFW_KEY_A] || keys[GLFW_KEY_LEFT] )\n {\n camera.ProcessKeyboard( LEFT, deltaTime );\n }\n if( keys[GLFW_KEY_D] || keys[GLFW_KEY_RIGHT] ) \n {\n camera.ProcessKeyboard( RIGHT, deltaTime );\n }\n}\n```", "```cpp\n// Is called whenever a key is pressed/released via GLFW\nvoid KeyCallback( GLFWwindow *window, int key, int scancode, int action, int mode )\n{\n    if( key == GLFW_KEY_ESCAPE && action == GLFW_PRESS )\n    {\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    }\n    if ( key >= 0 && key < 1024 )\n    {\n        if( action == GLFW_PRESS )\n        {\n            keys[key] = true;\n        }\n        else if( action == GLFW_RELEASE )\n        {\n            keys[key] = false;\n        }\n    }\n}\n```", "```cpp\nvoid MouseCallback( GLFWwindow *window, double xPos, double yPos )\n{\n    if( firstMouse )\n    {\n        lastX = xPos;\n        lastY = yPos;\n        firstMouse = false;\n    }\n    GLfloat xOffset = xPos - lastX;\n    GLfloat yOffset = lastY - yPos;  // Reversed since y-coordinates go from bottom to left\n\n    lastX = xPos;\n    lastY = yPos;\n\n    camera.ProcessMouseMovement( xOffset, yOffset );\n} \n```", "```cpp\ncamera.ProcessMouseScroll( yOffset );\n```"]