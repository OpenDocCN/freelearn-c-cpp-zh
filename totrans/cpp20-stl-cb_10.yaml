- en: '*Chapter 10*: Using the File System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of the STL `filesystem` library is to normalize file system operations
    across platforms. The `filesystem` library seeks to normalize operations, bridging
    irregularities between POSIX/Unix, Windows, and other file systems.
  prefs: []
  type: TYPE_NORMAL
- en: The `filesystem` library was adopted from the corresponding *Boost* library
    and incorporated into the STL with C++17\. At the time of writing, there are still
    gaps in its implementation on some systems, but the recipes in this chapter have
    been tested on Linux, Windows, and macOS file systems, and compiled with the latest
    available versions of the GCC, MSVC, and Clang compilers, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library uses the `<filesystem>` header, and the `std::filesystem` namespace
    is commonly aliased as `fs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `fs::path` class is at the core of the `filesystem` library. It provides
    normalized filename and directory path representation across disparate environments.
    A `path` object may represent a file, a directory, or any object in a , even a
    non-existent or impossible object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following recipes, we cover tools for working with files and directories
    using the `filesystem` library:'
  prefs: []
  type: TYPE_NORMAL
- en: Specialize `std::formatter` for the `path` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use manipulation functions with `path`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List files in a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search directories and files with a `grep` utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename files with `regex` and `directory_iterator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a disk usage counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10).
  prefs: []
  type: TYPE_NORMAL
- en: Specialize std::formatter for the path class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `path` class is used throughout the `filesystem` library to represent a
    file or directory path. On POSIX-conformant systems, such as macOS and Linux,
    the `path` object uses the `char` type to represent filenames. On Windows, `path`
    uses `wchar_t`. On Windows, `cout` and `format()` will not display primitive strings
    of `wchar_t` characters. This means there is no simple out-of-the-box way to write
    code that uses the `filesystem` library and is portable across POSIX and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We could use preprocessor directives to write specific versions of code for
    Windows. That may be a reasonable solution for some code bases, but for this book,
    it's messy and does not serve the purpose of simple, portable, reusable recipes.
  prefs: []
  type: TYPE_NORMAL
- en: The elegant solution is to write a C++20 `formatter` specialization for the
    `path` class. This allows us to display `path` objects simply and portably.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we write a `formatter` specialization for use with the `fs::path`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a namespace alias for convenience. All the `filesystem` names
    are in the `std::filesystem` namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `formatter` specialization for the `path` class is simple and succinct:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we're specializing `formatter` for the `fs::path` type, using its `string()`
    method to get a printable representation. We cannot use the `c_str()` method because
    it doesn't work with the `wchar_t` characters on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: There's a more complete explanation of `formatter` specialization in [*Chaper
    1*](B18267_01_ePub.xhtml#_idTextAnchor027), *New C++20 Features*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we use the command line to pass a filename or path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `argc` and `argv` parameters are the standard command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`argv[0]` is always the full directory path and filename for the executable
    itself. If we don''t have the correct number of arguments, we display the filename
    part from `argv[0]` as part of our *usage* message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used some `filesystem` functions in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fs::exists()` function checks if a directory or file exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir` is a `path` object. We can now pass it directly to `format()`, using
    our specialization to display the string representation of the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filename()` method returns a new `path` object, which we pass directly
    to `format()` using our specialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fs::cannonical()` function takes a `path` object and returns a new `path`
    object with the canonical absolute directory path. We pass this `path` object
    directly to `format()` and it displays the directory path returned from `cannonical()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fs::path` class is used throughout the `filesystem` library to represent
    directory paths and filenames. By providing a `formatter` specialization, we can
    easily display `path` objects consistently across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `path` class provides some useful methods. We can iterate through a path
    to see its component parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The iterator returns a `path` object for each element of the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also get different parts of the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will continue to use this `formatter` specialization for the `path` class
    throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Use manipulation functions with path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filesystem` library includes functions for manipulating the contents of
    `path` objects. In this recipe, we will consider a few of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we examine some functions that manipulate the contents of `path`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `namespace` directive and our `formatter` specialization.
    We do this in every recipe in this chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can get the current working directory with the `current_path()` function,
    which returns a `path` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `absolute()` function returns an absolute path from a relative path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`absolute()` will also dereference symbolic links.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `+=` operator *concatenates* a string to the end of the `path` string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/=` operator *appends* a string to the end of the `path` string and returns
    a new `path` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `canonical()` function returns the full canonical directory path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equivalent()` function tests if two relative paths resolve to the same
    file system entity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filesystem` library includes the `filesystem_error` class for exception
    handling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `filesystem_error` class includes methods for displaying the error message
    and for getting the path(s) involved in the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we introduce an error into the `equivalent()` call, we can see the results
    of the `fileystem_error` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is the output on Debian with GCC.
  prefs: []
  type: TYPE_NORMAL
- en: The `filesystem_error` class provides additional detail through its `path1()`
    and `path2()` methods. These methods return `path` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `std::error_code` with some of the `filesystem` functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though Windows uses a very different file system, this code still works
    as expected, using Windows file naming conventions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of these functions take a `path` object, an optional `std::error_code`
    object, and return a `path` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equivalent()` function takes two `path` objects and returns a `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `path` class has operators for concatenate and append. Both operators are
    destructive. They modify the `path` on the left-hand side of the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For the right-hand side, these operators take either a `path` object, a `string`,
    a `string_view`, a C-string, or a pair of iterators.
  prefs: []
  type: TYPE_NORMAL
- en: The concatenate operator adds the string from the right-hand side of the operator
    to the end of the `p1` `path` string.
  prefs: []
  type: TYPE_NORMAL
- en: The append operator adds a separator (e.g., `/` or `\`), followed by the string
    from the right-hand side of the operator to the end of the `p1` `path` string.
  prefs: []
  type: TYPE_NORMAL
- en: List files in a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filesystem` library provides a `directory_entry` class with directory-related
    information about a given `path`. We can use this to create useful directory listings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we create a directory listing utility using the information
    in the `directory_entry` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with our namespace alias and `formatter` specialization for displaying
    `path` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `directory_iterator` class makes it easy to list a directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add command-line options to make this work, like Unix `ls`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there is a command-line argument, we use it to create a `path` object. Otherwise,
    we use `"."` for the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: We check if the path exists with `if_exists()`. If not, we print an error message
    and exit. The error message includes `cmdname` from `argv[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check `is_directory()`. If we have a directory, we loop through a `directory_iterator`
    for each entry. `directory_iterator` iterates over `directory_entry` objects.
    `de.path().filename()` gets the `path` and `filename` from each `directory_entry`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If we want our output sorted, we can store our `directory_entry` objects in
    a sortable container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create an alias for `fs::directory_entry`. We''ll be using this a lot.
    This goes at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of `main()`, we declare a `vector` of `de` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `is_directory()` block, we load the `vector`, sort it, and then
    display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our output is sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `Makefile` is sorted first, apparently out of order. This is because
    capital letters sort before lowercase in ASCII order.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want a case-insensitive sort, we need a comparison function that ignores
    case. First, we need a function to return a lowercase `string`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need a function that compares two `directory_entry` objects, using `strlower()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use `dircmp_lc()` in our sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output is now sorted ignoring case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have a simple directory listing utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s a lot more information available from the `filesystem` library. Let''s
    create a `print_dir()` function to gather more information and format it for display
    in the style of Unix `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_dir()` function takes a `directory_entry` argument. We then retrieve
    some useful objects from the `directory_entry` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dir.path()` returns a `path` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir.symlink_status()` returns a `file_status` object, without following symbolic
    links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fstat.permissions()` returns a `perms` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsize` is the size of the file and `fn` is the filename `string`. We''ll look
    more closely at each of these as we use them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix `ls` uses trailing characters, after the filename, to indicate a directory
    or an executable. We test the `fstat` object with `is_directory()` to see if the
    file is a directory and add a trailing `/` to the filename. Likewise, we can test
    if a file is executable with the `fperm` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `print_dir()` from `main()` in the `for` loop after `sort()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `include*` entry. That''s actually a symbolic link. Let''s notate
    that properly by following the link to get the target path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `read_symlink()` function returns a `path` object. We take the `string()`
    representation of the returned `path` object and add it to the suffix for this
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The Unix `ls` command also includes a string of characters to indicate a file''s
    permission bits. It looks something like this: `drwxr-xr-x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first character indicates the type of the file, for example: `d` for directory,
    `l` for symbolic link, and `-` for a regular file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `type_char()` function returns the appropriate character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the string is in three triplets. Each triplet includes positions
    for the read, write, and execute permission bits, in the form `rwx`. If a bit
    is not set, its character is replaced by a `-`. There are three triplets for three
    sets of permissions: owner, group, and other, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `perms` object represents the POSIX permissions bitmap, but it's not necessarily
    implemented as bits. Each entry must be compared to the `perms::none` value. Our
    lambda function fulfills this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add this definition to the top of our `print_dir()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We update our `format()` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a size string. The `fsize` value is from the `file_size()`
    function, which returns a `std::uintmax_t` type. This represents the maximum size
    natural integer on the target system. `uintmax_t` is not always the same as `size_t`
    and does not always convert easily. Notably, `uintmax_t` is 32 bits on Windows,
    where `size_t` is 64 bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I chose to use 1,024 as 1K in this function, as that appears to be the default
    on both Linux and BSD Unix. In production, this could be a command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We update our `format()` string in `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This utility is designed for POSIX systems, such as Linux and macOS. It works
    on a Windows system, but the Windows permissions system is different from the
    POSIX system. On Windows, the permissions bits will always appear fully set.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filesystem` library carries a rich set of information through its `directory_entry`
    and related classes. The major classes we used in this recipe include:'
  prefs: []
  type: TYPE_NORMAL
- en: The `path` class represents a file system path, according to the rules of the
    target system. A `path` object is constructed from a string or another path. It
    need not represent an existing path, or even a possible path. The path string
    is parsed to component parts, including a root name, root directory, and an optional
    series of filenames and directory separators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `directory_entry` class carries a `path` object as a member, and may also
    store additional attributes, including hard link count, status, symbolic link,
    file size, and last write time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_status` class carries information about the type and permissions of
    a file. A `perms` object may be a member of `file_status`, representing the permissions
    structure of a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two functions for retrieving a `perms` object from `file_status`.
    The `status()` function and the `symlink_status()` function both return a `perms`
    object. The difference is in how they handle a symbolic link. The `status()` function
    will follow a symbolic link and return the `perms` from the target file. `symlink_status()`
    will return the `perms` from the symbolic link itself.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I had intended to include the last-write time of each file in the directory
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: The `directory_entry` class has a member function, `last_write_time()`, which
    returns a `file_time_type` object representing the timestamp of the last time
    the file was written.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at the time of writing, the available implementations lack a
    portable way to convert a `file_time_type` object to a standard `chrono::sys_time`,
    suitable for use with `cout` or `format()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, here''s a solution that works with GCC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It's recommended that user code should use `std::chrono::clock_cast` instead
    of `file::clock::to_sys` to convert time points between clocks. Unfortunately,
    none of the currently available implementations have a working `std::chrono::clock_cast`
    specialization for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this `time_string()` function, we can add to `print_dir()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then change the `format()` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This works on Debian with GCC-11\. Do not expect it to work without modification
    on any other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Search directories and files with a grep utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate traversing and searching directory structures, we create a simple
    utility that works like Unix *grep*. This utility uses `recursive_directory_iterator`
    to traverse nested directories and searches files for matches with a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we write a simple *grep* utility that traverses directories
    to search files with a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with some convenience aliases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`match_v` is a `vector` of regular expression match results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue using our `formatter` specialization for `path` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have a simple function for getting regular expression matches from a file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we open the file with `ifstream`, read lines from the file
    with `getline()`, and match the regular expression with `regex_search()`. Results
    are collected in the `vector` and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call this function from `main()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we use constants for the filename and the regular expression
    pattern. We create `path` and `regex` objects, call the `matches()` function,
    and print the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our output has line numbers and strings for the matching lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Our utility needs to take command-line arguments for the `regex` pattern and
    filenames. It should be able to traverse directories or take a list of filenames
    (which may be the result of command-line wildcard expansion). This requires a
    bit of logic in the `main()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we need one more helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This function calls our `matches()` function and prints the results. It takes
    a `regex` object and two `path` objects. `epath` is the result of a directory
    search, and `search_path` is the search directory itself. We'll set these in `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, we use the `argc` and `argv` command-line arguments and we declare
    a few variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The variables declared here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arg_pat` is for the regular expression pattern from the command line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`re` is the `regex` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search_path` is the command-line search path argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matchcount` is for counting the matched lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continuing in `main()`, if we have no arguments, then we print a short usage
    string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`argv[1]` is always the invoking command from the command line. `cmdname` uses
    the `filename()` method to return a `path` with just the filename part of the
    invoking command path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we parse the regular expression. We use a `try-catch` block to capture
    any error from the `regex` parser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `icase` flag to tell the `regex` parser to ignore case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `argc == 2`, we have just one argument, which we treat as the regular expression
    pattern, and we use the current directory for the search path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`rdit` is an alias for the `recursive_directory_iterator` class, which traverses
    the directory tree from the starting path, returning a `directory_entry` object
    for each file it encounters. We then create a `path` object and call `pmatches()`
    to go through the file and print any regular expression matches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point in `main()`, we know that `argc` is `>=2`. Now, we handle cases
    where we have one or more file paths on the command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `while` loop handles one or more arguments past the search pattern on the
    command line. It checks each filename to ensure it exists. Then, if it's a directory,
    it uses the `rdit` alias for the `recursive_directory_iterator` class to traverse
    the directory and call `pmatches()` to print any pattern matches in the files.
  prefs: []
  type: TYPE_NORMAL
- en: If it's a single file, it calls `pmatches()` on that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run our `grep` clone with one argument as the search pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run it with a second argument as a directory to search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it *traverses the directory tree* to find files in sub-directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can run it with a single file argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the main task of this utility is the regular expression matching, we're
    concentrating on the technique of recursively processing directories of files.
  prefs: []
  type: TYPE_NORMAL
- en: The `recursive_directory_iterator` object is interchangeable with `directory_iterator`,
    except `recursive_directory_iterator` operates recursively over all the entries
    of each sub-directory.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more about regular expressions, see the recipe *Parse strings with Regular
    Expressions* in [*Chapter 7*](B18267_07_ePub.xhtml#_idTextAnchor212), *Strings,
    Streams, and Formatting*.
  prefs: []
  type: TYPE_NORMAL
- en: Rename files with regex and directory_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a simple utility that renames files using regular expressions. It uses
    `directory_iterator` to find the files in a directory and `fs::rename()` to rename
    them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we create a file rename utility that uses regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a few convenience aliases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `pat_v` alias is a vector for use with our regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also continue to use the `formatter` specialization for `path` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have a function for applying the regular expression replacement to filename
    strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we loop through a `vector` of pattern/replacement pairs, applying
    the regular expressions successively. This allows us to stack our replacements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, we first check the command-line arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command line accepts one or more *pairs of strings*. Each pair of strings
    includes a *regex* (regular expression) followed by a *replacement*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we populate the `vector` with `regex` and `string` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `pair` constructor constructs the `regex` and `string` objects in place,
    from the C-strings passed on the command line. These are added to the `vector`
    with the `emplace_back()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We search the current directory using a `directory_iterator` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this `for` loop, we call `replace_str()` to get the replacement filename
    and then check that the new name is not a duplicate of a file in the directory.
    We use the `replace_filename()` method on a `path` object to create a `path` with
    the new filename and use `fs::rename()` to rename the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the utility, I''ve created a directory with a few files in it for renaming:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can do something simple, like change `.cpp` to `.Cpp`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s change them back again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Using standard regular expression syntax, I can add "`bw`" to the beginning
    of each of the filenames:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that it even renamed the files that already had "`bw`" at the beginning.
    Let''s have it not do that. First, we restore the filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we use a *regex* that checks if the filename already begins with "`bw`":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we use a `vector` of regex/replacement strings, we can stack several
    replacements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filesystem` part of this recipe uses `directory_iterator` to return a
    `directory_entry` object for each file in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We then construct a `path` object from the `directory_entry` object to process
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `replace_filename()` method on a `path` object to create the destination
    for the rename operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a duplicate and change its name, giving us both sides for the
    rename operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'On the regular expression side of the recipe, we use `regex_replace()`, which
    uses regular expression syntax to perform substitutions in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular expression syntax is extremely powerful. It even allows replacements
    to include sections of the search string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: By using parentheses in the search pattern, I can easily rearrange parts of
    a filename.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more about regular expressions, see the recipe *Parse strings with Regular
    Expressions* in [*Chapter 7*](B18267_07_ePub.xhtml#_idTextAnchor212), *Strings,
    Streams, and Formatting*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a disk usage counter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a simple utility that totals the size of every file in a directory and
    its sub-directories. It runs on both POSIX/Unix and Windows file systems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is a utility to report the size of every file in a directory and
    its sub-directories, along with a total. We''ll re-use some of the functions we''ve
    used elsewhere in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a few convenience aliases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also use our `format` specialization for `fs::path` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For reporting the size of the directory, we''ll use this `make_commas()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've used this before. It inserts a comma before every third character from
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort our directory, we''ll need a lowercase string function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a comparison predicate for sorting `directory_entry` objects by the
    lowercase of the `path` name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`size_string()` returns abbreviated values for reporting file size in gigabytes,
    megabytes, kilobytes, or bytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`entry_size()` returns the size of a file or, if it''s a directory, the recursive
    size of the directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main()`, we start with declarations and test if we have a valid directory
    to search:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our directory path, `dir`, we use `argv[1]` if we have an argument; otherwise,
    we use `current_path()` for the current directory. Then we set up an environment
    for our usage counter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` of `directory_entry` objects is used for sorting our response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accum` is used to accumulate values for our final size total.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We make sure `dir` exists and is a directory before proceeding to examine the
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, a simple loop to populate the `vector`. Once populated, we sort `entries`
    using our `dircmp_lc()` function as a comparison predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that everything is set up, we can accumulate results from the sorted `vector`
    of `directory_entry` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The call to `entry_size()` returns the size of the file or directory represented
    in the `directory_entry` object.
  prefs: []
  type: TYPE_NORMAL
- en: If the current entry is a directory (and not a *symbolic link*), we add a symbol
    to indicate it's a directory. I chose an inverted triangle. You may use anything
    here.
  prefs: []
  type: TYPE_NORMAL
- en: After the loop is complete, we display the accumulated size in both bytes with
    commas, and the abbreviated notation from `size_string()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fs::file_size()` function returns a `uintmax_t` value that represents the
    size of the file as the largest natural unsigned integer on a given platform.
    While this is normally a 64-bit integer on most 64-bit systems, a notable exception
    is Windows, which uses a 32-bit integer. This means that while `size_t` may work
    for this value on some systems, it fails to compile on Windows because it may
    try to promote a 64-bit value to a 32-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `entry_size()` function takes a `path` object and returns a `uintmax_t`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The function checks for a regular file and returns the size of the file. Otherwise,
    it checks for a directory that is not also a symbolic link. We just want the size
    of the files in a directory, so we don't want to follow symbolic links. (Symbolic
    links may also cause reference loops, leading to a runaway condition.)
  prefs: []
  type: TYPE_NORMAL
- en: If we find a directory, we loop through it, calling `entry_size()` for each
    file we encounter. This is a recursive loop, so we eventually end up with the
    size of the directory.
  prefs: []
  type: TYPE_NORMAL
