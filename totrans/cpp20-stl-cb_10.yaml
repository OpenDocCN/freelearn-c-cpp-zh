- en: '*Chapter 10*: Using the File System'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用文件系统'
- en: The purpose of the STL `filesystem` library is to normalize file system operations
    across platforms. The `filesystem` library seeks to normalize operations, bridging
    irregularities between POSIX/Unix, Windows, and other file systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: STL `filesystem`库的目的是在各个平台上标准化文件系统操作。`filesystem`库旨在标准化操作，弥合POSIX/Unix、Windows和其他文件系统之间的不规则性。
- en: The `filesystem` library was adopted from the corresponding *Boost* library
    and incorporated into the STL with C++17\. At the time of writing, there are still
    gaps in its implementation on some systems, but the recipes in this chapter have
    been tested on Linux, Windows, and macOS file systems, and compiled with the latest
    available versions of the GCC, MSVC, and Clang compilers, respectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem`库是从相应的*Boost*库中采纳的，并在C++17中纳入了STL。在撰写本文时，一些系统上其实现仍存在空白，但本章中的菜谱已在Linux、Windows和macOS文件系统上进行了测试，并分别使用最新的GCC、MSVC和Clang编译器编译。'
- en: 'The library uses the `<filesystem>` header, and the `std::filesystem` namespace
    is commonly aliased as `fs`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该库使用`<filesystem>`头文件，并且`std::filesystem`命名空间通常被别名为`fs`：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `fs::path` class is at the core of the `filesystem` library. It provides
    normalized filename and directory path representation across disparate environments.
    A `path` object may represent a file, a directory, or any object in a , even a
    non-existent or impossible object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs::path`类是`filesystem`库的核心。它为不同的环境提供了标准化的文件名和目录路径表示。一个`path`对象可以表示一个文件、一个目录，甚至是一个，即使是一个不存在或不可能的对象。'
- en: 'In the following recipes, we cover tools for working with files and directories
    using the `filesystem` library:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的菜谱中，我们将介绍使用`filesystem`库处理文件和目录的工具：
- en: Specialize `std::formatter` for the `path` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`path`类特化`std::formatter`
- en: Use manipulation functions with `path`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path`的操纵函数
- en: List files in a directory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出目录中的文件
- en: Search directories and files with a `grep` utility
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`grep`实用工具搜索目录和文件
- en: Rename files with `regex` and `directory_iterator`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`regex`和`directory_iterator`重命名文件
- en: Create a disk usage counter
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建磁盘使用计数器
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10)。
- en: Specialize std::formatter for the path class
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为path类特化std::formatter
- en: The `path` class is used throughout the `filesystem` library to represent a
    file or directory path. On POSIX-conformant systems, such as macOS and Linux,
    the `path` object uses the `char` type to represent filenames. On Windows, `path`
    uses `wchar_t`. On Windows, `cout` and `format()` will not display primitive strings
    of `wchar_t` characters. This means there is no simple out-of-the-box way to write
    code that uses the `filesystem` library and is portable across POSIX and Windows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在`filesystem`库中，`path`类被用来表示文件或目录路径。在符合POSIX的系统上，例如macOS和Linux，`path`对象使用`char`类型来表示文件名。在Windows上，`path`使用`wchar_t`。在Windows上，`cout`和`format()`将不会显示`wchar_t`字符的原始字符串。这意味着没有简单的方法来编写既使用`filesystem`库又在POSIX和Windows之间可移植的代码。
- en: We could use preprocessor directives to write specific versions of code for
    Windows. That may be a reasonable solution for some code bases, but for this book,
    it's messy and does not serve the purpose of simple, portable, reusable recipes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用预处理器指令为Windows编写特定版本的代码。这可能是一些代码库的合理解决方案，但对于这本书来说，它会变得混乱，并且不符合简单、可移植、可重用的菜谱的目的。
- en: The elegant solution is to write a C++20 `formatter` specialization for the
    `path` class. This allows us to display `path` objects simply and portably.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 精美的解决方案是编写一个C++20的`formatter`特化，用于`path`类。这允许我们简单地、可移植地显示`path`对象。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we write a `formatter` specialization for use with the `fs::path`
    class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们编写了一个`formatter`特化，用于与`fs::path`类一起使用：
- en: 'We start with a namespace alias for convenience. All the `filesystem` names
    are in the `std::filesystem` namespace:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便，我们首先定义一个命名空间别名。所有的`filesystem`名称都在`std::filesystem`命名空间中：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our `formatter` specialization for the `path` class is simple and succinct:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为`path`类提供的`formatter`特化简单而简洁：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we're specializing `formatter` for the `fs::path` type, using its `string()`
    method to get a printable representation. We cannot use the `c_str()` method because
    it doesn't work with the `wchar_t` characters on Windows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在为`fs::path`类型特殊化`formatter`，使用其`string()`方法获取可打印的表示形式。我们无法使用`c_str()`方法，因为它在Windows上的`wchar_t`字符上不起作用。
- en: There's a more complete explanation of `formatter` specialization in [*Chaper
    1*](B18267_01_ePub.xhtml#_idTextAnchor027), *New C++20 Features*, of this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的[*第1章*](B18267_01_ePub.xhtml#_idTextAnchor027)，“新C++20特性”，对`formatter`特殊化的解释更为完整。
- en: 'In the `main()` function, we use the command line to pass a filename or path:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们使用命令行传递一个文件名或路径：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `argc` and `argv` parameters are the standard command-line arguments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`argc`和`argv`参数是标准的命令行参数。'
- en: '`argv[0]` is always the full directory path and filename for the executable
    itself. If we don''t have the correct number of arguments, we display the filename
    part from `argv[0]` as part of our *usage* message.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv[0]`始终是可执行文件的完整目录路径和文件名。如果我们没有正确的参数数量，我们将显示`argv[0]`中的文件名部分作为我们的*用法*消息的一部分。'
- en: 'We''ve used some `filesystem` functions in this example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中使用了一些`filesystem`函数：
- en: The `fs::exists()` function checks if a directory or file exists.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs::exists()`函数检查目录或文件是否存在。'
- en: '`dir` is a `path` object. We can now pass it directly to `format()`, using
    our specialization to display the string representation of the path.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir`是一个`path`对象。我们现在可以直接将其传递给`format()`，使用我们的特殊化来显示路径的字符串表示形式。'
- en: The `filename()` method returns a new `path` object, which we pass directly
    to `format()` using our specialization.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename()`方法返回一个新的`path`对象，我们将其直接传递给`format()`，使用我们的特殊化。'
- en: The `fs::cannonical()` function takes a `path` object and returns a new `path`
    object with the canonical absolute directory path. We pass this `path` object
    directly to `format()` and it displays the directory path returned from `cannonical()`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs::cannonical()`函数接受一个`path`对象，并返回一个新的`path`对象，其中包含规范绝对目录路径。我们直接将此`path`对象传递给`format()`，并显示从`cannonical()`返回的目录路径。'
- en: 'Output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `fs::path` class is used throughout the `filesystem` library to represent
    directory paths and filenames. By providing a `formatter` specialization, we can
    easily display `path` objects consistently across platforms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs::path`类在`filesystem`库中用于表示目录路径和文件名。通过提供`formatter`特殊化，我们可以轻松地在各个平台上一致地显示`path`对象。'
- en: 'The `path` class provides some useful methods. We can iterate through a path
    to see its component parts:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`类提供了一些有用的方法。我们可以遍历路径以查看其组成部分：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The iterator returns a `path` object for each element of the path.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器为路径的每个元素返回一个`path`对象。
- en: 'We can also get different parts of the path:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以获取路径的不同部分：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will continue to use this `formatter` specialization for the `path` class
    throughout this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中继续使用这个`formatter`特殊化来处理`path`类。
- en: Use manipulation functions with path
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径操作函数
- en: The `filesystem` library includes functions for manipulating the contents of
    `path` objects. In this recipe, we will consider a few of these tools.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem`库包括用于操作`path`对象内容的函数。在本例中，我们将考虑这些工具中的几个。'
- en: How to do it…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we examine some functions that manipulate the contents of `path`
    objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们检查了一些操作`path`对象内容的函数：
- en: 'We start with the `namespace` directive and our `formatter` specialization.
    We do this in every recipe in this chapter:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`namespace`指令和我们的`formatter`特殊化开始。我们在本章的每个菜谱中都这样做：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can get the current working directory with the `current_path()` function,
    which returns a `path` object:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`current_path()`函数获取当前工作目录，该函数返回一个`path`对象：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `absolute()` function returns an absolute path from a relative path:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`absolute()`函数从相对路径返回绝对路径：'
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`absolute()` will also dereference symbolic links.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`absolute()`也会取消符号链接的引用。'
- en: 'The `+=` operator *concatenates* a string to the end of the `path` string:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=`运算符将字符串连接到`path`字符串的末尾：'
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `/=` operator *appends* a string to the end of the `path` string and returns
    a new `path` object:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/=`运算符将字符串附加到`path`字符串的末尾并返回一个新的`path`对象：'
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `canonical()` function returns the full canonical directory path:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canonical()`函数返回完整的规范目录路径：'
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `equivalent()` function tests if two relative paths resolve to the same
    file system entity:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equivalent()`函数测试两个相对路径是否解析到相同的文件系统实体：'
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `filesystem` library includes the `filesystem_error` class for exception
    handling:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filesystem` 库包含了用于异常处理的 `filesystem_error` 类：'
- en: '[PRE22]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `filesystem_error` class includes methods for displaying the error message
    and for getting the path(s) involved in the error.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem_error` 类包含了显示错误信息和获取涉及错误路径的方法。'
- en: 'If we introduce an error into the `equivalent()` call, we can see the results
    of the `fileystem_error` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `equivalent()` 调用中引入错误，我们可以看到 `filesystem_error` 类的结果：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the output on Debian with GCC.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Debian 上使用 GCC 的输出。
- en: The `filesystem_error` class provides additional detail through its `path1()`
    and `path2()` methods. These methods return `path` objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem_error` 类通过其 `path1()` 和 `path2()` 方法提供了额外的详细信息。这些方法返回 `path` 对象。'
- en: 'You can also use `std::error_code` with some of the `filesystem` functions:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用 `std::error_code` 与一些 `filesystem` 函数一起使用：
- en: '[PRE25]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Even though Windows uses a very different file system, this code still works
    as expected, using Windows file naming conventions:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管Windows使用一个非常不同的文件系统，但此代码仍然按预期工作，使用Windows文件命名约定：
- en: '[PRE27]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Most of these functions take a `path` object, an optional `std::error_code`
    object, and return a `path` object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些函数接受一个 `path` 对象、一个可选的 `std::error_code` 对象，并返回一个 `path` 对象：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `equivalent()` function takes two `path` objects and returns a `bool`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`equivalent()` 函数接受两个 `path` 对象并返回一个 `bool`：'
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `path` class has operators for concatenate and append. Both operators are
    destructive. They modify the `path` on the left-hand side of the operator:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 类有用于连接和追加的运算符。这两个运算符都是破坏性的。它们修改运算符左侧的 `path`：'
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the right-hand side, these operators take either a `path` object, a `string`,
    a `string_view`, a C-string, or a pair of iterators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于右侧，这些运算符可以接受一个 `path` 对象、一个 `string`、一个 `string_view`、一个 C 字符串或一对迭代器。
- en: The concatenate operator adds the string from the right-hand side of the operator
    to the end of the `p1` `path` string.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 连接运算符将运算符右侧的字符串添加到 `p1` `path` 字符串的末尾。
- en: The append operator adds a separator (e.g., `/` or `\`), followed by the string
    from the right-hand side of the operator to the end of the `p1` `path` string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 追加运算符添加一个分隔符（例如，`/` 或 `\`），然后是运算符右侧的字符串到 `p1` `path` 字符串的末尾。
- en: List files in a directory
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出目录中的文件
- en: The `filesystem` library provides a `directory_entry` class with directory-related
    information about a given `path`. We can use this to create useful directory listings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem` 库提供了一个包含给定 `path` 的目录相关信息的 `directory_entry` 类。我们可以使用它来创建有用的目录列表。'
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we create a directory listing utility using the information
    in the `directory_entry` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `directory_entry` 类中的信息创建一个目录列表实用工具：
- en: 'We start with our namespace alias and `formatter` specialization for displaying
    `path` objects:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从命名空间别名和用于显示 `path` 对象的 `formatter` 特化开始：
- en: '[PRE31]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `directory_iterator` class makes it easy to list a directory:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory_iterator` 类使得列出目录变得容易：'
- en: '[PRE32]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can add command-line options to make this work, like Unix `ls`:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加命令行选项来使它工作，就像 Unix `ls`：
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If there is a command-line argument, we use it to create a `path` object. Otherwise,
    we use `"."` for the current directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有命令行参数，我们使用它来创建一个 `path` 对象。否则，我们使用 `"."` 表示当前目录。
- en: We check if the path exists with `if_exists()`. If not, we print an error message
    and exit. The error message includes `cmdname` from `argv[0]`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `if_exists()` 检查路径是否存在。如果不存在，我们打印错误消息并退出。错误消息包括 `argv[0]` 中的 `cmdname`。
- en: Next, we check `is_directory()`. If we have a directory, we loop through a `directory_iterator`
    for each entry. `directory_iterator` iterates over `directory_entry` objects.
    `de.path().filename()` gets the `path` and `filename` from each `directory_entry`
    object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查 `is_directory()`。如果我们有一个目录，我们通过 `directory_iterator` 对每个条目进行循环。`directory_iterator`
    遍历 `directory_entry` 对象。`de.path().filename()` 从每个 `directory_entry` 对象中获取 `path`
    和 `filename`。
- en: 'Output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we want our output sorted, we can store our `directory_entry` objects in
    a sortable container.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们希望输出排序，我们可以将我们的 `directory_entry` 对象存储在可排序的容器中。
- en: 'Let''s create an alias for `fs::directory_entry`. We''ll be using this a lot.
    This goes at the top of the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `fs::directory_entry` 创建一个别名。我们会经常使用它。这个别名放在文件的顶部：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At the top of `main()`, we declare a `vector` of `de` objects:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数的顶部，我们声明了一个 `de` 对象的 `vector`：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the `is_directory()` block, we load the `vector`, sort it, and then
    display it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `is_directory()` 块内部，我们加载 `vector`，对其进行排序，然后显示它：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now our output is sorted:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出已经排序：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that `Makefile` is sorted first, apparently out of order. This is because
    capital letters sort before lowercase in ASCII order.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Makefile` 是首先排序的，看起来顺序不对。这是因为大写字母在 ASCII 排序中排在小写字母之前。
- en: 'If we want a case-insensitive sort, we need a comparison function that ignores
    case. First, we need a function to return a lowercase `string`:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要不区分大小写的排序，我们需要一个忽略大小写的比较函数。首先，我们需要一个函数来返回小写的 `string`：
- en: '[PRE40]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we need a function that compares two `directory_entry` objects, using `strlower()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数来比较两个 `directory_entry` 对象，使用 `strlower()`：
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can use `dircmp_lc()` in our sort:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在排序中使用 `dircmp_lc()`：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our output is now sorted ignoring case:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在忽略大小写排序的输出：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At this point, we have a simple directory listing utility.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个简单的目录列表工具。
- en: 'There''s a lot more information available from the `filesystem` library. Let''s
    create a `print_dir()` function to gather more information and format it for display
    in the style of Unix `ls`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem` 库中还有更多可用的信息。让我们创建一个 `print_dir()` 函数来收集更多信息，并以 Unix `ls` 的样式格式化显示：'
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `print_dir()` function takes a `directory_entry` argument. We then retrieve
    some useful objects from the `directory_entry` object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_dir()` 函数接受一个 `directory_entry` 参数。然后我们从 `directory_entry` 对象中检索一些有用的对象：'
- en: '`dir.path()` returns a `path` object.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir.path()` 返回一个 `path` 对象。'
- en: '`dir.symlink_status()` returns a `file_status` object, without following symbolic
    links.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir.symlink_status()` 返回一个 `file_status` 对象，不跟随符号链接。'
- en: '`fstat.permissions()` returns a `perms` object.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fstat.permissions()` 返回一个 `perms` 对象。'
- en: '`fsize` is the size of the file and `fn` is the filename `string`. We''ll look
    more closely at each of these as we use them.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fsize` 是文件的大小，`fn` 是文件名 `string`。我们将在使用它们时更详细地查看这些。'
- en: Unix `ls` uses trailing characters, after the filename, to indicate a directory
    or an executable. We test the `fstat` object with `is_directory()` to see if the
    file is a directory and add a trailing `/` to the filename. Likewise, we can test
    if a file is executable with the `fperm` object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Unix `ls` 使用文件名之后的尾随字符来指示目录或可执行文件。我们用 `is_directory()` 测试 `fstat` 对象以查看文件是否是目录，并将尾随的
    `/` 添加到文件名。同样，我们可以用 `fperm` 对象测试文件是否可执行。
- en: 'We call `print_dir()` from `main()` in the `for` loop after `sort()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sort()` 之后，我们在 `for` 循环中调用 `main()` 中的 `print_dir()`：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Our output now looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的输出看起来像这样：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice the `include*` entry. That''s actually a symbolic link. Let''s notate
    that properly by following the link to get the target path:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意到 `include*` 条目。实际上这是一个符号链接。让我们通过跟随链接来正确地标记目标路径：
- en: '[PRE47]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `read_symlink()` function returns a `path` object. We take the `string()`
    representation of the returned `path` object and add it to the suffix for this
    output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_symlink()` 函数返回一个 `path` 对象。我们取返回的 `path` 对象的 `string()` 表示形式，并将其添加到这个输出的后缀：'
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The Unix `ls` command also includes a string of characters to indicate a file''s
    permission bits. It looks something like this: `drwxr-xr-x`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix `ls` 命令还包括一个字符序列来指示文件的权限位。它看起来像这样：`drwxr-xr-x`。
- en: 'The first character indicates the type of the file, for example: `d` for directory,
    `l` for symbolic link, and `-` for a regular file.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符表示文件的类型，例如：`d` 表示目录，`l` 表示符号链接，`-` 表示常规文件。
- en: 'The `type_char()` function returns the appropriate character:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_char()` 函数返回适当的字符：'
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The rest of the string is in three triplets. Each triplet includes positions
    for the read, write, and execute permission bits, in the form `rwx`. If a bit
    is not set, its character is replaced by a `-`. There are three triplets for three
    sets of permissions: owner, group, and other, respectively.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的其余部分分为三个三元组。每个三元组包括读取、写入和执行权限位的位，形式为 `rwx`。如果位未设置，则其字符被替换为 `-`。有三组权限位，分别对应所有者、组和其它。
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `perms` object represents the POSIX permissions bitmap, but it's not necessarily
    implemented as bits. Each entry must be compared to the `perms::none` value. Our
    lambda function fulfills this requirement.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`perms` 对象代表 POSIX 权限位图，但并不一定以位的形式实现。每个条目都必须与 `perms::none` 值进行比较。我们的 lambda
    函数满足这一要求。'
- en: 'We add this definition to the top of our `print_dir()` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个定义添加到 `print_dir()` 函数的顶部：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We update our `format()` string:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新我们的 `format()` 字符串：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And we get this output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let''s add a size string. The `fsize` value is from the `file_size()`
    function, which returns a `std::uintmax_t` type. This represents the maximum size
    natural integer on the target system. `uintmax_t` is not always the same as `size_t`
    and does not always convert easily. Notably, `uintmax_t` is 32 bits on Windows,
    where `size_t` is 64 bits:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个大小字符串。`fsize`值来自`file_size()`函数，它返回一个`std::uintmax_t`类型。这代表目标系统上的最大自然整数。`uintmax_t`并不总是与`size_t`相同，并且并不总是容易转换。值得注意的是，在Windows上`uintmax_t`是32位，而`size_t`是64位：
- en: '[PRE54]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I chose to use 1,024 as 1K in this function, as that appears to be the default
    on both Linux and BSD Unix. In production, this could be a command-line option.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在这个函数中使用1,024作为1K，因为这看起来是Linux和BSD Unix的默认设置。在生产环境中，这可以是一个命令行选项。
- en: 'We update our `format()` string in `main()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main()`中更新我们的`format()`字符串：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we get this output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到这个输出：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This utility is designed for POSIX systems, such as Linux and macOS. It works
    on a Windows system, but the Windows permissions system is different from the
    POSIX system. On Windows, the permissions bits will always appear fully set.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用程序是为POSIX系统设计的，例如Linux和macOS。它在Windows系统上也能工作，但Windows的权限系统与POSIX系统不同。在Windows上，权限位总是完全设置的。
- en: How it works…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `filesystem` library carries a rich set of information through its `directory_entry`
    and related classes. The major classes we used in this recipe include:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem`库通过其`directory_entry`和相关类携带丰富的信息。我们在本菜谱中使用的的主要类包括：'
- en: The `path` class represents a file system path, according to the rules of the
    target system. A `path` object is constructed from a string or another path. It
    need not represent an existing path, or even a possible path. The path string
    is parsed to component parts, including a root name, root directory, and an optional
    series of filenames and directory separators.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`类表示一个文件系统路径，根据目标系统的规则。一个`path`对象可以从一个字符串或另一个路径构造而成。它不需要表示一个现有路径，甚至不是一个可能的路径。路径字符串被解析成组件部分，包括根名称、根目录以及一系列可选的文件名和目录分隔符。'
- en: The `directory_entry` class carries a `path` object as a member, and may also
    store additional attributes, including hard link count, status, symbolic link,
    file size, and last write time.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory_entry`类携带一个`path`对象作为成员，并且也可能存储额外的属性，包括硬链接计数、状态、符号链接、文件大小和最后写入时间。'
- en: The `file_status` class carries information about the type and permissions of
    a file. A `perms` object may be a member of `file_status`, representing the permissions
    structure of a file.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_status`类携带有关文件类型和权限的信息。`perms`对象可能是`file_status`的一个成员，表示文件的权限结构。'
- en: There are two functions for retrieving a `perms` object from `file_status`.
    The `status()` function and the `symlink_status()` function both return a `perms`
    object. The difference is in how they handle a symbolic link. The `status()` function
    will follow a symbolic link and return the `perms` from the target file. `symlink_status()`
    will return the `perms` from the symbolic link itself.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数可以从`file_status`检索`perms`对象。`status()`函数和`symlink_status()`函数都返回一个`perms`对象。区别在于它们处理符号链接的方式。`status()`函数会跟随符号链接并返回目标文件的`perms`。`symlink_status()`将返回符号链接本身的`perms`。
- en: There's more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: I had intended to include the last-write time of each file in the directory
    listing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我原本打算在目录列表中包含每个文件的最后写入时间。
- en: The `directory_entry` class has a member function, `last_write_time()`, which
    returns a `file_time_type` object representing the timestamp of the last time
    the file was written.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`directory_entry`类有一个成员函数`last_write_time()`，它返回一个表示文件最后一次写入时间戳的`file_time_type`对象。'
- en: Unfortunately, at the time of writing, the available implementations lack a
    portable way to convert a `file_time_type` object to a standard `chrono::sys_time`,
    suitable for use with `cout` or `format()`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在写作的时候，可用的实现缺乏一种可移植的方式来将`file_time_type`对象转换为标准的`chrono::sys_time`，适用于与`cout`或`format()`一起使用。
- en: 'For now, here''s a solution that works with GCC:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这里有一个与GCC兼容的解决方案：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It's recommended that user code should use `std::chrono::clock_cast` instead
    of `file::clock::to_sys` to convert time points between clocks. Unfortunately,
    none of the currently available implementations have a working `std::chrono::clock_cast`
    specialization for this purpose.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 建议用户代码使用`std::chrono::clock_cast`而不是`file::clock::to_sys`来在时钟之间转换时间点。不幸的是，目前可用的实现中没有任何一个为这个目的工作的`std::chrono::clock_cast`特化。
- en: 'Using this `time_string()` function, we can add to `print_dir()`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`time_string()`函数，我们可以在`print_dir()`中添加：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can then change the `format()` string:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更改 `format()` 字符串：
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And we get this output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This works on Debian with GCC-11\. Do not expect it to work without modification
    on any other systems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Debian 系统上使用 GCC-11 是可行的。不要期望它在任何其他系统上无需修改就能工作。
- en: Search directories and files with a grep utility
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 grep 工具搜索目录和文件
- en: To demonstrate traversing and searching directory structures, we create a simple
    utility that works like Unix *grep*. This utility uses `recursive_directory_iterator`
    to traverse nested directories and searches files for matches with a regular expression.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示遍历和搜索目录结构，我们创建了一个类似于 Unix *grep* 的简单工具。这个工具使用 `recursive_directory_iterator`
    来遍历嵌套目录，并搜索与正则表达式匹配的文件。
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we write a simple *grep* utility that traverses directories
    to search files with a regular expression:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们编写了一个简单的 *grep* 工具，它遍历目录以搜索使用正则表达式的文件：
- en: 'We start with some convenience aliases:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一些便利的别名开始：
- en: '[PRE61]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`match_v` is a `vector` of regular expression match results.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_v` 是正则表达式匹配结果的一个 `vector`。'
- en: 'We continue using our `formatter` specialization for `path` objects:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继续使用 `formatter` 特化来处理 `path` 对象：
- en: '[PRE62]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We have a simple function for getting regular expression matches from a file:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个简单的函数用于从文件中获取正则表达式匹配：
- en: '[PRE63]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this function, we open the file with `ifstream`, read lines from the file
    with `getline()`, and match the regular expression with `regex_search()`. Results
    are collected in the `vector` and returned.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用 `ifstream` 打开文件，使用 `getline()` 从文件中读取行，并使用 `regex_search()` 匹配正则表达式。结果收集在
    `vector` 中并返回。
- en: 'We can now call this function from `main()`:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以从 `main()` 中调用这个函数：
- en: '[PRE64]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, we use constants for the filename and the regular expression
    pattern. We create `path` and `regex` objects, call the `matches()` function,
    and print the results.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用常量来表示文件名和正则表达式模式。我们创建 `path` 和 `regex` 对象，调用 `matches()` 函数，并打印结果。
- en: 'Our output has line numbers and strings for the matching lines:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出带有行号和匹配行的字符串：
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Our utility needs to take command-line arguments for the `regex` pattern and
    filenames. It should be able to traverse directories or take a list of filenames
    (which may be the result of command-line wildcard expansion). This requires a
    bit of logic in the `main()` function.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的工具需要接受命令行参数作为 `regex` 模式和文件名。它应该能够遍历目录或接受文件名列表（这可能是命令行通配符扩展的结果）。这需要在 `main()`
    函数中添加一些逻辑。
- en: 'First, we need one more helper function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个额外的辅助函数：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This function calls our `matches()` function and prints the results. It takes
    a `regex` object and two `path` objects. `epath` is the result of a directory
    search, and `search_path` is the search directory itself. We'll set these in `main()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用我们的 `matches()` 函数并打印结果。它接受一个 `regex` 对象和两个 `path` 对象。`epath` 是目录搜索的结果，而
    `search_path` 是搜索的目录本身。我们将在 `main()` 中设置这些。
- en: 'In `main()`, we use the `argc` and `argv` command-line arguments and we declare
    a few variables:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 中，我们使用 `argc` 和 `argv` 命令行参数，并声明了一些变量：
- en: '[PRE67]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The variables declared here are:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里声明的变量有：
- en: '`arg_pat` is for the regular expression pattern from the command line'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg_pat` 是用于命令行中的正则表达式模式。'
- en: '`re` is the `regex` object'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re` 是 `regex` 对象。'
- en: '`search_path` is the command-line search path argument'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search_path` 是命令行搜索路径参数。'
- en: '`matchcount` is for counting the matched lines'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matchcount` 用于计算匹配的行数。'
- en: 'Continuing in `main()`, if we have no arguments, then we print a short usage
    string:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续在 `main()` 中，如果没有参数，则打印一个简短的用法字符串：
- en: '[PRE68]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`argv[1]` is always the invoking command from the command line. `cmdname` uses
    the `filename()` method to return a `path` with just the filename part of the
    invoking command path.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv[1]` 总是命令行中的调用命令。`cmdname` 使用 `filename()` 方法返回一个只包含调用命令路径文件名的 `path`。'
- en: 'Next, we parse the regular expression. We use a `try-catch` block to capture
    any error from the `regex` parser:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们解析正则表达式。我们使用 `try-catch` 块来捕获 `regex` 解析器可能产生的任何错误：
- en: '[PRE69]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We use the `icase` flag to tell the `regex` parser to ignore case.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `icase` 标志来告诉 `regex` 解析器忽略大小写。
- en: 'If `argc == 2`, we have just one argument, which we treat as the regular expression
    pattern, and we use the current directory for the search path:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `argc == 2`，我们只有一个参数，我们将其视为正则表达式模式，并使用当前目录作为搜索路径：
- en: '[PRE70]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`rdit` is an alias for the `recursive_directory_iterator` class, which traverses
    the directory tree from the starting path, returning a `directory_entry` object
    for each file it encounters. We then create a `path` object and call `pmatches()`
    to go through the file and print any regular expression matches.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`rdit`是`recursive_directory_iterator`类的别名，它从起始路径遍历目录树，为遇到的每个文件返回一个`directory_entry`对象。然后我们创建一个`path`对象并调用`pmatches()`来遍历文件并打印任何正则表达式匹配。'
- en: 'At this point in `main()`, we know that `argc` is `>=2`. Now, we handle cases
    where we have one or more file paths on the command line:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`的这个点上，我们知道`argc`是`>=2`。现在，我们处理命令行上有一个或多个文件路径的情况：
- en: '[PRE71]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `while` loop handles one or more arguments past the search pattern on the
    command line. It checks each filename to ensure it exists. Then, if it's a directory,
    it uses the `rdit` alias for the `recursive_directory_iterator` class to traverse
    the directory and call `pmatches()` to print any pattern matches in the files.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环处理命令行上的搜索模式之后的一个或多个参数。它检查每个文件名以确保它存在。然后，如果它是一个目录，它使用`rdit`别名（`recursive_directory_iterator`类）来遍历目录并调用`pmatches()`来打印文件中的任何模式匹配。'
- en: If it's a single file, it calls `pmatches()` on that file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是单个文件，它会在该文件上调用`pmatches()`。
- en: 'We can run our `grep` clone with one argument as the search pattern:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用一个搜索模式作为参数运行我们的`grep`克隆：
- en: '[PRE72]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can run it with a second argument as a directory to search:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用第二个参数作为搜索目录来运行它：
- en: '[PRE73]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice that it *traverses the directory tree* to find files in sub-directories.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它*遍历目录树*来查找子目录中的文件。
- en: 'Or we can run it with a single file argument:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以用一个单个文件参数来运行它：
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: While the main task of this utility is the regular expression matching, we're
    concentrating on the technique of recursively processing directories of files.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个实用程序的主要任务是正则表达式匹配，但我们专注于递归处理文件目录的技术。
- en: The `recursive_directory_iterator` object is interchangeable with `directory_iterator`,
    except `recursive_directory_iterator` operates recursively over all the entries
    of each sub-directory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`recursive_directory_iterator`对象与`directory_iterator`可互换，除了`recursive_directory_iterator`递归地遍历每个子目录的所有条目。'
- en: See also…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见…
- en: For more about regular expressions, see the recipe *Parse strings with Regular
    Expressions* in [*Chapter 7*](B18267_07_ePub.xhtml#_idTextAnchor212), *Strings,
    Streams, and Formatting*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于正则表达式的信息，请参阅*第7章*中的配方*使用正则表达式解析字符串*，*字符串、流和格式化*。
- en: Rename files with regex and directory_iterator
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式和目录迭代器重命名文件
- en: This is a simple utility that renames files using regular expressions. It uses
    `directory_iterator` to find the files in a directory and `fs::rename()` to rename
    them.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实用程序，使用正则表达式重命名文件。它使用`directory_iterator`在目录中查找文件，并使用`fs::rename()`来重命名它们。
- en: How to do it…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we create a file rename utility that uses regular expressions:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个使用正则表达式的文件重命名实用程序：
- en: 'We start by defining a few convenience aliases:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先定义一些便利别名：
- en: '[PRE75]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `pat_v` alias is a vector for use with our regular expressions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`pat_v`别名是一个用于正则表达式的`vector`。'
- en: 'We also continue to use the `formatter` specialization for `path` objects:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还继续使用`path`对象的`formatter`特化：
- en: '[PRE76]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We have a function for applying the regular expression replacement to filename
    strings:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个函数用于将正则表达式替换应用到文件名字符串：
- en: '[PRE77]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Notice that we loop through a `vector` of pattern/replacement pairs, applying
    the regular expressions successively. This allows us to stack our replacements.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们遍历一个包含模式/替换对的`vector`，依次应用正则表达式。这允许我们堆叠我们的替换。
- en: 'In `main()`, we first check the command-line arguments:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`中，我们首先检查命令行参数：
- en: '[PRE78]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The command line accepts one or more *pairs of strings*. Each pair of strings
    includes a *regex* (regular expression) followed by a *replacement*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行接受一个或多个字符串对。每个字符串对包括一个正则表达式（正则表达式）后跟一个替换。
- en: 'Now we populate the `vector` with `regex` and `string` objects:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们用`regex`和`string`对象填充`vector`：
- en: '[PRE79]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `pair` constructor constructs the `regex` and `string` objects in place,
    from the C-strings passed on the command line. These are added to the `vector`
    with the `emplace_back()` method.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`pair`构造函数在原地构造`regex`和`string`对象，从命令行传递的C-字符串。这些通过`emplace_back()`方法添加到`vector`中。'
- en: 'We search the current directory using a `directory_iterator` object:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`directory_iterator`对象在当前目录中搜索：
- en: '[PRE80]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this `for` loop, we call `replace_str()` to get the replacement filename
    and then check that the new name is not a duplicate of a file in the directory.
    We use the `replace_filename()` method on a `path` object to create a `path` with
    the new filename and use `fs::rename()` to rename the file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `for` 循环中，我们调用 `replace_str()` 来获取替换后的文件名，然后检查新名称不是目录中文件的重复项。我们在 `path`
    对象上使用 `replace_filename()` 方法来创建具有新文件名的 `path`，并使用 `fs::rename()` 来重命名文件。
- en: 'To test the utility, I''ve created a directory with a few files in it for renaming:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了测试这个实用程序，我创建了一个包含一些文件的目录以进行重命名：
- en: '[PRE81]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can do something simple, like change `.cpp` to `.Cpp`:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做一些简单的事情，比如将 `.cpp` 改为 `.Cpp`：
- en: '[PRE82]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s change them back again:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次更改它们：
- en: '[PRE83]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Using standard regular expression syntax, I can add "`bw`" to the beginning
    of each of the filenames:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准的正则表达式语法，我可以将 "`bw`" 添加到每个文件名的开头：
- en: '[PRE84]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Notice that it even renamed the files that already had "`bw`" at the beginning.
    Let''s have it not do that. First, we restore the filenames:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它甚至重命名了那些已经以 "`bw`" 开头的文件。让我们让它不要这样做。首先，我们恢复文件名：
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now we use a *regex* that checks if the filename already begins with "`bw`":'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用一个检查文件名是否以 "`bw`" 开头的正则表达式：
- en: '[PRE86]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Because we use a `vector` of regex/replacement strings, we can stack several
    replacements:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用正则表达式/替换字符串的 `vector`，所以我们可以堆叠多个替换：
- en: '[PRE87]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `filesystem` part of this recipe uses `directory_iterator` to return a
    `directory_entry` object for each file in the current directory:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱中的 `filesystem` 部分使用 `directory_iterator` 返回当前目录中每个文件的 `directory_entry`
    对象：
- en: '[PRE88]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We then construct a `path` object from the `directory_entry` object to process
    the file.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从 `directory_entry` 对象构造一个 `path` 对象来处理文件。
- en: 'We use the `replace_filename()` method on a `path` object to create the destination
    for the rename operation:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `path` 对象上使用 `replace_filename()` 方法来创建重命名操作的目标：
- en: '[PRE89]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here, we create a duplicate and change its name, giving us both sides for the
    rename operation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个副本并更改其名称，这样我们就有两个用于重命名操作的版本：
- en: '[PRE90]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'On the regular expression side of the recipe, we use `regex_replace()`, which
    uses regular expression syntax to perform substitutions in a string:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式的这一侧，我们使用 `regex_replace()`，它使用正则表达式语法在字符串中执行替换：
- en: '[PRE91]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Regular expression syntax is extremely powerful. It even allows replacements
    to include sections of the search string:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语法非常强大。它甚至允许替换包括搜索字符串的部分：
- en: '[PRE92]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: By using parentheses in the search pattern, I can easily rearrange parts of
    a filename.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在搜索模式中使用括号，我可以轻松地重新排列文件名的一部分。
- en: See also…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见…
- en: For more about regular expressions, see the recipe *Parse strings with Regular
    Expressions* in [*Chapter 7*](B18267_07_ePub.xhtml#_idTextAnchor212), *Strings,
    Streams, and Formatting*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于正则表达式的信息，请参阅 *第7章* 中的食谱 *使用正则表达式解析字符串*，*字符串、流和格式化*。
- en: Create a disk usage counter
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建磁盘使用计数器
- en: This is a simple utility that totals the size of every file in a directory and
    its sub-directories. It runs on both POSIX/Unix and Windows file systems.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实用程序，它计算目录及其子目录中每个文件的总大小。它可以在 POSIX/Unix 和 Windows 文件系统上运行。
- en: How to do it…
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'This recipe is a utility to report the size of every file in a directory and
    its sub-directories, along with a total. We''ll re-use some of the functions we''ve
    used elsewhere in this chapter:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是一个实用程序，用于报告目录及其子目录中每个文件的大小，以及总大小。我们将重用本章其他地方使用的一些函数：
- en: 'We start with a few convenience aliases:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一些便利别名开始：
- en: '[PRE93]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We also use our `format` specialization for `fs::path` objects:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用了我们的 `format` 特化 `fs::path` 对象：
- en: '[PRE94]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'For reporting the size of the directory, we''ll use this `make_commas()` function:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了报告目录的大小，我们将使用这个 `make_commas()` 函数：
- en: '[PRE95]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We've used this before. It inserts a comma before every third character from
    the end.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用过这个。它在每个第三个字符之前插入一个逗号。
- en: 'To sort our directory, we''ll need a lowercase string function:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了对目录进行排序，我们需要一个将字符串转换为小写的函数：
- en: '[PRE96]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We need a comparison predicate for sorting `directory_entry` objects by the
    lowercase of the `path` name:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个比较谓词来按 `path` 名称的小写对 `directory_entry` 对象进行排序：
- en: '[PRE97]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`size_string()` returns abbreviated values for reporting file size in gigabytes,
    megabytes, kilobytes, or bytes:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size_string()` 返回用于报告文件大小的缩写值，单位为千兆字节、兆字节、千字节或字节：'
- en: '[PRE98]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`entry_size()` returns the size of a file or, if it''s a directory, the recursive
    size of the directory:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_size()` 返回文件的大小，如果是目录，则返回目录的递归大小：'
- en: '[PRE99]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In `main()`, we start with declarations and test if we have a valid directory
    to search:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`中，我们开始声明并测试是否有有效的目录要搜索：
- en: '[PRE100]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'For our directory path, `dir`, we use `argv[1]` if we have an argument; otherwise,
    we use `current_path()` for the current directory. Then we set up an environment
    for our usage counter:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目录路径`dir`，如果我们有一个参数，我们使用`argv[1]`；否则，我们使用`current_path()`表示当前目录。然后我们为我们的使用计数器设置一个环境：
- en: The `vector` of `directory_entry` objects is used for sorting our response.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory_entry`对象的`vector`用于对响应进行排序。'
- en: '`accum` is used to accumulate values for our final size total.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accum`用于累计我们最终的总大小值。'
- en: We make sure `dir` exists and is a directory before proceeding to examine the
    directory.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查目录之前，我们确保`dir`存在并且是一个目录。
- en: 'Next, a simple loop to populate the `vector`. Once populated, we sort `entries`
    using our `dircmp_lc()` function as a comparison predicate:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，一个简单的循环来填充`vector`。一旦填充完成，我们使用我们的`dircmp_lc()`函数作为比较谓词对`entries`进行排序：
- en: '[PRE101]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now that everything is set up, we can accumulate results from the sorted `vector`
    of `directory_entry` objects:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，我们可以从排序的`directory_entry`对象的`vector`中累计结果：
- en: '[PRE102]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The call to `entry_size()` returns the size of the file or directory represented
    in the `directory_entry` object.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry_size()`的调用返回由`directory_entry`对象表示的文件或目录的大小。'
- en: If the current entry is a directory (and not a *symbolic link*), we add a symbol
    to indicate it's a directory. I chose an inverted triangle. You may use anything
    here.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前条目是一个目录（而不是一个*符号链接*），我们添加一个符号来表示它是一个目录。我选择了一个倒三角形。你可以在这里使用任何东西。
- en: After the loop is complete, we display the accumulated size in both bytes with
    commas, and the abbreviated notation from `size_string()`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 循环完成后，我们以字节为单位显示累计的大小，并用逗号分隔，以及来自`size_string()`的缩写表示法。
- en: 'Our output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出：
- en: '[PRE103]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How it works…
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `fs::file_size()` function returns a `uintmax_t` value that represents the
    size of the file as the largest natural unsigned integer on a given platform.
    While this is normally a 64-bit integer on most 64-bit systems, a notable exception
    is Windows, which uses a 32-bit integer. This means that while `size_t` may work
    for this value on some systems, it fails to compile on Windows because it may
    try to promote a 64-bit value to a 32-bit value.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs::file_size()`函数返回一个`uintmax_t`值，它表示文件的大小，作为给定平台上的最大自然无符号整数。虽然这通常在大多数64位系统上是一个64位整数，但有一个值得注意的例外是Windows，它使用32位整数。这意味着虽然在某些系统上`size_t`可能适用于此值，但在Windows上它无法编译，因为它可能尝试将64位值提升为32位值。'
- en: 'The `entry_size()` function takes a `path` object and returns a `uintmax_t`
    value:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry_size()`函数接受一个`path`对象并返回一个`uintmax_t`值：'
- en: '[PRE104]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The function checks for a regular file and returns the size of the file. Otherwise,
    it checks for a directory that is not also a symbolic link. We just want the size
    of the files in a directory, so we don't want to follow symbolic links. (Symbolic
    links may also cause reference loops, leading to a runaway condition.)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 函数检查是否为常规文件，并返回文件的大小。否则，它检查是否为既不是符号链接的目录。我们只想获取目录中文件的大小，所以不想跟随符号链接。（符号链接也可能导致引用循环，导致失控状态。）
- en: If we find a directory, we loop through it, calling `entry_size()` for each
    file we encounter. This is a recursive loop, so we eventually end up with the
    size of the directory.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个目录，我们将遍历它，为遇到的每个文件调用`entry_size()`。这是一个递归循环，所以我们最终得到目录的大小。
