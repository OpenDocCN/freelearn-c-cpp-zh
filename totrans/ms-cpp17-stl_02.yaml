- en: Iterators and Ranges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器和范围
- en: 'In the previous chapter, we implemented several generic algorithms that operated
    on containers, but in an inefficient manner. In this chapter, you''ll learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了几个在容器上操作的泛型算法，但效率不高。在这一章中，你将学习：
- en: How and why C++ generalizes the idea of pointers to create the *iterator* concept
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 如何以及为什么将指针的概念泛化以创建 *迭代器* 概念
- en: The importance of *ranges* in C++, and the standard way to express a half-open
    range as a pair of iterators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 中 *范围* 的重要性，以及将半开范围表示为迭代器对的标准方法
- en: How to write your own rock-solid, const-correct iterator types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写自己的坚如磐石、const-正确的迭代器类型
- en: How to write generic algorithms that operate on iterator pairs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写在迭代器对上操作的泛型算法
- en: The standard iterator hierarchy and its algorithmic importance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准迭代器层次结构及其算法重要性
- en: The problem with integer indices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数索引的问题
- en: 'In the previous chapter, we implemented several generic algorithms that operated
    on containers. Consider one of those algorithms again:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了几个在容器上操作的泛型算法。再次考虑这些算法之一：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This algorithm is defined in terms of the lower-level operations `.size()`
    and `.at()`. This works reasonably well for a container type such as `array_of_ints`
    or `std::vector`, but it doesn''t work nearly so well for, say, a linked list
    such as the previous chapter''s `list_of_ints`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法是用较低级别的操作 `.size()` 和 `.at()` 定义的。这对于容器类型，如 `array_of_ints` 或 `std::vector`，效果相当不错，但对于，比如说，上一章的
    `list_of_ints` 这样的链表，效果就差多了：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The implementation of `list_of_ints::at()` is O(*n*) in the length of the list--the
    longer our list gets, the slower `at()` gets. And particularly, when our `count_if`
    function loops over each element of the list, it's calling that `at()` function
    *n* times, which makes the runtime of our generic algorithm O(*n*²)--for a simple
    counting operation that ought to be O(*n*)!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_of_ints::at()` 的实现是 O(*n*)，即列表的长度——列表越长，`at()` 越慢。特别是，当我们的 `count_if`
    函数遍历列表的每个元素时，它会调用那个 `at()` 函数 *n* 次，这使得我们的泛型算法的运行时间为 O(*n*²)——对于一个本应 O(*n*) 的简单计数操作！'
- en: It turns out that integer indexing with `.at()` isn't a very good foundation
    on which to build algorithmic castles. We ought to pick a primitive operation
    that's closer to how computers actually manipulate data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，使用 `.at()` 进行整数索引并不是构建算法城堡的良好基础。我们应该选择一个更接近计算机实际操作数据的原始操作。
- en: On beyond pointers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越指针
- en: 'In the absence of any abstraction, how does one normally identify an element
    of an array, an element of a linked list, or an element of a tree? The most straightforward
    way would be to use a *pointer* to the element''s address in memory. Here are
    some examples of pointers to elements of various data structures:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何抽象的情况下，一个人通常如何识别数组、链表或树中的元素？最直接的方法是使用指向元素内存地址的 *指针*。以下是一些指向各种数据结构元素的指针示例：
- en: '![](img/00005.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: 'To iterate over an *array*, all we need is that pointer; we can handle all
    the elements in the array by starting with a pointer to the first element and
    simply incrementing that pointer until it reaches the last element. In C:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历一个 *数组*，我们只需要那个指针；我们可以通过从指向第一个元素的指针开始，简单地递增该指针直到它达到最后一个元素来处理数组中的所有元素。在 C
    语言中：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But in order to efficiently iterate over a *linked list*, we need more than
    just a raw pointer; incrementing a pointer of type `node*` is highly unlikely
    to produce a pointer to the next node in the list! In that case, we need something
    that acts like a pointer--in particular, we should be able to dereference it to
    retrieve or modify the pointed-to element--but has special, container-specific
    behavior associated with the abstract concept of incrementing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了有效地遍历一个 *链表*，我们需要的不仅仅是原始指针；递增 `node*` 类型的指针几乎不可能产生指向列表中下一个节点的指针！在这种情况下，我们需要某种类似于指针的东西——特别是，我们应该能够解引用它来检索或修改指向的元素——但与增量这一抽象概念相关联的特殊、容器特定的行为。
- en: 'In C++, given that we have operator overloading built into the language, when
    I say "associate special behavior with the concept of incrementing", you should
    be thinking "let''s overload the `++` operator." And indeed, that''s what we''ll
    do:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，鉴于我们已经在语言中内置了操作符重载，当我说“将特殊行为与增量概念关联”时，你应该想到“让我们重载 `++` 操作符。”确实，这正是我们将要做的：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we also overload the unary `*` operator (for dereferencing) and
    the `==` and `!=` operators; our `count_if` template requires all of these operations
    be valid for the loop control variable `it`. (Well, okay, technically our `count_if`
    doesn't require the `==` operation; but if you're going to overload one of the
    comparison operators, you should overload the other as well.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还重载了单目`*`运算符（用于解引用）和`==`和`!=`运算符；我们的`count_if`模板要求所有这些操作对循环控制变量`it`都有效。（好吧，好吧，技术上我们的`count_if`不需要`==`操作；但如果你要重载一个比较运算符，你应该也重载另一个。）
- en: Const iterators
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量迭代器
- en: There's just one more complication to consider, before we abandon this list
    iterator example. Notice that I quietly changed our `count_if` function template
    so that it takes `Container&` instead of `const Container&`! That's because the
    `begin()` and `end()` member functions we provided are non-const member functions;
    and that's because they return iterators whose `operator*` returns non-const references
    to the elements of the list. We'd like to make our list type (and its iterators)
    completely const-correct--that is, we'd like you to be able to define and use
    variables of type `const list_of_ints`, but prevent you from modifying the elements
    of a `const` list.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们放弃这个列表迭代器例子之前，还有一个问题需要考虑。请注意，我悄悄地改变了我们的`count_if`函数模板，使其接受`Container&`而不是`const
    Container&`！这是因为我们提供的`begin()`和`end()`成员函数是非const成员函数；而且是因为它们返回的迭代器的`operator*`返回对列表元素的non-const引用。我们希望我们的列表类型（及其迭代器）完全符合const的正确性--也就是说，我们希望你能定义并使用`const
    list_of_ints`类型的变量，但防止你修改`const`列表的元素。
- en: 'The standard library generally deals with this issue by giving each standard
    container two different kinds of iterator: `bag::iterator` and `bag::const_iterator`.
    The non-const member function `bag::begin()` returns an `iterator` and the `bag::begin()
    const` member function returns a `const_iterator`. The underscore is all-important!
    Notice that `bag::begin() const` does not return a mere `const iterator`; if the
    returned object were `const`, we wouldn''t be allowed to `++` it. (Which, in turn,
    would make it darn difficult to iterate over a `const bag`!) No, `bag::begin()
    const` returns something more subtle: a non-const `const_iterator` object whose
    `operator*` simply happens to yield a *const* reference to its element.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库通常通过为每个标准容器提供两种不同类型的迭代器来处理这个问题：`bag::iterator`和`bag::const_iterator`。非const成员函数`bag::begin()`返回一个`iterator`，而`bag::begin()
    const`成员函数返回一个`const_iterator`。下划线非常重要！请注意，`bag::begin() const`并不返回一个普通的`const
    iterator`；如果返回的对象是`const`的，我们就不能对它进行`++`操作。（这反过来会使遍历`const bag`变得非常困难！）不，`bag::begin()
    const`返回的是一个更微妙的东西：一个非const的`const_iterator`对象，其`operator*`恰好返回一个*const*引用到其元素。
- en: Maybe an example would help. Let's go ahead and implement `const_iterator` for
    our `list_of_ints` container.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一个例子会有所帮助。让我们继续为我们的`list_of_ints`容器实现`const_iterator`。
- en: 'Since most of the code for the `const_iterator` type is going to be exactly
    the same as the code for the `iterator` type, our first instinct might be to cut
    and paste. But this is C++! When I say "most of this code is going to be exactly
    the same as this other code," you should be thinking "let''s make the common parts
    into a template." And indeed, that''s what we''ll do:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`const_iterator`类型的代码大部分将与`iterator`类型的代码完全相同，我们的第一反应可能是剪切和粘贴。但这是C++！当我这么说“大部分代码将与另一部分代码完全相同”时，你应该在想“让我们将公共部分变成一个模板。”确实，这就是我们将要做的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code implements fully const-correct iterator types for our `list_of_ints`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了对`list_of_ints`完全符合const的迭代器类型。
- en: A pair of iterators defines a range
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一对迭代器定义了一个范围
- en: 'Now that we understand the fundamental concept of an iterator, let''s put it
    to some practical use. We''ve already seen that if you have a pair of iterators
    as returned from `begin()` and `end()`, you can use a for-loop to iterate over
    all the elements of the underlying container. But more powerfully, you can use
    some pair of iterators to iterate over any sub-range of the container''s elements!
    Let''s say you only wanted to view the first half of a vector:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了迭代器的根本概念，让我们将其应用于一些实际用途。我们已经看到，如果你有一个由`begin()`和`end()`返回的迭代器对，你可以使用for循环遍历底层容器的所有元素。但更强大的是，你可以使用一对迭代器来遍历容器元素中的任何子范围！比如说，你只想查看向量的前半部分：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that in the first and second test cases in `main()` we pass in a pair
    of iterators derived from `v.begin()`; that is, two values of type `std::vector::iterator`.
    In the third test case, we pass in two values of type `int*`. Since `int*` satisfies
    all the requirements of an iterator type in this case--namely: it is incrementable,
    comparable, and dereferenceable--our code works fine even with pointers! This
    example demonstrates the flexibility of the iterator-pair model. (However, in
    general you should avoid messing around with raw pointers, if you''re using a
    container such as `std::vector` that offers a proper `iterator` type. Use iterators
    derived from `begin()` and `end()` instead.)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `main()` 的第一个和第二个测试用例中，我们传递了从 `v.begin()` 派生的迭代器对；也就是说，两个 `std::vector::iterator`
    类型的值。在第三个测试用例中，我们传递了两个 `int*` 类型的值。由于在这种情况下 `int*` 满足迭代器类型的所有要求——即它是可增量的、可比较的和可解引用的——我们的代码即使与指针一起使用也能正常工作！这个例子展示了迭代器对模型的灵活性。（然而，一般来说，如果你使用的是像
    `std::vector` 这样的容器，它提供了适当的 `iterator` 类型，你应该避免与原始指针打交道。请使用从 `begin()` 和 `end()`
    派生的迭代器。）
- en: We can say that a pair of iterators implicitly defines a *range* of data elements.
    And for a surprisingly large family of algorithms, that's good enough! We don't
    need to have access to the *container* in order to perform certain searches or
    transformations; we only need access to the particular *range* of elements being
    searched or transformed. Going further down this line of thought will eventually
    lead us to the concept of a *non-owning view* (which is to a data sequence as
    a C++ reference is to a single variable), but views and ranges are still more
    modern concepts, and we ought to finish up with the 1998-vintage STL before we
    talk about those things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，一对迭代器隐式地定义了一个数据元素的范围。对于大量令人惊讶的算法，这已经足够了！我们不需要访问 *容器* 就能执行某些搜索或转换；我们只需要访问正在搜索或转换的特定
    *范围* 的元素。沿着这条思路进一步思考最终将引导我们到 *非拥有视图* 的概念（这类似于 C++ 引用对单个变量的关系），但视图和范围仍然是更现代的概念，在我们讨论那些事情之前，我们应该先完成
    1998 年风格的 STL。
- en: In the previous code sample, we saw the first example of a real STL-style generic
    algorithm. Admittedly, `double_each_element` is not a terribly generic algorithm
    in the sense of implementing a behavior that we might want to reuse in other programs;
    but this version of the function is now perfectly generic in the sense of operating
    only on pairs of `Iterators`, where `Iterator` can be any type in the world that
    implements incrementability, comparability, and dereferenceability. (We'll see
    a version of this algorithm that is more generic in that first sense in this book's
    next chapter, when we talk about `std::transform`.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们看到了第一个真正的 STL 风格泛型算法的例子。诚然，`double_each_element` 并不是一个在实现我们可能在其他程序中希望重用的行为方面的非常泛型算法；但这个函数版本的泛型性现在在仅操作
    `Iterators` 对（其中 `Iterator` 可以是任何实现了增量、比较和解引用能力的类型）方面是完美的。（我们将在本书的下一章中看到这个算法在这个意义上的一个更泛型的版本，当我们讨论
    `std::transform` 时。）
- en: Iterator categories
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器类别
- en: Let's revisit the `count` and `count_if` functions that we introduced in
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新回顾一下我们在之前代码示例中介绍的 `count` 和 `count_if` 函数。
- en: '[Chapter 1](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d), *Classical
    Polymorphism and Generic Programming*. Compare the function template definition
    in this next example to the similar code from that chapter; you''ll see that it''s
    identical except for the substitution of a pair of `Iterators` (that is, an implicitly
    defined *range*) for the `Container&` parameter--and except that I''ve changed
    the name of the first function from `count` to `distance`. That''s because you
    can find this function, almost exactly as described here, in the Standard Template
    Library under the name `std::distance` and you can find the second function under
    the name `std::count_if`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d)，*经典多态和泛型编程*。比较这个下一个示例中的函数模板定义与该章节中类似的代码；你会发现除了用一对
    `Iterators`（即隐式定义的范围）替换了 `Container&` 参数——以及我将第一个函数的名称从 `count` 改为 `distance`
    之外，它们是相同的。这是因为你可以在标准模板库中几乎以这里描述的完全相同的方式找到这个函数，命名为 `std::distance`，你可以在 `std::count_if`
    的名称下找到第二个函数：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But let''s consider the line marked `DUBIOUS` in that example. Here we''re
    computing the distance between two `Iterators` by repeatedly incrementing the
    one until it reaches the other. How performant is this approach? For certain kinds
    of iterators--for example, `list_of_ints::iterator`--we''re not going to be able
    to do better than this. But for `vector::iterator` or `int*`, which iterate over
    contiguous data, it''s a little silly of us to be using a loop and an O(n) algorithm
    when we could accomplish the same thing in O(1) time by simple pointer subtraction.
    That is, we''d like the standard library version of `std::distance` to include
    a template specialization something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们考虑那个例子中标记为`DUBIOUS`的行。在这里，我们通过反复递增一个迭代器直到它达到另一个迭代器来计算两个迭代器之间的距离。这种方法有多高效？对于某些类型的迭代器——例如，`list_of_ints::iterator`——我们可能无法做得比这更好。但对于迭代连续数据的`vector::iterator`或`int*`，当我们可以在O(1)时间内通过简单的指针减法完成相同的事情时，使用循环和O(n)算法就显得有些愚蠢。也就是说，我们希望标准库版本的`std::distance`包含一个类似于以下的模板特殊化：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But we don''t want the specialization to exist only for `int*` and `std::vector::iterator`.
    We want the standard library''s `std::distance` to be efficient for all the iterator
    types that support this particular operation. That is, we''re starting to develop
    an intuition that there are (at least) two different kinds of iterators: there
    are those that are incrementable, comparable, and dereferenceable; and then there
    are those that are incrementable, comparable, dereferenceable, *and also subtractable!*
    It turns out that for any iterator type where the operation `i = p - q` makes
    sense, its inverse operation `q = p + i` also makes sense. Iterators that support
    subtraction and addition are called *random-access iterators*.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不想让这种专业化只存在于`int*`和`std::vector::iterator`上。我们希望标准库中的`std::distance`对所有支持这种特定操作的迭代器类型都有效。也就是说，我们开始有了这样的直觉：存在（至少）两种不同的迭代器：一种是可递增、可比较和可解引用的；然后还有一种是可递增、可比较、可解引用，*并且还可以进行减法操作!*
    事实证明，对于任何可以进行操作`i = p - q`的迭代器类型，其逆操作`q = p + i`也是有意义的。支持减法和加法的迭代器被称为*随机访问迭代器*。
- en: So, the standard library's `std::distance` ought to be efficient for both random-access
    iterators and other kinds of iterators. To make it easier to supply the partial
    specializations for these templates, the standard library introduced the idea
    of a hierarchy of iterator kinds. Iterators such as `int*`, which support addition
    and subtraction, are known as random-access iterators. We'll say that they satisfy
    the concept `RandomAccessIterator`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，标准库中的`std::distance`应该对随机访问迭代器和其他类型的迭代器都有效。为了使提供这些模板的部分特殊化更容易，标准库引入了迭代器种类层次的概念。例如，支持加法和减法的`int*`迭代器被称为随机访问迭代器。我们将说它们满足`RandomAccessIterator`的概念。
- en: Iterators slightly less powerful than random-access iterators might not support
    addition or subtraction of arbitrary distances, but they at least support incrementing
    and decrementing with `++p` and `--p`. Iterators of this nature are called `BidirectionalIterator`.
    All `RandomAccessIterator` are `BidirectionalIterator`, but not necessarily vice
    versa. In some sense, we can imagine `RandomAccessIterator` to be a sub-class
    or sub-concept relative to `BidirectionalIterator`; and we can say that `BidirectionalIterator`
    is a *weaker concept*, imposing fewer requirements, than `RandomAccessIterator`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 比随机访问迭代器稍微弱一些的迭代器可能不支持任意距离的加法和减法，但它们至少支持使用`++p`和`--p`进行递增和递减。这种性质的迭代器被称为`BidirectionalIterator`。所有`RandomAccessIterator`都是`BidirectionalIterator`，但反之不一定成立。在某种意义上，我们可以将`RandomAccessIterator`想象成是相对于`BidirectionalIterator`的子类或子概念；我们可以说`BidirectionalIterator`是一个*更弱的概念*，它提出了更少的要求，相对于`RandomAccessIterator`。
- en: An even weaker concept is the kind of iterators that don't even support decrementing.
    For example, our `list_of_ints::iterator` type doesn't support decrementing, because
    our linked list has no previous pointers; once you've got an iterator pointing
    at a given element of the list, you can only move forward to later elements, never
    backward to previous ones. Iterators that support `++p` but not `--p` are called
    `ForwardIterator`. `ForwardIterator` is a weaker concept than `BidirectionalIterator`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更弱的概念是那些甚至不支持递减的迭代器。例如，我们的`list_of_ints::iterator`类型不支持递减，因为我们的链表没有前向指针；一旦你得到了指向列表中某个元素的迭代器，你只能向前移动到后面的元素，而不能向后移动到前面的元素。支持`++p`但不支持`--p`的迭代器被称为`ForwardIterator`。`ForwardIterator`是一个比`BidirectionalIterator`更弱的概念。
- en: Input and output iterators
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出迭代器
- en: 'We can imagine even weaker concepts than `ForwardIterator`! For example, one
    useful thing you can do with a `ForwardIterator` is to make a copy of it, save
    the copy, and use it to iterate twice over the same data. Manipulating the iterator
    (or copies of it) doesn''t affect the underlying range of data at all. But we
    could invent an iterator like the one in the following snippet, where there is
    no underlying data at all, and it''s not even meaningful to make a copy of the
    iterator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以想象比 `ForwardIterator` 更弱的概念！例如，你可以用 `ForwardIterator` 做的一件有用的事情是复制它，保存这个副本，然后使用它对相同的数据进行两次迭代。操作迭代器（或其副本）根本不会影响底层的数据范围。但我们可以发明一个像下面片段中的迭代器，其中根本没有底层数据，甚至复制迭代器都没有意义：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (In fact, the standard library contains some iterator types very similar to
    this one; we'll discuss one such type, `std::istream_iterator`, in [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d),
    *Iostreams*.) Such iterators, which are not meaningfully copyable, and do not
    point to data elements in any meaningful sense, are called `InputIterator` types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: （实际上，标准库包含一些与这个非常相似的迭代器类型；我们将在第 9 章*iostreams*中讨论这种类型，即 `std::istream_iterator`。）这种迭代器，不可有意义地复制，并且不在任何有意义的意义上指向数据元素，被称为
    `InputIterator` 类型。
- en: 'The mirror-image case is also possible. Consider the following invented iterator
    type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 反映这种情况也是可能的。考虑以下发明的迭代器类型：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (Again, the standard library contains some iterator types very similar to this
    one; we'll discuss `std::back_insert_iterator` in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*, and `std::ostream_iterator` in [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d),
    *Iostreams.*) Such iterators, which are not meaningfully copyable, and are writeable-into
    but not readable-out-of, are called `OutputIterator` types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: （同样，标准库包含一些与这个非常相似的迭代器类型；我们将在第 3 章*迭代器对算法*中讨论 `std::back_insert_iterator`，在第
    9 章*iostreams*中讨论 `std::ostream_iterator`。）这种迭代器，不可有意义地复制，可写入但不可读出，被称为 `OutputIterator`
    类型。
- en: 'Every iterator type in C++ falls into at least one of the following five categories:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的每个迭代器类型至少属于以下五个类别之一：
- en: '`InputIterator`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputIterator`'
- en: '`OutputIterator`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutputIterator`'
- en: '`ForwardIterator`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForwardIterator`'
- en: '`BidirectionalIterator`, and/or'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BidirectionalIterator`，和/或'
- en: '`RandomAccessIterator`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RandomAccessIterator`'
- en: 'Notice that while it''s easy to figure out at compile time whether a particular
    iterator type conforms to the `BidirectionalIterator` or `RandomAccessIterator`
    requirements, it''s impossible to figure out (purely from the syntactic operations
    it supports) whether we''re dealing with an `InputIterator`, an `OutputIterator`,
    or a `ForwardIterator`. In our examples just a moment ago, consider: `getc_iterator`,
    `putc_iterator`, and `list_of_ints::iterator` support exactly the same syntactic
    operations--dereferencing with `*it`, incrementing with `++it`, and comparison
    with `it != it`. These three classes differ only at the semantic level. So how
    can the standard library distinguish between them?'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然编译时很容易确定一个特定的迭代器类型是否符合 `BidirectionalIterator` 或 `RandomAccessIterator`
    的要求，但仅从它支持的语法操作中，我们无法确定我们是在处理 `InputIterator`、`OutputIterator` 还是 `ForwardIterator`。在我们刚才的例子中，考虑一下：`getc_iterator`、`putc_iterator`
    和 `list_of_ints::iterator` 支持完全相同的语法操作——使用 `*it` 解引用，使用 `++it` 增量，以及使用 `it !=
    it` 进行比较。这三个类仅在语义层面上有所不同。那么，标准库如何区分它们呢？
- en: 'It turns out that the standard library needs a bit of help from the implementor
    of each new iterator type. The standard library''s algorithms will work only with
    iterator classes which define a *member typedef* named `iterator_category`. That
    is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，标准库需要从每个新迭代器的实现者那里得到一点帮助。标准库的算法仅与定义了名为 `iterator_category` 的 *成员类型别名* 的迭代器类一起工作。也就是说：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then any standard (or heck, non-standard) algorithm that wants to customize
    its behavior based on the iterator categories of its template type parameters
    can do that customization simply by inspecting those types' `iterator_category`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，任何想要根据其模板类型参数的迭代器类别来定制其行为的标准（或者，天哪，非标准）算法都可以通过检查这些类型的 `iterator_category`
    来简单地完成这种定制。
- en: 'The iterator categories described in the preceding paragraph, correspond to
    the following five standard tag types defined in the `<iterator>` header:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段中描述的迭代器类别对应于在 `<iterator>` 头文件中定义的以下五个标准标记类型：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that `random_access_iterator_tag` actually derives (in the classical-OO,
    polymorphic-class-hierarchy sense) from `bidirectional_iterator_tag`, and so on:
    the *conceptual hierarchy* of iterator kinds is reflected in the *class hierarchy*
    of `iterator_category` tag classes. This turns out to be useful in template metaprogramming
    when you''re doing tag dispatch; but all you need to know about it for the purposes
    of using the standard library is that if you ever want to pass an `iterator_category`
    to a function, a tag of type `random_access_iterator_tag` will be a match for
    a function expecting an argument of type `bidirectional_iterator_tag`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`random_access_iterator_tag`实际上（在经典面向对象、多态类层次结构的意义上）从`bidirectional_iterator_tag`派生，依此类推：迭代器种类的*概念层次结构*反映在`iterator_category`标签类的*类层次结构*中。这最终在模板元编程中很有用，当你进行标签分派时；但为了使用标准库的目的，你需要知道的是，如果你想要将一个`iterator_category`传递给一个函数，一个类型为`random_access_iterator_tag`的标签将匹配一个期望参数类型为`bidirectional_iterator_tag`的函数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point I expect you''re wondering: "But what about `int*`? How can we
    provide a member typedef to something that isn''t a class type at all, but rather
    a primitive scalar type? Scalar types can''t have member typedefs." Well, as with
    most problems in software engineering, this problem can be solved by adding a
    layer of indirection. Rather than referring directly to `T::iterator_category`,
    the standard algorithms are careful always to refer to `std::iterator_traits<T>::iterator_category`.
    The class template `std::iterator_traits<T>` is appropriately specialized for
    the case where `T` is a pointer type.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能正在想：“但是关于`int*`怎么办？我们如何为根本不是类类型的原始标量类型提供一个成员类型定义？标量类型不能有成员类型定义。”好吧，就像软件工程中的大多数问题一样，这个问题可以通过添加一层间接引用来解决。标准算法总是小心地直接引用`T::iterator_category`，而不是`std::iterator_traits<T>::iterator_category`。当`T`是一个指针类型时，类模板`std::iterator_traits<T>`会相应地专门化。
- en: 'Furthermore, `std::iterator_traits<T>` proved to be a convenient place to hang
    other member typedefs. It provides the following five member typedefs, if and
    only if `T` itself provides all five of them (or if `T` is a pointer type): `iterator_category`,
    `difference_type`, `value_type`, `pointer`, and `reference`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`std::iterator_traits<T>`证明是一个方便的地方来挂载其他成员类型定义。如果`T`本身提供了所有五个（或者如果`T`是一个指针类型），则它提供了以下五个成员类型定义：`iterator_category`、`difference_type`、`value_type`、`pointer`和`reference`。
- en: Putting it all together
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些综合起来
- en: Putting together everything we've learned in this chapter, we can now write
    code like the following example. In this example, we're implementing our own `list_of_ints`
    with our own iterator class (including a const-correct `const_iterator` version);
    and we're enabling it to work with the standard library by providing the five
    all-important member typedefs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章所学的一切综合起来，我们现在可以编写如下示例代码。在这个例子中，我们正在实现自己的`list_of_ints`，包括我们自己的迭代器类（包括一个正确的`const_iterator`版本）；并且我们通过提供五个至关重要的成员类型定义，使其能够与标准库一起工作。
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, to show that we understand how the standard library implements generic
    algorithms, we'll implement the function templates `distance` and `count_if` exactly
    as the C++17 standard library would implement them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了表明我们理解标准库如何实现泛型算法，我们将按照C++17标准库的实现方式，精确地实现函数模板`distance`和`count_if`。
- en: Notice the use of C++17's new `if constexpr` syntax in `distance`. We won't
    talk about C++17 core language features very much in this book, but suffice it
    to say, you can use `if constexpr` to eliminate a lot of awkward boilerplate compared
    to what you'd have had to write in C++14.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`distance`中使用C++17的新`if constexpr`语法。在这本书中，我们不会过多地讨论C++17的核心语言特性，但可以说，你可以使用`if
    constexpr`来消除与C++14相比需要编写的许多尴尬的样板代码。
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next chapter we'll stop implementing so many of our own function templates
    from scratch, and start marching through the function templates provided by the
    Standard Template Library. But before we leave this deep discussion of iterators,
    there's one more thing I'd like to talk about.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将停止从头实现我们自己的许多函数模板，而是开始遍历标准模板库提供的函数模板。但在我们离开对迭代器的深入讨论之前，还有一件事我想谈谈。
- en: The deprecated std::iterator
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已弃用的std::iterator
- en: 'You might be wondering: "Every iterator class I implement needs to provide
    the same five member typedefs. That''s a lot of boilerplate--a lot of typing that
    I''d like to factor out, if I could." Is there no way to eliminate all that boilerplate?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“我实现的每个迭代器类都需要提供相同的五个成员类型定义。这有很多样板代码——很多我希望能抽象出来的打字工作。”难道没有一种方法可以消除所有这些样板代码吗？
- en: 'Well, in C++98, and up until C++17, the standard library included a helper
    class template to do exactly that. Its name was `std::iterator`, and it took five
    template type parameters that corresponded to the five member typedefs required
    by `std::iterator_traits`. Three of these parameters had "sensible defaults,"
    meaning that the simplest use-case was pretty well covered:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在 C++98 以及直到 C++17，标准库包含了一个辅助类模板来做到这一点。它的名字是 `std::iterator`，它接受五个模板类型参数，这些参数对应于
    `std::iterator_traits` 所需的五个成员类型定义。其中三个参数有“合理的默认值”，这意味着最简单的用例得到了很好的覆盖：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unfortunately for `std::iterator`, real life wasn't that simple; and `std::iterator`
    was deprecated in C++17 for several reasons that we're about to discuss.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `std::iterator` 来说，现实生活并没有那么简单；`std::iterator` 在 C++17 被废弃，原因我们即将讨论。
- en: 'As we saw in the section *Const iterators*, const-correctness requires us to
    provide a const iterator type along with every "non-const iterator" type. So what
    we really end up with, following that example, is code like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *常量迭代器* 部分所看到的，常量正确性要求我们为每个“非常量迭代器”类型提供相应的常量迭代器类型。因此，按照那个例子，我们最终得到的代码是这样的：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code isn''t any easier to read or write than the version that
    didn''t use `std::iterator`; and furthermore, using `std::iterator` in the intended
    fashion complicates our code with *public inheritance*, which is to say, something
    that looks an awful lot like the classical object-oriented class hierarchy. A
    beginner might well be tempted to use that class hierarchy in writing functions
    like this one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与没有使用 `std::iterator` 的版本相比，在可读性和可写性上并没有任何优势；此外，按照预期的方式使用 `std::iterator`
    会使我们的代码复杂化，引入了 *公有继承*，也就是说，看起来非常像经典面向对象类层次结构。一个初学者可能会被诱惑在编写像这样的函数时使用那个类层次结构：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This looks superficially similar to our examples of "polymorphic programming"
    from [Chapter 1](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d), *Classical
    Polymorphism and Generic Programming*, a function that implements different behaviors
    by taking parameters of type reference-to-base-class. But in the case of `std::iterator`
    this similarity is purely accidental and misleading; inheriting from `std::iterator`
    does *not* give us a polymorphic class hierarchy, and referring to that "base
    class" from our own functions is never the correct thing to do!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来表面上类似于我们来自 [第 1 章](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d)
    的“多态编程”示例，*经典多态和泛型编程*，一个通过接受基类引用类型的参数来实现不同行为的函数。但在 `std::iterator` 的情况下，这种相似性纯粹是偶然的，并且具有误导性；从
    `std::iterator` 继承并不会给我们一个多态类层次结构，并且从我们的函数中引用那个“基类”永远不是正确的事情！
- en: So, the C++17 standard deprecates `std::iterator` with an eye toward removing
    it completely in 2020 or some later standard. You shouldn't use `std::iterator`
    in code you write.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C++17 标准废弃了 `std::iterator`，目的是在 2020 年或之后的某个标准中完全删除它。你不应该在编写的代码中使用 `std::iterator`。
- en: However, if you use Boost in your codebase, you might want to check out the
    Boost equivalent of `std::iterator`, which is spelled `boost::iterator_facade`.
    Unlike `std::iterator`, the `boost::iterator_facade` base class provides default
    functionality for pesky member functions such as `operator++(int)` and `operator!=`
    that would otherwise be tedious boilerplate. To use `iterator_facade`, simply
    inherit from it and define a few primitive member functions such as `dereference`,
    `increment`, and `equal`. (Since our list iterator is a `ForwardIterator`, that's
    all we need. For a `BidirectionalIterator` you would also need to provide a `decrement`
    member function, and so on.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在你的代码库中使用 Boost，你可能想查看 `std::iterator` 的 Boost 等价物，它被拼写为 `boost::iterator_facade`。与
    `std::iterator` 不同，`boost::iterator_facade` 基类为一些令人烦恼的成员函数提供了默认功能，例如 `operator++(int)`
    和 `operator!=`，否则这些功能将是繁琐的样板代码。要使用 `iterator_facade`，只需从它继承并定义一些原始成员函数，例如 `dereference`、`increment`
    和 `equal`。（由于我们的列表迭代器是 `ForwardIterator`，这就足够了。对于 `BidirectionalIterator`，你还需要提供一个
    `decrement` 成员函数，依此类推。）
- en: 'Since these primitive member functions are `private`, we grant Boost access
    to them via the declaration `friend class boost::iterator_core_access;`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原始成员函数是 `private` 的，我们通过声明 `friend class boost::iterator_core_access;` 授予
    Boost 对它们的访问权限：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice that the first template type argument to `boost::iterator_facade` is
    always the class whose definition you''re writing: this is the Curiously Recurring
    Template Pattern, which we''ll see again in [Chapter 6](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d),
    *Smart Pointers*.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`boost::iterator_facade`的第一个模板类型参数始终是你正在编写的类的定义：这是奇特重复的模板模式，我们将在[第6章](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d)“智能指针”中再次看到。
- en: This list-iterator code using `boost::iterator_facade` is significantly shorter
    than the same code in the previous section; the savings comes mainly from not
    having to repeat the relational operators. Because our list iterator is a `ForwardIterator`,
    we only had two relational operators; but if it were a `RandomAccessIterator`,
    then `iterator_facade` would generate default implementations of operators `-`,
    `<`, `>`, `<=`, and `>=` all based on the single primitive member function `distance_to`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`boost::iterator_facade`的此列表迭代器代码比上一节中的相同代码要短得多；节省主要来自于不必重复关系运算符。因为我们的列表迭代器是一个`ForwardIterator`，所以我们只有两个关系运算符；但如果它是一个`RandomAccessIterator`，那么`iterator_facade`将生成基于单个原始成员函数`distance_to`的运算符
    `-`、`<`、`>`、`<=` 和 `>=` 的默认实现。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we''ve learned that traversal is one of the most fundamental
    things you can do with a data structure. However, raw pointers alone are insufficient
    for traversing complicated structures: applying `++` to a raw pointer often doesn''t
    "go on to the next item" in the intended way.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到遍历是你可以对数据结构做的最基本的事情之一。然而，仅使用原始指针不足以遍历复杂结构：对原始指针应用`++`操作通常不会以预期的“移动到下一个项目”的方式进行。
- en: The C++ Standard Template Library provides the concept of *iterator* as a generalization
    of raw pointers. Two iterators define a *range* of data. That range might be only
    part of the contents of a container; or it might be unbacked by any memory at
    all, as we saw with `getc_iterator` and `putc_iterator`. Some of the properties
    of an iterator type are encoded in its iterator category--input, output, forward,
    bidirectional, or random-access--for the benefit of function templates that can
    use faster algorithms on certain categories of iterators.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准模板库提供了*迭代器*的概念，它是原始指针的泛化。两个迭代器定义了一个*范围*的数据。这个范围可能是容器内容的一部分；或者它可能根本不依赖于任何内存，就像我们在`getc_iterator`和`putc_iterator`中看到的那样。迭代器类型的某些属性编码在其迭代器类别中--输入、输出、前向、双向或随机访问--以利于可以使用更快算法的某些迭代器类别的函数模板。
- en: If you're defining your own container type, you'll need to define your own iterator
    types as well--both const and non-const versions. Templates are a handy way to
    do that. When implementing your own iterator types, avoid the deprecated `std::iterator`,
    but consider `boost::iterator_facade`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在定义自己的容器类型，你还需要定义自己的迭代器类型--包括const和非const版本。模板是做这件事的便捷方式。在实现自己的迭代器类型时，避免使用已弃用的`std::iterator`，但可以考虑使用`boost::iterator_facade`。
