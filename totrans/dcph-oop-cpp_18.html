<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-282"><a id="_idTextAnchor783"/>18</h1>
<h1 id="_idParaDest-283"><a id="_idTextAnchor784"/>Applying the Adapter Pattern</h1>
<p><a id="_idTextAnchor785"/>This chapter will extend our quest to expand your C++ programming skills beyond core OOP concepts, with the goal of enabling you to solve recurring types of coding problems utilizing common design patterns. Incorporating design patterns in coding solutions can not only provide elegant solutions but also enhance code maintenance and provide potential opportunities for code reuse.</p>
<p>The next core design pattern that we will learn how to implement effectively in C++ is the <strong class="bold">Adapter pattern</strong>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the Adapter pattern and how it contributes to OOP</li>
<li>Understanding how to implement the Adapter pattern in C++ </li>
</ul>
<p>By the end of this chapter, you will understand the essential Adapter pattern and how it can be used to either allow two incompatible classes to communicate or to upgrade unseemly code to well-designed OO code. Adding another key design pattern to your knowledge set will refine your programming skills to help make you a more valuable programmer. </p>
<p>Let’s increase our programming skillset by examining another common design pattern, the Adapter pattern.</p>
<h1 id="_idParaDest-284"><a id="_idTextAnchor786"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter18</code> in a file named <code>Chp18-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3Kaxckc">https://bit.ly/3Kaxckc</a>.</p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor787"/><a id="_idTextAnchor788"/><a id="_idTextAnchor789"/>Understanding the Adapter pattern</h1>
<p>The <strong class="bold">Adapter pattern</strong> is a structural design pattern that provides a means for converting an existing, undesirable <a id="_idIndexMarker1149"/>interface of a class to an interface that another class expects. An <strong class="bold">Adapter class</strong> will be the link for communication between <a id="_idIndexMarker1150"/>two existing components, adapting the interfaces so that the two may share and exchange information. An Adapter allows two or more classes to work together that otherwise could not do so. </p>
<p>Ideally, an Adapter will not add functionality but will add the preferred interface for usage (or conversion) to either allow one class to be used in an expected manner or for two otherwise incompatible classes to communicate with one another. In its most simple form, an Adapter simply converts an existing class to support an expected interface as may be specified in an OO design.</p>
<p>An Adapter can be either associated with or derived from the class for which it is providing an adaptive interface. If inheritance is used, a private or protected base class is appropriate to hide the underlying implementation. If instead, the Adapter class is associated with the class having the undesirable interface, the methods in the Adapter class (with the new interfaces) will merely delegate the work to its associated class.</p>
<p>The Adapter pattern can also be used to add an OO interface to (that is, to <em class="italic">wrap an OO interface around</em>) a series of functions or other classes, allowing assorted existing components to be utilized <a id="_idIndexMarker1151"/>more naturally in an OO system. This specific type of Adapter is known as a <code>extern C</code>, to allow the linker to resolve linkage conventions between the two languages).</p>
<p>Utilizing the Adapter pattern has benefits. The Adapter allows the reuse of existing code by providing a shared <a id="_idIndexMarker1152"/>interface to allow otherwise unrelated classes to communicate. The OO programmer will now use the Adapter class directly, allowing for easier maintenance of the application. That is, most programmer interaction will be with a well-designed Adapter class, rather than with two or more odd components. A small drawback of using an Adapter is a slightly decreased performance from the added layer of code. However, most often, reusing existing components through providing a clean interface to support their interaction is a winning proposition, despite a (hopefully small) performance trade-o<a id="_idTextAnchor790"/>ff.</p>
<p>The Adapter pattern will include the following:</p>
<ul>
<li>An <strong class="bold">Adaptee</strong> class, which represents the class with desirable utilities, yet which exists in a form that <a id="_idIndexMarker1153"/>is not suitable or as expected.</li>
<li>An <strong class="bold">Adapter</strong> class, which <a id="_idIndexMarker1154"/>adapts the interface of the Adaptee class to meet the needs of the desired interface.</li>
<li>A <strong class="bold">Target</strong> class, which <a id="_idIndexMarker1155"/>represents the specific, desired interface of the application at hand. A class may be both a Target and an Adapter.</li>
<li>Optional <strong class="bold">Client</strong> classes, which will <a id="_idIndexMarker1156"/>interact with the Target class to fully define the application at hand.</li>
</ul>
<p>An Adapter pattern allows the <a id="_idIndexMarker1157"/>reuse of qualified, existing components that do not meet the interface needs of current application designs.</p>
<p>Let’s move forward to see two common applications of the Adapter pattern; one will have two potential means for implementation.</p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor791"/>Implementing the Adapter pattern</h1>
<p>Let’s explore two <a id="_idIndexMarker1158"/>common uses of the Adapter pattern. That is, creating an Adapter to bridge the gap between two incompatible class interfaces or building an Adapter to simply wrap an existing set of functions with an OO in<a id="_idTextAnchor792"/>terface. </p>
<p>We will start with the usage of an <em class="italic">Adapter</em> providing a connector between two (or more) incompatible classes. The <em class="italic">Adaptee</em> will be a well-tested class that we would like to reuse (but which has an undesirable interface), and the <em class="italic">Target</em> classes will be those specified in our OO design for an application in the making. Let’s now specify an Adapter to allow our Adaptee to work with our Target<a id="_idTextAnchor793"/> classes.</p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor794"/>Using an Adapter to provide a necessary interface to an existing class</h2>
<p>To implement the Adapter pattern, we will first need to identify our Adaptee class. We will then <a id="_idIndexMarker1159"/>create an Adapter class to modify the interface of the Adaptee. We will also identify our Target class, representing the class we need to model per our OO design. At times, our Adapter and Target may be rolled into a single class. In an actual application, we will additionally have Client classes, representing the full complement of classes found in the final application at hand. Let’s start with the Adaptee and Adapter classes, as these class definitions will begin the foundation on which to build our pattern.</p>
<p>In our example, we will specify our Adaptee class as one we are accustomed to seeing – <code>Person</code>. We will imagine that our planet has recently become aware of many other exoplanets capable of supporting life and that we have benevolently made allies with each such civilization. Further imagining that the various software systems on Earth would like to welcome and include our new friends, including <code>Romulans</code> and <code>Orkans</code>, we would like to adapt some of our existing software to easily accommodate the new demographics of our exoplanet neighbors. With that in mind, we will transform our <code>Person</code> class to include more interplanetary terminology by creating an Adapter class, <code>Humanoid</code>. </p>
<p>In our forthcoming implementation, we will use private inheritance to inherit <code>Humanoid</code> (Adapter) from <code>Person</code> (Adaptee), therefore hiding the underlying implementation of the Adaptee. We could have alternatively associated a <code>Humanoid</code> with a <code>Person</code> (an implementation we will also review in this section). We can then flesh out some derived classes of <code>Humanoid</code> within our hierarchy, such as <code>Orkan</code>, <code>Romulan</code>, and <code>Earthling</code>, to accommodate the intergalactic application at hand. The <code>Orkan</code>, <code>Romulan</code>, and <code>Earthling</code> classes can be considered our Target classes, or those that our application will instantiate. We will choose to make our Adapter class, <code>Humanoid</code>, abstract so that it is not directly instantiable. Because our specific derived classes (Target classes) can be generalized by their abstract base class type (<code>Humanoid</code>) in our application (Client), we can also consider <code>Humanoid</code> a Target class. That is, <code>Humanoid</code> can be viewed primarily as an Adapter, but secondarily as a generalized Target class. </p>
<p>Our various Client classes can utilize derived classes of <code>Humanoid</code>, making instances of each of its concrete descendants. These instances may be stored in their own specialized type <a id="_idIndexMarker1160"/>or genericized using <code>Humanoid</code> pointers. Our implementation is a modern take on the well-used Adapter desi<a id="_idTextAnchor795"/>gn pattern. </p>
<h3>Specifying the Adaptee and Adapter (private inheritance<a id="_idTextAnchor796"/> technique)</h3>
<p>Let’s take a look <a id="_idIndexMarker1161"/>at the mechanics of the first usage of our Adapter pattern, beginning <a id="_idIndexMarker1162"/>by reviewing the definition for our Adaptee class, <code>Person</code>. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp</a></p>
<pre class="source-code">
// Person is the Adaptee class (class requiring adaptation)
class Person
{
private:
    string firstName, lastName, title, greeting;
    char middleInitial  = '\0';  // in-class initialization
protected:
    void ModifyTitle(const string &amp;);  
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);
    // default copy constructor prototype is not necessary
    // Person(const Person &amp;) = default;  // copy ctor
    // Default op= suffices, so we'll comment out proto.
    // (see online code for review of implementation)
    // Person &amp;operator=(const Person &amp;); // assignment op.
    virtual ~Person()= default;  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const 
        { return lastName; }    
    const string &amp;GetTitle() const { return title; }
    char GetMiddleInitial() const { return middleInitial; }
    void SetGreeting(const string &amp;);
    virtual const string &amp;Speak() { return greeting; }
    virtual void Print() const;
};
// Assume constructors, destructor, and non-inline methods
// are implemented as expected (see online code)</pre>
<p>In the previous class definition, we notice that our <code>Person</code> class definition is as we have been <a id="_idIndexMarker1163"/>accustomed to seeing it in many other examples <a id="_idIndexMarker1164"/>throughout this book. This class is instantiable; however, <code>Person</code> is not an appropriate class to instantiate in our intergalactic application. Instead, the expected interface would be to utilize that foun<a id="_idTextAnchor797"/><a id="_idTextAnchor798"/>d in <code>Humanoid</code>. </p>
<p>With that in mind, let’s take a look at our Adapter <a id="_idTextAnchor799"/>c<a id="_idTextAnchor800"/>lass, <code>Humanoid</code>:</p>
<pre class="source-code">
<strong class="bold">class Humanoid</strong>: private Person   // Humanoid is abstract
{                           
protected:
    void SetTitle(const string &amp;t) { ModifyTitle(t); }
public:
    Humanoid() = default;   
    Humanoid(const string &amp;, const string &amp;, 
             const string &amp;, c<a id="_idTextAnchor801"/>onst string &amp;);
    // default copy constructor prototype not required
    // Humanoid(const Humanoid <a id="_idTextAnchor802"/>&amp;h) = default; 
    // default op= suffices, so commented out below, but
    // let's review how we'd write op= if needed
    // note explicit Humanoid downcast after calling base  
    // class Person::op= to match return type needed here
    // Humanoid &amp;operator=(const Humanoid &amp;h) 
    //     { return dynamic_cast&lt;Humanoid &amp;&gt; 
    //              (Person::o<a id="_idTextAnchor803"/>perator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Humanoid() override = default; // virt destructor
    // Added interfaces for the Adapter class 
    <strong class="bold">const string &amp;GetSecondaryName() const</strong> 
        { return GetFirstName(); }  
    <strong class="bold">const string &amp;GetPrimaryName() const</strong> 
        { return GetLastName(); } 
    // scope resolution needed in method to avoid recursion 
    <strong class="bold">const string &amp;GetTitle() const</strong> 
        { return Person::GetTitle();}
    <strong class="bold">void SetSalutation(const string &amp;m)</strong> { SetGreeting(m); }
    <strong class="bold">virtual void GetInfo() con<a id="_idTextAnchor804"/>st</strong> { Print(); }
    <strong class="bold">virtual const string &amp;Converse() = 0;</strong> // abstract class
};
Humanoid::Humanoid(const string &amp;n2, const string &amp;n1, 
    const string &amp;planetNation, const string &amp;greeting):
    Person(n2, n1, ' ', planetNation)
{
    SetGreeting(greeting);
}
<strong class="bold">const string &amp;Humanoid::Converse()</strong>  // default definition 
{                    // for pure virtual function - unusual
    return Speak();
}</pre>
<p>In the aforementioned <code>Humanoid</code> class, our goal is to provide an Adapter to contribute to the expected interface that our intergalactic application requires. We simply derive <code>Humanoid</code> from <code>Person</code> using private inheritance, hiding the public interfaces found in <code>Person</code> from use outside the scope of <code>Humanoid</code>. We understand that the target application (Client) would not wish for the public interfaces found in <code>Person</code> to be utilized by various subtypes of <code>Humanoid</code> instances. Notice that we are not adding functionality, only adapting the interface.</p>
<p>We then notice the <a id="_idIndexMarker1165"/>public methods introduced in <code>Humanoid</code> that provide <a id="_idIndexMarker1166"/>the desired interfaces for the Target class(es). The implementation of these interfaces is often straightforward. We simply call the inherited method defined in <code>Person</code>, which will easily complete the task at hand (but which uses an unacceptable interface to do so). For example, our <code>Humanoid::GetPrimaryName()</code> method simply calls <code>Person::GetLastName();</code> to complete the task. However, <code>GetPrimaryName()</code> may more so represent appropriate intergalactic lingo than <code>Person::GetLastName()</code>. We can see how <code>Humanoid</code> is serving as an Adapter for <code>Person</code>. We can also see how most of the member functions of the Adapter class, <code>Humanoid</code>, use inline functions to simply wrap the <code>Person</code> methods with more suitable interfaces while adding no overhead.</p>
<p>Note that it is not necessary to precede the calls to <code>Person</code> base class methods within Humanoid methods with <code>Person::</code> (except when a <code>Humanoid</code> method calls the same named method in <code>Person</code>, such as with <code>GetTitle()</code>). The scope resolution usage of <code>Person::</code> avoids potential recursion in these situations.</p>
<p>We also notice that <code>Humanoid</code> introduces an abstract polymorphic method (that is, a pure virtual function) with <a id="_idIndexMarker1167"/>the specification of <code>virtual const string &amp;Converse() = 0;</code>. We <a id="_idIndexMarker1168"/>have made the design decision that only derived classes of <code>Humanoid</code> will be instantiable. Nonetheless, we understand that public descendant classes may still be collected by their base class type of <code>Humanoid</code>. Here, <code>Humanoid</code> serves primarily as the Adapter class and secondarily as a Target class offering the suite of acceptable interfaces.</p>
<p>Notice that our pure virtual function <code>virtual const String &amp;Converse() = 0;</code> includes a default implementation. This is rare but allowed, so long as the implementation is not written inline. Here, we utilize the opportunity to specify a default behavior for <code>Humanoid::Converse()</code>, by simply calling <code>Person::Speak()</code>.</p>
<h3>Deriving concrete class<a id="_idTextAnchor805"/>es from the Adapter</h3>
<p>Next, let’s extend <a id="_idIndexMarker1169"/>our Adapter (<code>Humanoid</code>) and <a id="_idIndexMarker1170"/>take a look at one of our concrete, derived Target classes, <code>Orkan</code>:</p>
<pre class="source-code">
<strong class="bold">class Orkan</strong>: public Humanoid
{
public:
    Orkan() = default;   // default constructor
    Orkan(const string &amp;n2, const string &amp;n1, 
        const string &amp;t)<a id="_idTextAnchor806"/>: Humanoid(n2, n1, t, <strong class="bold">"Na<a id="_idTextAnchor807"/>nu nanu"</strong>)
        { }
    // default copy constructor prototype not required
    // Orkan(const Orkan &amp;h) = default;  
    // default op= suffices, so commented out below, but
    // let's review how we'd write it if needed
    // note explicit Orkan downcast after calling base  
    // class Humanoid::op= to match return type needed here
    // Orkan &amp;operator=(const Orkan &amp;h) 
    //    { return dynamic_cast&lt;Orkan &amp;&gt;
    //             (Human<a id="_idTextAnchor808"/>oid::operator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Orkan() override = default; // virtual destructor
    <strong class="bold">const string &amp;Converse() override;</strong>  
};
// Must override Converse to make Orkan a concrete class
<strong class="bold">const string &amp;Orkan::Converse()</strong>  
{                                
    return Humanoid::Converse(); // use scope resolution to
}                                // avoid recursion</pre>
<p>In our aforementioned <code>Orkan</code> class, we use public inheritance to derive <code>Orkan</code> from <code>Humanoid</code>. An <code>Orkan</code> <em class="italic">Is-A</em> <code>Humanoid</code>. As such, all of the public interfaces in <code>Humanoid</code> are <a id="_idIndexMarker1171"/>available to <code>Orkan</code> instances. Notice that our alternate constructor sets the default greeting message to <code>"Nanu nanu"</code>, per the <code>Orkan</code> dialect.</p>
<p>Because we <a id="_idIndexMarker1172"/>wish <code>Orkan</code> to be a concrete, instantiable <a id="_idIndexMarker1173"/>class, we must override <code>Humanoid::Converse()</code> and provide an implementation in the <code>Orkan</code> class. Notice, however, that <code>Orkan::Converse()</code> simply calls <code>Humanoid::Converse();</code>. Perhaps <code>Orkan</code> finds the default implementation in its base class acceptable. Notice that we use the <code>Humanoid::</code> scope resolution to qualify <code>Converse()</code> within the <code>Orkan::Converse()</code> method to avoid recursion. </p>
<p>Interestingly, had <code>Humanoid</code> not been an abstract class, <code>Orkan</code> would not have had to override <code>Converse()</code> – the default behavior would have automatically been inherited. Yet, with <code>Humanoid</code> defined as abstract, the override of <code>Converse()</code> is necessary <a id="_idIndexMarker1174"/>within <code>Orkan</code>, otherwise, <code>Orkan</code> will also <a id="_idIndexMarker1175"/>be also viewed as an abstract class. No worries! We can utilize the benefit of the default behavior of <code>Humanoid::Converse()</code> merely by calling it within <code>Orkan::Converse()</code>. This will satisfy the requirements for making <code>Orkan</code> concrete, while allowing <code>Humanoid</code> to remain abstract, while still providing the rare default behavior for <code>Converse()</code>!</p>
<p>Now, let’s take a look at our next concrete Target class, <code>Romulan</code>:</p>
<pre class="source-code">
<strong class="bold">class Romulan</strong>: public Humanoid
{
public:
    Romulan() = default;   // default constructor
    Romulan(const string &amp;n2, const string &amp;n1, 
        const strin<a id="_idTextAnchor809"/>g &amp;t): Humanoid(n2, n1, t<a id="_idTextAnchor810"/>, <strong class="bold">"jolan'tru"</strong>)
        { }
    // default copy constructor prototype not required
    // Romulan(const Romulan &amp;h) = default;
    // default op= suffices, so commented out below, but
    // let's review how we'd write it if so needed
    // note explicit Romulan downcast after calling base  
    // class Humanoid::op= to match return type needed here
    // Romulan &amp;operator=(const Romulan &amp;h) 
    //    { return dynamic_cast&lt;Romulan &amp;&gt;
    //             (<a id="_idTextAnchor811"/>Humanoid::operator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Romulan() override = default;  // virt destructor
    <strong class="bold">const string &amp;Converse() override;</strong>  
};
// Must override Converse to make Romulan a concrete class
<strong class="bold">const string &amp;Romulan::Converse()</strong>  
{                               
    return Humanoid::Converse(); // use scope resolution to
}                                // avoid recursion        </pre>
<p>Taking a comparably quick look at the aforementioned <code>Romulan</code> class, we notice that this concrete Target is similar to its sibling class, <code>Orkan</code>. We notice that the default message for the <a id="_idIndexMarker1176"/>greeting passed up to our base class <a id="_idIndexMarker1177"/>constructor is <code>"jolan'tru"</code> to reflect <code>Romulan</code> dialect. Though we could have made our implementation of <code>Romulan::Converse()</code> more intricate, we chose not to do so. We can quickly understand the full scope of this class.</p>
<p>Next, let’s take a look at our third Target class, <code>Earthling</code>:</p>
<pre class="source-code">
<strong class="bold">class Earthling</strong>: public Humanoid
{
public:
    Earthling() = default;   // default constructor
    Earthling(const string &amp;n2, const string &amp;n1, 
        const string &amp;t): Humanoid(n2, n1, t, <strong class="bold">"Hello"</strong>) { }
    // default copy constructor prototype not required
    // Earthling(const Romulan &amp;h) = default;  
    // default op= suffices, so commented out below, but
    // let's review how we'd write it if so needed
    // note explicit Earthling downcast after calling base
    // class Humanoid::op= to match return type needed here
    // Earthling &amp;operator=(const Earthling &amp;h) 
    //    { return dynamic_cast&lt;Earthling &amp;&gt;
    //             (Humanoid::operator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Earthling() override = default; // virt destructor
    <strong class="bold">const string &amp;Converse() override;</strong>  
};
// Must override to make Earthling a concrete class
<strong class="bold">const string &amp;Earthling::Converse()</strong> 
{                                                          
    return Humanoid::Converse(); // use scope resolution to
}                                // avoid recursion</pre>
<p>Again, taking <a id="_idIndexMarker1178"/>another comparably quick look at <a id="_idIndexMarker1179"/>the aforementioned <code>Earthling</code> class, we notice that this concrete Target is similar to its sibling classes, <code>Orkan</code> and <code>Romulan</code>. </p>
<p>Now that we have defined our Adaptee, Adapter, and multiple Target classes, let’s bring the pieces together by examining the Client portion of our program.</p>
<h3>Bringing the pattern components together</h3>
<p>Finally, let us <a id="_idIndexMarker1180"/>consider what a sample Client may look like in our overall application. Certainly, it may consist of many files with a variety of classes. In its simplest form, as shown next, our Client will contain a <code>main()</code> function to drive the application.</p>
<p>Let’s <a id="_idIndexMarker1181"/>now take a look at our <code>main()</code> function to see how our pattern is orchestrated:</p>
<pre class="source-code">
int main()
{
    <strong class="bold">list&lt;Humanoid *&gt; allies;</strong>
    <strong class="bold">Orkan *o1 = new Orkan("Mork", "McConnell", "Orkan");</strong>
    <strong class="bold">Romulan *r1 = new Romulan("Donatra", "Jarok", </strong>
<strong class="bold">                              "Romulan");</strong>
    <strong class="bold">Earthling *e1 = new Earthling("Eve", "Xu",</strong>
<strong class="bold">                                  "Earthling");</strong>
    // Add each specific type of Humanoid to generic list
    allies.push_back(<strong class="bold">o1</strong>);
    allies.push_back(<strong class="bold">r1</strong>);
    allies.push_back(<strong class="bold">e1</strong>);
    
    // Process the list of allies (which are Humanoid *'s 
    // Actually, each is a specialization of Humanoid!)
    for (auto *entity : allies)
    {
        entity-&gt;GetInfo();
        cout &lt;&lt; entity-&gt;Converse() &lt;&lt; endl;
    }
    // Though each type of Humanoid has a default
    // Salutation, each may expand their skills with 
    // an alternat<a id="_idTextAnchor812"/>e language
    <strong class="bold">e1-&gt;SetSalutation("Bonjour");</strong>
    <strong class="bold">e1-&gt;GetInfo();</strong>
    cout &lt;&lt; <strong class="bold">e1-&gt;Converse()</strong> &lt;&lt; endl; // Show the Earthling's 
                           // revised language capabilities
    delete o1;   // delete the heap instances
    delete r1;
    delete e1;
    return 0;
}</pre>
<p>Reviewing our aforementioned <code>main()</code> function, we first create an STL <code>list</code> of <code>Humanoid</code> pointers with <code>list&lt;Humanoid *&gt; allies;</code>. We then instantiate an <code>Orkan</code>, <code>Romulan</code>, and an <code>Earthling</code> and add each to the list using <code>allies.push_back()</code>. Again, using the Standard Template Library, we next create a list iterator to <a id="_idIndexMarker1182"/>walk through the list of pointers to <code>Humanoid</code> instances. As we iterate through our generalized list of allies, we call the approved interfaces of <code>GetInfo()</code> and <code>Converse()</code> on each item in our list (that is, for each specific type of <code>Humanoid</code>). </p>
<p>Next, we specify one specific <code>Humanoid</code>, an <code>Earthling</code>, and change this instance’s default greeting by i<a id="_idTextAnchor813"/>nvoking <code>e1-&gt;SetSalutation("Bonjour");</code>. By calling <code>Converse()</code> again on this instance (we first did so on this object generically in the aforementioned loop), we can request that the <code>Earthling</code> use <code>"Bonjour"</code> to greet allies instead of <code>"Hello"</code> (the<a id="_idTextAnchor814"/><a id="_idTextAnchor815"/><a id="_idTextAnchor816"/> default greeting for <code>Earthling</code>).</p>
<p>Let’s take a look at the output for this program:</p>
<pre>Orkan Mork McConnell
Nanu nanu
Romulan Donatra Jarok
jolan'tru
Earthling Eve Xu
Hello
Earthling Eve Xu
Bonjour</pre>
<p>In the aforementioned output, notice that the planetary specification for each <code>Humanoid</code> is displayed (<code>Orkan</code>, <code>Romulan</code>, and <code>Earthling</code>), followed by their secondary and primary names. Then, the appropriate greeting is displayed for the particular <code>Humanoid</code>. Notice that <code>Earthling</code> <code>Eve Xu</code> first converses using <code>"Hello"</code> and then later converses using <code>"Bonjour"</code>.</p>
<p>An advantage of the preceding implementation (using a private base class to derive Adapter from Adaptee) is that the coding is very straightforward. With this approach, any protected <a id="_idIndexMarker1183"/>methods in the Adaptee class can easily be carried down to be used within the scope of the Adapter methods. We will soon see that protected members will be an issue should we instead use the association as a means of connecting the Adapter to Adaptee. </p>
<p>A disadvantage of the prior mentioned approach is that it is a C++ specific implementation. Other languages do not support private base classes. Alternatively, using a public base class to define the relationship between Adapter and Adaptee would fail to conceal the unwanted Adaptee interface, and <a id="_idTextAnchor817"/><a id="_idTextAnchor818"/>would be a very poor design choice.</p>
<h3>Considering an alternate specification of<a id="_idTextAnchor819"/> Adaptee and Adapter (association)</h3>
<p>Let us now briefly <a id="_idIndexMarker1184"/>consider a slightly revised <a id="_idIndexMarker1185"/>version of the aforementioned Adapter pattern implementation. We will instead use an association to model the relationship between the Adaptee and Adapter. The concrete derived classes (Targets) will still be derived from the Adapter as before. </p>
<p>Here is an alternative implementation of our Adapter class, <code>Humanoid</code>, using an association between Adapter and Adaptee. Though we will only review the portion of the code that differs from our initial approach, the full implementation can be found as a complete program in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp</a></p>
<pre class="source-code">
// Assume that Person exists mostly as before – however,
// Person::ModifyTitle() must be moved from protected to
// public or be unused if modifying Person is not possible.
// Let's assume we moved Person::ModifyTitle() to public.
<strong class="bold">class Humanoid</strong>    // Humanoid is abstract
{
private:
    <strong class="bold">Person *life = nullptr;</strong>  // delegate all requests to
                             // the associated object
protected:
    void SetTitle(const string &amp;t) 
        { <strong class="bold">life-&gt;ModifyTitle(t);</strong> }
public:
    Humanoid() = default;
    Humanoid(const string &amp;, const string &amp;, 
             const string &amp;, const string &amp;);
    Humanoid(const Humanoid &amp;h);// we have work for copies!
    Humanoid &amp;operator=(const Humanoid &amp;); // and for op=
    virtual ~Humanoid()  // virtual destructor
        { delete life; life = nullptr; }  
    // Added interfaces for the Adapter class
    <strong class="bold">const string &amp;GetSecondaryName() const</strong> 
        { return <strong class="bold">life-&gt;GetFirstName();</strong> }
    <strong class="bold">const string &amp;GetPrimaryName() const</strong> 
        { return <strong class="bold">life-&gt;GetLastName();</strong> }    
    <strong class="bold">const string &amp;GetTitle() const</strong> 
        { return <strong class="bold">life-&gt;GetTitle();</strong>}
    <strong class="bold">void SetSalutation(const string &amp;m)</strong> 
        { <strong class="bold">life-&gt;SetGreeting(m);</strong> }
    <strong class="bold">virtual void GetInfo() const</strong> { <strong class="bold">life-&gt;Print();</strong> }
    <strong class="bold">virtual const string &amp;Converse() = 0;</strong> // abstract class
};
Humanoid::Humanoid(const string &amp;n2, const string &amp;n1, 
          const string &amp;planetNation, const string &amp;greeting)
{
    <strong class="bold">life = new Person(n2, n1, ' ', planetNation);</strong>
    <strong class="bold">life-&gt;SetGreeting(greeting);</strong>
}
// copy constructor (we need to write it ourselves)
Humanoid::Humanoid(const Humanoid &amp;h)  
{  // Remember life data member is of type Person
    delete life;  // delete former associated object
    <strong class="bold">life = new Person(h.GetSecondaryName(),</strong>
                     <strong class="bold">h.GetPrimaryName(),' ', h.GetTitle());</strong>
    <strong class="bold">life-&gt;SetGreeting(h.life-&gt;Speak());</strong>  
}
// overloaded operator= (we need to write it ourselves)
Humanoid &amp;Humanoid::operator=(const Humanoid &amp;h)
{
    if (this != &amp;h)
        <strong class="bold">life-&gt;Person::operator=(dynamic_cast</strong>
                                <strong class="bold">&lt;const Person &amp;&gt;(h));</strong>
    return *this;
}
<strong class="bold">const string &amp;Humanoid::Converse()</strong> //default definition for
{                              // pure virtual fn - unusual
    <strong class="bold">return life-&gt;Speak();</strong>
}</pre>
<p>Notice in the aforementioned implementation of our Adapter class, <code>Humanoid</code> is no longer derived from <code>Person</code>. Instead, <code>Humanoid</code> will add a private data member <code>Person *life;</code>, which will represent an association between the Adapter (<code>Humanoid</code>) and the Adaptee (<code>Person</code>). In our Humanoid constructors, we will need to allocate the underlying implementation of the Adaptee (<code>Person</code>). We will also need to delete the Adaptee (<code>Person</code>) in our destructor.</p>
<p>Similar to our <a id="_idIndexMarker1186"/>last implementation, <code>Humanoid</code> offers <a id="_idIndexMarker1187"/>the same member functions within its public interface. However, notice that each <code>Humanoid</code> method delegates, through the associated object, a call to the appropriate Adaptee methods. For example, <code>Humanoid::GetSecondaryName()</code> merely calls <code>life-&gt;GetFirstName();</code> to delegate the request (versus calling the inherited, corresponding Adaptee methods). </p>
<p>As in our initial implementation, our derived classes from <code>Humanoid</code> (<code>Orkan</code>, <code>Romulan</code>, and <code>Earthling</code>) are specified in the same fashion, as is our Client within our <code>main()</code> function. </p>
<h3>Choosing the relationship between Adaptee and Adapter</h3>
<p>An interesting point to consider when choosing between private inheritance or association as the <a id="_idIndexMarker1188"/>relationship between Adapter and Adaptee is <a id="_idIndexMarker1189"/>whether or not the Adaptee contains any protected members. Recall that the original code for <code>Person</code> included a protected <code>ModifyTitle()</code> method. Should protected members exist in the Adaptee class? The private base class implementation allows those inherited, protected members to continue to be accessed within the scope of the Adapter class (that is, by methods of the Adapter). However, using the association-based implementation, the protected methods in the Adaptee (<code>Person</code>) are unusable in the scope of the Adapter. To make this example work, we were required to move <code>Person::ModifyTitle()</code> to the public access region. However, modifying the Adaptee class is not always possible, nor is it necessarily recommended. Considering the protected member issue, our initial implementation using a private base class is the stronger implementation, as it does not depend on us modifying the class definition of the Adaptee (<code>Person</code>).</p>
<p>Let us now take a brief look at an alternate usage of the Adapter pattern. We will simply be using an Adapter class as a wrapper class. We will add an OO interface to an otherwise loosely arranged set of functions that work well, but lack the desired interface our application (Client) desires. </p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor820"/>Using an Adapter as a wrapper</h2>
<p>As an alternative <a id="_idIndexMarker1190"/>usage of the Adapter pattern, we will <a id="_idIndexMarker1191"/>wrap an OO interface around a grouping of related external functions. That is, we will create a wrapper class to encapsulate these functions.</p>
<p>In our example, the external functions will represent a suite of existing database access functions. We will assume that the core database functionality is well tested for our data type (<code>Person</code>) and has been used problem-free. However, these external functions by themselves present an undesirable and unexpected functional interface. </p>
<p>We will instead wrap the external functions by creating an Adapter class to encapsulate their collective functionality. Our Adapter class will be <code>CitizenDataBase</code>, representing an encapsulated means for reading and writing <code>Person</code> instances from and to a database. Our existing external functions will provide the implementation for our <code>CitizenDataBase</code> member functions. Let us assume that the OO interfaces, as defined in our Adapter class, meet the requirements of our OO design.</p>
<p>Let’s take a look at the mechanics of our simple wrapper Adapter pattern, beginning by examining <a id="_idIndexMarker1192"/>external functions providing the database <a id="_idIndexMarker1193"/>access functionality. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp</a></p>
<pre class="source-code">
// Assume Person class exists with its usual implementation
<strong class="bold">Person objectRead;</strong> // holds the object from current read
                   // to support a simulation of a DB read
<strong class="bold">void db_open(const string &amp;dbName)</strong>
{   // Assume implementation exists
    cout &lt;&lt; "Opening database: " &lt;&lt; dbName &lt;&lt; endl;
}
<strong class="bold">void db_close(const string &amp;dbName)</strong>
{   // Assume implementation exists
    cout &lt;&lt; "Closing database: " &lt;&lt; dbName &lt;&lt; endl;
}
<strong class="bold">Person &amp;db_read(const string &amp;dbName, const string &amp;key)</strong>
{   // Assume implementation exists
    cout &lt;&lt; "Reading from: " &lt;&lt; dbName &lt;&lt; " using key: ";
    cout &lt;&lt; key &lt;&lt; endl;
    // In a true implementation, we would read the data
    // using the key and return the object we read in
    return objectRead; // non-stack instance for simulation
}
<strong class="bold">const string &amp;db_write(const string &amp;dbName, Person &amp;data)</strong>
{   // Assume implementation exists
    const string &amp;key = data.GetLastName();
    cout &lt;&lt; "Writing: " &lt;&lt; key &lt;&lt; " to: " &lt;&lt; 
             dbName &lt;&lt; endl;
    return key;
}</pre>
<p>In our previously defined external functions, let’s assume all functions are well tested and allow <code>Person</code> instances to be read from or written to a database. To support this simulation, we <a id="_idIndexMarker1194"/>have created an external <code>Person</code> instance <a id="_idIndexMarker1195"/>with <code>Person objectRead;</code> to provide a brief, non-stack located storage place for a newly read instance (used by <code>db_read()</code>) until the newly read instance is captured as a return value. Keep in mind that the existing external functions do not represent an encapsulated solution.</p>
<p>Now, let’s create a simple wrapper class to encapsulate these external functions. The wrapper class, <code>CitizensDataBase</code>, will represent our Adapter class:</p>
<pre class="source-code">
// CitizenDataBase is the Adapter class 
<strong class="bold">class CitizenDataBase</strong>  // Adapter wraps undesired interface
{
private:
    string name;
public:
    // No default constructor (unusual)
    <strong class="bold">CitizenDataBase(const string &amp;);</strong>
    <strong class="bold">CitizenDataBase(const CitizenDataBase &amp;) = delete;</strong>
    <strong class="bold">CitizenDataBase &amp;operator=(const CitizenDataBase &amp;)</strong> 
                               <strong class="bold">= delete;</strong>  // disallow =
    <strong class="bold">virtual ~CitizenDataBase();</strong>  // virtual destructor
    <strong class="bold">inline Person &amp;Read(const string &amp;);</strong>
    <strong class="bold">inline const string &amp;Write(Person &amp;);</strong>
};
CitizenDataBase::CitizenDataBase(const string &amp;n): name(n)
{
    <strong class="bold">db_open(name);</strong>   // call existing external function
}
CitizenDataBase::~CitizenDataBase()
{
    <strong class="bold">db_close(name);</strong>  // close database with external
}                    // function
Person &amp;CitizenDataBase::Read(const string &amp;key)
{
    <strong class="bold">return db_read(name, key);</strong>   // call external function
}
const string &amp;CitizenDataBase::Write(Person &amp;data)
{
    <strong class="bold">return db_write(name, data);</strong>  // call external function
}</pre>
<p>In our aforementioned class definition for our Adapter class, we simply encapsulate the external database functionality within the <code>CitizenDataBase</code> class. Here, <code>CitizenDataBase</code> is not only our Adapter class but also our Target class, as it contains the interfaces our application at hand (Client) expects. Notice that the <code>CitizenDataBase</code> methods of <code>Read()</code> and <code>Write()</code> have both been inlined in the class <a id="_idIndexMarker1196"/>definition; their methods merely call the <a id="_idIndexMarker1197"/>external functions. This is an example of how a wrapper class with inline functions can be a low-cost Adapter class, adding a very minimal amount of overhead (constructors, destru<a id="_idTextAnchor822"/>ctor, and potentially other non-inline methods).</p>
<p>Now, let’s take a look at our <code>main()</code> function, which is a streamlined version of a Client:</p>
<pre class="source-code">
int main()
{
    string key;
    string name("PersonData"); // name of database
    Person p1("Curt", "Jeffreys", 'M', "Mr.");
    Person p2("Frank", "Burns", 'W', "Mr.");
    Person p3;
    <strong class="bold">CitizenDataBase People(name);</strong>   // open Database
    key = <strong class="bold">People.Write(p1);</strong> // write a Person object
    p3 = <strong class="bold">People.Read(key);</strong>  // using a key, retrieve Person
    return 0;
}                        // destruction will close database</pre>
<p>In the aforementioned <code>main()</code> function, we first instantiate three <code>Person</code> instances. We then instantiate a <code>CitizenDataBase</code> to provide encapsulated access to write or read our <code>Person</code> instances, to or from the database. The methods for our <code>CitizenDataBase</code> constructors call the external function <code>db_open()</code> to open the database. Likewise, the destructor calls <code>db_close()</code>. As expected, our <code>CitizenDataBase</code> methods for <code>Read()</code> and <code>Write()</code> will each, respectively, call the external functions, <code>db_read()</code> or <code>db_write()</code>. </p>
<p>Let’s take a look at the output for this program:</p>
<pre>Opening database: PersonData
Writing: Jeffreys to: PersonData
Reading from: PersonData using key: Jeffreys
Closing database: PersonData</pre>
<p>In the aforementioned output, we can notice the correlation between the various member <a id="_idIndexMarker1198"/>functions to the wrapped, external functions <a id="_idIndexMarker1199"/>via construction, a call to write and read, and then the destruction of the database.</p>
<p>Our simple <code>CitizenDataBase</code> wrapper is a very straightforward, but reasonable, use of the Adapter pattern. Interestingly, our <code>CitizenDataBase</code> also has commonalities with the <strong class="bold">Data Access Object pattern</strong>, as this wrapper provides a clean interface to a data storage <a id="_idIndexMarker1200"/>mechanism, concealing the implementation (access) to the underlying database.</p>
<p>We have now seen three implementations of the Adapter pattern. We have folded the concepts of Adapter, Adaptee, Target, and Client into the frame<a id="_idTextAnchor823"/>work of classes we are accustomed to seeing, namely <code>Person</code>, as well as into descendants of our Adapter (<code>Orkan</code>, <code>Romulan</code>, and <code>Earthling</code>, as in our first two examples). Let us now briefly recap what we have learned relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor824"/>Summary</h1>
<p>In this chapter, we have advanced our pursuit to become better C++ programmers through widening our knowledge of design patterns. We have explored the Adapter pattern in both the concept and through multiple implementations. Our first implementation used private inheritance two derive the Adapter from the Adaptee class. We specified our Adapter as an abstract class and then used public inheritance to introduce several Target classes based on the interface provided by our Adapter class. Our second implementation instead modeled the relationship between the Adapter and Adaptee using association. We then looked at an example usage of an Adapter as a wrapper to simply add an OO interface to existing function-based application components.</p>
<p>Utilizing common design patterns, such as the Adapter pattern, will help you more easily reuse existing, well-tested portions of code in a manner understood by other programmers. By utilizing core design patterns, you will be contributing to well-understood and reusable solutions with more sophisticated programming techniques.</p>
<p>We are now ready to continue forward with our next design pattern, in <a href="B19087_19.xhtml#_idTextAnchor829"><em class="italic">Chapter 19</em></a>, <em class="italic">Using the Singleton Pattern</em>. Adding more patterns to our arsenal of programming skills makes us more versatile and v<a id="_idTextAnchor825"/>alued programmers. Let’s continue forward!</p>
<h1 id="_idParaDest-290"><a id="_idTextAnchor826"/>Questions</h1>
<ol>
<li>Using the Adapter examples <a id="_idTextAnchor827"/>found in this chapter, create a program as follows:<ol><li>Implement a <code>CitizenDataBase</code> that stores various types of <code>Humanoid</code> instances (<code>Orkan</code>, <code>Romulan</code>, <code>Earthling</code>, and perhaps <code>Martian</code>). Decide whether you will use the private base class Adapter-Adaptee relationship or the association relationship between the Adapter and Adaptee (hin<a id="_idTextAnchor828"/>t: the private inheritance version will be easier).</li><li>Noting that the <code>CitizenDataBase</code> handles <code>Person</code> instances, can this class be used <em class="italic">as-is</em> to store various types of <code>Humanoid</code> instances, or must it be adapted in some way? Recall that <code>Person</code> is a base class of <code>Humanoid</code> (if you chose this implementation), but also remember that we can never upcast past a non-public inheritance boundary.</li></ol></li>
<li>What other examples can you imagine that might easily incorporate the Adapter pattern?</li>
</ol>
</div>
</div></body></html>