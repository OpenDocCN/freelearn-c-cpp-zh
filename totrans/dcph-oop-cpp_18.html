<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer071">
<h1 class="chapter-number" id="_idParaDest-282"><a id="_idTextAnchor783"/>18</h1>
<h1 id="_idParaDest-283"><a id="_idTextAnchor784"/>Applying the Adapter Pattern</h1>
<p><a id="_idTextAnchor785"/>This chapter will extend our quest to expand your C++ programming skills beyond core OOP concepts, with the goal of enabling you to solve recurring types of coding problems utilizing common design patterns. Incorporating design patterns in coding solutions can not only provide elegant solutions but also enhance code maintenance and provide potential opportunities for code reuse.</p>
<p>The next core design pattern that we will learn how to implement effectively in C++ is the <strong class="bold">Adapter pattern</strong>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the Adapter pattern and how it contributes to OOP</li>
<li>Understanding how to implement the Adapter pattern in C++ </li>
</ul>
<p>By the end of this chapter, you will understand the essential Adapter pattern and how it can be used to either allow two incompatible classes to communicate or to upgrade unseemly code to well-designed OO code. Adding another key design pattern to your knowledge set will refine your programming skills to help make you a more valuable programmer. </p>
<p>Let’s increase our programming skillset by examining another common design pattern, the Adapter pattern.</p>
<h1 id="_idParaDest-284"><a id="_idTextAnchor786"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter18</strong> in a file named <strong class="source-inline">Chp18-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3Kaxckc">https://bit.ly/3Kaxckc</a>.</p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor787"/><a id="_idTextAnchor788"/><a id="_idTextAnchor789"/>Understanding the Adapter pattern</h1>
<p>The <strong class="bold">Adapter pattern</strong> is a structural design pattern that provides a means for converting an existing, undesirable <a id="_idIndexMarker1149"/>interface of a class to an interface that another class expects. An <strong class="bold">Adapter class</strong> will be the link for communication between <a id="_idIndexMarker1150"/>two existing components, adapting the interfaces so that the two may share and exchange information. An Adapter allows two or more classes to work together that otherwise could not do so. </p>
<p>Ideally, an Adapter will not add functionality but will add the preferred interface for usage (or conversion) to either allow one class to be used in an expected manner or for two otherwise incompatible classes to communicate with one another. In its most simple form, an Adapter simply converts an existing class to support an expected interface as may be specified in an OO design.</p>
<p>An Adapter can be either associated with or derived from the class for which it is providing an adaptive interface. If inheritance is used, a private or protected base class is appropriate to hide the underlying implementation. If instead, the Adapter class is associated with the class having the undesirable interface, the methods in the Adapter class (with the new interfaces) will merely delegate the work to its associated class.</p>
<p>The Adapter pattern can also be used to add an OO interface to (that is, to <em class="italic">wrap an OO interface around</em>) a series of functions or other classes, allowing assorted existing components to be utilized <a id="_idIndexMarker1151"/>more naturally in an OO system. This specific type of Adapter is known as a <strong class="bold">wrapper class</strong>. The originating functions or utilities may even be written in another language, such as C (which would then require special language tags, such as <strong class="source-inline">extern C</strong>, to allow the linker to resolve linkage conventions between the two languages).</p>
<p>Utilizing the Adapter pattern has benefits. The Adapter allows the reuse of existing code by providing a shared <a id="_idIndexMarker1152"/>interface to allow otherwise unrelated classes to communicate. The OO programmer will now use the Adapter class directly, allowing for easier maintenance of the application. That is, most programmer interaction will be with a well-designed Adapter class, rather than with two or more odd components. A small drawback of using an Adapter is a slightly decreased performance from the added layer of code. However, most often, reusing existing components through providing a clean interface to support their interaction is a winning proposition, despite a (hopefully small) performance trade-o<a id="_idTextAnchor790"/>ff.</p>
<p>The Adapter pattern will include the following:</p>
<ul>
<li>An <strong class="bold">Adaptee</strong> class, which represents the class with desirable utilities, yet which exists in a form that <a id="_idIndexMarker1153"/>is not suitable or as expected.</li>
<li>An <strong class="bold">Adapter</strong> class, which <a id="_idIndexMarker1154"/>adapts the interface of the Adaptee class to meet the needs of the desired interface.</li>
<li>A <strong class="bold">Target</strong> class, which <a id="_idIndexMarker1155"/>represents the specific, desired interface of the application at hand. A class may be both a Target and an Adapter.</li>
<li>Optional <strong class="bold">Client</strong> classes, which will <a id="_idIndexMarker1156"/>interact with the Target class to fully define the application at hand.</li>
</ul>
<p>An Adapter pattern allows the <a id="_idIndexMarker1157"/>reuse of qualified, existing components that do not meet the interface needs of current application designs.</p>
<p>Let’s move forward to see two common applications of the Adapter pattern; one will have two potential means for implementation.</p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor791"/>Implementing the Adapter pattern</h1>
<p>Let’s explore two <a id="_idIndexMarker1158"/>common uses of the Adapter pattern. That is, creating an Adapter to bridge the gap between two incompatible class interfaces or building an Adapter to simply wrap an existing set of functions with an OO in<a id="_idTextAnchor792"/>terface. </p>
<p>We will start with the usage of an <em class="italic">Adapter</em> providing a connector between two (or more) incompatible classes. The <em class="italic">Adaptee</em> will be a well-tested class that we would like to reuse (but which has an undesirable interface), and the <em class="italic">Target</em> classes will be those specified in our OO design for an application in the making. Let’s now specify an Adapter to allow our Adaptee to work with our Target<a id="_idTextAnchor793"/> classes.</p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor794"/>Using an Adapter to provide a necessary interface to an existing class</h2>
<p>To implement the Adapter pattern, we will first need to identify our Adaptee class. We will then <a id="_idIndexMarker1159"/>create an Adapter class to modify the interface of the Adaptee. We will also identify our Target class, representing the class we need to model per our OO design. At times, our Adapter and Target may be rolled into a single class. In an actual application, we will additionally have Client classes, representing the full complement of classes found in the final application at hand. Let’s start with the Adaptee and Adapter classes, as these class definitions will begin the foundation on which to build our pattern.</p>
<p>In our example, we will specify our Adaptee class as one we are accustomed to seeing – <strong class="source-inline">Person</strong>. We will imagine that our planet has recently become aware of many other exoplanets capable of supporting life and that we have benevolently made allies with each such civilization. Further imagining that the various software systems on Earth would like to welcome and include our new friends, including <strong class="source-inline">Romulans</strong> and <strong class="source-inline">Orkans</strong>, we would like to adapt some of our existing software to easily accommodate the new demographics of our exoplanet neighbors. With that in mind, we will transform our <strong class="source-inline">Person</strong> class to include more interplanetary terminology by creating an Adapter class, <strong class="source-inline">Humanoid</strong>. </p>
<p>In our forthcoming implementation, we will use private inheritance to inherit <strong class="source-inline">Humanoid</strong> (Adapter) from <strong class="source-inline">Person</strong> (Adaptee), therefore hiding the underlying implementation of the Adaptee. We could have alternatively associated a <strong class="source-inline">Humanoid</strong> with a <strong class="source-inline">Person</strong> (an implementation we will also review in this section). We can then flesh out some derived classes of <strong class="source-inline">Humanoid</strong> within our hierarchy, such as <strong class="source-inline">Orkan</strong>, <strong class="source-inline">Romulan</strong>, and <strong class="source-inline">Earthling</strong>, to accommodate the intergalactic application at hand. The <strong class="source-inline">Orkan</strong>, <strong class="source-inline">Romulan</strong>, and <strong class="source-inline">Earthling</strong> classes can be considered our Target classes, or those that our application will instantiate. We will choose to make our Adapter class, <strong class="source-inline">Humanoid</strong>, abstract so that it is not directly instantiable. Because our specific derived classes (Target classes) can be generalized by their abstract base class type (<strong class="source-inline">Humanoid</strong>) in our application (Client), we can also consider <strong class="source-inline">Humanoid</strong> a Target class. That is, <strong class="source-inline">Humanoid</strong> can be viewed primarily as an Adapter, but secondarily as a generalized Target class. </p>
<p>Our various Client classes can utilize derived classes of <strong class="source-inline">Humanoid</strong>, making instances of each of its concrete descendants. These instances may be stored in their own specialized type <a id="_idIndexMarker1160"/>or genericized using <strong class="source-inline">Humanoid</strong> pointers. Our implementation is a modern take on the well-used Adapter desi<a id="_idTextAnchor795"/>gn pattern. </p>
<h3>Specifying the Adaptee and Adapter (private inheritance<a id="_idTextAnchor796"/> technique)</h3>
<p>Let’s take a look <a id="_idIndexMarker1161"/>at the mechanics of the first usage of our Adapter pattern, beginning <a id="_idIndexMarker1162"/>by reviewing the definition for our Adaptee class, <strong class="source-inline">Person</strong>. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp</a></p>
<pre class="source-code">
// Person is the Adaptee class (class requiring adaptation)
class Person
{
private:
    string firstName, lastName, title, greeting;
    char middleInitial  = '\0';  // in-class initialization
protected:
    void ModifyTitle(const string &amp;);  
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);
    // default copy constructor prototype is not necessary
    // Person(const Person &amp;) = default;  // copy ctor
    // Default op= suffices, so we'll comment out proto.
    // (see online code for review of implementation)
    // Person &amp;operator=(const Person &amp;); // assignment op.
    virtual ~Person()= default;  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const 
        { return lastName; }    
    const string &amp;GetTitle() const { return title; }
    char GetMiddleInitial() const { return middleInitial; }
    void SetGreeting(const string &amp;);
    virtual const string &amp;Speak() { return greeting; }
    virtual void Print() const;
};
// Assume constructors, destructor, and non-inline methods
// are implemented as expected (see online code)</pre>
<p>In the previous class definition, we notice that our <strong class="source-inline">Person</strong> class definition is as we have been <a id="_idIndexMarker1163"/>accustomed to seeing it in many other examples <a id="_idIndexMarker1164"/>throughout this book. This class is instantiable; however, <strong class="source-inline">Person</strong> is not an appropriate class to instantiate in our intergalactic application. Instead, the expected interface would be to utilize that foun<a id="_idTextAnchor797"/><a id="_idTextAnchor798"/>d in <strong class="source-inline">Humanoid</strong>. </p>
<p>With that in mind, let’s take a look at our Adapter <a id="_idTextAnchor799"/>c<a id="_idTextAnchor800"/>lass, <strong class="source-inline">Humanoid</strong>:</p>
<pre class="source-code">
<strong class="bold">class Humanoid</strong>: private Person   // Humanoid is abstract
{                           
protected:
    void SetTitle(const string &amp;t) { ModifyTitle(t); }
public:
    Humanoid() = default;   
    Humanoid(const string &amp;, const string &amp;, 
             const string &amp;, c<a id="_idTextAnchor801"/>onst string &amp;);
    // default copy constructor prototype not required
    // Humanoid(const Humanoid <a id="_idTextAnchor802"/>&amp;h) = default; 
    // default op= suffices, so commented out below, but
    // let's review how we'd write op= if needed
    // note explicit Humanoid downcast after calling base  
    // class Person::op= to match return type needed here
    // Humanoid &amp;operator=(const Humanoid &amp;h) 
    //     { return dynamic_cast&lt;Humanoid &amp;&gt; 
    //              (Person::o<a id="_idTextAnchor803"/>perator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Humanoid() override = default; // virt destructor
    // Added interfaces for the Adapter class 
    <strong class="bold">const string &amp;GetSecondaryName() const</strong> 
        { return GetFirstName(); }  
    <strong class="bold">const string &amp;GetPrimaryName() const</strong> 
        { return GetLastName(); } 
    // scope resolution needed in method to avoid recursion 
    <strong class="bold">const string &amp;GetTitle() const</strong> 
        { return Person::GetTitle();}
    <strong class="bold">void SetSalutation(const string &amp;m)</strong> { SetGreeting(m); }
    <strong class="bold">virtual void GetInfo() con<a id="_idTextAnchor804"/>st</strong> { Print(); }
    <strong class="bold">virtual const string &amp;Converse() = 0;</strong> // abstract class
};
Humanoid::Humanoid(const string &amp;n2, const string &amp;n1, 
    const string &amp;planetNation, const string &amp;greeting):
    Person(n2, n1, ' ', planetNation)
{
    SetGreeting(greeting);
}
<strong class="bold">const string &amp;Humanoid::Converse()</strong>  // default definition 
{                    // for pure virtual function - unusual
    return Speak();
}</pre>
<p>In the aforementioned <strong class="source-inline">Humanoid</strong> class, our goal is to provide an Adapter to contribute to the expected interface that our intergalactic application requires. We simply derive <strong class="source-inline">Humanoid</strong> from <strong class="source-inline">Person</strong> using private inheritance, hiding the public interfaces found in <strong class="source-inline">Person</strong> from use outside the scope of <strong class="source-inline">Humanoid</strong>. We understand that the target application (Client) would not wish for the public interfaces found in <strong class="source-inline">Person</strong> to be utilized by various subtypes of <strong class="source-inline">Humanoid</strong> instances. Notice that we are not adding functionality, only adapting the interface.</p>
<p>We then notice the <a id="_idIndexMarker1165"/>public methods introduced in <strong class="source-inline">Humanoid</strong> that provide <a id="_idIndexMarker1166"/>the desired interfaces for the Target class(es). The implementation of these interfaces is often straightforward. We simply call the inherited method defined in <strong class="source-inline">Person</strong>, which will easily complete the task at hand (but which uses an unacceptable interface to do so). For example, our <strong class="source-inline">Humanoid::GetPrimaryName()</strong> method simply calls <strong class="source-inline">Person::GetLastName();</strong> to complete the task. However, <strong class="source-inline">GetPrimaryName()</strong> may more so represent appropriate intergalactic lingo than <strong class="source-inline">Person::GetLastName()</strong>. We can see how <strong class="source-inline">Humanoid</strong> is serving as an Adapter for <strong class="source-inline">Person</strong>. We can also see how most of the member functions of the Adapter class, <strong class="source-inline">Humanoid</strong>, use inline functions to simply wrap the <strong class="source-inline">Person</strong> methods with more suitable interfaces while adding no overhead.</p>
<p>Note that it is not necessary to precede the calls to <strong class="source-inline">Person</strong> base class methods within Humanoid methods with <strong class="source-inline">Person::</strong> (except when a <strong class="source-inline">Humanoid</strong> method calls the same named method in <strong class="source-inline">Person</strong>, such as with <strong class="source-inline">GetTitle()</strong>). The scope resolution usage of <strong class="source-inline">Person::</strong> avoids potential recursion in these situations.</p>
<p>We also notice that <strong class="source-inline">Humanoid</strong> introduces an abstract polymorphic method (that is, a pure virtual function) with <a id="_idIndexMarker1167"/>the specification of <strong class="source-inline">virtual const string &amp;Converse() = 0;</strong>. We <a id="_idIndexMarker1168"/>have made the design decision that only derived classes of <strong class="source-inline">Humanoid</strong> will be instantiable. Nonetheless, we understand that public descendant classes may still be collected by their base class type of <strong class="source-inline">Humanoid</strong>. Here, <strong class="source-inline">Humanoid</strong> serves primarily as the Adapter class and secondarily as a Target class offering the suite of acceptable interfaces.</p>
<p>Notice that our pure virtual function <strong class="source-inline">virtual const String &amp;Converse() = 0;</strong> includes a default implementation. This is rare but allowed, so long as the implementation is not written inline. Here, we utilize the opportunity to specify a default behavior for <strong class="source-inline">Humanoid::Converse()</strong>, by simply calling <strong class="source-inline">Person::Speak()</strong>.</p>
<h3>Deriving concrete class<a id="_idTextAnchor805"/>es from the Adapter</h3>
<p>Next, let’s extend <a id="_idIndexMarker1169"/>our Adapter (<strong class="source-inline">Humanoid</strong>) and <a id="_idIndexMarker1170"/>take a look at one of our concrete, derived Target classes, <strong class="source-inline">Orkan</strong>:</p>
<pre class="source-code">
<strong class="bold">class Orkan</strong>: public Humanoid
{
public:
    Orkan() = default;   // default constructor
    Orkan(const string &amp;n2, const string &amp;n1, 
        const string &amp;t)<a id="_idTextAnchor806"/>: Humanoid(n2, n1, t, <strong class="bold">"Na<a id="_idTextAnchor807"/>nu nanu"</strong>)
        { }
    // default copy constructor prototype not required
    // Orkan(const Orkan &amp;h) = default;  
    // default op= suffices, so commented out below, but
    // let's review how we'd write it if needed
    // note explicit Orkan downcast after calling base  
    // class Humanoid::op= to match return type needed here
    // Orkan &amp;operator=(const Orkan &amp;h) 
    //    { return dynamic_cast&lt;Orkan &amp;&gt;
    //             (Human<a id="_idTextAnchor808"/>oid::operator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Orkan() override = default; // virtual destructor
    <strong class="bold">const string &amp;Converse() override;</strong>  
};
// Must override Converse to make Orkan a concrete class
<strong class="bold">const string &amp;Orkan::Converse()</strong>  
{                                
    return Humanoid::Converse(); // use scope resolution to
}                                // avoid recursion</pre>
<p>In our aforementioned <strong class="source-inline">Orkan</strong> class, we use public inheritance to derive <strong class="source-inline">Orkan</strong> from <strong class="source-inline">Humanoid</strong>. An <strong class="source-inline">Orkan</strong> <em class="italic">Is-A</em> <strong class="source-inline">Humanoid</strong>. As such, all of the public interfaces in <strong class="source-inline">Humanoid</strong> are <a id="_idIndexMarker1171"/>available to <strong class="source-inline">Orkan</strong> instances. Notice that our alternate constructor sets the default greeting message to <strong class="source-inline">"Nanu nanu"</strong>, per the <strong class="source-inline">Orkan</strong> dialect.</p>
<p>Because we <a id="_idIndexMarker1172"/>wish <strong class="source-inline">Orkan</strong> to be a concrete, instantiable <a id="_idIndexMarker1173"/>class, we must override <strong class="source-inline">Humanoid::Converse()</strong> and provide an implementation in the <strong class="source-inline">Orkan</strong> class. Notice, however, that <strong class="source-inline">Orkan::Converse()</strong> simply calls <strong class="source-inline">Humanoid::Converse();</strong>. Perhaps <strong class="source-inline">Orkan</strong> finds the default implementation in its base class acceptable. Notice that we use the <strong class="source-inline">Humanoid::</strong> scope resolution to qualify <strong class="source-inline">Converse()</strong> within the <strong class="source-inline">Orkan::Converse()</strong> method to avoid recursion. </p>
<p>Interestingly, had <strong class="source-inline">Humanoid</strong> not been an abstract class, <strong class="source-inline">Orkan</strong> would not have had to override <strong class="source-inline">Converse()</strong> – the default behavior would have automatically been inherited. Yet, with <strong class="source-inline">Humanoid</strong> defined as abstract, the override of <strong class="source-inline">Converse()</strong> is necessary <a id="_idIndexMarker1174"/>within <strong class="source-inline">Orkan</strong>, otherwise, <strong class="source-inline">Orkan</strong> will also <a id="_idIndexMarker1175"/>be also viewed as an abstract class. No worries! We can utilize the benefit of the default behavior of <strong class="source-inline">Humanoid::Converse()</strong> merely by calling it within <strong class="source-inline">Orkan::Converse()</strong>. This will satisfy the requirements for making <strong class="source-inline">Orkan</strong> concrete, while allowing <strong class="source-inline">Humanoid</strong> to remain abstract, while still providing the rare default behavior for <strong class="source-inline">Converse()</strong>!</p>
<p>Now, let’s take a look at our next concrete Target class, <strong class="source-inline">Romulan</strong>:</p>
<pre class="source-code">
<strong class="bold">class Romulan</strong>: public Humanoid
{
public:
    Romulan() = default;   // default constructor
    Romulan(const string &amp;n2, const string &amp;n1, 
        const strin<a id="_idTextAnchor809"/>g &amp;t): Humanoid(n2, n1, t<a id="_idTextAnchor810"/>, <strong class="bold">"jolan'tru"</strong>)
        { }
    // default copy constructor prototype not required
    // Romulan(const Romulan &amp;h) = default;
    // default op= suffices, so commented out below, but
    // let's review how we'd write it if so needed
    // note explicit Romulan downcast after calling base  
    // class Humanoid::op= to match return type needed here
    // Romulan &amp;operator=(const Romulan &amp;h) 
    //    { return dynamic_cast&lt;Romulan &amp;&gt;
    //             (<a id="_idTextAnchor811"/>Humanoid::operator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Romulan() override = default;  // virt destructor
    <strong class="bold">const string &amp;Converse() override;</strong>  
};
// Must override Converse to make Romulan a concrete class
<strong class="bold">const string &amp;Romulan::Converse()</strong>  
{                               
    return Humanoid::Converse(); // use scope resolution to
}                                // avoid recursion        </pre>
<p>Taking a comparably quick look at the aforementioned <strong class="source-inline">Romulan</strong> class, we notice that this concrete Target is similar to its sibling class, <strong class="source-inline">Orkan</strong>. We notice that the default message for the <a id="_idIndexMarker1176"/>greeting passed up to our base class <a id="_idIndexMarker1177"/>constructor is <strong class="source-inline">"jolan'tru"</strong> to reflect <strong class="source-inline">Romulan</strong> dialect. Though we could have made our implementation of <strong class="source-inline">Romulan::Converse()</strong> more intricate, we chose not to do so. We can quickly understand the full scope of this class.</p>
<p>Next, let’s take a look at our third Target class, <strong class="source-inline">Earthling</strong>:</p>
<pre class="source-code">
<strong class="bold">class Earthling</strong>: public Humanoid
{
public:
    Earthling() = default;   // default constructor
    Earthling(const string &amp;n2, const string &amp;n1, 
        const string &amp;t): Humanoid(n2, n1, t, <strong class="bold">"Hello"</strong>) { }
    // default copy constructor prototype not required
    // Earthling(const Romulan &amp;h) = default;  
    // default op= suffices, so commented out below, but
    // let's review how we'd write it if so needed
    // note explicit Earthling downcast after calling base
    // class Humanoid::op= to match return type needed here
    // Earthling &amp;operator=(const Earthling &amp;h) 
    //    { return dynamic_cast&lt;Earthling &amp;&gt;
    //             (Humanoid::operator=(h)); }
    // dtor proto. not required since base dtor is virt.
    // ~Earthling() override = default; // virt destructor
    <strong class="bold">const string &amp;Converse() override;</strong>  
};
// Must override to make Earthling a concrete class
<strong class="bold">const string &amp;Earthling::Converse()</strong> 
{                                                          
    return Humanoid::Converse(); // use scope resolution to
}                                // avoid recursion</pre>
<p>Again, taking <a id="_idIndexMarker1178"/>another comparably quick look at <a id="_idIndexMarker1179"/>the aforementioned <strong class="source-inline">Earthling</strong> class, we notice that this concrete Target is similar to its sibling classes, <strong class="source-inline">Orkan</strong> and <strong class="source-inline">Romulan</strong>. </p>
<p>Now that we have defined our Adaptee, Adapter, and multiple Target classes, let’s bring the pieces together by examining the Client portion of our program.</p>
<h3>Bringing the pattern components together</h3>
<p>Finally, let us <a id="_idIndexMarker1180"/>consider what a sample Client may look like in our overall application. Certainly, it may consist of many files with a variety of classes. In its simplest form, as shown next, our Client will contain a <strong class="source-inline">main()</strong> function to drive the application.</p>
<p>Let’s <a id="_idIndexMarker1181"/>now take a look at our <strong class="source-inline">main()</strong> function to see how our pattern is orchestrated:</p>
<pre class="source-code">
int main()
{
    <strong class="bold">list&lt;Humanoid *&gt; allies;</strong>
    <strong class="bold">Orkan *o1 = new Orkan("Mork", "McConnell", "Orkan");</strong>
    <strong class="bold">Romulan *r1 = new Romulan("Donatra", "Jarok", </strong>
<strong class="bold">                              "Romulan");</strong>
    <strong class="bold">Earthling *e1 = new Earthling("Eve", "Xu",</strong>
<strong class="bold">                                  "Earthling");</strong>
    // Add each specific type of Humanoid to generic list
    allies.push_back(<strong class="bold">o1</strong>);
    allies.push_back(<strong class="bold">r1</strong>);
    allies.push_back(<strong class="bold">e1</strong>);
    
    // Process the list of allies (which are Humanoid *'s 
    // Actually, each is a specialization of Humanoid!)
    for (auto *entity : allies)
    {
        entity-&gt;GetInfo();
        cout &lt;&lt; entity-&gt;Converse() &lt;&lt; endl;
    }
    // Though each type of Humanoid has a default
    // Salutation, each may expand their skills with 
    // an alternat<a id="_idTextAnchor812"/>e language
    <strong class="bold">e1-&gt;SetSalutation("Bonjour");</strong>
    <strong class="bold">e1-&gt;GetInfo();</strong>
    cout &lt;&lt; <strong class="bold">e1-&gt;Converse()</strong> &lt;&lt; endl; // Show the Earthling's 
                           // revised language capabilities
    delete o1;   // delete the heap instances
    delete r1;
    delete e1;
    return 0;
}</pre>
<p>Reviewing our aforementioned <strong class="source-inline">main()</strong> function, we first create an STL <strong class="source-inline">list</strong> of <strong class="source-inline">Humanoid</strong> pointers with <strong class="source-inline">list&lt;Humanoid *&gt; allies;</strong>. We then instantiate an <strong class="source-inline">Orkan</strong>, <strong class="source-inline">Romulan</strong>, and an <strong class="source-inline">Earthling</strong> and add each to the list using <strong class="source-inline">allies.push_back()</strong>. Again, using the Standard Template Library, we next create a list iterator to <a id="_idIndexMarker1182"/>walk through the list of pointers to <strong class="source-inline">Humanoid</strong> instances. As we iterate through our generalized list of allies, we call the approved interfaces of <strong class="source-inline">GetInfo()</strong> and <strong class="source-inline">Converse()</strong> on each item in our list (that is, for each specific type of <strong class="source-inline">Humanoid</strong>). </p>
<p>Next, we specify one specific <strong class="source-inline">Humanoid</strong>, an <strong class="source-inline">Earthling</strong>, and change this instance’s default greeting by i<a id="_idTextAnchor813"/>nvoking <strong class="source-inline">e1-&gt;SetSalutation("Bonjour");</strong>. By calling <strong class="source-inline">Converse()</strong> again on this instance (we first did so on this object generically in the aforementioned loop), we can request that the <strong class="source-inline">Earthling</strong> use <strong class="source-inline">"Bonjour"</strong> to greet allies instead of <strong class="source-inline">"Hello"</strong> (the<a id="_idTextAnchor814"/><a id="_idTextAnchor815"/><a id="_idTextAnchor816"/> default greeting for <strong class="source-inline">Earthling</strong>).</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">Orkan Mork McConnell</p>
<p class="source-code">Nanu nanu</p>
<p class="source-code">Romulan Donatra Jarok</p>
<p class="source-code">jolan'tru</p>
<p class="source-code">Earthling Eve Xu</p>
<p class="source-code">Hello</p>
<p class="source-code">Earthling Eve Xu</p>
<p class="source-code">Bonjour</p>
<p>In the aforementioned output, notice that the planetary specification for each <strong class="source-inline">Humanoid</strong> is displayed (<strong class="source-inline">Orkan</strong>, <strong class="source-inline">Romulan</strong>, and <strong class="source-inline">Earthling</strong>), followed by their secondary and primary names. Then, the appropriate greeting is displayed for the particular <strong class="source-inline">Humanoid</strong>. Notice that <strong class="source-inline">Earthling</strong> <strong class="source-inline">Eve Xu</strong> first converses using <strong class="source-inline">"Hello"</strong> and then later converses using <strong class="source-inline">"Bonjour"</strong>.</p>
<p>An advantage of the preceding implementation (using a private base class to derive Adapter from Adaptee) is that the coding is very straightforward. With this approach, any protected <a id="_idIndexMarker1183"/>methods in the Adaptee class can easily be carried down to be used within the scope of the Adapter methods. We will soon see that protected members will be an issue should we instead use the association as a means of connecting the Adapter to Adaptee. </p>
<p>A disadvantage of the prior mentioned approach is that it is a C++ specific implementation. Other languages do not support private base classes. Alternatively, using a public base class to define the relationship between Adapter and Adaptee would fail to conceal the unwanted Adaptee interface, and <a id="_idTextAnchor817"/><a id="_idTextAnchor818"/>would be a very poor design choice.</p>
<h3>Considering an alternate specification of<a id="_idTextAnchor819"/> Adaptee and Adapter (association)</h3>
<p>Let us now briefly <a id="_idIndexMarker1184"/>consider a slightly revised <a id="_idIndexMarker1185"/>version of the aforementioned Adapter pattern implementation. We will instead use an association to model the relationship between the Adaptee and Adapter. The concrete derived classes (Targets) will still be derived from the Adapter as before. </p>
<p>Here is an alternative implementation of our Adapter class, <strong class="source-inline">Humanoid</strong>, using an association between Adapter and Adaptee. Though we will only review the portion of the code that differs from our initial approach, the full implementation can be found as a complete program in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp</a></p>
<pre class="source-code">
// Assume that Person exists mostly as before – however,
// Person::ModifyTitle() must be moved from protected to
// public or be unused if modifying Person is not possible.
// Let's assume we moved Person::ModifyTitle() to public.
<strong class="bold">class Humanoid</strong>    // Humanoid is abstract
{
private:
    <strong class="bold">Person *life = nullptr;</strong>  // delegate all requests to
                             // the associated object
protected:
    void SetTitle(const string &amp;t) 
        { <strong class="bold">life-&gt;ModifyTitle(t);</strong> }
public:
    Humanoid() = default;
    Humanoid(const string &amp;, const string &amp;, 
             const string &amp;, const string &amp;);
    Humanoid(const Humanoid &amp;h);// we have work for copies!
    Humanoid &amp;operator=(const Humanoid &amp;); // and for op=
    virtual ~Humanoid()  // virtual destructor
        { delete life; life = nullptr; }  
    // Added interfaces for the Adapter class
    <strong class="bold">const string &amp;GetSecondaryName() const</strong> 
        { return <strong class="bold">life-&gt;GetFirstName();</strong> }
    <strong class="bold">const string &amp;GetPrimaryName() const</strong> 
        { return <strong class="bold">life-&gt;GetLastName();</strong> }    
    <strong class="bold">const string &amp;GetTitle() const</strong> 
        { return <strong class="bold">life-&gt;GetTitle();</strong>}
    <strong class="bold">void SetSalutation(const string &amp;m)</strong> 
        { <strong class="bold">life-&gt;SetGreeting(m);</strong> }
    <strong class="bold">virtual void GetInfo() const</strong> { <strong class="bold">life-&gt;Print();</strong> }
    <strong class="bold">virtual const string &amp;Converse() = 0;</strong> // abstract class
};
Humanoid::Humanoid(const string &amp;n2, const string &amp;n1, 
          const string &amp;planetNation, const string &amp;greeting)
{
    <strong class="bold">life = new Person(n2, n1, ' ', planetNation);</strong>
    <strong class="bold">life-&gt;SetGreeting(greeting);</strong>
}
// copy constructor (we need to write it ourselves)
Humanoid::Humanoid(const Humanoid &amp;h)  
{  // Remember life data member is of type Person
    delete life;  // delete former associated object
    <strong class="bold">life = new Person(h.GetSecondaryName(),</strong>
                     <strong class="bold">h.GetPrimaryName(),' ', h.GetTitle());</strong>
    <strong class="bold">life-&gt;SetGreeting(h.life-&gt;Speak());</strong>  
}
// overloaded operator= (we need to write it ourselves)
Humanoid &amp;Humanoid::operator=(const Humanoid &amp;h)
{
    if (this != &amp;h)
        <strong class="bold">life-&gt;Person::operator=(dynamic_cast</strong>
                                <strong class="bold">&lt;const Person &amp;&gt;(h));</strong>
    return *this;
}
<strong class="bold">const string &amp;Humanoid::Converse()</strong> //default definition for
{                              // pure virtual fn - unusual
    <strong class="bold">return life-&gt;Speak();</strong>
}</pre>
<p>Notice in the aforementioned implementation of our Adapter class, <strong class="source-inline">Humanoid</strong> is no longer derived from <strong class="source-inline">Person</strong>. Instead, <strong class="source-inline">Humanoid</strong> will add a private data member <strong class="source-inline">Person *life;</strong>, which will represent an association between the Adapter (<strong class="source-inline">Humanoid</strong>) and the Adaptee (<strong class="source-inline">Person</strong>). In our Humanoid constructors, we will need to allocate the underlying implementation of the Adaptee (<strong class="source-inline">Person</strong>). We will also need to delete the Adaptee (<strong class="source-inline">Person</strong>) in our destructor.</p>
<p>Similar to our <a id="_idIndexMarker1186"/>last implementation, <strong class="source-inline">Humanoid</strong> offers <a id="_idIndexMarker1187"/>the same member functions within its public interface. However, notice that each <strong class="source-inline">Humanoid</strong> method delegates, through the associated object, a call to the appropriate Adaptee methods. For example, <strong class="source-inline">Humanoid::GetSecondaryName()</strong> merely calls <strong class="source-inline">life-&gt;GetFirstName();</strong> to delegate the request (versus calling the inherited, corresponding Adaptee methods). </p>
<p>As in our initial implementation, our derived classes from <strong class="source-inline">Humanoid</strong> (<strong class="source-inline">Orkan</strong>, <strong class="source-inline">Romulan</strong>, and <strong class="source-inline">Earthling</strong>) are specified in the same fashion, as is our Client within our <strong class="source-inline">main()</strong> function. </p>
<h3>Choosing the relationship between Adaptee and Adapter</h3>
<p>An interesting point to consider when choosing between private inheritance or association as the <a id="_idIndexMarker1188"/>relationship between Adapter and Adaptee is <a id="_idIndexMarker1189"/>whether or not the Adaptee contains any protected members. Recall that the original code for <strong class="source-inline">Person</strong> included a protected <strong class="source-inline">ModifyTitle()</strong> method. Should protected members exist in the Adaptee class? The private base class implementation allows those inherited, protected members to continue to be accessed within the scope of the Adapter class (that is, by methods of the Adapter). However, using the association-based implementation, the protected methods in the Adaptee (<strong class="source-inline">Person</strong>) are unusable in the scope of the Adapter. To make this example work, we were required to move <strong class="source-inline">Person::ModifyTitle()</strong> to the public access region. However, modifying the Adaptee class is not always possible, nor is it necessarily recommended. Considering the protected member issue, our initial implementation using a private base class is the stronger implementation, as it does not depend on us modifying the class definition of the Adaptee (<strong class="source-inline">Person</strong>).</p>
<p>Let us now take a brief look at an alternate usage of the Adapter pattern. We will simply be using an Adapter class as a wrapper class. We will add an OO interface to an otherwise loosely arranged set of functions that work well, but lack the desired interface our application (Client) desires. </p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor820"/>Using an Adapter as a wrapper</h2>
<p>As an alternative <a id="_idIndexMarker1190"/>usage of the Adapter pattern, we will <a id="_idIndexMarker1191"/>wrap an OO interface around a grouping of related external functions. That is, we will create a wrapper class to encapsulate these functions.</p>
<p>In our example, the external functions will represent a suite of existing database access functions. We will assume that the core database functionality is well tested for our data type (<strong class="source-inline">Person</strong>) and has been used problem-free. However, these external functions by themselves present an undesirable and unexpected functional interface. </p>
<p>We will instead wrap the external functions by creating an Adapter class to encapsulate their collective functionality. Our Adapter class will be <strong class="source-inline">CitizenDataBase</strong>, representing an encapsulated means for reading and writing <strong class="source-inline">Person</strong> instances from and to a database. Our existing external functions will provide the implementation for our <strong class="source-inline">CitizenDataBase</strong> member functions. Let us assume that the OO interfaces, as defined in our Adapter class, meet the requirements of our OO design.</p>
<p>Let’s take a look at the mechanics of our simple wrapper Adapter pattern, beginning by examining <a id="_idIndexMarker1192"/>external functions providing the database <a id="_idIndexMarker1193"/>access functionality. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programmin<span id="_idTextAnchor821"/>g-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp</a></p>
<pre class="source-code">
// Assume Person class exists with its usual implementation
<strong class="bold">Person objectRead;</strong> // holds the object from current read
                   // to support a simulation of a DB read
<strong class="bold">void db_open(const string &amp;dbName)</strong>
{   // Assume implementation exists
    cout &lt;&lt; "Opening database: " &lt;&lt; dbName &lt;&lt; endl;
}
<strong class="bold">void db_close(const string &amp;dbName)</strong>
{   // Assume implementation exists
    cout &lt;&lt; "Closing database: " &lt;&lt; dbName &lt;&lt; endl;
}
<strong class="bold">Person &amp;db_read(const string &amp;dbName, const string &amp;key)</strong>
{   // Assume implementation exists
    cout &lt;&lt; "Reading from: " &lt;&lt; dbName &lt;&lt; " using key: ";
    cout &lt;&lt; key &lt;&lt; endl;
    // In a true implementation, we would read the data
    // using the key and return the object we read in
    return objectRead; // non-stack instance for simulation
}
<strong class="bold">const string &amp;db_write(const string &amp;dbName, Person &amp;data)</strong>
{   // Assume implementation exists
    const string &amp;key = data.GetLastName();
    cout &lt;&lt; "Writing: " &lt;&lt; key &lt;&lt; " to: " &lt;&lt; 
             dbName &lt;&lt; endl;
    return key;
}</pre>
<p>In our previously defined external functions, let’s assume all functions are well tested and allow <strong class="source-inline">Person</strong> instances to be read from or written to a database. To support this simulation, we <a id="_idIndexMarker1194"/>have created an external <strong class="source-inline">Person</strong> instance <a id="_idIndexMarker1195"/>with <strong class="source-inline">Person objectRead;</strong> to provide a brief, non-stack located storage place for a newly read instance (used by <strong class="source-inline">db_read()</strong>) until the newly read instance is captured as a return value. Keep in mind that the existing external functions do not represent an encapsulated solution.</p>
<p>Now, let’s create a simple wrapper class to encapsulate these external functions. The wrapper class, <strong class="source-inline">CitizensDataBase</strong>, will represent our Adapter class:</p>
<pre class="source-code">
// CitizenDataBase is the Adapter class 
<strong class="bold">class CitizenDataBase</strong>  // Adapter wraps undesired interface
{
private:
    string name;
public:
    // No default constructor (unusual)
    <strong class="bold">CitizenDataBase(const string &amp;);</strong>
    <strong class="bold">CitizenDataBase(const CitizenDataBase &amp;) = delete;</strong>
    <strong class="bold">CitizenDataBase &amp;operator=(const CitizenDataBase &amp;)</strong> 
                               <strong class="bold">= delete;</strong>  // disallow =
    <strong class="bold">virtual ~CitizenDataBase();</strong>  // virtual destructor
    <strong class="bold">inline Person &amp;Read(const string &amp;);</strong>
    <strong class="bold">inline const string &amp;Write(Person &amp;);</strong>
};
CitizenDataBase::CitizenDataBase(const string &amp;n): name(n)
{
    <strong class="bold">db_open(name);</strong>   // call existing external function
}
CitizenDataBase::~CitizenDataBase()
{
    <strong class="bold">db_close(name);</strong>  // close database with external
}                    // function
Person &amp;CitizenDataBase::Read(const string &amp;key)
{
    <strong class="bold">return db_read(name, key);</strong>   // call external function
}
const string &amp;CitizenDataBase::Write(Person &amp;data)
{
    <strong class="bold">return db_write(name, data);</strong>  // call external function
}</pre>
<p>In our aforementioned class definition for our Adapter class, we simply encapsulate the external database functionality within the <strong class="source-inline">CitizenDataBase</strong> class. Here, <strong class="source-inline">CitizenDataBase</strong> is not only our Adapter class but also our Target class, as it contains the interfaces our application at hand (Client) expects. Notice that the <strong class="source-inline">CitizenDataBase</strong> methods of <strong class="source-inline">Read()</strong> and <strong class="source-inline">Write()</strong> have both been inlined in the class <a id="_idIndexMarker1196"/>definition; their methods merely call the <a id="_idIndexMarker1197"/>external functions. This is an example of how a wrapper class with inline functions can be a low-cost Adapter class, adding a very minimal amount of overhead (constructors, destru<a id="_idTextAnchor822"/>ctor, and potentially other non-inline methods).</p>
<p>Now, let’s take a look at our <strong class="source-inline">main()</strong> function, which is a streamlined version of a Client:</p>
<pre class="source-code">
int main()
{
    string key;
    string name("PersonData"); // name of database
    Person p1("Curt", "Jeffreys", 'M', "Mr.");
    Person p2("Frank", "Burns", 'W', "Mr.");
    Person p3;
    <strong class="bold">CitizenDataBase People(name);</strong>   // open Database
    key = <strong class="bold">People.Write(p1);</strong> // write a Person object
    p3 = <strong class="bold">People.Read(key);</strong>  // using a key, retrieve Person
    return 0;
}                        // destruction will close database</pre>
<p>In the aforementioned <strong class="source-inline">main()</strong> function, we first instantiate three <strong class="source-inline">Person</strong> instances. We then instantiate a <strong class="source-inline">CitizenDataBase</strong> to provide encapsulated access to write or read our <strong class="source-inline">Person</strong> instances, to or from the database. The methods for our <strong class="source-inline">CitizenDataBase</strong> constructors call the external function <strong class="source-inline">db_open()</strong> to open the database. Likewise, the destructor calls <strong class="source-inline">db_close()</strong>. As expected, our <strong class="source-inline">CitizenDataBase</strong> methods for <strong class="source-inline">Read()</strong> and <strong class="source-inline">Write()</strong> will each, respectively, call the external functions, <strong class="source-inline">db_read()</strong> or <strong class="source-inline">db_write()</strong>. </p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">Opening database: PersonData</p>
<p class="source-code">Writing: Jeffreys to: PersonData</p>
<p class="source-code">Reading from: PersonData using key: Jeffreys</p>
<p class="source-code">Closing database: PersonData</p>
<p>In the aforementioned output, we can notice the correlation between the various member <a id="_idIndexMarker1198"/>functions to the wrapped, external functions <a id="_idIndexMarker1199"/>via construction, a call to write and read, and then the destruction of the database.</p>
<p>Our simple <strong class="source-inline">CitizenDataBase</strong> wrapper is a very straightforward, but reasonable, use of the Adapter pattern. Interestingly, our <strong class="source-inline">CitizenDataBase</strong> also has commonalities with the <strong class="bold">Data Access Object pattern</strong>, as this wrapper provides a clean interface to a data storage <a id="_idIndexMarker1200"/>mechanism, concealing the implementation (access) to the underlying database.</p>
<p>We have now seen three implementations of the Adapter pattern. We have folded the concepts of Adapter, Adaptee, Target, and Client into the frame<a id="_idTextAnchor823"/>work of classes we are accustomed to seeing, namely <strong class="source-inline">Person</strong>, as well as into descendants of our Adapter (<strong class="source-inline">Orkan</strong>, <strong class="source-inline">Romulan</strong>, and <strong class="source-inline">Earthling</strong>, as in our first two examples). Let us now briefly recap what we have learned relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor824"/>Summary</h1>
<p>In this chapter, we have advanced our pursuit to become better C++ programmers through widening our knowledge of design patterns. We have explored the Adapter pattern in both the concept and through multiple implementations. Our first implementation used private inheritance two derive the Adapter from the Adaptee class. We specified our Adapter as an abstract class and then used public inheritance to introduce several Target classes based on the interface provided by our Adapter class. Our second implementation instead modeled the relationship between the Adapter and Adaptee using association. We then looked at an example usage of an Adapter as a wrapper to simply add an OO interface to existing function-based application components.</p>
<p>Utilizing common design patterns, such as the Adapter pattern, will help you more easily reuse existing, well-tested portions of code in a manner understood by other programmers. By utilizing core design patterns, you will be contributing to well-understood and reusable solutions with more sophisticated programming techniques.</p>
<p>We are now ready to continue forward with our next design pattern, in <a href="B19087_19.xhtml#_idTextAnchor829"><em class="italic">Chapter 19</em></a>, <em class="italic">Using the Singleton Pattern</em>. Adding more patterns to our arsenal of programming skills makes us more versatile and v<a id="_idTextAnchor825"/>alued programmers. Let’s continue forward!</p>
<h1 id="_idParaDest-290"><a id="_idTextAnchor826"/>Questions</h1>
<ol>
<li>Using the Adapter examples <a id="_idTextAnchor827"/>found in this chapter, create a program as follows:<ol><li>Implement a <strong class="source-inline">CitizenDataBase</strong> that stores various types of <strong class="source-inline">Humanoid</strong> instances (<strong class="source-inline">Orkan</strong>, <strong class="source-inline">Romulan</strong>, <strong class="source-inline">Earthling</strong>, and perhaps <strong class="source-inline">Martian</strong>). Decide whether you will use the private base class Adapter-Adaptee relationship or the association relationship between the Adapter and Adaptee (hin<a id="_idTextAnchor828"/>t: the private inheritance version will be easier).</li><li>Noting that the <strong class="source-inline">CitizenDataBase</strong> handles <strong class="source-inline">Person</strong> instances, can this class be used <em class="italic">as-is</em> to store various types of <strong class="source-inline">Humanoid</strong> instances, or must it be adapted in some way? Recall that <strong class="source-inline">Person</strong> is a base class of <strong class="source-inline">Humanoid</strong> (if you chose this implementation), but also remember that we can never upcast past a non-public inheritance boundary.</li></ol></li>
<li>What other examples can you imagine that might easily incorporate the Adapter pattern?</li>
</ol>
</div>
</div></body></html>