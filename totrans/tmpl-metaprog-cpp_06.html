<html><head></head><body><div><div><h1 id="_idParaDest-59"><em class="italic"><a id="_idTextAnchor064"/>Chapter 4</em>: Advanced Template Concepts</h1>
			<p>In the previous chapters, we learned the core fundamentals of C++ templates. At this point, you should be able to write templates that are perhaps not very complex. However, there are many more details concerning templates, and this chapter is dedicated to these more advanced topics. These include the following topics that we address next:</p>
			<ul>
				<li>Understanding name binding and dependent names</li>
				<li>Exploring template recursion</li>
				<li>Understanding template argument deduction</li>
				<li>Learning forwarding references and perfect forwarding</li>
				<li>Using the <code>decltype</code> specifier and the <code>std::declval</code> type operator</li>
				<li>Understanding friendship in templates</li>
			</ul>
			<p>On completing this chapter, you will acquire a deeper knowledge of these advanced template concepts and be able to understand and write more complex template code.</p>
			<p>We will start this chapter by learning about name binding and dependent names.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor065"/>Understanding name binding and dependent names</h1>
			<p>The term <strong class="bold">name binding</strong> refers to the process of finding the declaration of each name that is used within a template. There <a id="_idIndexMarker253"/>are two kinds of names used <a id="_idIndexMarker254"/>within a template: <strong class="bold">dependent names</strong> and <strong class="bold">non-dependent names</strong>. The former are names that depend on the type or value of a template parameter that can be a type, non-type, or template parameter. Names that don’t depend on <a id="_idIndexMarker255"/>template parameters are called <em class="italic">non-dependent</em>. The name lookup is performed differently for dependent and non-dependent names:</p>
			<ul>
				<li>For dependent <a id="_idIndexMarker256"/>names, it is performed at <em class="italic">the point of template instantiation</em>.</li>
				<li>For non-dependent names, it is <a id="_idIndexMarker257"/>performed at <em class="italic">the point of the template definition</em>.</li>
			</ul>
			<p>We will first look at non-dependent names. As previously mentioned, name lookup happens at the point of the <a id="_idIndexMarker258"/>template definition. This is located immediately before the template definition. To understand how this works, let’s consider the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct processor;          // [1] template declaration</pre>
			<pre class="source-code">void handle(double value)  // [2] handle(double) definition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "processing a double: " &lt;&lt; value &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser              // [3] template definition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      handle(42);          // [4] non-dependent name</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void handle(int value)     // [5] handle(int) definition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "processing an int: " &lt;&lt; value &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   parser&lt;int&gt; p;          // [6] template instantiation</pre>
			<pre class="source-code">   p.parse();</pre>
			<pre class="source-code">}</pre>
			<p>There are several points of reference that are marked in the comments on the right side. At point <code>[1]</code>, we have the declaration of a class template called <code>parser</code>. This is followed at point <code>[2]</code> by the definition of a function called <code>handle</code> that takes a <code>double</code> as its argument. The definition of the class template follows at point <code>[3]</code>. This class contains a single method called <code>run</code> that invokes a function called <code>handle</code> with the value <code>42</code> as its argument, at point <code>[4]</code>.</p>
			<p>The name <code>handle</code> is a non-dependent name because it does not depend on any template parameter. Therefore, name lookup and binding are performed at this point. <code>handle</code> must be a function known at point <code>[3]</code> and the function defined at <code>[2]</code> is the only match. After the class template definition, at point <code>[5]</code> we have the definition of an overload for the <a id="_idIndexMarker259"/>function <code>handle</code>, which takes an integer as its argument. This is a better match for <code>handle(42)</code>, but it comes after the name binding has been performed, and therefore it will be ignored. In the <code>main</code> function, at point <code>[6]</code>, we have an instantiation of the <code>parser</code> class template for the type <code>int</code>. Upon calling the <code>run</code> function, the text <code>processing a double: 42</code> will be printed to the console output.</p>
			<p>The next example is designed to introduce you to the concept of dependent names. Let’s look at the code first:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct handler          // [1] template definition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void handle(T value)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "handler&lt;T&gt;: " &lt;&lt; value &lt;&lt; '\n';</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser           // [2] template definition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse(T arg)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      arg.handle(42);   // [3] dependent name</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct handler&lt;int&gt;     // [4] template specialization</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void handle(int value)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "handler&lt;int&gt;: " &lt;&lt; value &lt;&lt; '\n';</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   handler&lt;int&gt; h;         // [5] template instantiation</pre>
			<pre class="source-code">   parser&lt;handler&lt;int&gt;&gt; p; // [6] template instantiation</pre>
			<pre class="source-code">   p.parse(h);</pre>
			<pre class="source-code">}</pre>
			<p>This example is slightly different from the previous one. The <code>parser</code> class template is very similar, but the <code>handle</code> functions have become members of another class template. Let’s analyze it point by point. </p>
			<p>At the point mark with <code>[1]</code> in the comments, we have the definition of a class template called <code>handler</code>. This contains a single, public method called <code>handle</code> that takes an argument of the <code>T</code> type and prints its value to the console. Next, at point <code>[2]</code>, we have the definition of the <a id="_idIndexMarker260"/>class template called <code>parser</code>. This is similar to the previous one, except for one key aspect: at point <code>[3]</code>, it invokes a method called <code>handle</code> on its argument. Because the type of the argument is the template parameter <code>T</code>, it makes <code>handle</code> a dependent name. Dependent names are looked up at the point of template instantiation, so <code>handle</code> is not bound at this point. Continuing with the code, at point <code>[4]</code>, there is a template specialization for the <code>handler</code> class template for the type <code>int</code>. As a specialization, this is a better match for the dependent name. Therefore, when the template instantiation happens at point <code>[6]</code>, <code>handler&lt;int&gt;::handle</code> is the name that is bound to the dependent name used at <code>[3]</code>. Running this program will print <code>handler&lt;int&gt;: 42</code> to the console.</p>
			<p>Now that we’ve seen how name binding occurs, let’s learn how this relates to template instantiation.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor066"/>Two-phase name lookup</h2>
			<p>The key takeaway from the previous section is that name lookup happens differently for dependent <a id="_idIndexMarker261"/>names (those that depend on a template parameter) and non-dependent names (those that do not depend on a template parameter, plus the template name and names defined in the current template instantiation). When the compiler passes through the definition of a template it needs to figure out whether a name is dependent or non-dependent. Further name lookup depends on this categorization and happens either at the template definition point (for non-dependent names) or the template instantiation point (for dependent names). Therefore, instantiation of a template happens in two phases:</p>
			<ul>
				<li>The first phase occurs at the point of the definition when the template syntax is checked and names are categorized as dependent or non-dependent.</li>
				<li>The second phase occurs at the point of instantiation when the template arguments are substituted for the template parameters. Name binding for dependent names happens at this point.</li>
			</ul>
			<p>This process in two steps is called <strong class="bold">two-phase name lookup</strong>. To understand it better, let’s consider <a id="_idIndexMarker262"/>another example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct base_parser</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void init()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "init\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser : base_parser&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      init();        // error: identifier not found</pre>
			<pre class="source-code">      std::cout &lt;&lt; "parse\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   parser&lt;int&gt; p;</pre>
			<pre class="source-code">   p.parse();</pre>
			<pre class="source-code">}</pre>
			<p>In this snippet, we have two class templates: <code>base_parser</code>, which contains a public method called <code>init</code>, and <code>parser</code>, which derives from <code>base_parser</code> and contains a public method called <code>parse</code>. The <code>parse</code> member function calls a function called <code>init</code> and the intention is that it’s the base-class method <code>init</code> that is invoked here. However, the compiler will issue an error, because it’s not able to find <code>init</code>. The reason this happens is that <code>init</code> is a non-dependent name (as it does not depend on a template parameter). Therefore, it must be known at the point of the definition of the <code>parser</code> template. Although a <code>base_parser&lt;T&gt;::init</code> exists, the compiler cannot assume it’s what we want to call because the primary template <code>base_parser</code> can be later specialized and <code>init</code> can <a id="_idIndexMarker263"/>be defined as something else (such as a type, or a variable, or another function, or it may be missing entirely). Therefore, name lookup does not happen in the base class, only on its enclosing scope, and there is no function called <code>init</code> in <code>parser</code>. </p>
			<p>This problem can be fixed by making <code>init</code> a dependent name. This can be done either by prefixing with <code>this-&gt;</code> or with <code>base_parser&lt;T&gt;::</code>. By turning <code>init</code> into a dependent name, its name binding is moved from the point of template definition to the point of template instantiation. In the following snippet, this problem is solved by invoking <code>init</code> through the <code>this</code> pointer:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser : base_parser&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      this-&gt;init();        // OK</pre>
			<pre class="source-code">      std::cout &lt;&lt; "parse\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>Continuing this example, let’s consider that a specialization of <code>base_parser</code> for the <code>int</code> type is made <a id="_idIndexMarker264"/>available after the definition of the <code>parser</code> class template. This can look as follows:</p>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct base_parser&lt;int&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void init()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "specialized init\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>Furthermore, let’s consider the following use of the <code>parser</code> class template:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   parser&lt;int&gt; p1;</pre>
			<pre class="source-code">   p1.parse();</pre>
			<pre class="source-code">   parser&lt;double&gt; p2;</pre>
			<pre class="source-code">   p2.parse();</pre>
			<pre class="source-code">}</pre>
			<p>When you run this program, the following text will be printed to the console:</p>
			<pre class="source-code">specialized init</pre>
			<pre class="source-code">parse</pre>
			<pre class="source-code">init</pre>
			<pre class="source-code">parse</pre>
			<p>The reason for this behavior is that <code>p1</code> is an instance of <code>parser&lt;int&gt;</code> and there is a specialization of its base class, <code>base_parser&lt;int&gt;</code> that implements the <code>init</code> function <a id="_idIndexMarker265"/>and prints <code>specialized init</code> to the console. On the other hand, <code>p2</code> is an instance of <code>parser&lt;double&gt;</code>. Since a specialization of <code>base_parser</code> for the <code>double</code> type is not available, the <code>init</code> function from the primary template is being called and this only prints <code>init</code> to the console.</p>
			<p>The next subject of this broader topic is using dependent names that are types. Let’s learn how that works.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor067"/>Dependent type names</h2>
			<p>In the examples <a id="_idIndexMarker266"/>seen so far, the dependent name was a function or a member function. However, there are cases when a dependent name is a type. This is demonstrated with the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct base_parser</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser : base_parser&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      value_type v{};                       // [1] error</pre>
			<pre class="source-code">      // or</pre>
			<pre class="source-code">      base_parser&lt;T&gt;::value_type v{};       // [2] error</pre>
			<pre class="source-code">      std::cout &lt;&lt; "parse\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>In this snippet, <code>base_parser</code> is a class template that defines a type alias for <code>T</code> called <code>value_type</code>. The <code>parser</code> class template, which derives from <code>base_parser</code>, needs to use this type within its <code>parse</code> method. However, both <code>value_type</code> and <code>base_parser&lt;T&gt;::value_type</code> do not work, and the compiler is issuing an error. <code>value_type</code> does not work because it’s a non-dependent name and therefore it will not be looked up <a id="_idIndexMarker267"/>in the base class, only in the enclosing scope. <code>base_parser&lt;T&gt;::value_type</code> does not work either because the compiler cannot assume this is actually a type. A specialization of <code>base_parser</code> may follow and <code>value_type</code> could be defined as something else than a type.</p>
			<p>In order to fix this problem, we need to tell the compiler the name refers to a type. Otherwise, by default, the compiler assumes it’s not a type. This is done with the <code>typename</code> keyword, at the point of definition, shown as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser : base_parser&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      typename base_parser&lt;T&gt;::value_type v{}; // [3] OK</pre>
			<pre class="source-code">      std::cout &lt;&lt; "parse\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>There are actually two exceptions to this rule:</p>
			<ul>
				<li>When specifying a base class</li>
				<li>When initializing class members</li>
			</ul>
			<p>Let’s see <a id="_idIndexMarker268"/>an example for these two exceptions:</p>
			<pre class="source-code">struct dictionary_traits</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    using key_type = int;</pre>
			<pre class="source-code">    using map_type = std::map&lt;key_type, std::string&gt;;</pre>
			<pre class="source-code">    static constexpr int identity = 1;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct dictionary : T::map_type      // [1]</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    int start_key { T::identity };   // [2]</pre>
			<pre class="source-code">    typename T::key_type next_key;   // [3]</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    dictionary&lt;dictionary_traits&gt; d;</pre>
			<pre class="source-code">}</pre>
			<p>The <code>dictionay_traits</code> is a class used as the template argument for the <code>dictionary</code> class template. This class derives from <code>T::map_type</code> (see line <code>[1]</code>) but the use of the <code>typename</code> keyword is not required here. The dictionary class defines a member called <code>start_key</code>, which is an <code>int</code> initialized with the value of <code>T::identity</code> (see line <code>[2]</code>). Again, the <code>typename</code> keyword is not needed here. However, if we want to define yet another member of the type <code>T::key_type</code> (see line <code>[3]</code>) we do need to use <code>typename</code>. </p>
			<p>The requirements for using <code>typename</code> have been relaxed in <code>[3]</code> previously no longer requires prefixing with the <code>typename</code> keyword.</p>
			<p>In C++20, <code>typename</code> is <a id="_idIndexMarker270"/>implicit (can be deduced by the compiler) in the following contexts:</p>
			<ul>
				<li>In using declarations</li>
				<li>In the declaration of data members</li>
				<li>In the declaration or definition of function parameters</li>
				<li>In trailing return types</li>
				<li>In default arguments of type-parameters of a template</li>
				<li>In the type-id of a <code>static_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>, or <code>dynamic_cast</code> statement</li>
			</ul>
			<p>Some of these contexts are exemplified in the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct dictionary : T::map_type</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int start_key{ T::identity };</pre>
			<pre class="source-code">   T::key_type next_key;                              // [1]</pre>
			<pre class="source-code">   using value_type = T::map_type::mapped_type;       // [2]</pre>
			<pre class="source-code">   void add(T::key_type const&amp;, value_type const&amp;) {} // [3]</pre>
			<pre class="source-code">};.</pre>
			<p>At all the lines marked with <code>[1]</code>, <code>[2]</code>, and <code>[3]</code> in this snippet, prior to C++20, the <code>typename</code> keyword was required to indicate a type name (such as <code>T::key_type</code> or <code>T::map_type::mapped_type</code>). When compiled with C++20, this is no longer necessary.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B18367_02_ePub.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Template Fundamentals</em>, we have seen that the keywords <code>typename</code> and <code>class</code> can be used to introduce type template parameters and they are interchangeable. The keyword <code>typename</code> here, although it has a similar purpose, cannot be substituted with the keyword <code>class</code>.</p>
			<p>Not only types <a id="_idIndexMarker271"/>can be dependent names but other templates too. We look at this topic in the next subsection.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor068"/>Dependent template names</h2>
			<p>There are cases when the dependent name is a template, such as a function template or a class template. However, the <a id="_idIndexMarker272"/>default behavior of the compiler is to interpret the dependent name as a non-type, which leads to errors concerning the usage of the comparison operator <code>&lt;</code>. Let’s demonstrate this with an example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct base_parser</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   void init()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "init\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser : base_parser&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      // base_parser&lt;T&gt;::init&lt;int&gt;();        // [1] error</pre>
			<pre class="source-code">      base_parser&lt;T&gt;::template init&lt;int&gt;();  // [2] OK</pre>
			<pre class="source-code">      std::cout &lt;&lt; "parse\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>This is similar to the previous snippets, but the <code>init</code> function in <code>base_parser</code> is also a template. The attempt to call it using the <code>base_parser&lt;T&gt;::init&lt;int&gt;()</code> syntax, as seen at point <code>[1]</code>, results in a compiler error. Therefore, we must use the <code>template</code> keyword to tell the compiler the dependent name is a template. This is done as shown at point <code>[2]</code>.</p>
			<p>Keep in mind that the <code>template</code> keyword can only follow the scope resolution operator (<code>::</code>), member access through pointer (<code>-&gt;</code>), and the member access (<code>.</code>). Examples of correct <a id="_idIndexMarker273"/>usage are <code>X::template foo&lt;T&gt;()</code>, <code>this-&gt;template foo&lt;T&gt;()</code>, and <code>obj.template foo&lt;T&gt;()</code>.</p>
			<p>The dependent name does not have to be a function template. It can also be a class template, shown as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct base_parser</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   struct token {};</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser : base_parser&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void parse()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using token_type = </pre>
			<pre class="source-code">         base_parser&lt;T&gt;::template token&lt;int&gt;; // [1]</pre>
			<pre class="source-code">      token_type t1{};</pre>
			<pre class="source-code">      typename base_parser&lt;T&gt;::template token&lt;int&gt; t2{}; </pre>
			<pre class="source-code">                                                     // [2]</pre>
			<pre class="source-code">      std::cout &lt;&lt; "parse\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The <code>token</code> class is an inner class template of the <code>base_parser</code> class template. It can be either used as in the line marked with <code>[1]</code>, where a type alias is defined (which is then used to instantiate an object) or as at line <code>[2]</code>, where it is used directly to declare a variable. Notice that <a id="_idIndexMarker274"/>the <code>typename</code> keyword is not necessary at <code>[1]</code>, where the using declaration indicates we are dealing with a type, but is required at <code>[2]</code> because the compiler would otherwise assume it’s a non-type name.</p>
			<p>The use of the <code>typename</code> and <code>template</code> keywords is not required in some contexts of the current template <a id="_idIndexMarker275"/>instantiation being observed. This will be the topic of the next subsection.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor069"/>Current instantiation</h2>
			<p>The requirement to use the <code>typename</code> and <code>template</code> keywords to disambiguate dependent names may be <a id="_idIndexMarker276"/>avoided in the context of a class template definition where the compiler is able to deduce some dependent names (such as the name of a nested class) to refer to the current instantiation. This means some errors can be identified sooner, at the point of definition instead of the point of instantiation.</p>
			<p>The complete list of names that can refer to the current instantiation, according to the C++ <em class="italic">Standard, §13.8.2.1 - Dependent Types</em>, is presented in the following table:</p>
			<div><div><img src="img/B18367_04_Table_4.1.jpg" alt="Table 4.1&#13;&#10;" width="1642" height="1153"/>
				</div>
			</div>
			<p class="figure-caption">Table 4.1</p>
			<p>The following <a id="_idIndexMarker277"/>are the rules for considering a name as part of the current instantiation:</p>
			<ul>
				<li>An unqualified name (that does not appear on the right side of the scope resolution operator <code>::</code>) found in the current instantiation or its non-dependent base</li>
				<li>A qualified name (that appears on the right side of the scope resolution operator <code>::</code>) if its qualifier (the part that appears on the left side of the scope resolution operator) names the current instantiation and is found in the current instantiation or its non-dependent base</li>
				<li>A name used in a class member access expression where the object expression is the current instantiation and the name is found in the current instantiation or its non-dependent base<p class="callout-heading">Note</p><p class="callout">It is said that a base class is a <strong class="bold">dependent class</strong> if it is a dependent type (depends on a template parameter) and <a id="_idIndexMarker278"/>is not in the current instantiation. Otherwise, a base <a id="_idIndexMarker279"/>class is said to be a <strong class="bold">non-dependent class</strong>.</p></li>
			</ul>
			<p>These rules may <a id="_idIndexMarker280"/>sound a bit harder to comprehend; therefore, let’s try to understand them with the help of several examples, as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   parser* p1;          // parser is the CI</pre>
			<pre class="source-code">   parser&lt;T&gt;* p2;       // parser&lt;T&gt; is the CI</pre>
			<pre class="source-code">   ::parser&lt;T&gt;* p3;     // ::parser&lt;T&gt; is the CI</pre>
			<pre class="source-code">   parser&lt;T*&gt; p4;       // parser&lt;T*&gt; is not the CI</pre>
			<pre class="source-code">   struct token</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      token* t1;                  // token is the CI</pre>
			<pre class="source-code">      parser&lt;T&gt;::token* t2;       // parser&lt;T&gt;::token is the CI</pre>
			<pre class="source-code">      typename parser&lt;T*&gt;::token* t3; </pre>
			<pre class="source-code">                         // parser&lt;T*&gt;::token is not the CI</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct parser&lt;T*&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   parser&lt;T*&gt;* p1;   // parser&lt;T*&gt; is the CI</pre>
			<pre class="source-code">   parser&lt;T&gt;*  p2;   // parser&lt;T&gt; is not the CI</pre>
			<pre class="source-code">};</pre>
			<p>In the primary template <code>parser</code>, the names <code>parser</code>, <code>parser&lt;T&gt;</code>, and <code>::parser&lt;T&gt;</code> all refer to the current instantiation. However, <code>parser&lt;T*&gt;</code> does not. The class <code>token</code> is a nested class of the primary template <code>parser</code>. In the scope of this class, <code>token</code> and <code>parser&lt;T&gt;::token</code> are both denoting the current instantiation. The same is not true for <code>parser&lt;T*&gt;::token</code>. This snippet also contains a partial specialization of the primary template for the pointer type <code>T*</code>. In the context of this partial specialization, <code>parser&lt;T*&gt;</code> is the current instantiation, but <code>parser&lt;T&gt;</code> is not.</p>
			<p>Dependent names are an important aspect of template programming. The key takeaway from this section is that names are categorized as dependent (those that depend on a template parameter) and non-dependent (those that don’t depend on a template parameter). Name binding happens at the point of definition for non-dependent types and at the point of instantiation <a id="_idIndexMarker281"/>for dependent types. In some cases, the keywords <code>typename</code> and <code>template</code> are required to disambiguate the use of names and tell the compiler that a name refers to a type or a template. In the context of a class template definition, the compiler is, however, able to figure out that some dependent names refer to the current instantiation, which enables it to identify errors sooner.</p>
			<p>In the next section, we move our attention to a topic that we briefly touched already, which is template recursion.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor070"/>Exploring template recursion</h1>
			<p>In <a href="B18367_03_ePub.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Variadic Templates</em>, we discussed variadic templates and saw that they are implemented <a id="_idIndexMarker282"/>with a mechanism that looks like recursion. In fact, it is overloaded functions and class template specializations respectively. However, it is possible to create recursive templates. To demonstrate how this works, we’ll look at implementing a compile-time version of the factorial function. This is typically implemented in a recursive manner, and a possible implementation is the following:</p>
			<pre class="source-code">constexpr unsigned int factorial(unsigned int const n)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return n &gt; 1 ? n * factorial(n - 1) : 1;</pre>
			<pre class="source-code">}</pre>
			<p>This should be trivial to understand: return the result of multiplying the function argument with the value returned by calling the function recursively with the decremented argument, or return the value <code>1</code> if the argument is <code>0</code> or <code>1</code>. The type of the argument (and the return value) is <code>unsigned int</code> to avoid calling it for negative integers.</p>
			<p>To compute the value of the factorial function at compile time, we need to define a class template that <a id="_idIndexMarker283"/>contains a data member holding the value of the function. The implementation looks as follows:</p>
			<pre class="source-code">template &lt;unsigned int N&gt;</pre>
			<pre class="source-code">struct factorial</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr unsigned int value = </pre>
			<pre class="source-code">      N * factorial&lt;N - 1&gt;::value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct factorial&lt;0&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr unsigned int value = 1;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; factorial&lt;4&gt;::value &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>The first definition is the primary template. It has a non-type template parameter representing the value whose factorial needs to be computed. This class contains a static <code>constexpr</code> data member called <code>value</code>, initialized with the result of multiplying the argument <code>N</code> and the value of the factorial class template instantiated with the decremented argument. The recursion needs an end case and that is provided by the explicit specialization for the value <code>0</code> (of the non-type template argument), in which case the member value is initialized with <code>1</code>.</p>
			<p>When encountering the instantiation <code>factorial&lt;4&gt;::value</code> in the <code>main</code> function, the compiler <a id="_idIndexMarker284"/>generates all the recursive instantiations from <code>factorial&lt;4&gt;</code> to <code>factorial&lt;0&gt;</code>. These look as follows:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct factorial&lt;4&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline static constexpr const unsigned int value = </pre>
			<pre class="source-code">      4U * factorial&lt;3&gt;::value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct factorial&lt;3&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline static constexpr const unsigned int value = </pre>
			<pre class="source-code">      3U * factorial&lt;2&gt;::value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct factorial&lt;2&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline static constexpr const unsigned int value = </pre>
			<pre class="source-code">      2U * factorial&lt;1&gt;::value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct factorial&lt;1&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline static constexpr const unsigned int value = </pre>
			<pre class="source-code">      1U * factorial&lt;0&gt;::value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct factorial&lt;0&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline static constexpr const unsigned int value = 1;</pre>
			<pre class="source-code">};</pre>
			<p>From these instantiations, the compiler is able to compute the value of the data member <code>factorial&lt;N&gt;::value</code>. It should be mentioned again that when optimizations are enabled, this code would not even be generated, but the resulting constant is used directly in the generated assembly code.</p>
			<p>The implementation of the factorial class template is relatively trivial, and the class template is basically <a id="_idIndexMarker285"/>only a wrapper over the static data member <code>value</code>. We can actually avoid it altogether by using a variable template instead. This can be defined as follows:</p>
			<pre class="source-code">template &lt;unsigned int N&gt;</pre>
			<pre class="source-code">inline constexpr unsigned int factorial = N * factorial&lt;N - 1&gt;;</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">inline constexpr unsigned int factorial&lt;0&gt; = 1;</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; factorial&lt;4&gt; &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>There is a striking similarity between the implementation of the <code>factorial</code> class template and the <code>factorial</code> variable template. For the latter, we have basically taken out the data member <a id="_idIndexMarker286"/>value and called it <code>factorial</code>. On the other hand, this may also be more convenient to use because it does not require accessing the data member value as in <code>factorial&lt;4&gt;::value</code>.</p>
			<p>There is a third approach for computing the factorial at compile time: using function templates. A possible implementation is shown next:</p>
			<pre class="source-code">template &lt;unsigned int n&gt;</pre>
			<pre class="source-code">constexpr unsigned int factorial()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return n * factorial&lt;n - 1&gt;();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt; constexpr unsigned int factorial&lt;1&gt;() { </pre>
			<pre class="source-code">                                               return 1; }</pre>
			<pre class="source-code">template&lt;&gt; constexpr unsigned int factorial&lt;0&gt;() { </pre>
			<pre class="source-code">                                               return 1; }</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; factorial&lt;4&gt;() &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>You can see there is a primary template that calls the <code>factorial</code> function template recursively, and we have two full specializations for the values <code>1</code> and <code>0</code>, both returning <code>1</code>. </p>
			<p>Which of these three different approaches is the best is probably arguable. Nevertheless, the <a id="_idIndexMarker287"/>complexity of the recursive instantiations of the factorial templates remained the same. However, this depends on the nature of the template. The following snippet shows an example of when complexity increases:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper {};</pre>
			<pre class="source-code">template &lt;int N&gt;</pre>
			<pre class="source-code">struct manyfold_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = </pre>
			<pre class="source-code">      wrapper&lt;</pre>
			<pre class="source-code">             typename manyfold_wrapper&lt;N - 1&gt;::value_type&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct manyfold_wrapper&lt;0&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = unsigned int;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; </pre>
			<pre class="source-code">    typeid(manyfold_wrapper&lt;0&gt;::value_type).name() &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; </pre>
			<pre class="source-code">    typeid(manyfold_wrapper&lt;1&gt;::value_type).name() &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; </pre>
			<pre class="source-code">    typeid(manyfold_wrapper&lt;2&gt;::value_type).name() &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; </pre>
			<pre class="source-code">    typeid(manyfold_wrapper&lt;3&gt;::value_type).name() &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>There are two class templates in this example. The first is called <code>wrapper</code> and has an empty implementation (it doesn’t actually matter what it contains) but it represents a wrapper class over some type (or more precisely a value of some type). The second template is called <code>manyfold_wrapper</code>. This represents a wrapper over a wrapper over a type many times over, hence the name <code>manyfold_wrapper</code>. There is no end case for an upper limit of this number of wrappings, but there is a start case for the lower limit. The full specialization for value <code>0</code> defines a member type called <code>value_type</code> for the <code>unsigned int</code> type. As a result, <code>manyfold_wrapper&lt;1&gt;</code> defines a member type called <code>value_type</code> for <code>wrapper&lt;unsigned int&gt;</code>, <code>manyfold_wrapper&lt;2&gt;</code> defines a member type called <code>value_type</code> for <code>wrapper&lt;wrapper&lt;unsigned int&gt;&gt;</code>, and so on. Therefore, executing the <code>main</code> function <a id="_idIndexMarker288"/>will print the following to the console:</p>
			<pre class="source-code">unsigned int</pre>
			<pre class="source-code">struct wrapper&lt;unsigned int&gt;</pre>
			<pre class="source-code">struct wrapper&lt;struct wrapper&lt;unsigned int&gt; &gt;</pre>
			<pre class="source-code">struct wrapper&lt;struct wrapper&lt;struct wrapper&lt;unsigned int&gt; &gt; &gt;</pre>
			<p>The C++ standard does not specify a limit for the recursively nested template instantiations but does recommend a minimum limit of 1,024. However, this is only a recommendation and not a requirement. Therefore, different compilers have implemented different limits. The <strong class="bold">VC++ 16.11</strong> compiler has <a id="_idIndexMarker289"/>the limit set <a id="_idIndexMarker290"/>at 500, <strong class="bold">GCC 12</strong> at 900, and <strong class="bold">Clang 13</strong> at 1,024. A compiler error <a id="_idIndexMarker291"/>is generated when this limit is exceeded. Some examples are shown here:</p>
			<p>For VC++:</p>
			<pre>fatal error C1202: recursive type or function dependency context too complex</pre>
			<p>For GCC:</p>
			<pre>fatal error: template instantiation depth exceeds maximum of 900 (use '-ftemplate-depth=' to increase the maximum)</pre>
			<p>For Clang:</p>
			<pre>fatal error: recursive template instantiation exceeded maximum depth of 1024
use -ftemplate-depth=N to increase recursive template instantiation depth</pre>
			<p>For GCC and Clang, the compiler option <code>-ftemplate-depth=N</code> can be used to increase this maximum value for nested template instantiations. Such an option is not available for the Visual C++ compiler.</p>
			<p>Recursive templates help us solve some problems in a recursive manner at compile time. Whether you use recursive function templates, variable templates, or class templates depends on the problem you are trying to solve or perhaps your preference. However, you should <a id="_idIndexMarker292"/>keep in mind there are limits to the depth template recursion works. Nevertheless, use template recursion judiciously. </p>
			<p>The next advanced topic to address in this chapter is template argument deduction, both for functions and classes. We start next with the former.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor071"/>Function template argument deduction</h1>
			<p>Earlier in this book, we have briefly talked about the fact that the compiler can sometimes <a id="_idIndexMarker293"/>deduce the template arguments from the <a id="_idIndexMarker294"/>context of the function call, allowing you to avoid explicitly specifying them. The rules for template argument deduction are more complex and we will explore this topic in this section.</p>
			<p>Let’s start the discussion by looking at a simple example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void process(T arg)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "process " &lt;&lt; arg &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   process(42);          // [1] T is int</pre>
			<pre class="source-code">   process&lt;int&gt;(42);     // [2] T is int, redundant</pre>
			<pre class="source-code">   process&lt;short&gt;(42);   // [3] T is short</pre>
			<pre class="source-code">}</pre>
			<p>In this snippet, <code>process</code> is a function template with a single type template parameter. The calls <code>process(42)</code> and <code>process&lt;int&gt;(42)</code> are identical because, in the first case, the compiler is able to deduce the type of the type template parameter <code>T</code> as <code>int</code> from the value of the argument passed to the function.</p>
			<p>When the compiler tries to deduce the template arguments, it performs the matching of the types of the template parameters with the types of the arguments used to invoke the function. There are some rules that govern this matching. The compiler can match the following:</p>
			<ul>
				<li>Types (both cv-qualified and non-qualified) of the form <code>T</code>, <code>T const</code>, <code>T volatile</code>:<pre>struct account_t
{
   int number;
};
template &lt;typename T&gt;
void process01(T) { std::cout &lt;&lt; "T\n"; }
template &lt;typename T&gt;
void process02(T const) { std::cout &lt;&lt; "T const\n"; }
template &lt;typename T&gt;
void process03(T volatile) { std::cout &lt;&lt; "T volatile\n"; }
int main()
{
   account_t ac{ 42 };
   process01(ac);  // T
   process02(ac);  // T const
   process03(ac);  // T volatile
}</pre></li>
				<li>Pointers (<code>T*</code>), l-value <a id="_idIndexMarker295"/>references (<code>T&amp;</code>), and <a id="_idIndexMarker296"/>r-value references (<code>T&amp;&amp;</code>):<pre>template &lt;typename T&gt;
void process04(T*) { std::cout &lt;&lt; "T*\n"; }
template &lt;typename T&gt;
void process04(T&amp;) { std::cout &lt;&lt; "T&amp;\n"; }
template &lt;typename T&gt;
void process05(T&amp;&amp;) { std::cout &lt;&lt; "T&amp;&amp;\n"; }
int main()
{
   account_t ac{ 42 };
   process04(&amp;ac);  // T*
   process04(ac);  // T&amp;
   process05(ac);  // T&amp;&amp;
}</pre></li>
				<li>Arrays such as <code>T[5]</code>, or <code>C[5][n]</code>, where <code>C</code> is a class type and <code>n</code> is a non-type template argument:<pre>template &lt;typename T&gt;
void process06(T[5]) { std::cout &lt;&lt; "T[5]\n"; }
template &lt;size_t n&gt;
void process07(account_t[5][n]) 
{ std::cout &lt;&lt; "C[5][n]\n"; }
int main()
{
   account_t arr1[5] {};
   process06(arr1);  // T[5]
   account_t ac{ 42 };
   process06(&amp;ac);   // T[5]
   account_t arr2[5][3];
   process07(arr2);  // C[5][n]
}</pre></li>
				<li>Pointers to functions, with the form <code>T(*)()</code>, <code>C(*)(T)</code>, and <code>T(*)(U)</code>, where <code>C</code> is a class <a id="_idIndexMarker297"/>type and <code>T</code> and <code>U</code> are type <a id="_idIndexMarker298"/>template parameters:<pre>template&lt;typename T&gt;
void process08(T(*)()) { std::cout &lt;&lt; "T (*)()\n"; }
template&lt;typename T&gt;
void process08(account_t(*)(T)) 
{ std::cout &lt;&lt; "C (*) (T)\n"; }
template&lt;typename T, typename U&gt;
void process08(T(*)(U)) { std::cout &lt;&lt; "T (*)(U)\n"; }
int main()
{
   account_t (*pf1)() = nullptr;
   account_t (*pf2)(int) = nullptr;
   double    (*pf3)(int) = nullptr;
   process08(pf1);    // T (*)()
   process08(pf2);    // C (*)(T)
   process08(pf3);    // T (*)(U)
}</pre></li>
				<li>Pointers <a id="_idIndexMarker299"/>to member functions <a id="_idIndexMarker300"/>with one of the following forms, <code>T (C::*)()</code>, <code>T (C::*)(U)</code>, <code>T (U::*)()</code>, <code>T (U::*)(V)</code>, <code>C (T::*)()</code>, <code>C (T::*)(U)</code>, and <code>D (C::*)(T)</code>, where <code>C</code> and <code>D</code> are class types and <code>T</code>, <code>U</code>, and <code>V</code> are type template parameters:<pre>struct account_t
{
   int number;
   int get_number() { return number; }
   int from_string(std::string text) { 
      return std::atoi(text.c_str()); }
};
struct transaction_t
{
   double amount;
};
struct balance_report_t {};
struct balance_t
{
   account_t account;
   double    amount;
   account_t get_account()  { return account; }
   int get_account_number() { return account.number; }
   bool can_withdraw(double const value)  
      {return amount &gt;= value; };
   transaction_t withdraw(double const value) { 
      amount -= value; return transaction_t{ -value }; }
   balance_report_t make_report(int const type) 
   {return {}; }
};
template&lt;typename T&gt;
void process09(T(account_t::*)())
{ std::cout &lt;&lt; "T (C::*)()\n"; }
template&lt;typename T, typename U&gt;
void process09(T(account_t::*)(U))
{ std::cout &lt;&lt; "T (C::*)(U)\n"; }
template&lt;typename T, typename U&gt;
void process09(T(U::*)())
{ std::cout &lt;&lt; "T (U::*)()\n"; }
template&lt;typename T, typename U, typename V&gt;
void process09(T(U::*)(V))
{ std::cout &lt;&lt; "T (U::*)(V)\n"; }
template&lt;typename T&gt;
void process09(account_t(T::*)())
{ std::cout &lt;&lt; "C (T::*)()\n"; }
template&lt;typename T, typename U&gt;
void process09(transaction_t(T::*)(U))
{ std::cout &lt;&lt; "C (T::*)(U)\n"; }
template&lt;typename T&gt;
void process09(balance_report_t(balance_t::*)(T))
{ std::cout &lt;&lt; "D (C::*)(T)\n"; }
int main()
{
   int (account_t::* pfm1)() = &amp;account_t::get_number;
   int (account_t::* pfm2)(std::string) = 
      &amp;account_t::from_string;
   int (balance_t::* pfm3)() =
      &amp;balance_t::get_account_number;
   bool (balance_t::* pfm4)(double) =
      &amp;balance_t::can_withdraw;
   account_t (balance_t::* pfm5)() = 
      &amp;balance_t::get_account;
   transaction_t(balance_t::* pfm6)(double) = 
      &amp;balance_t::withdraw;
   balance_report_t(balance_t::* pfm7)(int) = 
      &amp;balance_t::make_report;
   process09(pfm1);    // T (C::*)()
   process09(pfm2);    // T (C::*)(U)
   process09(pfm3);    // T (U::*)()
   process09(pfm4);    // T (U::*)(V)
   process09(pfm5);    // C (T::*)()
   process09(pfm6);    // C (T::*)(U)
   process09(pfm7);    // D (C::*)(T)
}</pre></li>
				<li>Pointers <a id="_idIndexMarker301"/>to data members such <a id="_idIndexMarker302"/>as <code>T C::*</code>, <code>C T::*</code>, and <code>T U::*</code>, where <code>C</code> is a class type and <code>T</code> and <code>U</code> are type template parameters:<pre>template&lt;typename T&gt;
void process10(T account_t::*) 
{ std::cout &lt;&lt; "T C::*\n"; }
template&lt;typename T&gt;
void process10(account_t T::*) 
{ std::cout &lt;&lt; "C T::*\n"; }
template&lt;typename T, typename U&gt;
void process10(T U::*) { std::cout &lt;&lt; "T U::*\n"; }
int main()
{
   process10(&amp;account_t::number);   // T C::*
   process10(&amp;balance_t::account);  // C T::*
   process10(&amp;balance_t::amount);   // T U::*
}</pre></li>
				<li>A template with an argument list that contains at least one type template parameter; the general form is <code>C&lt;T&gt;</code>, where <code>C</code> is a class type and <code>T</code> is a type template parameter:<pre>template &lt;typename T&gt;
struct wrapper
{
   T data;
};
template&lt;typename T&gt;
void process11(wrapper&lt;T&gt;) { std::cout &lt;&lt; "C&lt;T&gt;\n"; }
int main()
{
   wrapper&lt;double&gt; wd{ 42.0 };
   process11(wd); // C&lt;T&gt;
}</pre></li>
				<li>A template <a id="_idIndexMarker303"/>with an argument list <a id="_idIndexMarker304"/>that contains at least one non-type template argument; the general form is <code>C&lt;i&gt;</code>, where <code>C</code> is a class type and <code>i</code> a non-type template argument:<pre>template &lt;size_t i&gt;
struct int_array
{
   int data[i];
};
template&lt;size_t i&gt;
void process12(int_array&lt;i&gt;) { std::cout &lt;&lt; "C&lt;i&gt;\n"; }
int main()
{
   int_array&lt;5&gt; ia{};
   process12(ia); // C&lt;i&gt;
}</pre></li>
				<li>A template template argument with an argument list that contains at least one type <a id="_idIndexMarker305"/>template parameter; the general <a id="_idIndexMarker306"/>form is <code>TT&lt;T&gt;</code>, where <code>TT</code> is a template template parameter and <code>T</code> is a type template:<pre>template&lt;template&lt;typename&gt; class TT, typename T&gt;
void process13(TT&lt;T&gt;) { std::cout &lt;&lt; "TT&lt;T&gt;\n"; }
int main()
{
   wrapper&lt;double&gt; wd{ 42.0 };
   process13(wd);    // TT&lt;U&gt;
}</pre></li>
				<li>A template template argument with an argument list that contains at least one non-type template argument; the general form is <code>TT&lt;i&gt;</code>, where <code>TT</code> is a template template parameter and <code>i</code> is a non-type template argument:<pre>template&lt;template&lt;size_t&gt; typename TT, size_t i&gt;
void process14(TT&lt;i&gt;) { std::cout &lt;&lt; "TT&lt;i&gt;\n"; }
int main()
{
   int_array&lt;5&gt; ia{};
   process14(ia);    // TT&lt;i&gt;
}</pre></li>
				<li>A template template argument with an argument list that has no template arguments dependent on a template parameter; this has the form <code>TT&lt;C&gt;</code>, where <code>TT</code> is the template template parameter and <code>C</code> is a class type:<pre>template&lt;template&lt;typename&gt; typename TT&gt;
void process15(TT&lt;account_t&gt;) { std::cout &lt;&lt; "TT&lt;C&gt;\n"; }
int main()
{
   wrapper&lt;account_t&gt; wa{ {42} };
   process15(wa);    // TT&lt;C&gt;
}</pre></li>
			</ul>
			<p>Although the compiler is able to deduce many types of template parameters, as previously seen, there are also limitations to what it can do. These are exemplified in the following list:</p>
			<ul>
				<li>The compiler cannot deduce the type of a type template argument, from the type of a non-type template argument. In the following example, <code>process</code> is a function <a id="_idIndexMarker307"/>template with two template <a id="_idIndexMarker308"/>parameters: a type template called <code>T</code>, and a non-type template <code>i</code> of the type <code>T</code>. Calling the function with an array of five doubles does not allow the compiler to determine the type of <code>T</code>, even though this is the type of the value specifying the size of the array:<pre>template &lt;typename T, T i&gt;
void process(double arr[i])
{
   using index_type = T;
   std::cout &lt;&lt; "processing " &lt;&lt; i 
             &lt;&lt; " doubles" &lt;&lt; '\n';
          
std::cout &lt;&lt; "index type is " 
          &lt;&lt; typeid(T).name() &lt;&lt; '\n';
}
int main()
{
   double arr[5]{};
   process(arr);         // error
   process&lt;int, 5&gt;(arr); // OK
}</pre></li>
				<li>The compiler is not able to determine the type of a template argument from the type of a default value. This is exemplified ahead in the code with the function template <code>process</code>, which has a single type template parameter, but two function parameters, both of type <code>T</code> and both with default values.</li>
			</ul>
			<p>The <code>process()</code> call (without any arguments) fails because the compiler cannot deduce the type of the type template parameter <code>T</code> from the default values of the function parameters. The <code>process&lt;int&gt;()</code> call is OK because the template argument is explicitly provided. The <code>process(6)</code> call is also OK, because <a id="_idIndexMarker309"/>the type of the first function <a id="_idIndexMarker310"/>parameter can be deduced from the supplied argument, and, therefore, the type template argument can also be deduced:</p>
			<pre>template &lt;typename T&gt;
void process(T a = 0, T b = 42)
{
   std::cout &lt;&lt; a &lt;&lt; "," &lt;&lt; b &lt;&lt; '\n';
}
int main()
{
   process();        // [1] error
   process&lt;int&gt;();   // [2] OK
   process(10);      // [3] OK
}</pre>
			<ul>
				<li>Although the compiler can deduce function template arguments from pointer to functions or pointer to member functions, as we have seen earlier, there are a couple of restrictions to this capability: it cannot deduce arguments from pointers to function templates, nor from a pointer to a function that has an overloaded set with more than one overloaded function matching the required type.</li>
			</ul>
			<p>In the code ahead, the function template <code>invoke</code> takes a pointer to a function that has two arguments, the first of the type template parameter <code>T</code>, and the second <a id="_idIndexMarker311"/>an <code>int</code>, and returns <code>void</code>. This function <a id="_idIndexMarker312"/>template cannot be passed a pointer to <code>alpha</code> (see <code>[1]</code>) because this is a function template, nor to <code>beta</code> (see <code>[2]</code>), because this has more than one overload that can match the type <code>T</code>. However, it is possible to call it with a pointer to <code>gamma</code> (see <code>[3]</code>), and it will correctly deduce the type of the second overload:</p>
			<pre>template &lt;typename T&gt;
void invoke(void(*pfun)(T, int))
{
   pfun(T{}, 42);
}
template &lt;typename T&gt;
void alpha(T, int)
{ std::cout &lt;&lt; "alpha(T,int)" &lt;&lt; '\n'; }
void beta(int, int)
{ std::cout &lt;&lt; "beta(int,int)" &lt;&lt; '\n'; }
void beta(short, int)
{ std::cout &lt;&lt; "beta(short,int)" &lt;&lt; '\n'; }
void gamma(short, int, long long)
{ std::cout &lt;&lt; "gamma(short,int,long long)" &lt;&lt; '\n'; }
void gamma(double, int) 
{ std::cout &lt;&lt; "gamma(double,int)" &lt;&lt; '\n'; }
int main()
{
   invoke(&amp;alpha);  // [1] error
   invoke(&amp;beta);   // [2] error
   invoke(&amp;gamma);  // [3] OK
}</pre>
			<ul>
				<li>Another <a id="_idIndexMarker313"/>limitation of the compiler is <a id="_idIndexMarker314"/>the argument deduction of the primary dimension of an array. The reason is this is not part of function parameter types. The exceptions to this limitation are the cases when the dimension refers to a reference or pointer type. The following code snippet demonstrates these restrictions:<ul><li>The call to <code>process1()</code> at <code>[1]</code> generates an error because the compiler is not able to deduce the value of the non-type template argument <code>Size</code>, since this refers to the primary dimension of an array. </li><li>The call <a id="_idIndexMarker315"/>to <code>process2()</code> at the <a id="_idIndexMarker316"/>point marked with <code>[2]</code> is correct because the non-type template parameter <code>Size</code> refers to the second dimension of an array. </li><li>On the other hand, the calls to <code>process3()</code> (at <code>[3]</code>) and <code>process4()</code> (at <code>[4]</code>) are both successful, since the function argument is either a reference or a pointer to a single-dimensional array:<pre>template &lt;size_t Size&gt;
void process1(int a[Size])
{ std::cout &lt;&lt; "process(int[Size])" &lt;&lt; '\n'; };
template &lt;size_t Size&gt;
void process2(int a[5][Size])
{ std::cout &lt;&lt; "process(int[5][Size])" &lt;&lt; '\n'; };
template &lt;size_t Size&gt;
void process3(int(&amp;a)[Size])
{ std::cout &lt;&lt; "process(int[Size]&amp;)" &lt;&lt; '\n'; };
template &lt;size_t Size&gt;
void process4(int(*a)[Size])
{ std::cout &lt;&lt; "process(int[Size]*)" &lt;&lt; '\n'; };
int main()
{
   int arr1[10];
   int arr2[5][10];
   process1(arr1);   // [1] error
   process2(arr2);   // [2] OK
   process3(arr1);   // [3] OK
   process4(&amp;arr1);  // [4] OK
}</pre></li></ul></li>
				<li>If a non-type template argument is used in an expression in the function template parameter list, then the compiler cannot deduce its value. </li>
			</ul>
			<p>In the following snippet, <code>ncube</code> is a class template with a non-type template parameter <code>N</code> representing a number of dimensions. The function template <code>process</code> also has a non-type template parameter <code>N</code>, but this is used in an expression <a id="_idIndexMarker317"/>in the template parameter <a id="_idIndexMarker318"/>list of the type of its single parameter. As a result, the compiler cannot deduce the value of <code>N</code> from the type of the function argument (as seen at <code>[1]</code>) and this must be specified explicitly (as seen at <code>[2]</code>):</p>
			<pre>template &lt;size_t N&gt;
struct ncube 
{
   static constexpr size_t dimensions = N;
};
template &lt;size_t N&gt;
void process(ncube&lt;N - 1&gt; cube)
{
   std::cout &lt;&lt; cube.dimensions &lt;&lt; '\n';
}
int main()
{
   ncube&lt;5&gt; cube;
   process(cube);    // [1] error
   process&lt;6&gt;(cube); // [2] OK
}</pre>
			<p>All the rules for template argument deduction discussed in this section also apply to variadic <a id="_idIndexMarker319"/>function templates. However, everything <a id="_idIndexMarker320"/>that was discussed was in the context of function templates. Template argument deduction works for class templates too and we will explore this topic in the next section.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor072"/>Class template argument deduction</h1>
			<p>Before <strong class="bold">C++17</strong>, template argument deduction only worked for functions but not classes. This meant that when <a id="_idIndexMarker321"/>a class template had to be <a id="_idIndexMarker322"/>instantiated, all the template arguments had to be supplied. The following snippet shows several examples:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T data;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">std::pair&lt;int, double&gt; p{ 42, 42.0 };</pre>
			<pre class="source-code">std::vector&lt;int&gt;       v{ 1,2,3,4,5 };</pre>
			<pre class="source-code">wrapper&lt;int&gt;           w{ 42 };</pre>
			<p>By leveraging template argument deduction for function templates, some standard types feature helper functions that create an instance of the type without the need to explicitly specify template arguments. Such examples are <code>std::make_pair</code> for <code>std::pair</code> and <code>std::make_unique</code> for <code>std::unique_ptr</code>. These helper function templates, used in corroboration with the <code>auto</code> keyword, avoid the need for specifying template arguments for class templates. Here is an example:</p>
			<pre class="source-code">auto p = std::make_pair(42, 42.0);</pre>
			<p>Although not all standard class templates have such a helper function for creating instances, it’s not <a id="_idIndexMarker323"/>hard to write your own. In the <a id="_idIndexMarker324"/>following snippet, we can see a <code>make_vector</code> function template used to create a <code>std::vector&lt;T&gt;</code> instance, and a <code>make_wrapper</code> function template to create a <code>wrapper&lt;T&gt;</code> instance:</p>
			<pre class="source-code">template &lt;typename T, typename... Ts, </pre>
			<pre class="source-code">          typename Allocator = std::allocator&lt;T&gt;&gt;</pre>
			<pre class="source-code">auto make_vector(T&amp;&amp; first, Ts&amp;&amp;... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return std::vector&lt;std::decay_t&lt;T&gt;, Allocator&gt; {</pre>
			<pre class="source-code">      std::forward&lt;T&gt;(first),</pre>
			<pre class="source-code">      std::forward&lt;Ts&gt;(args)... </pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">constexpr wrapper&lt;T&gt; make_wrapper(T&amp;&amp; data)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return wrapper{ data };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">auto v = make_vector(1, 2, 3, 4, 5);</pre>
			<pre class="source-code">auto w = make_wrapper(42);</pre>
			<p>The C++17 standard has simplified the use of class templates by providing template argument deduction for them. Therefore, as of C++17, the first snippet shown in this section can be simplified as follows:</p>
			<pre class="source-code">std::pair   p{ 42, 42.0 };   // std::pair&lt;int, double&gt;</pre>
			<pre class="source-code">std::vector v{ 1,2,3,4,5 };  // std::vector&lt;int&gt;</pre>
			<pre class="source-code">wrapper     w{ 42 };         // wrapper&lt;int&gt;</pre>
			<p>This is possible because the compiler is able to deduce the template arguments from the type of the <a id="_idIndexMarker325"/>initializers. In this example, the compiler <a id="_idIndexMarker326"/>deduced it from the initializing expression of the variables. But the compiler is also able to deduce template arguments from <code>new</code> expressions and function-style cast expressions. These are exemplified next:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct point_t</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   point_t(T vx, T vy) : x(vx), y(vy) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T x;</pre>
			<pre class="source-code">   T y;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">auto p = new point_t(1, 2);   // [1] point&lt;int&gt;</pre>
			<pre class="source-code">                              // new expression</pre>
			<pre class="source-code">std::mutex mt;</pre>
			<pre class="source-code">auto l = std::lock_guard(mt); // [2] </pre>
			<pre class="source-code">// std::lock_guard&lt;std::mutex&gt;</pre>
			<pre class="source-code">// function-style cast expression</pre>
			<p>The way template argument deduction works for class templates is different than for function templates but it relies on the latter. When encountering the name of a class template in a variable declaration or function-style cast, the compiler proceeds to build a set of so-called <strong class="bold">deduction guides</strong>.</p>
			<p>There are fictional function templates representing constructor signatures of a <em class="italic">fictional class type</em>. Users can also provide deduction guides and these are added to the list of compiler-generated <a id="_idIndexMarker327"/>guides. If overload resolution fails on the <a id="_idIndexMarker328"/>constructed set of fictional function templates (the return type is not part of the matching process since these functions represent constructors), then the program is ill-formed and an error is generated. Otherwise, the return type of the selected function template specialization becomes the deduced class template specialization.</p>
			<p>To understand this better, let’s see how the deduction guides actually look. In the following snippet, you can see some of the guides generated by the compiler for the <code>std::pair</code> class. The actual list is longer and, for brevity, only some are presented here:</p>
			<pre class="source-code">template &lt;typename T1, typename T2&gt;</pre>
			<pre class="source-code">std::pair&lt;T1, T2&gt; F();</pre>
			<pre class="source-code">template &lt;typename T1, typename T2&gt;</pre>
			<pre class="source-code">std::pair&lt;T1, T2&gt; F(T1 const&amp; x, T2 const&amp; y);</pre>
			<pre class="source-code">template &lt;typename T1, typename T2, typename U1, </pre>
			<pre class="source-code">          typename U2&gt;</pre>
			<pre class="source-code">std::pair&lt;T1, T2&gt; F(U1&amp;&amp; x, U2&amp;&amp; y);</pre>
			<p>This set of implicitly deduced guides is generated from the constructors of the class template. This includes the default constructor, the copy constructor, the move constructor, and <a id="_idIndexMarker329"/>all the conversion constructors, with the <a id="_idIndexMarker330"/>arguments copied in the exact order. If the constructor is explicit, then so is the deduction guide. However, if the class template does not have any user-defined constructor, a deduction guide is created for a hypothetical default constructor. A deduction guide for a hypothetical copy constructor is always created.</p>
			<p>User-defined deduction guides can be provided in the source code. The syntax is similar to that of functions with <a id="_idIndexMarker331"/>a trailing return type but without the <code>auto</code> keyword. Deduction guides can be either functions or function templates. What is important to keep in mind is that these must be provided in the same namespace as the class template they apply to. Therefore, if we were to add a user-defined deduction guide for the <code>std::pair</code> class, it must be done in the <code>std</code> namespace. An example is shown here:</p>
			<pre class="source-code">namespace std</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T1, typename T2&gt;</pre>
			<pre class="source-code">   pair(T1&amp;&amp; v1, T2&amp;&amp; v2) -&gt; pair&lt;T1, T2&gt;;</pre>
			<pre class="source-code">}</pre>
			<p>The deduction guides shown so far were all function templates. But as mentioned earlier, they don’t have to be function templates. They can be regular functions too. To demonstrate this, let’s consider the following example:</p>
			<pre class="source-code">std::pair  p1{1, "one"};    // std::pair&lt;int, const char*&gt;</pre>
			<pre class="source-code">std::pair  p2{"two", 2};    // std::pair&lt;const char*, int&gt;</pre>
			<pre class="source-code">std::pair  p3{"3", "three"};</pre>
			<pre class="source-code">                    // std::pair&lt;const char*, const char*&gt;</pre>
			<p>With the compiler-degenerated deduction guides for the <code>std::pair</code> class, the deduced types are <code>std::pair&lt;int, const char*&gt;</code> for <code>p1</code>, <code>std::pair&lt;const char*, int&gt;</code> for <code>p2</code>, and <code>std::pair&lt;const char*, const char*&gt;</code> for <code>p3</code>. In other words, the type deduced by the compiler where literal strings are used is <code>const char*</code> (as one should expect). We could tell the compiler to deduce <code>std::string</code> instead of <code>const char*</code> by providing several user-defined deduction guides. These are shown in the following listing:</p>
			<pre class="source-code">namespace std</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   pair(T&amp;&amp;, char const*) -&gt; pair&lt;T, std::string&gt;;</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   pair(char const*, T&amp;&amp;) -&gt; pair&lt;std::string, T&gt;;</pre>
			<pre class="source-code">   pair(char const*, char const*) -&gt; </pre>
			<pre class="source-code">      pair&lt;std::string, std::string&gt;;</pre>
			<pre class="source-code">}</pre>
			<p>Notice that the first two are function templates, but the third one is a regular function. Having these guides available, the deduced types for <code>p1</code>, <code>p2</code>, and <code>p3</code> from the previous example are <code>std::pair&lt;int, std::string&gt;</code>, <code>std::pair&lt;std::string, int&gt;</code> and <code>std::pair&lt;std::string, std::string&gt;</code> respectively.</p>
			<p>Let’s look at one <a id="_idIndexMarker332"/>more example for user-defined guides, this <a id="_idIndexMarker333"/>time for a user-defined class. Let’s consider the following class template that models a range:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct range_t</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename Iter&gt;</pre>
			<pre class="source-code">   range_t(Iter first, Iter last)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::copy(first, last, std::back_inserter(data));</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::vector&lt;T&gt; data;</pre>
			<pre class="source-code">};</pre>
			<p>There is not much to this implementation but, in fact, it is enough for our purpose. Let’s consider you want to construct a range object from an array of integers:</p>
			<pre class="source-code">int arr[] = { 1,2,3,4,5 };</pre>
			<pre class="source-code">range_t r(std::begin(arr), std::end(arr));</pre>
			<p>Running this code will generate an error. Different compilers would generate different error <a id="_idIndexMarker334"/>messages. Perhaps Clang provides the error <a id="_idIndexMarker335"/>messages that best describe the problem:</p>
			<pre>error: no viable constructor or deduction guide for deduction of template arguments of 'range_t'
   range_t r(std::begin(arr), std::end(arr));
           ^
note: candidate template ignored: couldn't infer template argument 'T'
      range_t(Iter first, Iter last)
      ^
note: candidate function template not viable: requires 1 argument, but 2 were provided
   struct range_t</pre>
			<p>Nevertheless, regardless of what the actual error message is, the meaning is the same: template argument deduction for <code>range_t</code> failed. In order to make deduction work, a user-defined deduction guide needs to be provided and it needs to look as follows:</p>
			<pre class="source-code">template &lt;typename Iter&gt;</pre>
			<pre class="source-code">range_t(Iter first, Iter last) -&gt; </pre>
			<pre class="source-code">   range_t&lt;</pre>
			<pre class="source-code">      typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;</pre>
			<p>What this deduction guide is instructing is that when a call to the constructor with two iterator <a id="_idIndexMarker336"/>arguments is encountered, the value of the <a id="_idIndexMarker337"/>template parameter <code>T</code> should be deduced to be the value type of the iterator traits. Iterator traits is a topic that will be addressed in <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>. However, with this available, the previous snippet runs without problems and the compiler deduces the type of the <code>r</code> variable to be <code>range_t&lt;int&gt;</code>, as intended.</p>
			<p>At the beginning of this section, the following example was provided, where the type of <code>w</code> was said to be deduced as <code>wrapper&lt;int&gt;</code>:</p>
			<pre class="source-code">wrapper w{ 42 }; // wrapper&lt;int&gt;</pre>
			<p>In C++17, this is not actually true without a user-defined deduction guide. The reason is that <code>wrapper&lt;T&gt;</code> is an aggregate type and class template argument deduction does not work from aggregate initialization in C++17. Therefore, to make the preceding line of code work, a deduction guide as follows needs to be provided:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">wrapper(T) -&gt; wrapper&lt;T&gt;;</pre>
			<p>Fortunately, the need for such a user-defined deduction guide was removed in C++20. This version of the standard provides support for aggregate types (as long as any dependent base class has no virtual functions or virtual base classes and the variable is initialized from a non-empty list of initializers).</p>
			<p>Class template argument deduction only works <em class="italic">if no template arguments are provided</em>. As a consequence, the following declarations of <code>p1</code> and <code>p2</code> are both valid and class template argument deduction occurs; for <code>p2</code>, the deduced type is <code>std::pair&lt;int, std::string&gt;</code> (assuming the previously user-defined guides are available). However, the declarations of <code>p3</code> and <code>p4</code> produce an error because class template argument deduction does not occur, since a template argument list is present (<code>&lt;&gt;</code> and <code>&lt;int&gt;</code>) but does not contain all required arguments:</p>
			<pre class="source-code">std::pair&lt;int, std::string&gt; p1{ 1, "one" };  // OK</pre>
			<pre class="source-code">std::pair p2{ 2, "two" };                    // OK</pre>
			<pre class="source-code">std::pair&lt;&gt; p3{ 3, "three" };                // error</pre>
			<pre class="source-code">std::pair&lt;int&gt; p4{ 4, "four" };              // error</pre>
			<p>Class template <a id="_idIndexMarker338"/>argument deduction may not always produce <a id="_idIndexMarker339"/>the expected results. Let’s consider the following example:</p>
			<pre class="source-code">std::vector v1{ 42 };</pre>
			<pre class="source-code">std::vector v2{ v1, v1 };</pre>
			<pre class="source-code">std::vector v3{ v1 };</pre>
			<p>The deduced type for <code>v1</code> is <code>std::vector&lt;int&gt;</code> and the deduced type for <code>v2</code> is <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>. However, what should the compiler deduce for the type of <code>v3</code>? There are two options: <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code> and <code>std::vector&lt;int&gt;</code>. If your expectation is the former, you will be disappointed to learn that the compiler actually deduces the latter. This is because deduction depends on both <em class="italic">the number of arguments and their type</em>.</p>
			<p>When the number of arguments is greater than one, it will use the constructor that takes an initializer list. For the <code>v2</code> variable, that is <code>std::initializer_list&lt;std::vector&lt;int&gt;&gt;</code>. When the number of arguments is one, then the type of the arguments is considered. If the type of the argument is a (specialization of) <code>std::vector</code> – considering this explicit case – then the copy-constructor is used and the deduced type is the declared type of the argument. This is the case of variable <code>v3</code>, where the deduced type is <code>std::vector&lt;int&gt;</code>. Otherwise, the constructor that takes an initializer list (with a single element) is used, as in the case of variable <code>v1</code>, for which the deduced <a id="_idIndexMarker340"/>type is <code>std::vector&lt;int&gt;</code>. These could be better visualized with the help of the cppinsights.io tool, which shows the following generated code (for the previous snippet). Notice that the allocator argument has been removed for brevity:</p>
			<pre class="source-code">std::vector&lt;int&gt; v1 = </pre>
			<pre class="source-code">   std::vector&lt;int&gt;{std::initializer_list&lt;int&gt;{42}};</pre>
			<pre class="source-code">std::vector&lt;vector&lt;int&gt;&gt; v2 = </pre>
			<pre class="source-code">   std::vector&lt;vector&lt;int&gt;&gt;{</pre>
			<pre class="source-code">      std::initializer_list&lt;std::vector&lt;int&gt;&gt;{</pre>
			<pre class="source-code">         std::vector&lt;int&gt;(v1), </pre>
			<pre class="source-code">         std::vector&lt;int&gt;(v1)</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">std::vector&lt;int&gt; v3 = std::vector&lt;int&gt;{v1};</pre>
			<p>Class template argument deduction is a useful feature of C++17 with improvements for aggregate types in C++20. It helps avoid writing unnecessary explicit template arguments <a id="_idIndexMarker341"/>when the compiler is able to deduce <a id="_idIndexMarker342"/>them, even though, in some cases, the compiler may require user-defined deduction guides for the deduction to work. It also avoids the need for creating factory functions, such as <code>std::make_pair</code> or <code>std::make_tuple</code>, that were a workaround for benefiting from template argument deduction before it was available for class templates.</p>
			<p>There is more to template argument deduction than what we have discussed so far. There is a special case of function template argument deduction known as forwarding references. This will be addressed next.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor073"/>Forwarding references</h1>
			<p>One of the most <a id="_idIndexMarker343"/>important features that were added to the language in <a id="_idIndexMarker344"/>C++11 is <strong class="bold">move semantics</strong>, which helps improve performance by avoiding making unnecessary copies. Move semantics are supported by <a id="_idIndexMarker345"/>another C++11 feature called <strong class="bold">rvalue references</strong>. Before discussing these, it is worth mentioning that, in C++, we have two kinds of values:</p>
			<ul>
				<li><code>&amp;</code> operator. lvalues can appear both on the left and right sides of an assignment expression.</li>
				<li><code>&amp;</code> operator. rvalues are literals and temporary objects and can only appear on the right side of an assignment expression.<p class="callout-heading">Note</p><p class="callout">In C++11, there are a few other value categories, glvalue, prvalue, and xvalue. Discussing them here would <a id="_idIndexMarker348"/>not benefit the current topic. However, you can read more about them at <a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a>.</p></li>
			</ul>
			<p>References are aliases to already existing objects or functions. Just as we have two kinds of values, in C++11 we have two kinds of references:</p>
			<ul>
				<li><code>&amp;</code>, such as in <code>&amp;x</code>, are references to lvalues.</li>
				<li><code>&amp;&amp;</code>, such as in <code>&amp;&amp;x</code>, are references to rvalues.</li>
			</ul>
			<p>Let’s look at some <a id="_idIndexMarker351"/>examples to understand these concepts better:</p>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int data;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void f(foo&amp; v)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; "f(foo&amp;)\n"; }</pre>
			<pre class="source-code">void g(foo&amp; v)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; "g(foo&amp;)\n"; }</pre>
			<pre class="source-code">void g(foo&amp;&amp; v)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; "g(foo&amp;&amp;)\n"; }</pre>
			<pre class="source-code">void h(foo&amp;&amp; v)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; "h(foo&amp;&amp;)\n"; }</pre>
			<pre class="source-code">foo x = { 42 };   //  x is lvalue</pre>
			<pre class="source-code">foo&amp; rx = x;      // rx is lvalue</pre>
			<p>We have three functions here: <code>f</code>, which takes an lvalue reference (that is, <code>int&amp;</code>); <code>g</code>, which has two overloads, one for an lvalue reference, and one for an rvalue reference (that is, <code>int&amp;&amp;</code>); and <code>h</code>, which takes an rvalue reference. We also have two variables, <code>x</code> and <code>rx</code>. Here, <code>x</code> is an lvalue, whose type is <code>foo</code>. We can take its address with <code>&amp;x</code>. An lvalue is also <code>rx</code>, which is an lvalue reference, whose type is <code>foo&amp;</code>. Now, let’s see how we can call each of the <code>f</code>, <code>g</code>, and <code>h</code> functions:</p>
			<pre class="source-code">f(x);       // f(foo&amp;)</pre>
			<pre class="source-code">f(rx);      // f(foo&amp;)</pre>
			<pre class="source-code">f(foo{42}); // error: a non-const reference</pre>
			<pre class="source-code">            // may only be bound to an lvalue</pre>
			<p>Because <code>x</code> and <code>rx</code> are both lvalues, passing them to <code>f</code> is OK since this function takes an lvalue reference. However, <code>foo{42}</code> is a temporary object, as it does not exist outside the context of the <a id="_idIndexMarker352"/>call to <code>f</code>. That means, it is an rvalue, and passing it to <code>f</code> will result in a compiler error, because the parameter of the function is of the type <code>foo&amp;</code> and non-constant references may only be bound to lvalues. This would work if the signature of the function <code>f</code> was changed to <code>f(int const &amp;v)</code>. Next, let’s discuss the <code>g</code> function:</p>
			<pre class="source-code">g(x);             // g(foo&amp;)</pre>
			<pre class="source-code">g(rx);            // g(foo&amp;)</pre>
			<pre class="source-code">g(foo{ 42 });     // g(foo&amp;&amp;)</pre>
			<p>In the preceding snippet, calling <code>g</code> with either <code>x</code> or <code>rx</code> will resolve to the first overload, which takes an lvalue reference. However, calling it with <code>foo{42}</code>, which is a temporary object, therefore an rvalue, will resolve to the second overload, which takes an rvalue reference. Let’s see what happens when we want to make the same calls to the <code>h</code> function:</p>
			<pre class="source-code">h(x);      // error, cannot bind an lvalue to an rvalue ref</pre>
			<pre class="source-code">h(rx);           // error</pre>
			<pre class="source-code">h(foo{ 42 });    // h(foo&amp;&amp;)</pre>
			<pre class="source-code">h(std::move(x)); // h(foo&amp;&amp;)</pre>
			<p>This function takes an rvalue reference. The attempts to pass either <code>x</code> or <code>rx</code> to it result in compiler errors because lvalues cannot be bound to rvalue references. The expression <code>foo{42}</code>, being an rvalue, can be passed as an argument. We can also pass the lvalue <code>x</code> to the function <code>h</code> if we change its semantic from an lvalue to an rvalue. That is done with the help of <code>std::move</code>. This function does not really move anything; it only makes a sort of a cast from an lvalue to an rvalue.</p>
			<p>However, it is important to understand that passing rvalues to a function has two purposes: either the object is temporary and does not exist outside the call and the function can do anything <a id="_idIndexMarker353"/>with it, or the function is supposed to take ownership of the object that is received. This is the purpose of the move constructor and the move assignment operator and it’s rare that you will see other functions taking rvalue references. In our last example, within the function <code>h</code>, the parameter <code>v</code> is an lvalue but it is bound to an rvalue. The variable <code>x</code> existed outside the call to <code>h</code> but passing it to <code>std::move</code> transformed it into an rvalue. It still exists as an lvalue after the call to <code>h</code> returns but you should assume the function <code>h</code> did something with it and its state can be anything. </p>
			<p>One purpose of rvalue references is, therefore, to enable move semantics. But it has yet another one and that is to enable <code>g</code> and <code>h</code>:</p>
			<pre class="source-code">void g(foo&amp; v)  { std::cout &lt;&lt; "g(foo&amp;)\n"; }</pre>
			<pre class="source-code">void g(foo&amp;&amp; v) { std::cout &lt;&lt; "g(foo&amp;&amp;)\n"; }</pre>
			<pre class="source-code">void h(foo&amp; v)  { g(v); }</pre>
			<pre class="source-code">void h(foo&amp;&amp; v) { g(v); }</pre>
			<p>In this snippet, the implementation of <code>g</code> is identical to the one seen earlier. However, <code>h</code> also has two overloads, one that takes an lvalue reference and calls <code>g</code> and another one that takes an rvalue reference and also calls <code>g</code>. In other words, the function <code>h</code> is just forwarding the argument to <code>g</code>. Now, let’s consider the following calls:</p>
			<pre class="source-code">foo x{ 42 };</pre>
			<pre class="source-code">h(x);          // g(foo&amp;)</pre>
			<pre class="source-code">h(foo{ 42 });  // g(foo&amp;)</pre>
			<p>From this, you would expect that the call <code>h(x)</code> will result in a call to the <code>g</code> overload taking an lvalue reference and the call to <code>h(foo{42})</code> will result in a call to the <code>g</code> overload taking an rvalue reference. However, in fact, both of them will call the first overload of <code>g</code>, therefore printing <code>g(foo&amp;)</code> to the console. The explanation is actually simple once you understand <a id="_idIndexMarker354"/>how references work: in the context <code>h(foo&amp;&amp; v)</code>, the parameter <code>v</code> is actually an lvalue (it has a name and you can take its address) so calling <code>g</code> with it invokes the overload that takes an lvalue reference. To make it work as intended, we need to change the implementation of the <code>h</code> functions as follows:</p>
			<pre class="source-code">void h(foo&amp; v)  { g(std::forward&lt;foo&amp;&gt;(v)); }</pre>
			<pre class="source-code">void h(foo&amp;&amp; v) { g(std::forward&lt;foo&amp;&amp;&gt;(v)); }</pre>
			<p>The <code>std::forward</code> is a function that enables the correct forwarding of values. What the function does is as follows:</p>
			<ul>
				<li>If the argument is an lvalue reference, then the function behaves just as a call to <code>std::move</code> (changing the semantics from an lvalue to an rvalue).</li>
				<li>If the argument is an rvalue reference, then it does nothing.</li>
			</ul>
			<p>Everything that we discussed so far is unrelated to templates, which are the subject of this book. However, function templates can also be used to take lvalue and rvalue references and it’s important to understand first how these work in non-templates scenarios. This is because, in templates, rvalue references work slightly differently, and sometimes they are rvalue references, but other times they are actually lvalue references.</p>
			<p>References that exhibit this behavior are called <strong class="bold">forwarding references</strong>. However, they are often referred to as <strong class="bold">universal references</strong>. This was a term coined by Scott Meyers shortly <a id="_idIndexMarker355"/>after C++11 when there was no term in the standard for this type of reference. In order to <a id="_idIndexMarker356"/>address this shortcoming, and because it didn’t feel the term universal references properly described their semantics, the C++ standard committee called these forwarding references in C++14. Yet, both terms are equally present in literature. For the sake of being true to the standard terminology, we’ll call them forwarding references in this book.</p>
			<p>To begin the discussion on forwarding references, let’s consider the following overloaded function templates and class templates:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void f(T&amp;&amp; arg)               // forwarding reference</pre>
			<pre class="source-code">{ std::cout &lt;&lt; "f(T&amp;&amp;)\n"; }</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void f(T const&amp;&amp; arg)         // rvalue reference</pre>
			<pre class="source-code">{ std::cout &lt;&lt; "f(T const&amp;&amp;)\n"; }</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void f(std::vector&lt;T&gt;&amp;&amp; arg)  // rvalue reference</pre>
			<pre class="source-code">{ std::cout &lt;&lt; "f(vector&lt;T&gt;&amp;&amp;)\n"; }</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct S</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void f(T&amp;&amp; arg)            // rvalue reference</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "S.f(T&amp;&amp;)\n"; }</pre>
			<pre class="source-code">};</pre>
			<p>We can <a id="_idIndexMarker357"/>make calls to these functions as follows:</p>
			<pre class="source-code">int x = 42;</pre>
			<pre class="source-code">f(x);                   // [1] f(T&amp;&amp;)</pre>
			<pre class="source-code">f(42);                  // [2] f(T&amp;&amp;)</pre>
			<pre class="source-code">int const cx = 100;</pre>
			<pre class="source-code">f(cx);                  // [3] f(T&amp;&amp;)</pre>
			<pre class="source-code">f(std::move(cx));       // [4] f(T const&amp;&amp;)</pre>
			<pre class="source-code">std::vector&lt;int&gt; v{ 42 };</pre>
			<pre class="source-code">f(v);                   // [5] f(T&amp;&amp;)</pre>
			<pre class="source-code">f(std::vector&lt;int&gt;{42});// [6] f(vector&lt;T&gt;&amp;&amp;)</pre>
			<pre class="source-code">S&lt;int&gt; s;</pre>
			<pre class="source-code">s.f(x);                 // [7] error</pre>
			<pre class="source-code">s.f(42);                // [8] S.f(T&amp;&amp;)</pre>
			<p>From this snippet, we can notice that:</p>
			<ul>
				<li>Calling <code>f</code> with an lvalue or rvalue at <code>[1]</code> and <code>[2]</code> resolves to the first overload, <code>f(T&amp;&amp;)</code>.</li>
				<li>Calling <code>f</code> with a constant lvalue at <code>[3]</code> also resolves to the first overload, but calling <code>f</code> with a constant rvalue at <code>[4]</code> resolves to the second overload, <code>f(T const&amp;&amp;)</code>, because it’s a better match.</li>
				<li>Calling <code>f</code> with an lvalue <code>std::vector</code> object at <code>[5]</code> resolves to the first overload, but calling <code>f</code> with an rvalue <code>std::vector</code> object at <code>[6]</code> resolves to the third overload, <code>f(vector&lt;T&gt;&amp;&amp;)</code>, because it’s a better match.</li>
				<li>Calling <code>S::f</code> with an lvalue at <code>[7]</code> is an error because lvalues cannot be bound to rvalue references, but calling it with an rvalue at <code>[8]</code> is correct.</li>
			</ul>
			<p>All the <code>f</code> function overloads in this example take an rvalue reference. However, the <code>&amp;&amp;</code> in the first overload does <a id="_idIndexMarker358"/>not necessarily mean an rvalue reference. It means <em class="italic">an rvalue reference if an rvalue was passed or an lvalue reference if an lvalue was passed</em>. Such a reference is called a <code>T&amp;&amp;</code> and nothing else. <code>T const&amp;&amp;</code> or <code>std::vector&lt;T&gt;&amp;&amp;</code> are not forwarding references, but normal rvalue references. Similarly, the <code>T&amp;&amp;</code> in the <code>f</code> function member of the class template <code>S</code> is also an rvalue reference because <code>f</code> is not a template but a non-template member function of a class template, so this rule for forwarding references does not apply.</p>
			<p>Forwarding references are a special case of function template argument deduction, a topic that we previously discussed in this chapter. Their purpose is to enable perfect forwarding with <a id="_idIndexMarker359"/>templates and they are made possible by a new C++11 feature called <strong class="bold">reference collapsing</strong>. Let’s look at this first, before showing how they solve the perfect forwarding problem.</p>
			<p>Prior to C++11, it was not possible to take a reference to a reference. However, that is now possible in C++11 for <code>typedef</code>s and templates. Here is an example:</p>
			<pre class="source-code">using lrefint = int&amp;;</pre>
			<pre class="source-code">using rrefint = int&amp;&amp;;</pre>
			<pre class="source-code">int x = 42;</pre>
			<pre class="source-code">lrefint&amp;  r1 = x; // type of r1 is int&amp;</pre>
			<pre class="source-code">lrefint&amp;&amp; r2 = x; // type of r2 is int&amp;</pre>
			<pre class="source-code">rrefint&amp;  r3 = x; // type of r3 is int&amp;</pre>
			<pre class="source-code">rrefint&amp;&amp; r4 = 1; // type of r4 is int&amp;&amp;</pre>
			<p>The rule is pretty simple: an rvalue reference to an rvalue reference collapses to an rvalue reference; all other combinations collapse to an lvalue reference. This can be put in a tabular form as follows:</p>
			<div><div><img src="img/B18367_04_Table_4.2.jpg" alt="Table 4.2&#13;&#10;" width="937" height="307"/>
				</div>
			</div>
			<p class="figure-caption">Table 4.2</p>
			<p>Any other <a id="_idIndexMarker360"/>combinations, shown in the following table, do not involve reference collapsing rules. These only apply when both types are references:</p>
			<div><div><img src="img/B18367_04_Table_4.3.jpg" alt="Table 4.3&#13;&#10;" width="937" height="365"/>
				</div>
			</div>
			<p class="figure-caption">Table 4.3</p>
			<p>Forwarding references work not only for templates but also with auto deduction rules. When <code>auto&amp;&amp;</code> is found, it means a forwarding reference. The same does not apply for anything else, such as cv-qualified forms like <code>auto const&amp;&amp;</code>. Here are some examples:</p>
			<pre class="source-code">int x = 42;</pre>
			<pre class="source-code">auto&amp;&amp; rx = x;          // [1] int&amp;</pre>
			<pre class="source-code">auto&amp;&amp; rc = 42;         // [2] int&amp;&amp;</pre>
			<pre class="source-code">auto const&amp;&amp; rcx = x;   // [3] error</pre>
			<pre class="source-code">std::vector&lt;int&gt; v{ 42 };</pre>
			<pre class="source-code">auto&amp;&amp; rv = v[0];       // [4] int&amp;</pre>
			<p>In the first two examples, <code>rx</code> and <code>rc</code> are both forwarding references and are bound to an lvalue and an rvalue respectively. However, <code>rcx</code> is an rvalue reference because <code>auto const&amp;&amp;</code> does not denote a forwarding reference. Therefore, trying to bind it to an lvalue is an error. Similarly, <code>rv</code> is a forwarding reference and is bound to an lvalue.</p>
			<p>As previously mentioned, the purpose of forwarding references is to enable perfect forwarding. We have <a id="_idIndexMarker361"/>seen the concept of perfect forwarding earlier but in a non-template context. It works, however, in a similar manner with templates. To demonstrate this, let’s redefine the function <code>h</code> as a template function. It would look as follows:</p>
			<pre class="source-code">void g(foo&amp; v)  { std::cout &lt;&lt; "g(foo&amp;)\n"; }</pre>
			<pre class="source-code">void g(foo&amp;&amp; v) { std::cout &lt;&lt; "g(foo&amp;&amp;)\n"; }</pre>
			<pre class="source-code">template &lt;typename T&gt; void h(T&amp; v)  { g(v); }</pre>
			<pre class="source-code">template &lt;typename T&gt; void h(T&amp;&amp; v) { g(v); }</pre>
			<pre class="source-code">foo x{ 42 };</pre>
			<pre class="source-code">h(x);          // g(foo&amp;)</pre>
			<pre class="source-code">h(foo{ 42 });  // g(foo&amp;)</pre>
			<p>The implementation of the <code>g</code> overloads is the same, but the <code>h</code> overloads are now function templates. However, calling <code>h</code> with an lvalue and an rvalue actually resolves to the same call to <code>g</code>, the first overload taking an lvalue. This is because in the context of the function <code>h</code>, <code>v</code> is an lvalue so passing it to <code>g</code> will call the overload taking an lvalue.</p>
			<p>The solution to this problem is the same as what we already saw before discussing templates. However, there is a difference: we no longer need two overloads, but a single one taking a forwarding reference:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void h(T&amp;&amp; v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   g(std::forward&lt;T&gt;(v));</pre>
			<pre class="source-code">}</pre>
			<p>This implementation is using <code>std::forward</code> to pass lvalues as lvalues and rvalues as rvalues. It works <a id="_idIndexMarker362"/>similarly for variadic function templates. The following is a conceptual implementation of the <code>std::make_unique</code> function that creates a <code>std::unique_ptr</code> object:</p>
			<pre class="source-code">template&lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return std::unique_ptr&lt;T&gt;(</pre>
			<pre class="source-code">           new T(std::forward&lt;Args&gt;(args)...));</pre>
			<pre class="source-code">}</pre>
			<p>To summarize this section, remember that forwarding references (also known as <strong class="bold">universal references</strong>) are basically a special deduction rule for function template arguments. They work based <a id="_idIndexMarker363"/>on the rules of reference collapsing and their purpose is to enable perfect forwarding. That is passing forward to another function a reference by preserving its valueness semantics: rvalues should be passed <a id="_idIndexMarker364"/>as rvalues and lvalues as lvalues.</p>
			<p>The next topic that we will address in this chapter is the <code>decltype</code> specifier.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor074"/>The decltype specifier</h1>
			<p>This specifier, introduced in C++11, returns the type of an expression. It is usually used in templates <a id="_idIndexMarker365"/>together with the <code>auto</code> specifier. Together, they can be used to declare the return type of a function template that depends on its template arguments, or the return type of a function that wraps another function and returns the result from executing the wrapped function.</p>
			<p>The <code>decltype</code> specifier is not restricted for use in template code. It can be used with different expressions, and it yields different results based on the expression. The rules are as follows:</p>
			<ol>
				<li>If the expression is an identifier or a class member access, then the result is the type of the entity that is named by the expression. If the entity does not exist, or it is a function that has an overload set (more than one function with the same name exists), then the compiler will generate an error.</li>
				<li>If the expression is a function call or an overloaded operator function, then the result is the return type of the function. If the overloaded operator is wrapped in parentheses, these are ignored.</li>
				<li>If the expression is an lvalue, then the result type is an lvalue reference to the type of expression.</li>
				<li>If the expression is something else, then the result type is the type of the expression.</li>
			</ol>
			<p>To understand these rules better, we’ll look at a set of examples. For these, we will consider the following functions and variables that we will use in <code>decltype</code> expressions:</p>
			<pre class="source-code">int f() { return 42; }</pre>
			<pre class="source-code">int g() { return 0; }</pre>
			<pre class="source-code">int g(int a) { return a; }</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int val;</pre>
			<pre class="source-code">   int get() const { return val; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int a = 42;</pre>
			<pre class="source-code">int&amp; ra = a;</pre>
			<pre class="source-code">const double d = 42.99;</pre>
			<pre class="source-code">long arr[10];</pre>
			<pre class="source-code">long l = 0;</pre>
			<pre class="source-code">char* p = nullptr;</pre>
			<pre class="source-code">char c = 'x';</pre>
			<pre class="source-code">wrapper w1{ 1 };</pre>
			<pre class="source-code">wrapper* w2 = new wrapper{ 2 };</pre>
			<p>The following listing shows multiple uses of the <code>decltype</code> specifier. The rule that applies in <a id="_idIndexMarker366"/>each case, as well as the deduced type, is specified on each line in a comment:</p>
			<pre class="source-code">decltype(a) e1;             // R1, int</pre>
			<pre class="source-code">decltype(ra) e2 = a;        // R1, int&amp;</pre>
			<pre class="source-code">decltype(f) e3;             // R1, int()</pre>
			<pre class="source-code">decltype(f()) e4;           // R2, int</pre>
			<pre class="source-code">decltype(g) e5;             // R1, error</pre>
			<pre class="source-code">decltype(g(1)) e6;          // R2, int</pre>
			<pre class="source-code">decltype(&amp;f) e7 = nullptr;  // R4, int(*)()</pre>
			<pre class="source-code">decltype(d) e8 = 1;         // R1, const double</pre>
			<pre class="source-code">decltype(arr) e9;           // R1, long[10]</pre>
			<pre class="source-code">decltype(arr[1]) e10 = l;   // R3, long&amp;</pre>
			<pre class="source-code">decltype(w1.val) e11;       // R1, int</pre>
			<pre class="source-code">decltype(w1.get()) e12;     // R1, int</pre>
			<pre class="source-code">decltype(w2-&gt;val) e13;      // R1, int</pre>
			<pre class="source-code">decltype(w2-&gt;get()) e14;    // R1, int</pre>
			<pre class="source-code">decltype(42) e15 = 1;       // R4, int</pre>
			<pre class="source-code">decltype(1 + 2) e16;        // R4, int</pre>
			<pre class="source-code">decltype(a + 1) e17;        // R4, int</pre>
			<pre class="source-code">decltype(a = 0) e18 = a;    // R3, int&amp;</pre>
			<pre class="source-code">decltype(p) e19 = nullptr;  // R1, char*</pre>
			<pre class="source-code">decltype(*p) e20 = c;       // R3, char&amp;</pre>
			<pre class="source-code">decltype(p[0]) e21 = c;     // R3, char&amp;</pre>
			<p>We will not elaborate on all these declarations. Most of these are relatively easy to follow based on <a id="_idIndexMarker367"/>the specified rules. A few notes, however, are worth considering for clarifying some of the deduced types:</p>
			<ul>
				<li><code>decltype(f)</code> only names a function with an overloaded set, so rule 1 applies. <code>decltype(g)</code> also names a function but it has an overloaded set. Therefore, rule 1 applies and the compiler generates an error.</li>
				<li><code>decltype(f())</code> and <code>decltype(g(1))</code> are both using function calls for the expression, so the second rule applies, and even if <code>g</code> has an overload set, the declaration is correct.</li>
				<li><code>decltype(&amp;f)</code> uses the address of the function <code>f</code>, so the fourth rule applies, yielding <code>int(*)()</code>.</li>
				<li><code>decltype(1+2)</code> and <code>decltype(a+1)</code> use the overloaded operator <code>+</code> that returns an rvalue, so the fourth rule applies. The result is <code>int</code>. However, <code>decltype(a = 1)</code> uses the assignment operator that returns an lvalue, so the third rule applies, yielding the lvalue reference <code>int&amp;</code>.</li>
			</ul>
			<p>The <code>decltype</code> specifier defines an <code>a=1</code> is used with the <code>decltype</code> specifier to declare the variable <code>e</code>, but after the declaration, the value of <code>a</code> is the one with which it was initialized:</p>
			<pre class="source-code">int a = 42;</pre>
			<pre class="source-code">decltype(a = 1) e = a;</pre>
			<pre class="source-code">std::cout &lt;&lt; a &lt;&lt; '\n';  // prints 42</pre>
			<p>There is an exception <a id="_idIndexMarker369"/>to this rule concerning template instantiation. When the expression used with the <code>decltype</code> specifier contains a template, the template is instantiated before the expression is evaluated at compile time:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T data;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">decltype(wrapper&lt;double&gt;::data) e1;  // double</pre>
			<pre class="source-code">int a = 42;</pre>
			<pre class="source-code">decltype(wrapper&lt;char&gt;::data, a) e2; // int&amp;</pre>
			<p>The type of <code>e1</code> is <code>double</code>, and <code>wrapper&lt;double&gt;</code> is instantiated for this to be deduced. On the other hand, the type of <code>e2</code> is <code>int&amp;</code> (as the variable <code>a</code> is an lvalue). However, <code>wrapper&lt;char&gt;</code> is instantiated here even if the type is only deduced from the variable <code>a</code> (due to the use of the comma operator).</p>
			<p>The preceding rules mentioned are not the only ones used for determining the type. There are several more for data member access. These are as follows:</p>
			<ul>
				<li>The <code>const</code> or <code>volatile</code> specifiers of the object used in the <code>decltype</code> expression do not contribute to the deduced type.</li>
				<li>Whether the object or pointer expression is an lvalue or an rvalue does not affect the deduced type.</li>
				<li>If the data member access expression is parenthesized, such as <code>decltype((expression))</code>, then the previous two rules do not apply. The <code>const</code> or <code>volatile</code> qualifier of the object does affect the deduced type, including the valueness of the object.</li>
			</ul>
			<p>The first two rules from this <a id="_idIndexMarker370"/>list are demonstrated with the following snippet:</p>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int          a = 0;</pre>
			<pre class="source-code">   volatile int b = 0;</pre>
			<pre class="source-code">   const int    c = 42;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">foo f;</pre>
			<pre class="source-code">foo const cf;</pre>
			<pre class="source-code">volatile foo* pf = &amp;f;</pre>
			<pre class="source-code">decltype(f.a) e1 = 0;       // int</pre>
			<pre class="source-code">decltype(f.b) e2 = 0;       // int volatile</pre>
			<pre class="source-code">decltype(f.c) e3 = 0;       // int const</pre>
			<pre class="source-code">decltype(cf.a) e4 = 0;      // int</pre>
			<pre class="source-code">decltype(cf.b) e5 = 0;      // int volatile</pre>
			<pre class="source-code">decltype(cf.c) e6 = 0;      // int const</pre>
			<pre class="source-code">decltype(pf-&gt;a) e7 = 0;     // int</pre>
			<pre class="source-code">decltype(pf-&gt;b) e8 = 0;     // int volatile</pre>
			<pre class="source-code">decltype(pf-&gt;c) e9 = 0;     // int const</pre>
			<pre class="source-code">decltype(foo{}.a) e10 = 0;  // int</pre>
			<pre class="source-code">decltype(foo{}.b) e11 = 0;  // int volatile</pre>
			<pre class="source-code">decltype(foo{}.c) e12 = 0;  // int const</pre>
			<p>The deduced type for each case is mentioned on the right side in a comment. When the expression is <a id="_idIndexMarker371"/>parenthesized, these two rules are reversed. Let’s take a look at the following snippet:</p>
			<pre class="source-code">foo f;</pre>
			<pre class="source-code">foo const cf;</pre>
			<pre class="source-code">volatile foo* pf = &amp;f;</pre>
			<pre class="source-code">int x = 1;</pre>
			<pre class="source-code">int volatile y = 2;</pre>
			<pre class="source-code">int const z = 3;</pre>
			<pre class="source-code">decltype((f.a)) e1 = x;       // int&amp;</pre>
			<pre class="source-code">decltype((f.b)) e2 = y;       // int volatile&amp;</pre>
			<pre class="source-code">decltype((f.c)) e3 = z;       // int const&amp;</pre>
			<pre class="source-code">decltype((cf.a)) e4 = x;      // int const&amp;</pre>
			<pre class="source-code">decltype((cf.b)) e5 = y;      // int const volatile&amp;</pre>
			<pre class="source-code">decltype((cf.c)) e6 = z;      // int const&amp;</pre>
			<pre class="source-code">decltype((pf-&gt;a)) e7 = x;     // int volatile&amp;</pre>
			<pre class="source-code">decltype((pf-&gt;b)) e8 = y;     // int volatile&amp;</pre>
			<pre class="source-code">decltype((pf-&gt;c)) e9 = z;     // int const volatile&amp;</pre>
			<pre class="source-code">decltype((foo{}.a)) e10 = 0;  // int&amp;&amp;</pre>
			<pre class="source-code">decltype((foo{}.b)) e11 = 0;  // int volatile&amp;&amp;</pre>
			<pre class="source-code">decltype((foo{}.c)) e12 = 0;  // int const&amp;&amp;</pre>
			<p>Here, all the expressions used with <code>decltype</code> for declaring variables <code>e1</code> to <code>e9</code> are lvalues, so the deduced type is an lvalue reference. On the other hand, the expression used to declare the variables <code>e10</code>, <code>e11</code>, and <code>e12</code> is an rvalue; therefore, the deduced type is an rvalue reference. Furthermore, <code>cf</code> is a constant object and <code>foo::a</code> has the type <code>int</code>. Therefore, the <a id="_idIndexMarker372"/>result type is <code>const int&amp;</code>. Similarly, <code>foo::b</code> has the type <code>volatile int</code>; therefore, the result type is <code>const volatile int&amp;</code>. These are just a few examples from this snippet, but the others follow the same rules for deduction.</p>
			<p>Because <code>decltype</code> is a type specifier, the redundant <code>const</code> and <code>volatile</code> qualifiers and reference specifiers are ignored. This is demonstrated with the following example:</p>
			<pre class="source-code">int a = 0;</pre>
			<pre class="source-code">int&amp; ra = a;</pre>
			<pre class="source-code">int const c = 42;</pre>
			<pre class="source-code">int volatile d = 99;</pre>
			<pre class="source-code">decltype(ra)&amp; e1 = a;          // int&amp;</pre>
			<pre class="source-code">decltype(c) const e2 = 1;      // int const</pre>
			<pre class="source-code">decltype(d) volatile e3 = 1;   // int volatile</pre>
			<p>So far in this section, we have learned how the <code>decltype</code> specifier works. However, its real purpose is to be used in templates, where the return value of a function depends on its template arguments and is not known before instantiation. To understand this scenario, let’s start with the following example of a function template that returns the minimum of two values:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T minimum(T&amp;&amp; a, T&amp;&amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>We can use this as follows:</p>
			<pre class="source-code">auto m1 = minimum(1, 5);       // OK</pre>
			<pre class="source-code">auto m2 = minimum(18.49, 9.99);// OK</pre>
			<pre class="source-code">auto m3 = minimum(1, 9.99);    </pre>
			<pre class="source-code">                     // error, arguments of different type</pre>
			<p>The first two calls are both correct, as the supplied arguments are of the same type. The third call, however, will produce a compiler error, because the arguments have different types. For this to work, we <a id="_idIndexMarker373"/>need to cast the integer value to a <code>double</code>. However, there is an alternative: we could write a function template that takes two arguments of potentially different types and returns the minimum of the two. This can look as follows:</p>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">??? minimum(T&amp;&amp; a, U&amp;&amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>The question is, what is the return type of this function? This can be implemented differently, depending on the standard version you are using.</p>
			<p>In C++11, we can use the <code>auto</code> specifier with a trailing return type, where we use the <code>decltype</code> specifier to deduce the return type from an expression. This would look as follows:</p>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">auto minimum(T&amp;&amp; a, U&amp;&amp; b) -&gt; decltype(a &lt; b ? a : b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>This syntax can be simplified if you’re using C++14 or a newer version of the standard. The trailing return type is no longer necessary. You can write the same function as follows:</p>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">decltype(auto) minimum(T&amp;&amp; a, U&amp;&amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>It is possible to <a id="_idIndexMarker374"/>simplify this further and simply use <code>auto</code> for the return type, shown as follows:</p>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">auto minimum(T&amp;&amp; a, U&amp;&amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>Although <code>decltype(auto)</code> and <code>auto</code> have the same effect in this example, this is not always the case. Let’s consider the following example where we have a function returning a reference, and another function that calls it perfectly forwarding the argument:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T const&amp; func(T const&amp; ref)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return ref;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">auto func_caller(T&amp;&amp; ref)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return func(std::forward&lt;T&gt;(ref));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int a = 42;</pre>
			<pre class="source-code">decltype(func(a))        r1 = func(a);        // int const&amp;</pre>
			<pre class="source-code">decltype(func_caller(a)) r2 = func_caller(a); // int</pre>
			<p>The function <code>func</code> returns a reference, and <code>func_caller</code> is supposed to do a perfect forwarding to this function. By using <code>auto</code> for the return type, it is inferred as <code>int</code> in the preceding <a id="_idIndexMarker375"/>snippet (see variable <code>r2</code>). In order to do a perfect forwarding of the return type, we must use <code>decltype(auto)</code> for it, as shown next:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">decltype(auto) func_caller(T&amp;&amp; ref)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return func(std::forward&lt;T&gt;(ref));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int a = 42;</pre>
			<pre class="source-code">decltype(func(a))        r1 = func(a);        // int const&amp;</pre>
			<pre class="source-code">decltype(func_caller(a)) r2 = func_caller(a); // int const&amp;</pre>
			<p>This time, the result is as intended, and the type of both <code>r1</code> and <code>r2</code> in this snippet is <code>int const&amp;</code>.</p>
			<p>As we have seen in this section, <code>decltype</code> is a type specifier used to deduce the type of an expression. It can be used in different contexts, but its purpose is for templates to determine the return <a id="_idIndexMarker376"/>type of a function and to ensure the perfect forwarding of it. Another feature that comes together with <code>decltype</code> is <code>std::declval</code>, which we will look at in the following section.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor075"/>The std::declval type operator</h1>
			<p>The <code>std::declval</code> is a utility type operation function, available in the <code>&lt;utility&gt;</code> header. It’s in the same <a id="_idIndexMarker377"/>category as functions such as <code>std::move</code> and <code>std::forward</code> that we have already seen. What it does is very simple: it adds an rvalue reference to its type template argument. The declaration of this function looks as follows:</p>
			<pre class="source-code">template&lt;class T&gt;</pre>
			<pre class="source-code">typename std::add_rvalue_reference&lt;T&gt;::type declval() noexcept;</pre>
			<p>This function has no definition and therefore it cannot be called directly. It can only be used in <code>decltype</code>, <code>sizeof</code>, <code>typeid</code>, and <code>noexcept</code>. These are compile-time-only contexts that are not evaluated during runtime. The purpose of <code>std::declval</code> is to aid with dependent type evaluation for types that do not have a default constructor or have one but it cannot be accessed because it’s private or protected.</p>
			<p>To understand how this works, let’s consider a class template that does the composition of two values of different types, and we want to create a type alias for the result of applying the plus operator to two values of these types. How could such a type alias be defined? Let’s start with the following form:</p>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">struct composition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(???);</pre>
			<pre class="source-code">};</pre>
			<p>We can use the <code>decltype</code> specifier but we need to provide an expression. We cannot say <code>decltype(T + U)</code> because these are types, not values. We could invoke the default constructor and, therefore, use the expression <code>decltype(T{} + U{})</code>. This can work fine for built-in types such as <code>int</code> and <code>double</code>, as shown in the following snippet:</p>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">  std::is_same_v&lt;double, </pre>
			<pre class="source-code">                 composition&lt;int, double&gt;::result_type&gt;);</pre>
			<p>It can also work for types that have an (accessible) default constructor. But it cannot work for types <a id="_idIndexMarker378"/>that don’t have a default constructor. The following type wrapper is such an example:</p>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper(int const v) : value(v){}</pre>
			<pre class="source-code">   int value;</pre>
			<pre class="source-code">   friend wrapper operator+(int const a, wrapper const&amp; w)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return wrapper(a + w.value);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   friend wrapper operator+(wrapper const&amp; w, int const a)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return wrapper(a + w.value);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">// error, no appropriate default constructor available</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">  std::is_same_v&lt;wrapper, </pre>
			<pre class="source-code">                 composition&lt;int,wrapper&gt;::result_type&gt;);</pre>
			<p>The solution here is to use <code>std::declval()</code>. The implementation of the class template composition would change as follows:</p>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">struct composition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(std::declval&lt;T&gt;() + </pre>
			<pre class="source-code">                                std::declval&lt;U&gt;());</pre>
			<pre class="source-code">};</pre>
			<p>With this change, both the static asserts previously shown compile without any error. This function avoids <a id="_idIndexMarker379"/>the need to use particular values to determine the type of an expression. It produces a value of a type <code>T</code> without involving a default constructor. The reason it returns an rvalue reference is to enable us to work with types that cannot be returned from a function, such as arrays and abstract types.</p>
			<p>The definition of the <code>wrapper</code> class earlier contained two friend operators. Friendship, when templates <a id="_idIndexMarker380"/>are involved, has some particularities. We will discuss this in the next section.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor076"/>Understanding friendship in templates</h1>
			<p>When you define a class, you can restrict access to its member data and member functions with the <code>protected</code> and <code>private</code> access specifiers. If a member is private, it can only be accessed <a id="_idIndexMarker381"/>within the class. If a member is protected, it can be accessed from derived classes with public or protected access. However, a class can grant access to its private or protected members to other functions or classes with the help of the <code>friend</code> keyword. These functions or classes, to which special access has <a id="_idIndexMarker382"/>been granted, are called <strong class="bold">friends</strong>. Let’s take a look at a simple example:</p>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{   </pre>
			<pre class="source-code">   wrapper(int const v) :value(v) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   int value;</pre>
			<pre class="source-code">   friend void print(wrapper const &amp; w);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void print(wrapper const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">wrapper w{ 42 };</pre>
			<pre class="source-code">print(w);</pre>
			<p>The <code>wrapper</code> class has a private data member called <code>value</code>. There is a free function called <code>print</code> that takes an argument of the type <code>wrapper</code> and prints the wrapped value to the console. However, in <a id="_idIndexMarker383"/>order to be able to access it, the function is declared a friend of the <code>wrapper</code> class.</p>
			<p>We will not focus on the way friendship works for non-templates. You should be familiar with this feature to proceed to discuss it in the context of templates. When it comes to templates, things get <a id="_idIndexMarker384"/>a bit complicated. We will look into this with the help of several examples. Let’s start with the following:</p>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper(int const v) :value(v) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   int value;</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   friend void print(wrapper const&amp;);</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   friend struct printer;</pre>
			<pre class="source-code">};   </pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void print(wrapper const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct printer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(wrapper const&amp; w)</pre>
			<pre class="source-code">   { std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">wrapper w{ 42 };</pre>
			<pre class="source-code">print&lt;int&gt;(w);</pre>
			<pre class="source-code">print&lt;char&gt;(w);</pre>
			<pre class="source-code">printer&lt;int&gt;()(w);</pre>
			<pre class="source-code">printer&lt;double&gt;()(w);</pre>
			<p>The <code>print</code> function is now a function template. It has a type template parameter, but that’s not really used anywhere. That may look a bit odd, but it’s a valid code, and we need to invoke it by specifying the template argument. However, it helps us make a point: any template instantiation of <code>print</code>, regardless of the template argument, can access the private <a id="_idIndexMarker385"/>members of the <code>wrapper</code> class. Notice the syntax used to declare it as a friend of the <code>wrapper</code> class: it uses the template syntax. The same applies to the class template <code>printer</code>. It’s declared as a friend of the <code>wrapper</code> class and any template instantiation, regardless <a id="_idIndexMarker386"/>of the template argument, can access its private parts.</p>
			<p>What if we wanted to restrict access to only some instances of these templates? Such as only the specializations for the <code>int</code> type? Then, we can declare these specializations as friends, as shown here:</p>
			<pre class="source-code">struct wrapper;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void print(wrapper const&amp; w);</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct printer;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper(int const v) :value(v) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   int value;</pre>
			<pre class="source-code">   friend void print&lt;int&gt;(wrapper const&amp;);</pre>
			<pre class="source-code">   friend struct printer&lt;int&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void print(wrapper const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; /* error */ }</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">void print&lt;int&gt;(wrapper const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct printer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(wrapper const&amp; w)</pre>
			<pre class="source-code">   { std::cout &lt;&lt; w.value &lt;&lt; '\n'; /* error*/ }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct printer&lt;int&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(wrapper const&amp; w)</pre>
			<pre class="source-code">   { std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">wrapper w{ 43 };</pre>
			<pre class="source-code">print&lt;int&gt;(w);</pre>
			<pre class="source-code">print&lt;char&gt;(w);</pre>
			<pre class="source-code">printer&lt;int&gt;()(w);</pre>
			<pre class="source-code">printer&lt;double&gt;()(w);</pre>
			<p>In this snippet, the <code>wrapper</code> class is the same as previously. For both the <code>print</code> function template <a id="_idIndexMarker387"/>and the <code>printer</code> class template, we have a primary template and a full specialization for the <code>int</code> type. Only the <code>int</code> instantiations are declared friends of the <code>wrapper</code> class. Attempting to access the private parts of the <code>wrapper</code> class in the primary templates generates compiler errors.</p>
			<p>In these examples, the class that granted friendship to its private parts was a non-template class. But <a id="_idIndexMarker388"/>class templates can also declare friends. Let’s see how it works in this case. We will start with the case of a class template and a non-template function:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper(T const v) :value(v) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   friend void print(wrapper&lt;int&gt; const&amp;);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void print(wrapper&lt;int&gt; const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">void print(wrapper&lt;char&gt; const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; /* error */ }</pre>
			<p>In this implementation, the <code>wrapper</code> class template declares the overload of print that takes a <code>wrapper&lt;int&gt;</code> as a parameter as being a friend. Therefore, in this overloaded function, we can access <a id="_idIndexMarker389"/>the private data member <code>value</code>, but not in any other <a id="_idIndexMarker390"/>overload. A similar case occurs when the friend function or class is a template and we want only one specialization to access the private parts. Let’s see the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct printer;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper(T const v) :value(v) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   friend void print&lt;int&gt;(wrapper&lt;int&gt; const&amp;);</pre>
			<pre class="source-code">   friend struct printer&lt;int&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void print(wrapper&lt;T&gt; const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; /* error */ }</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void print(wrapper&lt;int&gt; const&amp; w)</pre>
			<pre class="source-code">{ std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct printer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(wrapper&lt;T&gt; const&amp; w)</pre>
			<pre class="source-code">   { std::cout &lt;&lt; w.value &lt;&lt; '\n'; /* error */ }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct printer&lt;int&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(wrapper&lt;int&gt; const&amp; w)</pre>
			<pre class="source-code">   { std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">};</pre>
			<p>This implementation of the <code>wrapper</code> class template grants friendship to the <code>int</code> specializations of the <code>print</code> function template and <code>printer</code> class template. The attempt to access the private data member <code>value</code> in the primary templates (or any other specialization) would generate a compiler error.</p>
			<p>If the intention is that the <code>wrapper</code> class template gives friend access to any instantiation <a id="_idIndexMarker391"/>of the <code>print</code> function template or <code>printer</code> class template, then the <a id="_idIndexMarker392"/>syntax to do so is as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct printer;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper(T const v) :value(v) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   friend void print(wrapper&lt;U&gt; const&amp;);</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   friend struct printer;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void print(wrapper&lt;T&gt; const&amp; w)</pre>
			<pre class="source-code">{  std::cout &lt;&lt; w.value &lt;&lt; '\n'; }</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct printer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(wrapper&lt;T&gt; const&amp; w)</pre>
			<pre class="source-code">   {  std::cout &lt;&lt; w.value &lt;&lt; '\n';  }</pre>
			<pre class="source-code">};</pre>
			<p>Notice that in declaring the friends, the syntax is <code>template &lt;typename U&gt;</code> and not <code>template &lt;typename T&gt;</code>. The name of the template parameter, <code>U</code>, can be anything except for <code>T</code>. That would shadow the name of the template parameter of the <code>wrapper</code> class template and that is an error. Keep in mind though that with this syntax, any specialization of <code>print</code> or <code>printer</code> has access to the private members of any specialization of the <code>wrapper</code> class template. If you want that only the specializations of the friends that meet <a id="_idIndexMarker393"/>the template argument of the wrapper class have access <a id="_idIndexMarker394"/>to its private parts, then you must use the following syntax:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper(T const v) :value(v) {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   friend void print&lt;T&gt;(wrapper&lt;T&gt; const&amp;);</pre>
			<pre class="source-code">   friend struct printer&lt;T&gt;;</pre>
			<pre class="source-code">};</pre>
			<p>This is similar to what we have seen previously when access was granted only to the <code>int</code> specializations, except that now it’s for any specialization that matches <code>T</code>.</p>
			<p>Apart from these cases, it’s also possible for a class template to grant friendship to a type template parameter. This is demonstrated with the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct connection</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   connection(std::string const&amp; host, int const port) </pre>
			<pre class="source-code">      :ConnectionString(host + ":" + std::to_string(port)) </pre>
			<pre class="source-code">   {}</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::string ConnectionString;</pre>
			<pre class="source-code">   friend T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct executor</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void run()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      connection&lt;executor&gt; c("localhost", 1234);</pre>
			<pre class="source-code">      std::cout &lt;&lt; c.ConnectionString &lt;&lt; '\n';</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The <code>connection</code> class template has a private data member called <code>ConnectionString</code>. The type <a id="_idIndexMarker395"/>template parameter <code>T</code> is a friend of the class. The <code>executor</code> class uses the <a id="_idIndexMarker396"/>instantiation <code>connection&lt;executor&gt;</code>, which means the <code>executor</code> type is the template argument and benefits from the friendship with the <code>connection</code> class so that it can <a id="_idIndexMarker397"/>access the private data member <code>ConnectionString</code>.</p>
			<p>As can be seen from all these examples, friendship with templates is slightly different than friendship among non-template entities. Remember that friends have access to all the non-public members <a id="_idIndexMarker398"/>of a class. Therefore, friendship should be granted with care. On the other hand, if you need to grant access to some private members but not all, this is possible with the help of the <strong class="bold">client-attorney pattern</strong>. This pattern <a id="_idIndexMarker399"/>allows you to control the granularity of access to the private parts of a class. You can learn more about this pattern at this URL: <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client</a>. </p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor077"/>Summary</h1>
			<p>In this chapter, we went through a series of advanced topics. We started with name binding and dependent names and learned how to use the <code>typename</code> and the <code>template</code> keywords to tell the compiler what kind of dependent names we are referring to. Then, we learned about recursive templates and how to implement compile-time versions, using different approaches, for a recursive function.</p>
			<p>We also learned about argument deduction for both function templates and class templates and how to help the compiler to do the latter with the help of user-defined deduction guides. An important topic covered in this chapter was the forwarding references and how they help us to implement perfect forwarding. Toward the end of the chapter, we learned about the <code>decltype</code> type specifier, the <code>std::declvalue</code> type utility, and, lastly, how friendship works in the context of class templates.</p>
			<p>In the next chapter, we begin utilizing the knowledge accumulated so far about templates to do template metaprogramming, which is, basically, writing code that is evaluated at compile-time.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor078"/>Questions</h1>
			<ol>
				<li value="1">When is name lookup performed?</li>
				<li>What are deduction guides?</li>
				<li>What are forwarding references?</li>
				<li>What does <code>decltype</code> do?</li>
				<li>What does <code>std::declval</code> do?</li>
			</ol>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor079"/>Further readings</h1>
			<ul>
				<li><em class="italic">Dependent name lookup for C++ templates</em> – Eli Bendersky, <a href="https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates">https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates</a></li>
				<li><em class="italic">Universal References in C++11</em> – Scott Meyers, <a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers</a></li>
				<li><em class="italic">C++ Rvalue References Explained</em> – Thomas Becker, <a href="http://thbecker.net/articles/rvalue_references/section_01.html">http://thbecker.net/articles/rvalue_references/section_01.html</a></li>
				<li><em class="italic">Universal vs Forwarding References in C++</em> – Petr Zemek, <a href="https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/">https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/</a></li>
			</ul>
		</div>
	</div></body></html>