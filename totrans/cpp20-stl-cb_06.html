<html><head></head><body>
		<div id="_idContainer030">
			<h1 id="_idParaDest-182"><em class="italic"><a id="_idTextAnchor181"/>Chapter 6</em>: STL Algorithms</h1>
			<p>Much of the power of the STL is in the standardization of container interfaces. If a container has a particular capability, there's a good chance that the interface for that capability is standardized across container types. This standardization makes possible a library of <em class="italic">algorithms</em> that operate seamlessly across containers and sequences sharing a common interface.</p>
			<p>For example, if we want to sum all the elements in a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong>, we could use a loop:</p>
			<p class="source-code">vector&lt;int&gt; x { 1, 2, 3, 4, 5 };</p>
			<p class="source-code">long sum{};</p>
			<p class="source-code">for( int i : x ) sum += i;                     // sum is 15</p>
			<p>Or we could use an algorithm:</p>
			<p class="source-code">vector&lt;int&gt; x { 1, 2, 3, 4, 5 };</p>
			<p class="source-code">auto sum = accumulate(x.begin(), x.end(), 0);  // sum is 15</p>
			<p>This same syntax works with other containers:</p>
			<p class="source-code">deque&lt;int&gt; x { 1, 2, 3, 4, 5 };</p>
			<p class="source-code">auto sum = accumulate(x.begin(), x.end(), 0);  // sum is 15</p>
			<p>The algorithm version is not necessarily shorter, but it is easier to read and easier to maintain. And an algorithm is often more efficient than the equivalent loop.</p>
			<p>Beginning with C++20, the <strong class="source-inline">ranges</strong> library provides a set of alternative algorithms that operate with <em class="italic">ranges</em> and <em class="italic">views</em>. This book will demonstrate those alternatives where appropriate. For more information on ranges and views, refer to the recipe <em class="italic">Create views into containers with ranges</em> in <a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>, of this book.</p>
			<p>Most of the algorithms are in the <strong class="source-inline">algorithm</strong> header. Some numeric algorithms, notably <strong class="source-inline">accumulate()</strong>, are in the <strong class="source-inline">numeric</strong> header, and some memory-related algorithms are in the <strong class="source-inline">memory</strong> header.</p>
			<p>We will cover STL algorithms in the following recipes:</p>
			<ul>
				<li>Copy from one iterator to another</li>
				<li>Join container elements into a string</li>
				<li>Sort containers with <strong class="source-inline">std::sort</strong></li>
				<li>Modify containers with <strong class="source-inline">std::transform</strong></li>
				<li>Find items in a container</li>
				<li>Limit the values of a container to a range with <strong class="source-inline">std::clamp</strong></li>
				<li>Sample data sets with <strong class="source-inline">std::sample</strong></li>
				<li>Generate permutations of data sequences</li>
				<li>Merge sorted containers</li>
			</ul>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06</a>.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Copy from one iterator to another</h1>
			<p>The <em class="italic">copy algorithms</em> are <a id="_idIndexMarker481"/>generally used to copy from and to containers, but in fact, they work with iterators, which is far more flexible.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>How to do it…</h2>
			<p>In this recipe, we will experiment with <strong class="source-inline">std::copy</strong> and <strong class="source-inline">std::copy_n</strong> to get a good understanding of how they work:</p>
			<ul>
				<li>Let's start with a function to print a container:<p class="source-code">void printc(auto&amp; c, string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : c) cout &lt;&lt; format("[{}] ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main()</strong>, we define a <strong class="source-inline">vector</strong> and print it with <strong class="source-inline">printc()</strong>:<p class="source-code">int main() {</p><p class="source-code">    vector&lt;string&gt; v1</p><p class="source-code">        { "alpha", "beta", "gamma", "delta", </p><p class="source-code">          "epsilon" };</p><p class="source-code">    printc(v1);</p><p class="source-code">}</p></li>
			</ul>
			<p>We get this output:</p>
			<p class="source-code"><strong class="bold">v1: [alpha] [beta] [gamma] [delta] [epsilon]</strong></p>
			<ul>
				<li>Now, let's <a id="_idIndexMarker482"/>create a second <strong class="source-inline">vector</strong> with enough space to copy the first <strong class="source-inline">vector</strong>:<p class="source-code">vector&lt;string&gt; v2(v1.size());</p></li>
				<li>We can copy <strong class="source-inline">v1</strong> to <strong class="source-inline">v2</strong> using the <strong class="source-inline">std::copy()</strong> algorithm:<p class="source-code">std::copy(v1.begin(), v1.end(), v2.begin());</p><p class="source-code">printc(v2);</p></li>
			</ul>
			<p>The <strong class="source-inline">std::copy()</strong> algorithm takes two iterators for the range of the copy source, and one iterator for the destination. In this case, we give it the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators of <strong class="source-inline">v1</strong> to copy the entire <strong class="source-inline">vector</strong>. The <strong class="source-inline">begin()</strong> iterator of <strong class="source-inline">v2</strong> serves as the destination for the copy.</p>
			<p>Our output is now:</p>
			<p class="source-code"><strong class="bold">v1: [alpha] [beta] [gamma] [delta] [epsilon]</strong></p>
			<p class="source-code"><strong class="bold">v2: [alpha] [beta] [gamma] [delta] [epsilon]</strong></p>
			<ul>
				<li>The <strong class="source-inline">copy()</strong> algorithm does not allocate space for the destination. So, <strong class="source-inline">v2</strong> must already have the space for the copy. Alternately, you can use the <strong class="source-inline">back_inserter()</strong> iterator adapter to insert the elements at the back of the <strong class="source-inline">vector</strong>:<p class="source-code">vector&lt;string&gt; v2{};</p><p class="source-code">std::copy(v1.begin(), v1.end(), back_inserter(v2))</p></li>
				<li>We can also use the <strong class="source-inline">ranges::copy()</strong> algorithm to copy an entire <em class="italic">range</em>. A container <a id="_idIndexMarker483"/>object serves as a range so we can use <strong class="source-inline">v1</strong> as the source. We still use an iterator for the destination:<p class="source-code">vector&lt;string&gt; v2(v1.size());</p><p class="source-code">ranges::copy(v1, v2.begin());</p></li>
			</ul>
			<p>This also works with <strong class="source-inline">back_inserter()</strong>:</p>
			<p class="source-code">vector&lt;string&gt; v2{};</p>
			<p class="source-code">ranges::copy(v1, back_inserter(v2));</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">v2: [alpha] [beta] [gamma] [delta] [epsilon]</strong></p>
			<ul>
				<li>You can copy a certain number of elements using <strong class="source-inline">copy_n()</strong>:<p class="source-code">vector&lt;string&gt; v3{};</p><p class="source-code">std::copy_n(v1.begin(), 3, back_inserter(v3));</p><p class="source-code">printc(v3, "v3");</p></li>
			</ul>
			<p>In the second argument, the <strong class="source-inline">copy_n()</strong> algorithm is a <em class="italic">count</em> for the number of elements to copy. The output is:</p>
			<p class="source-code"><strong class="bold">v3: [alpha] [beta] [gamma]</strong></p>
			<ul>
				<li>There's also a <strong class="source-inline">copy_if()</strong> algorithm that uses a Boolean <em class="italic">predicate function</em> to determine which elements to copy:<p class="source-code">vector&lt;string&gt; v4{};</p><p class="source-code">std::copy_if(v1.begin(), v1.end(), back_inserter(v4), </p><p class="source-code">    [](string&amp; s){ return s.size() &gt; 4; });</p><p class="source-code">printc(v4, "v4");</p></li>
			</ul>
			<p>There's also a <strong class="source-inline">ranges</strong> version of <strong class="source-inline">copy_if()</strong>:</p>
			<p class="source-code">vector&lt;string&gt; v4{};</p>
			<p class="source-code">ranges::copy_if(v1, back_inserter(v4), </p>
			<p class="source-code">    [](string&amp; s){ return s.size() &gt; 4; });</p>
			<p class="source-code">printc(v4, "v4");</p>
			<p>The <a id="_idIndexMarker484"/>output includes only strings longer than <strong class="source-inline">4</strong> characters:</p>
			<p class="source-code"><strong class="bold">v4: [alpha] [gamma] [delta] [epsilon]</strong></p>
			<p>Notice that the value <strong class="source-inline">beta</strong> is excluded.</p>
			<ul>
				<li>You can use any of these algorithms to copy to or from any sequence, including a stream iterator:<p class="source-code">ostream_iterator&lt;string&gt; out_it(cout, " ");</p><p class="source-code">ranges::copy(v1, out_it)</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">alpha beta gamma delta epsilon</strong></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>How it works…</h2>
			<p>The <strong class="source-inline">std::copy()</strong> algorithm is very simple. An equivalent function would look like this:</p>
			<p class="source-code">template&lt;typename Input_it, typename Output_it&gt;</p>
			<p class="source-code">Output_it bw_copy(Input_it begin_it, Input_it end_it, </p>
			<p class="source-code">                  Output_it dest_it) {</p>
			<p class="source-code">    while (begin_it != end_it) {</p>
			<p class="source-code">        *dest_it++ = *begin_it++;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return dest_it;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">copy()</strong> function uses the destination iterator's assignment operator to copy from the input iterator to the output iterator until it reaches the end of the input range.</p>
			<p>There is also a version of this algorithm called <strong class="source-inline">std::move()</strong>, which moves elements instead of copying them:</p>
			<p class="source-code">std::move(v1.begin(), v1.end(), v2.begin());</p>
			<p class="source-code">printc(v1, "after move: v1");</p>
			<p class="source-code">printc(v2, "after move: v2");</p>
			<p>This <a id="_idIndexMarker485"/>performs a move instead of copy assignment. After the move operation, the elements in <strong class="source-inline">v1</strong> will be empty, and the elements that were in <strong class="source-inline">v1</strong> are now in <strong class="source-inline">v2</strong>. The output looks like this:</p>
			<p class="source-code">after move1: v1: [] [] [] [] []</p>
			<p class="source-code">after move1: v2: [alpha] [beta] [gamma] [delta] [epsilon]</p>
			<p>There is also a <strong class="source-inline">ranges</strong> version of the <strong class="source-inline">move()</strong> algorithm that performs the same operation:</p>
			<p class="source-code">ranges::move(v1, v2.begin());</p>
			<p>The power of these algorithms lies in their simplicity. By letting the iterators manage the data, these simple, elegant functions allow you to seamlessly copy or move between any of the STL containers that support the required iterators.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Join container elements into a string</h1>
			<p>Sometimes, there is <a id="_idIndexMarker486"/>no algorithm in the library to accomplish <a id="_idIndexMarker487"/>a task at hand. We can use iterators, with the same techniques as the <strong class="source-inline">algorithms</strong> library, to easily write one.</p>
			<p>For example, we often need to join elements from a container, with separators, into a string. One common solution is to use a simple <strong class="source-inline">for()</strong> loop:</p>
			<p class="source-code">for(auto v : c) cout &lt;&lt; v &lt;&lt; ', ';</p>
			<p>The problem with this otherwise simple solution is that it leaves a trailing separator:</p>
			<p class="source-code">vector&lt;string&gt; greek{ "alpha", "beta", "gamma", </p>
			<p class="source-code">                      "delta", "epsilon" };</p>
			<p class="source-code">for(auto v : greek) cout &lt;&lt; v &lt;&lt; ", ";</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">alpha, beta, gamma, delta, epsilon,</p>
			<p>This may be <a id="_idIndexMarker488"/>fine in a testing environment, but in any <a id="_idIndexMarker489"/>production system, that trailing comma is unacceptable.</p>
			<p>The <strong class="source-inline">ranges::views</strong> library has a <strong class="source-inline">join()</strong> function, but it doesn't provide a separator:</p>
			<p class="source-code">auto <strong class="bold">greek_view</strong> = views::join(greek);</p>
			<p>The <strong class="source-inline">views::join()</strong> function returns a <strong class="source-inline">ranges::view</strong> object. This requires a separate step to display or turn into a string. We can cycle through the view with a <strong class="source-inline">for()</strong> loop:</p>
			<p class="source-code">for(const char c : <strong class="bold">greek_view</strong>) cout &lt;&lt; c;</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>The output looks like this:</p>
			<p class="source-code">alphabetagammadeltaepsilon</p>
			<p>It's all there, but we need a proper separator between the elements to make it useful for our purposes.</p>
			<p>Since the <strong class="source-inline">algorithms</strong> library does not have a function that suits our needs, we'll write one.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>How to do it…</h2>
			<p>For this recipe, we will take the elements of a container and join them into a string with separators:</p>
			<ul>
				<li>In our <strong class="source-inline">main()</strong> function, we declare a vector of strings:<p class="source-code">int main() {</p><p class="source-code">    vector&lt;string&gt; greek{ "alpha", "beta", "gamma",</p><p class="source-code">        "delta", "epsilon" };</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Now, let's <a id="_idIndexMarker490"/>write a simple <strong class="source-inline">join()</strong> function <a id="_idIndexMarker491"/>that uses an <strong class="source-inline">ostream</strong> object to join elements with a separator:<p class="source-code">namespace bw {</p><p class="source-code">    template&lt;typename I&gt;</p><p class="source-code">    ostream&amp; join(I it, I end_it, ostream&amp; o, </p><p class="source-code">                  string_view sep = "") {</p><p class="source-code">        if(it != end_it) o &lt;&lt; *it++;</p><p class="source-code">        while(it != end_it) o &lt;&lt; sep &lt;&lt; *it++;</p><p class="source-code">        return o;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>I've put this in my own <strong class="source-inline">bw</strong> namespace to avoid name collisions.</p>
			<p>We can call it with <strong class="source-inline">cout</strong> like this:</p>
			<p class="source-code">bw::join(greek.begin(), greek.end(), cout, ", ") &lt;&lt; '\n';</p>
			<p>Because it returns the <strong class="source-inline">ostream</strong> object, we can follow it with <strong class="source-inline">&lt;&lt;</strong> to add a <em class="italic">newline</em> to the stream.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">alpha, beta, gamma, delta, epsilon</strong></p>
			<ul>
				<li>We'll often <a id="_idIndexMarker492"/>want a <strong class="source-inline">string</strong>, instead of <a id="_idIndexMarker493"/>directly writing to <strong class="source-inline">cout</strong>. We can overload this function for a version that returns a <strong class="source-inline">string</strong> object:<p class="source-code">template&lt;typename I&gt;</p><p class="source-code">string join(I it, I end_it, string_view sep = "") {</p><p class="source-code">    ostringstream ostr;</p><p class="source-code">    join(it, end_it, ostr, sep);</p><p class="source-code">    return ostr.str();</p><p class="source-code">}</p></li>
			</ul>
			<p>This also goes in the <strong class="source-inline">bw</strong> namespace. This function creates an <strong class="source-inline">ostringstream</strong> object to pass to the <strong class="source-inline">ostream</strong> version of <strong class="source-inline">bw::join()</strong>. It returns a <strong class="source-inline">string</strong> object from the <strong class="source-inline">str()</strong> method of the <strong class="source-inline">ostringstream</strong> object.</p>
			<p>We can use it like this:</p>
			<p class="source-code">string s = bw::join(greek.begin(), greek.end(), ", ");</p>
			<p class="source-code">cout &lt;&lt; s &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">alpha, beta, gamma, delta, epsilon</strong></p>
			<ul>
				<li>Let's add one final overload to make this easier to use:<p class="source-code">string join(const auto&amp; c, string_view sep = "") {</p><p class="source-code">    return join(begin(c), end(c), sep);</p><p class="source-code">}</p></li>
			</ul>
			<p>This version just takes a container and a separator, which should satisfy most use cases nicely:</p>
			<p class="source-code">string s = bw::join(greek, ", ");</p>
			<p class="source-code">cout &lt;&lt; s &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">alpha, beta, gamma, delta, epsilon</strong></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>How it works…</h2>
			<p>Most of <a id="_idIndexMarker494"/>the work in this recipe is done by the <a id="_idIndexMarker495"/>iterators and the <strong class="source-inline">ostream</strong> object:</p>
			<p class="source-code">namespace bw {</p>
			<p class="source-code">    template&lt;typename I&gt;</p>
			<p class="source-code">    ostream&amp; join(I it, I end_it, ostream&amp; o, </p>
			<p class="source-code">                  string_view sep = "") {</p>
			<p class="source-code">        if(it != end_it) <strong class="bold">o &lt;&lt; *it++</strong>;</p>
			<p class="source-code">        while(it != end_it) <strong class="bold">o &lt;&lt; sep &lt;&lt; *it++</strong>;</p>
			<p class="source-code">        <strong class="bold">return o</strong>;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The separators go after the first element, between each of the successive elements, and stop before the final element. This means we can either add a separator <em class="italic">before</em> each element, skipping the first, or <em class="italic">after</em> each element, skipping the last. The logic is simpler if we test for, and skip, the first element. We do that in the line just before the <strong class="source-inline">while()</strong> loop:</p>
			<p class="source-code">if(it != end_it) <strong class="bold">o &lt;&lt; *it++</strong>;</p>
			<p>Once we have the first element out of the way, we can simply add a separator before each remaining element:</p>
			<p class="source-code">while(it != end_it) <strong class="bold">o &lt;&lt; sep &lt;&lt; *it++</strong>;</p>
			<p>We <a id="_idIndexMarker496"/>return the <strong class="source-inline">ostream</strong> object as a convenience. This <a id="_idIndexMarker497"/>allows the user to easily add a newline, or other objects, to the stream:</p>
			<p class="source-code">bw::join(greek.begin(), greek.end(), cout, ", ") <strong class="bold">&lt;&lt;</strong> '\n';</p>
			<p>Output:</p>
			<p class="source-code">alpha, beta, gamma, delta, epsilon</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>There's more…</h2>
			<p>As with any of the library <a id="_idIndexMarker498"/>algorithms, the <strong class="source-inline">join()</strong> function will work with any <a id="_idIndexMarker499"/>container that supports <em class="italic">forward iterators</em>. For example, here's a <strong class="source-inline">list</strong> of <strong class="source-inline">double</strong> constants from the <strong class="source-inline">numbers</strong> library:</p>
			<p class="source-code">namespace num = std::numbers;</p>
			<p class="source-code">list&lt;double&gt; constants { num::pi, num::e, num::sqrt2 };</p>
			<p class="source-code">cout &lt;&lt; bw::join(constants, ", ") &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">3.14159, 2.71828, 1.41421</p>
			<p>It will even work with a <strong class="source-inline">ranges::view</strong> object, like the <strong class="source-inline">greek_view</strong> defined earlier in this recipe:</p>
			<p class="source-code">cout &lt;&lt; bw::join(greek_view, ":") &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">a:l:p:h:a:b:e:t:a:g:a:m:m:a:d:e:l:t:a:e:p:s:i:l:o:n</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Sort containers with std::sort</h1>
			<p>The problem of how <a id="_idIndexMarker500"/>to efficiently sort comparable elements is essentially solved. For most applications, there's no reason to re-invent this wheel. The STL provides an excellent sorting solution via the <strong class="source-inline">std::sort()</strong> algorithm. While the standard does not specify a <a id="_idIndexMarker501"/>sorting algorithm, it does specify a worst-case complexity of <em class="italic">O</em>(<em class="italic">n</em> log <em class="italic">n</em>), when applied to a range of <em class="italic">n</em> elements.</p>
			<p>Just a few decades ago, the <em class="italic">quicksort</em> algorithm was considered a good compromise for most uses and was generally faster than other comparable algorithms. Today we have <em class="italic">hybrid</em> algorithms that choose between different approaches according to the circumstances, often switching algorithms on the fly. Most current C++ libraries use a hybrid approach with some combination of <em class="italic">introsort</em> and an <em class="italic">insertion sort</em>. <strong class="source-inline">std::sort()</strong> provides exceptional performance under most common circumstances.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>How to do it…</h2>
			<p>In this recipe, we'll examine the <strong class="source-inline">std::sort()</strong> algorithm. The <strong class="source-inline">sort()</strong> algorithm works with any <a id="_idIndexMarker502"/>container with random-access iterators. Here, we will use a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong>:</p>
			<ul>
				<li>We'll start with a function to test if a container is sorted:<p class="source-code">void check_sorted(auto &amp;c) {</p><p class="source-code">    if(!is_sorted(c.begin(), c.end())) cout &lt;&lt; "un";</p><p class="source-code">    cout &lt;&lt; "sorted: ";</p><p class="source-code">}</p></li>
			</ul>
			<p>This uses the <strong class="source-inline">std::is_sorted()</strong> algorithm and prints either <strong class="source-inline">"sorted:"</strong> or <strong class="source-inline">"unsorted:"</strong> according to the result.</p>
			<ul>
				<li>We'll need a function to print our <strong class="source-inline">vector</strong>:<p class="source-code">void printc(const auto &amp;c) {</p><p class="source-code">    check_sorted(c);</p><p class="source-code">    for(auto&amp; e : c) cout &lt;&lt; e &lt;&lt; ' ';</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>This function calls <strong class="source-inline">check_sorted()</strong> to display the status of the container before the value.</p>
			<ul>
				<li>Now we can define and print a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong> in the <strong class="source-inline">main()</strong> function:<p class="source-code">int main() {</p><p class="source-code">    vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p class="source-code">    printc(v);</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ul>
			<p>The output looks like this:</p>
			<p class="source-code"><strong class="bold">sorted: 1 2 3 4 5 6 7 8 9 10</strong></p>
			<ul>
				<li>In order to <a id="_idIndexMarker503"/>test the <strong class="source-inline">std::sort()</strong> algorithm, we need an unsorted vector. Here's a simple function to randomize our container:<p class="source-code">void randomize(auto&amp; c) {</p><p class="source-code">    static std::random_device rd;</p><p class="source-code">    static std::default_random_engine rng(rd());</p><p class="source-code">    std::shuffle(c.begin(), c.end(), rng);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">std::random_device</strong> class uses your system's hardware <em class="italic">entropy</em> source. Most modern systems have one, otherwise the library will simulate it. The <strong class="source-inline">std::default_random_engine()</strong> function generates random numbers from the entropy source. This is used by <strong class="source-inline">std::shuffle()</strong> to randomize the container.</p>
			<p>We can now call <strong class="source-inline">randomize()</strong> with our container and print the result:</p>
			<p class="source-code">randomize(v);</p>
			<p class="source-code">printc(v);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">unsorted: 6 3 4 8 10 1 2 5 9 7</strong></p>
			<p>Of course, your output will be different because it's randomized. In fact, I get a different result every time I run it:</p>
			<p class="source-code">for(int i{3}; i; --i) {</p>
			<p class="source-code">    randomize(v);</p>
			<p class="source-code">    printc(v);</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">unsorted: 3 1 8 5 10 2 7 9 6 4</strong></p>
			<p class="source-code"><strong class="bold">unsorted: 7 6 5 1 3 9 10 2 4 8</strong></p>
			<p class="source-code"><strong class="bold">unsorted: 4 2 3 10 1 9 5 6 8 7</strong></p>
			<ul>
				<li>To sort the <a id="_idIndexMarker504"/>vector, we simply call <strong class="source-inline">std::sort()</strong>:<p class="source-code">std::sort(v.begin(), v.end());</p><p class="source-code">printc(v);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">sorted: 1 2 3 4 5 6 7 8 9 10</strong></p>
			<p>By default, the <strong class="source-inline">sort()</strong> algorithm uses the <strong class="source-inline">&lt;</strong> operator to sort the elements in the range specified by the supplied iterators.</p>
			<ul>
				<li>The <strong class="source-inline">partial_sort()</strong> algorithm will sort part of the container:<p class="source-code">cout &lt;&lt; "partial_sort:\n";</p><p class="source-code">randomize(v);</p><p class="source-code">auto middle{ v.begin() + (v.size() / 2) };</p><p class="source-code">std::partial_sort(v.begin(), middle, v.end());</p><p class="source-code">printc(v);</p></li>
			</ul>
			<p><strong class="source-inline">partial_sort()</strong> takes three iterators: beginning, middle, and end. It sorts the container such that the elements before the middle are sorted. The elements after the middle are not guaranteed to be in the original order. Here's the output:</p>
			<p class="source-code"><strong class="bold">unsorted: 1 2 3 4 5 10 7 6 8 9</strong></p>
			<p>Notice that the first five elements are sorted, and the rest are not.</p>
			<ul>
				<li>The <strong class="source-inline">partition()</strong> algorithm <em class="italic">does not</em> sort anything. It rearranges the container so <a id="_idIndexMarker505"/>that certain elements appear at the front of the container:<p class="source-code">coutrandomize(v);</p><p class="source-code">printc(v);</p><p class="source-code">partition(v.begin(), v.end(), [](int i)</p><p class="source-code">    { return i &gt; 5; });</p><p class="source-code">printc(v);</p></li>
			</ul>
			<p>The third argument is a <em class="italic">predicate</em> lambda that determines which elements will be moved to the front.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">unsorted: 4 6 8 1 9 5 2 7 3 10</strong></p>
			<p class="source-code"><strong class="bold">unsorted: 10 6 8 7 9 5 2 1 3 4</strong></p>
			<p>Notice that the values <strong class="source-inline">&gt;5</strong> are moved to the front of the container.</p>
			<ul>
				<li>The <strong class="source-inline">sort()</strong> algorithms support an optional comparison function that may be used for non-standard comparisons. For example, given a class called <strong class="source-inline">things</strong>:<p class="source-code">struct things {</p><p class="source-code">    string s_;</p><p class="source-code">    int i_;</p><p class="source-code">    string str() const {</p><p class="source-code">        return format("({}, {})", s_, i_);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>We can create a <strong class="source-inline">vector</strong> of <strong class="source-inline">things</strong>:</p>
			<p class="source-code">vector&lt;things&gt; vthings{ {"button", 40},</p>
			<p class="source-code">    {"hamburger", 20}, {"blog", 1000},</p>
			<p class="source-code">    {"page", 100}, {"science", 60} };</p>
			<p>We'll need a <a id="_idIndexMarker506"/>function to print them out:</p>
			<p class="source-code">void print_things(const auto&amp; c) {</p>
			<p class="source-code">    for (auto&amp; v : c) cout &lt;&lt; v.str() &lt;&lt; ' ';</p>
			<p class="source-code">    cout &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<ul>
				<li>Now we can sort and print the <strong class="source-inline">vector</strong> of <strong class="source-inline">things</strong>:<p class="source-code">std::sort(vthings.begin(), vthings.end(), </p><p class="source-code">        [](const things &amp;lhs, const things &amp;rhs) {</p><p class="source-code">    return lhs.i_ &lt; rhs.i_;</p><p class="source-code">});</p><p class="source-code">print_things(vthings);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">(hamburger, 20) (button, 40) (science, 60) (page, 100) (blog, 1000)</strong></p>
			<p>Notice the comparison function sorts on the <strong class="source-inline">i_</strong> member, so the result is sorted by <strong class="source-inline">i_</strong>. We could instead sort on the <strong class="source-inline">s_</strong> member:</p>
			<p class="source-code">std::sort(vthings.begin(), vthings.end(), </p>
			<p class="source-code">        [](const things &amp;lhs, const things &amp;rhs) {</p>
			<p class="source-code">    return lhs.s_ &lt; rhs.s_;</p>
			<p class="source-code">});</p>
			<p class="source-code">print_things(vthings);</p>
			<p>Now we get this output:</p>
			<p class="source-code"><strong class="bold">(blog, 1000) (button, 40) (hamburger, 20) (page, 100) (science, 60)</strong></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>How it works…</h2>
			<p>The <strong class="source-inline">sort()</strong> functions work by applying a sorting algorithm to a range of elements indicated by two iterators, for the beginning and end of the range.</p>
			<p>By default, these algorithms use the <strong class="source-inline">&lt;</strong> operator to compare elements. Optionally, they may use a <em class="italic">comparison function</em>, often provided as a lambda:</p>
			<p class="source-code">std::sort(vthings.begin(), vthings.end(), </p>
			<p class="source-code">        [](const things&amp; lhs, const things&amp; rhs) {</p>
			<p class="source-code">    return lhs.i_ &lt; rhs.i_;</p>
			<p class="source-code">});</p>
			<p>The comparison function takes two arguments and returns a <strong class="source-inline">bool</strong>. It has a signature equivalent to this:</p>
			<p class="source-code">bool cmp(const Type1&amp; a, const Type2&amp; b);</p>
			<p>The <strong class="source-inline">sort()</strong> functions use <strong class="source-inline">std::swap()</strong> to move elements. This is efficient in both compute cycles and <a id="_idIndexMarker507"/>memory usage, as it relieves the need to allocate space for reading and writing the objects being sorted. This is also why the <strong class="source-inline">partial_sort()</strong> and <strong class="source-inline">partition()</strong> functions cannot guarantee the order of unsorted elements.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Modify containers with std::transform</h1>
			<p>The <strong class="source-inline">std::transform()</strong> function is remarkably powerful and flexible. One of the more commonly <a id="_idIndexMarker508"/>deployed algorithms in the <a id="_idIndexMarker509"/>library, it applies a <em class="italic">function</em> or <em class="italic">lambda</em> to each element in a container, storing the results in another container while leaving the original in place.</p>
			<p>Given its power, it's deceptively simple to use.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>How to do it…</h2>
			<p>In this recipe, we will explore a few applications for the <strong class="source-inline">std::transform()</strong> function:</p>
			<ul>
				<li>We'll start with a simple function that prints the contents of a container:<p class="source-code">void printc(auto&amp; c, string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : c) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>We'll use this to view the results of our transformations.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, let's declare a couple of vectors:<p class="source-code">int main() {</p><p class="source-code">    vector&lt;int&gt; v1{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p class="source-code">    vector&lt;int&gt; v2;</p><p class="source-code">    printc(v1, "v1");</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ul>
			<p>This prints out the contents of <strong class="source-inline">v1</strong>:</p>
			<p class="source-code"><strong class="bold">v1: 1 2 3 4 5 6 7 8 9 10</strong></p>
			<ul>
				<li>Now we can use the <strong class="source-inline">transform()</strong> function to insert the square of each value into <strong class="source-inline">v2</strong>:<p class="source-code">cout &lt;&lt; "squares:\n";</p><p class="source-code">transform(v1.begin(), v1.end(), back_inserter(v2),</p><p class="source-code">    [](int x){ return x * x; });</p><p class="source-code">printc(v2, "v2");</p></li>
			</ul>
			<p>The <strong class="source-inline">transform()</strong> function takes four arguments. The first two are the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators for the source range. The third argument is the <strong class="source-inline">begin()</strong> iterator for the destination range. In this case, we're using the <strong class="source-inline">back_inserter()</strong> algorithm to insert the results in <strong class="source-inline">v2</strong>. The fourth argument is <a id="_idIndexMarker510"/>the transformation <a id="_idIndexMarker511"/>function. In this case, we're using a simple lambda to square the value.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">squares:</strong></p>
			<p class="source-code"><strong class="bold">v2: 1 4 9 16 25 36 49 64 81 100</strong></p>
			<ul>
				<li>Of course, we can use <strong class="source-inline">transform()</strong> with any type. Here's an example that converts a <strong class="source-inline">vector</strong> of <strong class="source-inline">string</strong> objects to lowercase. First, we need a function to return the lowercase value of a string:<p class="source-code">string str_lower(const string&amp; s) {</p><p class="source-code">    string outstr{};</p><p class="source-code">    for(const char&amp; c : s) {</p><p class="source-code">        outstr += tolower(c);</p><p class="source-code">    }</p><p class="source-code">    return outstr;</p><p class="source-code">}</p></li>
			</ul>
			<p>Now we can use the <strong class="source-inline">str_lower()</strong> function with transform:</p>
			<p class="source-code">vector&lt;string&gt; vstr1{ "Mercury", "Venus", "Earth",</p>
			<p class="source-code">    "Mars", "Jupiter", "Saturn", "Uranus", "Neptune",</p>
			<p class="source-code">    "Pluto" };</p>
			<p class="source-code">vector&lt;string&gt; vstr2;</p>
			<p class="source-code">printc(vstr1, "vstr1");</p>
			<p class="source-code">cout &lt;&lt; "str_lower:\n";</p>
			<p class="source-code">transform(vstr1.begin(), vstr1.end(),</p>
			<p class="source-code">    back_inserter(vstr2), </p>
			<p class="source-code">    [](string&amp; x){ return str_lower(x); });</p>
			<p class="source-code">printc(vstr2, "vstr2");</p>
			<p>This <a id="_idIndexMarker512"/>calls <strong class="source-inline">str_lower()</strong> for every <a id="_idIndexMarker513"/>element in <strong class="source-inline">vstr1</strong> and inserts the results into <strong class="source-inline">vstr2</strong>. The result is:</p>
			<p class="source-code"><strong class="bold">vstr: Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto</strong></p>
			<p class="source-code"><strong class="bold">str_lower:</strong></p>
			<p class="source-code"><strong class="bold">vstr: mercury venus earth mars jupiter saturn uranus neptune pluto</strong></p>
			<p>(Yes, Pluto will always be a planet to me.)</p>
			<ul>
				<li>There's also a <strong class="source-inline">ranges</strong> version of transform:<p class="source-code">cout &lt;&lt; "ranges squares:\n";</p><p class="source-code">auto view1 = views::transform(v1, [](int x){ </p><p class="source-code">    return x * x; });</p><p class="source-code">printc(view1, "view1");</p></li>
			</ul>
			<p>The <strong class="source-inline">ranges</strong> version has a more succinct syntax and returns a <strong class="source-inline">view</strong> object, rather than populating another container.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>How it works…</h2>
			<p>The <strong class="source-inline">std::transform()</strong> function works very much like <strong class="source-inline">std::copy()</strong>, with the addition of the user-provided function. Each element in the input range is passed to the function, and the <a id="_idIndexMarker514"/>return value from the function <a id="_idIndexMarker515"/>is copy-assigned to the destination iterator. This makes <strong class="source-inline">transform()</strong> a singularly useful and powerful algorithm.</p>
			<p>It's worth noting that <strong class="source-inline">transform()</strong> does not guarantee the elements will be processed in order. If you need to ensure the order of the transformation, you will want to use a <strong class="source-inline">for</strong> loop instead:</p>
			<p class="source-code">v2.clear();    // reset vector v2 to empty state</p>
			<p class="source-code">for(auto e : v1) v2.push_back(e * e);</p>
			<p class="source-code">printc(v2, "v2");</p>
			<p>Output:</p>
			<p class="source-code">v2: 1 4 9 16 25 36 49 64 81 100</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor196"/>Find items in a container</h1>
			<p>The <strong class="source-inline">algorithm</strong> library <a id="_idIndexMarker516"/>contains a set of functions for finding elements <a id="_idIndexMarker517"/>in a container. The <strong class="source-inline">std::find()</strong> function, and its derivatives, search sequentially through a container and return an iterator pointing to the first matching element, or the <strong class="source-inline">end()</strong> element if there's no match.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>How to do it…</h2>
			<p>The <strong class="source-inline">find()</strong> algorithm works <a id="_idIndexMarker518"/>with any container that satisfies the <em class="italic">Forward</em> or <em class="italic">Input</em> iterator qualifications. For this recipe, we'll use <strong class="source-inline">vector</strong> containers. The <strong class="source-inline">find()</strong> algorithm searches sequentially for the first matching element in a container. In this recipe, we'll walk through a few examples:</p>
			<ul>
				<li>We'll start by declaring a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong> in the <strong class="source-inline">main()</strong> function:<p class="source-code">int main() {</p><p class="source-code">    const vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Now, let's search for the element with the value <strong class="source-inline">7</strong>:<p class="source-code">auto it1 = <strong class="bold">find(v.begin(), v.end(), 7)</strong>;</p><p class="source-code"><strong class="bold">if(it1 != v.end())</strong> cout &lt;&lt; format("found: {}\n", *it1);</p><p class="source-code">else cout &lt;&lt; "not found\n";</p></li>
			</ul>
			<p>The <strong class="source-inline">find()</strong> algorithm takes three arguments: the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators, and the <a id="_idIndexMarker519"/>value to search. It returns an iterator to the <a id="_idIndexMarker520"/>first element it finds, or the <strong class="source-inline">end()</strong> iterator if the search failed to find a match.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">found: 7</strong></p>
			<ul>
				<li>We can also search for something more complex than a scalar. The object needs to support the equality comparison operator, <strong class="source-inline">==</strong>. Here's a simple struct with an <strong class="source-inline">operator==()</strong> overload:<p class="source-code">struct City {</p><p class="source-code">    string name{};</p><p class="source-code">    unsigned pop{};</p><p class="source-code">    bool operator==(const City&amp; o) const {</p><p class="source-code">        return <strong class="bold">name == o.name</strong>;</p><p class="source-code">    }</p><p class="source-code">    string str() const {</p><p class="source-code">        return format("[{}, {}]", name, pop);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>Notice that the <strong class="source-inline">operator=()</strong> overload only compares the <strong class="source-inline">name</strong> members.</p>
			<p>I've also <a id="_idIndexMarker521"/>included an <strong class="source-inline">str()</strong> function that returns a <strong class="source-inline">string</strong> representation <a id="_idIndexMarker522"/>of a <strong class="source-inline">City</strong> element.</p>
			<ul>
				<li>Now we can declare a <strong class="source-inline">vector</strong> of <strong class="source-inline">City</strong> elements:<p class="source-code">const vector&lt;City&gt; c{</p><p class="source-code">    { "London", 9425622 },</p><p class="source-code">    { "Berlin", 3566791 },</p><p class="source-code">    { "Tokyo",  37435191 },</p><p class="source-code">    { "Cairo",  20485965 }</p><p class="source-code">};</p></li>
				<li>We can search the <strong class="source-inline">vector</strong> of <strong class="source-inline">City</strong> just as we did with the <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong>:<p class="source-code">auto it2 = <strong class="bold">find(c.begin(), c.end(), City{"Berlin"})</strong>;</p><p class="source-code">if(it2 != c.end()) cout &lt;&lt; format("found: {}\n", </p><p class="source-code">    <strong class="bold">it2-&gt;str()</strong>);</p><p class="source-code">else cout &lt;&lt; "not found\n";</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">found: [Berlin, 3566791]</strong></p>
			<ul>
				<li>If we want to search on the <strong class="source-inline">pop</strong> member instead of <strong class="source-inline">name</strong>, we can use the <strong class="source-inline">find_if()</strong> function with a predicate:<p class="source-code">auto it3 = find_if(begin(c), end(c),</p><p class="source-code">    [](const City&amp; item)</p><p class="source-code">        { return item.pop &gt; 20000000; });</p><p class="source-code">if(it3 != c.end()) cout &lt;&lt; format("found: {}\n",</p><p class="source-code">    it3-&gt;str());</p><p class="source-code">else cout &lt;&lt; "not found\n";</p></li>
			</ul>
			<p>The predicate tests the <strong class="source-inline">pop</strong> member, so we get this output:</p>
			<p class="source-code"><strong class="bold">found: [Tokyo, 37435191]</strong></p>
			<ul>
				<li>Notice that the result from <strong class="source-inline">find_if()</strong> returns only the first element that satisfies the <a id="_idIndexMarker523"/>predicate, even though there are two elements <a id="_idIndexMarker524"/>in the <strong class="source-inline">vector</strong> with <strong class="source-inline">pop</strong> values greater than 20,000,000.</li>
			</ul>
			<p>The <strong class="source-inline">find()</strong> and <strong class="source-inline">find_if()</strong> functions return only one iterator. The <strong class="source-inline">ranges</strong> library provides <strong class="source-inline">ranges::views::filter()</strong>, a <em class="italic">view adapter</em> that will give us all the matching iterators without disturbing our <strong class="source-inline">vector</strong>:</p>
			<p class="source-code">auto <strong class="bold">vw1</strong> = ranges::views::filter(c, </p>
			<p class="source-code">    [](const City&amp; c){ return c.pop &gt; 20000000; });</p>
			<p class="source-code">for(const City&amp; e : <strong class="bold">vw1</strong>) cout &lt;&lt; format("{}\n", e.str());</p>
			<p>This gives us both matching elements in our output:</p>
			<p class="source-code"><strong class="bold">[Tokyo, 37435191]</strong></p>
			<p class="source-code"><strong class="bold">[Cairo, 20485965]</strong></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>How it works…</h2>
			<p>The <strong class="source-inline">find()</strong> and <strong class="source-inline">find_if()</strong> functions search sequentially through a container, checking each element until it finds a match. If it finds a match, it returns an iterator pointing to that match. If it reaches the <strong class="source-inline">end()</strong> iterator without finding a match, it returns the <strong class="source-inline">end()</strong> iterator to indicate no match was found.</p>
			<p>The <strong class="source-inline">find()</strong> function takes <a id="_idIndexMarker525"/>three arguments, the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators, and a search value. The <a id="_idIndexMarker526"/>signature looks like this:</p>
			<p class="source-code">template&lt;class InputIt, class T&gt;</p>
			<p class="source-code">constexpr InputIt find(InputIt, InputIt, const T&amp;)</p>
			<p>The <strong class="source-inline">find_if()</strong> function uses a predicate instead of a value:</p>
			<p class="source-code">template&lt;class InputIt, class UnaryPredicate&gt;</p>
			<p class="source-code">constexpr InputIt find_if(InputIt, InputIt, UnaryPredicate)</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>There's more…</h2>
			<p>Both <strong class="source-inline">find()</strong> functions search <a id="_idIndexMarker527"/>sequentially and return when they find the first match. If you want to find more matching elements, you can use the <strong class="source-inline">filter()</strong> function from the <strong class="source-inline">ranges</strong> library:</p>
			<p class="source-code">template&lt;ranges::viewable_range R, class Pred&gt;</p>
			<p class="source-code">constexpr ranges::view auto ranges::views::filter(R&amp;&amp;, Pred&amp;&amp;);</p>
			<p>The <strong class="source-inline">filter()</strong> function returns a <em class="italic">view</em>, a non-destructive window into the container with only the filtered <a id="_idIndexMarker528"/>elements. We can then use the view as we would any other container:</p>
			<p class="source-code">auto vw1 = std::ranges::views::filter(c,</p>
			<p class="source-code">    [](const City&amp; c){ return c.pop &gt; 20000000; });</p>
			<p class="source-code">for(const City&amp; e : vw1) cout &lt;&lt; format("{}\n", e.str());</p>
			<p>Output:</p>
			<p class="source-code">[Tokyo, 37435191]</p>
			<p class="source-code">[Cairo, 20485965]</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Limit the values of a container to a range with std::clamp</h1>
			<p>Introduced with C++17, the <strong class="source-inline">std::clamp()</strong> function can be used to limit the range of a numeric <a id="_idIndexMarker529"/>scalar to within minimum <a id="_idIndexMarker530"/>and maximum values. The function is optimized to use <em class="italic">move semantics</em>, where possible, for maximum speed and efficiency.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>How to do it…</h2>
			<p>We can use <strong class="source-inline">clamp()</strong> to constrain the values of a container by using it in a loop, or with the <strong class="source-inline">transform()</strong> algorithm. Let's look at some examples.</p>
			<ul>
				<li>We'll start with a simple function for printing out the values of a container:<p class="source-code">void printc(auto&amp; c, string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : c) cout &lt;&lt; format("{:&gt;5} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>Notice the <em class="italic">format string</em> <strong class="source-inline">"{:&gt;5} "</strong>. This right-aligns each value to <strong class="source-inline">5</strong> spaces, for a tabular view.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we'll define an <em class="italic">initializer list</em> for use with our container. This allows us to use the same values more than once:<p class="source-code">int main() {</p><p class="source-code">    auto il = { 0, -12, 2001, 4, 5, -14, 100, 200, </p><p class="source-code">      30000 };</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ul>
			<p>That's a nice range of values to work with <strong class="source-inline">clamp()</strong>.</p>
			<ul>
				<li>Let's also define some constants for use as our limits:<p class="source-code">constexpr int ilow{0};</p><p class="source-code">constexpr int ihigh{500};</p></li>
			</ul>
			<p>We'll use these values in our calls to <strong class="source-inline">clamp()</strong>.</p>
			<ul>
				<li>Now <a id="_idIndexMarker531"/>we can define <a id="_idIndexMarker532"/>a container in our <strong class="source-inline">main()</strong> function. We'll use a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong>:<p class="source-code">vector&lt;int&gt; voi{ il };</p><p class="source-code">cout &lt;&lt; "vector voi before:\n";</p><p class="source-code">printc(voi);</p></li>
			</ul>
			<p>Using the values from our initializer list, the output is:</p>
			<p class="source-code"><strong class="bold">vector voi before:</strong></p>
			<p class="source-code"><strong class="bold">    0   -12  2001     4     5   -14   100   200 30000</strong></p>
			<ul>
				<li>Now we can use a <strong class="source-inline">for</strong> loop with <strong class="source-inline">clamp()</strong> to limit the values to between 0 and 500:<p class="source-code">cout &lt;&lt; "vector voi after:\n";</p><p class="source-code">for(auto&amp; e : voi) e = clamp(e, ilow, ihigh);</p><p class="source-code">printc(voi);</p></li>
			</ul>
			<p>This applies the <strong class="source-inline">clamp()</strong> function to each value in the container, using 0 and 500 for the low and high limits, respectively. Now, the output is:</p>
			<p class="source-code"><strong class="bold">vector voi before:</strong></p>
			<p class="source-code"><strong class="bold">    0   -12  2001     4     5   -14   100   200 30000</strong></p>
			<p class="source-code"><strong class="bold">vector voi after:</strong></p>
			<p class="source-code"><strong class="bold">    0     0   500     4     5     0   100   200   500</strong></p>
			<p>After the <strong class="source-inline">clamp()</strong> operation, the negative values are 0 and the values greater than 500 are 500.</p>
			<ul>
				<li>We can <a id="_idIndexMarker533"/>do the same <a id="_idIndexMarker534"/>thing with the <strong class="source-inline">transform()</strong> algorithm, using <strong class="source-inline">clamp()</strong> in a lambda. This time we'll use a <strong class="source-inline">list</strong> container:<p class="source-code">cout &lt;&lt; "list loi before:\n";</p><p class="source-code">list&lt;int&gt; loi{ il };</p><p class="source-code">printc(loi);</p><p class="source-code">transform(loi.begin(), loi.end(), loi.begin(), </p><p class="source-code">    [=](auto e){ return clamp(e, ilow, ihigh); });</p><p class="source-code">cout &lt;&lt; "list loi after:\n";</p><p class="source-code">printc(loi);</p></li>
			</ul>
			<p>The output is the same as in the version with a <strong class="source-inline">for</strong> loop:</p>
			<p class="source-code"><strong class="bold">list loi before:</strong></p>
			<p class="source-code"><strong class="bold">    0   -12  2001     4     5   -14   100   200 30000</strong></p>
			<p class="source-code"><strong class="bold">list loi after:</strong></p>
			<p class="source-code"><strong class="bold">    0     0   500     4     5     0   100   200   500</strong></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>How it works…</h2>
			<p>The <strong class="source-inline">clamp()</strong> algorithm is a simple function that looks something like this:</p>
			<p class="source-code">template&lt;class T&gt;</p>
			<p class="source-code">constexpr const T&amp; clamp( const T&amp; v, const T&amp; lo,</p>
			<p class="source-code">        const T&amp; hi ) {</p>
			<p class="source-code">    return less(v, lo) ? lo : less(hi, v) ? hi : v;</p>
			<p class="source-code">}</p>
			<p>If the value of <strong class="source-inline">v</strong> is less than <strong class="source-inline">lo</strong>, it returns <strong class="source-inline">lo</strong>. If <strong class="source-inline">hi</strong> is less than <strong class="source-inline">v</strong>, it returns <strong class="source-inline">hi</strong>. The function is fast and efficient.</p>
			<p>In our examples, we used a <strong class="source-inline">for</strong> loop to apply <strong class="source-inline">clamp()</strong> to a container:</p>
			<p class="source-code">for(auto&amp; v : voi) v = clamp(v, ilow, ihigh);</p>
			<p>We also used the <strong class="source-inline">transform()</strong> algorithm with <strong class="source-inline">clamp()</strong> in a lambda:</p>
			<p class="source-code">transform(loi.begin(), loi.end(), loi.begin(),</p>
			<p class="source-code">    [=](auto v){ return clamp(v, ilow, ihigh); });</p>
			<p>In my <a id="_idIndexMarker535"/>experiments, both versions <a id="_idIndexMarker536"/>gave the same results, and both produced similar code from the GCC compiler. There was a slight difference in compiled size (the version with the <strong class="source-inline">for</strong> loop was smaller, as expected) and a negligible difference in performance.</p>
			<p>In general, I prefer the <strong class="source-inline">for</strong> loop, but the <strong class="source-inline">transform()</strong> version may be more flexible in other applications.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/>Sample data sets with std::sample</h1>
			<p>The <strong class="source-inline">std::sample()</strong> algorithm takes a random <em class="italic">sample</em> of a sequence of values and populates a <a id="_idIndexMarker537"/>destination container with the sample. It is <a id="_idIndexMarker538"/>useful for analyzing a larger set of data, where the random sample is taken to be representative of the whole.</p>
			<p>A sample set allows us to approximate the characteristics of a large set of data, without analyzing the full set. This provides efficiency in exchange for accuracy, a fair trade-off in many circumstances.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>How to do it…</h2>
			<p>In this recipe, we'll use an array of 200,000 random integers, with <em class="italic">standard normal distribution</em>. We'll sample a few hundred values to create a histogram of the frequency of each value.</p>
			<ul>
				<li>We'll start with a simple function to return a rounded <strong class="source-inline">int</strong> from a <strong class="source-inline">double</strong>. The standard library lacks such a function and we'll need it later:<p class="source-code">int iround(const double&amp; d) {</p><p class="source-code">    return static_cast&lt;int&gt;(std::round(d));</p><p class="source-code">}</p></li>
			</ul>
			<p>The standard library provides several versions of <strong class="source-inline">std::round()</strong>, including one that returns a <strong class="source-inline">long int</strong>. But we need an <strong class="source-inline">int</strong>, and this is a simple solution that avoids compiler warnings about narrowing conversion while hiding away the unsightly <strong class="source-inline">static_cast</strong>.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we'll start with some useful constants:<p class="source-code">int main() {</p><p class="source-code">    constexpr size_t n_data{ 200000 };</p><p class="source-code">    constexpr size_t n_samples{ 500 };</p><p class="source-code">    constexpr int mean{ 0 };</p><p class="source-code">    constexpr size_t dev{ 3 };</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ul>
			<p>We have <a id="_idIndexMarker539"/>values for <strong class="source-inline">n_data</strong> and <strong class="source-inline">n_samples</strong>, used for <a id="_idIndexMarker540"/>the size of the data and sample containers, respectively. We also have values for <strong class="source-inline">mean</strong> and <strong class="source-inline">dev</strong>, the <em class="italic">mean</em> and <em class="italic">standard deviation</em> parameters for the <em class="italic">normal distribution</em> of random values.</p>
			<ul>
				<li>We now set up our <em class="italic">random number generator</em> and <em class="italic">distribution</em> objects. These are used to initialize the source data set:<p class="source-code">std::<strong class="bold">random_device</strong> rd;</p><p class="source-code">std::<strong class="bold">mt19937</strong> rng(rd());</p><p class="source-code">std::<strong class="bold">normal_distribution</strong>&lt;&gt; dist{ mean, dev };</p></li>
			</ul>
			<p>The <strong class="source-inline">random_device</strong> object provides access to the hardware random number generator. The <strong class="source-inline">mt19937</strong> class is an implementation of the <em class="italic">Mersenne Twister</em> random number algorithm, a high-quality algorithm that will perform well on most systems with a data set of the size we're using. The <strong class="source-inline">normal_distribution</strong> class provides a distribution of random numbers around the <em class="italic">mean</em> with the <em class="italic">standard deviation</em> provided.</p>
			<ul>
				<li>Now we populate an array with an <strong class="source-inline">n_data</strong> number of random <strong class="source-inline">int</strong> values:<p class="source-code">array&lt;int, <strong class="bold">n_data</strong>&gt; v{};</p><p class="source-code">for(auto&amp; e : v) e = iround(dist(rng));</p></li>
			</ul>
			<p>The <strong class="source-inline">array</strong> container is fixed in size, so the template parameters include a <strong class="source-inline">size_t</strong> value <a id="_idIndexMarker541"/>for the number of elements to <a id="_idIndexMarker542"/>allocate. We use a <strong class="source-inline">for()</strong> loop to populate the array.</p>
			<p>The <strong class="source-inline">rng</strong> object is the hardware random number generator. This is passed to <strong class="source-inline">dist()</strong>, our <strong class="source-inline">normal_distribution</strong> object, and then to <strong class="source-inline">iround()</strong>, our integer rounding function.</p>
			<ul>
				<li>At this point, we have an array with 200,000 data points. That's a lot to analyze, so we'll use the <strong class="source-inline">sample()</strong> algorithm to take a sample of 500 values:<p class="source-code">array&lt;int, <strong class="bold">n_samples</strong>&gt; samples{};</p><p class="source-code">sample(data.begin(), data.end(), samples.begin(), </p><p class="source-code">    <strong class="bold">n_samples</strong>, rng);</p></li>
			</ul>
			<p>We define another <strong class="source-inline">array</strong> object to hold the samples. This one is <strong class="source-inline">n_samples</strong> in size. Then we use the <strong class="source-inline">sample()</strong> algorithm to populate the array with <strong class="source-inline">n_samples</strong> random data points.</p>
			<ul>
				<li>We create a histogram to analyze the samples. A <strong class="source-inline">map</strong> structure is perfect for this as we can easily map the frequency of each value:<p class="source-code">std::map&lt;int, size_t&gt; hist{};</p><p class="source-code">for (const int i : samples) <strong class="bold">++hist[i]</strong>;</p></li>
			</ul>
			<p>The <strong class="source-inline">for()</strong> loop takes each value from the <strong class="source-inline">samples</strong> container and uses it as a key in the <strong class="source-inline">map</strong>. The increment expression <strong class="source-inline">++hist[i]</strong> counts the number of occurrences of each value in the sample set.</p>
			<ul>
				<li>We print out the histogram using the C++20 <strong class="source-inline">format()</strong> function:<p class="source-code">constexpr size_t scale{ 3 };</p><p class="source-code">cout &lt;&lt; format("<strong class="bold">{:&gt;3}</strong> <strong class="bold">{:&gt;5}</strong> <strong class="bold">{:&lt;}</strong>/{}\n", </p><p class="source-code">    "n", "count", "graph", scale);</p><p class="source-code">for (const auto&amp; [value, count] : hist) {</p><p class="source-code">    cout &lt;&lt; format("<strong class="bold">{:&gt;3}</strong> (<strong class="bold">{:&gt;3}</strong>) {}\n", </p><p class="source-code">        value, count, <strong class="bold">string(count / scale, '*')</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">format()</strong> specifiers that look like <strong class="source-inline">{:&gt;3}</strong> make space for a certain number of characters. The angle bracket specifies alignment, right or left.</p>
			<p>The <strong class="source-inline">string(count, char)</strong> constructor creates a <strong class="source-inline">string</strong> with a character repeated the <a id="_idIndexMarker543"/>number of times specified, in <a id="_idIndexMarker544"/>this case, <em class="italic">n</em> asterisk characters <strong class="source-inline">*</strong>, where <em class="italic">n</em> is <strong class="source-inline">count/scale</strong>, the frequency of a value in the histogram, divided by the <strong class="source-inline">scale</strong> constant.</p>
			<p>The output looks like this:</p>
			<p class="source-code"><strong class="bold">$ ./sample</strong></p>
			<p class="source-code"><strong class="bold">  n count graph/3</strong></p>
			<p class="source-code"><strong class="bold"> -9 (  2)</strong></p>
			<p class="source-code"><strong class="bold"> -7 (  5) *</strong></p>
			<p class="source-code"><strong class="bold"> -6 (  9) ***</strong></p>
			<p class="source-code"><strong class="bold"> -5 ( 22) *******</strong></p>
			<p class="source-code"><strong class="bold"> -4 ( 24) ********</strong></p>
			<p class="source-code"><strong class="bold"> -3 ( 46) ***************</strong></p>
			<p class="source-code"><strong class="bold"> -2 ( 54) ******************</strong></p>
			<p class="source-code"><strong class="bold"> -1 ( 59) *******************</strong></p>
			<p class="source-code"><strong class="bold">  0 ( 73) ************************</strong></p>
			<p class="source-code"><strong class="bold">  1 ( 66) **********************</strong></p>
			<p class="source-code">  <strong class="bold">2 ( 44) **************</strong></p>
			<p class="source-code"><strong class="bold">  3 ( 34) ***********</strong></p>
			<p class="source-code"><strong class="bold">  4 ( 26) ********</strong></p>
			<p class="source-code"><strong class="bold">  5 ( 18) ******</strong></p>
			<p class="source-code"><strong class="bold">  6 (  9) ***</strong></p>
			<p class="source-code"><strong class="bold">  7 (  5) *</strong></p>
			<p class="source-code"><strong class="bold">  8 (  3) *</strong></p>
			<p class="source-code"><strong class="bold">  9 (  1)</strong></p>
			<p>This is a nice graphical representation of the histogram. The first number is the value, the second number is the frequency of the value, and the asterisks are a visual representation of the frequency, where each asterisk represents <strong class="source-inline">scale</strong> (3) occurrences in the sample set.</p>
			<p>Your output will differ each time you run the code.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>How it works…</h2>
			<p>The <strong class="source-inline">std::sample()</strong> function <a id="_idIndexMarker545"/>selects a specific number <a id="_idIndexMarker546"/>of elements from random locations in the source container and copies them to the destination container.</p>
			<p>The signature of <strong class="source-inline">sample()</strong> looks like this:</p>
			<p class="source-code">OutIter sample(SourceIter, SourceIter, OutIter, </p>
			<p class="source-code">    SampleSize, RandNumGen&amp;&amp;);</p>
			<p>The first two arguments are <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators on a container with the full data set. The third <a id="_idIndexMarker547"/>argument is an iterator for the destination <a id="_idIndexMarker548"/>of the samples. The fourth argument is the sample size, and the final argument is a random number generator function.</p>
			<p>The <strong class="source-inline">sample()</strong> algorithm uses <em class="italic">uniform distribution</em>, so each data point has the same chance of being sampled.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Generate permutations of data sequences</h1>
			<p>There are <a id="_idIndexMarker549"/>many use cases for permutations, including <a id="_idIndexMarker550"/>testing, statistics, research, and more. The <strong class="source-inline">next_permutation()</strong> algorithm generates permutations by re-ordering a container to the next <em class="italic">lexicographical</em> permutation.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>How to do it…</h2>
			<p>For this recipe, we will print out the permutations of a set of three strings:</p>
			<ul>
				<li>We'll start by creating a short function for printing the contents of a container:<p class="source-code">void printc(const auto&amp; c, string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : c) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>We'll use this simple function to print our data set and permutations.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we declare a <strong class="source-inline">vector</strong> of <strong class="source-inline">string</strong> objects and sort it with the <strong class="source-inline">sort()</strong> algorithm.<p class="source-code">int main() {</p><p class="source-code">    vector&lt;string&gt; vs{ "dog", "cat", "velociraptor" };</p><p class="source-code">    sort(vs.begin(), vs.end());</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">next_permutation()</strong> function requires a sorted container.</p>
			<ul>
				<li>Now we can list the permutations with <strong class="source-inline">next_permutation()</strong> in a <strong class="source-inline">do</strong> loop:<p class="source-code">do {</p><p class="source-code">    printc(vs);</p><p class="source-code">} while (<strong class="bold">next_permutation(vs.begin(), vs.end())</strong>);</p></li>
			</ul>
			<p>The <strong class="source-inline">next_permutation()</strong> function modifies the container and returns <strong class="source-inline">true</strong> if there is another permutation, or <strong class="source-inline">false</strong> if not.</p>
			<p>The output lists six permutations of our three pets:</p>
			<p class="source-code"><strong class="bold">cat dog velociraptor</strong></p>
			<p class="source-code"><strong class="bold">cat velociraptor dog</strong></p>
			<p class="source-code"><strong class="bold">dog cat velociraptor</strong></p>
			<p class="source-code"><strong class="bold">dog velociraptor cat</strong></p>
			<p class="source-code"><strong class="bold">velociraptor cat dog</strong></p>
			<p class="source-code"><strong class="bold">velociraptor dog cat</strong></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>How it works…</h2>
			<p>The <strong class="source-inline">std::next_permutation()</strong> algorithm generates <em class="italic">lexicographical</em> permutations of a set of values, that is, permutations based on dictionary ordering. The input must <a id="_idIndexMarker551"/>be sorted because the algorithm <a id="_idIndexMarker552"/>steps through permutations in lexicographical order. So, if you start with a set like 3, 2, 1, it will terminate immediately as this is the last lexicographical order of those three elements.</p>
			<p>For example:</p>
			<p class="source-code">vector&lt;string&gt; vs{ "velociraptor", "dog", "cat" };</p>
			<p class="source-code">do {</p>
			<p class="source-code">    printc(vs);</p>
			<p class="source-code">} while (next_permutation(vs.begin(), vs.end()));</p>
			<p>This gives us the following output:</p>
			<p class="source-code">velociraptor dog cat</p>
			<p>While the term <em class="italic">lexicographical</em> implies alphabetical ordering, the implementation uses standard comparison operators, so it works on any sortable values.</p>
			<p>Likewise, if values in the set repeat, they are only counted according to <em class="italic">lexicographical</em> order. Here we have a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong> with two repeating sequences of five values:</p>
			<p class="source-code">vector&lt;int&gt; vi{ 1, 2, 3, 4, 5, 1, 2, 3, 4, 5 };</p>
			<p class="source-code">sort(vi.begin(), vi.end());</p>
			<p class="source-code">printc(vi, "vi sorted");</p>
			<p class="source-code">long <strong class="bold">count</strong>{};</p>
			<p class="source-code">do {</p>
			<p class="source-code">    <strong class="bold">++count</strong>;</p>
			<p class="source-code">} while (next_permutation(vi.begin(), vi.end()));</p>
			<p class="source-code">cout &lt;&lt; format("number of permutations: {}\n", <strong class="bold">count</strong>);</p>
			<p>Output:</p>
			<p class="source-code">Vi sorted: 1 1 2 2 3 3 4 4 5 5</p>
			<p class="source-code">number of permutations: 113400</p>
			<p>There are 113,400 permutations of these values. Notice that it's not <em class="italic">10!</em> (3,628,800) because some <a id="_idIndexMarker553"/>values repeat. Since <em class="italic">3,3</em> and <em class="italic">3,3</em> sort <a id="_idIndexMarker554"/>the same, they are not different <em class="italic">lexicographical</em> permutations.</p>
			<p>In other words, if I list the permutations of this short set:</p>
			<p class="source-code">vector&lt;int&gt; vi2{ 1, 3, 1 };</p>
			<p class="source-code">sort(vi2.begin(), vi2.end());</p>
			<p class="source-code">do {</p>
			<p class="source-code">    printc(vi2);</p>
			<p class="source-code">} while (next_permutation(vi2.begin(), vi2.end()));</p>
			<p>We get only three permutations, not <em class="italic">3!</em> (9), because of the repeating values:</p>
			<p class="source-code">1 1 3</p>
			<p class="source-code">1 3 1</p>
			<p class="source-code">3 1 1</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor209"/>Merge sorted containers</h1>
			<p>The <strong class="source-inline">std::merge()</strong> algorithm takes two sorted sequences and creates a third merged and sorted sequence. This technique <a id="_idIndexMarker555"/>is often used as part of a <em class="italic">merge sort</em>, allowing <a id="_idIndexMarker556"/>very large amounts of data to be broken down into chunks, sorted separately, and merged into one sorted target.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>How to do it…</h2>
			<p>For this recipe, we'll take two sorted <strong class="source-inline">vector</strong> containers and merge them into a third <strong class="source-inline">vector</strong> using <strong class="source-inline">std::merge()</strong>.</p>
			<ul>
				<li>We'll start with a simple function to print the contents of a container:<p class="source-code">void printc(const auto&amp; c, string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : c) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>We'll use this to print the source and destination sequences.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we'll declare our source vectors, along with the destination vector, and print them out:<p class="source-code">int main() {</p><p class="source-code">    vector&lt;string&gt; vs1{ "dog", "cat", </p><p class="source-code">      "velociraptor" };</p><p class="source-code">    vector&lt;string&gt; vs2{ "kirk", "sulu", "spock" };</p><p class="source-code">    vector&lt;string&gt; dest{};</p><p class="source-code">    printc(vs1, "vs1");</p><p class="source-code">    printc(vs2, "vs2");</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ul>
			<p>The output is:</p>
			<p class="source-code"><strong class="bold">vs1: dog cat velociraptor</strong></p>
			<p class="source-code"><strong class="bold">vs2: kirk sulu spock</strong></p>
			<ul>
				<li>Now we can sort our vectors and print them again:<p class="source-code">sort(vs1.begin(), vs1.end());</p><p class="source-code">sort(vs2.begin(), vs2.end());</p><p class="source-code">printc(vs1, "vs1 sorted");</p><p class="source-code">printc(vs2, "vs2 sorted");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">vs1 sorted: cat dog velociraptor</strong></p>
			<p class="source-code"><strong class="bold">vs2 sorted: kirk spock sulu</strong></p>
			<ul>
				<li>Now that our <a id="_idIndexMarker557"/>source containers are sorted, we can merge <a id="_idIndexMarker558"/>them for our final merged result:<p class="source-code">merge(vs1.begin(), vs1.end(), vs2.begin(), vs2.end(), </p><p class="source-code">    back_inserter(dest));</p><p class="source-code">printc(dest, "dest");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">dest: cat dog kirk spock sulu velociraptor</strong></p>
			<p>This output represents the merge of the two sources into one sorted vector.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>How it works…</h2>
			<p>The <strong class="source-inline">merge()</strong> algorithm <a id="_idIndexMarker559"/>takes <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators from <a id="_idIndexMarker560"/>both the sources and an output iterator for the destination:</p>
			<p class="source-code">OutputIt merge(InputIt1, InputIt1, InputIt2, InputIt2, OutputIt)</p>
			<p>It takes the two input ranges, performs its merge/sort operation, and sends the resulting sequence to the output iterator.</p>
		</div>
	</body></html>