<html><head></head><body>
		<div><h1 id="_idParaDest-182"><em class="italic"><a id="_idTextAnchor181"/>Chapter 6</em>: STL Algorithms</h1>
			<p>Much of the power of the STL is in the standardization of container interfaces. If a container has a particular capability, there's a good chance that the interface for that capability is standardized across container types. This standardization makes possible a library of <em class="italic">algorithms</em> that operate seamlessly across containers and sequences sharing a common interface.</p>
			<p>For example, if we want to sum all the elements in a <code>vector</code> of <code>int</code>, we could use a loop:</p>
			<pre>vector&lt;int&gt; x { 1, 2, 3, 4, 5 };
long sum{};
for( int i : x ) sum += i;                     // sum is 15</pre>
			<p>Or we could use an algorithm:</p>
			<pre>vector&lt;int&gt; x { 1, 2, 3, 4, 5 };
auto sum = accumulate(x.begin(), x.end(), 0);  // sum is 15</pre>
			<p>This same syntax works with other containers:</p>
			<pre>deque&lt;int&gt; x { 1, 2, 3, 4, 5 };
auto sum = accumulate(x.begin(), x.end(), 0);  // sum is 15</pre>
			<p>The algorithm version is not necessarily shorter, but it is easier to read and easier to maintain. And an algorithm is often more efficient than the equivalent loop.</p>
			<p>Beginning with C++20, the <code>ranges</code> library provides a set of alternative algorithms that operate with <em class="italic">ranges</em> and <em class="italic">views</em>. This book will demonstrate those alternatives where appropriate. For more information on ranges and views, refer to the recipe <em class="italic">Create views into containers with ranges</em> in <a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>, of this book.</p>
			<p>Most of the algorithms are in the <code>algorithm</code> header. Some numeric algorithms, notably <code>accumulate()</code>, are in the <code>numeric</code> header, and some memory-related algorithms are in the <code>memory</code> header.</p>
			<p>We will cover STL algorithms in the following recipes:</p>
			<ul>
				<li>Copy from one iterator to another</li>
				<li>Join container elements into a string</li>
				<li>Sort containers with <code>std::sort</code></li>
				<li>Modify containers with <code>std::transform</code></li>
				<li>Find items in a container</li>
				<li>Limit the values of a container to a range with <code>std::clamp</code></li>
				<li>Sample data sets with <code>std::sample</code></li>
				<li>Generate permutations of data sequences</li>
				<li>Merge sorted containers</li>
			</ul>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06</a>.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Copy from one iterator to another</h1>
			<p>The <em class="italic">copy algorithms</em> are <a id="_idIndexMarker481"/>generally used to copy from and to containers, but in fact, they work with iterators, which is far more flexible.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>How to do it…</h2>
			<p>In this recipe, we will experiment with <code>std::copy</code> and <code>std::copy_n</code> to get a good understanding of how they work:</p>
			<ul>
				<li>Let's start with a function to print a container:<pre>void printc(auto&amp; c, string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : c) cout &lt;&lt; format("[{}] ", e);
    cout &lt;&lt; '\n';
}</pre></li>
				<li>In <code>main()</code>, we define a <code>vector</code> and print it with <code>printc()</code>:<pre>int main() {
    vector&lt;string&gt; v1
        { "alpha", "beta", "gamma", "delta", 
          "epsilon" };
    printc(v1);
}</pre></li>
			</ul>
			<p>We get this output:</p>
			<pre><strong class="bold">v1: [alpha] [beta] [gamma] [delta] [epsilon]</strong></pre>
			<ul>
				<li>Now, let's <a id="_idIndexMarker482"/>create a second <code>vector</code> with enough space to copy the first <code>vector</code>:<pre>vector&lt;string&gt; v2(v1.size());</pre></li>
				<li>We can copy <code>v1</code> to <code>v2</code> using the <code>std::copy()</code> algorithm:<pre>std::copy(v1.begin(), v1.end(), v2.begin());
printc(v2);</pre></li>
			</ul>
			<p>The <code>std::copy()</code> algorithm takes two iterators for the range of the copy source, and one iterator for the destination. In this case, we give it the <code>begin()</code> and <code>end()</code> iterators of <code>v1</code> to copy the entire <code>vector</code>. The <code>begin()</code> iterator of <code>v2</code> serves as the destination for the copy.</p>
			<p>Our output is now:</p>
			<pre><strong class="bold">v1: [alpha] [beta] [gamma] [delta] [epsilon]</strong>
<strong class="bold">v2: [alpha] [beta] [gamma] [delta] [epsilon]</strong></pre>
			<ul>
				<li>The <code>copy()</code> algorithm does not allocate space for the destination. So, <code>v2</code> must already have the space for the copy. Alternately, you can use the <code>back_inserter()</code> iterator adapter to insert the elements at the back of the <code>vector</code>:<pre>vector&lt;string&gt; v2{};
std::copy(v1.begin(), v1.end(), back_inserter(v2))</pre></li>
				<li>We can also use the <code>ranges::copy()</code> algorithm to copy an entire <em class="italic">range</em>. A container <a id="_idIndexMarker483"/>object serves as a range so we can use <code>v1</code> as the source. We still use an iterator for the destination:<pre>vector&lt;string&gt; v2(v1.size());
ranges::copy(v1, v2.begin());</pre></li>
			</ul>
			<p>This also works with <code>back_inserter()</code>:</p>
			<pre>vector&lt;string&gt; v2{};
ranges::copy(v1, back_inserter(v2));</pre>
			<p>Output:</p>
			<pre><strong class="bold">v2: [alpha] [beta] [gamma] [delta] [epsilon]</strong></pre>
			<ul>
				<li>You can copy a certain number of elements using <code>copy_n()</code>:<pre>vector&lt;string&gt; v3{};
std::copy_n(v1.begin(), 3, back_inserter(v3));
printc(v3, "v3");</pre></li>
			</ul>
			<p>In the second argument, the <code>copy_n()</code> algorithm is a <em class="italic">count</em> for the number of elements to copy. The output is:</p>
			<pre><strong class="bold">v3: [alpha] [beta] [gamma]</strong></pre>
			<ul>
				<li>There's also a <code>copy_if()</code> algorithm that uses a Boolean <em class="italic">predicate function</em> to determine which elements to copy:<pre>vector&lt;string&gt; v4{};
std::copy_if(v1.begin(), v1.end(), back_inserter(v4), 
    [](string&amp; s){ return s.size() &gt; 4; });
printc(v4, "v4");</pre></li>
			</ul>
			<p>There's also a <code>ranges</code> version of <code>copy_if()</code>:</p>
			<pre>vector&lt;string&gt; v4{};
ranges::copy_if(v1, back_inserter(v4), 
    [](string&amp; s){ return s.size() &gt; 4; });
printc(v4, "v4");</pre>
			<p>The <a id="_idIndexMarker484"/>output includes only strings longer than <code>4</code> characters:</p>
			<pre><strong class="bold">v4: [alpha] [gamma] [delta] [epsilon]</strong></pre>
			<p>Notice that the value <code>beta</code> is excluded.</p>
			<ul>
				<li>You can use any of these algorithms to copy to or from any sequence, including a stream iterator:<pre>ostream_iterator&lt;string&gt; out_it(cout, " ");
ranges::copy(v1, out_it)
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">alpha beta gamma delta epsilon</strong></pre>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>How it works…</h2>
			<p>The <code>std::copy()</code> algorithm is very simple. An equivalent function would look like this:</p>
			<pre>template&lt;typename Input_it, typename Output_it&gt;
Output_it bw_copy(Input_it begin_it, Input_it end_it, 
                  Output_it dest_it) {
    while (begin_it != end_it) {
        *dest_it++ = *begin_it++;
    }
    return dest_it;
}</pre>
			<p>The <code>copy()</code> function uses the destination iterator's assignment operator to copy from the input iterator to the output iterator until it reaches the end of the input range.</p>
			<p>There is also a version of this algorithm called <code>std::move()</code>, which moves elements instead of copying them:</p>
			<pre>std::move(v1.begin(), v1.end(), v2.begin());
printc(v1, "after move: v1");
printc(v2, "after move: v2");</pre>
			<p>This <a id="_idIndexMarker485"/>performs a move instead of copy assignment. After the move operation, the elements in <code>v1</code> will be empty, and the elements that were in <code>v1</code> are now in <code>v2</code>. The output looks like this:</p>
			<pre>after move1: v1: [] [] [] [] []
after move1: v2: [alpha] [beta] [gamma] [delta] [epsilon]</pre>
			<p>There is also a <code>ranges</code> version of the <code>move()</code> algorithm that performs the same operation:</p>
			<pre>ranges::move(v1, v2.begin());</pre>
			<p>The power of these algorithms lies in their simplicity. By letting the iterators manage the data, these simple, elegant functions allow you to seamlessly copy or move between any of the STL containers that support the required iterators.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Join container elements into a string</h1>
			<p>Sometimes, there is <a id="_idIndexMarker486"/>no algorithm in the library to accomplish <a id="_idIndexMarker487"/>a task at hand. We can use iterators, with the same techniques as the <code>algorithms</code> library, to easily write one.</p>
			<p>For example, we often need to join elements from a container, with separators, into a string. One common solution is to use a simple <code>for()</code> loop:</p>
			<pre>for(auto v : c) cout &lt;&lt; v &lt;&lt; ', ';</pre>
			<p>The problem with this otherwise simple solution is that it leaves a trailing separator:</p>
			<pre>vector&lt;string&gt; greek{ "alpha", "beta", "gamma", 
                      "delta", "epsilon" };
for(auto v : greek) cout &lt;&lt; v &lt;&lt; ", ";
cout &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>alpha, beta, gamma, delta, epsilon,</pre>
			<p>This may be <a id="_idIndexMarker488"/>fine in a testing environment, but in any <a id="_idIndexMarker489"/>production system, that trailing comma is unacceptable.</p>
			<p>The <code>ranges::views</code> library has a <code>join()</code> function, but it doesn't provide a separator:</p>
			<pre>auto <strong class="bold">greek_view</strong> = views::join(greek);</pre>
			<p>The <code>views::join()</code> function returns a <code>ranges::view</code> object. This requires a separate step to display or turn into a string. We can cycle through the view with a <code>for()</code> loop:</p>
			<pre>for(const char c : <strong class="bold">greek_view</strong>) cout &lt;&lt; c;
cout &lt;&lt; '\n';</pre>
			<p>The output looks like this:</p>
			<pre>alphabetagammadeltaepsilon</pre>
			<p>It's all there, but we need a proper separator between the elements to make it useful for our purposes.</p>
			<p>Since the <code>algorithms</code> library does not have a function that suits our needs, we'll write one.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>How to do it…</h2>
			<p>For this recipe, we will take the elements of a container and join them into a string with separators:</p>
			<ul>
				<li>In our <code>main()</code> function, we declare a vector of strings:<pre>int main() {
    vector&lt;string&gt; greek{ "alpha", "beta", "gamma",
        "delta", "epsilon" };
    ...
}</pre></li>
				<li>Now, let's <a id="_idIndexMarker490"/>write a simple <code>join()</code> function <a id="_idIndexMarker491"/>that uses an <code>ostream</code> object to join elements with a separator:<pre>namespace bw {
    template&lt;typename I&gt;
    ostream&amp; join(I it, I end_it, ostream&amp; o, 
                  string_view sep = "") {
        if(it != end_it) o &lt;&lt; *it++;
        while(it != end_it) o &lt;&lt; sep &lt;&lt; *it++;
        return o;
    }
}</pre></li>
			</ul>
			<p>I've put this in my own <code>bw</code> namespace to avoid name collisions.</p>
			<p>We can call it with <code>cout</code> like this:</p>
			<pre>bw::join(greek.begin(), greek.end(), cout, ", ") &lt;&lt; '\n';</pre>
			<p>Because it returns the <code>ostream</code> object, we can follow it with <code>&lt;&lt;</code> to add a <em class="italic">newline</em> to the stream.</p>
			<p>Output:</p>
			<pre><strong class="bold">alpha, beta, gamma, delta, epsilon</strong></pre>
			<ul>
				<li>We'll often <a id="_idIndexMarker492"/>want a <code>string</code>, instead of <a id="_idIndexMarker493"/>directly writing to <code>cout</code>. We can overload this function for a version that returns a <code>string</code> object:<pre>template&lt;typename I&gt;
string join(I it, I end_it, string_view sep = "") {
    ostringstream ostr;
    join(it, end_it, ostr, sep);
    return ostr.str();
}</pre></li>
			</ul>
			<p>This also goes in the <code>bw</code> namespace. This function creates an <code>ostringstream</code> object to pass to the <code>ostream</code> version of <code>bw::join()</code>. It returns a <code>string</code> object from the <code>str()</code> method of the <code>ostringstream</code> object.</p>
			<p>We can use it like this:</p>
			<pre>string s = bw::join(greek.begin(), greek.end(), ", ");
cout &lt;&lt; s &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre><strong class="bold">alpha, beta, gamma, delta, epsilon</strong></pre>
			<ul>
				<li>Let's add one final overload to make this easier to use:<pre>string join(const auto&amp; c, string_view sep = "") {
    return join(begin(c), end(c), sep);
}</pre></li>
			</ul>
			<p>This version just takes a container and a separator, which should satisfy most use cases nicely:</p>
			<pre>string s = bw::join(greek, ", ");
cout &lt;&lt; s &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre><strong class="bold">alpha, beta, gamma, delta, epsilon</strong></pre>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>How it works…</h2>
			<p>Most of <a id="_idIndexMarker494"/>the work in this recipe is done by the <a id="_idIndexMarker495"/>iterators and the <code>ostream</code> object:</p>
			<pre>namespace bw {
    template&lt;typename I&gt;
    ostream&amp; join(I it, I end_it, ostream&amp; o, 
                  string_view sep = "") {
        if(it != end_it) <strong class="bold">o &lt;&lt; *it++</strong>;
        while(it != end_it) <strong class="bold">o &lt;&lt; sep &lt;&lt; *it++</strong>;
        <strong class="bold">return o</strong>;
    }
}</pre>
			<p>The separators go after the first element, between each of the successive elements, and stop before the final element. This means we can either add a separator <em class="italic">before</em> each element, skipping the first, or <em class="italic">after</em> each element, skipping the last. The logic is simpler if we test for, and skip, the first element. We do that in the line just before the <code>while()</code> loop:</p>
			<pre>if(it != end_it) <strong class="bold">o &lt;&lt; *it++</strong>;</pre>
			<p>Once we have the first element out of the way, we can simply add a separator before each remaining element:</p>
			<pre>while(it != end_it) <strong class="bold">o &lt;&lt; sep &lt;&lt; *it++</strong>;</pre>
			<p>We <a id="_idIndexMarker496"/>return the <code>ostream</code> object as a convenience. This <a id="_idIndexMarker497"/>allows the user to easily add a newline, or other objects, to the stream:</p>
			<pre>bw::join(greek.begin(), greek.end(), cout, ", ") <strong class="bold">&lt;&lt;</strong> '\n';</pre>
			<p>Output:</p>
			<pre>alpha, beta, gamma, delta, epsilon</pre>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>There's more…</h2>
			<p>As with any of the library <a id="_idIndexMarker498"/>algorithms, the <code>join()</code> function will work with any <a id="_idIndexMarker499"/>container that supports <em class="italic">forward iterators</em>. For example, here's a <code>list</code> of <code>double</code> constants from the <code>numbers</code> library:</p>
			<pre>namespace num = std::numbers;
list&lt;double&gt; constants { num::pi, num::e, num::sqrt2 };
cout &lt;&lt; bw::join(constants, ", ") &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>3.14159, 2.71828, 1.41421</pre>
			<p>It will even work with a <code>ranges::view</code> object, like the <code>greek_view</code> defined earlier in this recipe:</p>
			<pre>cout &lt;&lt; bw::join(greek_view, ":") &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>a:l:p:h:a:b:e:t:a:g:a:m:m:a:d:e:l:t:a:e:p:s:i:l:o:n</pre>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Sort containers with std::sort</h1>
			<p>The problem of how <a id="_idIndexMarker500"/>to efficiently sort comparable elements is essentially solved. For most applications, there's no reason to re-invent this wheel. The STL provides an excellent sorting solution via the <code>std::sort()</code> algorithm. While the standard does not specify a <a id="_idIndexMarker501"/>sorting algorithm, it does specify a worst-case complexity of <em class="italic">O</em>(<em class="italic">n</em> log <em class="italic">n</em>), when applied to a range of <em class="italic">n</em> elements.</p>
			<p>Just a few decades ago, the <em class="italic">quicksort</em> algorithm was considered a good compromise for most uses and was generally faster than other comparable algorithms. Today we have <em class="italic">hybrid</em> algorithms that choose between different approaches according to the circumstances, often switching algorithms on the fly. Most current C++ libraries use a hybrid approach with some combination of <em class="italic">introsort</em> and an <em class="italic">insertion sort</em>. <code>std::sort()</code> provides exceptional performance under most common circumstances.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>How to do it…</h2>
			<p>In this recipe, we'll examine the <code>std::sort()</code> algorithm. The <code>sort()</code> algorithm works with any <a id="_idIndexMarker502"/>container with random-access iterators. Here, we will use a <code>vector</code> of <code>int</code>:</p>
			<ul>
				<li>We'll start with a function to test if a container is sorted:<pre>void check_sorted(auto &amp;c) {
    if(!is_sorted(c.begin(), c.end())) cout &lt;&lt; "un";
    cout &lt;&lt; "sorted: ";
}</pre></li>
			</ul>
			<p>This uses the <code>std::is_sorted()</code> algorithm and prints either <code>"sorted:"</code> or <code>"unsorted:"</code> according to the result.</p>
			<ul>
				<li>We'll need a function to print our <code>vector</code>:<pre>void printc(const auto &amp;c) {
    check_sorted(c);
    for(auto&amp; e : c) cout &lt;&lt; e &lt;&lt; ' ';
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>This function calls <code>check_sorted()</code> to display the status of the container before the value.</p>
			<ul>
				<li>Now we can define and print a <code>vector</code> of <code>int</code> in the <code>main()</code> function:<pre>int main() {
    vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    printc(v);
    …
}</pre></li>
			</ul>
			<p>The output looks like this:</p>
			<pre><strong class="bold">sorted: 1 2 3 4 5 6 7 8 9 10</strong></pre>
			<ul>
				<li>In order to <a id="_idIndexMarker503"/>test the <code>std::sort()</code> algorithm, we need an unsorted vector. Here's a simple function to randomize our container:<pre>void randomize(auto&amp; c) {
    static std::random_device rd;
    static std::default_random_engine rng(rd());
    std::shuffle(c.begin(), c.end(), rng);
}</pre></li>
			</ul>
			<p>The <code>std::random_device</code> class uses your system's hardware <em class="italic">entropy</em> source. Most modern systems have one, otherwise the library will simulate it. The <code>std::default_random_engine()</code> function generates random numbers from the entropy source. This is used by <code>std::shuffle()</code> to randomize the container.</p>
			<p>We can now call <code>randomize()</code> with our container and print the result:</p>
			<pre>randomize(v);
printc(v);</pre>
			<p>Output:</p>
			<pre><strong class="bold">unsorted: 6 3 4 8 10 1 2 5 9 7</strong></pre>
			<p>Of course, your output will be different because it's randomized. In fact, I get a different result every time I run it:</p>
			<pre>for(int i{3}; i; --i) {
    randomize(v);
    printc(v);
}</pre>
			<p>Output:</p>
			<pre><strong class="bold">unsorted: 3 1 8 5 10 2 7 9 6 4</strong>
<strong class="bold">unsorted: 7 6 5 1 3 9 10 2 4 8</strong>
<strong class="bold">unsorted: 4 2 3 10 1 9 5 6 8 7</strong></pre>
			<ul>
				<li>To sort the <a id="_idIndexMarker504"/>vector, we simply call <code>std::sort()</code>:<pre>std::sort(v.begin(), v.end());
printc(v);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">sorted: 1 2 3 4 5 6 7 8 9 10</strong></pre>
			<p>By default, the <code>sort()</code> algorithm uses the <code>&lt;</code> operator to sort the elements in the range specified by the supplied iterators.</p>
			<ul>
				<li>The <code>partial_sort()</code> algorithm will sort part of the container:<pre>cout &lt;&lt; "partial_sort:\n";
randomize(v);
auto middle{ v.begin() + (v.size() / 2) };
std::partial_sort(v.begin(), middle, v.end());
printc(v);</pre></li>
			</ul>
			<p><code>partial_sort()</code> takes three iterators: beginning, middle, and end. It sorts the container such that the elements before the middle are sorted. The elements after the middle are not guaranteed to be in the original order. Here's the output:</p>
			<pre><strong class="bold">unsorted: 1 2 3 4 5 10 7 6 8 9</strong></pre>
			<p>Notice that the first five elements are sorted, and the rest are not.</p>
			<ul>
				<li>The <code>partition()</code> algorithm <em class="italic">does not</em> sort anything. It rearranges the container so <a id="_idIndexMarker505"/>that certain elements appear at the front of the container:<pre>coutrandomize(v);
printc(v);
partition(v.begin(), v.end(), [](int i)
    { return i &gt; 5; });
printc(v);</pre></li>
			</ul>
			<p>The third argument is a <em class="italic">predicate</em> lambda that determines which elements will be moved to the front.</p>
			<p>Output:</p>
			<pre><strong class="bold">unsorted: 4 6 8 1 9 5 2 7 3 10</strong>
<strong class="bold">unsorted: 10 6 8 7 9 5 2 1 3 4</strong></pre>
			<p>Notice that the values <code>&gt;5</code> are moved to the front of the container.</p>
			<ul>
				<li>The <code>sort()</code> algorithms support an optional comparison function that may be used for non-standard comparisons. For example, given a class called <code>things</code>:<pre>struct things {
    string s_;
    int i_;
    string str() const {
        return format("({}, {})", s_, i_);
    }
};</pre></li>
			</ul>
			<p>We can create a <code>vector</code> of <code>things</code>:</p>
			<pre>vector&lt;things&gt; vthings{ {"button", 40},
    {"hamburger", 20}, {"blog", 1000},
    {"page", 100}, {"science", 60} };</pre>
			<p>We'll need a <a id="_idIndexMarker506"/>function to print them out:</p>
			<pre>void print_things(const auto&amp; c) {
    for (auto&amp; v : c) cout &lt;&lt; v.str() &lt;&lt; ' ';
    cout &lt;&lt; '\n';
}</pre>
			<ul>
				<li>Now we can sort and print the <code>vector</code> of <code>things</code>:<pre>std::sort(vthings.begin(), vthings.end(), 
        [](const things &amp;lhs, const things &amp;rhs) {
    return lhs.i_ &lt; rhs.i_;
});
print_things(vthings);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">(hamburger, 20) (button, 40) (science, 60) (page, 100) (blog, 1000)</strong></pre>
			<p>Notice the comparison function sorts on the <code>i_</code> member, so the result is sorted by <code>i_</code>. We could instead sort on the <code>s_</code> member:</p>
			<pre>std::sort(vthings.begin(), vthings.end(), 
        [](const things &amp;lhs, const things &amp;rhs) {
    return lhs.s_ &lt; rhs.s_;
});
print_things(vthings);</pre>
			<p>Now we get this output:</p>
			<pre><strong class="bold">(blog, 1000) (button, 40) (hamburger, 20) (page, 100) (science, 60)</strong></pre>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>How it works…</h2>
			<p>The <code>sort()</code> functions work by applying a sorting algorithm to a range of elements indicated by two iterators, for the beginning and end of the range.</p>
			<p>By default, these algorithms use the <code>&lt;</code> operator to compare elements. Optionally, they may use a <em class="italic">comparison function</em>, often provided as a lambda:</p>
			<pre>std::sort(vthings.begin(), vthings.end(), 
        [](const things&amp; lhs, const things&amp; rhs) {
    return lhs.i_ &lt; rhs.i_;
});</pre>
			<p>The comparison function takes two arguments and returns a <code>bool</code>. It has a signature equivalent to this:</p>
			<pre>bool cmp(const Type1&amp; a, const Type2&amp; b);</pre>
			<p>The <code>sort()</code> functions use <code>std::swap()</code> to move elements. This is efficient in both compute cycles and <a id="_idIndexMarker507"/>memory usage, as it relieves the need to allocate space for reading and writing the objects being sorted. This is also why the <code>partial_sort()</code> and <code>partition()</code> functions cannot guarantee the order of unsorted elements.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Modify containers with std::transform</h1>
			<p>The <code>std::transform()</code> function is remarkably powerful and flexible. One of the more commonly <a id="_idIndexMarker508"/>deployed algorithms in the <a id="_idIndexMarker509"/>library, it applies a <em class="italic">function</em> or <em class="italic">lambda</em> to each element in a container, storing the results in another container while leaving the original in place.</p>
			<p>Given its power, it's deceptively simple to use.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>How to do it…</h2>
			<p>In this recipe, we will explore a few applications for the <code>std::transform()</code> function:</p>
			<ul>
				<li>We'll start with a simple function that prints the contents of a container:<pre>void printc(auto&amp; c, string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : c) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>We'll use this to view the results of our transformations.</p>
			<ul>
				<li>In the <code>main()</code> function, let's declare a couple of vectors:<pre>int main() {
    vector&lt;int&gt; v1{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    vector&lt;int&gt; v2;
    printc(v1, "v1");
    ...
}</pre></li>
			</ul>
			<p>This prints out the contents of <code>v1</code>:</p>
			<pre><strong class="bold">v1: 1 2 3 4 5 6 7 8 9 10</strong></pre>
			<ul>
				<li>Now we can use the <code>transform()</code> function to insert the square of each value into <code>v2</code>:<pre>cout &lt;&lt; "squares:\n";
transform(v1.begin(), v1.end(), back_inserter(v2),
    [](int x){ return x * x; });
printc(v2, "v2");</pre></li>
			</ul>
			<p>The <code>transform()</code> function takes four arguments. The first two are the <code>begin()</code> and <code>end()</code> iterators for the source range. The third argument is the <code>begin()</code> iterator for the destination range. In this case, we're using the <code>back_inserter()</code> algorithm to insert the results in <code>v2</code>. The fourth argument is <a id="_idIndexMarker510"/>the transformation <a id="_idIndexMarker511"/>function. In this case, we're using a simple lambda to square the value.</p>
			<p>Output:</p>
			<pre><strong class="bold">squares:</strong>
<strong class="bold">v2: 1 4 9 16 25 36 49 64 81 100</strong></pre>
			<ul>
				<li>Of course, we can use <code>transform()</code> with any type. Here's an example that converts a <code>vector</code> of <code>string</code> objects to lowercase. First, we need a function to return the lowercase value of a string:<pre>string str_lower(const string&amp; s) {
    string outstr{};
    for(const char&amp; c : s) {
        outstr += tolower(c);
    }
    return outstr;
}</pre></li>
			</ul>
			<p>Now we can use the <code>str_lower()</code> function with transform:</p>
			<pre>vector&lt;string&gt; vstr1{ "Mercury", "Venus", "Earth",
    "Mars", "Jupiter", "Saturn", "Uranus", "Neptune",
    "Pluto" };
vector&lt;string&gt; vstr2;
printc(vstr1, "vstr1");
cout &lt;&lt; "str_lower:\n";
transform(vstr1.begin(), vstr1.end(),
    back_inserter(vstr2), 
    [](string&amp; x){ return str_lower(x); });
printc(vstr2, "vstr2");</pre>
			<p>This <a id="_idIndexMarker512"/>calls <code>str_lower()</code> for every <a id="_idIndexMarker513"/>element in <code>vstr1</code> and inserts the results into <code>vstr2</code>. The result is:</p>
			<pre><strong class="bold">vstr: Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto</strong>
<strong class="bold">str_lower:</strong>
<strong class="bold">vstr: mercury venus earth mars jupiter saturn uranus neptune pluto</strong></pre>
			<p>(Yes, Pluto will always be a planet to me.)</p>
			<ul>
				<li>There's also a <code>ranges</code> version of transform:<pre>cout &lt;&lt; "ranges squares:\n";
auto view1 = views::transform(v1, [](int x){ 
    return x * x; });
printc(view1, "view1");</pre></li>
			</ul>
			<p>The <code>ranges</code> version has a more succinct syntax and returns a <code>view</code> object, rather than populating another container.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>How it works…</h2>
			<p>The <code>std::transform()</code> function works very much like <code>std::copy()</code>, with the addition of the user-provided function. Each element in the input range is passed to the function, and the <a id="_idIndexMarker514"/>return value from the function <a id="_idIndexMarker515"/>is copy-assigned to the destination iterator. This makes <code>transform()</code> a singularly useful and powerful algorithm.</p>
			<p>It's worth noting that <code>transform()</code> does not guarantee the elements will be processed in order. If you need to ensure the order of the transformation, you will want to use a <code>for</code> loop instead:</p>
			<pre>v2.clear();    // reset vector v2 to empty state
for(auto e : v1) v2.push_back(e * e);
printc(v2, "v2");</pre>
			<p>Output:</p>
			<pre>v2: 1 4 9 16 25 36 49 64 81 100</pre>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor196"/>Find items in a container</h1>
			<p>The <code>algorithm</code> library <a id="_idIndexMarker516"/>contains a set of functions for finding elements <a id="_idIndexMarker517"/>in a container. The <code>std::find()</code> function, and its derivatives, search sequentially through a container and return an iterator pointing to the first matching element, or the <code>end()</code> element if there's no match.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>How to do it…</h2>
			<p>The <code>find()</code> algorithm works <a id="_idIndexMarker518"/>with any container that satisfies the <em class="italic">Forward</em> or <em class="italic">Input</em> iterator qualifications. For this recipe, we'll use <code>vector</code> containers. The <code>find()</code> algorithm searches sequentially for the first matching element in a container. In this recipe, we'll walk through a few examples:</p>
			<ul>
				<li>We'll start by declaring a <code>vector</code> of <code>int</code> in the <code>main()</code> function:<pre>int main() {
    const vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    ...
}</pre></li>
				<li>Now, let's search for the element with the value <code>7</code>:<pre>auto it1 = <strong class="bold">find(v.begin(), v.end(), 7)</strong>;
<strong class="bold">if(it1 != v.end())</strong> cout &lt;&lt; format("found: {}\n", *it1);
else cout &lt;&lt; "not found\n";</pre></li>
			</ul>
			<p>The <code>find()</code> algorithm takes three arguments: the <code>begin()</code> and <code>end()</code> iterators, and the <a id="_idIndexMarker519"/>value to search. It returns an iterator to the <a id="_idIndexMarker520"/>first element it finds, or the <code>end()</code> iterator if the search failed to find a match.</p>
			<p>Output:</p>
			<pre><strong class="bold">found: 7</strong></pre>
			<ul>
				<li>We can also search for something more complex than a scalar. The object needs to support the equality comparison operator, <code>==</code>. Here's a simple struct with an <code>operator==()</code> overload:<pre>struct City {
    string name{};
    unsigned pop{};
    bool operator==(const City&amp; o) const {
        return <strong class="bold">name == o.name</strong>;
    }
    string str() const {
        return format("[{}, {}]", name, pop);
    }
};</pre></li>
			</ul>
			<p>Notice that the <code>operator=()</code> overload only compares the <code>name</code> members.</p>
			<p>I've also <a id="_idIndexMarker521"/>included an <code>str()</code> function that returns a <code>string</code> representation <a id="_idIndexMarker522"/>of a <code>City</code> element.</p>
			<ul>
				<li>Now we can declare a <code>vector</code> of <code>City</code> elements:<pre>const vector&lt;City&gt; c{
    { "London", 9425622 },
    { "Berlin", 3566791 },
    { "Tokyo",  37435191 },
    { "Cairo",  20485965 }
};</pre></li>
				<li>We can search the <code>vector</code> of <code>City</code> just as we did with the <code>vector</code> of <code>int</code>:<pre>auto it2 = <strong class="bold">find(c.begin(), c.end(), City{"Berlin"})</strong>;
if(it2 != c.end()) cout &lt;&lt; format("found: {}\n", 
    <strong class="bold">it2-&gt;str()</strong>);
else cout &lt;&lt; "not found\n";</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">found: [Berlin, 3566791]</strong></pre>
			<ul>
				<li>If we want to search on the <code>pop</code> member instead of <code>name</code>, we can use the <code>find_if()</code> function with a predicate:<pre>auto it3 = find_if(begin(c), end(c),
    [](const City&amp; item)
        { return item.pop &gt; 20000000; });
if(it3 != c.end()) cout &lt;&lt; format("found: {}\n",
    it3-&gt;str());
else cout &lt;&lt; "not found\n";</pre></li>
			</ul>
			<p>The predicate tests the <code>pop</code> member, so we get this output:</p>
			<pre><strong class="bold">found: [Tokyo, 37435191]</strong></pre>
			<ul>
				<li>Notice that the result from <code>find_if()</code> returns only the first element that satisfies the <a id="_idIndexMarker523"/>predicate, even though there are two elements <a id="_idIndexMarker524"/>in the <code>vector</code> with <code>pop</code> values greater than 20,000,000.</li>
			</ul>
			<p>The <code>find()</code> and <code>find_if()</code> functions return only one iterator. The <code>ranges</code> library provides <code>ranges::views::filter()</code>, a <em class="italic">view adapter</em> that will give us all the matching iterators without disturbing our <code>vector</code>:</p>
			<pre>auto <strong class="bold">vw1</strong> = ranges::views::filter(c, 
    [](const City&amp; c){ return c.pop &gt; 20000000; });
for(const City&amp; e : <strong class="bold">vw1</strong>) cout &lt;&lt; format("{}\n", e.str());</pre>
			<p>This gives us both matching elements in our output:</p>
			<pre><strong class="bold">[Tokyo, 37435191]</strong>
<strong class="bold">[Cairo, 20485965]</strong></pre>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>How it works…</h2>
			<p>The <code>find()</code> and <code>find_if()</code> functions search sequentially through a container, checking each element until it finds a match. If it finds a match, it returns an iterator pointing to that match. If it reaches the <code>end()</code> iterator without finding a match, it returns the <code>end()</code> iterator to indicate no match was found.</p>
			<p>The <code>find()</code> function takes <a id="_idIndexMarker525"/>three arguments, the <code>begin()</code> and <code>end()</code> iterators, and a search value. The <a id="_idIndexMarker526"/>signature looks like this:</p>
			<pre>template&lt;class InputIt, class T&gt;
constexpr InputIt find(InputIt, InputIt, const T&amp;)</pre>
			<p>The <code>find_if()</code> function uses a predicate instead of a value:</p>
			<pre>template&lt;class InputIt, class UnaryPredicate&gt;
constexpr InputIt find_if(InputIt, InputIt, UnaryPredicate)</pre>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>There's more…</h2>
			<p>Both <code>find()</code> functions search <a id="_idIndexMarker527"/>sequentially and return when they find the first match. If you want to find more matching elements, you can use the <code>filter()</code> function from the <code>ranges</code> library:</p>
			<pre>template&lt;ranges::viewable_range R, class Pred&gt;
constexpr ranges::view auto ranges::views::filter(R&amp;&amp;, Pred&amp;&amp;);</pre>
			<p>The <code>filter()</code> function returns a <em class="italic">view</em>, a non-destructive window into the container with only the filtered <a id="_idIndexMarker528"/>elements. We can then use the view as we would any other container:</p>
			<pre>auto vw1 = std::ranges::views::filter(c,
    [](const City&amp; c){ return c.pop &gt; 20000000; });
for(const City&amp; e : vw1) cout &lt;&lt; format("{}\n", e.str());</pre>
			<p>Output:</p>
			<pre>[Tokyo, 37435191]
[Cairo, 20485965]</pre>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Limit the values of a container to a range with std::clamp</h1>
			<p>Introduced with C++17, the <code>std::clamp()</code> function can be used to limit the range of a numeric <a id="_idIndexMarker529"/>scalar to within minimum <a id="_idIndexMarker530"/>and maximum values. The function is optimized to use <em class="italic">move semantics</em>, where possible, for maximum speed and efficiency.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>How to do it…</h2>
			<p>We can use <code>clamp()</code> to constrain the values of a container by using it in a loop, or with the <code>transform()</code> algorithm. Let's look at some examples.</p>
			<ul>
				<li>We'll start with a simple function for printing out the values of a container:<pre>void printc(auto&amp; c, string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : c) cout &lt;&lt; format("{:&gt;5} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>Notice the <em class="italic">format string</em> <code>"{:&gt;5} "</code>. This right-aligns each value to <code>5</code> spaces, for a tabular view.</p>
			<ul>
				<li>In the <code>main()</code> function, we'll define an <em class="italic">initializer list</em> for use with our container. This allows us to use the same values more than once:<pre>int main() {
    auto il = { 0, -12, 2001, 4, 5, -14, 100, 200, 
      30000 };
    ...
}</pre></li>
			</ul>
			<p>That's a nice range of values to work with <code>clamp()</code>.</p>
			<ul>
				<li>Let's also define some constants for use as our limits:<pre>constexpr int ilow{0};
constexpr int ihigh{500};</pre></li>
			</ul>
			<p>We'll use these values in our calls to <code>clamp()</code>.</p>
			<ul>
				<li>Now <a id="_idIndexMarker531"/>we can define <a id="_idIndexMarker532"/>a container in our <code>main()</code> function. We'll use a <code>vector</code> of <code>int</code>:<pre>vector&lt;int&gt; voi{ il };
cout &lt;&lt; "vector voi before:\n";
printc(voi);</pre></li>
			</ul>
			<p>Using the values from our initializer list, the output is:</p>
			<pre><strong class="bold">vector voi before:</strong>
<strong class="bold">    0   -12  2001     4     5   -14   100   200 30000</strong></pre>
			<ul>
				<li>Now we can use a <code>for</code> loop with <code>clamp()</code> to limit the values to between 0 and 500:<pre>cout &lt;&lt; "vector voi after:\n";
for(auto&amp; e : voi) e = clamp(e, ilow, ihigh);
printc(voi);</pre></li>
			</ul>
			<p>This applies the <code>clamp()</code> function to each value in the container, using 0 and 500 for the low and high limits, respectively. Now, the output is:</p>
			<pre><strong class="bold">vector voi before:</strong>
<strong class="bold">    0   -12  2001     4     5   -14   100   200 30000</strong>
<strong class="bold">vector voi after:</strong>
<strong class="bold">    0     0   500     4     5     0   100   200   500</strong></pre>
			<p>After the <code>clamp()</code> operation, the negative values are 0 and the values greater than 500 are 500.</p>
			<ul>
				<li>We can <a id="_idIndexMarker533"/>do the same <a id="_idIndexMarker534"/>thing with the <code>transform()</code> algorithm, using <code>clamp()</code> in a lambda. This time we'll use a <code>list</code> container:<pre>cout &lt;&lt; "list loi before:\n";
list&lt;int&gt; loi{ il };
printc(loi);
transform(loi.begin(), loi.end(), loi.begin(), 
    [=](auto e){ return clamp(e, ilow, ihigh); });
cout &lt;&lt; "list loi after:\n";
printc(loi);</pre></li>
			</ul>
			<p>The output is the same as in the version with a <code>for</code> loop:</p>
			<pre><strong class="bold">list loi before:</strong>
<strong class="bold">    0   -12  2001     4     5   -14   100   200 30000</strong>
<strong class="bold">list loi after:</strong>
<strong class="bold">    0     0   500     4     5     0   100   200   500</strong></pre>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>How it works…</h2>
			<p>The <code>clamp()</code> algorithm is a simple function that looks something like this:</p>
			<pre>template&lt;class T&gt;
constexpr const T&amp; clamp( const T&amp; v, const T&amp; lo,
        const T&amp; hi ) {
    return less(v, lo) ? lo : less(hi, v) ? hi : v;
}</pre>
			<p>If the value of <code>v</code> is less than <code>lo</code>, it returns <code>lo</code>. If <code>hi</code> is less than <code>v</code>, it returns <code>hi</code>. The function is fast and efficient.</p>
			<p>In our examples, we used a <code>for</code> loop to apply <code>clamp()</code> to a container:</p>
			<pre>for(auto&amp; v : voi) v = clamp(v, ilow, ihigh);</pre>
			<p>We also used the <code>transform()</code> algorithm with <code>clamp()</code> in a lambda:</p>
			<pre>transform(loi.begin(), loi.end(), loi.begin(),
    [=](auto v){ return clamp(v, ilow, ihigh); });</pre>
			<p>In my <a id="_idIndexMarker535"/>experiments, both versions <a id="_idIndexMarker536"/>gave the same results, and both produced similar code from the GCC compiler. There was a slight difference in compiled size (the version with the <code>for</code> loop was smaller, as expected) and a negligible difference in performance.</p>
			<p>In general, I prefer the <code>for</code> loop, but the <code>transform()</code> version may be more flexible in other applications.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/>Sample data sets with std::sample</h1>
			<p>The <code>std::sample()</code> algorithm takes a random <em class="italic">sample</em> of a sequence of values and populates a <a id="_idIndexMarker537"/>destination container with the sample. It is <a id="_idIndexMarker538"/>useful for analyzing a larger set of data, where the random sample is taken to be representative of the whole.</p>
			<p>A sample set allows us to approximate the characteristics of a large set of data, without analyzing the full set. This provides efficiency in exchange for accuracy, a fair trade-off in many circumstances.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>How to do it…</h2>
			<p>In this recipe, we'll use an array of 200,000 random integers, with <em class="italic">standard normal distribution</em>. We'll sample a few hundred values to create a histogram of the frequency of each value.</p>
			<ul>
				<li>We'll start with a simple function to return a rounded <code>int</code> from a <code>double</code>. The standard library lacks such a function and we'll need it later:<pre>int iround(const double&amp; d) {
    return static_cast&lt;int&gt;(std::round(d));
}</pre></li>
			</ul>
			<p>The standard library provides several versions of <code>std::round()</code>, including one that returns a <code>long int</code>. But we need an <code>int</code>, and this is a simple solution that avoids compiler warnings about narrowing conversion while hiding away the unsightly <code>static_cast</code>.</p>
			<ul>
				<li>In the <code>main()</code> function, we'll start with some useful constants:<pre>int main() {
    constexpr size_t n_data{ 200000 };
    constexpr size_t n_samples{ 500 };
    constexpr int mean{ 0 };
    constexpr size_t dev{ 3 };
    ...
}</pre></li>
			</ul>
			<p>We have <a id="_idIndexMarker539"/>values for <code>n_data</code> and <code>n_samples</code>, used for <a id="_idIndexMarker540"/>the size of the data and sample containers, respectively. We also have values for <code>mean</code> and <code>dev</code>, the <em class="italic">mean</em> and <em class="italic">standard deviation</em> parameters for the <em class="italic">normal distribution</em> of random values.</p>
			<ul>
				<li>We now set up our <em class="italic">random number generator</em> and <em class="italic">distribution</em> objects. These are used to initialize the source data set:<pre>std::<strong class="bold">random_device</strong> rd;
std::<strong class="bold">mt19937</strong> rng(rd());
std::<strong class="bold">normal_distribution</strong>&lt;&gt; dist{ mean, dev };</pre></li>
			</ul>
			<p>The <code>random_device</code> object provides access to the hardware random number generator. The <code>mt19937</code> class is an implementation of the <em class="italic">Mersenne Twister</em> random number algorithm, a high-quality algorithm that will perform well on most systems with a data set of the size we're using. The <code>normal_distribution</code> class provides a distribution of random numbers around the <em class="italic">mean</em> with the <em class="italic">standard deviation</em> provided.</p>
			<ul>
				<li>Now we populate an array with an <code>n_data</code> number of random <code>int</code> values:<pre>array&lt;int, <strong class="bold">n_data</strong>&gt; v{};
for(auto&amp; e : v) e = iround(dist(rng));</pre></li>
			</ul>
			<p>The <code>array</code> container is fixed in size, so the template parameters include a <code>size_t</code> value <a id="_idIndexMarker541"/>for the number of elements to <a id="_idIndexMarker542"/>allocate. We use a <code>for()</code> loop to populate the array.</p>
			<p>The <code>rng</code> object is the hardware random number generator. This is passed to <code>dist()</code>, our <code>normal_distribution</code> object, and then to <code>iround()</code>, our integer rounding function.</p>
			<ul>
				<li>At this point, we have an array with 200,000 data points. That's a lot to analyze, so we'll use the <code>sample()</code> algorithm to take a sample of 500 values:<pre>array&lt;int, <strong class="bold">n_samples</strong>&gt; samples{};
sample(data.begin(), data.end(), samples.begin(), 
    <strong class="bold">n_samples</strong>, rng);</pre></li>
			</ul>
			<p>We define another <code>array</code> object to hold the samples. This one is <code>n_samples</code> in size. Then we use the <code>sample()</code> algorithm to populate the array with <code>n_samples</code> random data points.</p>
			<ul>
				<li>We create a histogram to analyze the samples. A <code>map</code> structure is perfect for this as we can easily map the frequency of each value:<pre>std::map&lt;int, size_t&gt; hist{};
for (const int i : samples) <strong class="bold">++hist[i]</strong>;</pre></li>
			</ul>
			<p>The <code>for()</code> loop takes each value from the <code>samples</code> container and uses it as a key in the <code>map</code>. The increment expression <code>++hist[i]</code> counts the number of occurrences of each value in the sample set.</p>
			<ul>
				<li>We print out the histogram using the C++20 <code>format()</code> function:<pre>constexpr size_t scale{ 3 };
cout &lt;&lt; format("<strong class="bold">{:&gt;3}</strong> <strong class="bold">{:&gt;5}</strong> <strong class="bold">{:&lt;}</strong>/{}\n", 
    "n", "count", "graph", scale);
for (const auto&amp; [value, count] : hist) {
    cout &lt;&lt; format("<strong class="bold">{:&gt;3}</strong> (<strong class="bold">{:&gt;3}</strong>) {}\n", 
        value, count, <strong class="bold">string(count / scale, '*')</strong>);
}</pre></li>
			</ul>
			<p>The <code>format()</code> specifiers that look like <code>{:&gt;3}</code> make space for a certain number of characters. The angle bracket specifies alignment, right or left.</p>
			<p>The <code>string(count, char)</code> constructor creates a <code>string</code> with a character repeated the <a id="_idIndexMarker543"/>number of times specified, in <a id="_idIndexMarker544"/>this case, <em class="italic">n</em> asterisk characters <code>*</code>, where <em class="italic">n</em> is <code>count/scale</code>, the frequency of a value in the histogram, divided by the <code>scale</code> constant.</p>
			<p>The output looks like this:</p>
			<pre><strong class="bold">$ ./sample</strong>
<strong class="bold">  n count graph/3</strong>
<strong class="bold"> -9 (  2)</strong>
<strong class="bold"> -7 (  5) *</strong>
<strong class="bold"> -6 (  9) ***</strong>
<strong class="bold"> -5 ( 22) *******</strong>
<strong class="bold"> -4 ( 24) ********</strong>
<strong class="bold"> -3 ( 46) ***************</strong>
<strong class="bold"> -2 ( 54) ******************</strong>
<strong class="bold"> -1 ( 59) *******************</strong>
<strong class="bold">  0 ( 73) ************************</strong>
<strong class="bold">  1 ( 66) **********************</strong>
  <strong class="bold">2 ( 44) **************</strong>
<strong class="bold">  3 ( 34) ***********</strong>
<strong class="bold">  4 ( 26) ********</strong>
<strong class="bold">  5 ( 18) ******</strong>
<strong class="bold">  6 (  9) ***</strong>
<strong class="bold">  7 (  5) *</strong>
<strong class="bold">  8 (  3) *</strong>
<strong class="bold">  9 (  1)</strong></pre>
			<p>This is a nice graphical representation of the histogram. The first number is the value, the second number is the frequency of the value, and the asterisks are a visual representation of the frequency, where each asterisk represents <code>scale</code> (3) occurrences in the sample set.</p>
			<p>Your output will differ each time you run the code.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>How it works…</h2>
			<p>The <code>std::sample()</code> function <a id="_idIndexMarker545"/>selects a specific number <a id="_idIndexMarker546"/>of elements from random locations in the source container and copies them to the destination container.</p>
			<p>The signature of <code>sample()</code> looks like this:</p>
			<pre>OutIter sample(SourceIter, SourceIter, OutIter, 
    SampleSize, RandNumGen&amp;&amp;);</pre>
			<p>The first two arguments are <code>begin()</code> and <code>end()</code> iterators on a container with the full data set. The third <a id="_idIndexMarker547"/>argument is an iterator for the destination <a id="_idIndexMarker548"/>of the samples. The fourth argument is the sample size, and the final argument is a random number generator function.</p>
			<p>The <code>sample()</code> algorithm uses <em class="italic">uniform distribution</em>, so each data point has the same chance of being sampled.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Generate permutations of data sequences</h1>
			<p>There are <a id="_idIndexMarker549"/>many use cases for permutations, including <a id="_idIndexMarker550"/>testing, statistics, research, and more. The <code>next_permutation()</code> algorithm generates permutations by re-ordering a container to the next <em class="italic">lexicographical</em> permutation.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>How to do it…</h2>
			<p>For this recipe, we will print out the permutations of a set of three strings:</p>
			<ul>
				<li>We'll start by creating a short function for printing the contents of a container:<pre>void printc(const auto&amp; c, string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : c) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>We'll use this simple function to print our data set and permutations.</p>
			<ul>
				<li>In the <code>main()</code> function, we declare a <code>vector</code> of <code>string</code> objects and sort it with the <code>sort()</code> algorithm.<pre>int main() {
    vector&lt;string&gt; vs{ "dog", "cat", "velociraptor" };
    sort(vs.begin(), vs.end());
    ...
}</pre></li>
			</ul>
			<p>The <code>next_permutation()</code> function requires a sorted container.</p>
			<ul>
				<li>Now we can list the permutations with <code>next_permutation()</code> in a <code>do</code> loop:<pre>do {
    printc(vs);
} while (<strong class="bold">next_permutation(vs.begin(), vs.end())</strong>);</pre></li>
			</ul>
			<p>The <code>next_permutation()</code> function modifies the container and returns <code>true</code> if there is another permutation, or <code>false</code> if not.</p>
			<p>The output lists six permutations of our three pets:</p>
			<pre><strong class="bold">cat dog velociraptor</strong>
<strong class="bold">cat velociraptor dog</strong>
<strong class="bold">dog cat velociraptor</strong>
<strong class="bold">dog velociraptor cat</strong>
<strong class="bold">velociraptor cat dog</strong>
<strong class="bold">velociraptor dog cat</strong></pre>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>How it works…</h2>
			<p>The <code>std::next_permutation()</code> algorithm generates <em class="italic">lexicographical</em> permutations of a set of values, that is, permutations based on dictionary ordering. The input must <a id="_idIndexMarker551"/>be sorted because the algorithm <a id="_idIndexMarker552"/>steps through permutations in lexicographical order. So, if you start with a set like 3, 2, 1, it will terminate immediately as this is the last lexicographical order of those three elements.</p>
			<p>For example:</p>
			<pre>vector&lt;string&gt; vs{ "velociraptor", "dog", "cat" };
do {
    printc(vs);
} while (next_permutation(vs.begin(), vs.end()));</pre>
			<p>This gives us the following output:</p>
			<pre>velociraptor dog cat</pre>
			<p>While the term <em class="italic">lexicographical</em> implies alphabetical ordering, the implementation uses standard comparison operators, so it works on any sortable values.</p>
			<p>Likewise, if values in the set repeat, they are only counted according to <em class="italic">lexicographical</em> order. Here we have a <code>vector</code> of <code>int</code> with two repeating sequences of five values:</p>
			<pre>vector&lt;int&gt; vi{ 1, 2, 3, 4, 5, 1, 2, 3, 4, 5 };
sort(vi.begin(), vi.end());
printc(vi, "vi sorted");
long <strong class="bold">count</strong>{};
do {
    <strong class="bold">++count</strong>;
} while (next_permutation(vi.begin(), vi.end()));
cout &lt;&lt; format("number of permutations: {}\n", <strong class="bold">count</strong>);</pre>
			<p>Output:</p>
			<pre>Vi sorted: 1 1 2 2 3 3 4 4 5 5
number of permutations: 113400</pre>
			<p>There are 113,400 permutations of these values. Notice that it's not <em class="italic">10!</em> (3,628,800) because some <a id="_idIndexMarker553"/>values repeat. Since <em class="italic">3,3</em> and <em class="italic">3,3</em> sort <a id="_idIndexMarker554"/>the same, they are not different <em class="italic">lexicographical</em> permutations.</p>
			<p>In other words, if I list the permutations of this short set:</p>
			<pre>vector&lt;int&gt; vi2{ 1, 3, 1 };
sort(vi2.begin(), vi2.end());
do {
    printc(vi2);
} while (next_permutation(vi2.begin(), vi2.end()));</pre>
			<p>We get only three permutations, not <em class="italic">3!</em> (9), because of the repeating values:</p>
			<pre>1 1 3
1 3 1
3 1 1</pre>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor209"/>Merge sorted containers</h1>
			<p>The <code>std::merge()</code> algorithm takes two sorted sequences and creates a third merged and sorted sequence. This technique <a id="_idIndexMarker555"/>is often used as part of a <em class="italic">merge sort</em>, allowing <a id="_idIndexMarker556"/>very large amounts of data to be broken down into chunks, sorted separately, and merged into one sorted target.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>How to do it…</h2>
			<p>For this recipe, we'll take two sorted <code>vector</code> containers and merge them into a third <code>vector</code> using <code>std::merge()</code>.</p>
			<ul>
				<li>We'll start with a simple function to print the contents of a container:<pre>void printc(const auto&amp; c, string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : c) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>We'll use this to print the source and destination sequences.</p>
			<ul>
				<li>In the <code>main()</code> function, we'll declare our source vectors, along with the destination vector, and print them out:<pre>int main() {
    vector&lt;string&gt; vs1{ "dog", "cat", 
      "velociraptor" };
    vector&lt;string&gt; vs2{ "kirk", "sulu", "spock" };
    vector&lt;string&gt; dest{};
    printc(vs1, "vs1");
    printc(vs2, "vs2");
    ...
}</pre></li>
			</ul>
			<p>The output is:</p>
			<pre><strong class="bold">vs1: dog cat velociraptor</strong>
<strong class="bold">vs2: kirk sulu spock</strong></pre>
			<ul>
				<li>Now we can sort our vectors and print them again:<pre>sort(vs1.begin(), vs1.end());
sort(vs2.begin(), vs2.end());
printc(vs1, "vs1 sorted");
printc(vs2, "vs2 sorted");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">vs1 sorted: cat dog velociraptor</strong>
<strong class="bold">vs2 sorted: kirk spock sulu</strong></pre>
			<ul>
				<li>Now that our <a id="_idIndexMarker557"/>source containers are sorted, we can merge <a id="_idIndexMarker558"/>them for our final merged result:<pre>merge(vs1.begin(), vs1.end(), vs2.begin(), vs2.end(), 
    back_inserter(dest));
printc(dest, "dest");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">dest: cat dog kirk spock sulu velociraptor</strong></pre>
			<p>This output represents the merge of the two sources into one sorted vector.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>How it works…</h2>
			<p>The <code>merge()</code> algorithm <a id="_idIndexMarker559"/>takes <code>begin()</code> and <code>end()</code> iterators from <a id="_idIndexMarker560"/>both the sources and an output iterator for the destination:</p>
			<pre>OutputIt merge(InputIt1, InputIt1, InputIt2, InputIt2, OutputIt)</pre>
			<p>It takes the two input ranges, performs its merge/sort operation, and sends the resulting sequence to the output iterator.</p>
		</div>
	</body></html>