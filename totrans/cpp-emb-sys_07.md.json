["```cpp\n#include <cstdint>\nclass uart {\npublic:\n    uart(std::uint32_t baud = 9600): baudrate_(baud) {}\n    void init() {\n        write_brr(calculate_uartdiv());\n    }\nprivate:\n    std::uint32_t baudrate_;\n    std::uint8_t calculate_uartdiv() {\n        return baudrate_ / 32000;\n    }\n    void write_brr(std::uint8_t) {}\n};\nint main () {\n    uart uart1(115200);\n    uart1.init();\n    return 0;\n} \n```", "```cpp\nclass uart {\n    std::uint32_t baudrate_;\n    std::uint8_t calculate_uartdiv();\n    void write_brr(std::uint8_t);\npublic:\n    uart(std::uint32_t baud = 9600);\n    void init();\n}; \n```", "```cpp\n std::uint32_t get_baudrate() const{\n        return baudrate_;\n    }\n    void set_baudrate(baudrate) {\n        baudrate_ = baudrate;\n    } \n```", "```cpp\n void set_baudrate(baudrate) {\n        if (baudrate <= c_max_baudrate) {\n            baudrate_ = baudrate;\n        } else {\n            baudrate = c_max_baudrate;\n        }\n    } \n```", "```cpp\n#include <cstdint>\nclass uart {\npublic:\n    static void init(std::uint32_t baudrate) {\n        write_brr(calculate_uartdiv(baudrate));\n    }\nprivate:\n    static std::uint8_t calculate_uartdiv(std::uint32_t baudrate) {\n        return baudrate / 32000;\n    }\n    static void write_brr(std::uint8_t) {}\n};\nint main () {\n    uart::init(115200);\n    return 0;\n} \n```", "```cpp\nstruct accelerometer_data {\n    std::uint32_t x;\n    std::uint32_t y;\n    std::uint32_t z;\n}; \n```", "```cpp\nclass my_class{\n    int a = 4;\n    int *ptr = nullptr;\n} \n```", "```cpp\n uart(std::uint32_t baud = 9600): baudrate_(baud) {\n    // empty constructor body\n    } \n```", "```cpp\n uart uart1; \n```", "```cpp\n uart uart1(); \n```", "```cpp\n uart uart1(115200); \n```", "```cpp\nclass sensor {\npublic:\n    sensor(uart &u, std::uint32_t read_interval):\n                uart_(u),\n                read_interval_(read_interval) {}\nprivate:\n    uart &uart_;\n    const std::uint32_t read_interval_;\n};\nint main() {\n    uart uart1;\n    sensor sensor1(uart1, 500);\n    return 0;\n} \n```", "```cpp\n#include <cstdio>\n#include <student>\nstruct uart {\n    uart(std::uint32_t baud = 9600): baudrate_(baud) {}\n    std::uint32_t baudrate_;\n};\nvoid uart_consumer(uart u) {\n   printf(\"Uart baudrate is %d\\r\\n\", u.baudrate_);\n}\nint main() {\n    uart uart1;\n    uart_consumer(uart1);\n    uart_consumer(115200);\n    return 0;\n} \n```", "```cpp\nUart baudrate is 9600\nUart baudrate is 115200 \n```", "```cpp\n explicit uart(std::uint32_t baud = 9600): baudrate_(baud) {} \n```", "```cpp\n<source>:19:19: error: could not convert '115200' from 'int' to 'uart'\n   19 |     uart_consumer(115200); \n```", "```cpp\n uart(float) = delete; \n```", "```cpp\n<source>:12:25: error: use of deleted function 'uart::uart(float)'\n   12 |     uart uart1(100000.0f); \n```", "```cpp\n uart uart1{100000.0f}; \n```", "```cpp\n<source>:11:25: error: narrowing conversion of '1.0e+5f' from 'float' to 'uint8_t' {aka 'unsigned char'} [-Wnarrowing]\n   11 |     uart uart1{100000.0f}; \n```", "```cpp\n#include <cstdio>\nstruct object_counter {\n    static int cnt;\n    object_counter() {\n        cnt++;\n    }\n    ~object_counter() {\n        cnt--;\n    }\n};\nint object_counter::cnt = 0;\nint main() {\n    {\n        object_counter obj1;\n        object_counter obj2;\n        object_counter obj3;\n        printf(\"Number of existing objects in this scope is: %d\\r\\n\",\n object_counter::cnt);\n    }\n    printf(\"Number of existing objects in this scope is: %d\\r\\n\", \n object_counter::cnt);\n    return 0;\n} \n```", "```cpp\nNumber of existing objects in this scope is: 3\nNumber of existing objects in this scope is: 0 \n```", "```cpp\nint object_counter::cnt = 0; \n```", "```cpp\nstruct object_counter {\n    inline static int cnt = 0;\n    ...\n}; \n```", "```cpp\n#include <cstdio>\nclass A {\npublic:\n    void method_1() {\n        printf(\"Class A, method1\\r\\n\");\n    }\n    void method_2() {\n        printf(\"Class A, method2\\r\\n\");\n    }\nprotected:\n    void method_protected() {\n        printf(\"Class A, method_protected\\r\\n\");\n    }\n};\nclass B : public A{\npublic:\n    void method_1() {\n        printf(\"Class B, method1\\r\\n\");\n    }\n    void method_3() {\n        printf(\"Class B, method3\\r\\n\");\n        A::method_2();\n        A::method_protected();\n    }\n};\nint main() {\n    B b;\n    b.method_1();\n    b.method_2();\n    b.method_3();\n    printf(\"-----------------\\r\\n\");\n    A &a = b;\n    a.method_1();\n    a.method_2();\n    return 0;\n} \n```", "```cpp\nClass B, method1\nClass A, method2\nClass B, method3\nClass A, method2\nClass A, method_protected \n```", "```cpp\nClass A, method1\nClass A, method2 \n```", "```cpp\nclass A {\npublic:\n    virtual void method_1() {\n        printf(\"Class A, method1\\r\\n\");\n    }\n...\n}; \n```", "```cpp\nClass B, method1\nClass A, method2 \n```", "```cpp\nclass B: public A {\npublic:\n    void method_1() override {\n        printf(\"Class B, method1\\r\\n\");\n    }\n...\n}; \n```", "```cpp\nclass A {\npublic:\n    void method_1() virtual{\n        printf(\"Class A, method1\\r\\n\");\n    }\n    void method_2() virtual{\n        printf(\"Class A, method2\\r\\n\");\n    }\n};\nclass B : public A{\npublic:\n    void method_2() override{\n        printf(\"Class B, method2\\r\\n\");\n    }\n }; \n```", "```cpp\nclass A {\npublic:\n    virtual void method_1() = 0;\n};\nclass B : public A{\n};\nint main() {\n    B b;\n    return 0;\n} \n```", "```cpp\n#include <span>\n#include <cstdio>\n#include <cstdint>\nclass uart {\npublic:\n    virtual void init(std::uint32_t baudrate) = 0;\n    virtual void write(std::span<const char> data) = 0;\n};\nclass uart_stm32 : public uart{\npublic:\n    void init(std::uint32_t baudrate = 9600) override { \n        printf(\"uart_stm32::init: setting baudrate to %d\\r\\n\", baudrate);\n    } \n    void write(std::span<const char> data) override {\n        printf(\"uart_stm32::write: \");\n        for(auto ch: data) {\n            putc(ch, stdout);\n        }\n    }\n};\nclass gsm_lib{\n    public:\n        gsm_lib(uart &u) : uart_(u) {}\n        void init() {\n            printf(\"gsm_lib::init: sending AT command\\r\\n\");\n            uart_.write(\"AT\");\n        }\n    private:\n        uart &uart_;\n};\nint main() {\n    uart_stm32 uart_stm32_obj;\n    uart_stm32_obj.init(115200);\n    gsm_lib gsm(uart_stm32_obj);\n    gsm.init();\n    return 0;\n} \n```"]