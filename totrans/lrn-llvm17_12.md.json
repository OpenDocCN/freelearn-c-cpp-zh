["```cpp\n\ndeclare i32 @printf(ptr, ...)\n@hellostr = private unnamed_addr constant [13 x i8] c\"Hello world\\0A\\00\"\ndefine dso_local i32 @main(i32 %argc, ptr %argv) {\n  %res = call i32 (ptr, ...) @printf(ptr @hellostr)\n  ret i32 0\n}\n```", "```cpp\n\n$ lli hello.ll\nHello world\n```", "```cpp\n\n#include <stdio.h>\nvoid greetings() {\n  puts(\"Hi!\");\n}\n```", "```cpp\n\n$ clang greetings.c -fPIC -shared -o greetings.so\n```", "```cpp\n\n$ clang greetings.c -c -o greetings.o\n```", "```cpp\n\ndeclare void @greetings(...)\ndefine dso_local i32 @main(i32 %argc, i8** %argv) {\n  call void (...) @greetings()\n  ret i32 0\n}\n```", "```cpp\n\n$ lli main.ll\nJIT session error: Symbols not found: [ _greetings ]\nlli: Failed to materialize symbols: { (main, { _main }) }\n```", "```cpp\n\n$ lli –load ./greetings.so main.ll\nHi!\n```", "```cpp\n\n$ lli –extra-object greetings.o main.ll\nHi!\n```", "```cpp\n\n    #include \"CodeGen.h\"\n    #include \"Parser.h\"\n    #include \"Sema.h\"\n    #include \"llvm/ExecutionEngine/Orc/LLJIT.h\"\n    #include \"llvm/Support/InitLLVM.h\"\n    #include \"llvm/Support/TargetSelect.h\"\n    #include <iostream>\n    ```", "```cpp\n\n    using namespace llvm;\n    using namespace llvm::orc;\n    ```", "```cpp\n\n    ExitOnError ExitOnErr;\n    ```", "```cpp\n\n    int main(int argc, const char **argv{\n      InitLLVM X(argc, argv);\n      InitializeNativeTarget();\n      InitializeNativeTargetAsmPrinter();\n      InitializeNativeTargetAsmParser();\n    ```", "```cpp\n\n    auto JIT = ExitOnErr(LLJITBuilder().create());\n    ```", "```cpp\n\n    StringMap<size_t> JITtedFunctions;\n    ```", "```cpp\n\n      while (true) {\n        outs() << \"JIT calc > \";\n        std::string calcExp;\n        std::getline(std::cin, calcExp);\n    ```", "```cpp\n\n        std::unique_ptr<LLVMContext> Ctx = std::make_unique<LLVMContext>();\n        std::unique_ptr<Module> M = std::make_unique<Module>(\"JIT calc.expr\", *Ctx);\n        M->setDataLayout(JIT->getDataLayout());\n        CodeGen CodeGenerator;\n    ```", "```cpp\n\n        Lexer Lex(calcExp);\n        Token::TokenKind CalcTok = Lex.peek();\n    ```", "```cpp\n\n       if (CalcTok == Token::KW_def) {\n          Parser Parser(Lex);\n          AST *Tree = Parser.parse();\n          if (!Tree || Parser.hasError()) {\n            llvm::errs() << \"Syntax errors occured\\n\";\n            return 1;\n          }\n          Sema Semantic;\n          if (Semantic.semantic(Tree, JITtedFunctions)) {\n            llvm::errs() << \"Semantic errors occured\\n\";\n            return 1;\n          }\n    ```", "```cpp\n\n          CodeGenerator.compileToIR(Tree, M.get(), JITtedFunctions);\n          ExitOnErr(\n              JIT->addIRModule(ThreadSafeModule(std::move(M),           std::move(Ctx))));\n    ```", "```cpp\n\n       } else if (CalcTok == Token::ident) {\n          outs() << \"Attempting to evaluate expression:\\n\";\n          Parser Parser(Lex);\n          AST *Tree = Parser.parse();\n          if (!Tree || Parser.hasError()) {\n            llvm::errs() << \"Syntax errors occured\\n\";\n            return 1;\n          }\n          Sema Semantic;\n          if (Semantic.semantic(Tree, JITtedFunctions)) {\n            llvm::errs() << \"Semantic errors occured\\n\";\n            return 1;\n          }\n    ```", "```cpp\n\n          llvm::StringRef FuncCallName = Tree->getFnName();\n          CodeGenerator.prepareCalculationCallFunc(Tree, M.get(),       FuncCallName, JITtedFunctions);\n    ```", "```cpp\n\n          auto RT = JIT->getMainJITDylib().createResourceTracker();\n          auto TSM = ThreadSafeModule(std::move(M), std::move(Ctx));\n          ExitOnErr(JIT->addIRModule(RT, std::move(TSM)));\n    ```", "```cpp\n\n          auto CalcExprCall = ExitOnErr(JIT->lookup(\"calc_expr_func\"));\n          int (*UserFnCall)() = CalcExprCall.toPtr<int (*)()>();\n          outs() << \"User defined function evaluated to:       \" << UserFnCall() << \"\\n\";\n    ```", "```cpp\n\n    ExitOnErr(RT->remove());\n    ```", "```cpp\n\n    void CodeGen::compileToIR(AST *Tree, Module *M,\n                        StringMap<size_t> &JITtedFunctions) {\n      ToIRVisitor ToIR(M, JITtedFunctions);\n      ToIR.run(Tree);\n      M->print(outs(), nullptr);\n    }\n    void CodeGen::prepareCalculationCallFunc(AST *FuncCall,\n               Module *M, llvm::StringRef FnName,\n               StringMap<size_t> &JITtedFunctions) {\n      ToIRVisitor ToIR(M, JITtedFunctions);\n      ToIR.genFuncEvaluationCall(FuncCall);\n      M->print(outs(), nullptr);\n    }\n    ```", "```cpp\n\n    class ToIRVisitor : public ASTVisitor {\n      Module *M;\n      IRBuilder<> Builder;\n      StringMap<size_t> &JITtedFunctionsMap;\n    . . .\n    public:\n      ToIRVisitor(Module *M,\n                  StringMap<size_t> &JITtedFunctions)\n          : M(M), Builder(M->getContext()),       JITtedFunctionsMap(JITtedFunctions) {\n    ```", "```cpp\n\n    virtual void visit(DefDecl &Node) override {\n        llvm::StringRef FnName = Node.getFnName();\n        llvm::SmallVector<llvm::StringRef, 8> FunctionVars =     Node.getVars();\n        (JITtedFunctionsMap)[FnName] = FunctionVars.size();\n    ```", "```cpp\n\n        Function *DefFunc = genUserDefinedFunction(FnName);\n    ```", "```cpp\n\n    Function *genUserDefinedFunction(llvm::StringRef Name) {\n        if (Function *F = M->getFunction(Name))\n          return F;\n        Function *UserDefinedFunction = nullptr;\n        auto FnNameToArgCount = JITtedFunctionsMap.find(Name);\n        if (FnNameToArgCount != JITtedFunctionsMap.end()) {\n          std::vector<Type *> IntArgs(FnNameToArgCount->second,       Int32Ty);\n          FunctionType *FuncType = FunctionType::get(Int32Ty,       IntArgs, false);\n          UserDefinedFunction =\n              Function::Create(FuncType,           GlobalValue::ExternalLinkage, Name, M);\n        }\n        return UserDefinedFunction;\n      }\n    ```", "```cpp\n\n        BasicBlock *BB = BasicBlock::Create(M->getContext(),     \"entry\", DefFunc);\n        Builder.SetInsertPoint(BB);\n        unsigned FIdx = 0;\n        for (auto &FArg : DefFunc->args()) {\n          nameMap[FunctionVars[FIdx]] = &FArg;\n          FArg.setName(FunctionVars[FIdx++]);\n        }\n        Node.getExpr()->accept(*this);\n      };\n    ```", "```cpp\n\n      virtual void visit(FuncCallFromDef &Node) override {\n        llvm::StringRef CalcExprFunName = \"calc_expr_func\";\n        FunctionType *CalcExprFunTy = FunctionType::get(Int32Ty, {},     false);\n        Function *CalcExprFun = Function::Create(\n            CalcExprFunTy, GlobalValue::ExternalLinkage,         CalcExprFunName, M);\n    ```", "```cpp\n\n        BasicBlock *BB = BasicBlock::Create(M->getContext(),     \"entry\", CalcExprFun);\n        Builder.SetInsertPoint(BB);\n    ```", "```cpp\n\n        llvm::StringRef CalleeFnName = Node.getFnName();\n        Function *CalleeFn = genUserDefinedFunction(CalleeFnName);\n    ```", "```cpp\n\n        auto CalleeFnVars = Node.getArgs();\n        llvm::SmallVector<Value *> IntParams;\n        for (unsigned i = 0, end = CalleeFnVars.size(); i != end;     ++i) {\n          int ArgsToIntType;\n          CalleeFnVars[i].getAsInteger(10, ArgsToIntType);\n          Value *IntParam = ConstantInt::get(Int32Ty, ArgsToIntType,       true);\n          IntParams.push_back(IntParam);\n        }\n        Builder.CreateRet(Builder.CreateCall(CalleeFn, IntParams,     \"calc_expr_res\"));\n      };\n    ```", "```cpp\n\n    cmake_minimum_required (VERSION 3.20.0)\n    project (\"jit\")\n    ```", "```cpp\n\n    find_package(LLVM REQUIRED CONFIG)\n    list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})\n    include(DetermineGCCCompatible)\n    include(ChooseMSVCCRT)\n    ```", "```cpp\n\n    add_definitions(${LLVM_DEFINITIONS})\n    include_directories(SYSTEM ${LLVM_INCLUDE_DIRS})\n    llvm_map_components_to_libnames(llvm_libs Core OrcJIT\n                                              Support native)\n    ```", "```cpp\n\n    if(LLVM_COMPILER_IS_GCC_COMPATIBLE)\n      if(NOT LLVM_ENABLE_RTTI)\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fno-rtti\")\n      endif()\n      if(NOT LLVM_ENABLE_EH)\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fno-exceptions\")\n      endif()\n    endif()\n    ```", "```cpp\n\n    add_executable (calc\n      Calc.cpp CodeGen.cpp Lexer.cpp Parser.cpp Sema.cpp)\n    target_link_libraries(calc PRIVATE ${llvm_libs})\n    ```", "```cpp\n\n$ cmake –G Ninja <path to source directory>\n$ ninja\n```", "```cpp\n\n$ ./calc\nJIT calc > def f(x) = x*2\ndefine i32 @f(i32 %x) {\nentry:\n  %0 = mul nsw i32 %x, 2\n  ret i32 %0\n}\nJIT calc > f(20)\nAttempting to evaluate expression:\ndefine i32 @calc_expr_func() {\nentry:\n  %calc_expr_res = call i32 @f(i32 20)\n  ret i32 %calc_expr_res\n}\ndeclare i32 @f(i32)\nUser defined function evaluated to: 40\nJIT calc > def g(x,y) = x*y+100\ndefine i32 @g(i32 %x, i32 %y) {\nentry:\n  %0 = mul nsw i32 %x, %y\n  %1 = add nsw i32 %0, 100\n  ret i32 %1\n}\nJIT calc > g(8,9)\nAttempting to evaluate expression:\ndefine i32 @calc_expr_func() {\nentry:\n  %calc_expr_res = call i32 @g(i32 8, i32 9)\n  ret i32 %calc_expr_res\n}\ndeclare i32 @g(i32, i32)\nUser defined function evaluated to: 172\n```", "```cpp\n\n$ ./calc\nJIT calc > def f(x) = x*2\ndefine i32 @f(i32 %x) {\nentry:\n  %0 = mul nsw i32 %x, 2\n  ret i32 %0\n}\nJIT calc > def f(x,y) = x+y\ndefine i32 @f(i32 %x, i32 %y) {\nentry:\n  %0 = add nsw i32 %x, %y\n  ret i32 %0\n}\nDuplicate definition of symbol '_f'\n```", "```cpp\n\n    #ifndef JIT_H\n    #define JIT_H\n    ```", "```cpp\n\n    #include \"llvm/Analysis/AliasAnalysis.h\"\n    #include \"llvm/ExecutionEngine/JITSymbol.h\"\n    #include \"llvm/ExecutionEngine/Orc/CompileUtils.h\"\n    #include \"llvm/ExecutionEngine/Orc/Core.h\"\n    #include \"llvm/ExecutionEngine/Orc/ExecutionUtils.h\"\n    #include \"llvm/ExecutionEngine/Orc/IRCompileLayer.h\"\n    #include \"llvm/ExecutionEngine/Orc/IRTransformLayer.h\"\n    #include\n         \"llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h\"\n    #include \"llvm/ExecutionEngine/Orc/Mangling.h\"\n    #include\n        \"llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h\"\n    #include\n            \"llvm/ExecutionEngine/Orc/TargetProcessControl.h\"\n    #include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n    #include \"llvm/Passes/PassBuilder.h\"\n    #include \"llvm/Support/Error.h\"\n    ```", "```cpp\n\n    class JIT {\n    ```", "```cpp\n\n      std::unique_ptr<llvm::orc::TargetProcessControl> TPC;\n      std::unique_ptr<llvm::orc::ExecutionSession> ES;\n      llvm::DataLayout DL;\n      llvm::orc::MangleAndInterner Mangle;\n      std::unique_ptr<llvm::orc::RTDyldObjectLinkingLayer>\n          ObjectLinkingLayer;\n      std::unique_ptr<llvm::orc::IRCompileLayer>\n          CompileLayer;\n      std::unique_ptr<llvm::orc::IRTransformLayer>\n          OptIRLayer;\n      llvm::orc::JITDylib &MainJITDylib;\n    ```", "```cpp\n\n    public:\n      static llvm::Expected<std::unique_ptr<JIT>> create() {\n        auto SSP =\n            std::make_shared<llvm::orc::SymbolStringPool>();\n        auto TPC =\n            llvm::orc::SelfTargetProcessControl::Create(SSP);\n        if (!TPC)\n          return TPC.takeError();\n        llvm::orc::JITTargetMachineBuilder JTMB(\n            (*TPC)->getTargetTriple());\n        auto DL = JTMB.getDefaultDataLayoutForTarget();\n        if (!DL)\n          return DL.takeError();\n    ```", "```cpp\n\n        auto ES =\n            std::make_unique<llvm::orc::ExecutionSession>(\n                std::move(SSP));\n        return std::make_unique<JIT>(\n            std::move(*TPC), std::move(ES), std::move(*DL),\n            std::move(JTMB));\n      }\n    ```", "```cpp\n\n    JIT(std::unique_ptr<llvm::orc::ExecutorProcessControl>\n              EPCtrl,\n          std::unique_ptr<llvm::orc::ExecutionSession>\n              ExeS,\n          llvm::DataLayout DataL,\n          llvm::orc::JITTargetMachineBuilder JTMB)\n          : EPC(std::move(EPCtrl)), ES(std::move(ExeS)),\n            DL(std::move(DataL)), Mangle(*ES, DL),\n            ObjectLinkingLayer(std::move(\n                createObjectLinkingLayer(*ES, JTMB))),\n            CompileLayer(std::move(createCompileLayer(\n                *ES, *ObjectLinkingLayer,\n                std::move(JTMB)))),\n            OptIRLayer(std::move(\n                createOptIRLayer(*ES, *CompileLayer))),\n            MainJITDylib(\n                ES->createBareJITDylib(\"<main>\")) {\n    ```", "```cpp\n\n        MainJITDylib.addGenerator(llvm::cantFail(\n            llvm::orc::DynamicLibrarySearchGenerator::\n                GetForCurrentProcess(DL.getGlobalPrefix())));\n      }\n    ```", "```cpp\n\n      static std::unique_ptr<\n          llvm::orc::RTDyldObjectLinkingLayer>\n      createObjectLinkingLayer(\n          llvm::orc::ExecutionSession &ES,\n          llvm::orc::JITTargetMachineBuilder &JTMB) {\n        auto GetMemoryManager = []() {\n          return std::make_unique<\n              llvm::SectionMemoryManager>();\n        };\n        auto OLLayer = std::make_unique<\n            llvm::orc::RTDyldObjectLinkingLayer>(\n            ES, GetMemoryManager);\n    ```", "```cpp\n\n        if (JTMB.getTargetTriple().isOSBinFormatCOFF()) {\n          OLLayer\n             ->setOverrideObjectFlagsWithResponsibilityFlags(\n                  true);\n          OLLayer\n             ->setAutoClaimResponsibilityForObjectSymbols(\n                  true);\n        }\n        return OLLayer;\n      }\n    ```", "```cpp\n\n      static std::unique_ptr<llvm::orc::IRCompileLayer>\n      createCompileLayer(\n          llvm::orc::ExecutionSession &ES,\n          llvm::orc::RTDyldObjectLinkingLayer &OLLayer,\n          llvm::orc::JITTargetMachineBuilder JTMB) {\n        auto IRCompiler = std::make_unique<\n            llvm::orc::ConcurrentIRCompiler>(\n            std::move(JTMB));\n        auto IRCLayer =\n            std::make_unique<llvm::orc::IRCompileLayer>(\n                ES, OLLayer, std::move(IRCompiler));\n        return IRCLayer;\n      }\n    ```", "```cpp\n\n  static std::unique_ptr<llvm::orc::IRTransformLayer>\n  createOptIRLayer(\n      llvm::orc::ExecutionSession &ES,\n      llvm::orc::IRCompileLayer &CompileLayer) {\n    auto OptIRLayer =\n        std::make_unique<llvm::orc::IRTransformLayer>(\n            ES, CompileLayer,\n            optimizeModule);\n    return OptIRLayer;\n  }\n```", "```cpp\n\n      static llvm::Expected<llvm::orc::ThreadSafeModule>\n      optimizeModule(\n          llvm::orc::ThreadSafeModule TSM,\n          const llvm::orc::MaterializationResponsibility\n              &R) {\n    ```", "```cpp\n\n        TSM.withModuleDo([](llvm::Module &M) {\n          bool DebugPM = false;\n          llvm::PassBuilder PB(DebugPM);\n          llvm::LoopAnalysisManager LAM(DebugPM);\n          llvm::FunctionAnalysisManager FAM(DebugPM);\n          llvm::CGSCCAnalysisManager CGAM(DebugPM);\n          llvm::ModuleAnalysisManager MAM(DebugPM);\n          FAM.registerPass(\n              [&] { return PB.buildDefaultAAPipeline(); });\n          PB.registerModuleAnalyses(MAM);\n          PB.registerCGSCCAnalyses(CGAM);\n          PB.registerFunctionAnalyses(FAM);\n          PB.registerLoopAnalyses(LAM);\n          PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);\n          llvm::ModulePassManager MPM =\n              PB.buildPerModuleDefaultPipeline(\n                  llvm::PassBuilder::OptimizationLevel::O2,\n                  DebugPM);\n          MPM.run(M, MAM);\n        });\n        return TSM;\n      }\n    ```", "```cpp\n\n      llvm::Error addIRModule(\n          llvm::orc::ThreadSafeModule TSM,\n          llvm::orc::ResourceTrackerSP RT = nullptr) {\n        if (!RT)\n          RT = MainJITDylib.getDefaultResourceTracker();\n        return OptIRLayer->add(RT, std::move(TSM));\n      }\n    ```", "```cpp\n\n      llvm::Expected<llvm::orc::ExecutorSymbolDef>\n      lookup(llvm::StringRef Name) {\n        return ES->lookup({&MainJITDylib},\n                          Mangle(Name.str()));\n      }\n    ```", "```cpp\n\n    #include \"JIT.h\"\n    #include \"llvm/IRReader/IRReader.h\"\n    #include \"llvm/Support/CommandLine.h\"\n    #include \"llvm/Support/InitLLVM.h\"\n    #include \"llvm/Support/TargetSelect.h\"\n    ```", "```cpp\n\n    using namespace llvm;\n    ```", "```cpp\n\n    static cl::opt<std::string>\n        InputFile(cl::Positional, cl::Required,\n                  cl::desc(\"<input-file>\"));\n    ```", "```cpp\n\n    std::unique_ptr<Module>\n    loadModule(StringRef Filename, LLVMContext &Ctx,\n               const char *ProgName) {\n      SMDiagnostic Err;\n      std::unique_ptr<Module> Mod =\n          parseIRFile(Filename, Err, Ctx);\n      if (!Mod.get()) {\n        Err.print(ProgName, errs());\n        exit(-1);\n      }\n      return Mod;\n    }\n    ```", "```cpp\n\n    Error jitmain(std::unique_ptr<Module> M,\n                  std::unique_ptr<LLVMContext> Ctx,\n                  int argc, char *argv[]) {\n    ```", "```cpp\n\n      auto JIT = JIT::create();\n      if (!JIT)\n        return JIT.takeError();\n    ```", "```cpp\n\n      if (auto Err = (*JIT)->addIRModule(\n              orc::ThreadSafeModule(std::move(M),\n                                    std::move(Ctx))))\n        return Err;\n    ```", "```cpp\n\n      llvm::orc::ExecutorAddr MainExecutorAddr = MainSym->getAddress();\n      auto *Main = MainExecutorAddr.toPtr<int(int, char**)>();\n    ```", "```cpp\n\n      (void)Main(argc, argv);\n    ```", "```cpp\n\n      return Error::success();\n    }\n    ```", "```cpp\n\n    int main(int argc, char *argv[]) {\n      InitLLVM X(argc, argv);\n      InitializeNativeTarget();\n      InitializeNativeTargetAsmPrinter();\n      InitializeNativeTargetAsmParser();\n      cl::ParseCommandLineOptions(argc, argv, \"JIT\\n\");\n    ```", "```cpp\n\n      auto Ctx = std::make_unique<LLVMContext>();\n      std::unique_ptr<Module> M =\n          loadModule(InputFile, *Ctx, argv[0]);\n    ```", "```cpp\n\n      ExitOnError ExitOnErr(std::string(argv[0]) + \": \");\n      ExitOnErr(jitmain(std::move(M), std::move(Ctx),\n                        argc, argv));\n    ```", "```cpp\n\n      return 0;\n    }\n    ```", "```cpp\n\nadd_executable(JIT JIT.cpp)\ninclude_directories(${CMAKE_SOURCE_DIR})\ntarget_link_libraries(JIT ${llvm_libs})\n```", "```cpp\n\n$ cmake –G Ninja <path to jit source directory>\n$ ninja\n```", "```cpp\n\n$ cat main.c\n#include <stdio.h>\nint main(int argc, char** argv) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n```", "```cpp\n\n$ clang -S -emit-llvm main.c\n```", "```cpp\n\n$ JIT main.ll\nHello world!\n```"]