<html><head></head><body>
        

                            
                    <h1 class="header-title">Types of light sources and combining of lights</h1>
                
            
            
                
<p> In this chapter, we'll discuss the various types of lighting effects, such as diffuse light, ambient light, and specular light. You'll also explore the different type of light sources, such as directional light, point light, and spot light. We'll also discuss how to combine these different types of light sources for your game world.</p>
<p>In this chapter we'll cover the following topics:</p>
<ul>
<li>Implementing different light sources, such as directional, point, and spot light</li>
<li>Understanding the different effects of lights, such as diffused, ambient, and specular</li>
<li>How to combine different effects of light and the sources in your game world</li>
</ul>
<p>Let's get started.</p>
<p>You can refer to all the code files for this chapter in the <kbd>Chapter05</kbd> folder on GitHub. The GitHub link can be found in the preface of the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Directional light</h1>
                
            
            
                
<p class="mce-root">In this section, we're going to talk about a directional light. We are advancing quite a bit now into the different lighting mechanics that you can use in OpenGL. We've looked at lighting maps, to be able to shine a light and have it affect an object differently depending on what sort of material a particular object or a particular part of the object is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Directional lights</h1>
                
            
            
                
<p class="mce-root">We've looked at other basic material and basic lighting, but there are a few main types of lights that you can use in your game, such as directional lights, point lights, and spotlights. We'll be covering point lights and spotlights in later sections; but directional lights are the most basic version of lights in 3D graphics, in general:</p>
<div><img src="img/30b0c351-57f1-43f0-a528-39f7f48e379c.png" style=""/></div>
<p class="mce-root">So, as you can see in the preceding diagram, there are arrows coming from some sort of light source. A directional light doesn't have an origin, or more precisely, a position, because the light source is infinitely far away.</p>
<p class="mce-root">So, for example, you had five cubes. Irrespective of what material they are, let's just assume they were all the same and they were rotated in the same way, but were positioned all over the place. So, let's say each one of them was (we don't really have a concept of distance in miles or kilometers in our engine) 100 miles away from each other and in any direction. The actual light and the directional light would affect each individual box object in the same way because the directional light has no starting position. You can't get any closer to the light source; you might think that if you move in the light's direction, you'll get closer to the light source. Technically, you could say that's true. But if it has no original location and no original position, and it's infinitely far away, it's still going to be infinitely far away. So that's what a directional light is.</p>
<p class="mce-root">A directional light is sort of just a general light you have in the scene, and then you use spotlights and point lights to enhance your scene to create more specific stuff. So, let's consider this example. If you have a game that's set on flat ground or some island, then the directional light could be the sun.</p>
<p class="mce-root">If you're not really going vertically up, you're not going into space, you can't really get any nearer to the sun; then you could think of that as a directional light and most of the time, that is thought of as a directional light in a lot of games.</p>
<p class="mce-root">Again, it depends on what sort of game you're playing. If you're playing a game where you can go into space and you can get to the stars or the sun, then that really wouldn't be a directional light; that would be a different light. But more different types of light will be covered in different sections. So let's implement this by using the <kbd>shaders/lighting.frag</kbd> file, as shown in the following code:</p>
<pre>struct Light<br/>{<br/> //vec3 position;<br/> <strong>vec3 direction;</strong><br/> <br/> vec3 ambient;<br/> vec3 diffuse;<br/> vec3 specular;<br/>};</pre>
<p class="mce-root">What we are doing is commenting out an original position, <kbd>vec3 position</kbd>, and instead adding a direction, that is, <kbd>vec3 direction</kbd>.</p>
<p class="mce-root">In the diffuse lighting, we need to modify it slightly:</p>
<pre> // Diffuse<br/> vec3 norm = normalize(Normal);<br/> // vec3 lightDir = normalize(light.position - FragPos);<br/> <strong>vec3 lightDir = normalize(-light.direction);</strong><br/> float diff = max(dot(norm, lightDir), 0.0);<br/> vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));</pre>
<p class="mce-root">So, let's just comment out <kbd>lightDir</kbd> because though we're going to have a light direction again, we want to leave in this code in case we need it later on. So, add a new code line, <kbd>lightDir = normalize -light.direction</kbd>.</p>
<p class="mce-root">So that's all we have to do here, because we're not working out the difference between the position (<kbd>light.position</kbd>) and the actual fragment shader position (<kbd>FragPos</kbd>). We don't have to do that, because all we are concerned about is the light's direction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making changes to main code to integrate directional light in our world</h1>
                
            
            
                
<p class="mce-root">Now open the <kbd>main.cpp</kbd> file, which is used for the actual light and the shaders. Comment out our shader programs, because we're not going to actually use the lamp shader in this section, simply because we don't want any sort of light source with an origin position:</p>
<pre>// Build and compile our shader program<br/> Shader lightingShader( "res/shaders/lighting.vs",  <br/> "res/shaders/lighting.frag" );<br/> <strong>//Shader lampShader( "res/shaders/lamp.vs", "res/shaders/lamp.frag" );</strong></pre>
<p class="mce-root">Here we're going to use an array of different cube positions.</p>
<pre>// Positions all containers<br/> glm::vec3 cubePositions[] = {<br/> glm::vec3( 0.0f, 0.0f, 0.0f),<br/> glm::vec3( 2.0f, 5.0f, -15.0f),<br/> glm::vec3( -1.5f, -2.2f, -2.5f),<br/> glm::vec3( -3.8f, -2.0f, -12.3f),<br/> glm::vec3( 2.4f, -0.4f, -3.5f),<br/> glm::vec3( -1.7f, 3.0f, -7.5f),<br/> glm::vec3( 1.3f, -2.0f, -2.5f),<br/> glm::vec3( 1.5f, 2.0f, -2.5f),<br/> glm::vec3( 1.5f, 0.2f, -1.5f),<br/> glm::vec3( -1.3f, 1.0f, -1.5f)<br/> };</pre>
<p class="mce-root">We're going to spawn several cubes, very similar to what we've done before, and you can see the variance in having different cubes. We don't need the light vertex array object anymore because we're not doing the lamp shader, so let's just comment that out:</p>
<pre>/*<br/> // Then, we set the light's VAO (VBO stays the same. After all, the vertices are the same for the light object (also a 3D cube))<br/> GLuint lightVAO;<br/> glGenVertexArrays(1, &amp;lightVAO);<br/> glBindVertexArray(lightVAO);<br/> // We only need to bind to the VBO (to link it with glVertexAttribPointer), no need to fill it; the VBO's data already contains all we need.<br/> glBindBuffer(GL_ARRAY_BUFFER, VBO);<br/> // Set the vertex attributes (only position data for the lamp))<br/> glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0); // Note that we skip over the other data in our buffer object (we don't need the normals/textures, only positions).<br/> glEnableVertexAttribArray(0);<br/> glBindVertexArray(0);<br/> */</pre>
<p class="mce-root">All this looks good so far, but we've to do a few changes within the <kbd>while</kbd> loop, to the part where we're using the lighting shader. So, add <kbd>GLint lightDirLoc = glGetUniformLocation</kbd> and <kbd>glUniform3f</kbd>:</p>
<pre>// Use cooresponding shader when setting uniforms/drawing objects<br/> lightingShader.Use( );<br/> //GLint lightPosLoc = glGetUniformLocation(lightingShader.Program, "light.position");<br/><strong> GLint lightDirLoc = glGetUniformLocation( lightingShader.Program, "light.direction" )</strong>;<br/> GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, "viewPos" );<br/>//glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z);<br/><strong>glUniform3f( lightDirLoc, -0.2f, -1.0f, -0.3f );</strong><br/>glUniform3f( viewPosLoc, camera.GetPosition( ).x    , camera.GetPosition( ).y, camera.GetPosition( ).z );</pre>
<p class="mce-root">The view position location, which is just the camera's position, is fine. The ambient and the diffuse need not be changed. You can modify them if you want to, but it's not needed for this particular chapter.</p>
<p class="mce-root">Now, create a for loop as follows:</p>
<pre> // Draw 10 containers with the same VAO and VBO information; <br/>// only their world space coordinates differ<br/> glm::mat4 model;<br/> glBindVertexArray( boxVAO );<br/> <strong>for ( GLuint i = 0; i &lt; 10; i++)</strong><br/><strong> {</strong><br/><strong> model = glm::mat4( );</strong><br/><strong> model = glm::translate( model, cubePositions[i] );</strong><br/><strong> GLfloat angle = 20.0f * i;</strong><br/><strong> model = glm::rotate( model, angle, glm::vec3( 1.0f, 0.3f, 0.5f ) );</strong><br/><strong> glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );</strong><br/> <br/><strong> glDrawArrays( GL_TRIANGLES, 0, 36 );</strong><br/><strong> }</strong><br/> glBindVertexArray( 0 );</pre>
<p class="mce-root">Here, we add <kbd>glm::mat4</kbd> as a 4x4 matrix. We will call it model. Then we add  <kbd>glBindVertexArray</kbd>, which will take the box vertex array object. Sometimes we only want one cube; sometimes we want several, so we will use <kbd>cubePositions</kbd> and it will take the iterator as the index. Now we're going to add <kbd>GLfloat angle = 20.0f * i; model = glm::rotate</kbd> and for the rotation, it's going to take the model again. For the angle, we are just going to put angle. After that, we will add a vector,<kbd>glm::vec3</kbd>, and for this, we are just going to put <kbd>1.0f</kbd>, <kbd>0.3f</kbd>, and <kbd>0.5f</kbd>. We're just going to uniform the 4x4 matrix. Use <kbd>glUniformMatrix4fv</kbd>, because its four float values and <kbd>modelLoc</kbd>, which is what we created previously, will take the value <kbd>1</kbd>. Then add <kbd>GL_FALSE</kbd> and <kbd>glm::value_ptr (model)</kbd>. <kbd>glDrawArrays</kbd> will take <kbd>GL_TRIANGLES</kbd>, the starting index <kbd>0</kbd>, and <kbd>36</kbd> different vertices. So, if we put a semicolon there, we just need to <kbd>glBind</kbd> the vertex array to <kbd>0</kbd>, so we will just unbind it.</p>
<p class="mce-root">Now we will run this bad boy and we get Build Failed. This is happening because we commented out the light vertex array object and hence there's no need for us to use  <kbd>glDeleteVertexArrays( 1, &amp;lightVAO )</kbd>. So, now run it again and you will get Build Succeeded and the following output:</p>
<div><img src="img/0650b9a6-801a-4251-b1d3-9ed9596d1fb6.png" style=""/></div>
<p class="mce-root">Here, we've got our different objects. All of these objects are affected by the light in the same way. Obviously, there are angle differences, and that's what makes the intensity of the light affecting it different. But in terms of their position, that doesn't matter. Because the light is coming from one direction, the objects are affected exactly the same. They are just as dark and bright. The specular lighting will affect them just the same way, and it's the angle that makes the lighting affect it differently.</p>
<p class="mce-root">So far, we have learned about directional lights in modern OpenGL. We'll cover an advanced form of lighting in the next section where we'll create some really, really cool stuff with lighting. When you see all our games, especially games that look really, really good in terms of graphical fidelity, you'll find that when you start going under the layers and start doing programming in graphics, you'll see a lot of it's due to lighting.</p>
<p class="mce-root">The way lighting affects things has probably the biggest effect because by using normal lighting you can make an object look like it's got depth, even though it's just a flat texture, and that is pretty radical.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Point lights</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will discuss point lights. We've covered lighting systems in a bit of depth so far. One technique is directional lights, which essentially are light sources that point in a certain direction, hence the name directional light; but they do not have an original location, that is, they are infinitely far away. So, say for example, we have two objects that are exactly the same, rotated exactly the same way, and there's no other lighting affecting those objects; no matter how far they are away from each other, they will not be affected differently by the directional light source.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The point light concept</h1>
                
            
            
                
<p class="mce-root">A <strong>point light</strong> is a light that has an actual origin, and it emits the light in every single direction:</p>
<div><img src="img/361b24d4-eebe-4fec-93cf-eed080f9f7b9.png" style=""/></div>
<p class="mce-root">You can almost think of a point light like our sun or a star in real life. You could argue that the sun technically emits different amounts of light from different sides, but we could, for argument's sake, say it emits the same intensity, the same type of light from its origin in all directions. It's very common for, let's say, space games to have something like a point light as the sun, a star, or some other sort of object like that.</p>
<p class="mce-root">First of all, just open your lighting fragment shader, that is, <kbd>../shaders/lighting.frag</kbd>, and in this file, we need to modify a few things:</p>
<pre>struct Light<br/>{<br/> //vec3 direction;<br/> vec3 position;<br/> <br/> vec3 ambient;<br/> vec3 diffuse;<br/> vec3 specular;<br/> <br/> <strong>float constant;</strong><br/><strong> float linear;</strong><br/><strong> float quadratic;</strong><br/>};</pre>
<p class="mce-root">In the preceding code snippet, we will comment out the <kbd>direction</kbd> vector because we don't need the direction anymore since the lighting source has a position, and it just emits light in every direction. So, <kbd>ambient</kbd>, <kbd>diffuse</kbd>, and <kbd>specular</kbd> will need no changes. Now, we will add a constant, a linear, and a quadratic float. That's all for the lighting struct.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The diffuse section</h1>
                
            
            
                
<p class="mce-root">Now, let's check out the diffuse section:</p>
<pre>// Diffuse<br/> vec3 norm = normalize(Normal);<br/> <strong>vec3 lightDir = normalize(light.position - FragPos);</strong><br/> <strong>//vec3 lightDir = normalize(-light.direction);</strong> <br/> float diff = max(dot(norm, lightDir), 0.0);<br/> vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, <br/> TexCoords));</pre>
<p class="mce-root">We're still going to normalize our <kbd>Normal</kbd>, but we want the difference between the light position and the fragment position. So we'll comment out the light direction, <kbd>vec3 lightDir = normalize(-light.direction)</kbd> and we'll uncomment <kbd>light.position - FragPos</kbd>.</p>
<p class="mce-root">The difference, <kbd>max (dot( norm, lightDir)</kbd>, will be kept as it is. In terms of <kbd>diffuse</kbd>, we're still using <kbd>light.diffuse</kbd>, multiplying it by the <kbd>float diffuse</kbd> variable, <kbd>diff</kbd>, and then <kbd>vec3</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The specular section</h1>
                
            
            
                
<p class="mce-root">Let's look at the specular section now:</p>
<pre>// Specular<br/> vec3 viewDir = normalize(viewPos - FragPos);<br/> vec3 reflectDir = reflect(-lightDir, norm);<br/> float spec = pow(max(dot(viewDir, reflectDir), 0.0),   <br/> material.shininess);<br/> vec3 specular = light.specular * spec * <br/> vec3(texture(material.specular, TexCoords)); </pre>
<p class="mce-root">Here, the view direction and the reflection direction won't change. What we need to add is something called attenuation, something like, distance and lighting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The attenuation section</h1>
                
            
            
                
<p class="mce-root">Attenuation is essentially dropout. Attenuation lighting is a decrease in lighting as you move away from an object. Take a look at this image:</p>
<div><img src="img/192a78ff-bd4b-4424-b46e-5baed84f8879.png" style=""/></div>
<p class="mce-root">We've got four different light sources, <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>D</strong>. We will assume they're all the same. <strong>A</strong> has more of an effect on the ground than <strong>D</strong> because <strong>D</strong> is further away. So, basically attenuation is the fall-off.</p>
<p>So, let's implement it:</p>
<pre><strong>// Attenuation</strong><br/><strong> float distance = length(light.position - FragPos);</strong><br/><strong> float attenuation = 1.0f / (light.constant + light.linear * distance</strong><br/><strong> + light.quadratic * (distance * distance));</strong> </pre>
<p class="mce-root">In the preceding code snippet, if the light source was further away but still had the same sort of angle, it would still affect our object the same, and we don't want that. So, we will add <kbd>float distance = length(light.position - FragPos)</kbd>, and after that, add <kbd>float attenuation = 1.0f / (light.constant + light.linear * distance + light.quadratic * (distance * distance))</kbd>. So, this is how we calculated the distance and the attenuation.</p>
<p>If you want more information about how this works, feel free to check out the following links:
<ul>
<li><a href="https://open.gl/">https://open.gl</a></li>
<li><a href="https://learnopengl.com">https://learnopengl.com</a><a href="https://learnopengl.com"/></li>
</ul>
<p>These are great resources, so feel free to check them out. </p>
</p>
<p class="mce-root">Now we are going to add attenuation to the ambient, diffuse, and specular lights:</p>
<pre> // Attenuation<br/> float distance = length(light.position - FragPos);<br/> float attenuation = 1.0f / (light.constant + light.linear * <br/> distance + light.quadratic * (distance * distance));<br/> <br/> <strong>ambient *= attenuation;</strong><br/><strong> diffuse *= attenuation;</strong><br/><strong> specular *= attenuation;</strong></pre>
<p class="mce-root">We need these because all three of them will have attenuation factored in as they need to factor in distance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for changes in main.cpp</h1>
                
            
            
                
<p class="mce-root">Open the <kbd>main.cpp</kbd> file. We will have to do a few modifications to it. The first thing we need to actually uncomment out is <kbd>lampShader</kbd>:</p>
<pre>// Build and compile our shader program<br/> Shader lightingShader( "res/shaders/lighting.vs", <br/> "res/shaders/lighting.frag" );<br/> Shader lampShader( "res/shaders/lamp.vs", "res/shaders/lamp.frag" );</pre>
<p class="mce-root">This is because we're using the lamp again since we are dealing with the point light.</p>
<p class="mce-root">The next thing we need to change is the light vertex array object because we're using the lamp shader now. So, uncomment the following code block:</p>
<pre><strong> GLuint VBO, boxVAO;</strong><br/><strong> glGenVertexArrays( 1, &amp;boxVAO );</strong><br/><strong> glGenBuffers( 1, &amp;VBO );</strong><br/> <br/><strong> glBindBuffer( GL_ARRAY_BUFFER, VBO );</strong><br/><strong> glBufferData( GL_ARRAY_BUFFER, sizeof(vertices), </strong><br/><strong> vertices, GL_STATIC_DRAW );</strong><br/> <br/><strong> glBindVertexArray( boxVAO );</strong><br/><strong> glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 8 * </strong><br/><strong> sizeof( GLfloat ), ( GLvoid * )0 );</strong><br/><strong> glEnableVertexAttribArray(0);</strong><br/><strong> glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 8 * </strong><br/><strong> sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );</strong><br/><strong> glEnableVertexAttribArray( 1 );</strong><br/><strong> glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 8 * </strong><br/><strong> sizeof( GLfloat ), ( GLvoid * )( 6 * sizeof( GLfloat ) ) );</strong><br/><strong> glEnableVertexAttribArray( 2 );</strong><br/><strong> glBindVertexArray( 0 );</strong></pre>
<p class="mce-root">Now we need an emission map, so we will add <kbd>emissionMap</kbd>:</p>
<pre> // Load textures<br/> GLuint diffuseMap, specularMap, <strong>emissionMap</strong>;<br/> glGenTextures( 1, &amp;diffuseMap );<br/> glGenTextures( 1, &amp;specularMap );<br/> glGenTextures( 1, <strong>&amp;emissionMap</strong> );</pre>
<p class="mce-root">The only change we need to make now is actually within our <kbd>while</kbd> loop:</p>
<pre> lightingShader.Use( );<br/> <br/><strong> GLint lightPosLoc = glGetUniformLocation( lightingShader.Program,  </strong><br/><strong> "light.position" );<br/> //GLint lightDirLoc = glGetUniformLocation( lightingShader.Program,    <br/> //"light.direction" );</strong><br/> GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, <br/> "viewPos" );<br/> <strong>glUniform3f( lightPosLoc, lightPos.x, lightPos.y, lightPos.z );</strong><br/><strong> //glUniform3f( lightPosLoc, -02.f, 1.0f, -0.3f );</strong><br/> glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z );
 and comment out the directions, <kbd>GLint lightDirLoc = glGetUniformLocation( lightingShader.Program, "light.direction" );</kbd>, because again, the pointer light emits light in every direction. Also, don't forget to comment out <kbd>glUniform3f( lightPosLoc, -02.f, 1.0f, -0.3f );</kbd> and remove the comment from <kbd>glUniform3f( lightPosLoc, lightPos.x, lightPos.y, lightPos.z );</kbd></pre>
<p class="mce-root">Now, we also need to add the constants, the linear, and the quadratic, which are float values:</p>
<pre>// Set lights properties<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "light.ambient" ), 0.2f, 0.2f, 0.2f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "light.diffuse" ), 0.5f, 0.5f, 0.5f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "light.specular" ), 1.0f, 1.0f, 1.0f );<br/> <strong>glUniform1f( glGetUniformLocation( lightingShader.Program, "light.constant" ), 1.0f );</strong><br/><strong> glUniform1f( glGetUniformLocation( lightingShader.Program, "light.linear" ), 0.09 );</strong><br/><strong> glUniform1f( glGetUniformLocation( lightingShader.Program, "light.quadratic" ), 0.032 );</strong></pre>
<p class="mce-root">Now, in order to bind our textures, we need to uncomment out the <kbd>lampShader.Use( )</kbd> block. Also, delete the light vertex array object, that is, uncomment the <kbd>glDeleteVertexArrays( 1, &amp;lightVAO );</kbd> line:</p>
<pre> glDeleteVertexArrays( 1, &amp;boxVAO );<br/> <strong>glDeleteVertexArrays( 1, &amp;lightVAO );</strong><br/> glDeleteBuffers( 1, &amp;VBO );</pre>
<p class="mce-root"/>
<p class="mce-root">Now, we are ready to run our application and we get the following screen:</p>
<div><img class="aligncenter size-full wp-image-370 image-border" src="img/7df644a1-5179-4278-9289-a8bf38296192.png" style=""/></div>
<p class="mce-root">If you examine the output, we've got our original light source and the objects that are further away are a bit darker, as they should be.</p>
<p class="mce-root">But let's make one more change in <kbd>main.cpp</kbd>; we can actually move our light by uncommenting the following lines in the <kbd>while</kbd> loop:</p>
<ul>
<li class="mce-root"><kbd>lightPos.x -=0.005f;</kbd></li>
<li><kbd>lightPos.z -=0.005f;</kbd></li>
</ul>
<p>And now, if you re-run the application, as you can see in the following screenshot, attenuation is factored in. You can see that this object is getting slightly brighter now, and you'll actually start seeing this particular object getting brighter:</p>
<div><img class="aligncenter size-full wp-image-371 image-border" src="img/6ed63f29-bf47-432b-9963-1cd4d0bdc4db.png" style=""/></div>
<p>Now, again comment out the following lines back in the <kbd>while</kbd> loop:</p>
<ul>
<li class="mce-root"><kbd>lightPos.x -=0.005f;</kbd></li>
<li><kbd>lightPos.z -=0.005f;</kbd></li>
</ul>
<p>And, instead we will try changing the light position in the camera section:</p>
<pre>// Camera<br/>Camera camera( glm::vec3( 0.0f, 0.0f, 3.0f ) );<br/>GLfloat lastX = WIDTH / 2.0;<br/>GLfloat lastY = HEIGHT / 2.0;<br/>bool keys[1024];<br/>bool firstMouse = true;<br/><br/>// Light attributes<br/>glm::vec3 lightPos( 1.2f, 1.0f, <strong>-2.0f</strong> );</pre>
<p>So, as you can see in the preceding code, we have replaced <kbd>2.0f</kbd> to <kbd>-2.0f</kbd> in the light attributes section. Now, if you run your application, you can see the light is being emitted in every single direction. Nearer objects are brighter than more distant objects:</p>
<div><img src="img/b5e35832-190e-4e04-891a-8fd890d2c685.png" style=""/></div>
<p>So, that is it for point lights.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Spotlight </h1>
                
            
            
                
<p>Let's discuss and take a look at how we can add spotlights to our game. We've looked at directional lights, we've looked at point lights. Directional lights have a direction but they don't have an original position, so they are infinitely far away. A point light has a position but it shines light in every single direction, whereas a spotlight has a position and a direction.</p>
<p>Take a look at the following diagram of a spotlight:</p>
<div><img src="img/3b3fb65f-787c-4a2d-b82c-25d886312251.png" style=""/></div>
<p>So, the position of the light is high up somewhere, and you can also see that there is a direction for the light. It essentially creates a cone-like effect, sort of what a lamp or a torch would do. Spotlights are used on stages. But spotlights are used in several scenarios in games throughout your world.</p>
<p>So, without further ado, let's get on with coding our spotlights. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making changes to shader files</h1>
                
            
            
                
<p>Follow the below mentioned steps: </p>
<ol>
<li>Updating shader files is actually very, very simple. We only need to actually modify the lighting fragment shader in terms of the shader files; everything else looks fine. In <kbd>lighting.frag</kbd>, we can keep the <kbd>Material</kbd> struct as it is because it's got <kbd>diffuse</kbd>, <kbd>specular</kbd>, and <kbd>shininess</kbd>, and that's what we require for a spot light.</li>
<li>But with the light struct, we need the direction because the spotlight has an original position and a direction in which it is shining. So, we'll uncomment  <kbd>vec3 direction</kbd>. We also need a couple of float variables. The first one is <kbd>float cutOff</kbd>. The next one is <kbd>float outerCutOff</kbd>. Take a look at the following code: </li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>struct Material<br/>{<br/>     sampler2D diffuse;<br/>     sampler2D specular;<br/>     float shininess;<br/>};<br/>struct Light<br/>{<br/>     vec3 position;<br/>     vec3 direction;<br/>     <strong>float cutOff;</strong><br/><strong>     float outerCutOff;</strong><br/> <br/>     float constant;<br/>     float linear;<br/>     float quadratic;<br/> <br/>     vec3 ambient;<br/>     vec3 diffuse;<br/>     vec3 specular;<br/>};</pre>
<ol start="3">
<li>The rest of the terms till <kbd>void main</kbd> starts remain the same.  </li>
<li>In <kbd>void main</kbd>, the ambient calculation, the diffuse calculation, and the specular calculation aren't changing. Even the attenuation calculation isn't going to be changing. All we actually need to do is add an extra section for the spotlight, which is going to be calculating soft edges.</li>
<li>So, for the calculation of the soft edges, we're going to add <kbd>float theta = dot();</kbd>, and to this we are going to pass <kbd>lightDir</kbd>. This needs to be normalized, so we're passing <kbd>normalize()</kbd>. And then finally, here you need to specify <kbd>-light.direction</kbd>. You need to add a negative light value because you're doing it from the perspective of the camera, not from the user. That's the reason the position is negated. On the other line, we need to calculate the difference between <kbd>cutOff</kbd> and <kbd>outerCutOff</kbd>, so we'll add the following:</li>
</ol>
<pre style="padding-left: 60px">float epsilon = (light.cutOff - light.outerCutOff);</pre>
<ol start="6">
<li>Then add <kbd>float intensity = clamp();</kbd>. And in here, we are going to pass <kbd>theta - light.outerCutOff</kbd>. We want to divide this calculation by <kbd>epsilon</kbd> and then just put two values, <kbd>0.0</kbd> and <kbd>1.0</kbd>:</li>
</ol>
<pre style="padding-left: 60px">float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);</pre>
<ol start="7">
<li> Finally, we just need to add the intensity into <kbd>diffuse</kbd> and <kbd>specular</kbd>: </li>
</ol>
<pre style="padding-left: 60px">diffuse *= intensity;<br/>specular *= intensity;</pre>
<p>So, we're now actually done with the updating the shader.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Minor modification to Camera.h</h1>
                
            
            
                
<p>In this section, we'll need <kbd>GetFront</kbd>, which is a private variable in our main code. We'll make a minor modification for it in our <kbd>Camera.h</kbd> file. So, below the <kbd>glm:: vec3 GetPosition()</kbd> method, we'll add a simple method as follows:</p>
<pre>glm::vec3 GetFront()<br/>{<br/>    return this -&gt; front;<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Making changes to the main code</h1>
                
            
            
                
<p>Now, if we go to main.cpp, we'll make the following modifications:  </p>
<ol>
<li>We don't need <kbd>lampShader</kbd> because we're going to be doing it via a spotlight, so we'll comment out the code. The reason we don't need any sort of lamp shader or anything like that is because what we're going to do in this section is attach the spotlight to, essentially, the camera. You can almost think of it like those helmets with the light on top that people use for rock climbing and that sort of stuff. We're simply going to simulate that because directional light and point lights are great and if you have them static, they're easy to see and understand what is going on. With a spotlight, it really does help if you can move it, and the best way to move it is with the camera.</li>
<li>We'll comment out the light vertex array object as we don't need it anymore.</li>
<li>After we've commented that out, we can go directly into the while loop and we need to change a few things here. When we go to <kbd>lightingShader.Use</kbd>, we need to change some of the code there. We're going to add <kbd>GLint lightSpotDirLocation = glGetUniformLocation();</kbd>. In here, we need to pass <kbd>lightingShader.Program</kbd>, and the other parameter you need to specify is <kbd>"light.direction"</kbd>. What we are going to do next is duplicate the preceding code and make the following modifications to it:</li>
</ol>
<pre style="padding-left: 60px"> lightingShader.Use();<br/> GLint lightPosLoc = glGetUniformLocation( lightingShader.Program, "light.position" );<br/> <strong>GLint lightSpotdirLoc = glGetUniformLocation( lightingShader.Program, "light.direction" );</strong><br/><strong> GLint lightSpotCutOffLoc = glGetUniformLocation( lightingShader.Program, "light.cutOff" );</strong><br/><strong> GLint lightSpotOuterCutOffLoc = glGetUniformLocation( lightingShader.Program, "light.outerCutOff" );</strong><br/><strong> GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, "viewPos" );</strong><br/> glUniform3f( lightPosLoc, <strong>camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z</strong>);<br/> glUniform3f( <strong>lightSpotdirLoc</strong>, camera.GetFront( ).x, camera.GetFront( ).y, camera.GetFront( ).z);<br/> <strong>glUniform1f( lightSpotCutOffLoc, glm::cos( glm::radians( 12.5f ) ) );</strong><br/> <strong>glUniform1f( lightSpotOuterCutOffLoc, glm::cos( glm::radians( 17.5f ) ) );</strong><br/> glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z);</pre>
<ol start="4">
<li>We'll modify the remaining terms of <kbd>lightingShader</kbd> code where we set the light properties as follows:</li>
</ol>
<pre style="padding-left: 60px">glUniform3f( glGetUniformLocation( lightingShader.Program, "light.ambient" ),   <strong>0.1f, 0.1f, 0.1f</strong> );<br/>glUniform3f( glGetUniformLocation( lightingShader.Program, "light.diffuse" ), <strong>0.8f, 0.8f, 0.8f</strong> );<br/></pre>
<ol start="5">
<li>There's only one thing we're going to change in here now. We'll comment out the whole <kbd>lampShader</kbd> code. Because we commented out the declaration and initialization, we need to do the same here.</li>
<li>We also need to comment out <kbd>glDeleteVertexArrays();</kbd>.</li>
</ol>
<p>We're all ready to run this now. You will see similar output on your screen. So, as you can see, we've got some light. The spot light is attached to us.</p>
<p>So, if we move forward, as you can see, we've got sort of a spotlight effect, and it's more profound the closer we get to it, as seen in the following screenshot:</p>
<div><img src="img/dbabce09-5e94-4d38-bbb3-0cb242d2d466.png" style=""/></div>
<p>Otherwise, it's very wide as we move further away from the objects, as seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"> <img src="img/4b6b6d74-0d58-4c8c-bc75-0803755a7255.png" style="width:25.50em;height:21.00em;"/></p>
<p>Hence, they're smaller. As we look around, we get a sort of spotlight effect. As you can see, it affects objects that are further away slightly differently, and we have this really cool spotlight, as seen in the following screenshot:</p>
<div><img src="img/2c107481-f0bc-4cc8-be1b-200ac41a92ab.png" style=""/></div>
<p>Let's try and do it on a corner, as follows: </p>
<div><img src="img/8e3cab23-d7f1-4482-ae37-608c8c1d507d.png" style=""/></div>
<p>We've got this really cool spotlight that is attached to our head. You could go ahead and create some sort of building game or some sort of miner's game where you have a light on your head. That would be pretty cool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combining light</h1>
                
            
            
                
<p class="mce-root">In this section, we're going to be looking at combining our light sources. So far we've covered directional lights, point lights, and spotlights in the previous sections. The following is a brief overview of what they are:</p>
<ul>
<li class="mce-root"><strong>Directional light</strong>: A directional light is a light that has a particular direction. It shines light in a particular direction. But it doesn't have a location, a position. It's just infinitely far away from everything.</li>
<li class="mce-root"><strong>Point light</strong>: A point light has a position, but it shines light in every single direction. Depending on what you're doing and what sort of game you've got, you could potentially have the sun or a star' as a directional light, but if you could go into space, go around your star or get near it, then you'd probably want a point light.</li>
<li class="mce-root"><strong>Spotlight</strong>: A spotlight essentially is like a lamp. It casts a light in an initial position, and then in a direction as well. So it's like a combination of the preceding two types of light.</li>
</ul>
<p class="mce-root">In the previous sections, we looked at all of them, but at the moment, in these sections, we've just been covering them one at a time. We've either been commenting out code or modifying code to just show one realistically. But in a real game scenario or a free application scenario, you'll want multiple light sources. You'll want multiple instances of directional lights, point lights, and spotlights. You'll probably want to try and create your own really cool effects as well. In this section, we're going to be combining our three types of light casters.</p>
<p>As usual, we'll start by updating the shader files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting the shader files ready </h1>
                
            
            
                
<p>Take a look at the below mentioned steps: </p>
<ol>
<li class="mce-root">The first thing that we need to do is go to the fragment shader for lighting, <kbd>lighting.frag</kbd>. That's the only shader that we actually need to modify, so we won't touch <kbd>lighting.vs</kbd>. Check out the following steps to understand the changes that we need to make to the fragment shader:</li>
<li class="mce-root">So, first of all, we're going to add <kbd>#define</kbd>, and this is just going to be <kbd>NUMBER_OF_POINT_LIGHTS</kbd>. For our project, we'll add the value as 4 because we're going to have four point lights.</li>
</ol>
<ol start="3">
<li class="mce-root">Next, we're going to need a data type for three different types of light source: a directional light, a point light, and a spotlight. For that, what we'll do is actually duplicate the struct that we already have in code. We'll rename each one of them appropriately: <kbd>DirLight</kbd> for directional light,  <kbd>PointLight</kbd> for point light, and <kbd>SpotLight</kbd> for the spot light. We don't need all of the vectors and the floats that we've got in the structs. Take a look at the following code to understand all the changes we need to make in the new struct that we have defined: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px">version 330 core<br/>#define NUMBER_OF_POINT_LIGHTS 4<br/>struct Material<br/>{<br/>     sampler2D diffuse;<br/>     sampler2D specular;<br/>     float shininess;<br/>};</pre>
<ol start="4">
<li class="mce-root">The directional light, as you may remember, doesn't have a position, it has a direction. It has an ambient, diffuse, and specular, but it doesn't have any of the float variables: constant linear and quadratic. So we'll just remove them: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px">struct DirLight<br/>{<br/>     vec3 direction;<br/> <br/>     vec3 ambient;<br/>     vec3 diffuse;<br/>     vec3 specular;<br/>};</pre>
<ol start="5">
<li>For the point light, remember it doesn't have a direction; it has a position because it just emits light in every direction. We can get rid of <kbd>cutOff</kbd> and <kbd>outerCutOff</kbd>, but we're going to need everything else:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">struct PointLight<br/>{<br/>     vec3 position;<br/> <br/>     float constant;<br/>     float linear;<br/>     float quadratic;<br/> <br/>     vec3 ambient;<br/>     vec3 diffuse;<br/>     vec3 specular;<br/>};</pre>
<ol start="6">
<li>For the spotlight, nothing will be changing in here because this structure was created in the previous section, which covered spotlights:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">struct SpotLight<br/>{<br/>     vec3 position;<br/>     vec3 direction;<br/>     float cutOff;<br/>     float outerCutOff;<br/> <br/>     float constant;<br/>     float linear;<br/>     float quadratic;<br/> <br/>     vec3 ambient;<br/>     vec3 diffuse;<br/>     vec3 specular;<br/>};</pre>
<ol start="7">
<li class="mce-root">As we move down, <kbd>uniform Light light</kbd> is going to change slightly as we've got three different sources of light. So we'll make the following changes to it:</li>
</ol>
<pre style="padding-left: 60px">uniform <strong>DirLight dirLight</strong>;<br/>uniform <strong>PointLight pointLights[NUMBER_OF_POINT_LIGHTS]</strong>;<br/>uniform <strong>SpotLight spotLight</strong>;<br/>uniform Material material;</pre>
<p class="mce-root" style="padding-left: 60px">In the preceding code, for a <kbd>PointLight</kbd> as you may remember, we created a <kbd>#define</kbd>. So, the <kbd>uniform PointLight</kbd> is going to be an array of lights. Even though we're creating multiple spotlights and only one directional light and spotlight, you can create multiple directional lights and you can create multiple spotlights such as lamps, lights on a stick and that sort of thing. You might have one really strong source of light such as a directional light that could be simulating the sun, and then you might have just other general small lights.</p>
<ol start="8">
<li class="mce-root">What we need to do next is create some function prototypes because at the moment, what we've been doing is just doing everything in main. This has been alright for now, but we need a bit more flexibility with the way we're doing things. So, we're going to add <kbd>vec3 CalcDirLight();</kbd>, and this is going to take a few parameters such as <kbd>DirLight</kbd>. Then we're going to take a <kbd>vec3</kbd> for the normal. We've explained the use of all of these different vectors and properties before. Again, we're just combining what we've done over the past few sections.  And then, we'll duplicate the code and make the following highlighted changes to it:</li>
</ol>
<pre style="padding-left: 60px">// Function prototypes<br/>vec3 CalcDirLight( DirLight light, vec3 normal, vec3 viewDir );<br/>vec3 CalcPointLight( <strong>PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir</strong> );<br/>vec3 CalcSpotLight( <strong>SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir</strong> );</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Making modifications void main of lighting.frag </h1>
                
            
            
                
<p>Check out the following steps to understand the modifications: </p>
<ol>
<li class="mce-root">In the void main of <kbd>lighting.frag</kbd>, we're going to get rid of all the initially present code and add fresh code to it. We'll start by adding <kbd>vec3</kbd> normal. We're just going to be normalizing using <kbd>Normal</kbd>.</li>
<li class="mce-root">Then we're going to create a vec3 for <kbd>viewDir</kbd>. This is going to normalize the difference between <kbd>viewPos</kbd> and <kbd>FragPos</kbd>.  </li>
<li class="mce-root">Now we need to do the directional lighting calculation. With this, we're just going to be calling the <kbd>CalcDirLight</kbd> method. So, we're not going to be doing much code in main. Because we're adding more stuff to it, it's becoming like another C++ project because we are abstracting it out into different methods, so we can reuse this code when and where we need to. So, we'll add <kbd>vec3 result</kbd> and we'll assign the value of <kbd>CalcDirLight();</kbd>, and this is going to take the <kbd>dirLight</kbd> variable, the <kbd>norm</kbd> that we've just calculated, and the <kbd>viewDir</kbd>.</li>
<li class="mce-root">Next, we're just going to loop over the point lights, then factor them in. So, add a for loop and pass the initializing parameters, <kbd>int i = 0; i &lt; NUMBER_OF_POINT_LIGHTS; i++</kbd>. In the <kbd>for</kbd> loop we are going to add <kbd>result += CalcPointLight() </kbd>. Again, what we're doing now is adding the effect of the different point lights to our result because again, this lighting is affecting our particular object, and this is the way it's done. So, to <kbd>CalcPointLight()</kbd> we're going to pass <kbd>pointLights[i]</kbd>, <kbd>norm</kbd>, and  <kbd>FragPos</kbd>. </li>
<li class="mce-root">What we're going to do now is add the code for the spotlight. So, we'll factor in the spotlight and add <kbd>result += CalcSpotLight()</kbd>. And this simply takes in the <kbd>spotLight</kbd> variable, <kbd>norm</kbd>, <kbd>FragPos</kbd>, and <kbd>viewDir</kbd>.Then we'll add <kbd>color = vec4(result,1.0);</kbd>. Take a look at the following code to understand the description: </li>
</ol>
<pre style="padding-left: 60px">void main( )<br/>{<br/> // Properties<br/> vec3 norm = normalize( Normal );<br/> vec3 viewDir = normalize( viewPos - FragPos );<br/> <br/> // Directional lighting<br/> vec3 result = CalcDirLight( dirLight, norm, viewDir );<br/> <br/> // Point lights<br/> for ( int i = 0; i &lt; NUMBER_OF_POINT_LIGHTS; i++ )<br/> {<br/> result += CalcPointLight( pointLights[i], norm, FragPos, viewDir );<br/> }<br/> <br/> // Spot light<br/> result += CalcSpotLight( spotLight, norm, FragPos, viewDir );<br/> <br/> color = vec4( result, 1.0 );<br/>}</pre>
<ol start="6">
<li class="mce-root">This is all stuff we've done before, and we're just abstracting it out now.</li>
<li class="mce-root">Now let's do the calculation of colors for the different sources of light. So here, what we'll do is copy and paste the <kbd>vec3 calc</kbd> code for all three sources of light. Now let's do the directional light calculation. So to the <kbd>vec3 CalcDirLight()</kbd> method we'll add  vec3 lightDir, and this is going to equal to <kbd>normalize( -light.direction );</kbd>.</li>
</ol>
<p class="mce-root" style="padding-left: 60px">The reason for <kbd>-light.direction</kbd> is because we're not doing it from our object, we're doing it from the light. So, instead of the way the object is looking at the light, it's coming from the light. So, that's the reason why it's flipped.</p>
<ol start="8">
<li class="mce-root">And now we need to add float. This is going to be the diffuse shading. So, <kbd>diff = max ()</kbd>, and to <kbd>max()</kbd> we'll pass <kbd>dot( normal, lightDir ), 0.0</kbd>.</li>
<li class="mce-root">Next, we're going to be calculating the specular shading. So add <kbd>vec3 reflectDir = reflect()</kbd>, and to <kbd>reflect()</kbd> we'll pass <kbd>-lightDir</kbd>, <kbd>normal </kbd>.</li>
<li class="mce-root">Then we'll add  <kbd>float spec = pow()</kbd> , and to that we'll pass <kbd>max ()</kbd>, and to <kbd>max()</kbd> we'll pass <kbd>dot( viewDir, reflectDir )</kbd> and  <kbd>0.0</kbd>.</li>
<li class="mce-root">Finally, we need to add <kbd>material.shininess</kbd>. Now we need to combine the results. So, add <kbd>vec3 ambient = light.ambient * vec3 ();</kbd>, and to <kbd>vec3()</kbd> we'll pass <kbd>texture( material.diffuse, TexCoords )</kbd>. This is going to be the texture diffuse and the texture coordinates, and for the diffuse and specular light it's similar to ambient light, so make the highlighted changes to in the following code. Also, take a look at the following code to understand the preceding description: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> vec3 CalcDirLight( DirLight light, vec3 normal, vec3 viewDir )<br/>{<br/> vec3 lightDir = normalize( -light.direction );<br/> <br/> // Diffuse shading<br/> float diff = max( dot( normal, lightDir ), 0.0 );<br/> <br/> // Specular shading<br/> vec3 reflectDir = reflect( -lightDir, normal );<br/> float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );<br/> <br/> // Combine results<br/> vec3 ambient = light.ambient * vec3( texture( material.diffuse, TexCoords ) );<br/> <strong>vec3 diffuse = light.diffuse * diff * vec3( texture( material.diffuse, TexCoords ) );</strong><br/><strong> vec3 specular = light.specular * spec * vec3( texture( material.specular, TexCoords ) );</strong><br/> <br/> return ( ambient + diffuse + specular );<br/>}</pre>
<p style="padding-left: 60px">In the preceding code, we just need to return the calculation, which is <kbd>ambient + diffuse + specular</kbd>.</p>
<ol start="12">
<li class="mce-root">Now we need to calculate the point light, so what we'll do is duplicate the lines of code mentioned in the previous steps and paste in the <kbd>CalcPointLight()</kbd>  method; we'll add, change, and remove what we need to. Take a look at the following highlighted code to understand the changes: </li>
</ol>
<pre style="padding-left: 60px">// Calculates the color when using a point light.<br/>vec3 CalcPointLight( PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir )<br/>{<br/> vec3 lightDir = normalize( <strong>light.position - fragPos</strong> );<br/> <br/> // Diffuse shading<br/> float diff = max( dot( normal, lightDir ), 0.0 );<br/> <br/> // Specular shading<br/> vec3 reflectDir = reflect( -lightDir, normal );<br/> float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );<br/> <br/><strong> // Attenuation</strong><br/><strong> float distance = length( light.position - fragPos );</strong><br/><strong> float attenuation = 1.0f / ( light.constant + light.linear * distance + light.quadratic * ( distance * distance ) );</strong><br/> <br/> // Combine results<br/> vec3 ambient = light.ambient * vec3( texture( material.diffuse, TexCoords ) );<br/> vec3 diffuse = light.diffuse * diff * vec3( texture( material.diffuse, TexCoords ) );<br/> vec3 specular = light.specular * spec * vec3( texture( material.specular, TexCoords ) );<br/> <br/> <strong>ambient *= attenuation;</strong><br/><strong> diffuse *= attenuation;</strong><br/><strong> specular *= attenuation;</strong><br/> <br/> return ( ambient + diffuse + specular );<br/>}</pre>
<p class="mce-root" style="padding-left: 60px">In the preceding code, after defining the <kbd>specular</kbd> shading we added the attenuation code, as we need to factor in the attenuation.  </p>
<ol start="13">
<li class="mce-root">Now we need to do the calculations for the <kbd>spotlight ()</kbd> method. Again, we're just going to copy and paste the previous code because we'll most likely be adding quite a lot to it, but we'll need most of it. So take a look at the following highlighted code:</li>
</ol>
<pre style="padding-left: 60px">// Calculates the color when using a spot light.<br/>vec3 CalcSpotLight( SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir )<br/>{<br/> vec3 lightDir = normalize( light.position - fragPos );<br/> <br/> // Diffuse shading<br/> float diff = max( dot( normal, lightDir ), 0.0 );<br/> <br/> // Specular shading<br/> vec3 reflectDir = reflect( -lightDir, normal );<br/> float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );<br/> <br/> // Attenuation<br/> float distance = length( light.position - fragPos );<br/> float attenuation = 1.0f / ( light.constant + light.linear * distance + light.quadratic * ( distance * distance ) );<br/> <br/><strong> // Spotlight intensity</strong><br/><strong> float theta = dot( lightDir, normalize( -light.direction ) );</strong><br/><strong> float epsilon = light.cutOff - light.outerCutOff;</strong><br/><strong> float intensity = clamp( ( theta - light.outerCutOff ) / epsilon, 0.0, 1.0 );</strong><br/> <br/> // Combine results<br/> vec3 ambient = light.ambient * vec3( texture( material.diffuse, TexCoords ) );<br/> vec3 diffuse = light.diffuse * diff * vec3( texture( material.diffuse, TexCoords ) );<br/> vec3 specular = light.specular * spec * vec3( texture( material.specular, TexCoords ) );<br/> <br/> ambient *= attenuation <strong>* intensity;</strong><br/> diffuse *= attenuation <strong>* intensity;</strong><br/> specular *= attenuation <strong>* intensity;</strong><br/> <br/> return ( ambient + diffuse + specular );<br/>}</pre>
<p class="mce-root">In the preceding code, before we go on to the <kbd>ambient</kbd>, <kbd>diffuse</kbd>, and <kbd>specular</kbd> vectors, we needed to add the spotlight intensity calculation code. Take a good look at the highlighted code. Then, finally, we just need to factor in the intensity. So we just multiplied the attenuation by the intensity in the final lines of code.</p>
<p class="mce-root">We're done now updating the fragment lighting shader. We've covered all of this before in the previous sections. We are just combining it all together. Now, we're done. I'm sure there are going to be errors, because there's quite a lot of code in here, so we'll get to that when we start compiling it. So let's just save it.</p>
<p>Now we will move on to our main code to make modifications to it.    </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changes to the main code</h1>
                
            
            
                
<p>Follow the below mentioned steps to combine the light source in our code: </p>
<ol>
<li class="mce-root">In <kbd>main.cpp</kbd>, we need the lamp shader, so we'll uncomment it. After <kbd>cubePositions</kbd>, because now we've got multiple point light positions, we're going to add <kbd>glm::vec3</kbd>, and this is going to be called <kbd>pointLightPositions[]</kbd>. We are going to add <kbd>glm::vec3();</kbd> in there, and for this, we are going to pass <kbd>0.7f</kbd>, <kbd>0.2f</kbd>, and <kbd>2.0f</kbd>. Duplicate this line of code,  paste it four times, and make the following changes: </li>
</ol>
<pre style="padding-left: 60px">  // Positions of the point lights<br/>     glm::vec3 pointLightPositions[] = <br/>{<br/>     glm::vec3( 0.7f, 0.2f, 2.0f ),<br/>     glm::vec3( <strong>2.3f, -3.3f, -4.0f</strong> ),<br/>     glm::vec3( <strong>-4.0f, 2.0f, -12.0f</strong> ),<br/>     glm::vec3( <strong>0.0f, 0.0f, -3.0f</strong> )<br/> };</pre>
<ol start="2">
<li>Next, we'll uncomment the light vertex array object as we need it now to combine the lights.  </li>
<li>The major changes that we need to make are within the <kbd>while</kbd> loop now. We're using the lighting shader, so we'll make the following changes to it: </li>
</ol>
<pre style="padding-left: 60px">// Use cooresponding shader when setting uniforms/drawing objects<br/> lightingShader.Use( );<br/> GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, "viewPos" );<br/> glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z);<br/> // Set material properties<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "material.shininess" ), 32.0f );</pre>
<ol start="4">
<li>We're setting the uniforms for the directional light:  </li>
</ol>
<pre style="padding-left: 60px"> // Directional light<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "dirLight.direction" ), -0.2f, -1.0f, -0.3f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "dirLight.ambient" ), 0.05f, 0.05f, 0.05f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "dirLight.diffuse" ), 0.4f, 0.4f, 0.4f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "dirLight.specular" ), 0.5f, 0.5f, 0.5f );</pre>
<ol start="5">
<li>Then we'll set the uniforms for point light 1:</li>
</ol>
<pre style="padding-left: 60px">// Point light 1<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[0].position" ), pointLightPositions[0].x, pointLightPositions[0].y, pointLightPositions[0].z );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[0].ambient" ), 0.05f, 0.05f, 0.05f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[0].diffuse" ), 0.8f, 0.8f, 0.8f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[0].specular" ), 1.0f, 1.0f, 1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[0].constant" ), 1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[0].linear" ), 0.09f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[0].quadratic" ), 0.032f );</pre>
<ol start="6">
<li>Similarly, set the uniforms for point light 2: </li>
</ol>
<pre style="padding-left: 60px">// Point light 2<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[1].position" ), pointLightPositions[1].x, pointLightPositions[1].y, pointLightPositions[1].z );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[1].ambient" ), 0.05f, 0.05f, 0.05f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[1].diffuse" ), 0.8f, 0.8f, 0.8f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[1].specular" ), 1.0f, 1.0f, 1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[1].constant" ), 1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[1].linear" ), 0.09f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[1].quadratic" ), 0.032f );</pre>
<ol start="7">
<li>Here are the definition of the uniforms for point light 3:</li>
</ol>
<pre style="padding-left: 60px"> // Point light 3<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[2].position" ), pointLightPositions[2].x, pointLightPositions[2].y, pointLightPositions[2].z );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[2].ambient" ), 0.05f, 0.05f, 0.05f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[2].diffuse" ), 0.8f, 0.8f, 0.8f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[2].specular" ), 1.0f, 1.0f, 1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[2].constant" ), 1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[2].linear" ), 0.09f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[2].quadratic" ), 0.032f );</pre>
<ol start="8">
<li>Here are the definitions for point light 4:</li>
</ol>
<pre style="padding-left: 60px">// Point light 4<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[3].position" ), pointLightPositions[3].x, pointLightPositions[3].y, pointLightPositions[3].z );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[3].ambient" ), 0.05f, 0.05f, 0.05f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[3].diffuse" ), 0.8f, 0.8f, 0.8f );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "pointLights[3].specular" ), 1.0f, 1.0f, 1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[3].constant" ),  1.0f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[3].linear" ), 0.09f );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "pointLights[3].quadratic" ), 0.032f );<br/> </pre>
<ol start="9">
<li>Then we'll define uniforms for the spotlight as follows:</li>
</ol>
<pre style="padding-left: 60px">// SpotLight<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "spotLight.position" ), camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z );<br/> glUniform3f( glGetUniformLocation( lightingShader.Program, "spotLight.direction" ), camera.GetFront( ).x, camera.GetFront( ).y, camera.GetFront( ).z );<br/> <br/>glUniform3f( glGetUniformLocation( lightingShader.Program, "spotLight.ambient" ), 0.0f, 0.0f, 0.0f );<br/><br/> glUniform3f( glGetUniformLocation( lightingShader.Program, <br/>"spotLight.diffuse" ), 1.0f, 1.0f, 1.0f );<br/><br/> glUniform3f( glGetUniformLocation( lightingShader.Program, <br/>"spotLight.specular" ), 1.0f, 1.0f, 1.0f );<br/><br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "spotLight.constant" ), 1.0f );<br/> <br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "spotLight.linear" ), 0.09f );<br/> <br/>glUniform1f( glGetUniformLocation( lightingShader.Program, "spotLight.quadratic" ), 0.032f );<br/> <br/>glUniform1f( glGetUniformLocation( lightingShader.Program, "spotLight.cutOff" ), glm::cos( glm::radians( 12.5f ) ) );<br/> glUniform1f( glGetUniformLocation( lightingShader.Program, "spotLight.outerCutOff" ), glm::cos( glm::radians( 15.0f ) ) );</pre>
<p style="padding-left: 60px">In the preceding lines of code, we set all the uniforms for the 5 or 6 types of lights we have. We have to set them manually and index the proper <kbd>PointLight</kbd> struct in the array to set each uniform variable. This can be made more code-friendly by defining light types as classes and setting their values in there, or by using a more efficient uniform approach by using uniform buffer objects.</p>
<ol start="10">
<li>We've still got all of the code that we don't need anymore, so, from just below the point where we finished our spotlight stuff to the point where we start defining our view matrix, we need to get rid of that all that code. These are the remnants from when we only had one type of light, and it was called <kbd>Light</kbd>, so we'll get rid of that.</li>
<li>We need to comment back in the shader, and I need to comment back in the deleting of the light vertex array object.</li>
<li>We've looped through our box array, we have created all the different boxes, and we've got our lamp shader. Remember, we've got multiple point lights, so we just need to create a loop for that. So, after binding the vertex array and unbinding it, we need to add <kbd>glBindVertexArray( lightVAO );</kbd>.</li>
<li>Then we'll add our  <kbd>for</kbd> loop and pass the initializing parameters for the loop as  <kbd>GLuint i = 0; i &lt; 4; i++</kbd>, and to the loop we're going to add, <kbd>model = glm:: mat4();</kbd>.</li>
<li>Then, on the other line, we are going to add <kbd>model = glm::translate();</kbd>, and this is just going to be translating the <kbd>model</kbd>. And then the vector for this is going to be <kbd>pointLightPositions</kbd>. Then pass the iterator <kbd>[i]</kbd>.</li>
<li>And now, we're just going to make the cube a little bit smaller, as we have done before. So we'll add <kbd>model = glm::scale();</kbd>, and to that we are going to pass <kbd>model</kbd> and <kbd>glm::vec3( 0.2f )</kbd>.</li>
<li>On the other line we're going to add <kbd>glUniformMatrix4fv()</kbd> because it's a 4x4 matrix, and to that, we need to pass <kbd>modelLoc, 1, GL_FALSE;</kbd>, and <kbd>glm:: value_ptr()</kbd>; to this, we are going to pass the model.</li>
<li>Then we'll add <kbd>glDrawArrays();</kbd>, and to that, we'll pass <kbd>GL_TRIANGLES</kbd>, <kbd>0</kbd>, and <kbd>36</kbd>. And, after this for loop is completed on the other line, we need to unbind the vertex array as <kbd>glBindVertexArray( 0 );</kbd>. Take a look at the following code to understand the description: </li>
</ol>
<pre style="padding-left: 60px">// We now draw as many light bulbs as we have point lights.<br/> glBindVertexArray( lightVAO );<br/> for ( GLuint i = 0; i &lt; 4; i++ )<br/> {<br/> model = glm::mat4( );<br/> model = glm::translate( model, pointLightPositions[i] );<br/> model = glm::scale( model, glm::vec3( 0.2f ) ); // Make it a smaller cube<br/> glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );<br/> glDrawArrays( GL_TRIANGLES, 0, 36 );<br/> }<br/> glBindVertexArray( 0 );</pre>
<p>We are now all set to run the code. Save the updated code and compile it. You will get output similar to the following on your screen: </p>
<div><img class="aligncenter size-full wp-image-372 image-border" src="img/a2be11c3-3074-454d-89c2-dd74675550ff.png" style=""/></div>
<p>We've got our multiple light sources, four of which are point lights and one of which is just a regular lamp. We recommend you figure out which ones are the point lights and which one is the lamp. As you can see, we have the spotlight that is attached, and we also have the general directional light. You might be thinking that it's hard to tell which light is which, and generally, in the real world, it's hard to tell too. Light has an effect on everything around us, and this is how it works in the game. Now if you try to go further away from the object, our spotlight really isn't affecting the cube anymore, but it's still there, as seen in the following screenshot: </p>
<div><img src="img/123d6f1e-1ae6-46d3-bee8-3c5e1ceb4146.png" style=""/></div>
<p>As we get closer to it, it starts affecting the object:</p>
<div><img src="img/8fa7a101-2e88-4f72-b9a4-8780bc8d8f4a.png" style=""/></div>
<p>It's cool to see how the effect is combined with the other light sources. So, that's it for combining directional lights, point lights, and spotlights. There is a lot of lengthy code in this chapter, but a lot of it we've already done before. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary </h1>
                
            
            
                
<p>In this chapter, we discussed about the different types of light sources such as directional, point and spotlight. Then we learned how to combine these light source and the lighting effects to generate realistic lighting in our game world. </p>
<p>In the next chapter, we'll discuss about the cube maps and we'll learn to generate the skybox using for our game.</p>


            

            
        
    </body></html>