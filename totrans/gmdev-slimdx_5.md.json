["```cpp\nusing SlimDX.D3DCompiler;\nusing SlimDX.Direct3D11;\nusing SlimDX.DirectInput;\nusing SlimDX.DXGI\nusing SlimDX;\n```", "```cpp\nSlimDX.Direct3D11.Device m_Device;\nSlimDX.Direct3D11.DeviceContext m_DeviceContext;\nRenderTargetView m_RenderTargetView;\nSwapChain m_SwapChain;\nViewport m_Viewport;\n\nInputLayout m_InputLayout;\n\nVertexShader m_VertexShader;\nShaderSignature m_VShaderSignature;\nPixelShader m_PixelShader;\n\nSlimDX.Direct3D11.Buffer m_VertexBuffer;\n```", "```cpp\npublic void InitD3D()\n{\n    // Setup the configuration for the SwapChain.\n    var swapChainDesc = new SwapChainDescription()\n    {\n        BufferCount = 2, // 2 back buffers (Triple Buffering)\n        Usage = Usage.RenderTargetOutput,\n        OutputHandle = FormObject.Handle,\n\n        IsWindowed = true,\n        ModeDescription = new ModeDescription(FormObject.Width,\n          FormObject.Height,new Rational(60, 1),Format.R8G8B8A8_UNorm),\n        SampleDescription = new SampleDescription(1, 0),\n        Flags = SwapChainFlags.AllowModeSwitch,\n        SwapEffect = SwapEffect.Discard\n    };\n\n    // Create the SwapChain\n\n    SlimDX.Direct3D11.Device.CreateWithSwapChain(\n      DriverType.Hardware,\n      DeviceCreationFlags.Debug,\n      new FeatureLevel[] { FeatureLevel.Level_11_0 },\n      swapChainDesc,\n      out m_Device,\n\nout m_SwapChain);\n\n    // create a view of our render target, which is the backbuffer of the swap chain we just created\n    using (var resource =SlimDX.Direct3D11.Resource.FromSwapChain<Texture2D>(m_SwapChain, 0))\n    {\n        m_RenderTargetView = new RenderTargetView(m_Device,resource);\n    }\n\n    // Get the device context and store it in our m_DeviceContext member variable.\n    m_DeviceContext = m_Device.ImmediateContext;\n\n    // Setting a viewport is required if you want to actually see anything\n    m_Viewport = new Viewport(0.0f,0.0f,m_Form.Width,m_Form.Height,0.0f,1.0f);\n\n    m_DeviceContext.Rasterizer.SetViewports(m_Viewport);\n    m_DeviceContext.OutputMerger.SetTargets(m_RenderTargetView);\n\n    // Prevent DXGI handling of Alt+Enter since it does not work properly with Winforms\n    using (var factory = m_SwapChain.GetParent<Factory>())\n    {\n        factory.SetWindowAssociation(m_Form.Handle,\n             WindowAssociationFlags.IgnoreAltEnter);\n    }\n}\n```", "```cpp\npublic void InitShaders()\n{\n    // Load and compile the vertex shader\n    string vsCompileError = \"Vertex Shader Compile Error!!!\";\n    using (var bytecode =ShaderBytecode.CompileFromFile(\"Effects.fx\",\"Vertex_Shader\",\"vs_4_0\",ShaderFlags.Debug,SlimDX.D3DCompiler.EffectFlags.None,null,null,out vsCompileError))\n\n    {\n        m_VShaderSignature = ShaderSignature.GetInputSignature(bytecode);\n        m_VertexShader = new VertexShader(m_Device, bytecode);\n    }\n\n    // Load and compile the pixel shader\n    string psCompileError = \"Pixel Shader Compile Error!!!\";\n    using (var bytecode =ShaderBytecode.CompileFromFile(\"Effects.fx\",\"Pixel_Shader\",\"ps_4_0\",ShaderFlags.Debug,SlimDX.D3DCompiler.EffectFlags.None,null,null,out psCompileError))\n    {\n        m_PixelShader = new PixelShader(m_Device, bytecode);\n    }\n}\n```", "```cpp\npublic void InitScene()\n{\n    // Create the vertices of our triangle.\n    Vector3[] vertexData =\n    {\n        new Vector3(-0.5f,  0.5f,  0.5f),\n        new Vector3( 0.5f,  0.5f,  0.5f),\n        new Vector3( 0.0f, -0.5f,  0.5f),\n    };\n\n    // Create a DataStream object that we will use to put the vertices into the vertex buffer.\n    using (DataStream DataStream =new DataStream(Vector3.SizeInBytes * 3, true, true))\n    {\n        DataStream.Position = 0;\n        DataStream.Write(vertexData[0]);\n        DataStream.Write(vertexData[1]);\n        DataStream.Write(vertexData[2]);\n        DataStream.Position = 0;\n\n        // Create a description for the vertex buffer.\n        BufferDescription bd = new BufferDescription();\n        bd.Usage = ResourceUsage.Default;\n        bd.SizeInBytes = Vector3.SizeInBytes * 3;\n        bd.BindFlags = BindFlags.VertexBuffer;\n        bd.CpuAccessFlags = CpuAccessFlags.None;\n        bd.OptionFlags = ResourceOptionFlags.None;\n\n        // Create the vertex buffer.\n        m_VertexBuffer = new SlimDX.Direct3D11.Buffer(m_Device,DataStream,bd);\n    }\n\n    // Define the vertex format.\n    // This tells Direct3D what information we are storing for each vertex, and how it is stored.InputElement[] InputElements = new InputElement[]\n    {\n        new InputElement(\"POSITION\", 0, Format.R32G32B32_Float,InputElement.AppendAligned, 0,SlimDX.Direct3D11.InputClassification.PerVertexData, 0),};\n\n    // Create the InputLayout using the vertex format we just created.\n    m_InputLayout = new InputLayout(m_Device,m_VShaderSignature,InputElements);\n\n    // Setup the InputAssembler stage of the Direct3D 11 graphics pipeline.\n    m_DeviceContext.InputAssembler.InputLayout = m_InputLayout;\n    m_DeviceContext.InputAssembler.SetVertexBuffers(0,new VertexBufferBinding(m_VertexBuffer,Vector3.SizeInBytes,0));\n\n    // Set the Primitive Topology.\n    m_DeviceContext.InputAssembler.PrimitiveTopology =PrimitiveTopology.TriangleList;\n}\n```", "```cpp\npublic override void RenderScene()\n{\n    if ((!this.IsInitialized) || this.IsDisposed)\n    {\n         return;\n    }\n\n    // Clear the screen before we draw the next frame.\n    m_DeviceContext.ClearRenderTargetView(m_RenderTargetView,\n                                          ClearColor);\n\n    // Draw the triangle that we created in our vertex buffer.\n    m_DeviceContext.Draw(3, 0);\n\n    // Present the frame we just rendered to the user.\n    m_SwapChain.Present(0, PresentFlags.None);\n}\n```", "```cpp\npublic override void ToggleFullscreen()\n{\n    base.ToggleFullscreen();\n\n    m_SwapChain.IsFullScreen = this.IsFullScreen;\n}\n```", "```cpp\nenum GraphicsMode\n{\n    SolidBlue = 0,\n    PerVertexColoring,\n    Textured\n}\n```", "```cpp\nstruct Vertex\n{\n    public Vector4 Position;\n    public Color4 Color;\n    public Vector2 TexCoord;\n}\n```", "```cpp\nSlimDX.Direct3D11.Buffer m_CbChangesOnResize;\nSlimDX.Direct3D11.Buffer m_CbChangesPerFrame;\nSlimDX.Direct3D11.Buffer m_CbChangesPerObject;\n\n// We use this to send data into the constant buffers.\nDataStream m_DataStream;\n```", "```cpp\nMatrix m_ViewMatrix;  // This is our view matrix.\nMatrix m_ProjectionMatrix;  // The projection matrix.\n\nMatrix m_CubeWorldMatrix;\nMatrix m_CubeRotationMatrix;\n```", "```cpp\n// Depth stencil vars\nTexture2D m_DepthStencilTexture = null;\nDepthStencilView m_DepthStencilView = null;\n\n// Sampler vars.\nShaderResourceView m_CubeTexture;\nSamplerState m_CubeTexSamplerState;\n```", "```cpp\nVector3 m_CameraPosition = new Vector3(0, 2, -5);\n\nfloat m_CubeRotation = 0.005f;\n\nfloat m_MoveSpeed = 0.01f;\n\nGraphicsMode m_GraphicsMode = GraphicsMode.PerVertexColoring;\n```", "```cpp\npublic void InitDepthStencil()\n{\n    // Create the depth stencil texture description\n    Texture2DDescription DepthStencilTextureDesc =new Texture2DDescription();DepthStencilTextureDesc.Width = m_Form.ClientSize.Width;\n    DepthStencilTextureDesc.Height = m_Form.ClientSize.Height;\n    DepthStencilTextureDesc.MipLevels = 1;\n    DepthStencilTextureDesc.ArraySize = 1;\n    DepthStencilTextureDesc.Format = Format.D24_UNorm_S8_UInt;\n    DepthStencilTextureDesc.SampleDescription =new SampleDescription(1, 0);\n    DepthStencilTextureDesc.Usage = ResourceUsage.Default;\n    DepthStencilTextureDesc.BindFlags = BindFlags.DepthStencil;\n    DepthStencilTextureDesc.CpuAccessFlags = CpuAccessFlags.None;\n    DepthStencilTextureDesc.OptionFlags =ResourceOptionFlags.None;\n\n    // Create the Depth Stencil View description\n    DepthStencilViewDescription DepthStencilViewDesc =new DepthStencilViewDescription();\n    DepthStencilViewDesc.Format = DepthStencilTextureDesc.Format;\n    DepthStencilViewDesc.Dimension =DepthStencilViewDimension.Texture2D;\n    DepthStencilViewDesc.MipSlice = 0;\n\n    // Create the depth stencil texture.\n    m_DepthStencilTexture = new Texture2D(m_Device,DepthStencilTextureDesc);\n\n    // Create the DepthStencilView object.\n    m_DepthStencilView = new DepthStencilView(m_Device,m_DepthStencilTexture,DepthStencilViewDesc);\n\n    // Make the DepthStencilView active.\n    m_DeviceContext.OutputMerger.SetTargets(m_DepthStencilView,\n        m_RenderTargetView);\n}\n```", "```cpp\npublic void InitConstantBuffers()\n{\n    // Create a buffer description.\n    BufferDescription bd = new BufferDescription();\n    bd.Usage = ResourceUsage.Default;\n    bd.BindFlags = BindFlags.ConstantBuffer;\n    bd.CpuAccessFlags = CpuAccessFlags.None;\n    bd.SizeInBytes = 64;\n\n    // Create the changes on resize buffer.\n    m_CbChangesOnResize = new SlimDX.Direct3D11.Buffer(m_Device,bd);// Create the changes per frame buffer.\n    m_CbChangesPerFrame = new SlimDX.Direct3D11.Buffer(m_Device,bd);\n    // Create the changes per object buffer.\n    m_CbChangesPerObject = new SlimDX.Direct3D11.Buffer(m_Device,bd);\n\n    // Send the Projection matrix into the changes on resize constant buffer.\n    m_DataStream = new DataStream(64, true, true);\n    m_DataStream.Position = 0;\n    m_DataStream.Write(Matrix.Transpose(m_ProjectionMatrix));\n    m_DataStream.Position = 0;\n    m_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesOnResize,0);\n\n    // Send the View matrix into the changes per frame buffer.\n    m_DataStream.Position = 0;\n    m_DataStream.Write(Matrix.Transpose(m_ViewMatrix));\n    m_DataStream.Position = 0;\n    m_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesPerFrame,0);\n\n    // Tell the VertexShader to use our constant buffers.\n    m_DeviceContext.VertexShader.SetConstantBuffer(m_CbChangesOnResize, 0);\n    m_DeviceContext.VertexShader.SetConstantBuffer(m_CbChangesPerFrame, 1);\n    m_DeviceContext.VertexShader.SetConstantBuffer(m_CbChangesPerObject, 2);\n}\n```", "```cpp\n// Create our projection matrix.\nm_ProjectionMatrix = Matrix.PerspectiveFovLH(1.570796f, // 90 degrees in radians(float) m_Form.Width / (float) m_Form.Height,0.5f,1000.0f);\n\n// Create our view matrix.\n    m_ViewMatrix = Matrix.LookAtLH(m_CameraPosition,new Vector3(0, 0, 0),new Vector3(0, 1, 0));\n```", "```cpp\n// Load the cube texture.\nm_CubeTexture = ShaderResourceView.FromFile(m_Device,Application.StartupPath + \"\\\\Brick.png\");\n// Create a SamplerDescription\nSamplerDescription sd = new SamplerDescription();\nsd.Filter = Filter.MinMagMipLinear;\nsd.AddressU = TextureAddressMode.Wrap;\nsd.AddressV = TextureAddressMode.Wrap;\nsd.AddressW = TextureAddressMode.Wrap;\nsd.ComparisonFunction = Comparison.Never;\nsd.MinimumLod = 0;\nsd.MaximumLod = float.MaxValue;\n\n// Create our SamplerState\nm_CubeTexSamplerState = SamplerState.FromDescription(m_Device,sd);\n```", "```cpp\n// Keep the cube rotating by increasing its rotation amount\nm_CubeRotation += 0.00025f;\nif (m_CubeRotation > 6.28f) // 2 times PI\n    m_CubeRotation = 0.0f;\n```", "```cpp\n// If the player pressed forward.\nif (UserInput.IsKeyPressed(Key.UpArrow) ||UserInput.IsKeyPressed(Key.W))\n{\n    m_CameraPosition.Z = m_CameraPosition.Z + m_MoveSpeed;\n}\n```", "```cpp\n// Update the view matrix.\nm_ViewMatrix = Matrix.LookAtLH(m_CameraPosition,new Vector3(0, 0, 0),new Vector3(0, 1, 0));\n\n// Send the updated view matrix into its constant buffer.\nm_DataStream.Position = 0;\nm_DataStream.Write(Matrix.Transpose(m_ViewMatrix));\nm_DataStream.Position = 0;\n\nm_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesPerFrame,0);\n```", "```cpp\n// Update the cube's rotation matrix.\nVector3 rotationAxis = new Vector3(0.0f, 1.0f, 0.0f);\nm_CubeRotationMatrix =Matrix.RotationAxis(rotationAxis, m_CubeRotation);\n\n// Update the cube's world matrix with the new translation and rotation matrices.\nm_CubeWorldMatrix = m_CubeRotationMatrix;\n```", "```cpp\nm_DeviceContext.ClearDepthStencilView(m_DepthStencilView,DepthStencilClearFlags.Depth,1.0f,0);\n```", "```cpp\nm_DeviceContext.PixelShader.SetShaderResource(m_CubeTexture, 0);\nm_DeviceContext.PixelShader.SetSampler(m_CubeTexSamplerState, 0);\n\n// Send the cube's world matrix to the changes per object constant buffer.\nm_DataStream.Position = 0;\nm_DataStream.Write(Matrix.Transpose(m_CubeWorldMatrix));\nm_DataStream.Position = 0;\n\nm_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesPerObject,0);\n```", "```cpp\nm_DeviceContext.Draw(36, 0);\n```"]