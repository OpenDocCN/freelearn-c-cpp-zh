["```cpp\nVkBufferCreateInfo buffer_create_info = { \n  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, \n  nullptr, \n  0, \n  size, \n  usage, \n  VK_SHARING_MODE_EXCLUSIVE, \n  0, \n  nullptr \n};\n\n```", "```cpp\nVkResult result = vkCreateBuffer( logical_device, &buffer_create_info, nullptr, &buffer ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a buffer.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkPhysicalDeviceMemoryProperties physical_device_memory_properties; \nvkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties );\n\n```", "```cpp\nVkMemoryRequirements memory_requirements; \nvkGetBufferMemoryRequirements( logical_device, buffer, &memory_requirements );\n\n```", "```cpp\nmemory_object = VK_NULL_HANDLE; \nfor( uint32_t type = 0; type < physical_device_memory_properties.memoryTypeCount; ++type ) { \n  if( (memory_requirements.memoryTypeBits & (1 << type)) && \n      ((physical_device_memory_properties.memoryTypes[type].propertyFlags & memory_properties) == memory_properties) ) { \n\n    VkMemoryAllocateInfo buffer_memory_allocate_info = { \n      VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, \n      nullptr, \n      memory_requirements.size, \n      type \n    }; \n\n    VkResult result = vkAllocateMemory( logical_device, &buffer_memory_allocate_info, nullptr, &memory_object ); \n    if( VK_SUCCESS == result ) { \n      break; \n    } \n  } \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE == memory_object ) { \n  std::cout << \"Could not allocate memory for a buffer.\" << std::endl; \n  return false; \n} \n\nVkResult result = vkBindBufferMemory( logical_device, buffer, memory_object, 0 ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not bind memory object to a buffer.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstruct BufferTransition { \n    VkBuffer        Buffer; \n    VkAccessFlags   CurrentAccess; \n    VkAccessFlags   NewAccess; \n    uint32_t        CurrentQueueFamily; \n    uint32_t        NewQueueFamily; \n  };\n\n```", "```cpp\nstd::vector<VkBufferMemoryBarrier> buffer_memory_barriers; \n\nfor( auto & buffer_transition : buffer_transitions ) { \n  buffer_memory_barriers.push_back( { \n    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, \n    nullptr, \n    buffer_transition.CurrentAccess, \n    buffer_transition.NewAccess, \n    buffer_transition.CurrentQueueFamily, \n    buffer_transition.NewQueueFamily, \n    buffer_transition.Buffer, \n    0, \n    VK_WHOLE_SIZE \n  } ); \n}\n\n```", "```cpp\nif( buffer_memory_barriers.size() > 0 ) { \n  vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages, 0, 0, nullptr, static_cast<uint32_t>(buffer_memory_barriers.size()), &buffer_memory_barriers[0], 0, nullptr ); \n}\n\n```", "```cpp\nVkBufferViewCreateInfo buffer_view_create_info = { \n  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, \n  nullptr, \n  0, \n  buffer, \n  format, \n  memory_offset, \n  memory_range \n};\n\n```", "```cpp\nVkResult result = vkCreateBufferView( logical_device, &buffer_view_create_info, nullptr, &buffer_view ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not creat buffer view.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkImageCreateInfo image_create_info = { \n  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, \n  nullptr, \n  cubemap ? VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT : 0u, \n  type, \n  format, \n  size, \n  num_mipmaps, \n  cubemap ? 6 * num_layers : num_layers, \n  samples, \n  VK_IMAGE_TILING_OPTIMAL, \n  usage_scenarios, \n  VK_SHARING_MODE_EXCLUSIVE, \n  0, \n  nullptr, \n  VK_IMAGE_LAYOUT_UNDEFINED \n};\n\n```", "```cpp\nVkResult result = vkCreateImage( logical_device, &image_create_info, nullptr, &image ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create an image.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkPhysicalDeviceMemoryProperties physical_device_memory_properties; \nvkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties );\n\n```", "```cpp\nVkMemoryRequirements memory_requirements; \nvkGetImageMemoryRequirements( logical_device, image, &memory_requirements );\n\n```", "```cpp\nmemory_object = VK_NULL_HANDLE; \nfor( uint32_t type = 0; type < physical_device_memory_properties.memoryTypeCount; ++type ) { \n  if( (memory_requirements.memoryTypeBits & (1 << type)) && \n    ((physical_device_memory_properties.memoryTypes[type].propertyFlags & memory_properties) == memory_properties) ) { \n\n    VkMemoryAllocateInfo image_memory_allocate_info = { \n\n      VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,    \n      nullptr,                                  \n      memory_requirements.size,                \n      type                                     \n    }; \n\n    VkResult result = vkAllocateMemory( logical_device, &image_memory_allocate_info, nullptr, &memory_object ); \n    if( VK_SUCCESS == result ) { \n      break; \n    } \n  } \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE == memory_object ) { \n  std::cout << \"Could not allocate memory for an image.\" << std::endl; \n  return false; \n} \n\nVkResult result = vkBindImageMemory( logical_device, image, memory_object, 0 ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not bind memory object to an image.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstruct ImageTransition { \n  VkImage             Image; \n  VkAccessFlags       CurrentAccess; \n  VkAccessFlags       NewAccess; \n  VkImageLayout       CurrentLayout; \n  VkImageLayout       NewLayout; \n  uint32_t            CurrentQueueFamily; \n  uint32_t            NewQueueFamily; \n  VkImageAspectFlags  Aspect; \n};\n\n```", "```cpp\nstd::vector<VkImageMemoryBarrier> image_memory_barriers; \n\nfor( auto & image_transition : image_transitions ) { \n  image_memory_barriers.push_back( { \n    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, \n    nullptr, \n    image_transition.CurrentAccess, \n    image_transition.NewAccess, \n    image_transition.CurrentLayout, \n    image_transition.NewLayout, \n    image_transition.CurrentQueueFamily, \n    image_transition.NewQueueFamily, \n    image_transition.Image, \n    { \n      image_transition.Aspect, \n      0, \n      VK_REMAINING_MIP_LEVELS, \n      0, \n      VK_REMAINING_ARRAY_LAYERS \n    } \n  } ); \n}\n\n```", "```cpp\nif( image_memory_barriers.size() > 0 ) { \n  vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages, 0, 0, nullptr, 0, nullptr, static_cast<uint32_t>(image_memory_barriers.size()), &image_memory_barriers[0] ); \n}\n\n```", "```cpp\nVkImageViewCreateInfo image_view_create_info = { \n  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, \n  nullptr, \n  0, \n  image, \n  view_type, \n  format, \n  { \n    VK_COMPONENT_SWIZZLE_IDENTITY, \n    VK_COMPONENT_SWIZZLE_IDENTITY, \n    VK_COMPONENT_SWIZZLE_IDENTITY, \n    VK_COMPONENT_SWIZZLE_IDENTITY \n  }, \n  { \n    aspect, \n    0, \n    VK_REMAINING_MIP_LEVELS, \n    0, \n    VK_REMAINING_ARRAY_LAYERS \n  } \n};\n\n```", "```cpp\nVkResult result = vkCreateImageView( logical_device, &image_view_create_info, nullptr, &image_view ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create an image view.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nif( !CreateImage( logical_device, VK_IMAGE_TYPE_2D, format, { size.width, size.height, 1 }, num_mipmaps, num_layers, samples, usage, false, image ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device, image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !CreateImageView( logical_device, image, VK_IMAGE_VIEW_TYPE_2D, format, aspect, image_view ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !CreateImage( logical_device, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, { size, size, 1 }, num_mipmaps, 6, VK_SAMPLE_COUNT_1_BIT, usage, true, image ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device, image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !CreateImageView( logical_device, image, VK_IMAGE_VIEW_TYPE_CUBE, VK_FORMAT_R8G8B8A8_UNORM, aspect, image_view ) ) { \n  return false; \n}\n\n```", "```cpp\nVkResult result; \nvoid * local_pointer; \nresult = vkMapMemory( logical_device, memory_object, offset, data_size, 0, &local_pointer );  \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not map memory object.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nstd::memcpy( local_pointer, data, data_size );\n\n```", "```cpp\nstd::vector<VkMappedMemoryRange> memory_ranges = { \n  { \n  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, \n  nullptr, \n  memory_object, \n  offset, \n  data_size \n  } \n}; \n\nvkFlushMappedMemoryRanges( logical_device, static_cast<uint32_t>(memory_ranges.size()), &memory_ranges[0] ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not flush mapped memory.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( unmap ) { \n  vkUnmapMemory( logical_device, memory_object ); \n} else if( nullptr != pointer ) { \n  *pointer = local_pointer; \n} \n\nreturn true;\n\n```", "```cpp\nif( regions.size() > 0 ) { \n  vkCmdCopyBuffer( command_buffer, source_buffer, destination_buffer, static_cast<uint32_t>(regions.size()), &regions[0] ); \n}\n\n```", "```cpp\nif( regions.size() > 0 ) { \n  vkCmdCopyBufferToImage( command_buffer, source_buffer, destination_image, image_layout, static_cast<uint32_t>(regions.size()), &regions[0] ); \n}\n\n```", "```cpp\nif( regions.size() > 0 ) { \n  vkCmdCopyImageToBuffer( command_buffer, source_image, image_layout, destination_buffer, static_cast<uint32_t>(regions.size()), &regions[0] ); \n}\n\n```", "```cpp\nVkBuffer staging_buffer; \nif( !CreateBuffer( logical_device, data_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, staging_buffer ) ) { \n  return false; \n} \n\nVkDeviceMemory memory_object; \nif( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device, staging_buffer, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, memory_object ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !MapUpdateAndUnmapHostVisibleMemory( logical_device, memory_object, 0, data_size, data, true, nullptr ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !BeginCommandBufferRecordingOperation( command_buffer, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr ) ) { \n  return false; \n} \n\nSetBufferMemoryBarrier( command_buffer, destination_buffer_generating_stages, VK_PIPELINE_STAGE_TRANSFER_BIT, { { destination_buffer, destination_buffer_current_access, VK_ACCESS_TRANSFER_WRITE_BIT, VK_QUEUE_FAMILY_IGNORED, VK_QUEUE_FAMILY_IGNORED } } );\n\n```", "```cpp\nCopyDataBetweenBuffers( command_buffer, staging_buffer, destination_buffer, { { 0, destination_offset, data_size } } );\n\n```", "```cpp\nSetBufferMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, destination_buffer_consuming_stages, { { destination_buffer, VK_ACCESS_TRANSFER_WRITE_BIT, destination_buffer_new_access, VK_QUEUE_FAMILY_IGNORED, VK_QUEUE_FAMILY_IGNORED } } ); \n\nif( !EndCommandBufferRecordingOperation( command_buffer ) ) { \n  return false; \n}\n\n```", "```cpp\nVkFence fence; \nif( !CreateFence( logical_device, false, fence ) ) { \n  return false; \n} \nif( !SubmitCommandBuffersToQueue( queue, {}, { command_buffer }, signal_semaphores, fence ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !WaitForFences( logical_device, { fence }, VK_FALSE, 500000000 ) ) { \n  return false; \n} \n\nDestroyBuffer( logical_device, staging_buffer ); \nFreeMemoryObject( logical_device, memory_object ); \nreturn true;\n\n```", "```cpp\nVkBuffer staging_buffer; \nif( !CreateBuffer( logical_device, data_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, staging_buffer ) ) { \n  return false; \n} \n\nVkDeviceMemory memory_object; \nif( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device, staging_buffer, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, memory_object ) ) { \n  return false; \n} \n\nif( !MapUpdateAndUnmapHostVisibleMemory( logical_device, memory_object, 0, data_size, data, true, nullptr ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !BeginCommandBufferRecordingOperation( command_buffer, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr ) ) { \n  return false; \n} \n\nSetImageMemoryBarrier( command_buffer, destination_image_generating_stages, VK_PIPELINE_STAGE_TRANSFER_BIT, \n{ \n  { \n    destination_image, \n    destination_image_current_access, \n    VK_ACCESS_TRANSFER_WRITE_BIT, \n    destination_image_current_layout, \n    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, \n    VK_QUEUE_FAMILY_IGNORED, \n    VK_QUEUE_FAMILY_IGNORED, \n    destination_image_aspect \n  } } ); \n\nCopyDataFromBufferToImage( command_buffer, staging_buffer, destination_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, \n{ \n  { \n    0, \n    0, \n    0, \n    destination_image_subresource, \n    destination_image_offset, \n    destination_image_size, \n  } } );\n\n```", "```cpp\nSetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, destination_image_consuming_stages, \n{ \n  { \n    destination_image, \n    VK_ACCESS_TRANSFER_WRITE_BIT, \n    destination_image_new_access, \n    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, \n    destination_image_new_layout, \n    VK_QUEUE_FAMILY_IGNORED, \n    VK_QUEUE_FAMILY_IGNORED, \n    destination_image_aspect \n  } } ); \n\nif( !EndCommandBufferRecordingOperation( command_buffer ) ) { \n  return false; \n}\n\n```", "```cpp\nVkFence fence; \nif( !CreateFence( logical_device, false, fence ) ) { \n  return false; \n} \n\nif( !SubmitCommandBuffersToQueue( queue, {}, { command_buffer }, signal_semaphores, fence ) ) { \n  return false; \n} \n\nif( !WaitForFences( logical_device, { fence }, VK_FALSE, 500000000 ) ) { \n  return false; \n} \n\nDestroyBuffer( logical_device, staging_buffer ); \nFreeMemoryObject( logical_device, memory_object ); \n\nreturn true;\n\n```", "```cpp\nif( VK_NULL_HANDLE != image_view ) { \n  vkDestroyImageView( logical_device, image_view, nullptr ); \n  image_view = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != image ) { \n  vkDestroyImage( logical_device, image, nullptr ); \n  image = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != buffer_view ) { \n  vkDestroyBufferView( logical_device, buffer_view, nullptr ); \n  buffer_view = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != memory_object ) { \n  vkFreeMemory( logical_device, memory_object, nullptr ); \n  memory_object = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != buffer ) { \n  vkDestroyBuffer( logical_device, buffer, nullptr ); \n  buffer = VK_NULL_HANDLE; \n}\n\n```"]