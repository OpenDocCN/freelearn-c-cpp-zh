<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Actors and Components</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a custom Actor in C++</li>
<li>Instantiating an Actor using SpawnActor</li>
<li>Creating a UFUNCTION </li>
<li>Destroying an Actor using Destroy and a Timer</li>
<li>Destroying an Actor after a delay using SetLifeSpan</li>
<li>Implementing the Actor functionality by composition</li>
<li>Loading assets into components using FObjectFinder</li>
<li>Implementing the Actor functionality by inheritance</li>
<li>Attaching components to create a hierarchy</li>
<li>Creating a custom Actor Component</li>
<li>Creating a custom Scene Component</li>
<li>Creating an InventoryComponent for an RPG</li>
<li>Creating an OrbitingMovement Component</li>
<li>Creating a building that spawns units</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Actors are classes that have some presence in the game world. Actors gain their specialized functionality by incorporating Components. This chapter deals with creating custom Actors and Components, the purpose that they serve, and how they work together.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>, of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom Actor in C++</h1>
                </header>
            
            <article>
                
<p>While there are different types of Actors that ship with Unreal as part of the default installation, you will find yourself needing to create custom Actors at some point during your project's development. This might happen when you need to add functionality to an existing class, combine Components in a combination that's not present in the default subclasses, or add additional member variables to a class. The following two recipes demonstrate how to use either composition or inheritance to customize Actors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Make sure that you have installed Visual Studio and Unreal 4 as per the recipe in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>UE4 Development Tools.</em> You'll also need to have an existing project <span>– if you don't, you can</span> create a new one using the Unreal-provided wizard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open up your project within the Unreal Editor and click on the <span class="packt_screen">Add New</span> button in <span class="packt_screen">Content Browser</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/efd3d84e-10b0-4d49-8ea8-c53f92ce86f7.png" style="width:22.92em;height:13.67em;"/></p>
<p class="mce-root"/>
<ol start="2">
<li>Select <span class="packt_screen">New C++ Class...</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1d0f7ab4-9130-465d-8be6-5a5e8bd5a31c.png" style="width:52.25em;height:27.83em;"/></p>
<ol start="3">
<li>In the dialog that opens, select <span class="packt_screen">Actor</span> from the list:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4524f05e-09f3-4fb8-abfb-d0ad23a869e5.png" style="width:55.58em;height:33.50em;"/></p>
<p class="mce-root"/>
<ol start="4">
<li>Give your <span class="packt_screen">Actor</span> a name, such as <kbd>MyFirstActor</kbd>, and then click on <span class="packt_screen">OK</span> to launch Visual Studio:</li>
</ol>
<div class="packt_tip"><span>By convention, class names for </span><kbd>Actor</kbd><span> subclasses begin with an </span><kbd>A</kbd><span>. When using this class creation wizard, make sure you don't prefix your class with </span><kbd>A</kbd><span>, as the engine automatically adds the prefix for you.</span></div>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef31f6fe-8231-49b3-87e0-6c3edc4007a2.png"/></p>
<ol start="5">
<li>When Visual Studio loads, you should see something very similar to the following listing:</li>
</ol>
<pre style="padding-left: 60px">// MyFirstActor.h<br/><br/>#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "MyFirstActor.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_04_API AMyFirstActor : public AActor<br/>{<br/>  GENERATED_BODY()<br/>  <br/>public: <br/>  // Sets default values for this actor's properties<br/>  AMyFirstActor();<br/><br/>protected:<br/>  // Called when the game starts or when spawned<br/>  virtual void BeginPlay() override;<br/><br/>public: <br/>  // Called every frame<br/>  virtual void Tick(float DeltaTime) override;<br/><br/>};<br/><br/>// MyFirstActor.cpp<br/><br/>#include "MyFirstActor.h"<br/><br/>// Sets default values<br/>AMyFirstActor::AMyFirstActor()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/>}<br/><br/>// Called when the game starts or when spawned<br/>void AMyFirstActor::BeginPlay()<br/>{<br/>  Super::BeginPlay();<br/>  <br/>}<br/><br/>// Called every frame<br/>void AMyFirstActor::Tick(float DeltaTime)<br/>{<br/>  Super::Tick(DeltaTime);<br/><br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In time, you'll become familiar with the standard code, so you will be able to just create new classes from Visual Studio without using the Unreal wizard.</p>
<p>In <kbd>MyFirstActor.h</kbd>, we have the following aspects:</p>
<p style="margin-left: 2em"/>
<ul>
<li><kbd>#pragma once</kbd>: This preprocessor statement, or <kbd>pragma</kbd>, is Unreal's expected method of implementing include guards pieces of code that prevent an <kbd>include</kbd> file from causing errors by being referenced multiple times.</li>
<li><kbd>#include "CoreMinimal.h"</kbd>: This file includes a number of definitions of classes that are often used, such as <kbd>FString</kbd>, <kbd>TArray</kbd>, <kbd>Vector</kbd>, and so on, and is included by default in created script files for that reason, though it could still compile at this point without it.</li>
</ul>
<ul>
<li><kbd>#include "GameFramework/Actor.h"</kbd>: We're going to create an <kbd>Actor</kbd> subclass so, naturally, we need to include the <kbd>header</kbd> file for the class we are inheriting from so that we know about its contents.</li>
<li><kbd>#include "MyFirstActor.generated.h"</kbd>: All Actor classes need to include their <kbd>generated.h</kbd> file. This file is automatically created by the <strong>Unreal Header Tool</strong> (<strong>UHT</strong>) based on the macros that it detects in your files.</li>
<li><kbd>UCLASS()</kbd>: <kbd>UCLASS</kbd> is one such macro that allows us to indicate that a class will be exposed to Unreal's reflection system. Reflection allows us to inspect and iterate object properties during runtime, as well as manage references to our objects for garbage collection.</li>
<li><kbd>class CHAPTER_04_API AMyFirstActor : public AActor</kbd>: This is the actual declaration of our class. The <kbd>CHAPTER_04_API </kbd> macro is created by the UHT, and is necessary to help our project compile properly on Windows by ensuring that our project module's classes are exported correctly in the DLL. You will also notice that both <kbd>MyFirstActor</kbd> and <kbd>Actor</kbd> have the prefix <kbd>A</kbd> <span>–</span> this is the naming convention that Unreal requires for native classes that are inherited from <kbd>Actor</kbd>.</li>
</ul>
<div class="packt_tip">Note that, in this case, <kbd>Chapter_04</kbd> is the name of the project, and your project may have a different name.</div>
<ul>
<li><kbd>GENERATED_BODY()</kbd>: <kbd>GENERATED_BODY</kbd> is another UHT macro that has been expanded to include the automatically generated functions that the underlying UE type system requires.</li>
</ul>
<p>Inside the <kbd>MyFirstActor.cpp</kbd> file, we have the following aspects to note:</p>
<ul>
<li><kbd>PrimaryActorTick.bCanEverTick = true;</kbd>: Inside the constructor implementation, this line enables ticking for this <kbd>Actor</kbd>. All Actors have a function called <kbd>Tick</kbd>, and this Boolean variable means that the <kbd>Actor</kbd> will have that function called once per frame, enabling the actor to perform actions in every frame as necessary. As a performance optimization, this is disabled by default.</li>
<li><kbd>BeginPlay/Tick</kbd>: You can also see the implementation of two default methods, <kbd>BeginPlay</kbd> and <kbd>Tick</kbd>, which are called once an object is spawned and every frame it is alive, respectively. Currently, these only call the parent's version of the function via <kbd>Super::FunctionName</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instantiating an Actor using SpawnActor</h1>
                </header>
            
            <article>
                
<p>For this recipe, you'll need to have an <kbd>Actor</kbd> subclass ready to instantiate. You can use a built-in class such as <kbd>StaticMeshActor</kbd>, but it would help to practice with the custom <kbd>Actor</kbd> you made in the previous recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new C++ class, like in the previous recipe. This time, select <span class="packt_screen">Game Mode Base</span> as your base class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f59f3973-6781-406c-be4b-1525e29de708.png"/></p>
<ol start="2">
<li>Once you have clicked <span class="packt_screen">Next</span>, give the new class a name, such as <kbd>UE4CookbookGameModeBase</kbd>.</li>
</ol>
<p> </p>
<ol start="3">
<li>Declare a function override in the <kbd>.h</kbd> file of your new <kbd>GameModeBase</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/>#include "UECookbookGameModeBase.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_04_API AUECookbookGameModeBase : public AGameModeBase<br/>{<br/>  GENERATED_BODY()<br/><br/><strong>public:</strong><br/><strong>  virtual void BeginPlay() override;</strong> <br/>};</pre>
<ol start="4">
<li>Implement the <kbd>BeginPlay</kbd> function in the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "UECookbookGameModeBase.h"<br/><strong>#include "MyFirstActor.h" // AMyFirstActor</strong><br/><br/>void AUECookbookGameModeBase::BeginPlay()<br/>{<br/>  // Call the parent class version of this function<br/>  Super::BeginPlay();<br/><br/>  // Displays a red message on the screen for 10 seconds<br/>  GEngine-&gt;AddOnScreenDebugMessage(-1, 10, FColor::Red, <br/>                                   TEXT("Actor Spawning")); <br/><br/>  // Spawn an instance of the AMyFirstActor class at the<br/>  //default location.<br/>  FTransform SpawnLocation;<br/>  GetWorld()-&gt;SpawnActor&lt;AMyFirstActor&gt;<br/>                             (AMyFirstActor::StaticClass(), <br/>                              SpawnLocation);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Compile your code, either through Visual Studio or by clicking on the <span class="packt_screen">Compile</span> button in Unreal Editor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91a0b957-21e2-4d2f-8f52-81d4bacdbee3.png" style="width:41.58em;height:10.25em;"/></p>
<ol start="6">
<li>Open the <span class="packt_screen">World Settings</span> panel for the current level by clicking on the <span class="packt_screen">Settings</span> toolbar icon, and then pick <span class="packt_screen">World Settings</span> from the drop-down menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/652d3673-3870-48fc-b748-08d665536339.png" style="width:33.00em;height:13.50em;"/></p>
<ol start="7">
<li>In the <span class="packt_screen">GameMode Override</span> section, change the game mode to the <kbd>GameMode</kbd> subclass you just created:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e69cfdec-f16a-4902-a53a-e379c485f4e0.png" style="width:46.00em;height:24.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the GameMode Override property</div>
<ol start="8">
<li>Start the level and verify that <kbd>GameMode</kbd> spawns a copy of your <kbd>Actor</kbd> in the world by looking at the <span class="packt_screen">World Outliner</span> panel. You can verify that the <kbd>BeginPlay</kbd> function is being run by viewing the <span class="packt_screen">Actor Spawning</span> text being displayed on screen. If it doesn't spawn, make sure that there are no obstructions at the world origin to prevent the <kbd>Actor</kbd> from being spawned. You can search the list of objects in the world by typing in the search bar at the top of the <span class="packt_screen">World Outliner</span> panel. This will filter the entities that are shown:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fbbdf8b8-9165-43d8-bf27-706fa64a23af.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>GameMode</kbd> is a special type of actor that is part of the Unreal Game Framework. Your map's <kbd>GameMode</kbd> is instantiated by the engine automatically when the game starts.</p>
<p>By placing some code into the <kbd>BeginPlay</kbd> method of our custom <kbd>GameMode</kbd>, we can run it automatically when the game begins.</p>
<p>Inside <kbd>BeginPlay</kbd>, we create an <kbd>FTransform</kbd>, which is going to be used by the <kbd>SpawnActor</kbd> function. By default, <kbd>FTransform</kbd> is constructed to have zero rotation and a location at the origin.</p>
<p>We then get a reference to the current level's <kbd>UWorld</kbd> instance using <kbd>GetWorld</kbd>, and then we call its <kbd>SpawnActor</kbd> function. We pass in <kbd>FTransform</kbd>, which we created earlier, to specify that the object should be created at its location, that is, the origin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a UFUNCTION</h1>
                </header>
            
            <article>
                
<p><kbd>UFUNCTION()</kbd><span> </span>is useful because it is a C++ function that can be called from both your C++ client code as well as Blueprint diagrams. Any C++ function can be marked as a<span> </span><kbd>UFUNCTION()</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Construct a<span> </span><kbd>UClass</kbd><span> class or a derived class (such as <kbd>AActor</kbd>) </span>with a member function that you'd like to expose to Blueprints. Decorate that member function with<span> </span><kbd>UFUNCTION( BlueprintCallable, Category=SomeCategory)</kbd><span> </span>to make it callable from Blueprints.</li>
<li>For example, let's create an <kbd>Actor</kbd> class called<span> </span><kbd>Warrior</kbd><span> and use the following scripts for it</span>:</li>
</ol>
<pre style="padding-left: 60px">//Warrior.h<br/>#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "Warrior.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_04_API AWarrior : public AActor<br/>{<br/>  GENERATED_BODY()<br/><br/>public: <br/>  // Sets default values for this actor's properties<br/>  AWarrior();<br/><br/><strong>  // Name of the Actor</strong><br/><strong>  UPROPERTY(EditAnywhere, BlueprintReadWrite, </strong><br/><strong>                          Category = Properties) </strong><br/><strong>  FString Name; </strong><br/><br/><strong>  // Returns message containing the Name property</strong><br/><strong>  UFUNCTION(BlueprintCallable, Category = Properties) </strong><br/><strong>  FString ToString(); </strong><br/><br/>protected:<br/>  // Called when the game starts or when spawned<br/>  virtual void BeginPlay() override;<br/><br/>public: <br/>  // Called every frame<br/>  virtual void Tick(float DeltaTime) override;<br/><br/>};<br/><br/>// Warrior.cpp<br/><br/>#include "Warrior.h"<br/><br/>// Sets default values<br/>AWarrior::AWarrior()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/>}<br/><br/>// Called when the game starts or when spawned<br/>void AWarrior::BeginPlay()<br/>{<br/>  Super::BeginPlay();<br/>  <br/>}<br/><br/>// Called every frame<br/>void AWarrior::Tick(float DeltaTime)<br/>{<br/>  Super::Tick(DeltaTime);<br/><br/>}<br/><br/><strong>FString AWarrior::ToString() </strong><br/><strong>{ </strong><br/><strong>  return FString::Printf(TEXT("An instance of AWarrior: %s"), *Name); </strong><br/><strong>}</strong> </pre>
<ol start="3">
<li>Create an instance of your<span> </span><kbd>Warrior</kbd><span> </span>class by going to the <span class="packt_screen">Content Browser</span> and opening the <kbd>C++ Classes\Chapter_04</kbd> folder. Once there, drag the <kbd>Warrior</kbd> icon onto your game world and release the mouse.</li>
</ol>
<p> </p>
<ol start="4">
<li>You should see the item in the <span class="packt_screen">World Outliner</span> tab. By selecting the newly added object, you should be able to see the <span class="packt_screen">Name</span> property that we added. Go ahead and put in a value here, such as <kbd>John</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4597410e-9600-4936-95cd-1ed87e6ec8ba.png" style="width:21.00em;height:34.67em;"/></p>
<ol start="5">
<li>From Blueprints (<span class="packt_screen">Blueprints | Open Level Blueprint</span>), get a reference to your <kbd>Warrior</kbd> object. One way to do this is by dragging and dropping the object from the <span class="packt_screen">World Outliner</span> into the Level Blueprint's <span class="packt_screen">Event Graph</span> and letting go.</li>
<li>Click and hold the blue circle handle on the right-hand side of the <span class="packt_screen">Warrior1</span> node and drag it over a little bit to the right. Once you release the mouse, you'll see a number of actions you can pick from. </li>
</ol>
<p> </p>
<ol start="7">
<li>Call the<span> </span><kbd>ToString()</kbd><span> </span>function on that<span> </span><kbd>Warrior</kbd><span> </span>instance by clicking on your<span> </span><kbd>Warrior</kbd><span> </span>instance. Then, in a Blueprint diagram, type in<span> </span><kbd>ToString</kbd>. It should look as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/c709de65-ff1b-4ce7-af93-4e71d6a6eaf3.png"/><br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>UFUNCTION()</kbd><span> </span>is really a C++ function, but with additional metadata that makes it accessible to Blueprints. This can be incredibly useful in allowing your designers to have access to functions that you've written.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destroying an Actor using Destroy and a Timer</h1>
                </header>
            
            <article>
                
<p>This recipe will reuse the <kbd>GameMode</kbd> from the previous recipe, <em>Instantiating an Actor using SpawnActor</em>, so you should complete that recipe first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Make the following changes to the <kbd>GameMode</kbd> declaration:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_04_API AUECookbookGameModeBase : public AGameModeBase<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>  virtual void BeginPlay() override; <br/><br/><strong>  UPROPERTY() </strong><br/><strong>  AMyFirstActor* SpawnedActor; </strong><br/><br/><strong>  UFUNCTION() </strong><br/><strong>  void DestroyActorFunction();</strong> <br/>};</pre>
<ol start="2">
<li>Add <kbd>#include "MyFirstActor.h"</kbd> to the implementation file's include statements. Remember, we need to place it above the <kbd>.generated</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/><strong>#include "MyFirstActor.h"</strong><br/>#include "UECookbookGameModeBase.generated.h"</pre>
<ol start="3">
<li>Assign the results of <kbd>SpawnActor</kbd> to the new <kbd>SpawnedActor</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">#include "UECookbookGameModeBase.h"<br/>#include "MyFirstActor.h" // AMyFirstActor<br/><br/>void AUECookbookGameModeBase::BeginPlay()<br/>{<br/>  // Call the parent class version of this function<br/>  Super::BeginPlay();<br/><br/>  // Displays a red message on the screen for 10 seconds<br/>  GEngine-&gt;AddOnScreenDebugMessage(-1, 10, FColor::Red, <br/>                   TEXT("Actor Spawning")); <br/><br/>  // Spawn an instance of the AMyFirstActor class at the<br/>  // default location.<br/>  FTransform SpawnLocation;<br/><strong>  SpawnedActor =</strong> GetWorld()-&gt;SpawnActor&lt;AMyFirstActor&gt;( <br/>                             AMyFirstActor::StaticClass(), <br/>                             SpawnLocation);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>Add the following to the end of the <kbd>BeginPlay</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">FTimerHandle Timer; <br/>GetWorldTimerManager().SetTimer(Timer, this, <br/>                   &amp;AUECookbookGameModeBase::DestroyActorFunction, 10);</pre>
<ol start="5">
<li>Lastly, implement <kbd>DestroyActorFunction</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AUECookbookGameModeBase::DestroyActorFunction() <br/>{ <br/>  if (SpawnedActor != nullptr) <br/>  { <br/>    // Displays a red message on the screen for 10 seconds<br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 10, FColor::Red, <br/>                                     TEXT("Actor Destroyed")); <br/>    SpawnedActor-&gt;Destroy(); <br/>  } <br/>} </pre>
<ol start="6">
<li>Load the level you created in the previous recipe, which had the game mode set to your custom class.</li>
<li>Play your level and use the <span class="packt_screen">World Outliner</span> to verify that your <kbd>SpawnedActor</kbd> is deleted after 10 seconds:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c1492b0f-321d-4cb9-8a0b-1f0bfee5bc05.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We declare a <kbd>UPROPERTY</kbd> to store our spawned <kbd>Actor</kbd> instance, and a custom function so that we can call <kbd>Destroy()</kbd> on a timer:</p>
<pre>UPROPERTY() 
AMyFirstActor* SpawnedActor; <br/>UFUNCTION() 
void DestroyActorFunction(); </pre>
<p>In <kbd>BeginPlay</kbd>, we assign the spawned <kbd>Actor</kbd> to our new <kbd>UPROPERTY</kbd>:</p>
<pre><strong>SpawnedActor =</strong> GetWorld()-&gt;SpawnActor&lt;AMyFirstActor&gt; <br/> (AMyFirstActor::StaticClass(), SpawnLocation);</pre>
<p>We then declare a <kbd>TimerHandle</kbd> object and pass it to <kbd>GetWorldTimerManager::SetTimer</kbd>. <kbd>SetTimer</kbd> calls <kbd>DestroyActorFunction</kbd> on the object that was pointed to by this pointer after 10 seconds. <kbd>SetTimer</kbd> returns an object <span>– </span>a handle <span>– </span>to allow us to cancel the timer if necessary. The <kbd>SetTimer</kbd> function takes the <kbd>TimerHandle</kbd> object in as a reference parameter, and so we declare it in advance so that we can pass it into the function properly, even if we aren't going to be using it again:</p>
<pre>FTimerHandle Timer; 
GetWorldTimerManager().SetTimer(Timer, this, <br/> &amp;AUE4CookbookGameMode::DestroyActorFunction, 10);</pre>
<p><kbd>DestroyActorFunction</kbd> checks whether we have a valid reference to a spawned <kbd>Actor</kbd>:</p>
<pre>void AUE4CookbookGameMode::DestroyActorFunction() 
{ 
  if (SpawnedActor != nullptr) <br/>  {<br/>     // Then we know that SpawnedActor is valid<br/>  }
} </pre>
<p>If we do, it calls <kbd>Destroy</kbd> on the instance so it will be destroyed and, eventually, garbage-collected:</p>
<pre>SpawnedActor-&gt;Destroy();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destroying an Actor after a delay using SetLifeSpan</h1>
                </header>
            
            <article>
                
<p>Let's look at how we can destroy an <kbd>Actor</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>If you haven't already, create a new C++ class using the wizard. Select <kbd>Actor</kbd> as your base class. In our case, I will reuse the <kbd>AWarrior</kbd> class we created previously in this chapter.</li>
<li>In the implementation of <kbd>Actor</kbd>, add the following code to the <kbd>BeginPlay</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void AWarrior::BeginPlay()<br/>{<br/>  Super::BeginPlay();<br/><br/><strong>  // Will destroy this object in 10 seconds</strong><br/><strong>  SetLifeSpan(10);</strong> <br/>  <br/>}</pre>
<ol start="3">
<li>Drag a copy of your custom <kbd>Actor</kbd> into the viewport within the Editor.</li>
<li>Play your level and look at the Outliner to verify that your <kbd>Actor</kbd> instance disappears after 10 seconds, having destroyed itself.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We insert our code into the <kbd>BeginPlay</kbd> function so that it executes when the game starts.</p>
<p>The <kbd>SetLifeSpan</kbd> function allows us to specify a duration in seconds, after which the <kbd>Actor</kbd> calls its own <kbd>Destroy()</kbd> method.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Actor functionality by composition</h1>
                </header>
            
            <article>
                
<p>Custom Actors without components don't have a location, and can't be attached to other Actors. Without a root Component, an Actor doesn't have a base transform, and so it has no location. Most Actors, therefore, require at least one Component to be useful.</p>
<p>We can create custom Actors through composition by adding a number of components to our <kbd>Actor</kbd>, where each component provides some of the functionality that's required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe will use the <kbd>Actor</kbd> class we created in the <em>Creating a custom Actor in C++</em> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Add a new member to your custom class in C++ by making the following changes in the <kbd>public</kbd> section of the <kbd>MyFirstActor.h</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY() 
UStaticMeshComponent* Mesh; </pre>
<ol start="2">
<li>Add the following lines to the constructor inside the <kbd>MyFirstActor.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AMyFirstActor::AMyFirstActor()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn<br/>   // this off to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/>  // Creates a StaticMeshComponent on this object and assigns<br/>  // Mesh to it<br/>  Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;<br/>         ("BaseMeshComponent");<br/>}</pre>
<ol start="3">
<li>Once finished, save both files and compile them by using the <span class="packt_screen">Compile</span> button in the editor, or building the project in Visual Studio.</li>
</ol>
<ol start="4">
<li>Once you've compiled this code, drag an instance of your class from the <span class="packt_screen">Content Browser</span> out into the game environment. Here, you will be able to verify that it now has a transform and other properties, such as a Static Mesh, which comes from the <kbd>StaticMeshComponent</kbd> that we added:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ee1cb6d8-1dc7-4bb1-bdd0-c0e6bebf0324.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Selecting the instantiated actor</div>
<div class="packt_tip">You can use the search bar on the top of the <span class="packt_screen">Details</span> tab to search for specific components, such as the <span class="packt_screen">Static Mesh</span> component.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>UPROPERTY macro</kbd> we added to the class declaration is a pointer to hold the component we are using as a subobject of our <kbd>Actor</kbd>:</p>
<pre>UPROPERTY() 
UStaticMeshComponent* Mesh; </pre>
<p>Using the <kbd>UPROPERTY()</kbd> macro ensures that the object that was declared in the pointer is considered to be referenced, and won't be garbage-collected (that is, deleted) out from under us, leaving the pointer dangling.</p>
<p>We're using a Static Mesh component, but any of the <kbd>Actor</kbd> Component subclasses would work. Note that the asterisk is connected to the variable type in accordance with Epic's style guide.</p>
<p>In the constructor, we initialize the pointer to a known valid value by using a <kbd>template</kbd> function, <kbd>template&lt;class TReturnType&gt; TReturnType* CreateDefaultSubobject(FName SubobjectName, bool bTransient = false)</kbd>.</p>
<p>This function is responsible for calling the engine code to appropriately initialize the component, and return a pointer to the newly constructed object so that we can give our component pointer a default value. This is important because it ensures that the pointer has a valid value at all times, minimizing the risk of dereferencing uninitialized memory.</p>
<p>The function is templated based on the type of object to create, but also takes two parameters <span>– t</span>he first one is the name of the subobject, which ideally should be human-readable, and the second is whether the object should be transient (that is, not saved along with the parent object).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The following recipe shows you how to reference a mesh asset in your Static Mesh Component so that it can be displayed without requiring a user to specify a mesh in the Editor</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading assets into components using FObjectFinder</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we created a Static Mesh Component, but we didn't try to load a mesh for the Component to display. While it's possible to do this in the Editor, it is sometimes helpful to specify a default in C++.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Complete the previous recipe so that you have a custom <kbd>Actor</kbd> subclass with a Static Mesh Component ready.</p>
<p>In your <span class="packt_screen">Content Browser</span>, click on the <span class="packt_screen">View Options</span> button and select <span class="packt_screen">Show Engine Content</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/13ca9ea4-400f-4449-9884-8cb62b9519cf.png"/></p>
<p class="mce-root"/>
<p>Click on the <span class="packt_screen">Show/Hide Sources</span> panel button or click on the Folder icon to view the folders in the Content Browser. From there, browse to <span class="packt_screen">Engine Content</span> and then to <span class="packt_screen">BasicShapes</span> to see the <span class="packt_screen">Cube</span> we will be using in this recipe:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e10cc256-1f8a-40fa-98b8-40c5400f401a.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Add the following code to the constructor of your class:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AMyFirstActor::AMyFirstActor()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn this off <br/>  // to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/>  // Creates a StaticMeshComponent on this object and assigns Mesh <br/>  // to it<br/>  Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;<br/>       ("BaseMeshComponent");<br/><br/><strong>  auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>                   (TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));<br/><br/></strong>  <strong>// Check if the MeshAsset is valid before setting it</strong><br/><strong>  if (MeshAsset.Object != nullptr)</strong><br/><strong>  {</strong><br/><strong>    Mesh-&gt;SetStaticMesh(MeshAsset.Object); </strong><br/><strong>  }</strong><br/><br/>} </pre>
<ol start="2">
<li>Compile and verify in the Editor that an instance of your class now has a mesh as its visual representation:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4b01adda-3262-411f-a5ef-9600ab836b95.png"/></p>
<div class="packt_tip">If the actor was placed in the world before these changes, the mesh may only appear after you try moving the actor in the viewport. For whatever reason, it doesn't always update automatically.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We create an instance of the <kbd>FObjectFinder</kbd> class, passing in the type of asset that we are trying to load as a template parameter.</p>
<p><kbd>FObjectFinder</kbd> is a class template that helps us load assets. When we construct it, we pass in a string that contains a path to the asset that we are trying to load.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The string is of the format <kbd>"{ObjectType}'/Path/To/Asset.Asset'"</kbd>. Note the use of single quotes in the string.</p>
<p>To get the string for an asset that already exists in the editor, you can right-click on the asset in the <span class="packt_screen">Content Browser</span> and select <span class="packt_screen">Copy Reference</span>. This gives you the string so that you can paste it into your code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a080553c-e009-4413-91f1-1347e6efe2b8.png" style="width:48.50em;height:19.67em;"/></p>
<p>We use the <kbd>auto</kbd> keyword, from C++11, to avoid typing out our whole object type in its declaration; the compiler deduces it for us. Without <kbd>auto</kbd>, we would have to use the following code instead:</p>
<pre>ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; MeshAsset = <br/> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("Static<br/> Mesh'/Engine/BasicShapes/Cube.Cube'"));</pre>
<p>The <kbd>FObjectFinder</kbd> class has a property called <kbd>Object</kbd> that will either have a pointer to the desired asset, or will be <kbd>NULL</kbd> if the asset cannot be found.</p>
<p>This means that we can check it against <kbd>nullptr</kbd>, and if it isn't null, assign it to <kbd>Mesh</kbd> using <kbd>SetStaticMesh</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Actor functionality by inheritance</h1>
                </header>
            
            <article>
                
<p>Inheritance is the second way to implement a custom <kbd>Actor</kbd>. This is commonly done to make a new subclass, which adds member variables, functions, or a Component to an existing <kbd>Actor</kbd> class. In this recipe, we are going to add a variable to a custom <kbd>GameState</kbd> subclass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the Unreal Editor, click on <span class="packt_screen">Add New</span> in the <span class="packt_screen">Content Browser</span>. Then, in <span class="packt_screen">New C++ Class...</span>, select <span class="packt_screen">Game State Base</span> as the base class, and give your new class a name (I'll be using the default <kbd>MyGameStateBase</kbd> by creating the <kbd>AMyGameStateBase</kbd> class):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a9707562-42a3-4c40-b578-031460d86dc0.png"/></p>
<p class="mce-root"/>
<p style="padding-left: 60px">The <kbd>GameState</kbd> class is responsible for information that is meant to be shared by all players and is specific to the Game Mode, but is not specific to any individual player. Let's say we are working on a cooperative game and all players are working together for a combined score. It would make sense for this information to be included in this class.</p>
<ol start="2">
<li>Add the following code to the new class header:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_04_API AMyGameStateBase : public AGameStateBase<br/>{<br/>    GENERATED_BODY()<br/><br/><strong>public:</strong><br/><strong>    // Constructor to initialize CurrentScore</strong><br/><strong>    AMyGameStateBase(); </strong><br/><strong> </strong><br/><strong>    // Will set the CurrentScore variable</strong><br/><strong>    UFUNCTION() </strong><br/><strong>    void SetScore(int32 NewScore); </strong><br/><strong> </strong><br/><strong>    // Getter</strong><br/><strong>    UFUNCTION() </strong><br/><strong>    int32 GetScore(); </strong><br/><br/><strong>private: </strong><br/><strong>    UPROPERTY() </strong><br/><strong>    int32 CurrentScore;</strong> <br/>    <br/>};</pre>
<ol start="3">
<li>Add the following code to the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "MyGameStateBase.h"<br/><br/><strong>AMyGameStateBase::AMyGameStateBase()</strong><br/><strong>{</strong><br/><strong>  CurrentScore = 0;</strong><br/><strong>}</strong><br/><br/><strong>int32 AMyGameStateBase::GetScore()</strong><br/><strong>{</strong><br/><strong>  return CurrentScore;</strong><br/><strong>}</strong><br/><br/><strong>void AMyGameStateBase::SetScore(int32 NewScore)</strong><br/><strong>{</strong><br/><strong>  CurrentScore = NewScore;</strong><br/><strong>}</strong></pre>
<ol start="4">
<li>Confirm that your code looks like the following listing, and compile it using the <span class="packt_screen">Compile</span> button in the Unreal Editor:</li>
</ol>
<pre style="padding-left: 60px">//MyGameStateBase.h 
#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameStateBase.h"<br/>#include "MyGameStateBase.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_04_API AMyGameStateBase : public AGameStateBase<br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/>    // Constructor to initialize CurrentScore<br/>    AMyGameStateBase(); <br/> <br/>    // Will set the CurrentScore variable<br/>    UFUNCTION() <br/>    void SetScore(int32 NewScore); <br/> <br/>    // Getter<br/>    UFUNCTION() <br/>    int32 GetScore(); <br/><br/>private: <br/>    UPROPERTY() <br/>    int32 CurrentScore; <br/>    <br/>};<br/><br/>//MyGameState.cpp 
#include "MyGameStateBase.h"<br/><br/>AMyGameStateBase::AMyGameStateBase()<br/>{<br/>  CurrentScore = 0;<br/>}<br/><br/>int32 AMyGameStateBase::GetScore()<br/>{<br/>  return CurrentScore;<br/>}<br/><br/>void AMyGameStateBase::SetScore(int32 NewScore)<br/>{<br/>  CurrentScore = NewScore;<br/>}<br/><br/></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>First, we add the declaration of a default constructor:</p>
<pre>AMyGameState(); </pre>
<p>This allows us to set our new member variable to a safe default value of <kbd>0</kbd> on object initialization:</p>
<pre>AMyGameState::AMyGameState() 
{ 
  CurrentScore = 0; 
} </pre>
<p>We use the <kbd>int32</kbd> type when declaring our new variable to ensure portability between the various compilers that Unreal Engine supports. This variable is going to be responsible for storing the current game score while it is running.</p>
<div class="packt_tip">If you want the value to only be positive, you can use the <kbd>uint32</kbd> type instead, which is for unsigned numbers only.</div>
<p>As always, we will be marking our variable with <kbd>UPROPERTY</kbd> so that it is garbage-collected appropriately. This variable is marked <kbd>private</kbd> so that the only way to change the value is through our functions:</p>
<pre>UPROPERTY() 
int32 CurrentScore; </pre>
<p>The <kbd>GetScore</kbd> function will retrieve the current score and return it to the caller. It is implemented as a simple accessor, which simply returns the underlying member variable.</p>
<p>The second function, <kbd>SetScore</kbd>, sets the value of the member variable, allowing external objects to request a change to the score. Placing this request as a function ensures that the <kbd>GameState</kbd> can vet such requests, and only allow them when they're valid, to prevent cheating. The specifics of such a check are beyond the scope of this recipe, but the <kbd>SetScore</kbd> function is the appropriate place to make them.</p>
<div class="packt_infobox">Cedric 'eXi' Neukirchen has created an excellent and very extensive document on this topic here: <a href="http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf">http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf</a>.</div>
<p>Our score functions are declared using the <kbd>UFUNCTION</kbd> macro for a number of reasons. First, <kbd>UFUNCTION</kbd>, with some additional code, can be called or overridden by Blueprints. Second, <kbd>UFUNCTION</kbd> can be marked as <kbd>exec</kbd>, which means that they can be run as console commands by a player or developer during a play session, which enables debugging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Integrating C++ and the Unreal Editor: Part II,</em> has a recipe called <em>Creating new console commands</em>, which you can refer to for more information regarding <kbd>exec</kbd> and the console command functionality</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attaching components to create a hierarchy</h1>
                </header>
            
            <article>
                
<p>When creating custom Actors from components, it is important to consider the concept of <strong>attaching</strong>. Attaching components creates a relationship where transformations that are applied to the parent component will also affect the components that are attached to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new class derived from the  <kbd>Actor</kbd> class using the editor and call it <kbd>HierarchyActor</kbd>.</li>
<li>Add the following properties to your new class in the header file (<kbd>HierarchyActor.h</kbd>):</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_04_API AHierarchyActor : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    AHierarchyActor();<br/><br/><strong>    UPROPERTY(VisibleAnywhere) </strong><br/><strong>    USceneComponent* Root; </strong><br/><br/><strong>    UPROPERTY(VisibleAnywhere) </strong><br/><strong>    USceneComponent* ChildSceneComponent; </strong><br/><br/><strong>    UPROPERTY(VisibleAnywhere) </strong><br/><strong>    UStaticMeshComponent* BoxOne; </strong><br/><strong>    </strong><br/><strong>    UPROPERTY(VisibleAnywhere) </strong><br/><strong>    UStaticMeshComponent* BoxTwo; </strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};</pre>
<ol start="3">
<li>Add the following code to the class constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AHierarchyActor::AHierarchyActor()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn this<br/>    // off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    // Create four subobjects</strong><br/><strong>    Root = CreateDefaultSubobject&lt;USceneComponent&gt;("Root");<br/></strong><br/><strong>    ChildSceneComponent = CreateDefaultSubobject&lt;USceneComponent&gt;<br/>                          ("ChildSceneComponent");<br/></strong><br/><strong>    BoxOne = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("BoxOne");<br/></strong><br/><strong>    BoxTwo = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("BoxTwo");</strong><br/><br/><strong>    // Get a reference to the cube mesh</strong><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>                   (TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));</strong><br/><strong>    </strong><br/><strong>    // Give both boxes a mesh</strong><br/><strong>    if (MeshAsset.Object != nullptr)</strong><br/><strong>    {</strong><br/><strong>        BoxOne-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>        BoxTwo-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>    }</strong><br/><br/><strong>    RootComponent = Root;</strong><br/><br/><strong>    // Set up the object's hierarchy</strong><br/><strong>    BoxOne-&gt;AttachTo(Root);</strong><br/><strong>    BoxTwo-&gt;AttachTo(ChildSceneComponent);</strong><br/><br/><strong>    ChildSceneComponent-&gt;AttachTo(Root);</strong><br/><br/><strong>    // Offset and scale the child from the root</strong><br/><strong>    ChildSceneComponent-&gt;SetRelativeTransform(</strong><br/><strong>                                FTransform(FRotator(0, 0, 0), </strong><br/><strong>                                           FVector(250, 0, 0), </strong><br/><strong>                                           FVector(0.1f))</strong><br/><strong>                                             );</strong><br/><br/>}</pre>
<ol start="4">
<li>Compile and launch the editor. Drag a copy of <kbd>HierarchyActor</kbd> into the scene:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f978bc11-df51-42b0-b644-c49f5e52f0fb.png"/></p>
<ol start="5">
<li>Verify that <kbd>Actor</kbd> has components in a hierarchy, and that the second box is a smaller size:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b9ec562-6754-455d-b342-43cc0e478f2b.png"/></p>
<div class="packt_tip">If you do not see the <span class="packt_screen">Root (Inherited)</span> section under the <span class="packt_screen">Details</span> tab, it is possible to drag the mouse above the search bar to extend it out. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As usual, we create some tagged <kbd>UPROPERTY</kbd> Components for our actor. In this case, we added an additional parameter to the tag called <kbd>VisibleAnywhere</kbd>, so that we can see our variables within the <span class="packt_screen">Details</span> tab. We create two Scene Components and two Static Mesh components.</p>
<p>In the constructor, we create default subobjects for each component, as usual.</p>
<p>We then load the static mesh, and if loading is successful, assign it to the two static mesh components so that they have a visual representation.</p>
<p>We then construct a hierarchy within our <kbd>Actor</kbd> by attaching components.</p>
<p class="mce-root"/>
<p>We set the first Scene Component as the <kbd>Actor</kbd> root. This component will determine the transformations that are applied to all other components in the hierarchy.</p>
<p>We then attach the first box to our new root component and parent the second scene component to the first one.</p>
<p>We attach the second box to our child scene component to demonstrate how changing the transform on that scene component affects its children, but no other components in the object.</p>
<p>Lastly, we set the relative transform of that scene component so that it moves a certain distance away from the origin, and is one-tenth of the scale.</p>
<p>This means that in the Editor, you can see that the <kbd>BoxTwo</kbd> component has inherited the translation and scaling of its parent component, <kbd>ChildSceneComponent</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom Actor Component</h1>
                </header>
            
            <article>
                
<p>Actor components are an easy way to implement common functionality that should be shared between Actors. Actor components aren't rendered, but can still perform actions such as subscribing to events, or communicating with other components of the Actor that they are inside.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create an <kbd>ActorComponent</kbd> named <kbd>RandomMovementComponent</kbd> using the Editor wizard:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e5e56d7-96ca-45c1-8e46-241ffee79da7.png"/></p>
<ol start="2">
<li>Add the following <kbd>UPROPERTY</kbd> to the class header in the public section:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Components/ActorComponent.h"<br/>#include "RandomMovementComponent.generated.h"<br/><br/><br/>UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br/>class CHAPTER_04_API URandomMovementComponent : public UActorComponent<br/>{<br/>    GENERATED_BODY()<br/><br/>public: <br/>    // Sets default values for this component's properties<br/>    URandomMovementComponent();<br/><br/><strong>    UPROPERTY()</strong><br/><strong>    float MovementRadius;</strong><br/><br/>protected:<br/>    // Called when the game starts<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void TickComponent(float DeltaTime, ELevelTick <br/>    TickType, FActorComponentTickFunction* ThisTickFunction) <br/>    override;<br/><br/>        <br/>};<br/><br/></pre>
<ol start="3">
<li>Add the following code to the constructor's implementation:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values for this component's properties<br/>URandomMovementComponent::URandomMovementComponent()<br/>{<br/>    // Set this component to be initialized when the game<br/>    // starts, and to be ticked every frame. You can turn<br/>    // these features<br/>    // off to improve performance if you don't need them.<br/>    PrimaryComponentTick.bCanEverTick = true;<br/><br/>    // ...<br/>    <strong>MovementRadius = 5;</strong><br/>}</pre>
<ol start="4">
<li>Lastly, add the following code to the implementation of <kbd>TickComponent( )</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// Called every frame<br/>void URandomMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)<br/>{<br/>    Super::TickComponent(DeltaTime, TickType,<br/>    ThisTickFunction);<br/><br/>    // ...<br/><strong>    AActor* Parent = GetOwner(); </strong><br/><br/><strong>    if (Parent) </strong><br/><strong>    { </strong><br/><strong>        // Find a new position for the object to go to</strong><br/><strong>        auto NewPos = Parent-&gt;GetActorLocation() + </strong><br/><strong>                      FVector</strong><br/><strong>                      ( </strong><br/><strong>                      FMath::FRandRange(-1, 1) * <br/>                      MovementRadius, </strong><br/><strong>                      FMath::FRandRange(-1, 1) *<br/>                      MovementRadius, </strong><br/><strong>                      FMath::FRandRange(-1, 1) *<br/>                      MovementRadius</strong><br/><strong>                      );</strong><br/><strong>        // Update the object's position</strong><br/><strong>        Parent-&gt;SetActorLocation( NewPos ); </strong><br/><strong>    }</strong> <br/>}</pre>
<ol start="5">
<li>Compile your project. In the editor, create an empty <kbd>Actor</kbd> and add your <span class="packt_screen">Random Movement</span> Component to it. For example, from the <span class="packt_screen">Modes</span> tab, go to the <span class="packt_screen">Basic</span> option and drag and drop a Cube into your level.</li>
</ol>
<ol start="6">
<li>Afterwards, ensure that the <span class="packt_screen">Transform</span> component's <span class="packt_screen">Mobility</span> property is set to <span class="packt_screen">Moveable</span> from the <span class="packt_screen">Details</span> tab:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/637d0947-9dfb-451e-998a-729739f42501.png" style="width:60.83em;height:32.17em;"/></p>
<ol start="7">
<li>Then, with the object selected, click on <span class="packt_screen">Add Component</span> in the <span class="packt_screen">Details</span> panel and select <span class="packt_screen">Random Movement</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cd367a36-8adb-4a14-9f4d-a247f43044e8.png"/></p>
<ol start="8">
<li>Play your level and observe the actor randomly moving around as its location changes every time the <kbd>TickComponent</kbd> function is called:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7befead9-e431-42e6-9f29-882bb5a0e06b.png"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>First, we add a few specifiers to the <kbd>UCLASS</kbd> macro that was used in our component's declaration. Adding <kbd>BlueprintSpawnableComponent</kbd> to the class's meta values means that instances of the component can be added to Blueprint classes in the editor. The <kbd>ClassGroup</kbd> specifier allows us to indicate what category of class our Component belongs to in the list of classes:</p>
<pre>UCLASS( ClassGroup=(Custom), <br/> meta=(BlueprintSpawnableComponent) )</pre>
<p>Adding <kbd>MovementRadius</kbd> as a property to the new component allows us to specify how far the component will be allowed to wander in a single frame:</p>
<pre>UPROPERTY() 
float MovementRadius; </pre>
<p>In the constructor, we initialize this property to a safe default value:</p>
<pre>MovementRadius = 5; </pre>
<p><kbd>TickComponent</kbd> is a function that is called every frame by the engine, just like <kbd>Tick</kbd> is for Actors. In its implementation, we retrieve the current location of the component's owner, that is, the <kbd>Actor</kbd> that contains our component, and we generate an offset in the world space:</p>
<pre style="padding-left: 30px">    AActor* Parent = GetOwner(); <br/><br/>    if (Parent) <br/>    { <br/>        // Find a new position for the object to go to<br/>        auto NewPos = Parent-&gt;GetActorLocation() + <br/>                      FVector<br/>                      ( <br/>                      FMath::FRandRange(-1, 1) * MovementRadius, <br/>                      FMath::FRandRange(-1, 1) * MovementRadius, <br/>                      FMath::FRandRange(-1, 1) * MovementRadius<br/>                      );<br/>        // Update the object's position<br/>        Parent-&gt;SetActorLocation( NewPos ); <br/>    } </pre>
<p>We add the random offset to the current location to determine a new location and move the owning actor to it. This causes the actor's location to randomly change from frame to frame and dance about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom Scene Component</h1>
                </header>
            
            <article>
                
<p><kbd>Scene</kbd> Components are a subclass of <kbd>Actor</kbd> Components that have a transform, that is, a relative location, rotation, and scale. Just like <kbd>Actor</kbd> Components, <kbd>Scene</kbd> Components aren't rendered themselves, but can use their transform for various things, such as spawning other objects at a fixed offset from an <kbd>Actor</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a custom <kbd>SceneComponent</kbd> called <kbd>ActorSpawnerComponent</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/83bd074a-030f-46c2-baa9-9a4b1ccfdde6.png"/></p>
<ol start="2">
<li>Make the following changes to the header:</li>
</ol>
<pre style="padding-left: 60px">#include "CoreMinimal.h"<br/>#include "Components/SceneComponent.h"<br/>#include "ActorSpawnerComponent.generated.h"<br/><br/><br/>UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br/>class CHAPTER_04_API UActorSpawnerComponent : public USceneComponent<br/>{<br/>  GENERATED_BODY()<br/><br/>public: <br/>  // Sets default values for this component's properties<br/>  UActorSpawnerComponent();<br/><br/><strong>  // Will spawn actor when called</strong><br/><strong>  UFUNCTION(BlueprintCallable, Category=Cookbook)</strong><br/><strong>  void Spawn();</strong><br/><br/><strong>  UPROPERTY(EditAnywhere)</strong><br/><strong>  TSubclassOf&lt;AActor&gt; ActorToSpawn;</strong><br/><br/>protected:<br/>  // Called when the game starts<br/>  virtual void BeginPlay() override;<br/><br/>public: <br/>  // Called every frame<br/>  virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;<br/><br/>    <br/>};</pre>
<ol start="3">
<li>Add the following function implementation to the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">void UActorSpawnerComponent::Spawn()<br/>{<br/>    UWorld* TheWorld = GetWorld();<br/>    if (TheWorld != nullptr)<br/>    {<br/>        FTransform ComponentTransform(this-&gt;GetComponentTransform());<br/>        TheWorld-&gt;SpawnActor(ActorToSpawn,&amp;ComponentTransform);<br/>    }<br/>}</pre>
<ol start="4">
<li>Compile and open your project. Drag an empty <kbd>Actor</kbd> into the scene and add your <kbd>ActorSpawnerComponent</kbd> to it. Select your new Component in the <span class="packt_screen">Details</span> panel and assign a value to <kbd>ActorToSpawn</kbd>.</li>
</ol>
<p>Now, whenever <kbd>Spawn()</kbd> is called on an instance of your component, it will instantiate a copy of the <kbd>Actor</kbd> class that's specified in <kbd>ActorToSpawn</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We create the <kbd>Spawn UFUNCTION</kbd> and a variable called <kbd>ActorToSpawn</kbd>. The <kbd>ActorToSpawn</kbd><kbd>UPROPERTY</kbd> is of the <kbd>TSubclassOf&lt; &gt;</kbd> type, a template type that allows us to restrict a pointer to either a base class or subclasses thereof. This also means that within the editor, we will get a pre-filtered list of classes to pick from, preventing us from accidentally assigning an invalid value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6b7004ee-a06d-4099-b334-bb0d9433f0aa.png" style="width:24.75em;height:34.50em;"/></p>
<p>Inside the <kbd>Spawn</kbd> function's implementation, we get access to our world. From here, we check it for validity.</p>
<p><kbd>SpawnActor</kbd> wants an <kbd>FTransform*</kbd> to specify the location to spawn the new actor to, so we create a new stack variable to contain a copy of the current component's transform.</p>
<p>If <kbd>TheWorld</kbd> is valid, we request it to spawn an instance of the specified <kbd>ActorToSpawn</kbd> subclass, passing in the address of the <kbd>FTransform</kbd> we just created, which now contains the desired location for the new actor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="bded5c5b-3038-4d12-b03d-39218257492b.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Integrating C++ and the Unreal Editor,</em> contains a much more detailed investigation into how you can make things Blueprint-accessible</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an InventoryComponent for an RPG</h1>
                </header>
            
            <article>
                
<p>An <kbd>InventoryComponent</kbd> enables its containing <kbd>Actor</kbd> to store <kbd>InventoryActors</kbd> in its inventory, and place them back into the game world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Make sure you've followed the <em>Axis mappings <span>–</span> keyboard, mouse, and gamepad directional input for an FPS character</em> recipe in <a href="613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Input and Collision,</em> before continuing with this recipe, as it shows you how to create a simple character.</p>
<p>Also, the <em>Instantiating an Actor using SpawnActor</em> recipe in this chapter shows you how to create a custom <kbd>GameMode</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create an <kbd>ActorComponent</kbd> subclass using the engine called <kbd>InventoryComponent</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6a88aa60-de6e-48da-9a0b-df939365bc5f.png"/></p>
<ol start="2">
<li>Inside of the <kbd>InventoryComponent.h</kbd> file, add the following code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Components/ActorComponent.h"<br/>#include "InventoryComponent.generated.h"<br/><br/><br/>UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br/>class CHAPTER_04_API UInventoryComponent : public UActorComponent<br/>{<br/>    GENERATED_BODY()<br/><br/>public: <br/>    // Sets default values for this component's properties<br/>    UInventoryComponent();<br/><br/><strong>    UPROPERTY()</strong><br/><strong>    TArray&lt;AInventoryActor*&gt; CurrentInventory;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    int32 AddToInventory(AInventoryActor* ActorToAdd);</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void RemoveFromInventory(AInventoryActor* ActorToRemove);</strong><br/><br/>protected:<br/>    // Called when the game starts<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;<br/><br/>        <br/>};</pre>
<ol start="3">
<li>Add the following function implementation to the source file:</li>
</ol>
<pre style="padding-left: 60px">int32 UInventoryComponent::AddToInventory(AInventoryActor* ActorToAdd)<br/>{<br/>    return CurrentInventory.Add(ActorToAdd);<br/>}<br/><br/>void UInventoryComponent::RemoveFromInventory(AInventoryActor* ActorToRemove)<br/>{<br/>    CurrentInventory.Remove(ActorToRemove);<br/>}</pre>
<p class="mceNonEditable"/>
<ol start="4">
<li>Next, create a new <kbd>StaticMeshActor</kbd> subclass called <kbd>InventoryActor</kbd>. Remember to check <span class="packt_screen">Show All Classes</span> to see the <kbd>StaticMeshActor</kbd> class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/253b7cd0-e29a-4bc8-88b5-15fcd7b599ac.png"/></p>
<ol start="5">
<li>Now that we have the file, go to the <kbd>InventoryComponent.h</kbd> file and add the following includes:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Components/ActorComponent.h"<br/><strong>#include "InventoryActor.h"</strong><br/>#include "InventoryComponent.generated.h"<br/><br/><br/>UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br/>class CHAPTER_04_API UInventoryComponent : public UActorComponent</pre>
<p class="mceNonEditable"/>
<ol start="6">
<li>Return to the <kbd>InventoryActor.h</kbd> file and add the following to its declaration:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_04_API AInventoryActor : public AStaticMeshActor<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/><strong>    virtual void PickUp();</strong><br/><strong>    virtual void PutDown(FTransform TargetLocation);</strong><br/>  <br/>};</pre>
<ol start="7">
<li>Implement the new functions in the implementation file:</li>
</ol>
<pre style="padding-left: 60px">void AInventoryActor::PickUp() 
{ 
  SetActorTickEnabled(false); 
  SetActorHiddenInGame(true); 
  SetActorEnableCollision(false); 
} 
 
void AInventoryActor::PutDown(FTransform TargetLocation) 
{ 
  SetActorTickEnabled(true); 
  SetActorHiddenInGame(false); 
  SetActorEnableCollision(true); 
  SetActorLocation(TargetLocation.GetLocation()); 
} </pre>
<ol start="8">
<li>Also, change the constructor to look like the following:</li>
</ol>
<pre style="padding-left: 60px">AInventoryActor::AInventoryActor()<br/>    :Super()<br/>{<br/>    PrimaryActorTick.bCanEverTick = true;<br/>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));<br/><br/>    if (MeshAsset.Object != nullptr)<br/>    {<br/>        GetStaticMeshComponent()-&gt;SetStaticMesh(MeshAsset.Object);<br/>        GetStaticMeshComponent()-&gt;SetCollisionProfileName( UCollisionProfile::Pawn_ProfileName);<br/>    }<br/><br/>    GetStaticMeshComponent()-&gt;SetMobility(EComponentMobility::Movable);<br/><br/>    SetActorEnableCollision(true);<br/>}</pre>
<ol start="9">
<li>Afterwards, we need to add the following #includes for <kbd>InventoryActor.cpp</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "InventoryActor.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><strong>#include "Engine/CollisionProfile.h"</strong></pre>
<ol start="10">
<li>We need to add an <kbd>InventoryComponent</kbd> to our character so that we have an inventory that we can store items in. Create a class that's derived from the <kbd>Character</kbd> class called <kbd>InventoryCharacter</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5a38752a-967c-49e6-a018-7e2316e3a4e4.png"/></p>
<ol start="11">
<li>Add the following to the #includes:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Character.h"<br/><strong>#include "InventoryComponent.h"</strong><br/><strong>#include "InventoryActor.h"</strong><br/>#include "InventoryCharacter.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_04_API AInventoryCharacter : public ACharacter</pre>
<ol start="12">
<li>Then, add the following to the <kbd>InventoryCharacter</kbd> class's declaration:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_04_API AInventoryCharacter : public ACharacter<br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/>    // Sets default values for this character's properties<br/>    AInventoryCharacter();<br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UInventoryComponent* MyInventory;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void DropItem();</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void TakeItem(AInventoryActor* InventoryItem);</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    virtual void NotifyHit(class UPrimitiveComponent* MyComp,</strong><br/><strong>        AActor* Other, class UPrimitiveComponent* OtherComp, <br/>        bool </strong><strong>bSelfMoved, FVector HitLocation, FVector<br/>        HitNormal, FVector </strong><strong>NormalImpulse, const FHitResult&amp;<br/>        Hit) override;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void MoveForward(float AxisValue);</strong><br/><strong>    void MoveRight(float AxisValue);</strong><br/><strong>    void PitchCamera(float AxisValue);</strong><br/><strong>    void YawCamera(float AxisValue);</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>    // Called to bind functionality to input<br/>    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;<br/><br/><strong>private:</strong><br/><strong>    FVector MovementInput;</strong><br/><strong>    FVector CameraInput;</strong><br/><br/>};</pre>
<ol start="13">
<li>Add the following line to the character's constructor implementation:</li>
</ol>
<pre style="padding-left: 60px">AInventoryCharacter::AInventoryCharacter()<br/>{<br/>    // Set this character to call Tick() every frame. You can turn this <br/>    // off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    <strong>MyInventory = CreateDefaultSubobject&lt;UInventoryComponent&gt;("MyInventory");</strong><br/>}</pre>
<ol start="14">
<li>Add the following code to the overridden <kbd>SetupPlayerInputComponent</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// Called to bind functionality to input<br/>void AInventoryCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)<br/>{<br/>    Super::SetupPlayerInputComponent(PlayerInputComponent);<br/><br/>    PlayerInputComponent-&gt;BindAction("DropItem", <br/>                                     EInputEvent::IE_Pressed, this, <br/>                                     &amp;AInventoryCharacter::DropItem);<br/><br/>    // Movement<br/>    PlayerInputComponent-&gt;BindAxis("MoveForward", this, <br/>                                    &amp;AInventoryCharacter::MoveForward);<br/>    PlayerInputComponent-&gt;BindAxis("MoveRight", this, <br/>                                      &amp;AInventoryCharacter::MoveRight);<br/>    PlayerInputComponent-&gt;BindAxis("CameraPitch", this, <br/>                                    &amp;AInventoryCharacter::PitchCamera);<br/>    PlayerInputComponent-&gt;BindAxis("CameraYaw", this, <br/>                                      &amp;AInventoryCharacter::YawCamera);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="15">
<li>Next, add in the <kbd>MoveForward</kbd>, <kbd>MoveRight</kbd>, <kbd>CameraPitch</kbd>, and <kbd>CameraYaw</kbd> axes and <kbd>DropItem</kbd> action to the <kbd>Input</kbd> menu. If you do not recall how to do this, read <a href="613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml">Chapter 6</a>, <em>Input and Collision</em>, where we go into detail on this. Here are the settings that I used for this particular example:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8001e2c7-62e2-434b-8865-931916baf3c8.png"/></p>
<ol start="16">
<li>Finally, add the following function implementations:</li>
</ol>
<pre style="padding-left: 60px">void AInventoryCharacter::DropItem()<br/>{<br/>    if (MyInventory-&gt;CurrentInventory.Num() == 0)<br/>    {<br/>        return;<br/>    }<br/>    AInventoryActor* Item = MyInventory-&gt;CurrentInventory.Last();<br/>    MyInventory-&gt;RemoveFromInventory(Item);<br/><br/><br/>    FVector ItemOrigin;<br/>    FVector ItemBounds;<br/>    Item-&gt;GetActorBounds(false, ItemOrigin, ItemBounds);<br/><br/>    FTransform PutDownLocation = GetTransform() + FTransform(RootComponent-&gt;GetForwardVector() * ItemBounds.GetMax());<br/><br/>    Item-&gt;PutDown(PutDownLocation);<br/>}<br/><br/><br/>void AInventoryCharacter::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult&amp; Hit)<br/>{<br/>    AInventoryActor* InventoryItem = Cast&lt;AInventoryActor&gt;(Other);<br/>    if (InventoryItem != nullptr)<br/>    {<br/>        TakeItem(InventoryItem);<br/>    }<br/><br/>}<br/><br/>void AInventoryCharacter::TakeItem(AInventoryActor* InventoryItem)<br/>{<br/>    InventoryItem-&gt;PickUp();<br/>    MyInventory-&gt;AddToInventory(InventoryItem);<br/>}<br/><br/>//Movement<br/>void AInventoryCharacter::MoveForward(float AxisValue)<br/>{<br/>    MovementInput.X = FMath::Clamp&lt;float&gt;(AxisValue, -1.0f, 1.0f);<br/>}<br/><br/>void AInventoryCharacter::MoveRight(float AxisValue)<br/>{<br/>    MovementInput.Y = FMath::Clamp&lt;float&gt;(AxisValue, -1.0f, 1.0f);<br/>}<br/><br/>void AInventoryCharacter::PitchCamera(float AxisValue)<br/>{<br/>    CameraInput.Y = AxisValue;<br/>}<br/><br/>void AInventoryCharacter::YawCamera(float AxisValue)<br/>{<br/>    CameraInput.X = AxisValue;<br/>}</pre>
<ol start="17">
<li>To handle the movement functions, update the <kbd>Tick</kbd> function to the following:</li>
</ol>
<pre style="padding-left: 60px">// Called every frame<br/>void AInventoryCharacter::Tick(float DeltaTime)<br/>{<br/>    Super::Tick(DeltaTime);<br/><br/>    if (!MovementInput.IsZero())<br/>    {<br/>        MovementInput *= 100;<br/><br/>        //Scale our movement input axis values by 100 units<br/>        // per second<br/>        FVector InputVector = FVector(0, 0, 0);<br/>        InputVector += GetActorForwardVector()* MovementInput.X * <br/>        DeltaTime;<br/>        InputVector += GetActorRightVector()* MovementInput.Y * <br/>        DeltaTime;<br/>        /* GEngine-&gt;AddOnScreenDebugMessage(-1, 1, <br/>                FColor::Red, <br/>                FString::Printf(TEXT("x- %f, y - %f, z - %f"), <br/>             InputVector.X, InputVector.Y, InputVector.Z)); */<br/>    }<br/><br/>    if (!CameraInput.IsNearlyZero())<br/>    {<br/>        FRotator NewRotation = GetActorRotation();<br/>        NewRotation.Pitch += CameraInput.Y;<br/>        NewRotation.Yaw += CameraInput.X;<br/><br/>        APlayerController* MyPlayerController = <br/>        Cast&lt;APlayerController&gt;(GetController());<br/>        if (MyPlayerController != nullptr)<br/>        {<br/>            MyPlayerController-&gt;AddYawInput(CameraInput.X);<br/>            MyPlayerController-&gt;AddPitchInput(CameraInput.Y);<br/>        }<br/>        SetActorRotation(NewRotation);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="18">
<li>Then, add the following #include:</li>
</ol>
<pre style="padding-left: 60px">#include "InventoryCharacter.h"<br/><strong>#include "GameFramework/CharacterMovementComponent.h"</strong></pre>
<ol start="19">
<li>Compile your code and test it in the Editor. Create a new level and drag a few instances of <kbd>InventoryActor</kbd> out into your scene.</li>
<li>Refer to the <em>Instantiating an Actor using SpawnActor</em> recipe if you need a reminder of how to override the current game mode. Add the following line to the constructor of your Game Mode from that recipe, and then set your level's <kbd>GameMode</kbd> to the one you created in that recipe:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_04GameModeBase.h"<br/><strong>#include "InventoryCharacter.h"</strong><br/><br/><strong>AChapter_04GameModeBase::AChapter_04GameModeBase()</strong><br/><strong>{</strong><br/><strong>    DefaultPawnClass = AInventoryCharacter::StaticClass();</strong><br/><strong>}</strong></pre>
<ol start="21">
<li>Of course, we will also need to update the GameMode's <kbd>.h</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_04_API AChapter_04GameModeBase : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/>    <strong>AChapter_04GameModeBase();</strong><br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="22">
<li>Compile and launch your project. If all went well, you should be able to pick up objects by walking on them:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d7b159e0-643e-487e-a0e9-d35608810661.png"/></p>
<ol start="23">
<li>Then, you can drop the items whenever you hit the key that's assigned for <kbd>DropItem</kbd> in front of you:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0f75e9f4-9f66-47dd-a18b-e01ec1148af8.png"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our new component contains an array of actors, storing them by pointer as well as declaring functions that add or remove items to the array. These functions are simple wrappers around the <kbd>TArray</kbd> add/remove functionality, but allow us to optionally do things such as checking whether the array is within a specified size limit before going ahead with storing the item.</p>
<p><kbd>InventoryActor</kbd> is a base class that can be used for all of the items that can be taken by a player.</p>
<p>In the <kbd>PickUp</kbd> function, we need to disable the actor when it is picked up. To do that, we have to do the following:</p>
<ul>
<li>Disable actor ticking</li>
<li>Hide the actor</li>
<li>Disable collision</li>
</ul>
<p>We do this with the <kbd>SetActorTickEnabled</kbd>, <kbd>SetActorHiddenInGame</kbd>, and <kbd>SetActorEnableCollision</kbd> functions.</p>
<p>The <kbd>PutDown</kbd> function is the reverse of this. We enable actor ticking, unhide the actor, and then turn its collision back on, and we transport the actor to the desired location.</p>
<p>We add an <kbd>InventoryComponent</kbd> to our new character as well as a function to take items.</p>
<p>In the constructor for our character, we create a default subobject for our <kbd>InventoryComponent</kbd>. We also add a <kbd>NotifyHit</kbd> override so that we are notified when the character hits other Actors.</p>
<p>Inside this function, we cast the other actor to an <kbd>InventoryActor</kbd>. If the cast is successful, then we know our <kbd>Actor</kbd> was an <kbd>InventoryActor</kbd>, and so we can call the <kbd>TakeItem</kbd> function to take it.</p>
<p class="mce-root"/>
<p>In the <kbd>TakeItem</kbd> function, we notify the Inventory item actor that we want to pick it up, and then we add it to our inventory.</p>
<p>The last piece of functionality in the <kbd>InventoryCharacter</kbd> is the <kbd>DropItem</kbd> function. This function checks whether we have any items in our inventory. If it has any items, we remove it from our inventory, and then we calculate a safe distance in front of our player character to drop the item using the Item Bounds to get its maximum bounding box dimension.</p>
<p>We then inform the item that we are placing it in the world at the desired location.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Handling Events and Delegates,</em> has a detailed explanation of how events and input handling work together within the Engine, as well as a recipe for the <kbd>SimpleCharacter</kbd> class we mentioned in this recipe</li>
<li><a href="613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Input and Collision,</em> also has recipes concerning the binding of input actions and axes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an OrbitingMovement Component</h1>
                </header>
            
            <article>
                
<p>This component is similar to <kbd>RotatingMovementComponent</kbd> in that it is designed to make the components parented to it move in a particular way. In this instance, it will move any attached components in an orbit around a fixed point at a fixed distance.</p>
<p>This could be used, for example, for a shield that orbits around a character in an <strong>Action RPG</strong>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>SceneComponent</kbd> subclass called <kbd>OrbitingMovementComponent</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12609215-3391-497d-9a47-7234f7f59bdf.png"/></p>
<ol start="2">
<li>Add the following properties to the class declaration:</li>
</ol>
<pre style="padding-left: 60px">UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br/>class CHAPTER_04_API UOrbitingMovementComponent : public USceneComponent<br/>{<br/>  GENERATED_BODY()<br/><br/>public: <br/>  // Sets default values for this component's properties<br/>  UOrbitingMovementComponent();<br/><br/><strong>  UPROPERTY()</strong><br/><strong>  bool RotateToFaceOutwards;</strong><br/><strong>  </strong><br/><strong>  UPROPERTY()</strong><br/><strong>  float RotationSpeed;</strong><br/><br/><strong>  UPROPERTY()</strong><br/><strong>  float OrbitDistance;</strong><br/><br/><strong>  float CurrentValue;</strong><br/><br/>protected:<br/>  // Called when the game starts<br/>  virtual void BeginPlay() override;<br/><br/>public: <br/>  // Called every frame<br/>  virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;</pre>
<ol start="3">
<li>Add the following code to the constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values for this component's properties<br/>UOrbitingMovementComponent::UOrbitingMovementComponent()<br/>{<br/>    // Set this component to be initialized when the game<br/>    // starts, and to be ticked every frame. You can turn<br/>    // these features off to improve performance if you<br/>    // don't need them.<br/>    PrimaryComponentTick.bCanEverTick = true;<br/>    <br/>    // ...<br/><strong>    RotationSpeed = 5; </strong><br/><strong>    OrbitDistance = 100; </strong><br/><strong>    CurrentValue = 0; </strong><br/><strong>    RotateToFaceOutwards = true;</strong> <br/>}</pre>
<ol start="4">
<li>Add the following code to the <kbd>TickComponent</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">// Called every frame<br/>void UOrbitingMovementComponent::TickComponent(float DeltaTime, <br/>                                               ELevelTick TickType, <br/>                                         FActorComponentTickFunction* <br/>                                         ThisTickFunction)<br/>{<br/>    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);<br/><br/>    // ...<br/>   <strong> float CurrentValueInRadians = FMath::DegreesToRadians&lt;float&gt;(</strong><br/><strong>                                  CurrentValue);</strong><br/><br/><strong>    SetRelativeLocation(</strong><br/><strong>             FVector(OrbitDistance * FMath::Cos(CurrentValueInRadians), </strong><br/><strong>                     OrbitDistance * FMath::Sin(CurrentValueInRadians), </strong><br/><strong>                        RelativeLocation.Z)</strong><br/><strong>                        );</strong><br/><br/><strong>    if (RotateToFaceOutwards)</strong><br/><strong>    {</strong><br/><strong>        FVector LookDir = (RelativeLocation).GetSafeNormal();</strong><br/><strong>        FRotator LookAtRot = LookDir.Rotation();</strong><br/><strong>        SetRelativeRotation(LookAtRot);</strong><br/><strong>    }</strong><br/><br/><strong>    CurrentValue = FMath::Fmod(CurrentValue + (RotationSpeed * <br/>                               DeltaTime), 360);</strong><br/>}</pre>
<ol start="5">
<li>You can test this component by creating a simple <kbd>Actor</kbd> Blueprint.</li>
<li>Add an <kbd>OrbitingMovement</kbd> Component to your <kbd>Actor</kbd>, and then add a few meshes using the <kbd>Cube</kbd> component. Parent them to the <kbd>OrbitingMovement</kbd> component by dragging them onto it in the <span class="packt_screen">Components</span> panel. The resulting hierarchy should look as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/06f23a38-ca51-46ec-a3b5-c7b2d49502cc.png" style="width:15.00em;height:14.83em;"/></p>
<ol start="7">
<li>Refer to the <em>Creating a custom Actor Component</em> recipe if you're unsure of the process.</li>
<li>Hit play to see the meshes moving around in a circular pattern around the center of the <kbd>Actor</kbd>.</li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The properties that are added to the component are the basic parameters that we use to customize the circular motion of the component.</p>
<p><kbd>RotateToFaceOutwards</kbd> specifies whether the component will orient to face away from the center of rotation on every update. <kbd>RotationSpeed</kbd> is the number of degrees the component rotates every second.</p>
<p><kbd>OrbitDistance</kbd> indicates the distance that the components that rotate must be moved from the origin. <kbd>CurrentValue</kbd> is the current rotation position in degrees.</p>
<p>Inside our constructor, we establish some sane defaults for our new component.</p>
<p>In the <kbd>TickComponent</kbd> function, we calculate the location and rotation of our component.</p>
<p>The formula in the next step requires our angles to be expressed in radians rather than degrees. Radians describe an angle in terms of <em>π</em>. First, we use the <kbd>DegreesToRadians</kbd> function to convert our current value in degrees to radians.</p>
<p>The <kbd>SetRelativeLocation</kbd> function uses the general equation for circular motion, that is, <em>Pos(θ) = cos(θ in radians), sin(θ in radians)</em>. We preserve the <em>Z</em> axis position of each object.</p>
<p>The next step is to rotate the object back toward the origin (or directly away from it). This is only calculated if <kbd>RotateToFaceOutwards</kbd> is <kbd>true</kbd>, and involves getting the relative offset of the component to its parent and creating a rotator based on a vector pointing from the parent to the current relative offset. We then set the relative rotation to the resulting rotator.</p>
<p>Lastly, we increment the current value in degrees so that it moves <kbd>RotationSpeed</kbd> units per second, clamping the resulting value between 0 and 360 to allow the rotation to loop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a building that spawns units</h1>
                </header>
            
            <article>
                
<p>For this recipe, we will create a building that spawns units at a fixed time interval at a particular location.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>Actor</kbd> subclass in the editor, which we will name <kbd>Barracks</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7df75b09-439e-41bc-b8e7-a5c519efe1fd.png"/></p>
<ol start="2">
<li>Then, add the following implementation to the class:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_04_API ABarracks : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    ABarracks();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/><strong>    UPROPERTY() </strong><br/><strong>    UStaticMeshComponent* BuildingMesh; </strong><br/><br/><strong>    UPROPERTY() </strong><br/><strong>    UParticleSystemComponent* SpawnPoint; </strong><br/><strong>     </strong><br/><strong>    UPROPERTY() </strong><br/><strong>    UClass* UnitToSpawn; </strong><br/><strong>     </strong><br/><strong>    UPROPERTY() </strong><br/><strong>    float SpawnInterval; </strong><br/><strong>     </strong><br/><strong>    UFUNCTION() </strong><br/><strong>    void SpawnUnit(); </strong><br/><strong>     </strong><br/><strong>    UFUNCTION() </strong><br/><strong>    void EndPlay(const EEndPlayReason::Type EndPlayReason) override; </strong><br/><strong>     </strong><br/><strong>    UPROPERTY() </strong><br/><strong>    FTimerHandle SpawnTimerHandle;</strong> <br/><br/>};</pre>
<ol start="3">
<li>Add the following code to the constructor:</li>
</ol>
<pre style="padding-left: 60px">#include "Barracks.h"<br/><strong>#include "Particles/ParticleSystemComponent.h"<br/>#include "BarracksUnit.h"</strong><br/><br/>// Sets default values<br/>ABarracks::ABarracks()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn<br/>    // this off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    BuildingMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(</strong><br/><strong>                   "BuildingMesh");</strong><br/><br/><strong>    SpawnPoint = CreateDefaultSubobject&lt;UParticleSystemComponent&gt;(</strong><br/><strong>                   "SpawnPoint"); </strong><br/><br/><strong>    SpawnInterval = 10; </strong><br/><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(</strong><br/><strong>                      TEXT("Static    <br/>                      Mesh'/Engine/BasicShapes/Cube.Cube'")); </strong><br/><br/><strong>    if (MeshAsset.Object != nullptr) </strong><br/><strong>    { </strong><br/><strong>        BuildingMesh-&gt;SetStaticMesh(MeshAsset.Object); </strong><br/><strong>    } </strong><br/><br/><strong>    auto ParticleSystem = <br/>    ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt;<br/>    (TEXT("ParticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets  <br/>    /TutorialParticleSystem.TutorialParticleSystem'")); </strong><br/><strong>    </strong><br/><strong>    if (ParticleSystem.Object != nullptr) </strong><br/><strong>    { </strong><br/><strong>      SpawnPoint-&gt;SetTemplate(ParticleSystem.Object); </strong><br/><strong>    } </strong><br/><br/><strong>    SpawnPoint-&gt;SetRelativeScale3D(FVector(0.5, 0.5, 0.5)); </strong><br/><strong>    UnitToSpawn = ABarracksUnit::StaticClass();</strong> <br/>}</pre>
<p style="padding-left: 60px">Currently, we do not have the <kbd>BarracksUnit</kbd> class created, so you'll see Visual Studio complain. We'll implement that as soon as we finish up the <kbd>Barracks</kbd> class.</p>
<ol start="4">
<li>Add the following code to the <kbd>BeginPlay</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void ABarracks::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/><strong>    RootComponent = BuildingMesh; </strong><br/><strong>    SpawnPoint-&gt;AttachTo(RootComponent); </strong><br/><strong>    SpawnPoint-&gt;SetRelativeLocation(FVector(150, 0, 0)); </strong><br/><strong>    GetWorld()-&gt;GetTimerManager().SetTimer(SpawnTimerHandle, </strong><br/><strong>    this, &amp;ABarracks::SpawnUnit, SpawnInterval, true);</strong><br/>}</pre>
<ol start="5">
<li>Create the implementation for the <kbd>SpawnUnit</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">void ABarracks::SpawnUnit() 
{ 
  FVector SpawnLocation = SpawnPoint-&gt;GetComponentLocation(); 
  GetWorld()-&gt;SpawnActor(UnitToSpawn, &amp;SpawnLocation); 
}</pre>
<p class="mceNonEditable"/>
<ol start="6">
<li>Implement the overridden <kbd>EndPlay</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">void ABarracks::EndPlay(const EEndPlayReason::Type <br/> EndPlayReason) 
{ 
  Super::EndPlay(EndPlayReason); 
  GetWorld()-&gt;GetTimerManager().ClearTimer(SpawnTimerHandle); 
} </pre>
<ol start="7">
<li>Next, create a new character subclass, <kbd>BarracksUnit</kbd>, and add one property:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY() 
UParticleSystemComponent* VisualRepresentation; </pre>
<ol start="7"/>
<ol start="8">
<li>You'll need to add the following #include to get access to the <kbd>UParticleSystemComponent</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">#include "Particles/ParticleSystemComponent.h"</pre>
<ol start="9">
<li>Initialize the component in the constructor implementation:</li>
</ol>
<pre style="padding-left: 60px">VisualRepresentation = <br/> CreateDefaultSubobject&lt;UParticleSystemComponent&gt;("SpawnPoin<br/> t");auto ParticleSystem =<br/> ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt;(TEXT("Pa<br/> rticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets/Tut<br/> orialParticleSystem.TutorialParticleSystem'")); 
if (ParticleSystem.Object != nullptr) 
{ 
  SpawnPoint-&gt;SetTemplate(ParticleSystem.Object); 
} 
SpawnPoint-&gt;SetRelativeScale3D(FVector(0.5, 0.5, 0.5)); 
SpawnCollisionHandlingMethod = <br/> ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</pre>
<ol start="10">
<li>Attach the visual representation to the root component:</li>
</ol>
<pre style="padding-left: 60px">void ABarracksUnit::BeginPlay() 
{ 
  Super::BeginPlay(); 
  SpawnPoint-&gt;AttachTo(RootComponent); 
}</pre>
<ol start="11">
<li>Lastly, add the following to the <kbd>Tick</kbd> function to get the spawned actor moving:</li>
</ol>
<pre style="padding-left: 60px">SetActorLocation(GetActorLocation() + FVector(10, 0, 0)); </pre>
<ol start="12">
<li>Compile your project. Place a copy of the barracks actor into the level. You can then observe it spawning the character at fixed intervals.</li>
</ol>
<p style="padding-left: 60px">If all went well, you should be able to drag and drop a <kbd>Barracks</kbd> object into the world and play the game. Afterwards, you'll notice objects (<kbd>BarracksUnit</kbd> objects) being spawned from a singular point and continually moving in a direction!</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca986044-837e-4148-a6f0-5c8d32c9bbe3.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>First, we create the barracks actor. We add a particle system component to indicate where the new units will be spawning and a static mesh for the visual representation of the building.</p>
<p>In the constructor, we initialize the components and then set their values using <kbd>FObjectFinder</kbd>. We also set the class to spawn using the <kbd>StaticClass</kbd> function to retrieve a <kbd>UClass*</kbd> instance from a class type.</p>
<p class="mce-root"/>
<p>In the <kbd>BeginPlay</kbd> function of the barracks, we create a timer that calls our <kbd>SpawnUnit</kbd> function at fixed intervals. We store the timer handle in a member variable in the class so that when our instance is being destroyed, we can halt the timer; otherwise, when the timer triggers again, we'll encounter a crash where the object pointer is dereferenced.</p>
<p>The <kbd>SpawnUnit</kbd> function gets the world space location of the <kbd>SpawnPoint</kbd> object, and then asks the world to spawn an instance of our unit class at that location.</p>
<p><kbd>BarracksUnit</kbd> has code in its <kbd>Tick()</kbd> function to move forward by 10 units every frame so that each spawned unit will move to make room for the next one.</p>
<p>The <kbd>EndPlay</kbd> function override calls the parent class implementation of the function, which is important if there are timers to cancel or perform deinitialization in the parent class. It then uses the timer handle stored in <kbd>BeginPlay</kbd> to cancel the timer.</p>


            </article>

            
        </section>
    </body></html>