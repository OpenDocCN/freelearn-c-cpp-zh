["```cpp\nUFUNCTION(Server, Reliable, WithValidation)\nvoid ServerRPCFunction(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter); \n```", "```cpp\nvoid ARPCTest::CallMyOwnServerRPC(int32 IntegerParameter)\n{\n  ServerMyOwnRPC(IntegerParameter);\n}\n```", "```cpp\nvoid ARPCTest::CallServerRPCOfAnotherActor(AAnotherActor* OtherActor)\n{\n  if(OtherActor != nullptr)\n  {\n    OtherActor->ServerAnotherActorRPC();\n  }\n}\n```", "```cpp\nUFUNCTION(NetMulticast, Unreliable)\nvoid MulticastRPCFunction(int32 IntegerParameter, float \nFloatParameter, AActor* ActorParameter); \n```", "```cpp\nvoid ARPCTest::CallMyOwnMulticastRPC(int32 IntegerParameter)\n{\n  MulticastMyOwnRPC(IntegerParameter);\n}\n```", "```cpp\nvoid ARPCTest::CallMulticastRPCOfAnotherActor(AAnotherActor* \nOtherActor)\n{\n  if(OtherActor != nullptr)\n  {\n    OtherActor->MulticastAnotherActorRPC();\n  }\n}\n```", "```cpp\nUFUNCTION(Client, Unreliable)\nvoid ClientRPCFunction(int32 IntegerParameter, float FloatParameter, Aactor* ActorParameter); \n```", "```cpp\nvoid ARPCTest::CallMyOwnClientRPC(int32 IntegerParameter)\n{\n  ClientMyOwnRPC(IntegerParameter);\n}\n```", "```cpp\nvoid ARPCTest::CallClientRPCOfAnotherActor(AAnotherActor* OtherActor)\n{\n  if(OtherActor != nullptr)\n  {\n    OtherActor->ClientAnotherActorRPC();\n  }\n}\n```", "```cpp\nvoid ARPCTest::ServerRPCTest_Implementation(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nvoid ARPCTest::MulticastRPCTest_Implementation(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nvoid ARPCTest::ClientRPCTest_Implementation(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nvoid ARPCTest::ServerRPCFunction(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nUFUNCTION(Server, Reliable)\nvoid ServerRPCTest(int32 IntegerParameter); \n```", "```cpp\nvirtual void ServerRPCTest_Implementation(int32 IntegerParameter) override;\n```", "```cpp\nvoid ARPCTest::CallServerRPC(int32 IntegerParameter)\n{\n  if(HasAuthority())\n  {\n    ServerRPCFunction_Implementation(IntegerParameter);\n  }\n  else ServerRPCFunction(IntegerParameter);\n}\n```", "```cpp\nUFUNCTION(Server, Reliable, WithValidation)\nvoid ServerSetHealth(float NewHealth);\n```", "```cpp\nbool ARPCTest::ServerSetHealth_Validate(float NewHealth)\n{\n  return NewHealth >= 0.0f && NewHealth <= MaxHealth;\n}\nvoid ARPCTest::ServerSetHealth_Implementation(float NewHealth)\n{\n  Health = NewHealth;\n}\n```", "```cpp\n    UFUNCTION(Server, Reliable)\n    void ServerReliableRPCFunction(int32 IntegerParameter); \n    ```", "```cpp\n    UFUNCTION(Server, Unreliable)\n    void ServerUnreliableRPCFunction(int32 IntegerParameter);\n    ```", "```cpp\n    FTimerHandle FireTimer;\n    ```", "```cpp\n    UPROPERTY(Replicated)\n    int32 Ammo = 5;\n    ```", "```cpp\n    UPROPERTY(EditDefaultsOnly, Category = \"RPC Character\")\n    UAnimMontage* FireAnimMontage;\n    ```", "```cpp\n    UPROPERTY(EditDefaultsOnly, Category = \"RPC Character\")\n    USoundBase* NoAmmoSound;\n    ```", "```cpp\n    virtual void Tick(float DeltaSeconds) override;\n    ```", "```cpp\n    UFUNCTION(Server, Reliable, WithValidation, Category = \"RPC Character\")\n    void ServerFire();\n    ```", "```cpp\n    UFUNCTION(NetMulticast, Unreliable, Category = \"RPC Character\")\n    void MulticastFire();\n    ```", "```cpp\n    UFUNCTION(Client, Unreliable, Category = \"RPC Character\")\n    void ClientPlaySound2D(USoundBase* Sound);\n    ```", "```cpp\n    #include \"Kismet/GameplayStatics.h\"\"\n    #include \"Net/UnrealNetwork.h\"\n    ```", "```cpp\n    PrimaryActorTick.bCanEverTick = true;\n    ```", "```cpp\n    void ARPCCharacter::GetLifetimeReplicatedProps(TArray< \n      FLifetimeProperty >& OutLifetimeProps) const\n    {\n      Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n      DOREPLIFETIME(ARPCCharacter, Ammo);\n    }\n    ```", "```cpp\n    void ARPCCharacter::Tick(float DeltaSeconds)\n    {\n      Super::Tick(DeltaSeconds);\n      const FString AmmoString = \n      FString::Printf(TEXT(\"Ammo = %d\"), Ammo);\n      DrawDebugString(GetWorld(), GetActorLocation(), \n      AmmoString, nullptr, FColor::White, 0.0f, true);\n    }\n    ```", "```cpp\n    PlayerInputComponent->BindAction(\"Fire\", IE_Pressed, this, &ARPCCharacter::ServerFire);\n    ```", "```cpp\n    bool ARPCCharacter::ServerFire_Validate()\n    {\n      return true;\n    }\n    ```", "```cpp\n    void ARPCCharacter::ServerFire_Implementation()\n    {\n\n    }\n    ```", "```cpp\n    if (GetWorldTimerManager().IsTimerActive(FireTimer))\n    {\n      return;\n    }\n    ```", "```cpp\n    if (Ammo == 0)\n    {\n      ClientPlaySound2D(NoAmmoSound);\n      return;\n    }\n    ```", "```cpp\n    Ammo--;\n    GetWorldTimerManager().SetTimer(FireTimer, 1.5f, false);\n    ```", "```cpp\n    MulticastFire();\n    ```", "```cpp\n    void ARPCCharacter::MulticastFire_Implementation()\n    {\n      if (FireAnimMontage != nullptr)\n      {\n        PlayAnimMontage(FireAnimMontage);\n      }\n    }\n    ```", "```cpp\n    void ARPCCharacter::ClientPlaySound2D_Implementation(USoundBase* Sound)\n    {\n      UGameplayStatics::PlaySound2D(GetWorld(), Sound);\n    }\n    ```", "```cpp\nenum class ETestEnum : uint8\n{\n  EnumValue1,\n  EnumValue2,\n  EnumValue3\n};\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Test\")\nETestEnum TestEnum;\nUFUNCTION(BlueprintCallable, Category = \"Test\")\nvoid SetTestEnum(ETestEnum NewTestEnum) { TestEnum = NewTestEnum; }\n```", "```cpp\nerror : Unrecognized type 'ETestEnum' - type must be a UCLASS, USTRUCT or UENUM\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n  EnumValue1,\n  EnumValue2,\n  EnumValue3\n};\n```", "```cpp\nUENUM()\nenum ETestRawEnum\n{\n  EnumValue1,\n  EnumValue2,\n  EnumValue3\n};\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Test\")\nETestRawEnum TestRawEnum;\n```", "```cpp\nerror : You cannot use the raw enum name as a type for member variables, instead use TEnumAsByte or a C++11 enum class with an explicit underlying type.\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Test\")\nTEnumAsByte<ETestRawEnum> TestRawEnum;\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n  EnumValue1 UMETA(DisplayName = \"My First Option\"),\n  EnumValue2 UMETA(DisplayName = \"My Second Option\"),\n  EnumValue3 UMETA(DisplayName = \"My Third Option\")\n};\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Test\")\nETestEnum TestEnum;\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n  EnumValue1 UMETA(DisplayName = \"My First Option\"),\n  EnumValue2 UMETA(Hidden),\n  EnumValue3 UMETA(DisplayName = \"My Third Option\")\n};\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Test\")\nETestEnum TestEnum;\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n  EnumValue1,\n  EnumValue2,\n  EnumValue3,\n  MAX\n};\n```", "```cpp\nconst int32 MaxCount = static_cast<int32>(ETestEnum::MAX);\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n  EnumValue1 = 4,\n  EnumValue2 = 78,\n  EnumValue3 = 100,\n  MAX\n};\n```", "```cpp\n    #define ENUM_TO_INT32(Value) static_cast<int32>(Value)\n    ```", "```cpp\n    #define ENUM_TO_FSTRING(Enum, Value) FindObject<UEnum>(ANY_PACKAGE, TEXT(Enum), true)->GetDisplayNameTextByIndex(ENUM_TO_INT32(Value)).ToString()\n    ```", "```cpp\n    UENUM(BlueprintType)\n    enum class EWeaponType : uint8\n    {\n      Pistol UMETA(Display Name = \"Glock 19\"),\n      Shotgun UMETA(Display Name = \"Winchester M1897\"),\n      RocketLauncher UMETA(Display Name = \"RPG\"),    \n      MAX\n    };\n    UENUM(BlueprintType)\n    enum class EAmmoType : uint8\n    {\n      Bullets UMETA(DisplayName = \"9mm Bullets\"),\n      Shells UMETA(Display Name = \"12 Gauge Shotgun \n      Shells\"),\n      Rockets UMETA(Display Name = \"RPG Rockets\"),\n      MAX\n    };\n    ```", "```cpp\n    #include \"Enumerations.h\"\n    ```", "```cpp\n    UPROPERTY(BlueprintReadOnly, Category = \"Enumerations Character\")\n    EWeaponType Weapon;\n    ```", "```cpp\n    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Enumerations Character\")\n    TArray<int32> Ammo;\n    ```", "```cpp\n    virtual void BeginPlay() override;\n    virtual void Tick(float DeltaSeconds) override;\n    ```", "```cpp\n    void Pistol();\n    void Shotgun();\n    void RocketLauncher();\n    void Fire();\n    ```", "```cpp\n    PlayerInputComponent->BindAction(\"Pistol\", IE_Pressed, this, &AEnumerationsCharacter::Pistol);\n    PlayerInputComponent->BindAction(\"Shotgun\", IE_Pressed, this, &AEnumerationsCharacter::Shotgun);\n    PlayerInputComponent->BindAction(\"Rocket Launcher\", IE_Pressed, this, &AEnumerationsCharacter::RocketLauncher);\n    PlayerInputComponent->BindAction(\"Fire\", IE_Pressed, this, &AEnumerationsCharacter::Fire);\n    ```", "```cpp\n    void AEnumerationsCharacter::BeginPlay()\n    {\n      Super::BeginPlay();\n      constexpr int32 AmmoTypeCount = \n      ENUM_TO_INT32(EAmmoType::MAX);\n      Ammo.Init(10, AmmoTypeCount);\n    }\n    ```", "```cpp\n    void AEnumerationsCharacter::Tick(float DeltaSeconds)\n    {\n      Super::Tick(DeltaSeconds);\n    }\n    ```", "```cpp\n    const int32 WeaponIndex = ENUM_TO_INT32(Weapon);\n    const FString WeaponString = ENUM_TO_FSTRING(\"EWeaponType\", Weapon);\n    ```", "```cpp\n    const FString AmmoTypeString = ENUM_TO_FSTRING(\"EAmmoType\", Weapon);\n    const int32 AmmoCount = Ammo[WeaponIndex];\n    ```", "```cpp\n    const FString String = FString::Printf(TEXT(\"Weapon = %s\\nAmmo Type = %s\\nAmmo Count = %d\"), *WeaponString, *AmmoTypeString, AmmoCount);\n    DrawDebugString(GetWorld(), GetActorLocation(), String, nullptr, FColor::White, 0.0f, true);\n    ```", "```cpp\n    void AEnumerationsCharacter::Pistol()\n    {\n      Weapon = EWeaponType::Pistol;\n    }\n    void AEnumerationsCharacter::Shotgun()\n    {\n      Weapon = EWeaponType::Shotgun;\n    }\n    void AEnumerationsCharacter::RocketLauncher()\n    {\n      Weapon = EWeaponType::RocketLauncher;\n    }\n    ```", "```cpp\n    void AEnumerationsCharacter::Fire()\n    {\n      const int32 WeaponIndex = ENUM_TO_INT32(Weapon);\n      const int32 NewRawAmmoCount = Ammo[WeaponIndex] - 1;\n      const int32 NewAmmoCount = \n      FMath::Max(NewRawAmmoCount, 0);\n      Ammo[WeaponIndex] = NewAmmoCount;\n    }\n    ```", "```cpp\nAWeapon * APlayer::GetPreviousWeapon()\n{\n  if(WeaponIndex - 1 < 0)\n  {\n    WeaponIndex = Weapons.Num() - 1;\n  }\n  else\n  {\n    WeaponIndex--;\n  }\n  return Weapons[WeaponIndex];\n}\nAWeapon * APlayer::GetNextWeapon()\n{\n  if(WeaponIndex + 1 > Weapons.Num() - 1)\n  {\n    WeaponIndex = 0;\n  }\n  else\n  {\n    WeaponIndex++;\n  }\n  return Weapons[WeaponIndex];\n}\n```", "```cpp\nAWeapon * APlayer::GetNewWeapon(int32 Direction)\n{\n  const int32 WeaponCount = Weapons.Num();\n  const int32 NewRawIndex = WeaponIndex + Direction;\n  const in32 NewWrappedIndex = NewIndex % WeaponCount;\n  WeaponIndex = (NewClampedIndex + WeaponCount) % \n  WeaponCount;\n  return Weapons[WeaponIndex];\n}\n```", "```cpp\n    #define GET_WRAPPED_ARRAY_INDEX(Index, Count) (Index % Count + Count) % Count\n    ```", "```cpp\n    void PreviousWeapon();\n    void NextWeapon();\n    ```", "```cpp\n    void CycleWeapons(int32 Direction);\n    ```", "```cpp\n    PlayerInputComponent->BindAction(\"Previous Weapon\", IE_Pressed, this, &AEnumerationsCharacter::PreviousWeapon);\n    PlayerInputComponent->BindAction(\"Next Weapon\", IE_Pressed, this, &AEnumerationsCharacter::NextWeapon);\n    ```", "```cpp\n    void AEnumerationsCharacter::PreviousWeapon()\n    {\n      CycleWeapons(-1);\n    }\n    void AEnumerationsCharacter::NextWeapon()\n    {\n      CycleWeapons(1);\n    }\n    ```", "```cpp\n    void AEnumerationsCharacter::CycleWeapons(int32 Direction)\n    {\n      const int32 WeaponIndex = ENUM_TO_INT32(Weapon);\n      const int32 AmmoCount = Ammo.Num();\n      const int32 NextRawWeaponIndex = WeaponIndex + \n      Direction;\n      const int32 NextWeaponIndex = \n      GET_WRAPPED_ARRAY_INDEX(NextRawWeaponIndex , \n      AmmoCount);\n      Weapon = static_cast<EWeaponType>(NextWeaponIndex);\n    }\n    ```"]