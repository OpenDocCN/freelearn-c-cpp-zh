["```cpp\n    struct foo\n    {\n      foo() = default;\n    }; \n    ```", "```cpp\n    struct foo\n    {\n      foo(foo const &) = delete;\n    };\n    void func(int) = delete; \n    ```", "```cpp\n    class foo_not_copyable\n    {\n    public:\n      foo_not_copyable() = default;\n      foo_not_copyable(foo_not_copyable const &) = delete;\n      foo_not_copyable& operator=(foo_not_copyable const&) = delete;\n    }; \n    ```", "```cpp\n    class data_wrapper\n    {\n      Data* data;\n    public:\n      data_wrapper(Data* d = nullptr) : data(d) {}\n      ~data_wrapper() { delete data; }\n      data_wrapper(data_wrapper const&) = delete;\n      data_wrapper& operator=(data_wrapper const &) = delete;\n      data_wrapper(data_wrapper&& other)  \n     :data(std::move(other.data))\n      {\n        other.data = nullptr;\n      }\n      data_wrapper& operator=(data_wrapper&& other)\n      {\n        if (data != other.data))\n        {\n          delete data;\n          data = std::move(other.data);\n          other.data = nullptr;\n        }\n        return *this;\n      }\n    }; \n    ```", "```cpp\n    template <typename T>\n    void run(T val) = delete;\n    void run(long val) {} // can only be called with long integers \n    ```", "```cpp\nclass foo\n{\npublic:\n  foo() = default;\n  inline foo& operator=(foo const &);\n};\ninline foo& foo::operator=(foo const &) = default; \n```", "```cpp\nrun(42);  // error, matches a deleted overload\nrun(42L); // OK, long integer arguments are allowed \n```", "```cpp\nvoid forward_declared_function();\n// ...\nvoid forward_declared_function() = delete; // error \n```", "```cpp\n    auto numbers =\n      std::vector<int>{ 0, 2, -3, 5, -1, 6, 8, -4, 9 };\n    auto positives = std::count_if(\n      std::begin(numbers), std::end(numbers),\n      [](int const n) {return n > 0; }); \n    ```", "```cpp\n    auto ispositive = [](int const n) {return n > 0; };\n    auto positives = std::count_if(\n      std::begin(numbers), std::end(numbers), ispositive); \n    ```", "```cpp\n    auto positives = std::count_if(\n      std::begin(numbers), std::end(numbers),\n      [](auto const n) {return n > 0; }); \n    ```", "```cpp\nstruct __lambda_name__\n{\n  bool operator()(int const n) const { return n > 0; }\n}; \n```", "```cpp\nauto numbers = std::vector<int>{ 0, 2, -3, 5, -1, 6, 8, -4, 9 };\nauto minimum { 5 };\nauto maximum { 10 };\nauto inrange = std::count_if(\n    std::begin(numbers), std::end(numbers),\n    [minimum, maximum](int const n) {\n      return minimum <= n && n <= maximum;}); \n```", "```cpp\nclass __lambda_name_2__\n{\n  int minimum_;\n  int maximum_;\npublic:\n  explicit __lambda_name_2__(int const minimum, int const maximum) :\n    minimum_( minimum), maximum_( maximum)\n  {}\n  __lambda_name_2__(const __lambda_name_2__&) = default;\n  __lambda_name_2__(__lambda_name_2__&&) = default;\n  __lambda_name_2__& operator=(const __lambda_name_2__&)\n    = delete;\n  ~__lambda_name_2__() = default;\n  bool operator() (int const n) const\n {\n    return minimum_ <= n && n <= maximum_;\n  }\n}; \n```", "```cpp\n[capture-list](params) mutable constexpr exception attr -> ret\n{ body } \n```", "```cpp\nauto ptr = std::make_unique<int>(42);\nauto l = [lptr = std::move(ptr)](){return ++*lptr;}; \n```", "```cpp\n    struct foo\n    {\n      int         id;\n      std::string name;\n      auto run()\n     {\n        return [i=id, n=name] { std::cout << i << ' ' << n << '\\n'; };\n      }\n    }; \n    ```", "```cpp\n    struct foo\n    {\n      int         id;\n      std::string name;\n      auto run()\n     {\n        return [=] { std::cout << id << ' ' << name << '\\n'; };\n      }\n    }; \n    ```", "```cpp\n    struct foo\n    {\n      int         id;\n      std::string name;\n      auto run()\n     {\n        return[this]{ std::cout << id << ' ' << name << '\\n'; };\n      }\n    };\n    auto l = foo{ 42, \"john\" }.run();\n    l(); // does not print 42 john \n    ```", "```cpp\nauto linc = [](int a) [[deprecated]] { return a+1; };\nlinc(42); \n```", "```cpp\nauto linc = [][[nodiscard,deprecated]](int a) { return a+1; };\nlinc(42); \n```", "```cpp\nauto numbers =\n  std::vector<int>{0, 2, -3, 5, -1, 6, 8, -4, 9};\nusing namespace std::string_literals;\nauto texts =\n  std::vector<std::string>{\"hello\"s, \" \"s, \"world\"s, \"!\"s};\nauto lsum = [](auto const s, auto const n) {return s + n;};\nauto sum = std::accumulate(\n  std::begin(numbers), std::end(numbers), 0, lsum);\n  // sum = 22\nauto text = std::accumulate(\n  std::begin(texts), std::end(texts), \"\"s, lsum);\n  // sum = \"hello world!\"s \n```", "```cpp\nstd::vector<int> vi { 1, 1, 2, 3, 5, 8 };\nauto tl = []<typename T>(std::vector<T> const& vec)\n{\n   std::cout << std::size(vec) << '\\n';\n};\ntl(vi); // OK, prints 6\ntl(42); // error \n```", "```cpp\nstruct __lambda_name__\n{\n  template<typename T1, typename T2>\n auto operator()(T1 const s, T2 const n) const { return s + n; }\n  __lambda_name__(const __lambda_name__&) = default;\n  __lambda_name__(__lambda_name__&&) = default;\n  __lambda_name__& operator=(const __lambda_name__&) = delete;\n  ~__lambda_name__() = default;\n}; \n```", "```cpp\nauto tl = []<typename T>(T x, T y)\n{\n  std::cout << x << ' ' << y << '\\n';\n};\ntl(10, 20);   // OK\ntl(10, \"20\"); // error \n```", "```cpp\nstruct foo\n{\n   static void f() { std::cout << \"foo\\n\"; }\n};\nauto tl = [](auto x)\n{\n  using T = std::decay_t<decltype(x)>;\n  T other;\n  T::f();\n};\ntl(foo{}); \n```", "```cpp\nauto tl = []<typename T>(T x)\n{\n  T other;\n  T::f();\n}; \n```", "```cpp\ntemplate <typename ...T>\nvoid foo(T&& ... args)\n{ /* ... */ }\nauto tl = [](auto&& ...args)\n{\n  return foo(std::forward<decltype(args)>(args)...);\n};\ntl(1, 42.99, \"lambda\"); \n```", "```cpp\nauto tl = []<typename ...T>(T && ...args)\n{\n  return foo(std::forward<T>(args)...);\n}; \n```", "```cpp\nconstexpr int fib(int const n)\n{\n  return n <= 2 ? 1 : fib(n - 1) + fib(n - 2);\n} \n```", "```cpp\n    void sample()\n    {\n      std::function<int(int const)> lfib =\n        [&lfib](int const n)\n        {\n          return n <= 2 ? 1 : lfib(n - 1) + lfib(n - 2);\n        };\n      auto f10 = lfib(10);\n    } \n    ```", "```cpp\n    std::function<int(int const)> fib_create()\n    {\n      std::function<int(int const)> f = [](int const n)\n      {\n        std::function<int(int const)> lfib = [&lfib](int n)\n        {\n          return n <= 2 ? 1 : lfib(n - 1) + lfib(n - 2);\n        };\n        return lfib(n);\n      };\n      return f;\n    }\n    void sample()\n    {\n      auto lfib = fib_create();\n      auto f10 = lfib(10);\n    } \n    ```", "```cpp\n    struct fibonacci\n    {\n      std::function<int(int const)> lfib =\n        [this](int const n)\n        {\n          return n <= 2 ? 1 : lfib(n - 1) + lfib(n - 2);\n        };\n    };\n    fibonacci f;\n    f.lfib(10); \n    ```", "```cpp\n    void sample()\n    {\n       auto lfib = [](auto f, int const n)\n       {\n          if (n < 2) return 1;\n          else return f(f, n - 1) + f(f, n - 2);\n       };\n       lfib(lfib, 10);\n    } \n    ```", "```cpp\n    void sample()\n    {\n      auto lfib = [](this const auto& self, int n) -> int\n      {\n        return n <= 2 ? 1 : self(n - 1) + self(n - 2);\n      };\n      lfib(5);\n    } \n    ```", "```cpp\nauto lfib = [](auto f, int const n)\n{\n   if (n < 2) return 1;\n   else return f(f, n - 1) + f(f, n - 2);\n};\nlfib(lfib, 10); \n```", "```cpp\nclass __lambda_name_3\n{\npublic:\n   template<class T1>\n inline int operator()(T1 f, const int n) const\n {\n      if (n < 2) {\n         return 1;\n      }\n      else {\n         return f(f, n - 1) + f(f, n - 2);\n      }\n   }\n   template<>\n   inline int operator()<__lambda_name_3> (__lambda_name_3 f, \n const int n) const\n {\n      if (n < 2) {\n         return 1;\n      }\n      else {\n         return f.operator()(__lambda_name_3(f), n - 1) + \n                f.operator()(__lambda_name_3(f), n - 2);\n      }\n   }\n};\n__lambda_name_3 lfib = __lambda_name_3{};\nlfib.operator()(__lambda_name_3(lfib), 10); \n```", "```cpp\n[](this auto const & self, int n) -> int \n```", "```cpp\nerror: function 'operator()<(lambda)>' with deduced return type cannot be used before it is defined \n```", "```cpp\nauto lfib = [](this auto const& self, int n)\n{\n   if (n <= 2) return 1;\n   return self(n - 1) + self(n - 2);\n}; \n```", "```cpp\n    template <typename T>\n    T minimum(T a, T b)\n    {\n       return a <= b ? a : b;\n    }\n    minimum(3, 4);\n    minimum(3.99, 4.01); \n    ```", "```cpp\n    template <>\n    const char* minimum(const char* a, const char* b)\n    {\n       return std::strcmp(a, b) <= 1 ? a : b;\n    }\n    minimum(\"abc\", \"acxyz\"); \n    ```", "```cpp\n    template <typename T>\n    std::basic_string<T> minimum(std::basic_string<T> a, \n                                 std::basic_string<T> b) // [1]\n    {\n       return a.length() <= b.length() ? a : b;\n    }\n    std::string minimum(std::string a, std::string b) // [2]\n    {\n       return a.length() <= b.length() ? a : b;\n    }\n    minimum(std::string(\"def\"), std::string(\"acxyz\")); // calls [2]\n    minimum(std::wstring(L\"def\"), std::wstring(L\"acxyz\")); // calls [1] \n    ```", "```cpp\n    template <typename T>\n    T* minimum(T* a, T* b) = delete;\n    int a = 3;\n    int b = 4;\n    minimum(&a, &b); // error \n    ```", "```cpp\n    minimum<int>(1, 2);  // explicit int template argument\n    minimum(3.99, 4.50); // deduced double template argument \n    ```", "```cpp\n    template char minimum(char a, char b); \n    ```", "```cpp\n    template <typename T, std::size_t S>\n    std::array<T, S> make_array()\n    {\n       return std::array<T, S>{};\n    } \n    ```", "```cpp\ntemplate <typename T, auto S>\nstd::array<T, S> make_array()\n{\n   return std::array<T, S>{};\n} \n```", "```cpp\n    template <typename T>\n    struct Minimum\n    {\n       T operator()(T a, T b)\n     {\n          return a <= b ? a : b;\n       }\n    };\n    template <typename T, template <typename> class M>\n    T trimin(T a, T b, T c)\n    {\n       return M<T>{}(a, M<T>{}(b, c));\n    }\n    trimin<int, Minimum>(5, 2, 7); \n    ```", "```cpp\ntemplate <typename T>\nstd::basic_string<T> minimum(std::basic_string<T> a, std::basic_string<T> b);\nstd::string minimum(std::string a, std::string b);\nminimum(std::string(\"def\"), std::string(\"acxyz\"));\nminimum(std::wstring(L\"def\"), std::wstring(L\"acxyz\")); \n```", "```cpp\nminimum(1, 2);\nminimum<int>(1, 2); \n```", "```cpp\nminimum(1, 2u); // error, ambiguous template parameter T \n```", "```cpp\nminimum<unsigned>(1, 2u); // OK \n```", "```cpp\ntemplate <typename T>                 // [1] overload with fixed\nT add(T value) //     number of arguments\n{\n  return value;\n}\ntemplate <typename T, typename... Ts> // [2] typename... Ts\nT add(T head, Ts... rest) // [3] Ts... rest\n{\n  return head + add(rest...);         // [4] rest...\n} \n```", "```cpp\nauto s1 = add(1, 2, 3, 4, 5); // s1 = 15\nauto s2 = add(\"hello\"s, \" \"s, \"world\"s, \"!\"s); // s2 = \"hello world!\" \n```", "```cpp\nint add(int head, int arg1, int arg2, int arg3, int arg4)\n{return head + add(arg1, arg2, arg3, arg4);}\nint add(int head, int arg1, int arg2, int arg3)\n{return head + add(arg1, arg2, arg3);}\nint add(int head, int arg1, int arg2)\n{return head + add(arg1, arg2);}\nint add(int head, int arg1)\n{return head + add(arg1);}\nint add(int value)\n{return value;} \n```", "```cpp\n    T add(T, Ts ...) [with T = int; Ts = {int, int, int, int}]\n    T add(T, Ts ...) [with T = int; Ts = {int, int, int}]\n    T add(T, Ts ...) [with T = int; Ts = {int, int}]\n    T add(T, Ts ...) [with T = int; Ts = {int}]\n    T add(T) [with T = int] \n    ```", "```cpp\n    T add(T, Ts...) [T = int, Ts = <int, int, int, int>]\n    T add(T, Ts...) [T = int, Ts = <int, int, int>]\n    T add(T, Ts...) [T = int, Ts = <int, int>]\n    T add(T, Ts...) [T = int, Ts = <int>]\n    T add(T) [T = int] \n    ```", "```cpp\nauto s3 = add(\"hello\"s, ' ', \"world\"s, '!'); // s3 = \"hello world!\" \n```", "```cpp\nIn instantiation of 'T add(T, Ts ...) [with T = char; Ts = {string, char}]':\n16:29:   required from 'T add(T, Ts ...) [with T = string; Ts = {char, string, char}]'\n22:46:   required from here\n16:29: error: cannot convert 'string' to 'char' in return\n In function 'T add(T, Ts ...) [with T = char; Ts = {string, char}]':\n17:1: warning: control reaches end of non-void function [-Wreturn-type] \n```", "```cpp\nstring add(string head, char arg1, string arg2, char arg3)\n{return head + add(arg1, arg2, arg3);}\nchar add(char head, string arg1, char arg2)\n{return head + add(arg1, arg2);}\nstring add(string head, char arg1)\n{return head + add(arg1);}\nchar add(char value)\n{return value;} \n```", "```cpp\ntemplate <typename T, typename... Ts>\nauto add(T head, Ts... rest)\n{\n  return head + add(rest...);\n} \n```", "```cpp\ntemplate<typename... T>\nauto make_even_tuple(T... a)\n{\n  static_assert(sizeof...(a) % 2 == 0,\n                \"expected an even number of arguments\");\n  std::tuple<T...> t { a... };\n  return t;\n}\nauto t1 = make_even_tuple(1, 2, 3, 4); // OK\n// error: expected an even number of arguments\nauto t2 = make_even_tuple(1, 2, 3); \nsizeof...(a) to make sure that we have an even number of arguments and assert by generating a compiler error otherwise. The sizeof... operator can be used with both template parameter packs and function parameter packs. sizeof...(a) and sizeof...(T) would produce the same value. Then, we create and return a tuple. \n```", "```cpp\ntemplate <typename T>\nT add(T value)\n{\n  return value;\n}\ntemplate <typename T, typename... Ts>\nT add(T head, Ts... rest)\n{\n  return head + add(rest...);\n} \n```", "```cpp\n    template <typename... Ts>\n    auto add(Ts... args)\n    {\n      return (... + args);\n    } \n    ```", "```cpp\n    template <typename... Ts>\n    auto add_to_one(Ts... args)\n    {\n      return (1 + ... + args);\n    } \n    ```", "```cpp\n    template <typename... Ts>\n    auto add(Ts... args)\n    {\n      return (args + ...);\n    } \n    ```", "```cpp\n    template <typename... Ts>\n    auto add_to_one(Ts... args)\n    {\n      return (args + ... + 1);\n    } \n    ```", "```cpp\nauto sum = add(1, 2, 3, 4, 5);         // sum = 15\nauto sum1 = add_to_one(1, 2, 3, 4, 5); // sum = 16 \n```", "```cpp\nint add(int arg1, int arg2, int arg3, int arg4, int arg5)\n{\n  return ((((arg1 + arg2) + arg3) + arg4) + arg5);\n} \n```", "```cpp\ntemplate <typename T>\nstruct wrapper\n{\n  T const & value;\n};\ntemplate <typename T>\nconstexpr auto operator<(wrapper<T> const & lhs, wrapper<T> const & rhs)\n{\n  return wrapper<T> {lhs.value < rhs.value ? lhs.value : rhs.value};\n} \n```", "```cpp\ntemplate <typename... Ts>\nconstexpr auto min(Ts&&... args)\n{\n  return (wrapper<Ts>{args} < ...).value;\n}\nauto m = min(3, 1, 2); // m = 1 \n```", "```cpp\ntemplate<>\ninline constexpr int min<int, int, int>(int && __args0,\n                                        int && __args1,\n                                        int && __args2)\n{\n  return\noperator<(wrapper_min<int>{__args0},\n      operator<(wrapper_min<int>{__args1},\n                wrapper_min<int>{__args2})).value;\n} \n```", "```cpp\ntemplate <typename... Ts>\nconstexpr auto minimum(Ts&&... args)\n{\n  return (args < ...);\n} \n```", "```cpp\ntemplate<>\ninline constexpr bool minimum<int, int, int>(int && __args0,\n                                             int && __args1,\n                                             int && __args2)\n{\n  return __args0 < (static_cast<int>(__args1 < __args2));\n} \n```", "```cpp\n    template <typename F, typename R>\n    R mapf(F&& func, R range)\n    {\n      std::transform(\n        std::begin(range), std::end(range), std::begin(range),\n        std::forward<F>(func));\n      return range;\n    } \n    ```", "```cpp\n    template<typename F, typename T, typename U>\n    std::map<T, U> mapf(F&& func, std::map<T, U> const & m)\n    {\n      std::map<T, U> r;\n      for (auto const kvp : m)\n        r.insert(func(kvp));\n      return r;\n    }\n    template<typename F, typename T>\n    std::queue<T> mapf(F&& func, std::queue<T> q)\n    {\n      std::queue<T> r;\n      while (!q.empty())\n      {\n        r.push(func(q.front()));\n        q.pop();\n      }\n      return r;\n    } \n    ```", "```cpp\n    template <typename F, typename R, typename T>\n    constexpr T fold_left(F&& func, R&& range, T init)\n    {\n      return std::accumulate(\n        std::begin(range), std::end(range),\n        std::move(init),\n        std::forward<F>(func));\n    }\n    template <typename F, typename R, typename T>\n    constexpr T fold_right(F&& func, R&& range, T init)\n    {\n      return std::accumulate(\n        std::rbegin(range), std::rend(range),\n        std::move(init),\n        std::forward<F>(func));\n    } \n    ```", "```cpp\n    template <typename F, typename T>\n    constexpr T fold_left(F&& func, std::queue<T> q, T init)\n    {\n      while (!q.empty())\n      {\n        init = func(init, q.front());\n        q.pop();\n      }\n      return init;\n    } \n    ```", "```cpp\n    auto vnums =\n      std::vector<int>{0, 2, -3, 5, -1, 6, 8, -4, 9};\n    auto r =mapf([](int const i) { return std::abs(i); }, vnums);\n    // r = {0, 2, 3, 5, 1, 6, 8, 4, 9} \n    ```", "```cpp\n    auto lnums = std::list<int>{1, 2, 3, 4, 5};\n    auto l = mapf([](int const i) { return i*i; }, lnums);\n    // l = {1, 4, 9, 16, 25} \n    ```", "```cpp\n    template<class T = double>\n    struct fround\n    {\n      typename std::enable_if_t<std::is_floating_point_v<T>, T>\n      operator()(const T& value) const\n      {\n        return std::round(value);\n      }\n    };\n    auto amounts =\n      std::array<double, 5> {10.42, 2.50, 100.0, 23.75, 12.99};\n    auto a = mapf(fround<>(), amounts);\n    // a = {10.0, 3.0, 100.0, 24.0, 13.0} \n    ```", "```cpp\n    auto words = std::map<std::string, int>{\n      {\"one\", 1}, {\"two\", 2}, {\"three\", 3}\n    };\n    auto m = mapf(\n      [](std::pair<std::string, int> const kvp) {\n        return std::make_pair(\n          funclib::mapf(toupper, kvp.first),\n          kvp.second);\n        },\n        words);\n    // m = {{\"ONE\", 1}, {\"TWO\", 2}, {\"THREE\", 3}} \n    ```", "```cpp\n    auto priorities = std::queue<int>();\n    priorities.push(10);\n    priorities.push(20);\n    priorities.push(30);\n    priorities.push(40);\n    priorities.push(50);\n    auto p = mapf(\n      [](int const i) { return i > 30 ? 2 : 1; },\n      priorities);\n    // p = {1, 1, 1, 2, 2} \n    ```", "```cpp\n    auto vnums =\n      std::vector<int>{0, 2, -3, 5, -1, 6, 8, -4, 9};\n    auto s1 = fold_left(\n      [](const int s, const int n) {return s + n; },\n      vnums, 0);                // s1 = 22\n    auto s2 = fold_left(\n      std::plus<>(), vnums, 0); // s2 = 22\n    auto s3 = fold_right(\n      [](const int s, const int n) {return s + n; },\n      vnums, 0);                // s3 = 22\n    auto s4 = fold_right(\n      std::plus<>(), vnums, 0); // s4 = 22 \n    ```", "```cpp\n    auto texts =\n      std::vector<std::string>{\"hello\"s, \" \"s, \"world\"s, \"!\"s};\n    auto txt1 = fold_left(\n      [](std::string const & s, std::string const & n) {\n      return s + n;},\n      texts, \"\"s);    // txt1 = \"hello world!\"\n    auto txt2 = fold_right(\n      [](std::string const & s, std::string const & n) {\n      return s + n; },\n      texts, \"\"s);    // txt2 = \"!world hello\" \n    ```", "```cpp\n    char chars[] = {'c','i','v','i','c'};\n    auto str1 = fold_left(std::plus<>(), chars, \"\"s);\n    // str1 = \"civic\"\n    Auto str2 = fold_right(std::plus<>(), chars, \"\"s);\n    // str2 = \"civic\" \n    ```", "```cpp\n    auto words = std::map<std::string, int>{\n      {\"one\", 1}, {\"two\", 2}, {\"three\", 3} };\n    auto count = fold_left(\n      [](int const s, std::pair<std::string, int> const kvp) {\n        return s + kvp.second; },\n      words, 0); // count = 6 \n    ```", "```cpp\nauto vnums = std::vector<int>{ 0, 2, -3, 5, -1, 6, 8, -4, 9 };\nauto s = fold_left(\n  std::plus<>(),\n  mapf(\n    [](int const i) {return i*I; },\n    mapf(\n      [](int const i) {return std::abs(i); },\n      vnums)),\n  0); // s = 236 \n```", "```cpp\ntemplate <typename F, typename T1, typename T2>\nauto fold_left(F&&f, T1 arg1, T2 arg2)\n{\n  return f(arg1, arg2);\n}\ntemplate <typename F, typename T, typename... Ts>\nauto fold_left(F&& f, T head, Tsâ€¦ rest)\n{\n  return f(head, fold_left(std::forward<F>(f), rest...));\n} \n```", "```cpp\nauto s1 = fold_left(std::plus<>(), 1, 2, 3, 4, 5);\n// s1 = 15\nauto s2 = fold_left(std::plus<>(), \"hello\"s, ' ', \"world\"s, '!');\n// s2 = \"hello world!\"\nauto s3 = fold_left(std::plus<>(), 1); // error, too few arguments \n```", "```cpp\n    template <typename F, typename G>\n    auto compose(F&& f, G&& g)\n    {\n      return [=](auto x) { return f(g(x)); };\n    }\n    auto v = compose(\n      [](int const n) {return std::to_string(n); },\n      [](int const n) {return n * n; })(-3); // v = \"9\" \n    ```", "```cpp\n    template <typename F, typename... R>\n    auto compose(F&& f, R&&... r)\n    {\n      return [=](auto x) { return f(compose(r...)(x)); };\n    }\n    auto n = compose(\n      [](int const n) {return std::to_string(n); },\n      [](int const n) {return n * n; },\n      [](int const n) {return n + n; },\n      [](int const n) {return std::abs(n); })(-3); // n = \"36\" \n    ```", "```cpp\nauto s = compose(\n  [](std::vector<int> const & v) {\n    return fold_left(std::plus<>(), v, 0); },\n  [](std::vector<int> const & v) {\n    return mapf([](int const i) {return i + i; }, v); },\n  [](std::vector<int> const & v) {\n    return mapf([](int const i) {return std::abs(i); }, v); })(vnums); \n```", "```cpp\ntemplate <typename F, typename G>\nauto operator*(F&& f, G&& g)\n{\n  return compose(std::forward<F>(f), std::forward<G>(g));\n}\ntemplate <typename F, typename... R>\nauto operator*(F&& f, R&&... r)\n{\n  return operator*(std::forward<F>(f), r...);\n} \n```", "```cpp\nauto n =\n  ([](int const n) {return std::to_string(n); } *\n   [](int const n) {return n * n; } *\n   [](int const n) {return n + n; } *\n   [](int const n) {return std::abs(n); })(-3); // n = \"36\"\nauto c =\n  [](std::vector<int> const & v) {\n    return fold_left(std::plus<>(), v, 0); } *\n  [](std::vector<int> const & v) {\n    return mapf([](int const i) {return i + i; }, v); } *\n  [](std::vector<int> const & v) {\n    return mapf([](int const i) {return std::abs(i); }, v); };\nauto vnums = std::vector<int>{ 2, -3, 5 };\nauto s = c(vnums); // s = 20 \n```", "```cpp\nint add(int const a, int const b)\n{\n  return a + b;\n}\nstruct foo\n{\n  int x = 0;\n  void increment_by(int const n) { x += n; }\n}; \n```", "```cpp\n    auto a1 = std::invoke(add, 1, 2);   // a1 = 3 \n    ```", "```cpp\n    auto a2 = std::invoke(&add, 1, 2);  // a2 = 3\n    int(*fadd)(int const, int const) = &add;\n    auto a3 = std::invoke(fadd, 1, 2);  // a3 = 3 \n    ```", "```cpp\n    foo f;\n    std::invoke(&foo::increment_by, f, 10); \n    ```", "```cpp\n    foo f;\n    auto x1 = std::invoke(&foo::x, f);  // x1 = 0 \n    ```", "```cpp\n    foo f;\n    auto x3 = std::invoke(std::plus<>(),\n      std::invoke(&foo::x, f), 3); // x3 = 3 \n    ```", "```cpp\n    auto l = [](auto a, auto b) {return a + b; };\n    auto a = std::invoke(l, 1, 2); // a = 3 \n    ```", "```cpp\nnamespace details\n{\n  template <class F, class T, std::size_t... I>\n  auto apply(F&& f, T&& t, std::index_sequence<I...>)\n {\n    return std::invoke(\n      std::forward<F>(f),\n      std::get<I>(std::forward<T>(t))...);\n  }\n}\ntemplate <class F, class T>\nauto apply(F&& f, T&& t)\n{\n  return details::apply(\n    std::forward<F>(f),\n    std::forward<T>(t),\n    std::make_index_sequence<\n      std::tuple_size_v<std::decay_t<T>>> {}); \n} \n```", "```cpp\n// direct call\nauto a1 = add(1, 2);    // a1 = 3\n// call through function pointer\nint(*fadd)(int const, int const) = &add;\nauto a2 = fadd(1, 2);   // a2 = 3\nauto fadd2 = &add;\nauto a3 = fadd2(1, 2);  // a3 = 3 \n```", "```cpp\nfoo f;\nf.increment_by(3);\nauto x1 = f.x;    // x1 = 3\nvoid(foo::*finc)(int const) = &foo::increment_by;\n(f.*finc)(3);\nauto x2 = f.x;    // x2 = 6\nauto finc2 = &foo::increment_by;\n(f.*finc2)(3);\nauto x3 = f.x;    // x3 = 9 \n```"]