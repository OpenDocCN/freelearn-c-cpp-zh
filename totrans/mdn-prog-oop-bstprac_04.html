<html><head></head><body>
		<div class="Content" id="_idContainer018">
			<h1 id="_idParaDest-35"><em class="italics"><a id="_idTextAnchor037"/>Chapter 3</em></h1>
		</div>
		<div class="Content" id="_idContainer019">
			<h1 id="_idParaDest-36"><a id="_idTextAnchor038"/>Synthesis</h1>
		</div>
		<div class="Content" id="_idContainer020">
			<p>In <em class="italics">Chapter 2, Thesis</em>, we saw that the core benefits of OOP can be achieved with a small number of considerations:</p>
			<ul>
				<li>Objects are <em class="italics">independent programs</em>, ignorant of context to the largest possible extent</li>
				<li>Objects communicate by <em class="italics">sending messages</em></li>
				<li>Objects behave in ways described in <em class="italics">contracts</em> expressing their responses to messages</li>
				<li>Objects can be written, changed, inspected, and adapted <em class="italics">in context</em></li>
			</ul>
			<p>There is no system currently available that supports all of these requirements simultaneously. Ironically, while OOP has become <em class="italics">overcomplicated</em>, as demonstrated in <em class="italics">Chapter 1, Antithesis</em>, it has also remained <em class="italics">incomplete</em>. In the final part of this book, let's consider what such a system would look like.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>Objects Are Independent Programs</h2>
			<p>The easiest problem to solve is allowing developers to independently design objects without expressing constraints that inhibit the developers' design freedoms. One way is to provide a <strong class="inline">MetaObject</strong> protocol that allows developers to adapt the rules of a language to fit a particular context. An even easier way (both to create and to use) is to make the <em class="italics">primitive parts of the message system</em> available to developers, to combine as needed to fulfill their design goals.</p>
			<p>This is easier to create because any more complex system would need these primitives anyway. It is easier to use because it allows the developers to construct solutions to problems as they encounter them, rather than trying to work out how to adapt existing rules onto the models they have for their solutions. That adaptation was one of the difficulties with using OOP we explored in <em class="italics">Chapter 1, Antithesis</em>: if what you've got is Java inheritance, you need to solve your problem using Java inheritance, even if your problem doesn't seem like it fits with Java inheritance.</p>
			<p>The primitives needed are small in number. Here is a worked example in Python that is based on the functional programming view of objects explored in <em class="italics">Chapter 1, Antithesis</em>.</p>
			<p><strong class="bold">A selector type</strong>. This is a type that can be used to name messages, and thus it must be comparable: the receiver needs to know which selector was named in a message so it can decide what to do. Python's string type is sufficient as a selector type, though many OO languages use an interned string type (Ruby's symbols, for example) to make comparison cheaper.</p>
			<p><strong class="bold">A lookup function</strong>. This is a way, given a message, to decide what code to run. Python already uses a <strong class="inline">__getattr__()</strong> function to do this, both for its <strong class="inline">object.attribute</strong> syntax and to implement the <strong class="inline">getattr(object, attribute)</strong> function, and conveniently, it expects the attribute's name to be a string, so this works with the message selectors.</p>
			<p><strong class="bold">A way to send a message</strong>. This will let the object find the appropriate method implementation using its own lookup function, then execute that method with the arguments supplied in the message. It looks like this:</p>
			<p class="snippet">	def msg_send(obj, name, *args):</p>
			<p class="snippet">		message_arguments = [obj]</p>
			<p class="snippet">		message_arguments.extend(args)</p>
			<p class="snippet">		return getattr(obj,name)(*message_arguments)</p>
			<p>Notice the convention that the first argument to any message is the receiving object. This allows the object to recursively message itself, even if the method being invoked was not found on the receiver but on a delegated object that would otherwise be ignorant of the receiver.</p>
			<p><strong class="bold">A recursive case for message lookup</strong>. If an object does not know how to implement a given message, it can ask a different object. This is <em class="italics">delegation</em>. It looks like this:</p>
			<p class="snippet">    def delegate(other, name):</p>
			<p class="snippet">        return getattr(other, name)</p>
			<p><strong class="bold">A base case for message lookup</strong>. Eventually, an object will need a way to say "sorry, I was sent a message that I do not understand". The <strong class="inline">doesNotUnderstand</strong> function provides that behavior (in our case, raising an error), and we'll also supply a <strong class="inline">Base</strong> type that uses <strong class="inline">doesNotUnderstand</strong> and can terminate any delegation chain:</p>
			<p class="snippet">    def doesNotUnderstand(obj, name):</p>
			<p class="snippet">        raise ValueError("object {} does not respond to selector {}".format(obj, name))</p>
			<p class="snippet">	Base = type('Base', (), {</p>
			<p class="snippet">        '__getattr__': (lambda this, name:</p>
			<p class="snippet">            (lambda myself: myself) if name=="this"</p>
			<p class="snippet">            else (lambda myself: doesNotUnderstand(myself, name)))</p>
			<p class="snippet">        })</p>
			<p>Due to the message-sending convention, <strong class="inline">myself</strong> is the object that received the message, while <strong class="inline">this</strong> is the object that is handling the message on its behalf: these could be, but do not have to be, the same.</p>
			<p>Now these 13 lines of Python (found in <strong class="bold">objective-py</strong> at <a href="https://gitlab.labrary.online/leeg/objective-py">https://gitlab.labrary.online/leeg/objective-py</a>) are sufficient to build any form of object-oriented delegation, including the common forms of inheritance.</p>
			<p>An <strong class="bold">object</strong> can inherit from a prototype by delegating all unknown messages to it.</p>
			<p>A <strong class="bold">class</strong> is an object that implements methods on behalf of its instances. A created instance of a class contains all of its own data, but delegates all messages to the class object.</p>
			<p>The class can have no parents (it does not delegate unknown messages), one parent (it delegates all unknown messages to a single parent class object) or multiple parents (it delegates unknown messages to any of a list of parent class objects). It can also support traits or mixins, again by adding them to the list of objects to search for method implementations in.</p>
			<p>A class could even have a <strong class="inline">metaclass</strong>: a class object to which it delegates messages that it has received itself. That <strong class="inline">metaclass</strong> could have a <strong class="inline">metametaclass</strong>, if desired.</p>
			<p>Any, or multiple, of these schemes can be used within the same system, because the objects are ignorant of each other and how they are constructed. They simply know that they can use <strong class="inline">msg_send()</strong> to send each other messages, and that they can use <strong class="inline">delegate</strong> to have another object respond to messages on their behalf.</p>
			<p>But, Python being Python, these objects all run synchronously on the same thread, in the same process. They are not truly independent programs yet.</p>
			<p>Sticking with Python, it is easy to separate our objects out into separate processes by using a different Python interpreter for each object via the <strong class="inline">execnet</strong>â€”<a href="https://codespeak.net/execnet/index.html">https://codespeak.net/execnet/index.html</a> module.</p>
			<h4>A quick, but important, aside</h4>
			<p class="callout">The example here (and available at <a href="https://gitlab.labrary.online/leeg/objactive-py">https://gitlab.labrary.online/leeg/objactive-py</a>) focuses on demonstrating the possibility of running isolated objects, and is not really appropriate for using in a real application or system. The lack of production systems based around the simple object-oriented principles described in this book is the motivation for writing the book in the first place!</p>
			<p>Each object can live in its own module. Creating an object involves creating a new Python interpreter and telling it to run this module:</p>
			<p class="snippet">    def create_object():</p>
			<p class="snippet">        my_module = inspect.getmodule(create_object)</p>
			<p class="snippet">        gw = execnet.makegateway()</p>
			<p class="snippet">        channel = gw.remote_exec(my_module)</p>
			<p class="snippet">        return channel</p>
			<p>When <strong class="inline">execnet</strong> runs a module, it has a special name that we can use to store the receiving channel and install the message handler. In this code, the receiver is stored in a global variable; as this is running in its own Python interpreter in a separate process from the rest of our system, that <em class="italics">global</em> is in fact unique to the receiving object:</p>
			<p class="snippet">    if __name__ == '__channelexec__':</p>
			<p class="snippet">        global receiver</p>
			<p class="snippet">        receiver = channel</p>
			<p class="snippet">        channel.setcallback(handler)</p>
			<p class="snippet">        channel.waitclose()</p>
			<p>The <strong class="inline">handler</strong> function is our object's message dispatch function: it inspects the message selector and decides what code to run. This can work in exactly the same way as in previous examplesâ€”in other words, it can work however we want. Once an object receives a message, it should be up to <em class="italics">that object</em> to decide what to do with it, and how to act in response.</p>
			<h3 id="_idParaDest-38"><a id="_idTextAnchor040"/>An Object's Behavior Can Be Described in A Contract</h3>
			<p>While it is up to any one object to decide how it responds to messages, we need to know whether that object represents a useful addition to our system. In other words, we want to know <em class="italics">what</em> the object will do in response to <em class="italics">what</em> messages.</p>
			<p>As seen in <em class="italics">Chapter 2, Thesis</em>, the Eiffel language encapsulates this knowledge about an object in the form of a <em class="italics">contract</em>, describing the preconditions and postconditions for each method along with the invariants that hold when the object has been created and whenever it is not executing a method.</p>
			<p>This contract is, as the language in <em class="italics">Object-Oriented Software Construction</em> implies, a useful <em class="italics">design</em> tool: describe your object in terms of the messages it receives, what it expects when it receives those messages, and what the sender can expect in return.</p>
			<p>Eiffel also demonstrates that the contract is an effective <em class="italics">correctness testing</em> tool, because the assertions contained in an object's contract can be checked whenever appropriate, whether the object is being used in a test or a production system. In principle, the contract could even be used to <em class="italics">generate</em> tests in the style of property-based testing; what is "for all (expected input structure) -&gt; (assertions that some properties hold of results)" other than a statement of preconditions and postconditions? In practice, this integration does not yet exist.</p>
			<p>As the contract describes what an object can do, what must be true for the object to do it, and what will be true after the object has done it, it's also a great candidate for the position of <em class="italics">standard documentation structure</em> for each object. We already see in the world of HTTP APIs that the <strong class="bold">Open API Specification</strong> (formerly Swagger, <a href="https://swagger.io/specification">https://swagger.io/specification</a>) is a machine and human-readable description of what operations an API supports, its parameters and responses. An approach like this could easily be adopted for individual objects; after all, an object represents a model of a small, isolated computer program and so its message boundary <em class="italics">is</em> an API supporting particular operations.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor041"/>Objects Can Be Written, Inspected, And Changed in Context</h2>
			<p>David West describes objects as <em class="italics">actors</em> on the computer stage, and even the meta-acting of programmers picking up the CRC card representing an object and role-playing its part in the system, explaining what data they're using and what messages they're sending to the other objects. Objects are fundamentally a live, interactive way of <em class="italics">thinking about software</em>, so they would be best supported by a live, interactive way of <em class="italics">turning thought into software</em>.</p>
			<p>The Smalltalk environments, including modern ones such as <strong class="bold">Pharo</strong> and <strong class="bold">Amber</strong>â€”<a href="https://www.amber-lang.net/">https://www.amber-lang.net/</a>, demonstrate that such tools are possible. Pharo in particular features novel additions to the developer experience, one of the bullet points on the project's About page (<a href="https://pharo.org/about">https://pharo.org/about</a>) tells us that "yes, we code in the debugger."</p>
			<p>Distributing the software that is made with such an environment, currently, can be suboptimal. With Pharo, you either export specific classes into a package that somebody else who already has Pharo set up can use, or you write the state of your whole Pharo environment to an <em class="italics">image file</em>, and give the Pharo VM and the image file to the person who will use your software. Amber works like this too, but in the background is using the popular Bower package manager for JavaScript and its <em class="italics">image</em> contains just a few classes that implement JavaScript functions. Additionally, many JavaScript developers do not <em class="italics">distribute</em> their software in the conventional sense, as it is either served as needed to the browser or run by the developers themselves in a Node.js service.</p>
			<p>Such live interaction is not confined to the Smalltalk world. I am writing this section of the book using the <strong class="bold">GNU Emacs</strong>â€”<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a> text editor, which is really an Emacs Lisp interpreter with a dynamic text-centric user interface. At any time, I can type some Emacs Lisp in and evaluate it, including defining new functions or redefining existing functions. For example, given a paragraph containing the following:</p>
			<p class="snippet">    (defun words () (interactive) (shell-command (concat "wc -w " buffer-file-name)))</p>
			<p>I can move my cursor to the end of the paragraph, run the Emacs Lisp <strong class="inline">eval-last-sexp</strong> function, and then have a new <strong class="inline">words</strong> function that returns 1909, the number of words (at the time of writing) in this part of the manuscript. If it didn't do that, if I had accidentally counted characters instead of words, I could edit the function, re-evaluate it, and carry on using the fixed version. There's no need to quit Emacs while I re-build it, because I'm editing the code in the same environment that it runs in.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor042"/>Put That All Together</h2>
			<p>All of the parts explored here exist, but not in the same place. Putting these together is a significant undertaking; building message passing and delegation between objects in separate processes may only take a few source lines, design-by-contract is a judicious application of the <strong class="inline">assert()</strong> statement, but a whole interactive environment to allow live development and debugging of such a system is a much bigger undertaking. So why consider it?</p>
			<h3 id="_idParaDest-41"><a id="_idTextAnchor043"/>Speed</h3>
			<p>When the development environment and the deployment environment are the same, developers get a higher fidelity experience that makes turnaround time on development lower by reducing the likelihood that a change will "break in CI" (or even in production) due to differences in the environments.</p>
			<p>The people using the software can have higher confidence too, because they know that the developer has built the thing in the same environment it will be used in. Additionally, the use of contracts in this proposed development system increases confidence, because the software is stated (and demonstrated) to work for <em class="italics">all</em> satisfactory inputs rather than merely a few test cases thought of by the developer.</p>
			<p>Such fidelity is typically provided to developers at the <em class="italics">expense</em> of speed. Programmers connect over the network to a production-like server or wait for virtual machine or container images to be constructed on their local system. This time gets added to the typical steps, such as compiling or linking that come from separating development and deployment, giving us time to get distracted and lose our thread of concentration while getting validation of our work so far.</p>
			<p>Ultimately, though, the speed comes from <em class="italics">experimentation</em>. When development is close to deployment, it's easier to ask questions such as "what if I change this to be like that?" and to answer them. When systems are decomposed into small, isolated, independent objects, it's easier to change or even discard and replace objects that need improvement or adaptation.</p>
			<p>While there is value in <em class="italics">designing</em> by contract, there is also value in <em class="italics">progressively</em> adding details to an object's contract as more properties of the system being simulated become known, and confidence in the shape of the objects increases. Contracts are great for documentation and for confidence in the behavior of an object, but those benefits need not come at the expense of forcing a developer's train of thought to call at particular stations in a prescribed order. As we saw in <em class="italics">Chapter 1, Antithesis</em>, a lot of complexity in object-oriented programming to date came from requiring that software teams consider their use cases, or their class hierarchies, or their data sharing, or other properties of the system at particular points in an object-oriented software engineering process.</p>
			<p>It's far better to say, "here are the tools, use them when it makes sense," so that the developer experience is not on rails. If that means taking time designing the developer system so that use, construction, documentation, testing, and configuration of the thing being developed can happen in any order, then so be it.</p>
			<h3 id="_idParaDest-42"><a id="_idTextAnchor044"/>Tailoring</h3>
			<p>Such experimentation also lends itself to <em class="italics">adaptation</em>. A frequent call for the industrialization of software involves the standardization of components and the ability for end users to plug those components together as required. Brad Cox's Software ICs, Sal Soghoian's AppleScript dictionaries, and even the NPM repository represent approaches to designing reuse by defining the boundary between "things that are reused" and "contexts in which they are reused."</p>
			<p>In all of these situations, though, the distinction is arbitrary: a Software IC could implement a whole application, or the innards of a Mac app could be written in AppleScript. In a live development environment, the distinction is erased, and any part is available for extension, modification, or replacement. There is a famous story about Dan Ingalls adding smooth scrolling to a running Smalltalk system (<a href="http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html">http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html</a>) during a demo for a team from Apple Computer that included Steve Jobs. At that moment, Dan Ingalls' Alto computer had smooth scrolling, and nobody else's did. He didn't need to recompile his Smalltalk machine and take the computer down to redeploy it, it just started working that way.</p>
			<p>My assertion is that the addition of contracts to a live programming environment <em class="italics">enables</em> experimentation, customization, and adaptation by increasing confidence in the replacement parts. Many object-oriented programmers already design their objects to adhere to the Liskov Substitution Principle, which says (roughly) that one object can act as a replacement for another if its preconditions are at most as strict as the other object's, and its postconditions are at least as strict.</p>
			<p>In current environments, however, this idea of substitutability is unnecessarily coupled to the type system and to inheritance. In the proposed system, an object's inheritance or lack thereof is its own business, so we ask a simpler question: is this object's contract compatible with that use of an object? If it is, then they can be swapped and we know that things will work (at least to the extent that the contract is sufficient, anyway). If it is not, then we know <em class="italics">what</em> will not work, and what adaptation is required to hook things up.</p>
			<h3 id="_idParaDest-43"><a id="_idTextAnchor045"/>Propriety</h3>
			<p>"But how will we make money?" has been a rallying cry for developers who don't want to use a new tool or technique for decades. We said we couldn't make money when free and open source software made our source code available to our users, then started running GNU/Linux servers that our users connect to so they can download our JavaScript source code.</p>
			<p>The system described here involves combining the development and deployment environments, so how could we possibly make money? Couldn't users extract our code and run it themselves for free, or give it to their friends, or sell it to their friends?</p>
			<p>Each object on the system is an <em class="italics">independent program</em> running in its own process, and its interface is the loosely coupled abstraction of message-sending. Any particular object could be a compiled executable based on a proprietary algorithm, distributed without its source code. Or it could be running on the developer's own server, handling messages remotely, or it could be deployed as a <strong class="bold">dApp</strong> to <strong class="bold">Ethereum</strong> or <strong class="bold">NEO</strong>. In each case, the developer avoids having to deploy their source code to the end user, and while that means that the user can't inspect or adapt the object, it does not stop them from <em class="italics">replacing</em> it.</p>
			<p>It is interesting to consider how the economics of software delivery might change under such a system. At the moment, paid-outright applications, regular subscription fees, and free applications with paid-for content or components are all common, as are free (zero cost) applications and components. Other models do exist: some API providers charge per use, and blockchain dApps also cost <em class="italics">money</em> (albeit indirectly via tokens) to execute the distributed functions. An app or a web service has a clear brand, visible via the defined entry point for the user (their web address, or home screen icon). How might software businesses charge for the fulfilment of a programmatic contract, or for parts of an application that are augmented by other objects, or even replaced after deployment?</p>
			<h3 id="_idParaDest-44"><a id="_idTextAnchor046"/>Security</h3>
			<p>It was mentioned when discussing the propriety of objects that each object is hidden behind the loosely coupled message-sending abstraction. Implications on the security of such a system are as follows:</p>
			<ul>
				<li>For an object to trust the content of a message, it must have sufficient information to make a trust decision and the confidence that the message it has received is as intended with no modifications. Using operating system IPC, the messages sent between objects are mediated by the kernel, which can enforce any access restrictions.</li>
				<li>"Sufficient information" may include metadata that would be supplied by the messaging broker, for example, information about the context of the sender or the chain of events that led to this message being sent.</li>
				<li>The form in which the object receives the message does not have to be the form in which it was transmitted; for example, the messaging layer could encrypt the message and add an authentication code on sending that is checked on receipt before allowing the object to handle the message. Developers who work on web applications will be familiar with this anyway, as their requests involve HTTP verbs such as <strong class="inline">GET</strong> or <strong class="inline">POST</strong> and readable data such as <strong class="inline">JSON</strong>, but are then sent in a compressed format over encrypted, authenticated TLS channels. There is no reason such measures need to be limited to the network edges of an application nor (as evinced with a microservices architecture) for the network edge and the physical edge of the system to be in the same place.</li>
			</ul>
			<h3 id="_idParaDest-45"><a id="_idTextAnchor047"/>Multiprocessing</h3>
			<p>Computers have not been getting faster, in terms of single-task instructions per second, for a very long time. Nonetheless, they still <em class="italics">are</em> significantly faster than the memory from which they are loading their code and data.</p>
			<p>This hypothesis needs verifying, but my prediction is that small, independent objects communicating via message passing are a better fit for today's multi-core hardware architectures, as each object is a small self-contained program that should do a better job of fitting within the cache near to a CPU core than a monolithic application process.</p>
			<p>Modern high-performance computing architectures are already massively parallel systems that run separate instances of the workload that synchronize, share data, and communicate results via message sending, typically based on the MPI standard. Many of the processor designs used in HPC are even <em class="italics">slower</em> in terms of instruction frequency than those used in desktop or server applications, but have many more cores in a single package and higher memory bandwidth. </p>
			<p>The idea of breaking down an application to separate, independent objects is compatible with the observation that we don't need <em class="italics">a fast program</em>, but <em class="italics">a fast system</em> comprising multiple programs. As with cloud computing architectures, such systems can get faster by scaling. We don't necessarily need to make a faster widget if we can run tens of copies of the same widget and share the work out between them.</p>
			<h3 id="_idParaDest-46"><a id="_idTextAnchor048"/>Usability</h3>
			<p>All of this discussion focuses on the benefits (observed or hypothesized) of the approach to writing software that has been developed in this book. We need to be realistic, though, and admit that working in the way described here is untested and is a significant departure from the way programmers currently work.</p>
			<p>Smalltalk programmers already love their Smalltalk, but then C++ programmers love their C++ too, so there isn't a one-size-fits-all solution to the happiness of programmers, even if it could be shown that for some supposed objective property of the software construction process or the resulting software, one tool or technique had an advantage over others.</p>
			<p>Some people may take a "better the devil you know" outlook, while others may try this way (assuming such a system even gets built!) and decide that it isn't for them. Still others may even fall in love with the <em class="italics">idea</em> of working in this way, though we could find that it slows them down or makes lower quality output than their current way of working! Experimentation and study will be needed to find out what's working, for whom, and how it could be improved.</p>
			<p>This could turn out to be the biggest area of innovation in the whole system. Developer experiences are typically extremely conservative. "Modern" projects use the edit-compile-link-run-debug workflow that arose to satisfy technical, not experiential, constraints decades ago. They are driven from a <strong class="bold">DEC VT-100</strong> emulator. Weirdly, that is never the interface of choice for consumer products delivered by teams staffed with designers and user experience experts.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor049"/>Conclusion to Part Three</h2>
			<p>The story of this book has been one of deconstruction and reconstruction. The enormous complexity of three decades of OOP was deconstructed, to find a simple core, and an object-oriented programming experience was reconstructed around that core. The reconstruction contains all of the distinctive and important elements of the paradigm, while shedding the complexity borne of additive consultancy and capitulation to existing processes.</p>
			<p>Importantly, this new reconstruction still takes lessons from the two schools of thought in computing, which I call the <em class="italics">laboratory school</em> and the <em class="italics">library school</em>.</p>
			<p><strong class="bold">The Laboratory School</strong></p>
			<p>The Laboratory School is the experimental approach. Go out, make a thing, and adapt, refine, or reject it based on your observations of how it performs. Don't worry about making the right thing, or making the thing right, just ensure it is made. You can adapt it later.</p>
			<p><strong class="keyword">Extreme Programming</strong> (<strong class="keyword">XP</strong>) and the Lean Startup movement both exhibit influences of the laboratory school. Both schemes advocate experimentation and fast feedback. Both recommend starting small and simple â€“ XP with its <em class="italics">Ya Ain't Gonna Need It</em> principle and the Lean Startup with its <em class="italics">minimum viable product</em> â€“ and then rapidly iterating based on feedback.</p>
			<p>The Smalltalk style of object-oriented programming also evinces the laboratory way of thinking. Loose coupling via message-sending lets programmers replace the collaborating objects in a system with other objects easily and quickly. Integrated development and deployment environments enable a style called <strong class="bold">Debugger-Driven Design</strong>â€”<a href="https://medium.com/concerning-pharo/pharo-50c66685913c">https://medium.com/concerning-pharo/pharo-50c66685913c</a>: find the thing that breaks the system because you haven't built it yet, build it, then let the system carry on with its new behavior.</p>
			<p><strong class="bold">The Library School</strong></p>
			<p>The library school is the research-driven approach. Understand your problem, discover the properties of a solution that appropriately addresses the problem, implement the solution with those properties.</p>
			<p>The disciplines related to <em class="italics">object-oriented software engineering</em> show associations with the library school. While the Rational Unified Process, as one example, does promote <em class="italics">iterative and incremental</em> development, the increments tend to be additive rather than exploratory: build the walking skeleton, then design, implement, and test this use case, then that use case. Add more use cases until the funding runs out. Make sure that at each step you retain your carefully-considered hierarchy of class relationships.</p>
			<p>The <em class="italics">if it type checks, it works</em> principle in programming appears to come from the library school. A type system is a machine for constructing proofs about the software that uses types from that system. Design your software with consistent application of those types and you get theorems for free (<a href="https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf">https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf</a>) about the behavior of the software.</p>
			<p>Design by contract demonstrates library-school thinking applied to OOP. The principle characteristic of an object is not its named type, but its <em class="italics">shape</em>: the messages it responds to and the things it does in response to those messages. Taking the mathematical proof tools from formal methods and applying them to the shape of objects, you end up with the <em class="italics">contract</em>: a mathematical statement about the messages an object responds to and the behavior resulting from receiving those messages.</p>
			<p><strong class="bold">The Labrary</strong></p>
			<p>There are lessons to be learned from each of these schools of thought, and rather than siding with either one, the system described here adopts details from both. Not in an additive <em class="italics">let's do all the things these people do, and add all the things these people do</em> way, but in a synthetic <em class="italics">let's see what ideas these people promote and how they can be combined</em> way. We have contracts from the library, but don't require <em class="italics">design by contract</em>: they are part of a live, experimental system from the l<a id="_idTextAnchor050"/>aboratory that can be added and removed at any time.</p>
			<p>There is of course, one big problem with this environment, produced by the synthetic "Labrary" school of thought. That problem is that the environment doesn't exist. Yet. To the Labrary!</p>
		</div>
	</body></html>