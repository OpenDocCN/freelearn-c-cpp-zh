["```cpp\nQT += sensors\n```", "```cpp\n for (const QByteArray &type : QSensor::sensorTypes()) {\n        const QByteArray &identifier = QSensor::defaultSensorForType(type);\n```", "```cpp\n        QSensor* sensor = new QSensor(type, this);\n        sensor->setIdentifier(identifier);\n\n```", "```cpp\nif (!sensor->connectToBackend())\n    qWarning() << \"Could not connect to sensor backend\";\n```", "```cpp\nconnect(sensor, &QSensor::readingChanged, this, &SomeClass::readingChanged);\n```", "```cpp\nvoid SomeClass::readingChanged()\n{\n    QSensor *sensor = qobject_cast<QSensor *>(sender());\n    QSensorReading *reading = sensor->reading()\n    QString values;\n    for (int i = 0; i < reading->valueCount(); i++) {\n        values += QString::number(reading->value(i).toReal()) + \" \";\n    }\n  ui->textEdit->insertPlainText(sensor->type() +\" \" + sensor->identifier() + \" \"+ values + \"\\n\");\n}\n```", "```cpp\nif (!sensor->isActive())\n  sensor->start();\n```", "```cpp\nQLightSensor *lightSensor = new QLightSensor(this);\nif (!lightSensor->connectToBackend()) {\n    qWarning() << \"Could not connect to light sensor backend\";\n    return;\n}\nconnect(lightSensor, &QLightSensor::readingChanged, &SomeClass::lightSensorChanged);\n\n```", "```cpp\nSomeClass::lightSensorChanged(const QLightReading *reading)\n{\n    qWarning() << reading->lux();\n}\n```", "```cpp\nclass LightFilter : public QLightFilter\n{\npublic:\n```", "```cpp\n\n bool filter(QLightReading *reading)\n { \n      int lux = 0;\n        int averageLux = 0; \n        if (averagingList.count() <= 4) {\n            averagingList.append(reading->lux());\n        } else {\n            for (int i = 0; i < averagingList.count(); i++) {\n                lux += averagingList.at(i);\n            }\n            averageLux = lux / (averagingList.count());\n            reading->setLux(averageLux);\n            averagingList.append(averageLux);\n            return true; // store the reading in the sensor\n        }\n        return false;\n    };\n    QList<int> averagingList;\n\n};\n```", "```cpp\n            if (type == QByteArray(\"QLightSensor\")) {\n                LightFilter *filter = new LightFilter();\n                sensor->addFilter(filter);\n            }\n```", "```cpp\nQSensorReading reading;\nQList <qreal> data;\nqreal x = reading.at(0);\nqreal y = reading.at(1);\nif (reading.valueCount() == 3)\n    qreal z = reading.at(2);\nqreal timestamp = reading.timestamp;\n```", "```cpp\nQAccelerometer accel;\nQAccelerometerReading accelReading = accel.reading();\nqreal x = accelReading.x();\nqreal y = accelReading.y();\nqreal z = accelReading.z();\n```", "```cpp\nimport QtSensors 5.12\nLightSensor {    \n    id: lightSensor\n    active: true\n    onReadingChanged {\n        console.log(\"Lux \"+ illuminance);\n }\n```", "```cpp\ncd src/sensors\n$perl ./make_sensor.pl QSaltSensor \nCreating ../imports/sensors/qmlsaltsensor.h \nCreating ../imports/sensors/qmlsaltsensor.cpp \nCreating qsaltsensor_p.h \nCreating qsaltsensor.h \nCreating qsaltsensor.cpp\nYou will need to add qsaltsensor to the src/sensors.pro file to the SENSORS and the qmlsaltsensor files to src/imports/sensors/sensors.pro\n```", "```cpp\n#ifndef LINUXSALT_H\n#define LINUXSALT_H\n\n#include <qsensorbackend.h>\n#include <qsaltsensor.h>\n\nclass LinuxSaltSensor : public QSensorBackend\n{\n```", "```cpp\n\npublic:\n    static char const * const id;\n    LinuxSaltSensor(QSensor *sensor);\n    ~LinuxSaltSensor();\n    void start() override;\n    void stop() override;\nprivate:\n    QSaltReading m_reading;\n};\n#endif // LINUXSALT_H\n```", "```cpp\n[Default]\nQSaltSensor = linux.saltsensor\nQLightSensor = sensorfw.lightsensor\n```", "```cpp\nQSensorGesture *gesture = new QSensorGesture(QStringList() << \"QtSensors.slam\", this);\nconnect(gesture, SIGNAL(detected(QString)), this, SLOT(detectedGesture(QString)));\n\n```", "```cpp\ngesture->startDetection();\n```", "```cpp\nQSensorGestureManager manager;\n\n    for (const QString gestureId :  manager.gestureIds()) {\n        qDebug() << gestureId;\n\n       QStringList recognizerSignals = manager.recognizerSignals(gestureId);\n\n        for (const QString signalId : recognizerSignals ) {\n            qDebug() << \" Has signal \" << signalId;\n        }\n }\n```", "```cpp\nQSensorGesture *gesture = new QSensorGesture(QStringList() << gestureId, this);\n        connect(gesture,SIGNAL(detected(QString)), this,SLOT(detectedGesture(QString)));\n```", "```cpp\nimport QtSensors 5.12\n```", "```cpp\nSensorGesture {\n    id: sensorGesture\n    gestures : [ \"QtSensors.slam\", \"QtSensors.pickup\" ]\n}\n```", "```cpp\nonDetected: {\n    if (gesture == \"slam\") {\n        console.log(\"slam gesture detected!\")\n    }\n} \n```", "```cpp\nsensor.gesture.enabled\n```", "```cpp\nQT += websockets\n```", "```cpp\n#include <QtWebSockets/QWebSocketServer>\n\n```", "```cpp\nconst QWebSocketServer *socketServer = new QWebSocketServer(\"MobileSocketServer\",\n                                                            QWebSocketServer::NonSecureMode,this);\nconnect(sockerServer, &QWebSocketServer::newConnection, this, &SomeClass::newConnection);\nconnect(sockerServer, &QWebSocketServer::closed, this, &SomeClass::closed);\n```", "```cpp\nsocketServer->listen(QHostAddress::Any, 7532);\n```", "```cpp\nQWebSocket *socket = socketServer->nextPendingConnection();\n```", "```cpp\nconnect(socket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error),\n           this, &SomeClass::socketError);\n```", "```cpp\nconnect(socket, &QWebSocket::textMessageReceived, \n    this, &SomeClass::textMessageReceived);\nconnect(socket, &QWebSocket::binaryMessageReceived, \n    this, &SomeClass::binaryReceived);\n```", "```cpp\nSomeClass:binaryMessageReceived(const QByteArray &message) {\n}\nSomeClass:textMessageReceived(const QString &message) {\n}\n```", "```cpp\nimport QtWebSockets 1.0\n```", "```cpp\nWebSocketServer {\n    id: socketServer\n    url : \"ws://127.0.0.1:33343\"\n    listen: true\n}\n```", "```cpp\nonClientConnected {\n  ...\n}\n\nonErrorStringChanged {\n    console.log(errorString)\n}\n```", "```cpp\nWebSocketServer {\n      id: socketServer\n      host : \"127.0.0.1\"\n      port: 33343\n      listen: false\n      onClientConnected {\n         webSocket.onTextMessageReceived.connect(function(message)         {\n              console.log(message)\n         });\n      }\n  }\n```", "```cpp\n\nWebSocket {\n    id: webSocket\n    url: \"ws://localhost\"\n\n    onTextMessageReceived {\n        console.log(message)\n\n    }\n}\n```", "```cpp\nwebSocket.sendTextMessage(\"socket connected ok!\")\n```", "```cpp\nQT += mqtt\n```", "```cpp\n#include <QtMqtt/QMqttClient>\n```", "```cpp\nmqttClient = new QMqttClient(this);\nmqttClient->setHostname(broker.hivemq.com);\nmqttClient->setPort(1883);\n\n```", "```cpp\nconnect(mqttClient, &QMqttClient::errorChanged, this, &SomeClass::errorChanged);\nconnect(mqttClient, &QMqttClient::stateChanged, this, &SomeClass::stateChanged);\nconnect(mqttClient, &QMqttClient::messageReceived, this, &SomeClass::messageReceived);\n```", "```cpp\nmqttClient->connectToHost();\n```", "```cpp\nvoid SomeClass::stateChanged(QMqttClient::ClientState state)\n{\n   switch(state) {\n    case QMqttClient::Connecting:\n        qDebug() << \"Connecting...\";\n        break;\n    case QMqttClient::Connected:\n        qDebug() << \"Connected.\";\n        subscribe();\n        break;\n    case QMqttClient::Disconnected:\n        qDebug() << \"Disconnected.\"\n        break;\n    }\n}\n```", "```cpp\nvoid MainWindow::subscribe()\n{\n    QMqttTopicFilter topicName(\"Qt\");\n    subscription = mqttClient->subscribe(topicName, 0);\n    connect(subscription, &QMqttSubscription::stateChanged,this,    \n            &SomeClass::subscriptionStateChanged);\n    publish();\n}\n```", "```cpp\nvoid MainWindow::publish()\n{\n    QMqttTopicName topicName(\"Qt\");\n    QByteArray topicMessage(\"Everywhere!\");\n    mqttClient->publish(topicName, topicMessage);\n}\n```", "```cpp\nSensorServer::SensorServer(QObject *parent)\n   : QObject(parent),\n      humiditySensor(new QHumiditySensor(this)),\n      temperatureSensor(new QAmbientTemperatureSensor(this))\n{\n    initSensors();\n    initWebsocket();\n}\n```", "```cpp\nvoid SensorServer::initWebsocket() \n{ \n    mDevice.setUrl(\"broker.hivemq.com:8000\"); \n    mDevice.setProtocol(\"mqttv3.1\"); \n\n    connect(&mDevice, &WebSocketIODevice::socketConnected, this, &SensorServer::websocketConnected); \n} \n\n```", "```cpp\nvoid SensorServer::initSensors() \n{ \n    if (!humiditySensor->connectToBackend()) { \n        qWarning() << \"Could not connect to humidity backend\"; \n    } else { \n        humiditySensor->setProperty(\"alwaysOn\",true); \n        connect(humiditySensor,SIGNAL(readingChanged()), \n                this, SLOT(humidityReadingChanged())); \n    }    \n    if (!temperatureSensor->connectToBackend()) { \n        qWarning() << \"Could not connect to humidity backend\"; \n    } else { \n        temperatureSensor->setProperty(\"alwaysOn\",true); \n        connect(temperatureSensor,SIGNAL(readingChanged()), \n                this, SLOT(temperatureReadingChanged())); \n    } \n}\n\n```", "```cpp\nSOURCES += websocketiodevice.cpp\nHEADERS += websocketiodevice.h\n```", "```cpp\n#include \"websocketiodevice.h\"\n```", "```cpp\nWebSocketIODevice mDevice;\n```", "```cpp\nvoid SensorServer::initWebsocket()\n{\n    mDevice.setUrl(QUrl(\"broker.hivemq.com:8000\"));\n    connect(&mDevice, &WebSocketIODevice::socketConnected, this, &SensorServer::websocketConnected);\n    mDevice.open(QIODevice::ReadWrite);\n}\n```", "```cpp\nvoid SensorServer::websocketConnected()\n{\n    mqttClient = new QMqttClient(this);\n    mqttClient->setProtocolVersion(QMqttClient::MQTT_3_1);\n    mqttClient->setTransport(&mDevice, QMqttClient::IODevice);\n    connect(mqttClient, &QMqttClient::errorChanged,\n            this, &SensorServer::errorChanged);\n    connect(mqttClient, &QMqttClient::stateChanged,\n            this, &SensorServer::stateChanged);\n    connect(mqttClient, &QMqttClient::messageReceived,\n            this, &SensorServer::messageReceived);\n\n    mqttClient->connectToHost();\n}\n```", "```cpp\nvoid SensorServer::stateChanged(QMqttClient::ClientState state)\n{\n    switch(state) {\n    case QMqttClient::Connecting:\n        qDebug() << \"Connecting...\";\n        break;\n    case QMqttClient::Connected:\n        qDebug() << \"Connected.\";\n        humiditySensor->start();\n        temperatureSensor->start();\n        subscribe();\n        break;\n    case QMqttClient::Disconnected:\n        qDebug() << \"Disconnected.\";\n        break;\n    }\n}\n```", "```cpp\nvoid SensorServer::humidityReadingChanged()\n{\n    qDebug() << Q_FUNC_INFO << __LINE__;\n    QHumidityReading *humidityReading = humiditySensor->reading();\n    QByteArray data;\n    data.setNum(humidityReading->relativeHumidity());\n    QMqttTopicName topicName(\"Humidity\");\n    QByteArray topicMessage(data);\n    mqttClient->publish(topicName, topicMessage);\n}\n\nvoid SensorServer::temperatureReadingChanged()\n{\n    qDebug() << Q_FUNC_INFO << __LINE__;\n    QAmbientTemperatureReading *tempReading = temperatureSensor\n>reading();\n    QByteArray data;\n    data.setNum(tempReading->temperature());\n    QMqttTopicName topicName(\"Temperature\");\n    QByteArray topicMessage(data);\n    mqttClient->publish(topicName, topicMessage);\n}\n```", "```cpp\nvoid SensorServer::messageReceived(const QByteArray &message, const QMqttTopicName &topic)\n{\n    qDebug() << Q_FUNC_INFO  << topic << message;\n}\n```"]