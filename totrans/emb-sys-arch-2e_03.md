# 3

# 架构模式

从零开始启动嵌入式项目意味着通过经历所有研究和开发阶段，并考虑所有参与部分的协同作用，逐步走向最终解决方案。

软件开发需要在这些阶段中相应地发展。为了在不产生过多开销的情况下获得最佳结果，有一些最佳实践要遵循，以及一些工具要发现。

本章描述了一种基于实际经验的可能的方法，用于配置管理工具和设计模式。描述这种方法可能有助于您理解在一个专注于生产嵌入式设备或解决方案的团队中工作的动态。

本章我们将讨论以下主题：

+   配置管理

+   源代码组织

+   嵌入式项目的生命周期

+   安全考虑

到本章结束时，您将了解基于规范和平台限制设计系统时有用的架构模式概述。

# 配置管理

当作为团队工作时，协调和同步可以优化以提高效率。跟踪和控制开发生命周期可以平滑开发流程，减少停机时间和成本。

已知的最重要工具，用于帮助管理软件生命周期如下：

+   版本控制

+   问题跟踪

+   代码审查

+   持续集成

对于四个类别，存在不同的选项。源代码通过版本控制系统在开发者之间同步。**问题跟踪系统（ITSs**）通常由跟踪系统活动和已知错误的网络平台组成。可以通过特定的基于网络的工具鼓励代码审查，并通过版本控制系统的规则强制执行。

持续集成工具确保构建和测试执行任务被安排为自动执行，定期或在代码更改时执行，收集测试结果，并通知开发者关于回归的情况。

## 版本控制

无论您是单独工作还是在大型开发团队中，正确跟踪开发进度都极其重要。**版本控制**工具允许开发者通过按按钮随时回滚失败的实验，并查看其历史记录，以清晰地了解项目在任何时候是如何演变的。

**版本控制系统**，也称为**版本控制系统**或**VCS**，通过简化合并操作来鼓励合作。最更新的官方版本被称为**主干**、**主**或**主要**分支，具体取决于所使用的 VCS。VCSs 提供，包括其他事物，细粒度的访问控制和作者归属，直至单个提交。

最现代和最广泛使用的开源 VCS 之一是 Git。最初作为 Linux 内核的 VCS 而创建，Git 提供了一系列功能，但最重要的是，它提供了一个灵活的机制，允许快速且可靠地在不同版本和功能分支之间切换，并促进了代码中冲突修改的集成。

注意

在描述与版本控制系统（VCS）相关的特定活动时，本书使用了 Git 术语。

**提交**是版本控制系统中的一个操作，它会导致仓库出现新版本。仓库按照分层结构跟踪提交序列和每个版本中引入的更改：

+   **分支**：提交的线性序列称为分支。

+   **HEAD**：分支中的最新版本称为 HEAD。

+   **master**：Git 将主开发分支称为 master。master 分支是开发的主要焦点。错误修复和较小更改可以直接提交到 master。

+   **功能分支**：这些分支用于进行独立任务，在持续进行的实验中，最终将被合并到主分支。在不被滥用的情况下，功能分支非常适合在较小的子团队中处理任务，可以简化代码审查过程，允许开发者同时在不同的分支上工作，并将完成的任务的验证集中为单个 **合并** 请求。

**合并操作**是指将两个不同分支上的两个版本合并在一起，这两个分支在开发过程中可能已经分叉，并在代码中存在冲突。一些合并是微不足道的，可以由版本控制系统自动解决，而其他合并可能需要手动修复。

使用有意义的详细提交信息可以提高仓库历史的可读性，并有助于跟踪后续的回归。**标签**可以用于跟踪已发布和分发的中间版本。

## 跟踪活动

使用 ITS 可以简化跟踪活动和任务。一些工具可以直接链接到版本控制系统，以便将任务链接到仓库中的特定提交，反之亦然。这通常是一个好主意，因为可以很好地了解为了完成特定任务而进行的更改。

首先，将规范分解为简短的活动有助于开发方法。理想情况下，任务尽可能小，可以按类别分组。随后，可以根据中间目标和考虑最终硬件的可用性来设置优先级。创建的任务应分组到中间里程碑中，一些工具将其称为蓝图，这样就可以根据单个任务所取得的进展来衡量向中间交付成果的整体进度。

ITS 可以用于跟踪项目中的实际问题。**错误报告**应该足够详细，以便其他开发者能够理解症状并重现行为，从而证明代码中存在缺陷。理想情况下，最终用户和早期采用者应该能够向跟踪系统添加新问题，以便跟踪系统可以用于跟踪与开发团队的全部沟通。基于社区的开放源代码项目应向用户提供公开可访问的 ITS 接口。

修复错误的活动通常比开发任务具有更高的优先级，除非在少数情况下，例如，当错误是中间原型临时近似的结果，预计将在下一次迭代中修复。当一个错误影响了之前证明可以正常工作的系统行为时，它必须被标记为回归。这很重要，因为回归通常可以与普通错误不同处理，因为可以使用版本控制工具将它们追溯到单个提交。

**仓库控制**平台提供多种工具，包括源代码历史浏览和之前描述的问题跟踪功能。GitLab 是此类仓库控制平台的免费开源实现，可以安装并作为自托管解决方案运行。社区项目通常托管在社交编码平台，如 GitHub，这些平台旨在促进对开源和免费软件项目的贡献。

## 代码审查

通常集成到 ITS 工具中，**代码审查**通过鼓励对代码库中提出的更改进行批判性分析来促进团队合作，这有助于在提议的更改进入主分支之前检测潜在问题。根据项目要求，代码审查可能被推荐，甚至由团队强制执行，以提高代码质量并通过人工检查早期发现缺陷。

当与版本控制系统（VCS）正确集成时，可以在提交被认为可以合并之前，设置来自团队成员的强制正面审查的阈值。可以使用与 VCS 集成的工具，如**Gerrit**，强制要求对主分支上的每个提交进行审查。根据贡献的大小，这种机制可能会引入一些不必要的开销，因此，在大多数情况下，将分支引入主分支时，将分支引入主分支引入的更改分组在一起可能更合适，以方便审查。基于合并请求的机制使审查者可以概述整个修改开发过程中引入的更改。在接受外部贡献的开源项目中，代码审查是验证来自不太受信任的贡献者或通常来自维护者团队外部的更改的必要步骤。代码审查是防止可能被伪装且无法通过自动测试和代码分析工具检测到的恶意代码的最强大工具。

## 持续集成

如前所述，在嵌入式环境中，测试驱动的方法至关重要。在开发过程中自动化测试是及时检测回归和缺陷的最佳方式。使用自动化服务器，例如**Jenkins**，可以计划执行多个动作，或称**作业**，以响应式（例如每次提交时）、定期（例如每周二凌晨 1 点）或手动（根据用户请求）执行。以下是一些可以自动化的作业示例，以提高嵌入式项目的效率：

+   开发机器上的单元测试

+   系统验证测试

+   模拟环境中的功能测试

+   物理目标平台上的功能测试

+   稳定性测试

+   静态代码分析

+   生成文档

+   标签、版本控制和打包

必须在设计阶段决定所需的质量水平，并据此编写测试用例。可以使用`gcov`在每次测试执行后测量单元测试代码覆盖率。一些针对生命关键应用的项目可能需要单元测试有非常高的覆盖率，但为复杂系统编写完整的测试集会对总编程工作产生重大影响，并可能显著增加开发成本，因此，在大多数情况下，研究效率和质量的正确平衡是可取的。

对于功能测试，需要采取不同的方法。在目标上实现的所有功能都应该进行测试，并且应该使用预先准备好的测试来定义性能指标和验收阈值。在无法在目标系统和其周围环境中重新创建完整用例的所有情况下，功能测试应该在尽可能接近真实使用场景的环境中运行。

# 源代码组织

代码库应包含构建最终映像所需的所有源代码、第三方库、数据、脚本和自动化。将自包含库保存在单独的目录中是一个好主意，这样它们就可以通过替换子目录轻松更新到新版本。Makefiles 和其他脚本可以放置在项目的根目录中。

应用程序代码应简短、综合，并访问抽象宏观功能的模块。功能模块应描述一个过程，同时隐藏底层实现的细节，例如在适当采样和处理后从传感器读取数据。追求小型、自包含且充分抽象的模块也使得架构的组件更容易进行测试。将应用程序组件的大多数逻辑与其硬件特定实现分离，提高了跨不同平台的可移植性，并允许我们在开发阶段更改目标上的外设和接口。然而，过度抽象会影响成本，包括开发努力和所需资源，因此应研究正确的平衡点。

## 硬件抽象

通用原型平台由硅制造商构建和分发，用于评估微控制器和外设，因此软件开发的部分工作可能经常在这些设备上进行，甚至在最终产品的设计开始之前。

可在评估板上运行的软件通常以源代码或专有预编译库的形式作为参考实现分发。这些库可以根据最终目标进行配置和调整，从开始就用作参考硬件抽象，并更新其设置以匹配硬件配置的变化。

在我们的参考目标上，对通用 Cortex-M 微控制器的硬件组件支持以**Cortex Microcontroller Software Interface Standard**（CMSIS）库的形式提供，由 ARM 作为参考实现分发。硅制造商通过扩展 CMSIS 来获取其特定的硬件抽象。与特定硬件抽象链接的应用程序可以通过其特定的 API 调用访问外设，并通过 CMSIS 访问核心 MCU 功能。

要使代码在不同系列的 MCU 之间可移植，驱动程序可能需要在供应商特定 API 调用之上提供额外的抽象级别。如果 HAL 实现多个目标，它可以提供相同的 API 来访问多个平台上的通用功能，在幕后隐藏硬件特定实现。

CMSIS 和其他免费软件替代品，如**libopencm3**和**unicore-mx**的目标是将所有通用的 Cortex-M 抽象和最常见的 Cortex-M 硅制造商的特定代码分组，同时在控制系统和外围设备时掩盖平台特定调用之间的差异。

不论是硬件抽象，还是在引导的最早阶段所需的某些代码都非常特定于软件打算运行的每个目标。每个平台都有自己的特定地址空间分段、中断向量以及配置寄存器偏移。这意味着，在编写旨在在不同平台之间通用的代码时，自动化构建的 makefile 和脚本必须可配置，以便使用正确的启动代码和链接器配置进行链接。

本书中的示例不依赖于任何特定的硬件抽象，因为它们旨在通过直接与系统寄存器交互来控制系统组件，同时专注于与硬件组件的交互，并实现平台特定的设备驱动程序。

## 中间件

一些功能可能已经有一个已知的解决方案，该解决方案之前由单个开发者、社区或企业实现。解决方案可能是通用的，也许是为不同的平台设计的，甚至可能来自嵌入式世界之外。

在任何情况下，寻找任何可能已经编码并等待集成到我们项目中的数据转换库、协议实现或子系统模型总是值得的。

几个开源库和软件组件已经准备好被包含到嵌入式项目中，使我们能够实现更广泛的功能集。从开源项目中集成组件对于提供标准功能特别有用。有大量经过验证的开源实现，专为嵌入式设备设计，可以轻松集成到嵌入式项目中，以下是一些示例：

+   实时操作系统

+   密码学库

+   TCP/IP、6LoWPAN 和其他网络协议

+   **传输层安全性**（**TLS**）库

+   文件系统

+   物联网消息队列协议

+   解析器

本书后面将更详细地描述这些类别中的一些组件。

在软件基础上使用操作系统允许我们管理内存区域和线程执行。在这种情况下，线程独立于彼此执行，甚至可以在线程之间以及运行中的线程和内核之间实现内存分离。当设计复杂性增加或模块中存在无法重新设计的已知阻塞点时，这种方法是可取的。如果使用操作系统，其他库通常需要多线程支持，这可以在编译时启用。

集成第三方库的决定必须通过测量在目标平台上执行特定任务所需的资源（以代码大小和使用的内存来衡量）来评估。由于整个固件作为单个可执行文件分发，所有组件的许可证必须兼容，并且集成不得违反任何单个组件的许可证条款。

## 应用代码

应用代码的作用是从项目设计的最高层协调所有涉及的模块，并编排系统的启发式策略。一个设计良好的干净主模块使我们能够清晰地看到系统的所有宏观模块，它们之间的关系以及各个组件的执行时间。

裸机应用程序围绕一个主无限循环函数构建，该函数负责在底层库和驱动程序的入口点之间分配 CPU 时间。执行是顺序发生的，因此代码只能由中断处理程序挂起。因此，从主循环中调用的所有函数和库调用都应该尽可能快地返回，因为隐藏在其他模块中的停滞点可能会损害系统的反应性，甚至永远阻塞它们，从而永远无法返回主循环。理想情况下，在裸机系统中，每个组件都设计为使用事件驱动范式与主循环交互，主循环不断等待事件和机制注册回调，以在特定事件上唤醒应用程序。

裸机、单线程方法的优点是线程之间不需要同步，所有内存都可以被代码中的任何函数访问，并且不需要实现复杂机制，如上下文和执行模型切换。然而，当中断发生且执行流程在任何时刻都可能被外部事件中断以执行特定处理程序时，可能仍然需要一些基本的同步机制。

如果多个任务需要在操作系统上运行，每个任务应尽可能限制在其自己的模块内，并明确导出其启动函数和公共变量作为全局符号。在这种情况下，任务可以休眠并调用阻塞函数，这些函数应实现特定于操作系统的阻塞机制。

由于 Cortex-M CPU 的灵活性，系统上可以激活不同级别的线程和进程分离。

CPU 提供了多个工具来促进具有任务分离、多种执行模式、内核特定寄存器、特权分离和内存分段技术的多线程系统开发。这些选项允许架构师定义更复杂、更倾向于通用应用的系统，这些系统在进程之间提供特权分离和内存分段，但也允许定义更小、更简单、更直接的系统，这些系统不需要这些功能，因为它们通常是为单一目的设计的。

选择基于非特权线程的执行模型会导致系统上下文变化实现变得更加复杂，并可能影响实时操作的延迟，这就是为什么裸机、单线程解决方案对于大多数实时应用仍然更受欢迎。

# 安全考虑

在设计新系统时考虑的最重要方面之一是安全性。根据系统的特性、要求和风险评估，可能需要不同的对策。增强安全性的功能通常是硬件和软件努力的结合，以提供针对已知攻击的特定保护。

## 漏洞管理

软件组件会随着新功能的引入和缺陷的修复而不断进化。在后续版本中发现的某些缺陷，如果没有及时采取适当行动，可能会影响运行过时软件的系统的安全性。一旦第三方组件中的漏洞完全向公众披露，继续运行过时代码就不再是一个好的选择。

在公共网络上运行的已知缺陷的旧版本有更大的可能性成为系统受损、软件执行控制或重要数据被盗攻击的攻击面。最好的应对策略是在系统设计初期就准备，包括使用适合特定用例、安全要求和安全级别的程序来规划远程更新。

当使用第三方库时，跟踪其最新版本的开发并充分理解已修复缺陷的影响是合适的，尤其是当这些缺陷被标记为安全问题的时候。

## 软件加密

**加密**算法在适当的时候应该被使用，例如，用于加密存储在本地或在两个系统之间传输的数据，验证网络上的远程参与者，或验证数据未被篡改且来自可信源。

良好的密码学始终基于开放、透明的标准，因此系统的安全性完全取决于密钥的安全性，这是荷兰密码学家奥古斯特·凯克霍夫在 19 世纪提出的凯克霍夫原则，而不是依赖于秘密机制，寄希望于其实现永远不会被披露或逆向工程。（尽管对于对信息安全概念有一定信心的人来说，这个最后声明应该是显而易见的，但在过去，许多嵌入式系统都采用了*隐蔽性安全*，这是一种在缺乏适当资源运行成熟的密码学原语的老式硬件架构上走捷径的坏习惯。）

现在，嵌入式密码库存在，能够在基于微控制器的系统中运行与 PC 和服务器上使用的相同最新标准算法，同时它们也在变得更加强大，适合运行（通常是 CPU 密集型）的密码学数学原语。一个完整的密码库通常提供三种算法家族的现成实现：

+   **非对称密码学**（RSA，ECC）基于一对密钥，私钥和公钥，它们相互关联。除了单向加密外，这些算法还提供其他机制，例如验证签名和从两个密钥对中派生二级密钥，例如，用作通过不受信任的介质通信的两个端点之间的共享秘密。

+   **对称密码学**（AES，ChaCha20）主要用于双向加密，在两个方向上使用相同的预共享秘密密钥。

+   **哈希算法**（SHA）提供了一种注入式摘要计算，通常用于验证数据是否被更改。

wolfCrypt 提供了针对嵌入式系统优化的算法完整集，它是作为 wolfSSL 的一部分分发的密码引擎，wolfSSL 是一个由专业人士维护的开源库，它还包括传输层安全性协议，这些将在*第九章*中进一步解释，*分布式系统和* *物联网架构*。

## 硬件密码学

在设计过程的初期就考虑安全性方面非常重要，以便提前确定实现正确机制所需的软件和硬件组件。仅仅添加一个密码库并不能保证系统安全性的提高，除非所有要求都得到满足，这通常意味着需要特定硬件组件的参与。

一些算法需要具有高熵的随机值，在没有特定硬件帮助的情况下，在微控制器上通常很难获得，例如**真随机数生成器**（**TRNGs**）。

其他基于公钥的加密需要信任锚存储，这意味着一个在运行时不能被攻击者修改的内存位置，通常依赖于可能存在于闪存控制器上的某些非易失性内存特性。最后，为了存储密钥，可能需要硬件辅助来提供一个只能由特权代码访问的安全保险库，在某些情况下，它从软件中永远无法访问，并且仅允许与安全存储耦合的硬件加密引擎一起使用。

## 运行不受信任的代码

随着嵌入式系统的复杂性和代码内存的增加，看到来自多个来源的软件组件集成到一个单一的固件映像中并不罕见。一些系统甚至提供软件开发套件，可以运行用户提供的自定义代码。

其他可能有一个接口允许您从远程位置执行代码。在这些所有情况下，考虑分离机制以防止意外（或故意）访问那些不应被低能力演员访问的内存区域或外围设备是合适的。

大多数微控制器提供两个执行权限级别，在某些平台上，可以通过在操作系统中的上下文切换来根据这些权限划分可寻址的内存空间。新一代微控制器提供基于当前阶段执行级别的内存边界严格强制执行的 TEE（信任执行环境）。

# 嵌入式项目的生命周期

现代开发框架建议将工作分解成更小的动作点，并在项目开发过程中通过产生中间工作交付成果来标记里程碑。每个交付成果都专注于提供一个整个系统的原型，缺失的功能暂时使用占位代码来替代。

这些推荐对于嵌入式项目似乎特别有效。在一个每个错误都可能使整个系统陷入致命状态的环境中，一次只处理一个小动作点，是一种高效的方法，可以在代码库中及时识别缺陷和回归，前提是在开发的早期阶段就建立了**持续集成**（**CI**）机制。中间里程碑应尽可能频繁，因此，在开发阶段尽快创建最终系统的原型是明智的。在识别、优先排序和分配行动给团队时，必须考虑到这一点。

一旦定义了达到目标所需的步骤，我们需要找到产生中间里程碑的工作原型的最佳顺序。在分配工作之前，考虑到开发动作之间的依赖关系，对工作优先级进行排序。

对系统行为和硬件约束的逐步理解可能会在开发过程中改变对系统架构的看法，因为会遇到意外问题。对中间原型进行的测量和评估作为反应而更改规范可能需要大量代码重构。丢弃项目中的连贯部分并用新的、改进的设计替换通常有利于项目的质量，并可能在后期阶段提高生产力。这个过程，称为**重构**，不应被视为开发开销，只要它是旨在改进系统设计和行为。

最后，创建系统软件的过程包括为应用程序定义一个清晰的 API，以便以期望的方式与系统交互。嵌入式系统通常提供特定的 API 来访问系统资源；然而，某些操作系统和库可能提供 POSIX-like 接口以访问功能。在任何情况下，API 都是系统接口的入口点，必须设计得易于使用并且有良好的文档记录。

## 定义项目步骤

在分析规范、定义所需步骤和分配优先级时，可能需要考虑几个因素。考虑设计一个带有 PM10 空气质量串行传感器的空气质量监测设备，该设备每小时收集测量数据到内部闪存，然后使用无线收发器每天将所有统计数据发送到网关。目标系统是基于 Cortex-M MCU 的定制板，其尺寸足够运行最终软件。最终硬件设计将在对发送数据到网关的收发器进行一些实际测量后才能获得。

实现这些规范最终目标所需的步骤列表可能如下所示：

1.  在目标设备上启动最小系统（空主循环）。

1.  设置串行端口`0`以进行日志记录。

1.  设置串行端口`1`以与传感器通信。

1.  设置一个定时器。

1.  编写 PM10 传感器驱动程序。

1.  创建一个每小时唤醒并从传感器读取的应用程序。

1.  编写一个闪存子模块以存储/恢复测量数据。

1.  设置 SPI 端口以与无线电芯片通信。

1.  编写无线电驱动程序。

1.  实现一个与网关通信的协议。

1.  每 24 次测量后，应用程序将每日测量数据发送到网关。

注意

一些步骤可能依赖于其他步骤，因此存在执行顺序的约束。通过使用模拟器或仿真器，可以消除一些这些依赖关系。

例如，我们可能希望在只有一种方法可以通过网关上的模拟无线电信道测试协议与网关上运行的代理进行测试的情况下，才实现通信协议，而不需要有一个工作的无线电。保持模块自包含，并且对外仅暴露最小 API 调用集，使得将单个模块分离出来在不同的架构和受控环境中运行和测试变得更加容易，然后再将其集成到目标系统中。

## 原型设计

由于它是规格的一部分，我们知道我们应该优先处理与无线电通信相关的活动，以便硬件团队能够在设计上取得进展，因此在这种情况下，第一个原型必须执行以下操作：

1.  在目标设备上启动最小系统（空主循环）。

1.  设置串行端口`0`进行日志记录。

1.  设置 SPI 端口以与无线电芯片通信。

1.  编写无线电驱动程序。

1.  设置定时器。

1.  编写主应用程序以测试无线电信道（定期发送原始数据包）。

这个第一个原型已经会开始看起来像最终设备，即使它还不知道如何与传感器通信。一些测试用例可以已经实现，在模拟网关上运行，以检查消息是否被接收且有效。

在进行下一个原型定义时，我们可以开始添加一些额外的功能。在与网关进行协议进展时，并不需要真实的传感器读数，因为可以使用虚构的、*合成*的测试值来重现特定的行为。这使我们能够在真实硬件不可用的情况下，继续进行其他任务。

不论是开发团队采用纯敏捷软件开发方法还是使用不同的方法，在嵌入式开发环境中快速原型设计允许更快地应对路径上的不确定性，这些不确定性通常取决于硬件的行为和软件中需要采取的操作。

在嵌入式开发团队中，提供可行的中间交付成果是一种常见做法，这直接源于敏捷方法。敏捷软件开发预计在短时间内定期交付可工作的软件。就像先前的例子一样，中间原型不必实现最终软件图像的所有逻辑，而是必须用于证明概念、进行测量或在系统的较小部分上提供示例。

## 重构

重构通常被认为是对失败的激进补救措施，但实际上它是一种健康的实践，在系统最终成形和软件组件及外围设备支持随时间演变的同时，可以改进软件。

如果所有测试都在旧代码上运行，重构工作会更好。在重新设计模块内部结构的同时，单元测试应该适应新的函数签名。另一方面，如果模块的 API 保持不变，正在重构的模块的现有功能测试不应改变，并且只要与其他模块的接口保持相同，它将提供关于过程状态和准确性的持续反馈。

相比于较大的代码库，较小的代码库更容易进行重构，这又给我们一个理由保持每个模块较小且专注于系统上的特定功能。通过中间交付的原型进行进展意味着对应用程序代码的不断修改，当子系统被设计为相互独立以及与应用程序代码本身独立时，这应该需要更少的努力。

## API 和文档

我们都知道一本书不应该仅凭封面来判断。然而，一个系统通常可以通过其 API 来判断，这可能揭示系统内部实现和系统架构师的设计选择。一个清晰、易读且易于理解的 API 是嵌入式系统最重要的特性之一。应用开发者期望能够快速理解如何访问功能，并以最有效的方式使用系统。API 代表了系统与应用程序之间的*合同*，因此，它必须在开发之前设计，并且在最终交付过程中尽可能少地修改，如果需要修改的话。

API 中的一些接口可能描述了复杂的子系统并抽象出更详细的特点，因此始终提供足够的文档以帮助应用开发者熟悉并利用所有系统功能是一个好主意。提供文档的方式有很多，可以是将用户手册作为单独的文件分发到仓库中，或者直接在代码中包含不同接口的解释。

代码中的注释数量并不是质量的指标。每当代码被修改时，注释往往会*过时*，因为开发者可能会忘记更新注释以匹配代码中的新行为。此外，并非所有代码都需要注释；良好的习惯，如保持函数简短且复杂度低或使用表达性符号名称，在大多数情况下会使代码注释变得多余，因为代码可以自我解释。

对于包含复杂计算、位移动、详细条件或初次阅读代码时不易察觉的副作用等代码行，存在例外。某些代码部分可能还需要在开头进行描述，例如，具有多个返回值和特定错误处理的函数。在两个案例之间不包含 break 指令的 switch/case 语句必须始终有注释来表明这是有意为之，而不是错误。

他们还可能需要解释为什么某些操作被分组在两个或多个案例之间。添加没有提供任何有价值代码解释的冗余注释只会使代码更难以阅读。

另一方面，使用单独的编辑器和工具来描述模块的行为需要投入精力，因为每次代码发生重大变化时，所有文档都必须更新，并且开发者被要求将注意力从实际代码上转移开。

通常，需要记录的重要部分是之前提到的合同的描述，列举并解释应用程序和其他相关组件在运行时可以访问的函数和变量。由于这些声明可以包含在头文件中，因此可以通过在每个导出符号的声明上方添加扩展注释来描述整个合同。

存在将注释转换为格式化文档的软件工具。一个流行的例子是**Doxygen**，这是一个免费的开源文档生成工具，它解析整个代码库中匹配特定语法的注释，以生成超文本、结构化 PDF 手册和其他多种格式。如果文档在代码库中，更新和跟踪其结果对开发者的工作流程来说更容易且侵入性更小。在自动化服务器上集成文档生成可以提供在主分支每次提交时所有 API 的全新生成的手册副本。

# 摘要

提出的方法论旨在作为参考模式的一个示例，用于设计和管理嵌入式项目的发展。虽然可能有些描述的模式并不适用于所有项目，但本章的目标是鼓励嵌入式架构师寻找可能使软件生命周期更高效、成本更低的流程改进。最后，我们分析了在需要时通过添加适当的过程和组件来提高安全性的可能性。

在下一章中，我们将分析嵌入式系统启动时发生的事情，以及如何使用简单、裸机、主循环方法准备可启动的应用程序。
