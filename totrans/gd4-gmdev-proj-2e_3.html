<html><head></head><body>
		<div id="_idContainer080">
			<h1 id="_idParaDest-67" class="chapter-number"><a id="_idTextAnchor066"/>3</h1>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Space Rocks: Build a 2D Arcade Classic with Physics</h1>
			<p>By now, you should be getting more comfortable with working in Godot: adding nodes, creating scripts, modifying properties in the Inspector, and so on. If you find yourself stuck or feeling like you don’t remember how something is done, you can jump back to a project where it was first explained. As you repeat the more common actions in Godot, they’ll start to feel more and more familiar. At the same time, each chapter will introduce you to more nodes and techniques to expand your understanding of <span class="No-Break">Godot’s features.</span></p>
			<p>In this project, you’ll make a space shooter game similar to the arcade classic <em class="italic">Asteroids</em>. The player will <a id="_idIndexMarker131"/>control a ship that can rotate and move in any direction. The goal will be to avoid the floating “space rocks” and shoot them with the ship’s laser. Here’s a screenshot of the <span class="No-Break">final game:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B19289_03_01.jpg" alt="Figure 3.1: Space Rocks screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Space Rocks screenshot</p>
			<p>You’ll learn about the following key topics in <span class="No-Break">this project:</span></p>
			<ul>
				<li>Using custom <span class="No-Break">input actions</span></li>
				<li>Physics <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">RigidBody2D</strong></span></li>
				<li>Organizing game logic with finite <span class="No-Break">state machines</span></li>
				<li>Building a dynamic, <span class="No-Break">scalable UI</span></li>
				<li>Sound <span class="No-Break">and music</span></li>
				<li><span class="No-Break">Particle effects</span></li>
			</ul>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Technical requirements </h1>
			<p>Download the game assets from the following link below and unzip them into your new project <span class="No-Break">folder: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</span></a></p>
			<p>You can also find the complete code for this chapter on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks</span></a></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Setting up the project</h1>
			<p>Create a new project and download the project assets from the following <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</span></a><span class="No-Break">.</span><a href="https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads&#13;"/></p>
			<p>For <a id="_idIndexMarker132"/>this project, you’ll set up custom input actions in the <strong class="bold">Input Map</strong>. Using this feature, you can define custom input events and assign different keys, mouse events, or other inputs to them. This allows more flexibility in designing your game, as your code can be written to respond to the “jump” input, for example, without needing to know exactly what key and/or button the user pressed to make that event happen. This allows you to make the same code work on different devices, even if they have different hardware. In addition, since many gamers expect to be able to customize a game’s inputs, this enables you to provide that option to the user <span class="No-Break">as well.</span></p>
			<p>To set up the inputs for this game, open <strong class="bold">Project</strong> | <strong class="bold">Project Settings</strong> and select the <strong class="bold">Input </strong><span class="No-Break"><strong class="bold">Map</strong></span><span class="No-Break"> tab.</span></p>
			<p>You’ll need to create four new input actions: <strong class="source-inline">rotate_left</strong>, <strong class="source-inline">rotate_right</strong>, <strong class="source-inline">thrust</strong>, and <strong class="source-inline">shoot</strong>. Type the name of each action into the <strong class="bold">Add New Action</strong> box and hit <em class="italic">Enter</em> or click the <strong class="bold">Add</strong> button. Make sure you type the names exactly as shown since they’ll be used in <span class="No-Break">code later.</span></p>
			<p>Then, for each action, click the <strong class="bold">+</strong> button to its right. In the pop-up window, you can manually select a specific type of input, or you can press the physical button and Godot will detect it. You can add multiple inputs to each action. For example, to allow players to use both the arrow keys and the WASD keys, the setup will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B19289_03_02.jpg" alt="Figure 3.2: Input actions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Input actions</p>
			<p>If you have a gamepad or other controller connected to your computer, you can also add its inputs <a id="_idIndexMarker133"/>to the actions in the <span class="No-Break">same way.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We’re only considering button-style inputs at this stage, so while you’ll be able to use a D-pad for this project, using an analog joystick would require changes to the <span class="No-Break">project’s code.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Rigid body physics</h2>
			<p>In<a id="_idIndexMarker134"/> game development, you often need to know when two objects in the game space intersect or come into contact. This is known as <strong class="bold">collision detection</strong>. When a collision is detected, you typically want something to happen. This is known as <span class="No-Break"><strong class="bold">collision response</strong></span><span class="No-Break">.</span></p>
			<p>Godot offers three kinds of physics bodies, grouped under the <strong class="source-inline">PhysicsBody2D</strong> <span class="No-Break">node type:</span></p>
			<ul>
				<li><strong class="source-inline">StaticBody2D</strong>: A static body is one that is not moved by the physics engine. It participates in collision detection but does not move in response. This type of body is most often used for objects that are part of the environment or do not need to have any dynamic behavior, such as walls or <span class="No-Break">the ground.</span></li>
				<li> <strong class="source-inline">RigidBody2D</strong>: This is the physics body that provides simulated physics. This means that you don’t control a <strong class="source-inline">RigidBody2D</strong> physics body’s position directly. Instead, you apply forces to it (gravity, impulses, and so on) and Godot’s built-in physics engine calculates the resultant movement, including collisions, bouncing, rotating, and <span class="No-Break">other effects.</span></li>
				<li><strong class="source-inline">CharacterBody2D</strong>: This body type provides collision detection but no physics. All movement must be implemented in code, and you must implement any collision response yourself. Kinematic bodies are most often used for player characters or other actors that require <em class="italic">arcade-style</em> physics rather than realistic simulation, or when you need more precise control over how the <span class="No-Break">body moves.</span></li>
			</ul>
			<p>Understanding<a id="_idIndexMarker135"/> when to use a particular physics body type is a big part of building your game. Using the right type can simplify your development, while trying to force the wrong node to do the job can lead to frustration and poor results. As you work with each type of body, you’ll come to learn their pros and cons and get a feel for when they can help build what <span class="No-Break">you need.</span></p>
			<p>In this project, you’ll be using the <strong class="source-inline">RigidBody2D</strong> node for the ship as well as the rocks themselves. You’ll learn about the other body types in <span class="No-Break">later chapters.</span></p>
			<p>Individual <strong class="source-inline">RigidBody2D</strong> nodes have many properties you can use to customize their behavior, such as <strong class="bold">Mass</strong>, <strong class="bold">Friction</strong>, or <strong class="bold">Bounce</strong>. These properties can be set in <span class="No-Break">the Inspector.</span></p>
			<p>Rigid bodies are also affected by global properties, which can be set in <strong class="bold">Project Settings</strong> under <strong class="bold">Physics</strong> | <strong class="bold">2D</strong>. These settings apply to all bodies in <span class="No-Break">the world.</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B19289_03_03.jpg" alt="Figure 3.3: Project physics settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Project physics settings</p>
			<p>In most cases, you<a id="_idIndexMarker136"/> won’t need to modify these settings. However, note that by default, gravity has a value of <strong class="source-inline">980</strong> and a direction of <strong class="source-inline">(0, 1)</strong>, or downward. If you want to change the world’s gravity, you can do <span class="No-Break">that here.</span></p>
			<p>If you click the <strong class="bold">Advanced Settings</strong> toggle in the upper right of the <strong class="bold">Project Settings</strong> window, you’ll see many advanced configuration values for the physics engine. You should be aware of two of them in particular: <strong class="bold">Default Linear Damp</strong> and <strong class="bold">Default Angular Damp</strong>. These properties control how quickly a body will lose forward speed and rotation speed, respectively. Setting them to lower values will make the world feel frictionless, while using larger values will make it feel like your objects are moving through mud. This can be a great way to apply different movement styles to suit various game objects <span class="No-Break">and environments.</span></p>
			<p class="callout-heading">Area physics override</p>
			<p class="callout"><strong class="source-inline">Area2D</strong> nodes can also be used to influence rigid body physics by using their <strong class="bold">Space Override</strong> property. Custom gravity and damping values will then be applied to any bodies that enter <span class="No-Break">the area.</span></p>
			<p>Since this game will be taking place in outer space, gravity won’t be needed, so set <strong class="bold">Default Gravity</strong> to <strong class="source-inline">0</strong>. You can leave the other settings as <span class="No-Break">they are.</span></p>
			<p>That completes the project setup tasks. It’s a good idea to look back through this section and make sure you didn’t miss anything, since the changes you’ve made here will affect the behavior of many game objects. You’ll see this in the next section, where you’ll make the <span class="No-Break">player’s ship.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>The player’s ship</h1>
			<p>The <a id="_idIndexMarker137"/>player’s ship is the heart of this game. Most of the code you’ll write for this project will be about making the ship work. It will be controlled in <a id="_idIndexMarker138"/>the classic “Asteroids style, with left/right rotation and forward thrust. The player will also be able to fire the laser and destroy <span class="No-Break">floating rocks.</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B19289_03_04.jpg" alt="Figure 3.4: The player’s ship"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: The player’s ship</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Body and physics setup</h2>
			<p>Create a <a id="_idIndexMarker139"/>new scene and add a <strong class="source-inline">RigidBody2D</strong> named <strong class="source-inline">Player</strong> as the root node, with <strong class="source-inline">Sprite2D</strong> and <strong class="source-inline">CollisionShape2D</strong> children. Add the <strong class="source-inline">res://assets/player_ship.png</strong> image to the <strong class="bold">Texture</strong> property of the <strong class="source-inline">Sprite2D</strong>. The ship image is quite large, so set the <strong class="bold">Scale</strong> property of the <strong class="source-inline">Sprite2D</strong> to <strong class="source-inline">(0.5, 0.5)</strong> and <strong class="bold">Rotation</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">90</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B19289_03_05.jpg" alt="Figure 3.5: Player sprite settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Player sprite settings</p>
			<p class="callout-heading">Sprite orientation</p>
			<p class="callout">The image for the ship is drawn pointing upward. In Godot, a rotation of <strong class="source-inline">0</strong> degrees points to the right (along the <strong class="source-inline">x</strong>-axis). This means that you need to rotate the sprite so that it will match the body’s direction. If you use art that is drawn in the correct orientation, you can avoid this step. However, it’s very common to find art that’s drawn in an upward orientation, so you should know what <span class="No-Break">to do.</span></p>
			<p>In the <strong class="bold">Shape</strong> property <a id="_idIndexMarker140"/>of the <strong class="source-inline">CollisionShape2D</strong>, add a <strong class="source-inline">CircleShape2D</strong> and scale it to cover the image as closely <span class="No-Break">as possible.</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B19289_03_06.jpg" alt="Figure 3.6: Player collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Player collision shape</p>
			<p>The player ship<a id="_idIndexMarker141"/> is drawn in a pixel art style, but if you zoom in, you may notice it looks vary blurred and “smoothed out.” Godot’s default filter setting for drawing textures uses this smoothing technique, which looks good with some art, but typically isn’t wanted for pixel art. You can set the filtering individually on each sprite (in the <strong class="bold">CanvasItem</strong> section), or you can set it globally in <span class="No-Break"><strong class="bold">Project Settings</strong></span><span class="No-Break">.</span></p>
			<p>Open <strong class="bold">Project Settings</strong> and check the <strong class="bold">Advanced Settings</strong> toggle, and then find the <strong class="bold">rendering/textures</strong> section. Near the bottom, you’ll see two settings for <strong class="bold">Canvas Textures</strong>. Set <strong class="bold">Default Texture Filter</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Nearest</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B19289_03_07.jpg" alt="Figure 3.7: Default Texture Filter settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Default Texture Filter settings</p>
			<p>Save the scene. When working on larger-scale projects, it is recommended to organize your scenes and scripts into folders based on each game object rather than saving them all in the root <a id="_idIndexMarker142"/>project folder. For example, if you make a “player” folder, you can save all player-related files there. This makes it easier to find and modify your various game objects. While this project is relatively small – you’ll only have a few scenes – it’s a good habit to adopt as your projects grow in size <span class="No-Break">and complexity.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>State machines</h2>
			<p>The player’s ship <a id="_idIndexMarker143"/>can be in a number of different states during gameplay. For example, when <em class="italic">alive</em>, the ship is visible and can be controlled by the player, but it is vulnerable to being hit by rocks. On the other hand, when <em class="italic">invulnerable</em>, the ship should appear semi-transparent, and it is immune <span class="No-Break">to damage.</span></p>
			<p>One way that programmers often handle situations like this is to add Boolean variables, or <em class="italic">flags</em>, to the code. For example, the <strong class="source-inline">invulnerable</strong> flag is set to <strong class="source-inline">true</strong> when the player first spawns, or <strong class="source-inline">alive</strong> is set to <strong class="source-inline">false</strong> when the player is dead. However, this can lead to errors and strange situations when, for some reason, both <strong class="source-inline">alive</strong> and <strong class="source-inline">invulnerable</strong> are set to <strong class="source-inline">false</strong> at the same time. What happens when a rock hits the player in this situation? It would be better if the ship could only be in one clearly defined state at <span class="No-Break">a time.</span></p>
			<p>A solution to this <a id="_idIndexMarker144"/>problem is to use a <strong class="bold">finite state machine</strong> (<strong class="bold">FSM</strong>). When using an FSM, an entity can only be in one state at a given time. To design your FSM, you define a number of states and what events or actions can cause a transition from one state <span class="No-Break">to another.</span></p>
			<p>The following diagram depicts the FSM for the <span class="No-Break">player’s ship:</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B19289_03_08.jpg" alt="Figure 3.8: State machine diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: State machine diagram</p>
			<p>There <a id="_idIndexMarker145"/>are four states, shown by the ovals, and the arrows indicate what transitions can occur between states, as well as what triggers the transition. By checking the current state, you can decide what the player is allowed to do. For example, in <a id="_idIndexMarker146"/>the <strong class="bold">DEAD</strong> state, don’t allow input, or in the <strong class="bold">INVULNERABLE</strong> state, allow <a id="_idIndexMarker147"/>movement but don’t <span class="No-Break">allow shooting.</span></p>
			<p>Advanced FSM implementations can become quite complex, and the details are beyond the scope of this book (see the <em class="italic">Appendix</em> for further reading). In the purest sense, you won’t be creating a true FSM here, but for the purposes of this project, it will be sufficient to illustrate the concept and keep you from running into the Boolean <span class="No-Break">flag problem.</span></p>
			<p>Add a script to the <strong class="source-inline">Player</strong> node and start by creating the skeleton of the <span class="No-Break">FSM implementation:</span></p>
			<pre class="source-code">
extends RigidBody2D
enum {INIT, ALIVE, INVULNERABLE, DEAD}
var state = INIT</pre>
			<p>An <strong class="bold">enum</strong> (short for “enumeration”) is a <a id="_idIndexMarker148"/>convenient way to create a set of constants. The <strong class="source-inline">enum</strong> statement in the preceding code is equivalent to writing the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const INIT = 0
const ALIVE = 1
const INVULNERABLE = 2
const DEAD = 3</pre>
			<p>Next, create<a id="_idIndexMarker149"/> the <strong class="source-inline">change_state()</strong> function to handle <span class="No-Break">state transitions:</span></p>
			<pre class="source-code">
func _ready():
    change_state(ALIVE)
func change_state(new_state):
    match new_state:
        INIT:
            $CollisionShape2D.set_deferred("disabled",
                true)
        ALIVE:
            $CollisionShape2D.set_deferred("disabled",
                false)
        INVULNERABLE:
            $CollisionShape2D.set_deferred("disabled",
                true)
        DEAD:
            $CollisionShape2D.set_deferred("disabled",
                true)
    state = new_state</pre>
			<p>Whenever you need to change the state of the player, you’ll call the <strong class="source-inline">change_state()</strong> function and pass it the value of the new state. Then, by using a <strong class="source-inline">match</strong> statement, you can execute whatever code should accompany the transition to the new state or disallow it if you don’t want that transition to happen. To illustrate this, the <strong class="source-inline">CollisionShape2D</strong> node is <a id="_idIndexMarker150"/>being enabled/disabled by the new state. In <strong class="source-inline">_ready()</strong>,<strong class="source-inline"> </strong>we set <strong class="source-inline">ALIVE</strong> as the initial state – this is for testing, but we’ll change it to <span class="No-Break"><strong class="source-inline">INIT</strong></span><span class="No-Break"> later.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Adding player controls</h2>
			<p>Add the <a id="_idIndexMarker151"/>following variables at the top of <span class="No-Break">the script:</span></p>
			<pre class="source-code">
@export var engine_power = 500
@export var spin_power = 8000
var thrust = Vector2.ZERO
var rotation_dir = 0</pre>
			<p><strong class="source-inline">engine_power</strong> and <strong class="source-inline">spin_power</strong> control how fast the ship can accelerate and turn. <strong class="source-inline">thrust</strong> represents the force being applied by the engine: either <strong class="source-inline">(0, 0)</strong> when coasting or a vector pointing forward when the engine is on. <strong class="source-inline">rotation_dir</strong> represents in which direction the ship is turning so that you can apply a <em class="italic">torque</em> or <span class="No-Break">rotational force.</span></p>
			<p>As we saw earlier in <strong class="bold">Project Settings</strong>, the physics engine provides some <em class="italic">damping</em>, which reduces a body’s velocity and spin. In space, there’s no friction, so for realism, there shouldn’t be any damping at all. However, for the classic arcade feel, it’s preferable that the ship should stop when you let go of the keys. In the Inspector, set <strong class="bold">Linear/Damp</strong> to <strong class="source-inline">1</strong> and <strong class="bold">Angular/Damp</strong> to <strong class="source-inline">5</strong>. You can adjust these later to change how the <span class="No-Break">ship handles.</span></p>
			<p>The next step is to detect the input and move <span class="No-Break">the ship:</span></p>
			<pre class="source-code">
func _process(delta):
    get_input()
func get_input():
    thrust = Vector2.ZERO
    if state in [DEAD, INIT]:
        return
    if Input.is_action_pressed("thrust"):
        thrust = transform.x * engine_power
    rotation_dir = Input.get_axis("rotate_left",
        "rotate_right")
func _physics_process(delta):
    constant_force = thrust
    constant_torque = rotation_dir * spin_power</pre>
			<p>The <strong class="source-inline">get_input()</strong> function captures the key actions and sets the ship’s thrust on or off. Note<a id="_idIndexMarker152"/> that the direction of the thrust is based on the body’s <strong class="source-inline">transform.x</strong>, which always represents the body’s “forward” direction (see the <em class="italic">Appendix</em> for an overview <span class="No-Break">of transforms).</span></p>
			<p><strong class="source-inline">Input.get_axis()</strong> returns a value based on two inputs, representing negative and positive values. So, <strong class="source-inline">rotation_dir</strong> will be clockwise, counter-clockwise, or zero, depending on the state of the two <span class="No-Break">input actions.</span></p>
			<p>Finally, when using physics bodies, their movement and related functions should always be called in <strong class="source-inline">_physics_process()</strong>. Here, you can apply the forces set by the inputs to actually move <span class="No-Break">the body.</span></p>
			<p>Play the scene, and you should be able to fly <span class="No-Break">around freely.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Screen wrap</h2>
			<p>Another <a id="_idIndexMarker153"/>feature of classic 2D arcade games is <em class="italic">screen wrap</em>. If the player goes off one side of the screen, they appear on the other side. In practice, you teleport the ship to the other side by instantly changing its position. You’ll need to know the size of the screen, so add the following variable to the top of <span class="No-Break">the script:</span></p>
			<pre class="source-code">
var screensize = Vector.ZERO</pre>
			<p>And add this <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
screensize = get_viewport_rect().size</pre>
			<p>Later, you can have the game’s main script handle setting <strong class="source-inline">screensize</strong> for all the game’s objects, but for now, this will allow you to test the screen wrapping with just the <span class="No-Break">player’s scene.</span></p>
			<p>When<a id="_idIndexMarker154"/> first approaching this problem, you might think you could use the body’s <strong class="source-inline">position</strong> property and, if it exceeds the bounds of the screen, set it to the opposite side. And if you were using any other node type, that would work just fine; however, when using <strong class="source-inline">RigidBody2D</strong>, you can’t directly set <strong class="source-inline">position</strong> because that would conflict with the movement that the physics engine is calculating. A common mistake is to try adding something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func _physics_process(delta):
    if position.x &gt; screensize.x:
        position.x = 0
    if position.x &lt; 0:
        position.x = screensize.x
    if position.y &gt; screensize.y:
        position.y = 0
    if position.y &lt; 0:
        position.y = screensize.y</pre>
			<p>And if you wanted to try this with the <strong class="source-inline">Area2D</strong> in <em class="italic">Coin Dash</em>, it would work perfectly fine. Here, it will fail, trapping the player on the edge of the screen and glitching unpredictably at the corners. So, what is <span class="No-Break">the answer?</span></p>
			<p>To quote the <span class="No-Break"><strong class="source-inline">RigidBody2D</strong></span><span class="No-Break"> documentation:</span></p>
			<p class="author-quote">Note: You should not change a RigidBody2D’s <strong class="source-inline">position</strong> or <strong class="source-inline">linear_velocity</strong> every frame or even very often. If you need to directly affect the body’s state, use <strong class="source-inline">_integrate_forces</strong>, which allows you to directly access the physics state.</p>
			<p>And in the description <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">_integrate_forces()</strong></span><span class="No-Break">:</span></p>
			<p class="author-quote">(It) Allows you to read and safely modify the simulation state for the object. Use this instead of <strong class="source-inline">_physics_process</strong> if you need to directly change the body’s position or other physics properties.</p>
			<p>So, the <a id="_idIndexMarker155"/>answer is to use this separate function when you want to directly affect the rigid body’s position. Using <strong class="source-inline">_integrate_forces(</strong>) gives you access to the body’s <strong class="source-inline">PhysicsDirectBodyState2D</strong> – a Godot object containing a great deal of useful information about the current state of the body. Since you want to change the body’s location, that means you need to modify <span class="No-Break">its </span><span class="No-Break"><strong class="source-inline">Transform2D</strong></span><span class="No-Break">.</span></p>
			<p>A <strong class="bold">transform</strong> is a <a id="_idIndexMarker156"/>matrix representing one or more transformations in space, such as translation, rotation, and/or scaling. The translation (i.e., position) information is found by accessing the <strong class="source-inline">origin</strong> property of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Transform2D</strong></span><span class="No-Break">.</span></p>
			<p>Using this information, you can implement the wrap-around effect by adding the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
func _integrate_forces(physics_state):
    var xform = physics_state.transform
    xform.origin.x = wrapf(xform.origin.x, 0, screensize.x)
    xform.origin.y = wrapf(xform.origin.y, 0, screensize.y)
    physics_state.transform = xform</pre>
			<p>The <strong class="source-inline">wrapf()</strong> function takes a value (the first argument) and “wraps” it between any min/max values you choose. So, if the value goes below <strong class="source-inline">0</strong>, it becomes <strong class="source-inline">screensize.x</strong>, and <span class="No-Break">vice versa.</span></p>
			<p>Note that you’re using <strong class="source-inline">physics_state</strong> for the parameter name rather than the default of <strong class="source-inline">state</strong>. This is to avoid confusion since <strong class="source-inline">state</strong> is already being used to track the <span class="No-Break">player’s state.</span></p>
			<p>Run the scene again and check that everything is working as expected. Make sure you try wrapping around in all <span class="No-Break">four directions.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Shooting</h2>
			<p>Now it’s <a id="_idIndexMarker157"/>time to give your ship some weapons. When pressing the <strong class="source-inline">shoot</strong> action, a bullet/laser should be spawned at the front of the ship and then travel in a straight line until it exits the screen. The player isn’t allowed to shoot again<a id="_idIndexMarker158"/> until a small amount of time has passed (also known as <span class="No-Break">a </span><span class="No-Break"><strong class="bold">cooldown</strong></span><span class="No-Break">).</span></p>
			<h3>Bullet scene</h3>
			<p>This is<a id="_idIndexMarker159"/> the node setup for <span class="No-Break">the bullet:</span></p>
			<ul>
				<li><strong class="source-inline">Area2D</strong> <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Bullet</strong></span><ul><li><span class="No-Break"><strong class="source-inline">Sprite2D</strong></span></li><li><span class="No-Break"><strong class="source-inline">CollisionShape2D</strong></span></li><li><span class="No-Break"><strong class="source-inline">VisibleOnScreenNotifier2D</strong></span></li></ul></li>
			</ul>
			<p>Use <strong class="source-inline">res://assets/laser.png</strong> from the assets folder for the <strong class="bold">Texture</strong> property of the <strong class="source-inline">Sprite2D</strong> and a <strong class="source-inline">CapsuleShape2D</strong> for the collision shape. You’ll need to set <strong class="bold">Rotation</strong> of <strong class="source-inline">CollisionShape2D</strong> to <strong class="source-inline">90</strong> so that it is oriented correctly. You should also scale <strong class="source-inline">Sprite2D</strong> down to about half the size: <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">0.5, 0.5)</strong></span><span class="No-Break">.</span></p>
			<p>Add the following script to the <span class="No-Break"><strong class="source-inline">Bullet</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
extends Area2D
@export var speed = 1000
var velocity = Vector2.ZERO
func start(_transform):
    transform = _transform
    velocity = transform.x * speed
func _process(delta):
    position += velocity * delta</pre>
			<p>You’ll call the <strong class="source-inline">start()</strong> function whenever you spawn a new bullet. By passing it a transform, you can give it the correct position <em class="italic">and</em> rotation – typically that of the ship’s gun (more about <span class="No-Break">this later).</span></p>
			<p>The <strong class="source-inline">VisibleOnScreenNotifier2D</strong> is a node that informs you (via a signal) whenever a node becomes visible/invisible. You can use this to automatically delete a bullet <a id="_idIndexMarker160"/>that goes offscreen. Connect the node’s <strong class="source-inline">screen_exited</strong> signal and <span class="No-Break">add this:</span></p>
			<pre class="source-code">
func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free()</pre>
			<p>Finally, connect the bullet’s <strong class="source-inline">body_entered</strong> signal so that it can detect when it hits a rock. The bullet doesn’t need to know anything about rocks, just that it has hit something. When you create the rock, you’ll add it to a group called <strong class="source-inline">rocks</strong> and give it an <span class="No-Break"><strong class="source-inline">explode()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func _on_bullet_body_entered(body):
    if body.is_in_group("rocks"):
        body.explode()
        queue_free()</pre>
			<h3>Firing bullets</h3>
			<p>The next step <a id="_idIndexMarker161"/>is to create instances of the <strong class="source-inline">Bullet</strong> scene whenever the player presses the <strong class="source-inline">shoot</strong> action. However, if you make the bullet a child of the player, then it will move and rotate along with the player instead of moving independently. You could add the bullet to the main scene using <strong class="source-inline">get_parent().add_child()</strong>, since the <strong class="source-inline">Main</strong> scene will be the parent of the player when the game is running. However, this would mean that you could no longer run and test the <strong class="source-inline">Player</strong> scene by itself. Or, if you decided to rearrange your <strong class="source-inline">Main</strong> scene, making the player a child of some other node, the bullet wouldn’t be added where <span class="No-Break">you expect.</span></p>
			<p>In <a id="_idIndexMarker162"/>general, it is a bad idea to write code that assumes a fixed tree layout. Especially try to avoid situations where you use <strong class="source-inline">get_parent()</strong> if at all possible. You may find it difficult to think this way at first, but it will result in a much more modular design and prevent some <span class="No-Break">common mistakes.</span></p>
			<p>In any case, the <strong class="source-inline">SceneTree</strong> will always exist, and for this game, it will be fine to make the bullet a child of the tree’s root, which is the <strong class="source-inline">Window</strong> containing <span class="No-Break">the game.</span></p>
			<p>Add a <strong class="source-inline">Marker2D</strong> node to the player and name it <strong class="source-inline">Muzzle</strong>. This will mark the muzzle of the gun – the location where the bullet will spawn. Set <strong class="bold">Position</strong> to <strong class="source-inline">(50, 0)</strong> to place it directly in front of <span class="No-Break">the ship.</span></p>
			<p>Next, add a <strong class="source-inline">Timer</strong> node and name it <strong class="source-inline">GunCooldown</strong>. This will provide a cooldown to the gun, preventing a new bullet from firing until a certain amount of time has passed. Check the <strong class="bold">One Shot</strong> and <strong class="bold">Autostart</strong> boxes <span class="No-Break">to “on.”</span></p>
			<p>Add these new variables to the <span class="No-Break">player’s script:</span></p>
			<pre class="source-code">
@export var bullet_scene : PackedScene
@export var fire_rate = 0.25
var can_shoot = true</pre>
			<p>Drag the <strong class="source-inline">bullet.tscn</strong> file onto the new <strong class="bold">Bullet</strong> property in <span class="No-Break">the Inspector.</span></p>
			<p>Add this line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$GunCooldown.wait_time = fire_rate</pre>
			<p>And this <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">get_input()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if Input.is_action_pressed("shoot") and can_shoot:
    shoot()</pre>
			<p>Now create the <strong class="source-inline">shoot()</strong> function, which will handle creating <span class="No-Break">the bullet(s):</span></p>
			<pre class="source-code">
func shoot():
    if state == INVULNERABLE:
        return
    can_shoot = false
    $GunCooldown.start()
    var b = bullet_scene.instantiate()
    get_tree().root.add_child(b)
    b.start($Muzzle.global_transform)</pre>
			<p>When <a id="_idIndexMarker163"/>shooting, you first set <strong class="source-inline">can_shoot</strong> to <strong class="source-inline">false</strong> so that the action no longer calls <strong class="source-inline">shoot()</strong>. Then you add the new bullet as a child of whatever node is the root of the scene tree. Finally, you call the bullet’s <strong class="source-inline">start()</strong> function and give it the muzzle node’s <em class="italic">global</em> transform. Note that if you used <strong class="source-inline">transform</strong> here, you’d be giving it the muzzle’s position relative to the player (which is <strong class="source-inline">(50, 0)</strong>, remember?), and so the bullet would spawn in entirely the wrong place. This is another example of how important it is to understand the distinction between local and <span class="No-Break">global coordinates.</span></p>
			<p>To allow the gun to shoot again, connect the <strong class="source-inline">timeout</strong> signal <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">GunCooldown</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _on_gun_cooldown_timeout():
    can_shoot = true</pre>
			<h3>Testing the player’s ship</h3>
			<p>Create a <a id="_idIndexMarker164"/>new scene using a <strong class="source-inline">Node</strong> named <strong class="source-inline">Main</strong> and add a <strong class="source-inline">Sprite2D</strong> named <strong class="source-inline">Background</strong> as a child. Use <strong class="source-inline">res://assets/space_background.png</strong> in the <strong class="bold">Texture</strong> property. Add an instance of the <strong class="source-inline">Player</strong> to <span class="No-Break">the scene.</span></p>
			<p>Play the main scene and test that you can fly <span class="No-Break">and shoot.</span></p>
			<p>Now that your player’s ship works, it’s a good time to pause and check your understanding. Working with rigid bodies can be tricky; take a few minutes to experiment with some of the settings and code from this section. Just make sure to change them back before moving on to the next section, where you’ll add the asteroids to <span class="No-Break">the game.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Adding the rocks</h1>
			<p>The goal of <a id="_idIndexMarker165"/>the game is to destroy the floating space rocks, so now that you can shoot, it’s time to add them. Like the ship, the rocks will use <strong class="source-inline">RigidBody2D</strong>, which will make them travel in a straight line at a steady speed unless disturbed. They’ll also bounce off each other in a realistic fashion. To make things more interesting, rocks will start out large and, when you shoot them, break into multiple <span class="No-Break">smaller rocks.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Scene setup</h2>
			<p>Start a <a id="_idIndexMarker166"/>new scene with a <strong class="source-inline">RigidBody2D</strong> node named <strong class="source-inline">Rock</strong>, and add a <strong class="source-inline">Sprite2D</strong> child using the <strong class="source-inline">res://assets/rock.png</strong> texture. Add a <strong class="source-inline">CollisionShape2D</strong>, but <em class="italic">don’t</em> set its shape yet. Because you’ll be spawning different-sized rocks, the collision shape will need to be set in code and adjusted to the <span class="No-Break">correct size.</span></p>
			<p>You don’t want the rocks coasting to a stop, so they need to ignore the default linear and angular damping. Set both <strong class="bold">Linear/Damp</strong> and <strong class="bold">Angular/Damp</strong> to <strong class="source-inline">0</strong> and <strong class="bold">Damp Mode</strong> for both to <em class="italic">Replace</em>. The rocks also need to bounce off each other. You can do that in the <strong class="bold">Physics Material</strong> property. Select <strong class="source-inline">New PhysicsMaterial</strong> and then click on it to expand. Set the displayed <strong class="bold">Bounce</strong> property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Variable size rocks</h2>
			<p>Attach a <a id="_idIndexMarker167"/>script to <strong class="source-inline">Rock</strong> and define the <span class="No-Break">member variables:</span></p>
			<pre class="source-code">
extends RigidBody2D
var screensize = Vector2.ZERO
var size
var radius
var scale_factor = 0.2</pre>
			<p>The <strong class="source-inline">Main</strong> script will handle spawning new rocks, both at the beginning of a level as well as the smaller rocks that will appear after a large one explodes. A large rock will have a size of <strong class="source-inline">3</strong>, break into rocks of size <strong class="source-inline">2</strong>, and so on. The <strong class="source-inline">scale_factor</strong> is multiplied by <strong class="source-inline">size</strong> to set the <strong class="source-inline">Sprite2D</strong> scale, the collision radius, and so on. You can adjust this later to change how big each category of <span class="No-Break">rock is.</span></p>
			<p>All of this <a id="_idIndexMarker168"/>will be set by the <span class="No-Break"><strong class="source-inline">start()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func start(_position, _velocity, _size):
    position = _position
    size = _size
    mass = 1.5 * size
    $Sprite2D.scale = Vector2.ONE * scale_factor * size
    radius = int($Sprite2D.texture.get_size().x / 2 *
        $Sprite2D.scale.x)
    var shape = CircleShape2D.new()
    shape.radius = radius
    $CollisionShape2d.shape = shape
    linear_velocity = _velocity
    angular_velocity = randf_range(-PI, PI)</pre>
			<p>This is where you calculate the correct collision size based on the rock’s <strong class="source-inline">size</strong>. Note that since <strong class="source-inline">position</strong> and <strong class="source-inline">size</strong> are already in use as class variables, you can use an underscore for the function’s arguments to <span class="No-Break">prevent conflict.</span></p>
			<p>The rocks also need to wrap around the screen like the player, so use the same technique with <span class="No-Break"><strong class="source-inline">_integrate_forces()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _integrate_forces(physics_state):
    var xform = physics_state.transform
    xform.origin.x = wrapf(xform.origin.x, 0 - radius,
        screensize.x + radius)
    xform.origin.y = wrapf(xform.origin.y, 0 - radius,
        screensize.y + radius)
    physics_state.transform = xform</pre>
			<p>The one <a id="_idIndexMarker169"/>difference here is that including the rock’s <strong class="source-inline">radius</strong> in the calculation results in smoother-looking teleportation. The rock will appear to fully exit the screen before entering the opposite side. You may want to do the same thing with the player’s ship. Try it and see which you <span class="No-Break">like better.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Instantiating rocks</h2>
			<p>When <a id="_idIndexMarker170"/>new rocks are spawned, the main scene will need to pick a random starting location. To do this, you could use some math to pick a random point along the perimeter of the screen, but instead, you can take advantage of another Godot node type. You’ll draw a path around the edge of the screen, and the script will pick a random location along <span class="No-Break">that path.</span></p>
			<p>In the <strong class="source-inline">Main</strong> scene, add a <strong class="source-inline">Path2D</strong> node and name it <strong class="source-inline">RockPath</strong>. When you select the node, you will see some new buttons appear at the top of the <span class="No-Break">editor window:</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B19289_03_09.jpg" alt="Figure 3.9: Path drawing tools"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Path drawing tools</p>
			<p>Select the middle one (<strong class="bold">Add Point</strong>) to draw the path by clicking the points shown in the following screenshot. To make the points align, make sure <strong class="bold">Use Grid Snap</strong> is checked. This option is found in the icon bar at the top of the <span class="No-Break">editor window:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B19289_03_10.jpg" alt="Figure 3.10: Enabling grid snapping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: Enabling grid snapping</p>
			<p>Draw the points in the order shown in the following screenshot. After clicking the fourth point, click <a id="_idIndexMarker171"/>the <strong class="bold">Close Curve</strong> button (marked <em class="italic">5</em> in the screenshot) and your path will <span class="No-Break">be complete:</span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B19289_03_11.jpg" alt="Figure 3.11: Path drawing order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: Path drawing order</p>
			<p>Don’t click in the editor window again if you have <strong class="source-inline">RockPath</strong> selected! If you do, you’ll add additional points to the curve, and your rocks may not spawn where you want them to. You can press <em class="italic">Ctrl</em> + <em class="italic">Z</em> to undo any extra points you may <span class="No-Break">have added.</span></p>
			<p>Now that the path is defined, add a <strong class="source-inline">PathFollow2D</strong> as a child of <strong class="source-inline">RockPath</strong> and name it <strong class="source-inline">RockSpawn</strong>. This node’s purpose is to automatically move along its parent path using its <strong class="bold">Progress</strong> property, which represents an offset along the path. The higher the offset, the further along the path it goes. Since our path is closed, it will also loop if the offset value is bigger than the <span class="No-Break">path’s length.</span></p>
			<p>Add the following script <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Main.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
extends Node
@export var rock_scene : PackedScene
var screensize = Vector2.ZERO
func _ready():
    screensize = get_viewport().get_visible_rect().size
    for i in 3:
        spawn_rock(3)</pre>
			<p>You start by <a id="_idIndexMarker172"/>getting the <strong class="source-inline">screensize</strong> so that you can pass it to the rocks when they’re spawned. Then, you spawn three rocks of size <strong class="source-inline">3</strong>. Don’t forget to drag <strong class="source-inline">rock.tscn</strong> onto the <span class="No-Break"><strong class="bold">Rock</strong></span><span class="No-Break"> property.</span></p>
			<p>Here is the <span class="No-Break"><strong class="source-inline">spawn_rock()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func spawn_rock(size, pos=null, vel=null):
    if pos == null:
        $RockPath/RockSpawn.progress = randi()
        pos = $RockPath/RockSpawn.position
    if vel == null:
        vel = Vector2.RIGHT.rotated(randf_range(0, TAU)) *
            randf_range(50, 125)
    var r = rock_scene.instantiate()
    r.screensize = screensize
    r.start(pos, vel, size)
    call_deferred("add_child", r)</pre>
			<p>This function serves two purposes. When called with only a <strong class="source-inline">size</strong> parameter, it picks a random position along the <strong class="source-inline">RockPath</strong> and a random velocity. However, if those values are provided, it will use them instead. This will let you spawn the smaller rocks at the location of the explosion by specifying <span class="No-Break">their properties.</span></p>
			<p>Run the game and you should see three rocks floating around, but your bullets don’t <span class="No-Break">affect them.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Exploding rocks</h2>
			<p>The <a id="_idIndexMarker173"/>bullet checks for bodies in the <strong class="source-inline">rocks</strong> group, so in the <strong class="source-inline">Rock</strong> scene, select the <strong class="bold">Node</strong> tab and choose <strong class="bold">Groups</strong>. Type <strong class="source-inline">rocks</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B19289_03_12.jpg" alt="Figure 3.12: Adding a “rocks” group"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12: Adding a “rocks” group</p>
			<p>Now, if you run the game and shoot a rock, you’ll see an error message because the bullet is trying to call the rock’s <strong class="source-inline">explode()</strong> method, which you haven’t defined yet. This method needs to do <span class="No-Break">three things:</span></p>
			<ul>
				<li>Remove <span class="No-Break">the rock</span></li>
				<li>Play an <span class="No-Break">explosion animation</span></li>
				<li>Notify <strong class="source-inline">Main</strong> to spawn new, <span class="No-Break">smaller rocks</span></li>
			</ul>
			<h3>Explosion scene</h3>
			<p>The explosion <a id="_idIndexMarker174"/>will be a separate scene, which you can add to the <strong class="source-inline">Rock</strong> and later to the <strong class="source-inline">Player</strong>. It will contain <span class="No-Break">two nodes:</span></p>
			<ul>
				<li><strong class="source-inline">Sprite2D</strong> <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Explosion</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">AnimationPlayer</strong></span></li>
			</ul>
			<p>For the <strong class="source-inline">Sprite2D</strong> node’s <strong class="bold">Texture</strong> property, use <strong class="source-inline">res://assets/explosion.png</strong>. You’ll notice <a id="_idIndexMarker175"/>this is a <strong class="bold">sprite sheet</strong> – an image made up of 64 smaller images laid out in a grid pattern. These images are the individual frames of the animation. You’ll often find animations packaged this way, and Godot’s <strong class="source-inline">Sprite2D</strong> node supports <span class="No-Break">using them.</span></p>
			<p>In the Inspector, find the sprite’s <strong class="bold">Animation</strong> section. Set <strong class="bold">Vframes</strong> and <strong class="bold">Hframes</strong> both to <strong class="source-inline">8</strong>. This<a id="_idIndexMarker176"/> will slice the sprite sheet into its 64 individual images. You can verify this by changing the <strong class="bold">Frame</strong> property to different values between <strong class="source-inline">0</strong> and <strong class="source-inline">63</strong>. Make sure to set it back to <strong class="source-inline">0</strong> before <span class="No-Break">you continue.</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B19289_03_13.jpg" alt="Figure 3.13: Sprite Animation settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13: Sprite Animation settings</p>
			<p>The <strong class="source-inline">AnimationPlayer</strong> node can be used to animate any property of any node. You’ll use it to change the <strong class="bold">Frame</strong> property over time. Start by selecting the node and you’ll see the <strong class="bold">Animation</strong> panel open at <span class="No-Break">the bottom:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B19289_03_14.jpg" alt="Figure 3.14: Animation panel"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14: Animation panel</p>
			<p>Click the <strong class="bold">Animation</strong> button and choose <strong class="bold">New</strong>. Name the animation <strong class="source-inline">explosion</strong>. Set <strong class="bold">Animation Length</strong> to <strong class="source-inline">0.64</strong> and <strong class="bold">Snap</strong> to <strong class="source-inline">0.01</strong>. Select the <strong class="source-inline">Sprite2D</strong> node and you’ll notice that each property in the Inspector now has a key symbol next to it. Clicking on a key will create a <em class="italic">keyframe</em> in the <span class="No-Break">current animation.</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B19289_03_15.jpg" alt="Figure 3.15: Animation time settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15: Animation time settings</p>
			<p>Click the <a id="_idIndexMarker177"/>key next to the <strong class="source-inline">Explosion</strong> node’s <strong class="bold">Frame</strong> property and confirm that you want to create a new animation track. Deselect <strong class="bold">Create RESET Track(s)</strong>. You’ve now created a keyframe telling the <strong class="source-inline">AnimationPlayer</strong> that at time <strong class="source-inline">0</strong>, you want the sprite’s <strong class="bold">Frame</strong> to <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<p>Slide the scrubber to time <strong class="source-inline">0.64</strong> (you can adjust the zoom using the slider if you can’t see it). Set <strong class="bold">Frame</strong> to <strong class="source-inline">63</strong> and click the key again. Now the animation knows to use the last image at the animation’s final time. However, you also need to let the <strong class="source-inline">AnimationPlayer</strong> know that you want to use all the intermediate values in the times between those two points. At the right side of the animation track is an <strong class="bold">Update Mode</strong> dropdown. It’s currently set to <strong class="bold">Discrete</strong>, and you need to change it <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Continuous</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B19289_03_16.jpg" alt="Figure 3.16: Setting Update Mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16: Setting Update Mode</p>
			<p>Click the <strong class="bold">Play</strong> button in the <strong class="bold">Animation</strong> panel to see <span class="No-Break">the animation.</span></p>
			<p>You can now add the explosion to the rock. In the <strong class="source-inline">Rock</strong> scene, add an instance of <strong class="source-inline">Explosion</strong> and click the eye icon next to the node to make it hidden. Add this line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">start()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$Explosion.scale = Vector2.ONE * 0.75 * size</pre>
			<p>This will <a id="_idIndexMarker178"/>ensure the explosion is scaled to match the <span class="No-Break">rock’s size.</span></p>
			<p>Add a signal called <strong class="source-inline">exploded</strong> at the top of the script, then add the <strong class="source-inline">explode()</strong> function, which will be called when the bullet hits <span class="No-Break">the rock:</span></p>
			<pre class="source-code">
func explode():
    $CollisionShape2D.set_deferred("disabled", true)
    $Sprite2d.hide()
    $Explosion/AnimationPlayer.play("explosion")
    $Explosion.show()
    exploded.emit(size, radius, position, linear_velocity)
    linear_velocity = Vector2.ZERO
    angular_velocity = 0
    await $Explosion/AnimationPlayer.animation_finished
    queue_free()</pre>
			<p>Here, you hide the rock and play the explosion, waiting for it to finish before removing the rock. When you emit the <strong class="source-inline">exploded</strong> signal, you also include all the rock’s information, so that <strong class="source-inline">spawn_rock()</strong> in <strong class="source-inline">Main</strong> will be able to spawn the smaller rocks at the <span class="No-Break">same location.</span></p>
			<p>Test the game and check that you can see explosions when you shoot <span class="No-Break">the rocks.</span></p>
			<h3>Spawning smaller rocks</h3>
			<p>The <strong class="source-inline">Rock</strong> scene is <a id="_idIndexMarker179"/>emitting the signal, but <strong class="source-inline">Main</strong> isn’t listening for it yet. You can’t connect the signal in the <strong class="bold">Node</strong> tab because the rocks are being instanced in the code. They won’t exist until later, when the game is running. Add this line to the end <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">spawn_rock()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
r.exploded.connect(self._on_rock_exploded)</pre>
			<p>This <a id="_idIndexMarker180"/>connects the rock’s signal to a function in <strong class="source-inline">Main</strong>, which you also need <span class="No-Break">to create:</span></p>
			<pre class="source-code">
func _on_rock_exploded(size, radius, pos, vel):
    if size &lt;= 1:
        return
    for offset in [-1, 1]:
        var dir = $Player.position.direction_to(pos)
            .orthogonal() * offset
        var newpos = pos + dir * radius
        var newvel = dir * vel.length() * 1.1
        spawn_rock(size - 1, newpos, newvel)</pre>
			<p>In this function, you create two new rocks unless the rock that was just destroyed was of size <strong class="source-inline">1</strong> (the smallest size). The <strong class="source-inline">offset</strong> loop variable ensures that the two new rocks travel in opposite directions (that is, one’s velocity will be negative). The <strong class="source-inline">dir</strong> variable finds the vector between the player and the rock, then uses <strong class="source-inline">orthogonal()</strong> to get a vector that’s perpendicular. This ensures that the new rocks don’t fly straight toward <span class="No-Break">the player.</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B19289_03_17.jpg" alt="Figure 3.17: Explosion diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17: Explosion diagram</p>
			<p>Play the game once again and check that everything is working <span class="No-Break">as expected.</span></p>
			<p>This is a <a id="_idIndexMarker181"/>good place to stop and review what you’ve done so far. You’ve completed all the basic functionality of the game: the player can fly around and shoot; the rocks float, bounce, and explode; and new rocks are spawned. You should be feeling more comfortable using rigid bodies at this point. In the next section, you’ll start building the interface to allow the player to start the game and see important information <span class="No-Break">during gameplay.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Creating the UI</h1>
			<p>Creating a UI<a id="_idIndexMarker182"/> for your game can be very complex, or at least time-consuming. Precisely placing individual elements and ensuring<a id="_idIndexMarker183"/> they work across different-sized screens and devices is the least interesting part of game development for many programmers. Godot provides a wide variety of <strong class="source-inline">Control</strong> nodes to assist in this process. Learning how to use the various <strong class="source-inline">Control</strong> nodes will help lessen the pain of creating a <span class="No-Break">polished UI.</span></p>
			<p>For this game, you don’t need a very complex UI. The game needs to provide the following information <span class="No-Break">and interactions:</span></p>
			<ul>
				<li><span class="No-Break">Start button</span></li>
				<li>Status message (such as “Get Ready” or “<span class="No-Break">Game Over”)</span></li>
				<li><span class="No-Break">Score</span></li>
				<li><span class="No-Break">Lives counter</span></li>
			</ul>
			<p>Here is a <a id="_idIndexMarker184"/>preview of what you <span class="No-Break">will make:</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B19289_03_18.jpg" alt="Figure 3.18: UI layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18: UI layout</p>
			<p>Create a new <a id="_idIndexMarker185"/>scene and add a <strong class="source-inline">CanvasLayer</strong> node with the name <strong class="source-inline">HUD</strong> as the root node. You’ll build the UI on this layer using the <strong class="source-inline">Control</strong> node’s <span class="No-Break">layout features.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Layout</h2>
			<p>Godot’s <strong class="source-inline">Control</strong> nodes include<a id="_idIndexMarker186"/> a number of specialized containers. These nodes can be nested inside each other to create the exact layout you need. For example, a <strong class="source-inline">MarginContainer</strong> automatically adds padding around its contents, while <strong class="source-inline">HBoxContainer</strong> and <strong class="source-inline">VBoxContainer</strong> organize their contents in rows or <span class="No-Break">columns, respectively.</span></p>
			<p>Follow these steps to build <span class="No-Break">the layout:</span></p>
			<ol>
				<li>Start by adding <strong class="source-inline">Timer</strong> and <strong class="source-inline">MarginContainer children</strong>, which will hold the score and life counters. In the <strong class="bold">Layout</strong> dropdown, select <span class="No-Break"><strong class="bold">Top Wide</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B19289_03_19.jpg" alt="Figure 3.19: Top Wide control alignment"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19: Top Wide control alignment</p>
			<ol>
				<li value="2">In the Inspector, set the four margins in <strong class="bold">Theme Overrides/Constants</strong> <span class="No-Break">to 20.</span></li>
				<li>Set <a id="_idIndexMarker187"/>the <strong class="bold">One Shot</strong> property of <strong class="source-inline">Timer</strong> to on and its <strong class="bold">Wait Time</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></li>
				<li>As a child of the container, add an <strong class="source-inline">HBoxContainer</strong>, which will position the score counter on the left and the lives counter on the right. Under this container, add a <strong class="source-inline">Label</strong> (name it <strong class="source-inline">ScoreLabel</strong>) and another <strong class="source-inline">HBoxContainer</strong> (<span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">LivesCounter</strong></span><span class="No-Break">).</span></li>
			</ol>
			<p>Set the <strong class="source-inline">ScoreLabel's</strong> <strong class="bold">Text</strong> to <strong class="source-inline">0</strong>, and under <strong class="bold">Layout/Container Sizing/Horizontal</strong>, check the <strong class="bold">Expand</strong> box. In <strong class="bold">Label Settings</strong>, add a font as you did in <a href="B19289_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, using <strong class="source-inline">res://assets/kenvector_future_thin.ttf</strong> and setting the font size <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">64</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Select <strong class="source-inline">LivesCounter</strong> and set <strong class="bold">Theme Overrides/Constants/Separation</strong> to <strong class="source-inline">20</strong>, then add a child <strong class="source-inline">TextureRect</strong> and name it <strong class="source-inline">L1</strong>. Drag <strong class="source-inline">res://assets/player_small.png</strong> to the <strong class="bold">Texture</strong> property and set <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep Aspect Centered</strong>. Make sure you have the <strong class="source-inline">L1</strong> node selected and press <em class="italic">duplicate</em> (<em class="italic">Ctrl</em> + <em class="italic">D</em>) twice to create <strong class="source-inline">L2</strong> and <strong class="source-inline">L3</strong> (they’ll be named automatically). During the game, the <strong class="source-inline">HUD</strong> will show or hide these three textures to indicate how many lives the player <span class="No-Break">has left.</span></li>
				<li>In a larger, more complex UI, you might save this section as its own scene and embed it in other section(s) of the UI. However, this game only needs a few more elements, so it’s fine to combine them all in <span class="No-Break">one scene.</span></li>
				<li>As a child of <strong class="source-inline">HUD</strong>, add a <strong class="source-inline">VBoxContainer</strong>, and inside it, add a <strong class="source-inline">Label</strong> named <strong class="source-inline">Message</strong> and a <strong class="source-inline">TextureButton</strong> named <strong class="source-inline">StartButton</strong>. Set the layout of the <strong class="source-inline">VBoxContainer</strong> to <strong class="bold">Center Wide</strong> and <strong class="bold">Theme Overrides/ Constants/ Separation</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">100</strong></span><span class="No-Break">.</span></li>
				<li>In<a id="_idIndexMarker188"/> the <strong class="source-inline">res://assets</strong> folder, there are two textures for <strong class="source-inline">StartButton</strong>, one normal (<strong class="source-inline">play_button.png</strong>) and one to show when the mouse is hovering over it (<strong class="source-inline">'play_button_h.png</strong>). Drag these to <strong class="bold">Textures/Normal</strong> and <strong class="bold">Textures/Hover</strong> in the Inspector. Set the button’s <strong class="bold">Layout/Container Sizing/Horizontal</strong> to <strong class="bold">Shrink Center</strong> so that it will be <span class="No-Break">centered horizontally.</span></li>
				<li>Set the <strong class="source-inline">Message</strong> text to “Space Rocks!” and set its font using the same settings as <strong class="source-inline">ScoreLabel</strong>. Set <strong class="bold">Horizontal Alignment</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Center</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>When finished, your scene tree should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B19289_03_20.jpg" alt="Figure 3.20: HUD node layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20: HUD node layout</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Scripting the UI</h2>
			<p>You’ve <a id="_idIndexMarker189"/>completed the UI layout, now add a script to <strong class="source-inline">HUD</strong>. Since the nodes you’ll need to reference are located under containers, you can store references to them in variables at the start. Since this needs to happen after nodes are added to the tree, you can use the <strong class="source-inline">@onready</strong> decorator to cause the variable’s value to be set at the same time as the <strong class="source-inline">_ready()</strong> <span class="No-Break">function runs.</span></p>
			<pre class="source-code">
extends CanvasLayer
signal start_game
@onready var lives_counter = $MarginContainer/HBoxContainer/LivesCounter.get_children()
@onready var score_label = $MarginContainer/HBoxContainer/ScoreLabel
@onready var message = $VBoxContainer/Message
@onready var start_button = $VBoxContainer/StartButton</pre>
			<p>You’ll <a id="_idIndexMarker190"/>emit the <strong class="source-inline">start_game</strong> signal when the player clicks the <strong class="source-inline">StartButton</strong>. The <strong class="source-inline">lives_counter</strong> variable is an array holding references to the three life-counter images so they can be hidden/shown <span class="No-Break">as needed.</span></p>
			<p>Next, you need functions to handle updating the <span class="No-Break">displayed information:</span></p>
			<pre class="source-code">
func show_message(text):
    message.text = text
    message.show()
    $Timer.start()
func update_score(value):
    score_label.text = str(value)
func update_lives(value):
    for item in 3:
        lives_counter[item].visible = value &gt; item</pre>
			<p><strong class="source-inline">Main</strong> will call these functions whenever the relevant value changes. Now add a function to handle the end of <span class="No-Break">the game:</span></p>
			<pre class="source-code">
func game_over():
    show_message("Game Over")
    await $Timer.timeout
    start_button.show()</pre>
			<p>Connect the <strong class="source-inline">pressed</strong> signal of <strong class="source-inline">StartButton</strong> and the <strong class="source-inline">timeout</strong> signal <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Timer</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _on_start_button_pressed():
    start_button.hide()
    start_game.emit()
func _on_timer_timeout():
    message.hide()
    message.text = ""</pre>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>The Main scene’s UI code</h2>
			<p>Add an <a id="_idIndexMarker191"/>instance of the <strong class="source-inline">HUD</strong> scene to the <strong class="source-inline">Main</strong> scene. Add these variables <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">main.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var level = 0
var score = 0
var playing = false</pre>
			<p>And a function to handle starting a <span class="No-Break">new game:</span></p>
			<pre class="source-code">
func new_game():
    # remove any old rocks from previous game
    get_tree().call_group("rocks", "queue_free")
    level = 0
    score = 0
    $HUD.update_score(score)
    $HUD.show_message("Get Ready!")
    $Player.reset()
    await $HUD/Timer.timeout
    playing = true</pre>
			<p>Note the <strong class="source-inline">$Player.reset()</strong> line – don’t worry, you’ll add <span class="No-Break">that soon.</span></p>
			<p>When the player destroys all the rocks, they’ll advance to the <span class="No-Break">next level:</span></p>
			<pre class="source-code">
func new_level():
    level += 1
    $HUD.show_message("Wave %s" % level)
    for i in level:
        spawn_rock(3)</pre>
			<p>You’ll call this<a id="_idIndexMarker192"/> function every time the level changes. It announces the level number and spawns a number of rocks to match. Note that since you initialized <strong class="source-inline">level</strong> to <strong class="source-inline">0</strong>, this will set it to <strong class="source-inline">1</strong> for the first level. You should also remove the code that’s spawning rocks in <strong class="source-inline">_ready()</strong> – you don’t need <span class="No-Break">that anymore.</span></p>
			<p>To detect when the level has ended, you need to check how many rocks <span class="No-Break">are left:</span></p>
			<pre class="source-code">
func _process(delta):
    if not playing:
        return
    if get_tree().get_nodes_in_group("rocks").size() == 0:
        new_level()</pre>
			<p>Next, you need to connect the <strong class="source-inline">HUD</strong>’s <strong class="source-inline">start_game</strong> signal to the <strong class="source-inline">new_game()</strong> function <span class="No-Break">of Main.</span></p>
			<p>Select the <strong class="source-inline">HUD</strong> instance in <strong class="source-inline">Main</strong> and find its <strong class="source-inline">start_game</strong> signal in the <strong class="bold">Node</strong> tab. Click <strong class="bold">Connect</strong>, but in the popup, click the <strong class="bold">Pick</strong> button next to <strong class="bold">Receiver Method</strong>. You’ll see a list of the functions in <strong class="source-inline">Main</strong>, and you can select the <span class="No-Break"><strong class="source-inline">new_game()</strong></span><span class="No-Break"> function:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B19289_03_21.jpg" alt="Figure 3.21: Connecting a signal to an existing function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21: Connecting a signal to an existing function</p>
			<p>Add this <a id="_idIndexMarker193"/>function to handle what happens when the <span class="No-Break">game ends:</span></p>
			<pre class="source-code">
func game_over():
    playing = false
    $HUD.game_over()</pre>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Player code</h2>
			<p>Add <a id="_idIndexMarker194"/>the new signals and a new variable <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">player.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
signal lives_changed
signal dead
var reset_pos = false
var lives = 0: set = set_lives
func set_lives(value):
    lives = value
    lives_changed.emit(lives)
    if lives &lt;= 0:
        change_state(DEAD)
    else:
        change_state(INVULNERABLE)</pre>
			<p>For <a id="_idIndexMarker195"/>the <strong class="source-inline">lives</strong> variable, you’ve added something called<a id="_idIndexMarker196"/> a <strong class="bold">setter</strong>. This means that whenever the value of <strong class="source-inline">lives</strong> changes, the <strong class="source-inline">set_lives()</strong> function will be called. This lets you automatically emit the signal as well as checking when it <span class="No-Break">reaches </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">reset()</strong> function is called by <strong class="source-inline">Main</strong> when a new <span class="No-Break">game starts:</span></p>
			<pre class="source-code">
func reset():
    reset_pos = true
    $Sprite2d.show()
    lives = 3
    change_state(ALIVE)</pre>
			<p>Resetting the player means setting its position back to the center of the screen. As we saw before, that needs to be done in <strong class="source-inline">_integrate_forces()</strong> in order to work. Add this to <span class="No-Break">that function:</span></p>
			<pre class="source-code">
if reset_pos:
    physics_state.transform.origin = screensize / 2
    reset_pos = false</pre>
			<p>Back in the <strong class="source-inline">Main</strong> scene, select the <strong class="source-inline">Player</strong> instance and find its <strong class="source-inline">lives_changed</strong> signal in the <strong class="bold">Node</strong> tab. Click <strong class="bold">Connect</strong>, and under <strong class="bold">Connect to Script</strong>, choose the <strong class="source-inline">HUD</strong> node and type <strong class="source-inline">update_lives</strong> in <span class="No-Break"><strong class="bold">Receiver Method</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B19289_03_22.jpg" alt="Figure 3.22: Connecting the player signal to HUD"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22: Connecting the player signal to HUD</p>
			<p>In this<a id="_idIndexMarker197"/> section, you made a much more complex UI than in previous projects, including some new <strong class="source-inline">Control</strong> nodes such as <strong class="source-inline">TextureProgressBar</strong>, and used signals to connect everything together. In the next section, you’ll handle the end of the game: what should happen when the <span class="No-Break">player dies.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Ending the game</h1>
			<p>In this <a id="_idIndexMarker198"/>section, you’ll make the player detect when it is hit by rocks, add an invulnerability feature, and end the game when the player runs out <span class="No-Break">of lives.</span></p>
			<p>Add an instance of the <strong class="source-inline">Explosion</strong> scene to the <strong class="source-inline">Player</strong> scene and uncheck its <strong class="bold">Visibility</strong> property. Also add a <strong class="source-inline">Timer</strong> node named <strong class="source-inline">InvulnerabilityTimer</strong> and set <strong class="bold">Wait Time</strong> to <strong class="source-inline">2</strong> and <strong class="bold">One Shot</strong> <span class="No-Break">to “on.”</span></p>
			<p>You’ll emit the <strong class="source-inline">dead</strong> signal to notify <strong class="source-inline">Main</strong> that the game should end. Before that, however, you<a id="_idIndexMarker199"/> need to update the state machine to do a little more with <span class="No-Break">each state:</span></p>
			<pre class="source-code">
func change_state(new_state):
    match new_state:
        INIT:
            $CollisionShape2D.set_deferred("disabled",
                true)
            $Sprite2D.modulate.a = 0.5
        ALIVE:
            $CollisionShape2d.set_deferred("disabled",
                false)
            $Sprite2d.modulate.a = 1.0
        INVULNERABLE:
            $CollisionShape2d.set_deferred("disabled",
                true)
            $Sprite2d.modulate.a = 0.5
            $InvulnerabilityTimer.start()
        DEAD:
            $CollisionShape2d.set_deferred("disabled",
                true)
            $Sprite2d.hide()
            linear_velocity = Vector2.ZERO
            dead.emit()
    state = new_state</pre>
			<p>The <strong class="source-inline">modulate.a</strong> property of a sprite sets its alpha channel (transparency). Setting it to <strong class="source-inline">0.5</strong> makes <a id="_idIndexMarker200"/>it semi-transparent, while <strong class="source-inline">1.0</strong> <span class="No-Break">is solid.</span></p>
			<p>After entering the <strong class="source-inline">INVULNERABLE</strong> state, you start the timer. Connect its <span class="No-Break"><strong class="source-inline">timeout</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_invulnerability_timer_timeout():
    change_state(ALIVE)</pre>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Detecting collisions between rigid bodies</h2>
			<p>When you<a id="_idIndexMarker201"/> fly around, the ship bounces off rocks because both are rigid bodies. However, if you want to make something happen when two rigid bodies collide, you need to enable <strong class="bold">contact monitoring</strong>. In <a id="_idIndexMarker202"/>the <strong class="source-inline">Player</strong> scene, select the <strong class="source-inline">Player</strong> node, and in the Inspector, set <strong class="bold">Contact Monitor</strong> to on. By default, no contacts are reported, so set <strong class="bold">Max Contacts Reported</strong> to <strong class="source-inline">1</strong>. Now the player will emit a signal when it comes into contact with another body. Click on the <strong class="bold">Node</strong> tab and connect the <span class="No-Break"><strong class="source-inline">body_entered</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        body.explode()
        lives -= 1
        explode()
func explode():
    $Explosion.show()
    $Explosion/AnimationPlayer.play("explosion")
    await $Explosion/AnimationPlayer.animation_finished
    $Explosion.hide()</pre>
			<p>Now go to the <strong class="source-inline">Main</strong> scene and connect the <strong class="source-inline">Player</strong> instance’s <strong class="source-inline">dead</strong> signal to the <strong class="source-inline">game_over()</strong> method. Play the game and try running into a rock. Your ship should explode, become invulnerable for two seconds, and lose one life. Also check that the game ends if you get hit <span class="No-Break">three times.</span></p>
			<p>In this <a id="_idIndexMarker203"/>section, you learned about rigid body collisions and used them to handle the ship colliding with rocks. The full game cycle is now complete: the start screen leads to gameplay, which ends with a game over display. In the remaining sections of the chapter, you’ll add some additional features to the game, such as a <span class="No-Break">pause function.</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Pausing the game</h1>
			<p>Many<a id="_idIndexMarker204"/> games require some sort of pause mode to allow the player to take a break from the action. In Godot, pausing is a function of the <strong class="source-inline">SceneTree</strong> and can be set using its <strong class="source-inline">paused</strong> property. When the <strong class="source-inline">SceneTree</strong> is paused, three <span class="No-Break">things happen:</span></p>
			<ul>
				<li> The physics thread <span class="No-Break">stops running</span></li>
				<li> <strong class="source-inline">_process()</strong> and <strong class="source-inline">_physics_process()</strong> are no longer called on <span class="No-Break">any nodes</span></li>
				<li> The <strong class="source-inline">_input()</strong> and <strong class="source-inline">_input_event()</strong> methods are also not called <span class="No-Break">for inputs</span></li>
			</ul>
			<p>When pause mode is triggered, every node in the running game reacts accordingly, based on how you’ve configured it. This behavior is set via the node’s <strong class="bold">Process/Mode</strong> property, which you’ll find near the bottom of the <span class="No-Break">Inspector list.</span></p>
			<p>The pause mode can be set to the <span class="No-Break">following values:</span></p>
			<ul>
				<li><strong class="source-inline">Inherit</strong> – The node uses the same mode as <span class="No-Break">its parent</span></li>
				<li><strong class="source-inline">Pausable</strong> – The node pauses when the scene tree <span class="No-Break">is paused</span></li>
				<li><strong class="source-inline">When Paused</strong> – The node only runs when the tree <span class="No-Break">is paused</span></li>
				<li><strong class="source-inline">Always</strong> – The node always runs, ignoring the tree’s <span class="No-Break">paused state</span></li>
				<li><strong class="source-inline">Disabled</strong> – The node never runs, ignoring the tree’s <span class="No-Break">paused state</span></li>
			</ul>
			<p>Open the <strong class="bold">Input Map</strong> tab and create a new input action called <strong class="source-inline">pause</strong>. Assign a key you’d like to use to toggle pause mode. <strong class="source-inline">P</strong> is a <span class="No-Break">good choice.</span></p>
			<p>Add the<a id="_idIndexMarker205"/> following function <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Main.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _input(event):
    if event.is_action_pressed("pause"):
        if not playing:
            return
        get_tree().paused = not get_tree().paused
        var message = $HUD/VBoxContainer/Message
        if get_tree().paused:
            message.text = "Paused"
            message.show()
        else:
            message.text = ""
            message.hide()</pre>
			<p>This code detects pressing the key and toggles the tree’s <strong class="source-inline">paused</strong> state to the opposite of its current state. It also displays <strong class="bold">Paused</strong> on the screen so that it doesn’t just appear that the game <span class="No-Break">has frozen.</span></p>
			<p>If you were to run the game now, you’d have a problem – all nodes are paused, including <strong class="source-inline">Main</strong>. That means it’s not processing <strong class="source-inline">_input()</strong> anymore, so it can’t detect the input again to unpause the game! To fix this, set <strong class="bold">Process/Mode</strong> of the <strong class="source-inline">Main</strong> node <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Always</strong></span><span class="No-Break">.</span></p>
			<p>The pause function is a very useful one to know about. You can use this technique in any game you make, so review it to make sure you understand how it works. You can even try going back and adding it to <em class="italic">Coin Dash</em>. Our next section adds to the action by adding enemies to <span class="No-Break">the game.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Enemies</h1>
			<p>Space is <a id="_idIndexMarker206"/>filled with more dangers than just rocks. In this section, you’ll create an enemy spaceship that will periodically appear and shoot at <span class="No-Break">the player.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Following a path</h2>
			<p>When the <a id="_idIndexMarker207"/>enemy appears, it should follow a path across the screen. It’ll also look better if it’s not just a straight line. To keep it from looking too repetitive, you can create multiple paths and randomly choose one when the <span class="No-Break">enemy appears.</span></p>
			<p>Create a new scene and add a <strong class="source-inline">Node</strong>. Name it <strong class="source-inline">EnemyPaths</strong> and save it. To draw the path, add a <strong class="source-inline">Path2D</strong> node. As you saw earlier, this node allows you to draw a series of connected points. Selecting this node displays a new <span class="No-Break">menu bar:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B19289_03_23.jpg" alt="Figure 3.23: Path drawing options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23: Path drawing options</p>
			<p>These buttons let you draw and modify the path’s points. Click the one with the green <strong class="bold">+</strong> symbol to add points. Click to start the path somewhere just outside the game window, and then click a few more points to make a curve. Note that the arrows indicate the direction of the path. Don’t worry about making it <span class="No-Break">smooth yet:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B19289_03_24.jpg" alt="Figure 3.24: An example path"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24: An example path</p>
			<p>When the enemy follows the path, it will not look very smooth when it hits the sharp corners. To smooth the curve, click the second button in the path toolbar (its tooltip says <strong class="bold">Select Control Points</strong>). Now, if you click and drag any of the curve’s points, you will add a <a id="_idIndexMarker208"/>control point that allows you to curve the line at that point. Smoothing the line above results in something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B19289_03_25.jpg" alt="Figure 3.25: Using control points"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25: Using control points</p>
			<p>Add two or three more <strong class="source-inline">Path2D</strong> nodes to the scene and draw the paths however you like. Adding loops and curves rather than straight lines will make the enemy look more dynamic (and make it harder to hit). Remember that the first point you click will be the start of the path, so make sure to start them on different sides of the screen for variety. Here are three <span class="No-Break">example paths:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B19289_03_26.jpg" alt="Figure 3.26: Adding multiple paths"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26: Adding multiple paths</p>
			<p>Save the scene. You’ll add this to the enemy’s scene to give it the paths it <span class="No-Break">can follow.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Enemy scene</h2>
			<p>Create a <a id="_idIndexMarker209"/>new scene for the enemy, using an <strong class="source-inline">Area2D</strong> as its root node. Add a <strong class="source-inline">Sprite2D</strong> child and use <strong class="source-inline">res://assets/enemy_saucer.png</strong> as its <strong class="bold">Texture</strong> property. Set <strong class="bold">Animation/HFrames</strong> to <strong class="source-inline">3</strong> so that you can choose between the different <span class="No-Break">colored saucers:</span></p>
			<ol>
				<li>As you’ve done before, add a <strong class="source-inline">CollisionShape2D</strong> and give it a <strong class="source-inline">CircleShape2D</strong> scaled to cover the image. Add an instance of the <strong class="source-inline">EnemyPaths</strong> scene and an <strong class="source-inline">AnimationPlayer</strong>. In the <strong class="source-inline">AnimationPlayer</strong>, you’ll add an animation to create a flash effect when the saucer <span class="No-Break">is hit.</span></li>
				<li>Add an animation named <strong class="source-inline">flash</strong>. Set <strong class="bold">Length</strong> to <strong class="source-inline">0.25</strong> and <strong class="bold">Snap</strong> to <strong class="source-inline">0.01</strong>. The property you’ll be animating is the <strong class="source-inline">Sprite2D</strong>’s <strong class="bold">Modulate</strong> property (found under <strong class="bold">Visibility</strong>). Add a keyframe for <strong class="bold">Modulate</strong> to create the track, then move the scrubber to <strong class="source-inline">0.04</strong> and change the <strong class="bold">Modulate</strong> color to red. Move forward another <strong class="source-inline">0.04</strong> and change the color back <span class="No-Break">to white.</span></li>
				<li>Repeat this process two more times so that you have three flashes <span class="No-Break">in total.</span></li>
				<li>Add an instance of the <strong class="source-inline">Explosion</strong> scene and hide it. Add a <strong class="source-inline">Timer</strong> node named <strong class="source-inline">GunCooldown</strong> to control how often the enemy will shoot. Set <strong class="bold">Wait Time</strong> to <strong class="source-inline">1.5</strong> and <strong class="bold">Autostart</strong> <span class="No-Break">to on.</span></li>
				<li>Add a script to the enemy and connect the timer’s <strong class="source-inline">timeout</strong>. Don’t add anything to the <span class="No-Break">function yet.</span></li>
				<li>In the <strong class="bold">Node</strong> tab of Area2D, add it to a group called <strong class="source-inline">enemies</strong>. As with the rocks, this will give you a way to identify the object, even if there are multiple enemies on the screen at the <span class="No-Break">same time.</span></li>
			</ol>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Moving the enemy</h2>
			<p>To begin, you’ll <a id="_idIndexMarker210"/>write the code to select a path and move the enemy <span class="No-Break">along it:</span></p>
			<pre class="source-code">
extends Area2D
@export var bullet_scene : PackedScene
@export var speed = 150
@export var rotation_speed = 120
@export var health = 3
var follow = PathFollow2D.new()
var target = null
func _ready():
    $Sprite2D.frame = randi() % 3
    var path = $EnemyPaths.get_children()[randi() %
        $EnemyPaths.get_child_count()]
    path.add_child(follow)
    follow.loop = false</pre>
			<p>Recall that the <strong class="source-inline">PathFollow2D</strong> node automatically moves along a parent <strong class="source-inline">Path2D</strong>. By default, it loops around the path when it reaches the end, so you need to set that to <strong class="source-inline">false</strong> to <span class="No-Break">disable it.</span></p>
			<p>The next step is to move along the path and remove the enemy when it reaches the end of <span class="No-Break">the path:</span></p>
			<pre class="source-code">
func _physics_process(delta):
    rotation += deg_to_rad(rotation_speed) * delta
    follow.progress += speed * delta
    position = follow.global_position
    if follow.progress_ratio &gt;= 1:
        queue_free()</pre>
			<p>You can <a id="_idIndexMarker211"/>detect the end of the path when <strong class="source-inline">progress</strong> is greater than the total path length. However, it’s more straightforward to use <strong class="source-inline">progress_ratio</strong>, which varies from zero to one over the length of the path, so you don’t need to know how long each <span class="No-Break">path is.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Spawning enemies</h2>
			<p>In the <strong class="source-inline">Main</strong> scene, add<a id="_idIndexMarker212"/> a new <strong class="source-inline">Timer</strong> node called <strong class="source-inline">EnemyTimer</strong>. Set its <strong class="bold">One Shot</strong> property to on. Then, in <strong class="source-inline">main.gd</strong>, add a variable to reference the <span class="No-Break">enemy scene:</span></p>
			<pre class="source-code">
@export var enemy_scene : PackedScene</pre>
			<p>Add this line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">new_level()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$EnemyTimer.start(randf_range(5, 10))</pre>
			<p>Connect the <strong class="source-inline">EnemyTimer</strong>’s <span class="No-Break"><strong class="source-inline">timeout</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_enemy_timer_timeout():
    var e = enemy_scene.instantiate()
    add_child(e)
    e.target = $Player
    $EnemyTimer.start(randf_range(20, 40))</pre>
			<p>This code instances the enemy whenever <strong class="source-inline">EnemyTimer</strong> times out. You don’t want another enemy for a while, so the timer is restarted with a <span class="No-Break">longer delay.</span></p>
			<p>Play the game, and you should see a saucer appear and fly along <span class="No-Break">its path.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Shooting and collisions</h2>
			<p>The enemy needs to <a id="_idIndexMarker213"/>shoot at the player as well as react when hit by the player or the <span class="No-Break">player’s bullets.</span></p>
			<p>The enemy’s bullet <a id="_idIndexMarker214"/>will be similar to the player’s, but we’ll use a different texture. You can create it again from scratch or use the following process to reuse the <span class="No-Break">node setup.</span></p>
			<p>Open the <strong class="source-inline">Bullet</strong> scene and choose <strong class="bold">Scene</strong> | <strong class="bold">Save Scene As</strong> to save it as <strong class="source-inline">enemy_bullet.tscn</strong> (afterward, don’t forget to rename the root node as well). Remove the script by clicking the <strong class="bold">Detach the script</strong> button. Disconnect the signal connections by clicking the <strong class="bold">Node</strong> tab and choosing <strong class="bold">Disconnect</strong>. You can see which nodes have their signals connected by looking for the <img src="image/B19289_03_27.png" alt=""/> icon next to the <span class="No-Break">node name.</span></p>
			<p>Replace the sprite’s texture with the <strong class="source-inline">laser_green.png</strong> image, and add a new script to the <span class="No-Break">root node.</span></p>
			<p>The script for the enemy bullet will be very similar to the regular bullet. Connect the area’s <strong class="source-inline">body_entered</strong> signal and the <strong class="source-inline">screen_exited</strong> signal <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">VisibleOnScreenNotifier2D</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
extends Area2D
@export var speed = 1000
func start(_pos, _dir):
    position = _pos
    rotation = _dir.angle()
func _process(delta):
    position += transform.x * speed * delta
func _on_body_entered(body):
    queue_free()
func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free()</pre>
			<p>Note <a id="_idIndexMarker215"/>that you’ll need to specify a position and direction for the bullet. That’s because, unlike the player, who always shoots <a id="_idIndexMarker216"/>forward, the enemy will always shoot toward <span class="No-Break">the player.</span></p>
			<p>For now, the bullet won’t do any damage to the player. You’ll be adding a shield to the player in the next section, so you can add it at <span class="No-Break">that time.</span></p>
			<p>Save the scene and drag it into the <strong class="bold">Bullet</strong> property of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Enemy</strong></span><span class="No-Break">.</span></p>
			<p>In <strong class="source-inline">enemy.gd</strong>, add a variable for some random variation to the bullet, and the <span class="No-Break"><strong class="source-inline">shoot()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
@export var bullet_spread = 0.2
func shoot():
    var dir =
       global_position.direction_to(target.global_position)
    dir = dir.rotated(randf_range(-bullet_spread,
       bullet_spread))
    var b = bullet_scene.instantiate()
    get_tree().root.add_child(b)
    b.start(global_position, dir)</pre>
			<p>First, you find the vector pointing to the player’s position, then add a little bit of randomness so that it <span class="No-Break">can “miss.”</span></p>
			<p>Call the <strong class="source-inline">shoot()</strong> function whenever <strong class="source-inline">GunCooldown</strong> <span class="No-Break">times out:</span></p>
			<pre class="source-code">
func _on_gun_cooldown_timeout():
    shoot()</pre>
			<p>For an extra challenge, you can make the enemy shoot in pulses or multiple <span class="No-Break">rapid shots:</span></p>
			<pre class="source-code">
func shoot_pulse(n, delay):
    for i in n:
        shoot()
        await get_tree().create_timer(delay).timeout</pre>
			<p>This <a id="_idIndexMarker217"/>will shoot a given number of bullets, <strong class="source-inline">n</strong>, with <strong class="source-inline">delay</strong> seconds between them. You can call this instead when the <span class="No-Break">cooldown triggers:</span></p>
			<pre class="source-code">
func _on_gun_cooldown_timeout():
    shoot_pulse(3, 0.15)</pre>
			<p>This will <a id="_idIndexMarker218"/>shoot a pulse of <strong class="source-inline">3</strong> bullets with <strong class="source-inline">0.15</strong> seconds between them. Tough <span class="No-Break">to dodge!</span></p>
			<p>Next, the enemy needs to take damage when it’s hit by a shot from the player. It will flash using the animation you made and then explode when its health <span class="No-Break">reaches </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<p>Add these functions <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">enemy.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func take_damage(amount):
    health -= amount
    $AnimationPlayer.play("flash")
    if health &lt;= 0:
        explode()
func explode():
    speed = 0
    $GunCooldown.stop()
    $CollisionShape2D.set_deferred("disabled", true)
    $Sprite2D.hide()
    $Explosion.show()
    $Explosion/AnimationPlayer.play("explosion")
    await $Explosion/AnimationPlayer.animation_finished
    queue_free()</pre>
			<p>Also, connect <a id="_idIndexMarker219"/>the enemy’s <strong class="source-inline">body_entered</strong> signal<a id="_idIndexMarker220"/> so that the enemy will explode if the player runs <span class="No-Break">into it:</span></p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        return
    explode()</pre>
			<p>Again, you’re waiting for the player shield to be implemented before doing damage to the player, so for now, this collision only destroys <span class="No-Break">the enemy.</span></p>
			<p>Currently, the player’s bullet is only detecting rocks because its <strong class="source-inline">body_entered</strong> signal isn’t triggered by the enemy, which is an <strong class="source-inline">Area2D</strong>. To detect the enemy, go to the <strong class="source-inline">Bullet</strong> scene and connect the <span class="No-Break"><strong class="source-inline">area_entered</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("enemies"):
        area.take_damage(1)</pre>
			<p>Try playing the game again and you’ll be doing battle with an aggressive alien opponent! Verify that all the collision combinations are being handled (except for the enemy shooting the player). Also note that the enemy’s bullets can be blocked by rocks – maybe you can hide behind them <span class="No-Break">for cover!</span></p>
			<p>Now that the game has enemies, it’s a lot more challenging. If you still find it too easy, try increasing the enemy’s properties: how often it appears, how much damage it does, and how many shots it takes to destroy it. It’s OK if you make it too hard because, in the next section, you’ll give the player a little help by adding a shield to <span class="No-Break">absorb damage.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Player shield</h1>
			<p>In this<a id="_idIndexMarker221"/> section, you’ll add a shield to the player and a display element to the <strong class="source-inline">HUD</strong> showing the current <span class="No-Break">shield level.</span></p>
			<p>First, add the following to the top of the <span class="No-Break"><strong class="source-inline">player.gd</strong></span><span class="No-Break"> script:</span></p>
			<pre class="source-code">
signal shield_changed
@export var max_shield = 100.0
@export var shield_regen = 5.0
var shield = 0: set = set_shield
func set_shield(value):
    value = min(value, max_shield)
    shield = value
    shield_changed.emit(shield / max_shield)
    if shield &lt;= 0:
        lives -= 1
        explode()</pre>
			<p>The <strong class="source-inline">shield</strong> variable works similarly to <strong class="source-inline">lives</strong>, emitting a signal whenever it changes. Since the value will be added to by the shield’s regeneration, you need to make sure it doesn’t go above the <strong class="source-inline">max_shield</strong> value. Then, when you emit the <strong class="source-inline">shield_changed</strong> signal, you pass the ratio of <strong class="source-inline">shield</strong> / <strong class="source-inline">max_shield</strong> rather than the actual value. This way, the <strong class="source-inline">HUD</strong>’s display doesn’t need to know anything about how big the shield actually is, just <span class="No-Break">its percentage.</span></p>
			<p>You should also remove the <strong class="source-inline">explode()</strong> line from <strong class="source-inline">_on_body_entered()</strong>, since you now don’t want just hitting a rock to blow up the ship – that will now only happen when the shield <span class="No-Break">runs out.</span></p>
			<p>Hitting a rock will damage the shield, and bigger rocks should do <span class="No-Break">more damage:</span></p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        shield -= body.size * 25
        body.explode()</pre>
			<p>The enemy’s <a id="_idIndexMarker222"/>bullets should also do damage, so make this change <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">enemy_bullet.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
@export var damage = 15
func _on_body_entered(body):
    if body.name == "Player":
        body.shield -= damage
    queue_free()</pre>
			<p>Also, running into the enemy should damage the player, so update this <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">enemy.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        return
    explode()
    body.shield -= 50</pre>
			<p>If the player’s shield runs out and they lose a life, you should reset the shield to its maximum. Add this line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">set_lives()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
shield = max_shield</pre>
			<p>The last addition to the player script is to regenerate the shield each frame. Add this line to <strong class="source-inline">_process()</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">player.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
shield += shield_regen * delta</pre>
			<p>Now that the code is complete, you need to add a new display element to the <strong class="source-inline">HUD</strong> scene. Rather than display the shield’s value as a number, you’ll <a id="_idIndexMarker223"/>make a <strong class="bold">progress bar</strong>. <strong class="source-inline">TextureProgressBar</strong> is a <strong class="source-inline">Control</strong> node that displays a given value as a filled bar. It also allows you to assign a texture to be used for <span class="No-Break">the bar.</span></p>
			<p>Go to the <strong class="source-inline">HUD</strong> scene <a id="_idIndexMarker224"/>and add two new nodes as children of the existing <strong class="source-inline">HBoxContainer</strong>: <strong class="source-inline">TextureRect</strong> and <strong class="source-inline">TextureProgressBar</strong>. Rename <strong class="source-inline">TextureProgressBar</strong> to <strong class="source-inline">ShieldBar</strong>. Place them after the <strong class="source-inline">Score</strong> label and before <strong class="source-inline">LivesCounter</strong>. Your node setup should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B19289_03_28.jpg" alt="Figure 3.27: Updated HUD node layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27: Updated HUD node layout</p>
			<p>Drag <strong class="source-inline">res://assets/shield_gold.png</strong> into the <strong class="bold">Texture</strong> property of <strong class="source-inline">TextureRect</strong>. This will be an icon indicating that this bar shows the shield value. Change <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep Centered</strong> so that the texture won’t <span class="No-Break">be distorted.</span></p>
			<p>The <strong class="source-inline">ShieldBar</strong> has three <strong class="bold">Texture</strong> properties: <strong class="bold">Under</strong>, <strong class="bold">Over</strong>, and <strong class="bold">Progress</strong>. <strong class="bold">Progress</strong> is the texture that will be used for the bar’s value. Drag <strong class="source-inline">res://assets/bar_green_200.png</strong> into this property. The other two texture properties let you customize the appearance by setting an image to be drawn above or below the progress texture. Drag <strong class="source-inline">res://assets/bar_glass_200.png</strong> into the <span class="No-Break"><strong class="bold">Over</strong></span><span class="No-Break"> property.</span></p>
			<p>In the <strong class="bold">Range</strong> section, you<a id="_idIndexMarker225"/> can set the numerical properties of the bar. <strong class="bold">Min Value</strong> and <strong class="bold">Max Value</strong> should be set to <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, as this bar will show the ratio of the shield to its maximum, not its numerical value. This means <strong class="bold">Step</strong> must also be smaller – set it to <strong class="source-inline">0.01</strong>. <strong class="bold">Value</strong> is the property that controls how much of the bar should be “full.” Change it to <strong class="source-inline">.75</strong> to see the bar partly filled. Also, in the <strong class="bold">Layout/Container Sizing</strong> section, check the <strong class="bold">Expand</strong> box and set <strong class="bold">Vertical</strong> to <span class="No-Break"><strong class="bold">Shrink Center</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">HUD</strong> should look like this when <span class="No-Break">you’re done:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B19289_03_29.jpg" alt="Figure 3.28: Updated HUD with shield bar"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.28: Updated HUD with shield bar</p>
			<p>You can now update the script to set the value of the shield bar, as well as to make it change color as it gets closer to zero. Add these variables <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">hud.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
@onready var shield_bar =
    $MarginContainer/HBoxContainer/ShieldBar
var bar_textures = {
    "green": preload("res://assets/bar_green_200.png"),
    "yellow": preload("res://assets/bar_yellow_200.png"),
    "red": preload("res://assets/bar_red_200.png")
}</pre>
			<p>In addition to the green bar, you also have red and yellow bars in the <strong class="source-inline">assets</strong> folder. This allows you to change the shield bar’s color as the value decreases. Loading the textures in this<a id="_idIndexMarker226"/> way makes them easier to access later in the script when you want to assign the appropriate image to <span class="No-Break">the bar:</span></p>
			<pre class="source-code">
func update_shield(value):
    shield_bar.texture_progress = bar_textures["green"]
    if value &lt; 0.4:
        shield_bar.texture_progress = bar_textures["red"]
    elif value &lt; 0.7:
        shield_bar.texture_progress = bar_textures["yellow"]
    shield_bar.value = value</pre>
			<p>Finally, click on the <strong class="source-inline">Main</strong> scene’s <strong class="source-inline">Player</strong> node and connect the <strong class="source-inline">shield_changed</strong> signal to the <strong class="source-inline">HUD</strong>’s <span class="No-Break"><strong class="source-inline">update_shield()</strong></span><span class="No-Break"> function.</span></p>
			<p>Run the game and verify that the shield is working. You may want to increase or decrease the shield regeneration rate to give it a speed you’re happy with. When you’re ready to move on, in the next section, you’ll add some sound to <span class="No-Break">the game.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Sound and visual effects</h1>
			<p>The<a id="_idIndexMarker227"/> structure and gameplay of the game is complete. In this section, you’ll add some additional effects to the game to improve the <span class="No-Break">game experience.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Sound and music</h2>
			<p>In <a id="_idIndexMarker228"/>the <strong class="source-inline">res://assets/sounds</strong> folder are several audio effects for the game. To play a sound, it needs to be loaded by an <strong class="source-inline">AudioStreamPlayer</strong> node. Add two of these nodes to the <strong class="source-inline">Player</strong> scene, naming them <strong class="source-inline">LaserSound</strong> and <strong class="source-inline">EngineSound</strong>. Drag the respective sound files into each node’s <strong class="bold">Stream</strong> property in the Inspector. To play the sound when shooting, add this line to <strong class="source-inline">shoot()</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">player.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$LaserSound.play()</pre>
			<p>Play the game and try shooting. If you find the sound too loud, you can adjust the <strong class="bold">Volume dB</strong> property. Try a value of <strong class="source-inline">-10</strong> <span class="No-Break">to start.</span></p>
			<p>The <a id="_idIndexMarker229"/>engine sounds works a little differently. It needs to play when the thrust is on, but if you just try to call <strong class="source-inline">play()</strong> on the sound in the <strong class="source-inline">get_input()</strong> function when the player presses the key, it will restart the sound every frame. This doesn’t sound good, so you only want to start playing the sound if it isn’t already playing. Here is the relevant section of the <span class="No-Break"><strong class="source-inline">get_input()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
if Input.is_action_pressed("thrust"):
    thrust = transform.x * engine_power
    if not $EngineSound.playing:
        $EngineSound.play()
else:
    $EngineSound.stop()</pre>
			<p>Note that a problem can occur: if the player dies while holding down the thrust key, the engine sound will remain stuck playing because, in the <strong class="bold">DEAD</strong> state, you ignore player input. This can be solved by adding <strong class="source-inline">$EngineSound.stop()</strong> to the <strong class="bold">DEAD</strong> state <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">change_state()</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">Main</strong> scene, add three more <strong class="source-inline">AudioStreamPlayer</strong> nodes: <strong class="source-inline">ExplosionSound</strong>, <strong class="source-inline">LevelupSound</strong>, and <strong class="source-inline">Music</strong>. In their <strong class="bold">Stream</strong> properties, drop <strong class="source-inline">explosion.wav</strong>, <strong class="source-inline">levelup.ogg</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Funky-Gameplay_Looping.ogg</strong></span><span class="No-Break">.</span></p>
			<p>Add <strong class="source-inline">$ExplosionSound.play()</strong> as the first line of <strong class="source-inline">_on_rock_exploded()</strong>, and add <strong class="source-inline">$LevelupSound.play()</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">new_level()</strong></span><span class="No-Break">.</span></p>
			<p>To start and stop the background music, add <strong class="source-inline">$Music.play()</strong> to <strong class="source-inline">new_game()</strong> and <strong class="source-inline">$Music.stop()</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">game_over()</strong></span><span class="No-Break">.</span></p>
			<p>The enemy also needs <strong class="source-inline">ExplosionSound</strong> and <strong class="source-inline">ShootSound</strong> nodes. You can use <strong class="source-inline">enemy_laser.wav</strong> for their <span class="No-Break">shooting sound.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Particles</h2>
			<p>The <a id="_idIndexMarker230"/>player ship’s thrust is a perfect use of particle effects, creating a streaming flame from <span class="No-Break">the engine.</span></p>
			<p>Add a <strong class="source-inline">CPUParticles2D</strong> node and name it <strong class="source-inline">Exhaust</strong>. You might want to zoom in on the ship while you’re doing <span class="No-Break">this part.</span></p>
			<p class="callout-heading">Particle node types</p>
			<p class="callout">Godot offers two types of particle nodes: one that uses the CPU and one that uses the GPU for rendering. Since not all platforms, especially mobile or older desktops, support hardware acceleration for particles, you can use the CPU version for wider compatibility. If you know your game will be running on more powerful systems, you can use the <span class="No-Break">GPU version.</span></p>
			<p>You’ll see a line of white dots streaming down from the center of the ship. Your challenge now is to turn those dots into an <span class="No-Break">exhaust flame.</span></p>
			<p>There are a very large number of properties to choose from when configuring particles. As you go through the process of setting up this effect, feel free to experiment with them to see how they affect <span class="No-Break">the result.</span></p>
			<p>Set these properties of the <span class="No-Break"><strong class="source-inline">Exhaust</strong></span><span class="No-Break"> node:</span></p>
			<ul>
				<li> <span class="No-Break"><strong class="bold">Amount</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">25</strong></span></li>
				<li> <strong class="bold">Drawing/Local </strong><span class="No-Break"><strong class="bold">Coords</strong></span><span class="No-Break">: On</span></li>
				<li> <strong class="bold">Transform/Position</strong>: <strong class="source-inline">(-</strong><span class="No-Break"><strong class="source-inline">28, 0)</strong></span></li>
				<li> <span class="No-Break"><strong class="bold">Transform/Rotation</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">180</strong></span></li>
				<li> <strong class="bold">Visibility/Show Behind </strong><span class="No-Break"><strong class="bold">Parent</strong></span><span class="No-Break">: On</span></li>
			</ul>
			<p>The remaining properties you’ll change will affect the behavior of the particles. Start with <strong class="bold">Emission Shape</strong>: change it to <strong class="bold">Rectangle</strong>. This will reveal <strong class="bold">Rect Extents</strong>, which you can set to <strong class="source-inline">(1, 5)</strong>. The particles are now emitted over a small area instead of a <span class="No-Break">single point.</span></p>
			<p>Next, set <strong class="bold">Direction/Spread</strong> to <strong class="source-inline">0</strong> and <strong class="bold">Gravity</strong> to <strong class="source-inline">(0, 0)</strong>. Note that the particles are not falling or spreading out, although they are moving <span class="No-Break">very slowly.</span></p>
			<p>Set <strong class="bold">Initial Velocity/Velocity Max</strong> to <strong class="source-inline">400</strong>, then scroll down to <strong class="bold">Scale/Scale Amount Max</strong> and set it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">.</span></p>
			<p>To make the<a id="_idIndexMarker231"/> size change over time, you can set <strong class="bold">Scale Amount Curve</strong>. Select <strong class="bold">New Curve</strong> and then click to open it. In the small graph that shows, right-click to add two points – one on the left and one on the right. Drag the right-hand dot down until the curve looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B19289_03_30.jpg" alt="Figure 3.29: Adding a particle scale curve"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.29: Adding a particle scale curve</p>
			<p>You should now see the particles shrinking as they stream out from the back of <span class="No-Break">the ship.</span></p>
			<p>The last section to adjust is <strong class="bold">Color</strong>. To make the particles appear like a flame, they should start out bright orange-yellow and shift to red as they fade out. In the <strong class="bold">Color Ramp</strong> property, click on <strong class="bold">New Gradient</strong>, and you’ll see a gradient editor that looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B19289_03_31.jpg" alt="Figure 3.30: Color Ramp settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.30: Color Ramp settings</p>
			<p>The two<a id="_idIndexMarker232"/> rectangular sliders labeled <em class="italic">1</em> and <em class="italic">2</em> set the starting and ending colors of the gradient. Clicking on either of them will show its color in the box labeled <em class="italic">3</em>. Select slider <em class="italic">1</em> and then click box <em class="italic">3</em> to open a color picker. Choose an orange color, and then do the same for slider <em class="italic">2</em>, choosing a <span class="No-Break">dark red.</span></p>
			<p>Now that the particles have the correct appearance, they’re lasting far too long. In the node’s <strong class="bold">Time</strong> section, set <strong class="bold">Lifetime</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.1</strong></span><span class="No-Break">.</span></p>
			<p>Hopefully, your ship’s exhaust looks somewhat like a flame. If it doesn’t, feel free to adjust the properties until you are happy with how <span class="No-Break">it looks.</span></p>
			<p>Once the flame is looking good, it needs to be turned on and off based on the player’s input. Go to <strong class="source-inline">player.gd</strong> and add <strong class="source-inline">$Exhaust.emitting = false</strong> at the beginning of <strong class="source-inline">get_input()</strong>. Then, under the <strong class="source-inline">if</strong> statement that checks for <strong class="source-inline">thrust</strong> input, add <strong class="source-inline">$Exhaust.emitting = </strong><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Enemy trail</h2>
			<p>You can also use particles to give the<a id="_idIndexMarker233"/> enemy saucer a sparkling trail. Add a <strong class="source-inline">CPUParticles2D</strong> to the enemy scene and configure <span class="No-Break">these settings:</span></p>
			<ul>
				<li> <span class="No-Break"><strong class="bold">Amount</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">20</strong></span></li>
				<li> <strong class="bold">Visibility/Show Behind </strong><span class="No-Break"><strong class="bold">Parent</strong></span><span class="No-Break">: On</span></li>
				<li> <strong class="bold">Emission </strong><span class="No-Break"><strong class="bold">Shape/Shape</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Sphere</strong></span></li>
				<li> <strong class="bold">Emission Shape/Sphere </strong><span class="No-Break"><strong class="bold">Radius</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">25</strong></span></li>
				<li> <strong class="bold">Gravity</strong>: <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">0, 0)</strong></span></li>
			</ul>
			<p>You <a id="_idIndexMarker234"/>should now have particles appearing all across the radius of the saucer (you can hide the <strong class="source-inline">Sprite2D</strong> during this part if you want to see them better). The default shape for particles is a square, but you can also use a texture for even more visual appeal. Add <strong class="source-inline">res://assets/corona.png</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Drawing/Texture</strong></span><span class="No-Break">.</span></p>
			<p>This image gives a nice glowing effect, but it’s quite large compared to the saucer, so set <strong class="bold">Scale/Scale Amount Max</strong> to <strong class="source-inline">0.1</strong>. You’ll also notice that this image is white on a black background. In order to look correct, it <a id="_idIndexMarker235"/>needs its <strong class="bold">blend mode</strong> changed. To do this, find the <strong class="bold">Material</strong> property and select <strong class="bold">New CanvasItemMaterial</strong>. There, you can change <strong class="bold">Blend Mode</strong> from <strong class="bold">Mix</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">.</span></p>
			<p>Finally, you can make the particles fade away by using <strong class="bold">Scale Amount Curve</strong> in the <strong class="bold">Scale</strong> section, just as you did with the <span class="No-Break">player particles.</span></p>
			<p>Play your game and admire the effects. What else could you add <span class="No-Break">with particles?</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Summary</h1>
			<p>In this chapter, you learned how to work with <strong class="source-inline">RigidBody2D</strong> nodes and learned more about how Godot’s physics works. You also implemented a basic finite state machine – something you’ll find useful as your projects grow larger and that you’ll use again in future chapters. You saw how <strong class="source-inline">Container</strong> nodes help organize and keep UI nodes aligned. Finally, you added sound effects and got your first taste of advanced visual effects by using the <strong class="source-inline">Animation</strong> and <span class="No-Break"><strong class="source-inline">CPUParticles2D</strong></span><span class="No-Break"> nodes.</span></p>
			<p>You also continued to create game objects using standard Godot hierarchies, such as <strong class="source-inline">CollisionShapes</strong> attached to <strong class="source-inline">CollisionObjects</strong> and signals being used to handle communication between nodes. At this point, these practices should be starting to look familiar <span class="No-Break">to you.</span></p>
			<p>Are you prepared to try and remake this project on your own? Try repeating all, or even part, of this chapter without looking at the book. It’s a good way to check what information you absorbed and what you need to review again. You can also try remaking it with your own variations rather than making an <span class="No-Break">exact copy.</span></p>
			<p>When you’re ready to move on, in the next chapter, you’ll make another style of game that’s very popular: a platformer in the tradition of Super <span class="No-Break">Mario Bros.</span></p>
		</div>
	</body></html>