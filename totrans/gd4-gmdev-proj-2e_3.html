<html><head></head><body>
		<div><h1 id="_idParaDest-67" class="chapter-number"><a id="_idTextAnchor066"/>3</h1>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Space Rocks: Build a 2D Arcade Classic with Physics</h1>
			<p>By now, you should be getting more comfortable with working in Godot: adding nodes, creating scripts, modifying properties in the Inspector, and so on. If you find yourself stuck or feeling like you don’t remember how something is done, you can jump back to a project where it was first explained. As you repeat the more common actions in Godot, they’ll start to feel more and more familiar. At the same time, each chapter will introduce you to more nodes and techniques to expand your understanding of Godot’s features.</p>
			<p>In this project, you’ll make a space shooter game similar to the arcade classic <em class="italic">Asteroids</em>. The player will <a id="_idIndexMarker131"/>control a ship that can rotate and move in any direction. The goal will be to avoid the floating “space rocks” and shoot them with the ship’s laser. Here’s a screenshot of the final game:</p>
			<div><div><img src="img/B19289_03_01.jpg" alt="Figure 3.1: Space Rocks screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Space Rocks screenshot</p>
			<p>You’ll learn about the following key topics in this project:</p>
			<ul>
				<li>Using custom input actions</li>
				<li>Physics using <code>RigidBody2D</code></li>
				<li>Organizing game logic with finite state machines</li>
				<li>Building a dynamic, scalable UI</li>
				<li>Sound and music</li>
				<li>Particle effects</li>
			</ul>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Technical requirements </h1>
			<p>Download the game assets from the following link below and unzip them into your new project folder: <a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</a></p>
			<p>You can also find the complete code for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks</a></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Setting up the project</h1>
			<p>Create a new project and download the project assets from the following URL: <a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</a>.<a href="https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads&#13;"/></p>
			<p>For <a id="_idIndexMarker132"/>this project, you’ll set up custom input actions in the <strong class="bold">Input Map</strong>. Using this feature, you can define custom input events and assign different keys, mouse events, or other inputs to them. This allows more flexibility in designing your game, as your code can be written to respond to the “jump” input, for example, without needing to know exactly what key and/or button the user pressed to make that event happen. This allows you to make the same code work on different devices, even if they have different hardware. In addition, since many gamers expect to be able to customize a game’s inputs, this enables you to provide that option to the user as well.</p>
			<p>To set up the inputs for this game, open <strong class="bold">Project</strong> | <strong class="bold">Project Settings</strong> and select the <strong class="bold">Input </strong><strong class="bold">Map</strong> tab.</p>
			<p>You’ll need to create four new input actions: <code>rotate_left</code>, <code>rotate_right</code>, <code>thrust</code>, and <code>shoot</code>. Type the name of each action into the <strong class="bold">Add New Action</strong> box and hit <em class="italic">Enter</em> or click the <strong class="bold">Add</strong> button. Make sure you type the names exactly as shown since they’ll be used in code later.</p>
			<p>Then, for each action, click the <strong class="bold">+</strong> button to its right. In the pop-up window, you can manually select a specific type of input, or you can press the physical button and Godot will detect it. You can add multiple inputs to each action. For example, to allow players to use both the arrow keys and the WASD keys, the setup will look like this:</p>
			<div><div><img src="img/B19289_03_02.jpg" alt="Figure 3.2: Input actions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Input actions</p>
			<p>If you have a gamepad or other controller connected to your computer, you can also add its inputs <a id="_idIndexMarker133"/>to the actions in the same way.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We’re only considering button-style inputs at this stage, so while you’ll be able to use a D-pad for this project, using an analog joystick would require changes to the project’s code.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Rigid body physics</h2>
			<p>In<a id="_idIndexMarker134"/> game development, you often need to know when two objects in the game space intersect or come into contact. This is known as <strong class="bold">collision detection</strong>. When a collision is detected, you typically want something to happen. This is known as <strong class="bold">collision response</strong>.</p>
			<p>Godot offers three kinds of physics bodies, grouped under the <code>PhysicsBody2D</code> node type:</p>
			<ul>
				<li><code>StaticBody2D</code>: A static body is one that is not moved by the physics engine. It participates in collision detection but does not move in response. This type of body is most often used for objects that are part of the environment or do not need to have any dynamic behavior, such as walls or the ground.</li>
				<li> <code>RigidBody2D</code>: This is the physics body that provides simulated physics. This means that you don’t control a <code>RigidBody2D</code> physics body’s position directly. Instead, you apply forces to it (gravity, impulses, and so on) and Godot’s built-in physics engine calculates the resultant movement, including collisions, bouncing, rotating, and other effects.</li>
				<li><code>CharacterBody2D</code>: This body type provides collision detection but no physics. All movement must be implemented in code, and you must implement any collision response yourself. Kinematic bodies are most often used for player characters or other actors that require <em class="italic">arcade-style</em> physics rather than realistic simulation, or when you need more precise control over how the body moves.</li>
			</ul>
			<p>Understanding<a id="_idIndexMarker135"/> when to use a particular physics body type is a big part of building your game. Using the right type can simplify your development, while trying to force the wrong node to do the job can lead to frustration and poor results. As you work with each type of body, you’ll come to learn their pros and cons and get a feel for when they can help build what you need.</p>
			<p>In this project, you’ll be using the <code>RigidBody2D</code> node for the ship as well as the rocks themselves. You’ll learn about the other body types in later chapters.</p>
			<p>Individual <code>RigidBody2D</code> nodes have many properties you can use to customize their behavior, such as <strong class="bold">Mass</strong>, <strong class="bold">Friction</strong>, or <strong class="bold">Bounce</strong>. These properties can be set in the Inspector.</p>
			<p>Rigid bodies are also affected by global properties, which can be set in <strong class="bold">Project Settings</strong> under <strong class="bold">Physics</strong> | <strong class="bold">2D</strong>. These settings apply to all bodies in the world.</p>
			<div><div><img src="img/B19289_03_03.jpg" alt="Figure 3.3: Project physics settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Project physics settings</p>
			<p>In most cases, you<a id="_idIndexMarker136"/> won’t need to modify these settings. However, note that by default, gravity has a value of <code>980</code> and a direction of <code>(0, 1)</code>, or downward. If you want to change the world’s gravity, you can do that here.</p>
			<p>If you click the <strong class="bold">Advanced Settings</strong> toggle in the upper right of the <strong class="bold">Project Settings</strong> window, you’ll see many advanced configuration values for the physics engine. You should be aware of two of them in particular: <strong class="bold">Default Linear Damp</strong> and <strong class="bold">Default Angular Damp</strong>. These properties control how quickly a body will lose forward speed and rotation speed, respectively. Setting them to lower values will make the world feel frictionless, while using larger values will make it feel like your objects are moving through mud. This can be a great way to apply different movement styles to suit various game objects and environments.</p>
			<p class="callout-heading">Area physics override</p>
			<p class="callout"><code>Area2D</code> nodes can also be used to influence rigid body physics by using their <strong class="bold">Space Override</strong> property. Custom gravity and damping values will then be applied to any bodies that enter the area.</p>
			<p>Since this game will be taking place in outer space, gravity won’t be needed, so set <code>0</code>. You can leave the other settings as they are.</p>
			<p>That completes the project setup tasks. It’s a good idea to look back through this section and make sure you didn’t miss anything, since the changes you’ve made here will affect the behavior of many game objects. You’ll see this in the next section, where you’ll make the player’s ship.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>The player’s ship</h1>
			<p>The <a id="_idIndexMarker137"/>player’s ship is the heart of this game. Most of the code you’ll write for this project will be about making the ship work. It will be controlled in <a id="_idIndexMarker138"/>the classic “Asteroids style, with left/right rotation and forward thrust. The player will also be able to fire the laser and destroy floating rocks.</p>
			<div><div><img src="img/B19289_03_04.jpg" alt="Figure 3.4: The player’s ship"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: The player’s ship</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Body and physics setup</h2>
			<p>Create a <a id="_idIndexMarker139"/>new scene and add a <code>RigidBody2D</code> named <code>Player</code> as the root node, with <code>Sprite2D</code> and <code>CollisionShape2D</code> children. Add the <code>res://assets/player_ship.png</code> image to the <code>Sprite2D</code>. The ship image is quite large, so set the <code>Sprite2D</code> to <code>(0.5, 0.5)</code> and <code>90</code>.</p>
			<div><div><img src="img/B19289_03_05.jpg" alt="Figure 3.5: Player sprite settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Player sprite settings</p>
			<p class="callout-heading">Sprite orientation</p>
			<p class="callout">The image for the ship is drawn pointing upward. In Godot, a rotation of <code>0</code> degrees points to the right (along the <code>x</code>-axis). This means that you need to rotate the sprite so that it will match the body’s direction. If you use art that is drawn in the correct orientation, you can avoid this step. However, it’s very common to find art that’s drawn in an upward orientation, so you should know what to do.</p>
			<p>In the <code>CollisionShape2D</code>, add a <code>CircleShape2D</code> and scale it to cover the image as closely as possible.</p>
			<div><div><img src="img/B19289_03_06.jpg" alt="Figure 3.6: Player collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Player collision shape</p>
			<p>The player ship<a id="_idIndexMarker141"/> is drawn in a pixel art style, but if you zoom in, you may notice it looks vary blurred and “smoothed out.” Godot’s default filter setting for drawing textures uses this smoothing technique, which looks good with some art, but typically isn’t wanted for pixel art. You can set the filtering individually on each sprite (in the <strong class="bold">CanvasItem</strong> section), or you can set it globally in <strong class="bold">Project Settings</strong>.</p>
			<p>Open <strong class="bold">Project Settings</strong> and check the <strong class="bold">Advanced Settings</strong> toggle, and then find the <strong class="bold">rendering/textures</strong> section. Near the bottom, you’ll see two settings for <strong class="bold">Canvas Textures</strong>. Set <strong class="bold">Default Texture Filter</strong> to <strong class="bold">Nearest</strong>.</p>
			<div><div><img src="img/B19289_03_07.jpg" alt="Figure 3.7: Default Texture Filter settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Default Texture Filter settings</p>
			<p>Save the scene. When working on larger-scale projects, it is recommended to organize your scenes and scripts into folders based on each game object rather than saving them all in the root <a id="_idIndexMarker142"/>project folder. For example, if you make a “player” folder, you can save all player-related files there. This makes it easier to find and modify your various game objects. While this project is relatively small – you’ll only have a few scenes – it’s a good habit to adopt as your projects grow in size and complexity.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>State machines</h2>
			<p>The player’s ship <a id="_idIndexMarker143"/>can be in a number of different states during gameplay. For example, when <em class="italic">alive</em>, the ship is visible and can be controlled by the player, but it is vulnerable to being hit by rocks. On the other hand, when <em class="italic">invulnerable</em>, the ship should appear semi-transparent, and it is immune to damage.</p>
			<p>One way that programmers often handle situations like this is to add Boolean variables, or <em class="italic">flags</em>, to the code. For example, the <code>invulnerable</code> flag is set to <code>true</code> when the player first spawns, or <code>alive</code> is set to <code>false</code> when the player is dead. However, this can lead to errors and strange situations when, for some reason, both <code>alive</code> and <code>invulnerable</code> are set to <code>false</code> at the same time. What happens when a rock hits the player in this situation? It would be better if the ship could only be in one clearly defined state at a time.</p>
			<p>A solution to this <a id="_idIndexMarker144"/>problem is to use a <strong class="bold">finite state machine</strong> (<strong class="bold">FSM</strong>). When using an FSM, an entity can only be in one state at a given time. To design your FSM, you define a number of states and what events or actions can cause a transition from one state to another.</p>
			<p>The following diagram depicts the FSM for the player’s ship:</p>
			<div><div><img src="img/B19289_03_08.jpg" alt="Figure 3.8: State machine diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: State machine diagram</p>
			<p>There <a id="_idIndexMarker145"/>are four states, shown by the ovals, and the arrows indicate what transitions can occur between states, as well as what triggers the transition. By checking the current state, you can decide what the player is allowed to do. For example, in <a id="_idIndexMarker146"/>the <strong class="bold">DEAD</strong> state, don’t allow input, or in the <strong class="bold">INVULNERABLE</strong> state, allow <a id="_idIndexMarker147"/>movement but don’t allow shooting.</p>
			<p>Advanced FSM implementations can become quite complex, and the details are beyond the scope of this book (see the <em class="italic">Appendix</em> for further reading). In the purest sense, you won’t be creating a true FSM here, but for the purposes of this project, it will be sufficient to illustrate the concept and keep you from running into the Boolean flag problem.</p>
			<p>Add a script to the <code>Player</code> node and start by creating the skeleton of the FSM implementation:</p>
			<pre class="source-code">
extends RigidBody2D
enum {INIT, ALIVE, INVULNERABLE, DEAD}
var state = INIT</pre>
			<p>An <code>enum</code> statement in the preceding code is equivalent to writing the following code:</p>
			<pre class="source-code">
const INIT = 0
const ALIVE = 1
const INVULNERABLE = 2
const DEAD = 3</pre>
			<p>Next, create<a id="_idIndexMarker149"/> the <code>change_state()</code> function to handle state transitions:</p>
			<pre class="source-code">
func _ready():
    change_state(ALIVE)
func change_state(new_state):
    match new_state:
        INIT:
            $CollisionShape2D.set_deferred("disabled",
                true)
        ALIVE:
            $CollisionShape2D.set_deferred("disabled",
                false)
        INVULNERABLE:
            $CollisionShape2D.set_deferred("disabled",
                true)
        DEAD:
            $CollisionShape2D.set_deferred("disabled",
                true)
    state = new_state</pre>
			<p>Whenever you need to change the state of the player, you’ll call the <code>change_state()</code> function and pass it the value of the new state. Then, by using a <code>match</code> statement, you can execute whatever code should accompany the transition to the new state or disallow it if you don’t want that transition to happen. To illustrate this, the <code>CollisionShape2D</code> node is <a id="_idIndexMarker150"/>being enabled/disabled by the new state. In <code>_ready()</code>,<code> </code>we set <code>ALIVE</code> as the initial state – this is for testing, but we’ll change it to <code>INIT</code> later.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Adding player controls</h2>
			<p>Add the <a id="_idIndexMarker151"/>following variables at the top of the script:</p>
			<pre class="source-code">
@export var engine_power = 500
@export var spin_power = 8000
var thrust = Vector2.ZERO
var rotation_dir = 0</pre>
			<p><code>engine_power</code> and <code>spin_power</code> control how fast the ship can accelerate and turn. <code>thrust</code> represents the force being applied by the engine: either <code>(0, 0)</code> when coasting or a vector pointing forward when the engine is on. <code>rotation_dir</code> represents in which direction the ship is turning so that you can apply a <em class="italic">torque</em> or rotational force.</p>
			<p>As we saw earlier in <code>1</code> and <code>5</code>. You can adjust these later to change how the ship handles.</p>
			<p>The next step is to detect the input and move the ship:</p>
			<pre class="source-code">
func _process(delta):
    get_input()
func get_input():
    thrust = Vector2.ZERO
    if state in [DEAD, INIT]:
        return
    if Input.is_action_pressed("thrust"):
        thrust = transform.x * engine_power
    rotation_dir = Input.get_axis("rotate_left",
        "rotate_right")
func _physics_process(delta):
    constant_force = thrust
    constant_torque = rotation_dir * spin_power</pre>
			<p>The <code>get_input()</code> function captures the key actions and sets the ship’s thrust on or off. Note<a id="_idIndexMarker152"/> that the direction of the thrust is based on the body’s <code>transform.x</code>, which always represents the body’s “forward” direction (see the <em class="italic">Appendix</em> for an overview of transforms).</p>
			<p><code>Input.get_axis()</code> returns a value based on two inputs, representing negative and positive values. So, <code>rotation_dir</code> will be clockwise, counter-clockwise, or zero, depending on the state of the two input actions.</p>
			<p>Finally, when using physics bodies, their movement and related functions should always be called in <code>_physics_process()</code>. Here, you can apply the forces set by the inputs to actually move the body.</p>
			<p>Play the scene, and you should be able to fly around freely.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Screen wrap</h2>
			<p>Another <a id="_idIndexMarker153"/>feature of classic 2D arcade games is <em class="italic">screen wrap</em>. If the player goes off one side of the screen, they appear on the other side. In practice, you teleport the ship to the other side by instantly changing its position. You’ll need to know the size of the screen, so add the following variable to the top of the script:</p>
			<pre class="source-code">
var screensize = Vector.ZERO</pre>
			<p>And add this to <code>_ready()</code>:</p>
			<pre class="source-code">
screensize = get_viewport_rect().size</pre>
			<p>Later, you can have the game’s main script handle setting <code>screensize</code> for all the game’s objects, but for now, this will allow you to test the screen wrapping with just the player’s scene.</p>
			<p>When<a id="_idIndexMarker154"/> first approaching this problem, you might think you could use the body’s <code>position</code> property and, if it exceeds the bounds of the screen, set it to the opposite side. And if you were using any other node type, that would work just fine; however, when using <code>RigidBody2D</code>, you can’t directly set <code>position</code> because that would conflict with the movement that the physics engine is calculating. A common mistake is to try adding something like this:</p>
			<pre class="source-code">
func _physics_process(delta):
    if position.x &gt; screensize.x:
        position.x = 0
    if position.x &lt; 0:
        position.x = screensize.x
    if position.y &gt; screensize.y:
        position.y = 0
    if position.y &lt; 0:
        position.y = screensize.y</pre>
			<p>And if you wanted to try this with the <code>Area2D</code> in <em class="italic">Coin Dash</em>, it would work perfectly fine. Here, it will fail, trapping the player on the edge of the screen and glitching unpredictably at the corners. So, what is the answer?</p>
			<p>To quote the <code>RigidBody2D</code> documentation:</p>
			<p class="author-quote">Note: You should not change a RigidBody2D’s <code>position</code> or <code>linear_velocity</code> every frame or even very often. If you need to directly affect the body’s state, use <code>_integrate_forces</code>, which allows you to directly access the physics state.</p>
			<p>And in the description for <code>_integrate_forces()</code>:</p>
			<p class="author-quote">(It) Allows you to read and safely modify the simulation state for the object. Use this instead of <code>_physics_process</code> if you need to directly change the body’s position or other physics properties.</p>
			<p>So, the <a id="_idIndexMarker155"/>answer is to use this separate function when you want to directly affect the rigid body’s position. Using <code>_integrate_forces(</code>) gives you access to the body’s <code>PhysicsDirectBodyState2D</code> – a Godot object containing a great deal of useful information about the current state of the body. Since you want to change the body’s location, that means you need to modify its <code>Transform2D</code>.</p>
			<p>A <code>origin</code> property of the <code>Transform2D</code>.</p>
			<p>Using this information, you can implement the wrap-around effect by adding the following code:</p>
			<pre class="source-code">
func _integrate_forces(physics_state):
    var xform = physics_state.transform
    xform.origin.x = wrapf(xform.origin.x, 0, screensize.x)
    xform.origin.y = wrapf(xform.origin.y, 0, screensize.y)
    physics_state.transform = xform</pre>
			<p>The <code>wrapf()</code> function takes a value (the first argument) and “wraps” it between any min/max values you choose. So, if the value goes below <code>0</code>, it becomes <code>screensize.x</code>, and vice versa.</p>
			<p>Note that you’re using <code>physics_state</code> for the parameter name rather than the default of <code>state</code>. This is to avoid confusion since <code>state</code> is already being used to track the player’s state.</p>
			<p>Run the scene again and check that everything is working as expected. Make sure you try wrapping around in all four directions.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Shooting</h2>
			<p>Now it’s <a id="_idIndexMarker157"/>time to give your ship some weapons. When pressing the <code>shoot</code> action, a bullet/laser should be spawned at the front of the ship and then travel in a straight line until it exits the screen. The player isn’t allowed to shoot again<a id="_idIndexMarker158"/> until a small amount of time has passed (also known as a <strong class="bold">cooldown</strong>).</p>
			<h3>Bullet scene</h3>
			<p>This is<a id="_idIndexMarker159"/> the node setup for the bullet:</p>
			<ul>
				<li><code>Area2D</code> named <code>Bullet</code><ul><li><code>Sprite2D</code></li><li><code>CollisionShape2D</code></li><li><code>VisibleOnScreenNotifier2D</code></li></ul></li>
			</ul>
			<p>Use <code>res://assets/laser.png</code> from the assets folder for the <code>Sprite2D</code> and a <code>CapsuleShape2D</code> for the collision shape. You’ll need to set <code>CollisionShape2D</code> to <code>90</code> so that it is oriented correctly. You should also scale <code>Sprite2D</code> down to about half the size: <code>(</code><code>0.5, 0.5)</code>.</p>
			<p>Add the following script to the <code>Bullet</code> node:</p>
			<pre class="source-code">
extends Area2D
@export var speed = 1000
var velocity = Vector2.ZERO
func start(_transform):
    transform = _transform
    velocity = transform.x * speed
func _process(delta):
    position += velocity * delta</pre>
			<p>You’ll call the <code>start()</code> function whenever you spawn a new bullet. By passing it a transform, you can give it the correct position <em class="italic">and</em> rotation – typically that of the ship’s gun (more about this later).</p>
			<p>The <code>VisibleOnScreenNotifier2D</code> is a node that informs you (via a signal) whenever a node becomes visible/invisible. You can use this to automatically delete a bullet <a id="_idIndexMarker160"/>that goes offscreen. Connect the node’s <code>screen_exited</code> signal and add this:</p>
			<pre class="source-code">
func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free()</pre>
			<p>Finally, connect the bullet’s <code>body_entered</code> signal so that it can detect when it hits a rock. The bullet doesn’t need to know anything about rocks, just that it has hit something. When you create the rock, you’ll add it to a group called <code>rocks</code> and give it an <code>explode()</code> method:</p>
			<pre class="source-code">
func _on_bullet_body_entered(body):
    if body.is_in_group("rocks"):
        body.explode()
        queue_free()</pre>
			<h3>Firing bullets</h3>
			<p>The next step <a id="_idIndexMarker161"/>is to create instances of the <code>Bullet</code> scene whenever the player presses the <code>shoot</code> action. However, if you make the bullet a child of the player, then it will move and rotate along with the player instead of moving independently. You could add the bullet to the main scene using <code>get_parent().add_child()</code>, since the <code>Main</code> scene will be the parent of the player when the game is running. However, this would mean that you could no longer run and test the <code>Player</code> scene by itself. Or, if you decided to rearrange your <code>Main</code> scene, making the player a child of some other node, the bullet wouldn’t be added where you expect.</p>
			<p>In <a id="_idIndexMarker162"/>general, it is a bad idea to write code that assumes a fixed tree layout. Especially try to avoid situations where you use <code>get_parent()</code> if at all possible. You may find it difficult to think this way at first, but it will result in a much more modular design and prevent some common mistakes.</p>
			<p>In any case, the <code>SceneTree</code> will always exist, and for this game, it will be fine to make the bullet a child of the tree’s root, which is the <code>Window</code> containing the game.</p>
			<p>Add a <code>Marker2D</code> node to the player and name it <code>Muzzle</code>. This will mark the muzzle of the gun – the location where the bullet will spawn. Set <code>(50, 0)</code> to place it directly in front of the ship.</p>
			<p>Next, add a <code>Timer</code> node and name it <code>GunCooldown</code>. This will provide a cooldown to the gun, preventing a new bullet from firing until a certain amount of time has passed. Check the <strong class="bold">One Shot</strong> and <strong class="bold">Autostart</strong> boxes to “on.”</p>
			<p>Add these new variables to the player’s script:</p>
			<pre class="source-code">
@export var bullet_scene : PackedScene
@export var fire_rate = 0.25
var can_shoot = true</pre>
			<p>Drag the <code>bullet.tscn</code> file onto the new <strong class="bold">Bullet</strong> property in the Inspector.</p>
			<p>Add this line to <code>_ready()</code>:</p>
			<pre class="source-code">
$GunCooldown.wait_time = fire_rate</pre>
			<p>And this to <code>get_input()</code>:</p>
			<pre class="source-code">
if Input.is_action_pressed("shoot") and can_shoot:
    shoot()</pre>
			<p>Now create the <code>shoot()</code> function, which will handle creating the bullet(s):</p>
			<pre class="source-code">
func shoot():
    if state == INVULNERABLE:
        return
    can_shoot = false
    $GunCooldown.start()
    var b = bullet_scene.instantiate()
    get_tree().root.add_child(b)
    b.start($Muzzle.global_transform)</pre>
			<p>When <a id="_idIndexMarker163"/>shooting, you first set <code>can_shoot</code> to <code>false</code> so that the action no longer calls <code>shoot()</code>. Then you add the new bullet as a child of whatever node is the root of the scene tree. Finally, you call the bullet’s <code>start()</code> function and give it the muzzle node’s <em class="italic">global</em> transform. Note that if you used <code>transform</code> here, you’d be giving it the muzzle’s position relative to the player (which is <code>(50, 0)</code>, remember?), and so the bullet would spawn in entirely the wrong place. This is another example of how important it is to understand the distinction between local and global coordinates.</p>
			<p>To allow the gun to shoot again, connect the <code>timeout</code> signal of <code>GunCooldown</code>:</p>
			<pre class="source-code">
func _on_gun_cooldown_timeout():
    can_shoot = true</pre>
			<h3>Testing the player’s ship</h3>
			<p>Create a <a id="_idIndexMarker164"/>new scene using a <code>Node</code> named <code>Main</code> and add a <code>Sprite2D</code> named <code>Background</code> as a child. Use <code>res://assets/space_background.png</code> in the <code>Player</code> to the scene.</p>
			<p>Play the main scene and test that you can fly and shoot.</p>
			<p>Now that your player’s ship works, it’s a good time to pause and check your understanding. Working with rigid bodies can be tricky; take a few minutes to experiment with some of the settings and code from this section. Just make sure to change them back before moving on to the next section, where you’ll add the asteroids to the game.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Adding the rocks</h1>
			<p>The goal of <a id="_idIndexMarker165"/>the game is to destroy the floating space rocks, so now that you can shoot, it’s time to add them. Like the ship, the rocks will use <code>RigidBody2D</code>, which will make them travel in a straight line at a steady speed unless disturbed. They’ll also bounce off each other in a realistic fashion. To make things more interesting, rocks will start out large and, when you shoot them, break into multiple smaller rocks.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Scene setup</h2>
			<p>Start a <a id="_idIndexMarker166"/>new scene with a <code>RigidBody2D</code> node named <code>Rock</code>, and add a <code>Sprite2D</code> child using the <code>res://assets/rock.png</code> texture. Add a <code>CollisionShape2D</code>, but <em class="italic">don’t</em> set its shape yet. Because you’ll be spawning different-sized rocks, the collision shape will need to be set in code and adjusted to the correct size.</p>
			<p>You don’t want the rocks coasting to a stop, so they need to ignore the default linear and angular damping. Set both <code>0</code> and <code>New PhysicsMaterial</code> and then click on it to expand. Set the displayed <code>1</code>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Variable size rocks</h2>
			<p>Attach a <a id="_idIndexMarker167"/>script to <code>Rock</code> and define the member variables:</p>
			<pre class="source-code">
extends RigidBody2D
var screensize = Vector2.ZERO
var size
var radius
var scale_factor = 0.2</pre>
			<p>The <code>Main</code> script will handle spawning new rocks, both at the beginning of a level as well as the smaller rocks that will appear after a large one explodes. A large rock will have a size of <code>3</code>, break into rocks of size <code>2</code>, and so on. The <code>scale_factor</code> is multiplied by <code>size</code> to set the <code>Sprite2D</code> scale, the collision radius, and so on. You can adjust this later to change how big each category of rock is.</p>
			<p>All of this <a id="_idIndexMarker168"/>will be set by the <code>start()</code> method:</p>
			<pre class="source-code">
func start(_position, _velocity, _size):
    position = _position
    size = _size
    mass = 1.5 * size
    $Sprite2D.scale = Vector2.ONE * scale_factor * size
    radius = int($Sprite2D.texture.get_size().x / 2 *
        $Sprite2D.scale.x)
    var shape = CircleShape2D.new()
    shape.radius = radius
    $CollisionShape2d.shape = shape
    linear_velocity = _velocity
    angular_velocity = randf_range(-PI, PI)</pre>
			<p>This is where you calculate the correct collision size based on the rock’s <code>size</code>. Note that since <code>position</code> and <code>size</code> are already in use as class variables, you can use an underscore for the function’s arguments to prevent conflict.</p>
			<p>The rocks also need to wrap around the screen like the player, so use the same technique with <code>_integrate_forces()</code>:</p>
			<pre class="source-code">
func _integrate_forces(physics_state):
    var xform = physics_state.transform
    xform.origin.x = wrapf(xform.origin.x, 0 - radius,
        screensize.x + radius)
    xform.origin.y = wrapf(xform.origin.y, 0 - radius,
        screensize.y + radius)
    physics_state.transform = xform</pre>
			<p>The one <a id="_idIndexMarker169"/>difference here is that including the rock’s <code>radius</code> in the calculation results in smoother-looking teleportation. The rock will appear to fully exit the screen before entering the opposite side. You may want to do the same thing with the player’s ship. Try it and see which you like better.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Instantiating rocks</h2>
			<p>When <a id="_idIndexMarker170"/>new rocks are spawned, the main scene will need to pick a random starting location. To do this, you could use some math to pick a random point along the perimeter of the screen, but instead, you can take advantage of another Godot node type. You’ll draw a path around the edge of the screen, and the script will pick a random location along that path.</p>
			<p>In the <code>Main</code> scene, add a <code>Path2D</code> node and name it <code>RockPath</code>. When you select the node, you will see some new buttons appear at the top of the editor window:</p>
			<div><div><img src="img/B19289_03_09.jpg" alt="Figure 3.9: Path drawing tools"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Path drawing tools</p>
			<p>Select the middle one (<strong class="bold">Add Point</strong>) to draw the path by clicking the points shown in the following screenshot. To make the points align, make sure <strong class="bold">Use Grid Snap</strong> is checked. This option is found in the icon bar at the top of the editor window:</p>
			<div><div><img src="img/B19289_03_10.jpg" alt="Figure 3.10: Enabling grid snapping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: Enabling grid snapping</p>
			<p>Draw the points in the order shown in the following screenshot. After clicking the fourth point, click <a id="_idIndexMarker171"/>the <strong class="bold">Close Curve</strong> button (marked <em class="italic">5</em> in the screenshot) and your path will be complete:</p>
			<div><div><img src="img/B19289_03_11.jpg" alt="Figure 3.11: Path drawing order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: Path drawing order</p>
			<p>Don’t click in the editor window again if you have <code>RockPath</code> selected! If you do, you’ll add additional points to the curve, and your rocks may not spawn where you want them to. You can press <em class="italic">Ctrl</em> + <em class="italic">Z</em> to undo any extra points you may have added.</p>
			<p>Now that the path is defined, add a <code>PathFollow2D</code> as a child of <code>RockPath</code> and name it <code>RockSpawn</code>. This node’s purpose is to automatically move along its parent path using its <strong class="bold">Progress</strong> property, which represents an offset along the path. The higher the offset, the further along the path it goes. Since our path is closed, it will also loop if the offset value is bigger than the path’s length.</p>
			<p>Add the following script to <code>Main.gd</code>:</p>
			<pre class="source-code">
extends Node
@export var rock_scene : PackedScene
var screensize = Vector2.ZERO
func _ready():
    screensize = get_viewport().get_visible_rect().size
    for i in 3:
        spawn_rock(3)</pre>
			<p>You start by <a id="_idIndexMarker172"/>getting the <code>screensize</code> so that you can pass it to the rocks when they’re spawned. Then, you spawn three rocks of size <code>3</code>. Don’t forget to drag <code>rock.tscn</code> onto the <strong class="bold">Rock</strong> property.</p>
			<p>Here is the <code>spawn_rock()</code> function:</p>
			<pre class="source-code">
func spawn_rock(size, pos=null, vel=null):
    if pos == null:
        $RockPath/RockSpawn.progress = randi()
        pos = $RockPath/RockSpawn.position
    if vel == null:
        vel = Vector2.RIGHT.rotated(randf_range(0, TAU)) *
            randf_range(50, 125)
    var r = rock_scene.instantiate()
    r.screensize = screensize
    r.start(pos, vel, size)
    call_deferred("add_child", r)</pre>
			<p>This function serves two purposes. When called with only a <code>size</code> parameter, it picks a random position along the <code>RockPath</code> and a random velocity. However, if those values are provided, it will use them instead. This will let you spawn the smaller rocks at the location of the explosion by specifying their properties.</p>
			<p>Run the game and you should see three rocks floating around, but your bullets don’t affect them.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Exploding rocks</h2>
			<p>The <a id="_idIndexMarker173"/>bullet checks for bodies in the <code>rocks</code> group, so in the <code>Rock</code> scene, select the <code>rocks</code> and click <strong class="bold">Add</strong>:</p>
			<div><div><img src="img/B19289_03_12.jpg" alt="Figure 3.12: Adding a “rocks” group"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12: Adding a “rocks” group</p>
			<p>Now, if you run the game and shoot a rock, you’ll see an error message because the bullet is trying to call the rock’s <code>explode()</code> method, which you haven’t defined yet. This method needs to do three things:</p>
			<ul>
				<li>Remove the rock</li>
				<li>Play an explosion animation</li>
				<li>Notify <code>Main</code> to spawn new, smaller rocks</li>
			</ul>
			<h3>Explosion scene</h3>
			<p>The explosion <a id="_idIndexMarker174"/>will be a separate scene, which you can add to the <code>Rock</code> and later to the <code>Player</code>. It will contain two nodes:</p>
			<ul>
				<li><code>Sprite2D</code> named <code>Explosion</code></li>
				<li><code>AnimationPlayer</code></li>
			</ul>
			<p>For the <code>Sprite2D</code> node’s <code>res://assets/explosion.png</code>. You’ll notice <a id="_idIndexMarker175"/>this is a <code>Sprite2D</code> node supports using them.</p>
			<p>In the Inspector, find the sprite’s <code>8</code>. This<a id="_idIndexMarker176"/> will slice the sprite sheet into its 64 individual images. You can verify this by changing the <code>0</code> and <code>63</code>. Make sure to set it back to <code>0</code> before you continue.</p>
			<div><div><img src="img/B19289_03_13.jpg" alt="Figure 3.13: Sprite Animation settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13: Sprite Animation settings</p>
			<p>The <code>AnimationPlayer</code> node can be used to animate any property of any node. You’ll use it to change the <strong class="bold">Frame</strong> property over time. Start by selecting the node and you’ll see the <strong class="bold">Animation</strong> panel open at the bottom:</p>
			<div><div><img src="img/B19289_03_14.jpg" alt="Figure 3.14: Animation panel"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14: Animation panel</p>
			<p>Click the <code>explosion</code>. Set <code>0.64</code> and <code>0.01</code>. Select the <code>Sprite2D</code> node and you’ll notice that each property in the Inspector now has a key symbol next to it. Clicking on a key will create a <em class="italic">keyframe</em> in the current animation.</p>
			<div><div><img src="img/B19289_03_15.jpg" alt="Figure 3.15: Animation time settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15: Animation time settings</p>
			<p>Click the <a id="_idIndexMarker177"/>key next to the <code>Explosion</code> node’s <code>AnimationPlayer</code> that at time <code>0</code>, you want the sprite’s <code>0</code>.</p>
			<p>Slide the scrubber to time <code>0.64</code> (you can adjust the zoom using the slider if you can’t see it). Set <code>63</code> and click the key again. Now the animation knows to use the last image at the animation’s final time. However, you also need to let the <code>AnimationPlayer</code> know that you want to use all the intermediate values in the times between those two points. At the right side of the animation track is an <strong class="bold">Update Mode</strong> dropdown. It’s currently set to <strong class="bold">Discrete</strong>, and you need to change it to <strong class="bold">Continuous</strong>:</p>
			<div><div><img src="img/B19289_03_16.jpg" alt="Figure 3.16: Setting Update Mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16: Setting Update Mode</p>
			<p>Click the <strong class="bold">Play</strong> button in the <strong class="bold">Animation</strong> panel to see the animation.</p>
			<p>You can now add the explosion to the rock. In the <code>Rock</code> scene, add an instance of <code>Explosion</code> and click the eye icon next to the node to make it hidden. Add this line to <code>start()</code>:</p>
			<pre class="source-code">
$Explosion.scale = Vector2.ONE * 0.75 * size</pre>
			<p>This will <a id="_idIndexMarker178"/>ensure the explosion is scaled to match the rock’s size.</p>
			<p>Add a signal called <code>exploded</code> at the top of the script, then add the <code>explode()</code> function, which will be called when the bullet hits the rock:</p>
			<pre class="source-code">
func explode():
    $CollisionShape2D.set_deferred("disabled", true)
    $Sprite2d.hide()
    $Explosion/AnimationPlayer.play("explosion")
    $Explosion.show()
    exploded.emit(size, radius, position, linear_velocity)
    linear_velocity = Vector2.ZERO
    angular_velocity = 0
    await $Explosion/AnimationPlayer.animation_finished
    queue_free()</pre>
			<p>Here, you hide the rock and play the explosion, waiting for it to finish before removing the rock. When you emit the <code>exploded</code> signal, you also include all the rock’s information, so that <code>spawn_rock()</code> in <code>Main</code> will be able to spawn the smaller rocks at the same location.</p>
			<p>Test the game and check that you can see explosions when you shoot the rocks.</p>
			<h3>Spawning smaller rocks</h3>
			<p>The <code>Rock</code> scene is <a id="_idIndexMarker179"/>emitting the signal, but <code>Main</code> isn’t listening for it yet. You can’t connect the signal in the <code>spawn_rock()</code>:</p>
			<pre class="source-code">
r.exploded.connect(self._on_rock_exploded)</pre>
			<p>This <a id="_idIndexMarker180"/>connects the rock’s signal to a function in <code>Main</code>, which you also need to create:</p>
			<pre class="source-code">
func _on_rock_exploded(size, radius, pos, vel):
    if size &lt;= 1:
        return
    for offset in [-1, 1]:
        var dir = $Player.position.direction_to(pos)
            .orthogonal() * offset
        var newpos = pos + dir * radius
        var newvel = dir * vel.length() * 1.1
        spawn_rock(size - 1, newpos, newvel)</pre>
			<p>In this function, you create two new rocks unless the rock that was just destroyed was of size <code>1</code> (the smallest size). The <code>offset</code> loop variable ensures that the two new rocks travel in opposite directions (that is, one’s velocity will be negative). The <code>dir</code> variable finds the vector between the player and the rock, then uses <code>orthogonal()</code> to get a vector that’s perpendicular. This ensures that the new rocks don’t fly straight toward the player.</p>
			<div><div><img src="img/B19289_03_17.jpg" alt="Figure 3.17: Explosion diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17: Explosion diagram</p>
			<p>Play the game once again and check that everything is working as expected.</p>
			<p>This is a <a id="_idIndexMarker181"/>good place to stop and review what you’ve done so far. You’ve completed all the basic functionality of the game: the player can fly around and shoot; the rocks float, bounce, and explode; and new rocks are spawned. You should be feeling more comfortable using rigid bodies at this point. In the next section, you’ll start building the interface to allow the player to start the game and see important information during gameplay.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Creating the UI</h1>
			<p>Creating a UI<a id="_idIndexMarker182"/> for your game can be very complex, or at least time-consuming. Precisely placing individual elements and ensuring<a id="_idIndexMarker183"/> they work across different-sized screens and devices is the least interesting part of game development for many programmers. Godot provides a wide variety of <code>Control</code> nodes to assist in this process. Learning how to use the various <code>Control</code> nodes will help lessen the pain of creating a polished UI.</p>
			<p>For this game, you don’t need a very complex UI. The game needs to provide the following information and interactions:</p>
			<ul>
				<li>Start button</li>
				<li>Status message (such as “Get Ready” or “Game Over”)</li>
				<li>Score</li>
				<li>Lives counter</li>
			</ul>
			<p>Here is a <a id="_idIndexMarker184"/>preview of what you will make:</p>
			<div><div><img src="img/B19289_03_18.jpg" alt="Figure 3.18: UI layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18: UI layout</p>
			<p>Create a new <a id="_idIndexMarker185"/>scene and add a <code>CanvasLayer</code> node with the name <code>HUD</code> as the root node. You’ll build the UI on this layer using the <code>Control</code> node’s layout features.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Layout</h2>
			<p>Godot’s <code>Control</code> nodes include<a id="_idIndexMarker186"/> a number of specialized containers. These nodes can be nested inside each other to create the exact layout you need. For example, a <code>MarginContainer</code> automatically adds padding around its contents, while <code>HBoxContainer</code> and <code>VBoxContainer</code> organize their contents in rows or columns, respectively.</p>
			<p>Follow these steps to build the layout:</p>
			<ol>
				<li>Start by adding <code>Timer</code> and <code>MarginContainer children</code>, which will hold the score and life counters. In the <strong class="bold">Layout</strong> dropdown, select <strong class="bold">Top Wide</strong>.</li>
			</ol>
			<div><div><img src="img/B19289_03_19.jpg" alt="Figure 3.19: Top Wide control alignment"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19: Top Wide control alignment</p>
			<ol>
				<li value="2">In the Inspector, set the four margins in <strong class="bold">Theme Overrides/Constants</strong> to 20.</li>
				<li>Set <a id="_idIndexMarker187"/>the <code>Timer</code> to on and its <code>2</code>.</li>
				<li>As a child of the container, add an <code>HBoxContainer</code>, which will position the score counter on the left and the lives counter on the right. Under this container, add a <code>Label</code> (name it <code>ScoreLabel</code>) and another <code>HBoxContainer</code> (named <code>LivesCounter</code>).</li>
			</ol>
			<p>Set the <code>ScoreLabel's</code> <code>0</code>, and under <code>res://assets/kenvector_future_thin.ttf</code> and setting the font size to <code>64</code>.</p>
			<ol>
				<li value="5">Select <code>LivesCounter</code> and set <code>20</code>, then add a child <code>TextureRect</code> and name it <code>L1</code>. Drag <code>res://assets/player_small.png</code> to the <code>L1</code> node selected and press <em class="italic">duplicate</em> (<em class="italic">Ctrl</em> + <em class="italic">D</em>) twice to create <code>L2</code> and <code>L3</code> (they’ll be named automatically). During the game, the <code>HUD</code> will show or hide these three textures to indicate how many lives the player has left.</li>
				<li>In a larger, more complex UI, you might save this section as its own scene and embed it in other section(s) of the UI. However, this game only needs a few more elements, so it’s fine to combine them all in one scene.</li>
				<li>As a child of <code>HUD</code>, add a <code>VBoxContainer</code>, and inside it, add a <code>Label</code> named <code>Message</code> and a <code>TextureButton</code> named <code>StartButton</code>. Set the layout of the <code>VBoxContainer</code> to <code>100</code>.</li>
				<li>In<a id="_idIndexMarker188"/> the <code>res://assets</code> folder, there are two textures for <code>StartButton</code>, one normal (<code>play_button.png</code>) and one to show when the mouse is hovering over it (<code>'play_button_h.png</code>). Drag these to <strong class="bold">Textures/Normal</strong> and <strong class="bold">Textures/Hover</strong> in the Inspector. Set the button’s <strong class="bold">Layout/Container Sizing/Horizontal</strong> to <strong class="bold">Shrink Center</strong> so that it will be centered horizontally.</li>
				<li>Set the <code>Message</code> text to “Space Rocks!” and set its font using the same settings as <code>ScoreLabel</code>. Set <strong class="bold">Horizontal Alignment</strong> to <strong class="bold">Center</strong>.</li>
			</ol>
			<p>When finished, your scene tree should look like this:</p>
			<div><div><img src="img/B19289_03_20.jpg" alt="Figure 3.20: HUD node layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20: HUD node layout</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Scripting the UI</h2>
			<p>You’ve <a id="_idIndexMarker189"/>completed the UI layout, now add a script to <code>HUD</code>. Since the nodes you’ll need to reference are located under containers, you can store references to them in variables at the start. Since this needs to happen after nodes are added to the tree, you can use the <code>@onready</code> decorator to cause the variable’s value to be set at the same time as the <code>_ready()</code> function runs.</p>
			<pre class="source-code">
extends CanvasLayer
signal start_game
@onready var lives_counter = $MarginContainer/HBoxContainer/LivesCounter.get_children()
@onready var score_label = $MarginContainer/HBoxContainer/ScoreLabel
@onready var message = $VBoxContainer/Message
@onready var start_button = $VBoxContainer/StartButton</pre>
			<p>You’ll <a id="_idIndexMarker190"/>emit the <code>start_game</code> signal when the player clicks the <code>StartButton</code>. The <code>lives_counter</code> variable is an array holding references to the three life-counter images so they can be hidden/shown as needed.</p>
			<p>Next, you need functions to handle updating the displayed information:</p>
			<pre class="source-code">
func show_message(text):
    message.text = text
    message.show()
    $Timer.start()
func update_score(value):
    score_label.text = str(value)
func update_lives(value):
    for item in 3:
        lives_counter[item].visible = value &gt; item</pre>
			<p><code>Main</code> will call these functions whenever the relevant value changes. Now add a function to handle the end of the game:</p>
			<pre class="source-code">
func game_over():
    show_message("Game Over")
    await $Timer.timeout
    start_button.show()</pre>
			<p>Connect the <code>pressed</code> signal of <code>StartButton</code> and the <code>timeout</code> signal of <code>Timer</code>:</p>
			<pre class="source-code">
func _on_start_button_pressed():
    start_button.hide()
    start_game.emit()
func _on_timer_timeout():
    message.hide()
    message.text = ""</pre>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>The Main scene’s UI code</h2>
			<p>Add an <a id="_idIndexMarker191"/>instance of the <code>HUD</code> scene to the <code>Main</code> scene. Add these variables to <code>main.gd</code>:</p>
			<pre class="source-code">
var level = 0
var score = 0
var playing = false</pre>
			<p>And a function to handle starting a new game:</p>
			<pre class="source-code">
func new_game():
    # remove any old rocks from previous game
    get_tree().call_group("rocks", "queue_free")
    level = 0
    score = 0
    $HUD.update_score(score)
    $HUD.show_message("Get Ready!")
    $Player.reset()
    await $HUD/Timer.timeout
    playing = true</pre>
			<p>Note the <code>$Player.reset()</code> line – don’t worry, you’ll add that soon.</p>
			<p>When the player destroys all the rocks, they’ll advance to the next level:</p>
			<pre class="source-code">
func new_level():
    level += 1
    $HUD.show_message("Wave %s" % level)
    for i in level:
        spawn_rock(3)</pre>
			<p>You’ll call this<a id="_idIndexMarker192"/> function every time the level changes. It announces the level number and spawns a number of rocks to match. Note that since you initialized <code>level</code> to <code>0</code>, this will set it to <code>1</code> for the first level. You should also remove the code that’s spawning rocks in <code>_ready()</code> – you don’t need that anymore.</p>
			<p>To detect when the level has ended, you need to check how many rocks are left:</p>
			<pre class="source-code">
func _process(delta):
    if not playing:
        return
    if get_tree().get_nodes_in_group("rocks").size() == 0:
        new_level()</pre>
			<p>Next, you need to connect the <code>HUD</code>’s <code>start_game</code> signal to the <code>new_game()</code> function of Main.</p>
			<p>Select the <code>HUD</code> instance in <code>Main</code> and find its <code>start_game</code> signal in the <code>Main</code>, and you can select the <code>new_game()</code> function:</p>
			<div><div><img src="img/B19289_03_21.jpg" alt="Figure 3.21: Connecting a signal to an existing function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21: Connecting a signal to an existing function</p>
			<p>Add this <a id="_idIndexMarker193"/>function to handle what happens when the game ends:</p>
			<pre class="source-code">
func game_over():
    playing = false
    $HUD.game_over()</pre>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Player code</h2>
			<p>Add <a id="_idIndexMarker194"/>the new signals and a new variable to <code>player.gd</code>:</p>
			<pre class="source-code">
signal lives_changed
signal dead
var reset_pos = false
var lives = 0: set = set_lives
func set_lives(value):
    lives = value
    lives_changed.emit(lives)
    if lives &lt;= 0:
        change_state(DEAD)
    else:
        change_state(INVULNERABLE)</pre>
			<p>For <a id="_idIndexMarker195"/>the <code>lives</code> variable, you’ve added something called<a id="_idIndexMarker196"/> a <code>lives</code> changes, the <code>set_lives()</code> function will be called. This lets you automatically emit the signal as well as checking when it reaches <code>0</code>.</p>
			<p>The <code>reset()</code> function is called by <code>Main</code> when a new game starts:</p>
			<pre class="source-code">
func reset():
    reset_pos = true
    $Sprite2d.show()
    lives = 3
    change_state(ALIVE)</pre>
			<p>Resetting the player means setting its position back to the center of the screen. As we saw before, that needs to be done in <code>_integrate_forces()</code> in order to work. Add this to that function:</p>
			<pre class="source-code">
if reset_pos:
    physics_state.transform.origin = screensize / 2
    reset_pos = false</pre>
			<p>Back in the <code>Main</code> scene, select the <code>Player</code> instance and find its <code>lives_changed</code> signal in the <code>HUD</code> node and type <code>update_lives</code> in <strong class="bold">Receiver Method</strong>.</p>
			<div><div><img src="img/B19289_03_22.jpg" alt="Figure 3.22: Connecting the player signal to HUD"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22: Connecting the player signal to HUD</p>
			<p>In this<a id="_idIndexMarker197"/> section, you made a much more complex UI than in previous projects, including some new <code>Control</code> nodes such as <code>TextureProgressBar</code>, and used signals to connect everything together. In the next section, you’ll handle the end of the game: what should happen when the player dies.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Ending the game</h1>
			<p>In this <a id="_idIndexMarker198"/>section, you’ll make the player detect when it is hit by rocks, add an invulnerability feature, and end the game when the player runs out of lives.</p>
			<p>Add an instance of the <code>Explosion</code> scene to the <code>Player</code> scene and uncheck its <code>Timer</code> node named <code>InvulnerabilityTimer</code> and set <code>2</code> and <strong class="bold">One Shot</strong> to “on.”</p>
			<p>You’ll emit the <code>dead</code> signal to notify <code>Main</code> that the game should end. Before that, however, you<a id="_idIndexMarker199"/> need to update the state machine to do a little more with each state:</p>
			<pre class="source-code">
func change_state(new_state):
    match new_state:
        INIT:
            $CollisionShape2D.set_deferred("disabled",
                true)
            $Sprite2D.modulate.a = 0.5
        ALIVE:
            $CollisionShape2d.set_deferred("disabled",
                false)
            $Sprite2d.modulate.a = 1.0
        INVULNERABLE:
            $CollisionShape2d.set_deferred("disabled",
                true)
            $Sprite2d.modulate.a = 0.5
            $InvulnerabilityTimer.start()
        DEAD:
            $CollisionShape2d.set_deferred("disabled",
                true)
            $Sprite2d.hide()
            linear_velocity = Vector2.ZERO
            dead.emit()
    state = new_state</pre>
			<p>The <code>modulate.a</code> property of a sprite sets its alpha channel (transparency). Setting it to <code>0.5</code> makes <a id="_idIndexMarker200"/>it semi-transparent, while <code>1.0</code> is solid.</p>
			<p>After entering the <code>INVULNERABLE</code> state, you start the timer. Connect its <code>timeout</code> signal:</p>
			<pre class="source-code">
func _on_invulnerability_timer_timeout():
    change_state(ALIVE)</pre>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Detecting collisions between rigid bodies</h2>
			<p>When you<a id="_idIndexMarker201"/> fly around, the ship bounces off rocks because both are rigid bodies. However, if you want to make something happen when two rigid bodies collide, you need to enable <code>Player</code> scene, select the <code>Player</code> node, and in the Inspector, set <code>1</code>. Now the player will emit a signal when it comes into contact with another body. Click on the <code>body_entered</code> signal:</p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        body.explode()
        lives -= 1
        explode()
func explode():
    $Explosion.show()
    $Explosion/AnimationPlayer.play("explosion")
    await $Explosion/AnimationPlayer.animation_finished
    $Explosion.hide()</pre>
			<p>Now go to the <code>Main</code> scene and connect the <code>Player</code> instance’s <code>dead</code> signal to the <code>game_over()</code> method. Play the game and try running into a rock. Your ship should explode, become invulnerable for two seconds, and lose one life. Also check that the game ends if you get hit three times.</p>
			<p>In this <a id="_idIndexMarker203"/>section, you learned about rigid body collisions and used them to handle the ship colliding with rocks. The full game cycle is now complete: the start screen leads to gameplay, which ends with a game over display. In the remaining sections of the chapter, you’ll add some additional features to the game, such as a pause function.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Pausing the game</h1>
			<p>Many<a id="_idIndexMarker204"/> games require some sort of pause mode to allow the player to take a break from the action. In Godot, pausing is a function of the <code>SceneTree</code> and can be set using its <code>paused</code> property. When the <code>SceneTree</code> is paused, three things happen:</p>
			<ul>
				<li> The physics thread stops running</li>
				<li> <code>_process()</code> and <code>_physics_process()</code> are no longer called on any nodes</li>
				<li> The <code>_input()</code> and <code>_input_event()</code> methods are also not called for inputs</li>
			</ul>
			<p>When pause mode is triggered, every node in the running game reacts accordingly, based on how you’ve configured it. This behavior is set via the node’s <strong class="bold">Process/Mode</strong> property, which you’ll find near the bottom of the Inspector list.</p>
			<p>The pause mode can be set to the following values:</p>
			<ul>
				<li><code>Inherit</code> – The node uses the same mode as its parent</li>
				<li><code>Pausable</code> – The node pauses when the scene tree is paused</li>
				<li><code>When Paused</code> – The node only runs when the tree is paused</li>
				<li><code>Always</code> – The node always runs, ignoring the tree’s paused state</li>
				<li><code>Disabled</code> – The node never runs, ignoring the tree’s paused state</li>
			</ul>
			<p>Open the <code>pause</code>. Assign a key you’d like to use to toggle pause mode. <code>P</code> is a good choice.</p>
			<p>Add the<a id="_idIndexMarker205"/> following function to <code>Main.gd</code>:</p>
			<pre class="source-code">
func _input(event):
    if event.is_action_pressed("pause"):
        if not playing:
            return
        get_tree().paused = not get_tree().paused
        var message = $HUD/VBoxContainer/Message
        if get_tree().paused:
            message.text = "Paused"
            message.show()
        else:
            message.text = ""
            message.hide()</pre>
			<p>This code detects pressing the key and toggles the tree’s <code>paused</code> state to the opposite of its current state. It also displays <strong class="bold">Paused</strong> on the screen so that it doesn’t just appear that the game has frozen.</p>
			<p>If you were to run the game now, you’d have a problem – all nodes are paused, including <code>Main</code>. That means it’s not processing <code>_input()</code> anymore, so it can’t detect the input again to unpause the game! To fix this, set <code>Main</code> node to <strong class="bold">Always</strong>.</p>
			<p>The pause function is a very useful one to know about. You can use this technique in any game you make, so review it to make sure you understand how it works. You can even try going back and adding it to <em class="italic">Coin Dash</em>. Our next section adds to the action by adding enemies to the game.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Enemies</h1>
			<p>Space is <a id="_idIndexMarker206"/>filled with more dangers than just rocks. In this section, you’ll create an enemy spaceship that will periodically appear and shoot at the player.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Following a path</h2>
			<p>When the <a id="_idIndexMarker207"/>enemy appears, it should follow a path across the screen. It’ll also look better if it’s not just a straight line. To keep it from looking too repetitive, you can create multiple paths and randomly choose one when the enemy appears.</p>
			<p>Create a new scene and add a <code>Node</code>. Name it <code>EnemyPaths</code> and save it. To draw the path, add a <code>Path2D</code> node. As you saw earlier, this node allows you to draw a series of connected points. Selecting this node displays a new menu bar:</p>
			<div><div><img src="img/B19289_03_23.jpg" alt="Figure 3.23: Path drawing options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23: Path drawing options</p>
			<p>These buttons let you draw and modify the path’s points. Click the one with the green <strong class="bold">+</strong> symbol to add points. Click to start the path somewhere just outside the game window, and then click a few more points to make a curve. Note that the arrows indicate the direction of the path. Don’t worry about making it smooth yet:</p>
			<div><div><img src="img/B19289_03_24.jpg" alt="Figure 3.24: An example path"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24: An example path</p>
			<p>When the enemy follows the path, it will not look very smooth when it hits the sharp corners. To smooth the curve, click the second button in the path toolbar (its tooltip says <strong class="bold">Select Control Points</strong>). Now, if you click and drag any of the curve’s points, you will add a <a id="_idIndexMarker208"/>control point that allows you to curve the line at that point. Smoothing the line above results in something like this:</p>
			<div><div><img src="img/B19289_03_25.jpg" alt="Figure 3.25: Using control points"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25: Using control points</p>
			<p>Add two or three more <code>Path2D</code> nodes to the scene and draw the paths however you like. Adding loops and curves rather than straight lines will make the enemy look more dynamic (and make it harder to hit). Remember that the first point you click will be the start of the path, so make sure to start them on different sides of the screen for variety. Here are three example paths:</p>
			<div><div><img src="img/B19289_03_26.jpg" alt="Figure 3.26: Adding multiple paths"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26: Adding multiple paths</p>
			<p>Save the scene. You’ll add this to the enemy’s scene to give it the paths it can follow.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Enemy scene</h2>
			<p>Create a <a id="_idIndexMarker209"/>new scene for the enemy, using an <code>Area2D</code> as its root node. Add a <code>Sprite2D</code> child and use <code>res://assets/enemy_saucer.png</code> as its <code>3</code> so that you can choose between the different colored saucers:</p>
			<ol>
				<li>As you’ve done before, add a <code>CollisionShape2D</code> and give it a <code>CircleShape2D</code> scaled to cover the image. Add an instance of the <code>EnemyPaths</code> scene and an <code>AnimationPlayer</code>. In the <code>AnimationPlayer</code>, you’ll add an animation to create a flash effect when the saucer is hit.</li>
				<li>Add an animation named <code>flash</code>. Set <code>0.25</code> and <code>0.01</code>. The property you’ll be animating is the <code>Sprite2D</code>’s <code>0.04</code> and change the <code>0.04</code> and change the color back to white.</li>
				<li>Repeat this process two more times so that you have three flashes in total.</li>
				<li>Add an instance of the <code>Explosion</code> scene and hide it. Add a <code>Timer</code> node named <code>GunCooldown</code> to control how often the enemy will shoot. Set <code>1.5</code> and <strong class="bold">Autostart</strong> to on.</li>
				<li>Add a script to the enemy and connect the timer’s <code>timeout</code>. Don’t add anything to the function yet.</li>
				<li>In the <code>enemies</code>. As with the rocks, this will give you a way to identify the object, even if there are multiple enemies on the screen at the same time.</li>
			</ol>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Moving the enemy</h2>
			<p>To begin, you’ll <a id="_idIndexMarker210"/>write the code to select a path and move the enemy along it:</p>
			<pre class="source-code">
extends Area2D
@export var bullet_scene : PackedScene
@export var speed = 150
@export var rotation_speed = 120
@export var health = 3
var follow = PathFollow2D.new()
var target = null
func _ready():
    $Sprite2D.frame = randi() % 3
    var path = $EnemyPaths.get_children()[randi() %
        $EnemyPaths.get_child_count()]
    path.add_child(follow)
    follow.loop = false</pre>
			<p>Recall that the <code>PathFollow2D</code> node automatically moves along a parent <code>Path2D</code>. By default, it loops around the path when it reaches the end, so you need to set that to <code>false</code> to disable it.</p>
			<p>The next step is to move along the path and remove the enemy when it reaches the end of the path:</p>
			<pre class="source-code">
func _physics_process(delta):
    rotation += deg_to_rad(rotation_speed) * delta
    follow.progress += speed * delta
    position = follow.global_position
    if follow.progress_ratio &gt;= 1:
        queue_free()</pre>
			<p>You can <a id="_idIndexMarker211"/>detect the end of the path when <code>progress</code> is greater than the total path length. However, it’s more straightforward to use <code>progress_ratio</code>, which varies from zero to one over the length of the path, so you don’t need to know how long each path is.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Spawning enemies</h2>
			<p>In the <code>Main</code> scene, add<a id="_idIndexMarker212"/> a new <code>Timer</code> node called <code>EnemyTimer</code>. Set its <code>main.gd</code>, add a variable to reference the enemy scene:</p>
			<pre class="source-code">
@export var enemy_scene : PackedScene</pre>
			<p>Add this line to <code>new_level()</code>:</p>
			<pre class="source-code">
$EnemyTimer.start(randf_range(5, 10))</pre>
			<p>Connect the <code>EnemyTimer</code>’s <code>timeout</code> signal:</p>
			<pre class="source-code">
func _on_enemy_timer_timeout():
    var e = enemy_scene.instantiate()
    add_child(e)
    e.target = $Player
    $EnemyTimer.start(randf_range(20, 40))</pre>
			<p>This code instances the enemy whenever <code>EnemyTimer</code> times out. You don’t want another enemy for a while, so the timer is restarted with a longer delay.</p>
			<p>Play the game, and you should see a saucer appear and fly along its path.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Shooting and collisions</h2>
			<p>The enemy needs to <a id="_idIndexMarker213"/>shoot at the player as well as react when hit by the player or the player’s bullets.</p>
			<p>The enemy’s bullet <a id="_idIndexMarker214"/>will be similar to the player’s, but we’ll use a different texture. You can create it again from scratch or use the following process to reuse the node setup.</p>
			<p>Open the <code>Bullet</code> scene and choose <code>enemy_bullet.tscn</code> (afterward, don’t forget to rename the root node as well). Remove the script by clicking the <strong class="bold">Detach the script</strong> button. Disconnect the signal connections by clicking the <strong class="bold">Node</strong> tab and choosing <strong class="bold">Disconnect</strong>. You can see which nodes have their signals connected by looking for the <img src="img/B19289_03_27.png" alt=""/> icon next to the node name.</p>
			<p>Replace the sprite’s texture with the <code>laser_green.png</code> image, and add a new script to the root node.</p>
			<p>The script for the enemy bullet will be very similar to the regular bullet. Connect the area’s <code>body_entered</code> signal and the <code>screen_exited</code> signal of <code>VisibleOnScreenNotifier2D</code>:</p>
			<pre class="source-code">
extends Area2D
@export var speed = 1000
func start(_pos, _dir):
    position = _pos
    rotation = _dir.angle()
func _process(delta):
    position += transform.x * speed * delta
func _on_body_entered(body):
    queue_free()
func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free()</pre>
			<p>Note <a id="_idIndexMarker215"/>that you’ll need to specify a position and direction for the bullet. That’s because, unlike the player, who always shoots <a id="_idIndexMarker216"/>forward, the enemy will always shoot toward the player.</p>
			<p>For now, the bullet won’t do any damage to the player. You’ll be adding a shield to the player in the next section, so you can add it at that time.</p>
			<p>Save the scene and drag it into the <code>Enemy</code>.</p>
			<p>In <code>enemy.gd</code>, add a variable for some random variation to the bullet, and the <code>shoot()</code> function:</p>
			<pre class="source-code">
@export var bullet_spread = 0.2
func shoot():
    var dir =
       global_position.direction_to(target.global_position)
    dir = dir.rotated(randf_range(-bullet_spread,
       bullet_spread))
    var b = bullet_scene.instantiate()
    get_tree().root.add_child(b)
    b.start(global_position, dir)</pre>
			<p>First, you find the vector pointing to the player’s position, then add a little bit of randomness so that it can “miss.”</p>
			<p>Call the <code>shoot()</code> function whenever <code>GunCooldown</code> times out:</p>
			<pre class="source-code">
func _on_gun_cooldown_timeout():
    shoot()</pre>
			<p>For an extra challenge, you can make the enemy shoot in pulses or multiple rapid shots:</p>
			<pre class="source-code">
func shoot_pulse(n, delay):
    for i in n:
        shoot()
        await get_tree().create_timer(delay).timeout</pre>
			<p>This <a id="_idIndexMarker217"/>will shoot a given number of bullets, <code>n</code>, with <code>delay</code> seconds between them. You can call this instead when the cooldown triggers:</p>
			<pre class="source-code">
func _on_gun_cooldown_timeout():
    shoot_pulse(3, 0.15)</pre>
			<p>This will <a id="_idIndexMarker218"/>shoot a pulse of <code>3</code> bullets with <code>0.15</code> seconds between them. Tough to dodge!</p>
			<p>Next, the enemy needs to take damage when it’s hit by a shot from the player. It will flash using the animation you made and then explode when its health reaches <code>0</code>.</p>
			<p>Add these functions to <code>enemy.gd</code>:</p>
			<pre class="source-code">
func take_damage(amount):
    health -= amount
    $AnimationPlayer.play("flash")
    if health &lt;= 0:
        explode()
func explode():
    speed = 0
    $GunCooldown.stop()
    $CollisionShape2D.set_deferred("disabled", true)
    $Sprite2D.hide()
    $Explosion.show()
    $Explosion/AnimationPlayer.play("explosion")
    await $Explosion/AnimationPlayer.animation_finished
    queue_free()</pre>
			<p>Also, connect <a id="_idIndexMarker219"/>the enemy’s <code>body_entered</code> signal<a id="_idIndexMarker220"/> so that the enemy will explode if the player runs into it:</p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        return
    explode()</pre>
			<p>Again, you’re waiting for the player shield to be implemented before doing damage to the player, so for now, this collision only destroys the enemy.</p>
			<p>Currently, the player’s bullet is only detecting rocks because its <code>body_entered</code> signal isn’t triggered by the enemy, which is an <code>Area2D</code>. To detect the enemy, go to the <code>Bullet</code> scene and connect the <code>area_entered</code> signal:</p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("enemies"):
        area.take_damage(1)</pre>
			<p>Try playing the game again and you’ll be doing battle with an aggressive alien opponent! Verify that all the collision combinations are being handled (except for the enemy shooting the player). Also note that the enemy’s bullets can be blocked by rocks – maybe you can hide behind them for cover!</p>
			<p>Now that the game has enemies, it’s a lot more challenging. If you still find it too easy, try increasing the enemy’s properties: how often it appears, how much damage it does, and how many shots it takes to destroy it. It’s OK if you make it too hard because, in the next section, you’ll give the player a little help by adding a shield to absorb damage.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Player shield</h1>
			<p>In this<a id="_idIndexMarker221"/> section, you’ll add a shield to the player and a display element to the <code>HUD</code> showing the current shield level.</p>
			<p>First, add the following to the top of the <code>player.gd</code> script:</p>
			<pre class="source-code">
signal shield_changed
@export var max_shield = 100.0
@export var shield_regen = 5.0
var shield = 0: set = set_shield
func set_shield(value):
    value = min(value, max_shield)
    shield = value
    shield_changed.emit(shield / max_shield)
    if shield &lt;= 0:
        lives -= 1
        explode()</pre>
			<p>The <code>shield</code> variable works similarly to <code>lives</code>, emitting a signal whenever it changes. Since the value will be added to by the shield’s regeneration, you need to make sure it doesn’t go above the <code>max_shield</code> value. Then, when you emit the <code>shield_changed</code> signal, you pass the ratio of <code>shield</code> / <code>max_shield</code> rather than the actual value. This way, the <code>HUD</code>’s display doesn’t need to know anything about how big the shield actually is, just its percentage.</p>
			<p>You should also remove the <code>explode()</code> line from <code>_on_body_entered()</code>, since you now don’t want just hitting a rock to blow up the ship – that will now only happen when the shield runs out.</p>
			<p>Hitting a rock will damage the shield, and bigger rocks should do more damage:</p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        shield -= body.size * 25
        body.explode()</pre>
			<p>The enemy’s <a id="_idIndexMarker222"/>bullets should also do damage, so make this change to <code>enemy_bullet.gd</code>:</p>
			<pre class="source-code">
@export var damage = 15
func _on_body_entered(body):
    if body.name == "Player":
        body.shield -= damage
    queue_free()</pre>
			<p>Also, running into the enemy should damage the player, so update this in <code>enemy.gd</code>:</p>
			<pre class="source-code">
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        return
    explode()
    body.shield -= 50</pre>
			<p>If the player’s shield runs out and they lose a life, you should reset the shield to its maximum. Add this line to <code>set_lives()</code>:</p>
			<pre class="source-code">
shield = max_shield</pre>
			<p>The last addition to the player script is to regenerate the shield each frame. Add this line to <code>_process()</code> in <code>player.gd</code>:</p>
			<pre class="source-code">
shield += shield_regen * delta</pre>
			<p>Now that the code is complete, you need to add a new display element to the <code>HUD</code> scene. Rather than display the shield’s value as a number, you’ll <a id="_idIndexMarker223"/>make a <code>TextureProgressBar</code> is a <code>Control</code> node that displays a given value as a filled bar. It also allows you to assign a texture to be used for the bar.</p>
			<p>Go to the <code>HUD</code> scene <a id="_idIndexMarker224"/>and add two new nodes as children of the existing <code>HBoxContainer</code>: <code>TextureRect</code> and <code>TextureProgressBar</code>. Rename <code>TextureProgressBar</code> to <code>ShieldBar</code>. Place them after the <code>Score</code> label and before <code>LivesCounter</code>. Your node setup should look like this:</p>
			<div><div><img src="img/B19289_03_28.jpg" alt="Figure 3.27: Updated HUD node layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27: Updated HUD node layout</p>
			<p>Drag <code>res://assets/shield_gold.png</code> into the <code>TextureRect</code>. This will be an icon indicating that this bar shows the shield value. Change <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep Centered</strong> so that the texture won’t be distorted.</p>
			<p>The <code>ShieldBar</code> has three <code>res://assets/bar_green_200.png</code> into this property. The other two texture properties let you customize the appearance by setting an image to be drawn above or below the progress texture. Drag <code>res://assets/bar_glass_200.png</code> into the <strong class="bold">Over</strong> property.</p>
			<p>In the <code>0</code> and <code>1</code>, as this bar will show the ratio of the shield to its maximum, not its numerical value. This means <code>0.01</code>. <code>.75</code> to see the bar partly filled. Also, in the <strong class="bold">Layout/Container Sizing</strong> section, check the <strong class="bold">Expand</strong> box and set <strong class="bold">Vertical</strong> to <strong class="bold">Shrink Center</strong>.</p>
			<p>The <code>HUD</code> should look like this when you’re done:</p>
			<div><div><img src="img/B19289_03_29.jpg" alt="Figure 3.28: Updated HUD with shield bar"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.28: Updated HUD with shield bar</p>
			<p>You can now update the script to set the value of the shield bar, as well as to make it change color as it gets closer to zero. Add these variables to <code>hud.gd</code>:</p>
			<pre class="source-code">
@onready var shield_bar =
    $MarginContainer/HBoxContainer/ShieldBar
var bar_textures = {
    "green": preload("res://assets/bar_green_200.png"),
    "yellow": preload("res://assets/bar_yellow_200.png"),
    "red": preload("res://assets/bar_red_200.png")
}</pre>
			<p>In addition to the green bar, you also have red and yellow bars in the <code>assets</code> folder. This allows you to change the shield bar’s color as the value decreases. Loading the textures in this<a id="_idIndexMarker226"/> way makes them easier to access later in the script when you want to assign the appropriate image to the bar:</p>
			<pre class="source-code">
func update_shield(value):
    shield_bar.texture_progress = bar_textures["green"]
    if value &lt; 0.4:
        shield_bar.texture_progress = bar_textures["red"]
    elif value &lt; 0.7:
        shield_bar.texture_progress = bar_textures["yellow"]
    shield_bar.value = value</pre>
			<p>Finally, click on the <code>Main</code> scene’s <code>Player</code> node and connect the <code>shield_changed</code> signal to the <code>HUD</code>’s <code>update_shield()</code> function.</p>
			<p>Run the game and verify that the shield is working. You may want to increase or decrease the shield regeneration rate to give it a speed you’re happy with. When you’re ready to move on, in the next section, you’ll add some sound to the game.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Sound and visual effects</h1>
			<p>The<a id="_idIndexMarker227"/> structure and gameplay of the game is complete. In this section, you’ll add some additional effects to the game to improve the game experience.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Sound and music</h2>
			<p>In <a id="_idIndexMarker228"/>the <code>res://assets/sounds</code> folder are several audio effects for the game. To play a sound, it needs to be loaded by an <code>AudioStreamPlayer</code> node. Add two of these nodes to the <code>Player</code> scene, naming them <code>LaserSound</code> and <code>EngineSound</code>. Drag the respective sound files into each node’s <code>shoot()</code> in <code>player.gd</code>:</p>
			<pre class="source-code">
$LaserSound.play()</pre>
			<p>Play the game and try shooting. If you find the sound too loud, you can adjust the <code>-10</code> to start.</p>
			<p>The <a id="_idIndexMarker229"/>engine sounds works a little differently. It needs to play when the thrust is on, but if you just try to call <code>play()</code> on the sound in the <code>get_input()</code> function when the player presses the key, it will restart the sound every frame. This doesn’t sound good, so you only want to start playing the sound if it isn’t already playing. Here is the relevant section of the <code>get_input()</code> function:</p>
			<pre class="source-code">
if Input.is_action_pressed("thrust"):
    thrust = transform.x * engine_power
    if not $EngineSound.playing:
        $EngineSound.play()
else:
    $EngineSound.stop()</pre>
			<p>Note that a problem can occur: if the player dies while holding down the thrust key, the engine sound will remain stuck playing because, in the <code>$EngineSound.stop()</code> to the <code>change_state()</code>.</p>
			<p>In the <code>Main</code> scene, add three more <code>AudioStreamPlayer</code> nodes: <code>ExplosionSound</code>, <code>LevelupSound</code>, and <code>Music</code>. In their <code>explosion.wav</code>, <code>levelup.ogg</code>, and <code>Funky-Gameplay_Looping.ogg</code>.</p>
			<p>Add <code>$ExplosionSound.play()</code> as the first line of <code>_on_rock_exploded()</code>, and add <code>$LevelupSound.play()</code> to <code>new_level()</code>.</p>
			<p>To start and stop the background music, add <code>$Music.play()</code> to <code>new_game()</code> and <code>$Music.stop()</code> to <code>game_over()</code>.</p>
			<p>The enemy also needs <code>ExplosionSound</code> and <code>ShootSound</code> nodes. You can use <code>enemy_laser.wav</code> for their shooting sound.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Particles</h2>
			<p>The <a id="_idIndexMarker230"/>player ship’s thrust is a perfect use of particle effects, creating a streaming flame from the engine.</p>
			<p>Add a <code>CPUParticles2D</code> node and name it <code>Exhaust</code>. You might want to zoom in on the ship while you’re doing this part.</p>
			<p class="callout-heading">Particle node types</p>
			<p class="callout">Godot offers two types of particle nodes: one that uses the CPU and one that uses the GPU for rendering. Since not all platforms, especially mobile or older desktops, support hardware acceleration for particles, you can use the CPU version for wider compatibility. If you know your game will be running on more powerful systems, you can use the GPU version.</p>
			<p>You’ll see a line of white dots streaming down from the center of the ship. Your challenge now is to turn those dots into an exhaust flame.</p>
			<p>There are a very large number of properties to choose from when configuring particles. As you go through the process of setting up this effect, feel free to experiment with them to see how they affect the result.</p>
			<p>Set these properties of the <code>Exhaust</code> node:</p>
			<ul>
				<li> <code>25</code></li>
				<li> <strong class="bold">Drawing/Local </strong><strong class="bold">Coords</strong>: On</li>
				<li> <code>(-</code><code>28, 0)</code></li>
				<li> <code>180</code></li>
				<li> <strong class="bold">Visibility/Show Behind </strong><strong class="bold">Parent</strong>: On</li>
			</ul>
			<p>The remaining properties you’ll change will affect the behavior of the particles. Start with <code>(1, 5)</code>. The particles are now emitted over a small area instead of a single point.</p>
			<p>Next, set <code>0</code> and <code>(0, 0)</code>. Note that the particles are not falling or spreading out, although they are moving very slowly.</p>
			<p>Set <code>400</code>, then scroll down to <code>8</code>.</p>
			<p>To make the<a id="_idIndexMarker231"/> size change over time, you can set <strong class="bold">Scale Amount Curve</strong>. Select <strong class="bold">New Curve</strong> and then click to open it. In the small graph that shows, right-click to add two points – one on the left and one on the right. Drag the right-hand dot down until the curve looks like this:</p>
			<div><div><img src="img/B19289_03_30.jpg" alt="Figure 3.29: Adding a particle scale curve"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.29: Adding a particle scale curve</p>
			<p>You should now see the particles shrinking as they stream out from the back of the ship.</p>
			<p>The last section to adjust is <strong class="bold">Color</strong>. To make the particles appear like a flame, they should start out bright orange-yellow and shift to red as they fade out. In the <strong class="bold">Color Ramp</strong> property, click on <strong class="bold">New Gradient</strong>, and you’ll see a gradient editor that looks like this:</p>
			<div><div><img src="img/B19289_03_31.jpg" alt="Figure 3.30: Color Ramp settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.30: Color Ramp settings</p>
			<p>The two<a id="_idIndexMarker232"/> rectangular sliders labeled <em class="italic">1</em> and <em class="italic">2</em> set the starting and ending colors of the gradient. Clicking on either of them will show its color in the box labeled <em class="italic">3</em>. Select slider <em class="italic">1</em> and then click box <em class="italic">3</em> to open a color picker. Choose an orange color, and then do the same for slider <em class="italic">2</em>, choosing a dark red.</p>
			<p>Now that the particles have the correct appearance, they’re lasting far too long. In the node’s <code>0.1</code>.</p>
			<p>Hopefully, your ship’s exhaust looks somewhat like a flame. If it doesn’t, feel free to adjust the properties until you are happy with how it looks.</p>
			<p>Once the flame is looking good, it needs to be turned on and off based on the player’s input. Go to <code>player.gd</code> and add <code>$Exhaust.emitting = false</code> at the beginning of <code>get_input()</code>. Then, under the <code>if</code> statement that checks for <code>thrust</code> input, add <code>$Exhaust.emitting = </code><code>true</code>.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Enemy trail</h2>
			<p>You can also use particles to give the<a id="_idIndexMarker233"/> enemy saucer a sparkling trail. Add a <code>CPUParticles2D</code> to the enemy scene and configure these settings:</p>
			<ul>
				<li> <code>20</code></li>
				<li> <strong class="bold">Visibility/Show Behind </strong><strong class="bold">Parent</strong>: On</li>
				<li> <code>Sphere</code></li>
				<li> <code>25</code></li>
				<li> <code>(</code><code>0, 0)</code></li>
			</ul>
			<p>You <a id="_idIndexMarker234"/>should now have particles appearing all across the radius of the saucer (you can hide the <code>Sprite2D</code> during this part if you want to see them better). The default shape for particles is a square, but you can also use a texture for even more visual appeal. Add <code>res://assets/corona.png</code> to <strong class="bold">Drawing/Texture</strong>.</p>
			<p>This image gives a nice glowing effect, but it’s quite large compared to the saucer, so set <code>0.1</code>. You’ll also notice that this image is white on a black background. In order to look correct, it <a id="_idIndexMarker235"/>needs its <strong class="bold">blend mode</strong> changed. To do this, find the <strong class="bold">Material</strong> property and select <strong class="bold">New CanvasItemMaterial</strong>. There, you can change <strong class="bold">Blend Mode</strong> from <strong class="bold">Mix</strong> to <strong class="bold">Add</strong>.</p>
			<p>Finally, you can make the particles fade away by using <strong class="bold">Scale Amount Curve</strong> in the <strong class="bold">Scale</strong> section, just as you did with the player particles.</p>
			<p>Play your game and admire the effects. What else could you add with particles?</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Summary</h1>
			<p>In this chapter, you learned how to work with <code>RigidBody2D</code> nodes and learned more about how Godot’s physics works. You also implemented a basic finite state machine – something you’ll find useful as your projects grow larger and that you’ll use again in future chapters. You saw how <code>Container</code> nodes help organize and keep UI nodes aligned. Finally, you added sound effects and got your first taste of advanced visual effects by using the <code>Animation</code> and <code>CPUParticles2D</code> nodes.</p>
			<p>You also continued to create game objects using standard Godot hierarchies, such as <code>CollisionShapes</code> attached to <code>CollisionObjects</code> and signals being used to handle communication between nodes. At this point, these practices should be starting to look familiar to you.</p>
			<p>Are you prepared to try and remake this project on your own? Try repeating all, or even part, of this chapter without looking at the book. It’s a good way to check what information you absorbed and what you need to review again. You can also try remaking it with your own variations rather than making an exact copy.</p>
			<p>When you’re ready to move on, in the next chapter, you’ll make another style of game that’s very popular: a platformer in the tradition of Super Mario Bros.</p>
		</div>
	</body></html>