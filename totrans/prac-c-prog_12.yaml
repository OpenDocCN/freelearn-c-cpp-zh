- en: Creativity with Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用图形进行创意
- en: '**OpenGL** (short for **Open Graphics Library**) is a cross-platform **application
    program interface** (**API**) used for rendering two- and three-dimensional graphics;
    it works independently of operating systems. It provides several built-in routines
    for displaying graphics and for applying special effects, anti-aliasing, and different
    transformations.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL**（代表**Open Graphics Library**）是一个跨平台的**应用程序接口**（**API**），用于渲染二维和三维图形；它独立于操作系统工作。它提供了一些内置例程用于显示图形以及应用特殊效果、抗锯齿和不同的变换。'
- en: 'OpenGL had a library called the **OpenGL Utility Toolkit** (**GLUT**), but
    it has not been supported for several years. FreeGLUT, a free, open source piece
    of software, is used as an alternative in its place. GLUT was very popularly used
    in graphics applications as it is highly portable and is very simple to use. It
    has a large library of functions for creating windows, different graphical shapes,
    event handling, and more. If FreeGLUT is not installed on your computer and you
    have Windows OS on your computer, you can download `freeglut 3.0.0` for MinGW
    and extract it. On Ubuntu, you need to give the following command to install FreeGLUT:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL有一个名为**OpenGL Utility Toolkit**（**GLUT**）的库，但它已经不支持好几年了。FreeGLUT是一个免费的开源软件，作为其替代品。GLUT在图形应用中非常受欢迎，因为它高度可移植且非常简单易用。它有一个大型的函数库，用于创建窗口、不同的图形形状、事件处理等。如果你电脑上没有安装FreeGLUT，并且你的电脑上运行的是Windows操作系统，你可以下载`freeglut
    3.0.0`用于MinGW并提取它。在Ubuntu上，你需要输入以下命令来安装FreeGLUT：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this chapter, we will learn to do the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下食谱：
- en: Drawing four graphical shapes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画四个图形形状
- en: Drawing a circle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画圆
- en: Drawing a line between two mouse clicks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个鼠标点击之间画线
- en: Making a bar graph of the supplied values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据提供的值制作条形图
- en: Making an animated bouncing ball
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个动画弹跳球
- en: List of OpenGL functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL函数列表
- en: 'Before we delve into the recipes, let''s have a quick overview of some OpenGL
    functions that we will be using in this chapter. The following are some of the
    most frequently used OpenGL functions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨食谱之前，让我们快速概述一下本章中我们将使用的一些OpenGL函数。以下是一些最常用的OpenGL函数：
- en: '| **Function** | **Description** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **描述** |'
- en: '| `glutInit` | Used to initialize GLUT. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `glutInit` | 用于初始化GLUT。 |'
- en: '| `glutCreateWindow` | Used for creating a top-level window. You can supply
    the window name as a label while creating the window. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `glutCreateWindow` | 用于创建顶层窗口。在创建窗口时，你可以提供窗口名称作为标签。 |'
- en: '| `glutInitWindowSize` | Used to define the window size. The width and height
    of the window are specified in pixels while defining the window size. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `glutInitWindowSize` | 用于定义窗口大小。在定义窗口大小时，窗口的宽度和高度以像素为单位指定。 |'
- en: '| `void glutInitWindowPosition` | Used to set the initial window position.
    The window''s *x* and *y* locations are specified in terms of pixels. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `void glutInitWindowPosition` | 用于设置初始窗口位置。窗口的*x*和*y*位置以像素为单位指定。 |'
- en: '| `glutDisplayFunc` | Used to specify the callback function to be executed
    to display graphics in the current window. For redisplaying the content in the
    window too, the specified callback function is executed. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `glutDisplayFunc` | 用于指定要执行的回调函数以在当前窗口中显示图形。为了在窗口中重新显示内容，也会执行指定的回调函数。 |'
- en: '| `glutMainLoop` | This is an entry point for the GLUT event processing loop.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `glutMainLoop` | 这是GLUT事件处理循环的入口点。 |'
- en: '| `glClearColor` | Used to specify clear values for the color buffers. You
    need to specify the red, green, blue, and alpha values used when the color buffers
    are cleared. The initial values are all 0. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `glClearColor` | 用于指定颜色缓冲区的清除值。你需要指定在清除颜色缓冲区时使用的红色、绿色、蓝色和alpha值。初始值都是0。 |'
- en: '| `glClear` | Used to clear the buffers to preset values. Certain masks can
    be used to specify the buffers to be cleared. The following are three masks that
    can be used. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `glClear` | 用于将缓冲区清除到预设值。可以使用某些掩码来指定要清除的缓冲区。以下是可以使用的三个掩码。 |'
- en: '| `GL_COLOR_BUFFER_BIT` | This mask represents the buffers that are currently
    being used for applying colors. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `GL_COLOR_BUFFER_BIT` | 这个掩码代表当前用于应用颜色的缓冲区。 |'
- en: '| `GL_DEPTH_BUFFER_BIT` | This mask represents the depth buffer. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEPTH_BUFFER_BIT` | 这个掩码代表深度缓冲区。 |'
- en: '| `GL_STENCIL_BUFFER_BIT` | This mask represents the stencil buffer. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `GL_STENCIL_BUFFER_BIT` | 这个掩码代表模板缓冲区。 |'
- en: '| `glBegin` | Used for grouping statements that lead to a specific shape. You
    can create different shapes such as points, lines, triangles, rectangles, and
    more, by grouping the required vertices within this grouping statement. The shape
    that you want to create can be specified by specifying any of the modes: `GL_POINTS`,
    `GL_LINES`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`,
    `GL_TRIANGLE_FAN`, `GL_QUADS`, `GL_QUAD_STRIP`, and `GL_POLYGON`. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `glBegin` | 用于分组导致特定形状的语句。您可以通过在此分组语句内分组所需的顶点来创建不同的形状，例如点、线、三角形、矩形等。您可以通过指定以下任何模式来指定要创建的形状：`GL_POINTS`、`GL_LINES`、`GL_LINE_STRIP`、`GL_LINE_LOOP`、`GL_TRIANGLES`、`GL_TRIANGLE_STRIP`、`GL_TRIANGLE_FAN`、`GL_QUADS`、`GL_QUAD_STRIP`
    和 `GL_POLYGON`。 |'
- en: '| `glEnd` | Used to end the group of statements. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `glEnd` | 用于结束语句组。 |'
- en: '| `glColor3f` | Used to set the current color for drawing graphics. The values
    for the red, green, and blue colors (in this strict sequence) can be specified
    to set the color. The values of these colors can be between 0 and 1, where 0 is
    the lowest intensity and 1 is the highest intensity of the color. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `glColor3f` | 用于设置绘图时的当前颜色。可以指定红色、绿色和蓝色（按此严格顺序）的值来设置颜色。这些颜色的值介于 0 和 1 之间，其中
    0 是最低强度，1 是最高强度。 |'
- en: '| `glVertex` | Used to specify coordinates for the point, line, and polygon
    vertices. This function has to be enclosed between a `glBegin`/`glEnd` pair. There
    might be a suffix of 2, 3, or 4 after `glVertex`, depending on the number of coordinates
    required for defining the vertex. For example, if two coordinates, *x* and *y*,
    are required to specify the vertex, then a value of 2 will be added as a suffix
    to `glVertex` making it `glVertex2`. Similarly, 3 and 4 can be suffixed if the
    coordinates required for specifying the vertex are 3 and 4, respectively. Also,
    one more suffix can be added, such as `s`, `i`, `f`, or `d` if the vertex coordinates
    are of the `short`, `int`, `float` or `double` data types respectively. For example,
    `glVertex2f()` can be used to specify the vertex with *x* and *y* coordinates,
    and the coordinate values will be of the `float` data type. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `glVertex` | 用于指定点、线和多边形顶点的坐标。此函数必须位于 `glBegin`/`glEnd` 对之间。`glVertex` 后可能跟有
    2、3 或 4 的后缀，具体取决于定义顶点所需的坐标数量。例如，如果需要两个坐标 *x* 和 *y* 来指定顶点，则会在 `glVertex` 后添加一个值为
    2 的后缀，使其变为 `glVertex2`。同样，如果需要 3 和 4 个坐标来指定顶点，则可以分别添加 3 和 4 的后缀。此外，还可以添加一个后缀，如
    `s`、`i`、`f` 或 `d`，如果顶点坐标分别是 `short`、`int`、`float` 或 `double` 数据类型。例如，可以使用 `glVertex2f()`
    来指定具有 *x* 和 *y* 坐标的顶点，坐标值将是 `float` 数据类型。 |'
- en: '| `glLineWidth` | Used to specify the width of the line to be drawn. The width
    of the line can be specified in terms of pixels. The default width is 1. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `glLineWidth` | 用于指定要绘制的线的宽度。线的宽度可以用像素来指定。默认宽度为 1。 |'
- en: '| `glPointSize` | Used to specify the diameter of rasterized points. The default
    diameter is 1. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `glPointSize` | 用于指定光栅化点的直径。默认直径为 1。 |'
- en: '| `glFlush` | The commands sometimes get buffered depending on the resource
    utilization and networking situation. The `glFlush` function empties all the buffers
    and ensures that the commands are executed as early as possible. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `glFlush` | 命令有时会根据资源利用率和网络状况进行缓冲。`glFlush` 函数清空所有缓冲区，并确保命令尽可能早地执行。 |'
- en: '| `glutSwapBuffers` | This function is used for swapping the front buffer with
    the back buffer. The front buffer displays the image or frame on the screen and
    the back buffer is where the image (or frame) hasn''t yet been rendered. Once
    the image or frame is rendered in the back buffer, then this function swaps the
    front and back buffers, displaying the image that is now ready in the back buffer.
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `glutSwapBuffers` | 此函数用于交换前缓冲区与后缓冲区。前缓冲区显示屏幕上的图像或帧，后缓冲区是图像（或帧）尚未渲染的地方。一旦图像或帧在后缓冲区中渲染，则此函数交换前后缓冲区，显示现在已在后缓冲区中准备好的图像。
    |'
- en: '| `glutReshapeFunc` | Used for specifying the reshape callback function for
    the current window. The function is invoked automatically during these situations:
    when a window is reshaped, before a window''s first display callback, and after
    a window is created. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `glutReshapeFunc` | 用于指定当前窗口的 reshape 回调函数。在以下情况下自动调用该函数：当窗口被调整大小、在窗口第一次显示回调之前以及窗口创建之后。
    |'
- en: '| `glViewport` | Used to set the viewport, that is, the vicinity of the window
    in which we want the rendered image to appear. Four arguments are passed to the
    function. The first two arguments represent the lower-left corner of the viewport
    rectangle in terms of pixels. The third and fourth arguments represent the width
    and height of the viewport. The width and height of the viewport are usually set
    to be equal to the dimensions of the window or less in size. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `glViewport` | 用于设置视口，即我们希望渲染图像出现的窗口附近区域。该函数接收四个参数。前两个参数表示视口矩形的左下角，以像素为单位。第三个和第四个参数表示视口的宽度和高度。视口的宽度和高度通常设置为与窗口尺寸相等或更小。
    |'
- en: '| `glMatrixMode` | Used to specify which matrix is the current matrix. The
    vertices are rendered on the basis of the current state of the matrix, so a matrix
    must be chosen so that it serves our needs. The following are the two main options.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `glMatrixMode` | 用于指定当前矩阵是哪个。顶点是基于矩阵的当前状态进行渲染的，因此必须选择一个矩阵以满足我们的需求。以下有两个主要选项。'
- en: '| `GL_MODELVIEW` | This is the default matrix option. This option is used when
    the user wants to perform translation, rotation, or similar operations. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `GL_MODELVIEW` | 这是默认的矩阵选项。当用户想要执行平移、旋转等类似操作时使用此选项。'
- en: '| `GL_PROJECTION` | This option is used when the user wants to perform parallel
    projection, perspective projection, and so on. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `GL_PROJECTION` | 当用户想要执行平行投影、透视投影等操作时使用此选项。'
- en: '| `glLoadIdentity` | Used to replace the current matrix with the identity matrix.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `glLoadIdentity` | 用于用单位矩阵替换当前矩阵。'
- en: '| `gluOrtho2D` | Used to set up a two-dimensional orthographic viewing region.
    Four arguments are passed to this function. The first two coordinates represent
    the left and right vertical clipping planes. The last two specify the coordinates
    for the bottom and top horizontal clipping planes. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `gluOrtho2D` | 用于设置二维正交视图区域。该函数接收四个参数。前两个坐标表示左右垂直裁剪平面。最后两个指定底部和顶部的水平裁剪平面坐标。'
- en: '| `glutMouseFunc` | Used to set the mouse callback function for the current
    window. That is, whenever the mouse button is pressed or released, each action
    invokes the mouse callback function. In the callback function, the following three
    arguments are automatically passed. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `glutMouseFunc` | 用于设置当前窗口的鼠标回调函数。也就是说，每当鼠标按钮被按下或释放时，每个动作都会调用鼠标回调函数。在回调函数中，以下三个参数会自动传递。'
- en: '| `button` | It represents any of the three buttons, `GLUT_LEFT_BUTTON`, `GLUT_MIDDLE_BUTTON`,
    or `GLUT_RIGHT_BUTTON`, depending on which of the mouse buttons is pressed. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `button` | 它代表三个按钮中的任何一个，`GLUT_LEFT_BUTTON`、`GLUT_MIDDLE_BUTTON` 或 `GLUT_RIGHT_BUTTON`，具体取决于哪个鼠标按钮被按下。'
- en: '| `state` | The state can be either `GLUT_UP` or `GLUT_DOWN` depending on whether
    the callback was invoked because of the mouse release or mouse press, respectively.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `state` | 状态可以是 `GLUT_UP` 或 `GLUT_DOWN`，具体取决于回调是因为鼠标释放还是鼠标按下而触发的。'
- en: '| `x` and `y` | Represents the window''s relative coordinates when the mouse
    button state changes. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `x` 和 `y` | 表示鼠标按钮状态改变时窗口的相对坐标。'
- en: '| `glutIdleFunc` | Used to set the global idle callback, mainly used for performing
    background processing tasks. The idle callback is continuously called even if
    no event is occurring. The `NULL` parameter is sent to this function to disable
    the generation of the idle callback. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `glutIdleFunc` | 用于设置全局空闲回调，主要用于执行后台处理任务。即使没有事件发生，空闲回调也会持续调用。将 `NULL` 参数发送到该函数以禁用空闲回调的生成。'
- en: You need to initialize the **X Window System** (**X11**) for working with graphics.
    X11 provides a GUI environment, that is, it enables the displaying of windows
    and graphics, and provides an environment for interacting with a mouse and keyboard.
    The command used for starting the X11 is the `xinit` command.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要初始化**X 窗口系统**（**X11**）以进行图形处理。X11 提供了一个 GUI 环境，即它允许显示窗口和图形，并提供了一个与鼠标和键盘交互的环境。启动
    X11 的命令是 `xinit` 命令。
- en: Drawing four graphical shapes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制四个图形形状
- en: 'In this recipe, we will learn to draw four different shapes: a square, a triangle,
    points, and a line.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习绘制四种不同的图形：正方形、三角形、点和线。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps to make different graphical shapes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 制作不同图形形状的步骤如下：
- en: Initialize GLUT, define the window size, create the window, and set the position
    of the window.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 GLUT，定义窗口大小，创建窗口，并设置窗口位置。
- en: Define the callback function that will be automatically invoked after displaying
    the window.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a square, first, define its color.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a square by defining its four vertices and enclosing them within `glBegin`
    and `glEnd` statements along with the `GL_QUADS` keyword.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a line, set the width and color of the line.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group a pair of vertices within `glBegin` and `glEnd` with the `GL_LINES` keyword
    to draw a line.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw the points, set the point size to 3 px and also set their color.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The vertices are where the points have to be displayed. Group them into a pair
    of `glBegin` and `glEnd` with the `GL_POINTS` keyword.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a triangle, group three vertices into `glBegin` and `glEnd` statements
    along with the `GL_TRIANGLES` keyword.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `glFlush` function is invoked to empty all the buffered statements and get
    the shapes drawn quickly.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for drawing the preceding four shapes is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step, as expected, is that GLUT is initialized, followed by creating
    a top-level window, and the label supplied for the window is `Drawing some shapes`.
    However, you can give it any label. The window is defined with a width of 1,500
    px and height of 1,500 px. The initial position of the window is set at 0,0, that
    is, at the coordinates of *x=0* and *y=0*. The `drawshapes` callback function is
    invoked for displaying different shapes in the window.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In the `drawshapes` function, the values of the color buffers are cleared, followed
    by clearing the buffers to preset values.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The first shape that we are drawing is a square, so a group of statements for
    drawing a square are enclosed within `glBegin` and `glEnd` statements. The `GL_QUADS`
    keyword is supplied with the `glBegin` statement because a quad refers to any
    shape that comprises 4 vertices. The `glColor3f` function is invoked to create
    a square filled with the color blue. The four sets of vertices are supplied to
    make a square. A vertex comprises *x* and *y* coordinates.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will draw lines. The `glLineWidth` function is invoked to specify the
    width of the lines to be drawn as 2 px wide. The `glColor3f` function is invoked
    to make the lines appear in the color red. Two vertices are grouped within `glBegin`
    and `glEnd` with the `GL_LINES` keyword to draw a line.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will draw two points. To make the points clearly visible, the point
    size is set to 3 px, and the color in which the points will be drawn is set to
    red (or any color except black). The two vertices where we want the points to
    be displayed are supplied after being grouped into a pair of `glBegin` and `glEnd` statements.
    The `GL_POINTS` keyword is supplied with the `glBegin` statement to draw the points.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we draw a triangle by grouping three triangle vertices into `glBegin`
    and `glEnd` statements. The `GL_TRIANGLES` keyword is supplied with `glBegin`
    to indicate that the vertices that are specified in the group are meant for drawing
    a triangle. `glColor3f` is invoked to make sure the triangle will be filled with
    the color green.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将三个三角形顶点组合到 `glBegin` 和 `glEnd` 语句中来绘制三角形。将 `GL_TRIANGLES` 关键字与 `glBegin`
    一起提供，以指示组中指定的顶点是为了绘制三角形。调用 `glColor3f` 确保三角形将被填充为绿色。
- en: Finally, the `glFlush` function is invoked to empty all the buffered statements
    and get them executed quickly to display the desired shapes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用 `glFlush` 函数以清空所有缓冲语句并快速执行它们以显示所需的形状。
- en: To compile the program, we need to open the Command Prompt and change the directory
    to the folder where the program is saved. Then, we execute the `xinit` command
    at the command prompt to start the X server (X11).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序，我们需要打开命令提示符，并将目录更改为程序保存的文件夹。然后，在命令提示符中执行 `xinit` 命令以启动 X 服务器（X11）。
- en: Once X server starts, give the following command to compile the program. Remember
    that the program has to be linked with `-lGL -lGLU -lglut` while compiling the
    program.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 X 服务器启动，给出以下命令来编译程序。记住，在编译程序时，程序必须与 `-lGL -lGLU -lglut` 链接。
- en: 'The syntax is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `filename.c` is the name of the file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`filename.c` 是文件名。
- en: 'We will use the following command to compile our program:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令来编译我们的程序：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If no error appears, this means the `opengldrawshapes.c` program has successfully
    been compiled into an executable file: `opengldrawshapes.exe`. This file is executed
    using the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误出现，这意味着 `opengldrawshapes.c` 程序已成功编译成可执行文件：`opengldrawshapes.exe`。此文件使用以下命令执行：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will get the output as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到如下截图所示的输出：
- en: '![](img/893ec14f-dd2a-48e1-ba9f-86b7a51ecea1.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/893ec14f-dd2a-48e1-ba9f-86b7a51ecea1.png)'
- en: Figure 12.1
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1
- en: Voilà! We have successfully drawn four different graphical shapes: a square,
    triangle, points, and a line. Now let's move on to the next recipe!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功绘制了四种不同的图形形状：一个正方形、一个三角形、一些点和一条线。现在让我们继续到下一个菜谱！
- en: Drawing a circle
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制圆
- en: The procedure for drawing a circle is completely different from the other graphical
    shapes, hence it gets its own dedicated recipe. It needs a `for` loop to draw
    small points or lines at 0 to 360 degrees. So, let's learn to draw a circle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆的过程与其他图形形状完全不同，因此它有自己的专用菜谱。它需要一个 `for` 循环来在 0 到 360 度绘制小点或线条。所以，让我们学习如何绘制圆。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps for drawing a circle:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆的步骤如下：
- en: Initialize GLUT, define the size of a top-level window, and create it. Also,
    set the initial position of the window for displaying our circle.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 GLUT，定义顶级窗口的大小，并创建它。同时，设置窗口的初始位置以显示我们的圆。
- en: Define a callback function that is auto-invoked after creating the window.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个在创建窗口后自动调用的回调函数。
- en: In the callback function, color buffers are cleared and the color for displaying
    the circle is set.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在回调函数中，清除颜色缓冲区，并设置显示圆的颜色。
- en: The statements for drawing a circle are grouped within a pair of `glBegin` and
    `glEnd` functions along with the `GL_LINE_LOOP` keyword.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制圆的语句被包含在 `glBegin` 和 `glEnd` 函数对中，并带有 `GL_LINE_LOOP` 关键字。
- en: Use a `for` loop to draw small lines from 0 to 360 to give the shape of a circle.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环从 0 到 360 绘制小线条，以形成圆形的形状。
- en: 'The program for drawing a circle is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆的程序如下：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GLUT is initialized and a top-level window is created with the label, `Drawing
    some shapes`. The size of the window is defined as 1,500 px wide and 1,500 px
    in height. The initial position of the window is set at 0, 0, that is, at the *x=0*
    and *y=0* coordinate location. The `drawshapes` callback function is invoked for
    drawing a circle in the window.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: GLUT 已初始化，并创建了一个带有标签 `Drawing some shapes` 的顶级窗口。窗口的大小定义为 1,500 像素宽和 1,500 像素高。窗口的初始位置设置为
    0, 0，即 *x=0* 和 *y=0* 坐标位置。`drawshapes` 回调函数被调用来在窗口中绘制圆。
- en: In the `drawshapes` function, the values of the color buffers are cleared, followed
    by clearing the buffers to preset values. The `glColor3f` function is invoked
    to set the color in which we want to draw the circle. I have set the color to
    green to draw the circle but you can choose any color. A group of statements meant
    for drawing a circle is collected within a pair of `glBegin` and `glEnd` functions.
    The `glBegin` function is supplied to the `GL_LINE_LOOP` keyword to indicate that
    the circle that we are going to draw will be made up of several small lines.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawshapes` 函数中，清除颜色缓冲区的值，然后清除缓冲区到预设值。调用 `glColor3f` 函数来设置我们想要绘制的圆的颜色。我已经将颜色设置为绿色来绘制圆，但你可以选择任何颜色。一组用于绘制圆的语句被收集在
    `glBegin` 和 `glEnd` 函数之间。`glBegin` 函数被提供给 `GL_LINE_LOOP` 关键字，表示我们将要绘制的圆将由几条小线组成。
- en: Within the `glBegin` and `glEnd` functions, a `for` loop is used that executes
    from value 0 to 360; that is, a very small line will be drawn at every degree
    from 0 until 360 to give it the shape of a circle. The degree is first converted
    into radians and the line is drawn at the vertex location, *cos(angle) * radius,
    sin(angle)* radius*. When such small lines are drawn at every degree, it will
    give it the appearance of a circle on the screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `glBegin` 和 `glEnd` 函数内，使用了一个从 0 到 360 的 `for` 循环来执行；也就是说，将在 0 到 360 度的每个度数处绘制一条非常小的线，以给出圆形的形状。首先将度数转换为弧度，然后在顶点位置绘制线条，*cos(角度)
    * 半径，sin(角度)* 半径*.当在每度处绘制这样的小线时，它将在屏幕上呈现出圆形的外观。
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序，启动 X 服务器，并给出以下命令来编译程序：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If no error appears, that means the `opengldrawshapes2.c` program has successfully
    compiled into an executable file: `opengldrawshapes2.exe`. This file is executed
    using the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现错误，这意味着 `opengldrawshapes2.c` 程序已成功编译成可执行文件：`opengldrawshapes2.exe`。此文件使用以下命令执行：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will get the output as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下截图所示的输出：
- en: '![](img/f2da366c-7cad-4c0f-a71d-0a79a25a9d78.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2da366c-7cad-4c0f-a71d-0a79a25a9d78.png)'
- en: Figure 12.2
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2
- en: Voilà! We have successfully learned how to draw a circle. Now let's move on
    to the next recipe!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功学习了如何绘制圆。现在让我们继续下一个菜谱！
- en: Drawing a line between two mouse clicks
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在两个鼠标点击之间绘制线条
- en: In this recipe, we will learn to draw a line between two mouse clicks. A mouse
    click is considered a procedure of pressing the mouse button and releasing it.
    You can draw as many lines as you want between a pair of mouse press and release
    events.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在两个鼠标点击之间绘制线条。鼠标点击被认为是按下鼠标按钮并释放它的过程。你可以在一对鼠标按下和释放事件之间绘制任意数量的线条。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following are the steps to draw a line between two mouse clicks:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在两个鼠标点击之间绘制线条的步骤：
- en: Initialize GLUT, define the size of the top-level window, and display the window.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 GLUT，定义顶级窗口的大小，并显示窗口。
- en: Define a `drawLine` callback function that draws a line if any mouse click event
    occurs.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `drawLine` 回调函数，当发生任何鼠标点击事件时绘制线条。
- en: In the `drawLine` function, the clear values for the clear buffers are specified.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `drawLine` 函数中，指定了清除缓冲区的清除值。
- en: The `glutSwapBuffers()` function is invoked to swap the front and back buffers
    to display any frame that is rendered in the back buffer and is ready to be displayed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `glutSwapBuffers()` 函数以交换前后缓冲区，显示后缓冲区中渲染的任何帧，并准备显示。
- en: The `glutReshapeFunc` function is invoked to specify the reshape callback function
    that will be auto-invoked whenever the window is reshaped to redraw the lines.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `glutReshapeFunc` 函数来指定当窗口形状改变时将自动调用的重绘线条的回调函数。
- en: Because the vertices of the line are rendered on the basis of the current state
    of the matrix, a matrix is set as the current matrix for the viewing and modeling
    transformations.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于线条的顶点是基于矩阵的当前状态渲染的，因此设置了一个矩阵作为当前矩阵，用于视图和建模变换。
- en: A two-dimensional orthographic viewing region is also set up.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还设置了一个二维正交视图区域。
- en: A mouse callback function is set up with the name `mouseEvents`. The callback
    is invoked whenever the mouse button is pressed or released.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置了一个名为 `mouseEvents` 的鼠标回调函数。每当鼠标按钮被按下或释放时，都会调用回调。
- en: As per the coordinates where the mouse button is pressed and released, the `drawLine`
    function will be invoked to draw the lines between the two coordinates.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据鼠标按钮按下和释放的坐标，将调用 `drawLine` 函数来绘制两个坐标之间的线条。
- en: 'The program for drawing a line between two mouse clicks is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在两个鼠标点击之间绘制线条的程序：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GLUT is initialized and a top-level window is created with the label, `Displaying
    lines between two mouse clicks`. The window size is specified as 1,000 px wide
    and 1,000 px in height. The `drawLine` callback function is invoked for drawing
    lines if any mouse click event has occurred.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GLUT 被初始化，并创建了一个带有标签“Displaying lines between two mouse clicks”的顶层窗口。窗口大小被指定为
    1,000 像素宽和 1,000 像素高。如果发生了任何鼠标点击事件，将调用 `drawLine` 回调函数来绘制线条。
- en: In the `drawLine` function, the clear values for the clear buffers are specified.
    Also, the buffers are cleared to preset values so that colors can be applied to
    them. Because no mouse click has occurred yet, the value of `noOfClicks` global
    variable is 0, and hence no line will be drawn at the moment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawLine` 函数中，指定了清除缓冲区的清除值。此外，缓冲区被清除到预设值，以便可以应用颜色。由于尚未发生鼠标点击，全局变量 `noOfClicks`
    的值为 0，因此目前不会绘制任何线条。
- en: The `glutSwapBuffers()` function is invoked to swap the front and back buffers
    to display any frame that is rendered in the back buffer and is ready to be displayed.
    Because no mouse click has been made yet, nothing will happen with this function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`glutSwapBuffers()` 函数被调用以交换前后缓冲区，以便显示在后台缓冲区中渲染并准备好显示的任何帧。由于尚未进行鼠标点击，此函数将不会产生任何效果。'
- en: Then, the `glutReshapeFunc` function is invoked to specify the reshape callback
    function for the current window. The callback function projection will be invoked
    automatically whenever the window is reshaped, before the window's first display
    callback and after the window is created. In the projection callback, a viewport
    is set to define the vicinity in which we want the lines to be drawn. Thereafter,
    a matrix is set as the current matrix for the viewing and modeling transformations.
    Also, the vertices are rendered on the basis of the current state of the matrix,
    so the matrix is chosen accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用 `glutReshapeFunc` 函数来指定当前窗口的 reshape 回调函数。每当窗口被调整大小时，将自动调用回调函数 projection，在窗口的第一个显示回调之前和窗口创建之后。在投影回调中，设置一个视口来定义我们想要绘制线条的邻近区域。之后，设置一个矩阵作为当前矩阵，用于视图和建模变换。此外，基于矩阵的当前状态渲染顶点，因此相应地选择矩阵。
- en: Besides this, a two-dimensional orthographic viewing region is also set up.
    The mouse callback function is set up with the name `mouseEvents`, so whenever
    a mouse button is pressed or released, the `mouseEvents` callback function will
    be automatically invoked. In the callback function, the information about which
    mouse button is pressed and whether the mouse button is pressed or released is
    passed. Also, the *x* and *y* coordinates where the mouse action takes place are
    also passed to the `mouseEvents` callback function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还设置了一个二维正交视区。将鼠标回调函数命名为 `mouseEvents`，因此每当鼠标按钮被按下或释放时，`mouseEvents` 回调函数将自动被调用。在回调函数中，传递有关哪个鼠标按钮被按下以及鼠标按钮是被按下还是被释放的信息。同时，鼠标动作发生的
    *x* 和 *y* 坐标也被传递给 `mouseEvents` 回调函数。
- en: In the `mouseEvents` function, first, it checks whether the left mouse button
    is pressed. If yes, then the location where the mouse button is released, that
    location's *x* and *y* coordinates are picked up and assigned to the `coord` array.
    Basically, the mouse button has to be pressed and then released to store the coordinate
    values. When two mouse clicks and releases are observed, the `drawLine` function
    is invoked to draw the lines between the two coordinates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mouseEvents` 函数中，首先检查是否按下了左鼠标按钮。如果是，则拾取鼠标按钮释放的位置，以及该位置的 *x* 和 *y* 坐标，并将它们分配给
    `coord` 数组。基本上，必须先按下鼠标按钮然后释放，才能存储坐标值。当观察到两次鼠标点击和释放时，将调用 `drawLine` 函数来绘制两个坐标之间的线条。
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序，启动 X 服务器，并给出以下命令来编译程序：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If no error appears, that means the `openglmouseclick.c` program has successfully
    compiled into an executable file: `openglmouseclick.exe`. This file is executed
    using the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现错误，这意味着 `openglmouseclick.c` 程序已成功编译成可执行文件：`openglmouseclick.exe`。此文件使用以下命令执行：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will get the output as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下截图所示的输出：
- en: '![](img/f60dee79-2a14-4177-bcc0-67bbce7dba6e.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f60dee79-2a14-4177-bcc0-67bbce7dba6e.png)'
- en: Figure 12.3
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3
- en: Once you implement this functionality, you can draw as many lines as you want.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了这个功能，你可以绘制任意多的线条。
- en: Now let's move on to the next recipe!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个教程！
- en: Making a bar graph of the supplied values
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作条形图
- en: In this recipe, we will learn to draw bar charts. Let's assume we have data
    about the percentage of profit growth of a company for the last three years. We
    will assign that percentage of profit growth to an array, and on the basis of
    the values in the array, we will draw a bar chart with three bars on the screen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何绘制条形图。假设我们有一家公司在过去三年中利润增长百分比的统计数据。我们将将该利润增长百分比分配给一个数组，然后基于数组中的值，在屏幕上绘制一个包含三个条形的条形图。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following are the steps for drawing a bar chart with the values defined
    in an array:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组中定义的值绘制条形图的以下步骤：
- en: Initialize GLUT, define the size of the top-level window, set its initial position
    for display, and display the window on the screen.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 GLUT，定义顶级窗口的大小，设置其初始显示位置，并在屏幕上显示窗口。
- en: Define the callback function that is auto-invoked after creating a window for
    drawing the bar chart.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个回调函数，该函数在创建用于绘制条形图的窗口后自动调用。
- en: An array is defined in the callback that defines the height of the bar chart.
    The width of the bar chart is fixed at 2 px.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在回调函数中定义了一个数组，该数组定义了条形图的高度。条形图的宽度固定为 2 像素。
- en: A two-dimensional orthographic viewing region is set up, that is, coordinates
    are set up for horizontal and vertical clipping planes.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置了一个二维正交视图区域，即设置了水平和垂直裁剪平面的坐标。
- en: To display the horizontal and vertical *x* and *y* axes, the vertices for the
    two lines are grouped in a `glBegin` and `glEnd` pair with the `GL_LINES` keyword.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示水平和垂直的 *x* 和 *y* 轴，将两条线的顶点分组在 `glBegin` 和 `glEnd` 对配中，使用 `GL_LINES` 关键字。
- en: In order to display three bars, a `for` loop is set to execute three times.
    To display bars one beside the other, the *x* axis of the next bar is computed.
    The height of each bar is computed on the basis of the array defined in *step
    3*.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示三个条形，设置了一个 `for` 循环以执行三次。为了显示并排的条形，计算下一个条形的 *x* 轴。每个条形的高度基于第 3 步中定义的数组计算。
- en: The bar chart is displayed using the four vertices that are grouped in the `glBegin`
    and `glEnd` pair with the `GL_POLYGON` keyword.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条形图使用与 `glBegin` 和 `glEnd` 对配的 `GL_POLYGON` 关键字分组形成的四个顶点来显示。
- en: 'The program for drawing a bar chart on the basis of values in an array is as
    follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数组中的值绘制条形图的程序如下：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GLUT is initialized and a top-level window is created with the label, `Displaying
    Bar Chart`. The initial position of the window is set at 0,0, that is, at the
    *x=0* and *y=0* coordinate location. The window size is specified as 500 px in
    width and 500 px in height. The `display` callback function is invoked for drawing
    the bar chart.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: GLUT 已初始化，并创建了一个带有标签“Displaying Bar Chart”的顶级窗口。窗口的初始位置设置为 0,0，即 *x=0* 和 *y=0*
    坐标位置。窗口的宽度指定为 500 像素，高度也为 500 像素。`display` 回调函数被调用以绘制条形图。
- en: In the display callback, a result array is initialized to three values. Basically,
    the values in the resulting array represent the growth in profit percentage of
    the company in the last three years. Let's assume the growth in the profit percentage
    of the company in 2019, 2018, and 2017 was 10%, 15%, and 5%, respectively. We
    want the three bars corresponding to this data to rest on the *x* axis, so the
    *y* coordinate is set to 0\. To make the first bar appear after some space, the
    *x* coordinate value is set to 1\. The width of each bar is set to 2\. The color
    for the bar chart is set to red.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示回调中，初始化一个包含三个值的结果数组。基本上，结果数组中的值代表公司过去三年利润百分比的增长。假设公司 2019 年、2018 年和 2017
    年的利润百分比增长分别为 10%、15% 和 5%。我们希望与这些数据对应的三个条形图位于 *x* 轴上，因此将 *y* 坐标设置为 0。为了使第一个条形图在一段距离后出现，将
    *x* 坐标值设置为 1。每个条形图的宽度设置为 2。条形图的颜色设置为红色。
- en: A two-dimensional orthographic viewing region is set up, that is, coordinates
    are set up for the horizontal and vertical clipping planes. Before drawing the
    bar chart, the horizontal and vertical *x* and *y* axes have to be drawn, so vertices
    for two lines are grouped in the `glBegin` and `glEnd` pair with the `GL_LINES`
    keyword.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个二维正交视图区域，即设置水平和垂直裁剪平面的坐标。在绘制条形图之前，必须绘制水平和垂直的 *x* 和 *y* 轴，因此将两条线的顶点组合在 `glBegin`
    和 `glEnd` 对中，使用 `GL_LINES` 关键字。
- en: After drawing the *x* and *y* axes, a `for` loop is set to execute three times
    because we need to draw three bars. Within the `for` loop, the bars are given
    a fixed width of 2 px, and, after every bar chart, the *x* axis of the next bar
    is computed. Also, the height of the bar – that is, the *y* coordinate – is computed
    on the basis of the profit percentage mentioned in each result array. The bar
    chart is displayed using the four vertices that are grouped in the `glBegin` and
    `glEnd` pair with the `GL_POLYGON` keyword.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制 *x* 和 *y* 轴之后，设置一个 `for` 循环执行三次，因为我们需要绘制三个条形图。在 `for` 循环中，条形图被赋予固定的宽度 2
    px，并且在每个条形图之后，计算下一个条形图的 *x* 轴。此外，条形图的高度——即 *y* 坐标——是基于每个结果数组中提到的利润百分比计算的。条形图使用
    `glBegin` 和 `glEnd` 对中的四个顶点以及 `GL_POLYGON` 关键字显示。
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序，请启动 X 服务器并输入以下命令来编译程序：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If no error appears, that means the `opengldrawbar.c` program has successfully
    compiled into an executable file: `opengldrawbar.exe`. This file is executed using
    the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现错误，这意味着 `opengldrawbar.c` 程序已成功编译成可执行文件：`opengldrawbar.exe`。此文件使用以下命令执行：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will get the output as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下截图所示的输出：
- en: '![](img/f79d0021-098e-4f4a-b6be-7647cc1b6029.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f79d0021-098e-4f4a-b6be-7647cc1b6029.png)'
- en: Figure 12.4
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4
- en: Voilà! We have successfully created a bar chart using data entered in an array.
    Now let's move on to the next recipe!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用数组中输入的数据创建了一个条形图。现在让我们继续下一个菜谱！
- en: Making an animated bouncing ball
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个动画弹跳球
- en: In this recipe, we will learn to create an animation of a bouncing ball. The
    ball will be made to appear as if it is falling on the floor and then bouncing
    back up. To make the ball appear as falling to the floor, the ball is displayed
    at certain *x, y* coordinates; after drawing the ball, it is cleared from its
    current place and redrawn just below its original location. This process of drawing
    of the ball, erasing it, and redrawing at a lower *y* coordinate location in quick
    succession will make the ball appear as if it is falling to the ground. The reverse
    procedure can be used to show the ball bouncing back up.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个弹跳球的动画。球将看起来像是落在地板上然后弹回。为了使球看起来像是落在地板上，球被显示在特定的 *x, y* 坐标上；在绘制球之后，它从当前位置清除并重新绘制在其原始位置的下方。这种快速连续绘制球、清除它并在较低的
    *y* 坐标位置重新绘制的操作将使球看起来像是落在地面上。可以使用相反的过程来显示球弹回。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following are the steps to make a small animation of a bouncing ball:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个小型弹跳球动画的步骤如下：
- en: GLUT is initialized, the top-level window is defined as being of a specific
    size, its position is set, and, finally, the top-level window is created.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GLUT 已初始化，顶层窗口被定义为特定大小，其位置被设置，最后创建了顶层窗口。
- en: The callback function is invoked to display a bouncing ball.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用回调函数以显示弹跳球。
- en: In the callback function, the color buffers are cleared and the color of the
    bouncing ball is set to green.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在回调函数中，清除颜色缓冲区，并将弹跳球的颜色设置为绿色。
- en: The `glPointSize` is set to 1 px because the circle will be drawn with the help
    of small points or dots.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`glPointSize` 设置为 1 px，因为圆将通过小点或点来绘制。'
- en: The `GL_PROJECTION` is set as the current matrix in order to enable parallel
    and perspective projections. Also, a two-dimensional orthographic viewing region
    is set up.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GL_PROJECTION` 被设置为当前矩阵，以便启用平行和透视投影。同时，设置了一个二维正交视域区域。'
- en: To make the falling section of the animation, a ball is drawn at some *x, y*
    coordinate. After drawing that ball, the screen is cleared, and the ball is redrawn
    at a lower location (at a lower *y* coordinate).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要制作动画的下落部分，在某个 *x, y* 坐标处画一个球。画完那个球后，清除屏幕，并在更低的位置（在更低的 *y* 坐标处）重新绘制球。
- en: The preceding step is repeated in quick succession to give the appearance of
    a falling ball.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个步骤会快速连续重复，以产生下落球体的效果。
- en: To make the ball bounce back up, the ball is drawn, then the screen is cleared,
    and the ball is redrawn at a higher *y* coordinate that is just above the *ground*
    location.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使球体弹回，绘制球体，然后清除屏幕，并在高于 *地面* 位置的更高 *y* 坐标处重新绘制球体。
- en: 'The program for making an animated bouncing ball is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 制作动画弹跳球的程序如下：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入幕后，更好地理解代码。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GLUT is initialized and a top-level window is created with the label, `Animating
    a ball`. The initial position of the window is set at *0,0*, that is, at *x=0*
    and *y=0* coordinate location. The window size is specified with 1,000 px of width
    and 1,000 px of height. The callback function, `animball`, is invoked to display
    a bouncing ball.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: GLUT 被初始化，并创建了一个带有标签 `Animating a ball` 的顶层窗口。窗口的初始位置设置为 *0,0*，即 *x=0* 和 *y=0*
    坐标位置。窗口大小指定为 1,000 px 宽和 1,000 px 高。调用回调函数 `animball` 来显示弹跳球。
- en: In the `animball` callback function, the values of the color buffers are cleared.
    The color for drawing the bouncing ball is set to green. Because the ball will
    be drawn using small points or dots, the `glPointSize` is set to 1 px.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `animball` 回调函数中，清除颜色缓冲区的值。绘制弹跳球的颜色设置为绿色。因为球体将使用小点或点绘制，所以 `glPointSize` 设置为
    1 px。
- en: The `GL_PROJECTION` is set as the current matrix in order to enable parallel
    and perspective projections. Also, a two-dimensional orthographic viewing region
    is set up, defining the left and right vertical clipping planes and the bottom
    and top horizontal clipping planes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`GL_PROJECTION` 被设置为当前矩阵，以便启用平行和透视投影。同时，设置了一个二维正交视域区域，定义了左右垂直裁剪平面以及底部和顶部水平裁剪平面。'
- en: To display a bouncing ball, we first make the ball drop down on the floor and
    then bounce back up. To make the falling ball, we draw a ball at some *x, y* coordinate.
    After drawing that ball, we clear the screen and redraw the ball just below the
    original coordinate, that is, after lowering the *y* coordinate. Clearing and
    redrawing the ball with successively falling *y* coordinates repetitively and
    swiftly will make the ball appear as if it's falling. We will do the reverse to
    make the ball bounce up. That is, the ball is drawn, the screen is cleared, and
    the ball is redrawn at successively higher *y* coordinates. The radius of the
    ball is assumed to be 100 px (but it can be any radius).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示弹跳球，我们首先让球体落在地板上，然后弹回。为了制作下落球体，我们在某个 *x, y* 坐标处画一个球。画完那个球后，我们清除屏幕，并在原始坐标下方（即降低
    *y* 坐标）重新绘制球。通过重复快速地以逐渐降低的 *y* 坐标清除和重新绘制球，球体看起来就像在下落。我们将执行相反的操作来使球体弹起。也就是说，球体被绘制，屏幕被清除，并在逐渐更高的
    *y* 坐标处重新绘制球体。假设球体的半径为 100 px（但可以是任何半径）。
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序，启动 X 服务器，并给出以下命令来编译程序：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If no error appears, that means the `ballanim.c` program has successfully compiled
    into an executable file: `ballanim.exe`. This file is executed using the following
    command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现错误，这意味着 `ballanim.c` 程序已成功编译成可执行文件：`ballanim.exe`。此文件使用以下命令执行：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will get the output as shown in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下截图所示的输出：
- en: '![](img/ced1c048-8a20-4f46-9276-9f474f4dfa88.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ced1c048-8a20-4f46-9276-9f474f4dfa88.png)'
- en: Figure 12.5
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5
- en: Voilà! We have successfully created an animated bouncing ball.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功创建了一个动画弹跳球。
