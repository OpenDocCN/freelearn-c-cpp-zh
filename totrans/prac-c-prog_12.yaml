- en: Creativity with Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OpenGL** (short for **Open Graphics Library**) is a cross-platform **application
    program interface** (**API**) used for rendering two- and three-dimensional graphics;
    it works independently of operating systems. It provides several built-in routines
    for displaying graphics and for applying special effects, anti-aliasing, and different
    transformations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL had a library called the **OpenGL Utility Toolkit** (**GLUT**), but
    it has not been supported for several years. FreeGLUT, a free, open source piece
    of software, is used as an alternative in its place. GLUT was very popularly used
    in graphics applications as it is highly portable and is very simple to use. It
    has a large library of functions for creating windows, different graphical shapes,
    event handling, and more. If FreeGLUT is not installed on your computer and you
    have Windows OS on your computer, you can download `freeglut 3.0.0` for MinGW
    and extract it. On Ubuntu, you need to give the following command to install FreeGLUT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we will learn to do the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing four graphical shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a circle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a line between two mouse clicks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a bar graph of the supplied values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an animated bouncing ball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of OpenGL functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we delve into the recipes, let''s have a quick overview of some OpenGL
    functions that we will be using in this chapter. The following are some of the
    most frequently used OpenGL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `glutInit` | Used to initialize GLUT. |'
  prefs: []
  type: TYPE_TB
- en: '| `glutCreateWindow` | Used for creating a top-level window. You can supply
    the window name as a label while creating the window. |'
  prefs: []
  type: TYPE_TB
- en: '| `glutInitWindowSize` | Used to define the window size. The width and height
    of the window are specified in pixels while defining the window size. |'
  prefs: []
  type: TYPE_TB
- en: '| `void glutInitWindowPosition` | Used to set the initial window position.
    The window''s *x* and *y* locations are specified in terms of pixels. |'
  prefs: []
  type: TYPE_TB
- en: '| `glutDisplayFunc` | Used to specify the callback function to be executed
    to display graphics in the current window. For redisplaying the content in the
    window too, the specified callback function is executed. |'
  prefs: []
  type: TYPE_TB
- en: '| `glutMainLoop` | This is an entry point for the GLUT event processing loop.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `glClearColor` | Used to specify clear values for the color buffers. You
    need to specify the red, green, blue, and alpha values used when the color buffers
    are cleared. The initial values are all 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `glClear` | Used to clear the buffers to preset values. Certain masks can
    be used to specify the buffers to be cleared. The following are three masks that
    can be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_COLOR_BUFFER_BIT` | This mask represents the buffers that are currently
    being used for applying colors. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEPTH_BUFFER_BIT` | This mask represents the depth buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_STENCIL_BUFFER_BIT` | This mask represents the stencil buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| `glBegin` | Used for grouping statements that lead to a specific shape. You
    can create different shapes such as points, lines, triangles, rectangles, and
    more, by grouping the required vertices within this grouping statement. The shape
    that you want to create can be specified by specifying any of the modes: `GL_POINTS`,
    `GL_LINES`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`,
    `GL_TRIANGLE_FAN`, `GL_QUADS`, `GL_QUAD_STRIP`, and `GL_POLYGON`. |'
  prefs: []
  type: TYPE_TB
- en: '| `glEnd` | Used to end the group of statements. |'
  prefs: []
  type: TYPE_TB
- en: '| `glColor3f` | Used to set the current color for drawing graphics. The values
    for the red, green, and blue colors (in this strict sequence) can be specified
    to set the color. The values of these colors can be between 0 and 1, where 0 is
    the lowest intensity and 1 is the highest intensity of the color. |'
  prefs: []
  type: TYPE_TB
- en: '| `glVertex` | Used to specify coordinates for the point, line, and polygon
    vertices. This function has to be enclosed between a `glBegin`/`glEnd` pair. There
    might be a suffix of 2, 3, or 4 after `glVertex`, depending on the number of coordinates
    required for defining the vertex. For example, if two coordinates, *x* and *y*,
    are required to specify the vertex, then a value of 2 will be added as a suffix
    to `glVertex` making it `glVertex2`. Similarly, 3 and 4 can be suffixed if the
    coordinates required for specifying the vertex are 3 and 4, respectively. Also,
    one more suffix can be added, such as `s`, `i`, `f`, or `d` if the vertex coordinates
    are of the `short`, `int`, `float` or `double` data types respectively. For example,
    `glVertex2f()` can be used to specify the vertex with *x* and *y* coordinates,
    and the coordinate values will be of the `float` data type. |'
  prefs: []
  type: TYPE_TB
- en: '| `glLineWidth` | Used to specify the width of the line to be drawn. The width
    of the line can be specified in terms of pixels. The default width is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `glPointSize` | Used to specify the diameter of rasterized points. The default
    diameter is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `glFlush` | The commands sometimes get buffered depending on the resource
    utilization and networking situation. The `glFlush` function empties all the buffers
    and ensures that the commands are executed as early as possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `glutSwapBuffers` | This function is used for swapping the front buffer with
    the back buffer. The front buffer displays the image or frame on the screen and
    the back buffer is where the image (or frame) hasn''t yet been rendered. Once
    the image or frame is rendered in the back buffer, then this function swaps the
    front and back buffers, displaying the image that is now ready in the back buffer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `glutReshapeFunc` | Used for specifying the reshape callback function for
    the current window. The function is invoked automatically during these situations:
    when a window is reshaped, before a window''s first display callback, and after
    a window is created. |'
  prefs: []
  type: TYPE_TB
- en: '| `glViewport` | Used to set the viewport, that is, the vicinity of the window
    in which we want the rendered image to appear. Four arguments are passed to the
    function. The first two arguments represent the lower-left corner of the viewport
    rectangle in terms of pixels. The third and fourth arguments represent the width
    and height of the viewport. The width and height of the viewport are usually set
    to be equal to the dimensions of the window or less in size. |'
  prefs: []
  type: TYPE_TB
- en: '| `glMatrixMode` | Used to specify which matrix is the current matrix. The
    vertices are rendered on the basis of the current state of the matrix, so a matrix
    must be chosen so that it serves our needs. The following are the two main options.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_MODELVIEW` | This is the default matrix option. This option is used when
    the user wants to perform translation, rotation, or similar operations. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_PROJECTION` | This option is used when the user wants to perform parallel
    projection, perspective projection, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `glLoadIdentity` | Used to replace the current matrix with the identity matrix.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gluOrtho2D` | Used to set up a two-dimensional orthographic viewing region.
    Four arguments are passed to this function. The first two coordinates represent
    the left and right vertical clipping planes. The last two specify the coordinates
    for the bottom and top horizontal clipping planes. |'
  prefs: []
  type: TYPE_TB
- en: '| `glutMouseFunc` | Used to set the mouse callback function for the current
    window. That is, whenever the mouse button is pressed or released, each action
    invokes the mouse callback function. In the callback function, the following three
    arguments are automatically passed. |'
  prefs: []
  type: TYPE_TB
- en: '| `button` | It represents any of the three buttons, `GLUT_LEFT_BUTTON`, `GLUT_MIDDLE_BUTTON`,
    or `GLUT_RIGHT_BUTTON`, depending on which of the mouse buttons is pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `state` | The state can be either `GLUT_UP` or `GLUT_DOWN` depending on whether
    the callback was invoked because of the mouse release or mouse press, respectively.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `x` and `y` | Represents the window''s relative coordinates when the mouse
    button state changes. |'
  prefs: []
  type: TYPE_TB
- en: '| `glutIdleFunc` | Used to set the global idle callback, mainly used for performing
    background processing tasks. The idle callback is continuously called even if
    no event is occurring. The `NULL` parameter is sent to this function to disable
    the generation of the idle callback. |'
  prefs: []
  type: TYPE_TB
- en: You need to initialize the **X Window System** (**X11**) for working with graphics.
    X11 provides a GUI environment, that is, it enables the displaying of windows
    and graphics, and provides an environment for interacting with a mouse and keyboard.
    The command used for starting the X11 is the `xinit` command.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing four graphical shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn to draw four different shapes: a square, a triangle,
    points, and a line.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to make different graphical shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize GLUT, define the window size, create the window, and set the position
    of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the callback function that will be automatically invoked after displaying
    the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a square, first, define its color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a square by defining its four vertices and enclosing them within `glBegin`
    and `glEnd` statements along with the `GL_QUADS` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a line, set the width and color of the line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group a pair of vertices within `glBegin` and `glEnd` with the `GL_LINES` keyword
    to draw a line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw the points, set the point size to 3 px and also set their color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The vertices are where the points have to be displayed. Group them into a pair
    of `glBegin` and `glEnd` with the `GL_POINTS` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a triangle, group three vertices into `glBegin` and `glEnd` statements
    along with the `GL_TRIANGLES` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `glFlush` function is invoked to empty all the buffered statements and get
    the shapes drawn quickly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for drawing the preceding four shapes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step, as expected, is that GLUT is initialized, followed by creating
    a top-level window, and the label supplied for the window is `Drawing some shapes`.
    However, you can give it any label. The window is defined with a width of 1,500
    px and height of 1,500 px. The initial position of the window is set at 0,0, that
    is, at the coordinates of *x=0* and *y=0*. The `drawshapes` callback function is
    invoked for displaying different shapes in the window.
  prefs: []
  type: TYPE_NORMAL
- en: In the `drawshapes` function, the values of the color buffers are cleared, followed
    by clearing the buffers to preset values.
  prefs: []
  type: TYPE_NORMAL
- en: The first shape that we are drawing is a square, so a group of statements for
    drawing a square are enclosed within `glBegin` and `glEnd` statements. The `GL_QUADS`
    keyword is supplied with the `glBegin` statement because a quad refers to any
    shape that comprises 4 vertices. The `glColor3f` function is invoked to create
    a square filled with the color blue. The four sets of vertices are supplied to
    make a square. A vertex comprises *x* and *y* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will draw lines. The `glLineWidth` function is invoked to specify the
    width of the lines to be drawn as 2 px wide. The `glColor3f` function is invoked
    to make the lines appear in the color red. Two vertices are grouped within `glBegin`
    and `glEnd` with the `GL_LINES` keyword to draw a line.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will draw two points. To make the points clearly visible, the point
    size is set to 3 px, and the color in which the points will be drawn is set to
    red (or any color except black). The two vertices where we want the points to
    be displayed are supplied after being grouped into a pair of `glBegin` and `glEnd` statements.
    The `GL_POINTS` keyword is supplied with the `glBegin` statement to draw the points.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we draw a triangle by grouping three triangle vertices into `glBegin`
    and `glEnd` statements. The `GL_TRIANGLES` keyword is supplied with `glBegin`
    to indicate that the vertices that are specified in the group are meant for drawing
    a triangle. `glColor3f` is invoked to make sure the triangle will be filled with
    the color green.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `glFlush` function is invoked to empty all the buffered statements
    and get them executed quickly to display the desired shapes.
  prefs: []
  type: TYPE_NORMAL
- en: To compile the program, we need to open the Command Prompt and change the directory
    to the folder where the program is saved. Then, we execute the `xinit` command
    at the command prompt to start the X server (X11).
  prefs: []
  type: TYPE_NORMAL
- en: Once X server starts, give the following command to compile the program. Remember
    that the program has to be linked with `-lGL -lGLU -lglut` while compiling the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `filename.c` is the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following command to compile our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error appears, this means the `opengldrawshapes.c` program has successfully
    been compiled into an executable file: `opengldrawshapes.exe`. This file is executed
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/893ec14f-dd2a-48e1-ba9f-86b7a51ecea1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully drawn four different graphical shapes: a square,
    triangle, points, and a line. Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a circle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The procedure for drawing a circle is completely different from the other graphical
    shapes, hence it gets its own dedicated recipe. It needs a `for` loop to draw
    small points or lines at 0 to 360 degrees. So, let's learn to draw a circle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps for drawing a circle:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize GLUT, define the size of a top-level window, and create it. Also,
    set the initial position of the window for displaying our circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a callback function that is auto-invoked after creating the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the callback function, color buffers are cleared and the color for displaying
    the circle is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The statements for drawing a circle are grouped within a pair of `glBegin` and
    `glEnd` functions along with the `GL_LINE_LOOP` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `for` loop to draw small lines from 0 to 360 to give the shape of a circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for drawing a circle is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GLUT is initialized and a top-level window is created with the label, `Drawing
    some shapes`. The size of the window is defined as 1,500 px wide and 1,500 px
    in height. The initial position of the window is set at 0, 0, that is, at the *x=0*
    and *y=0* coordinate location. The `drawshapes` callback function is invoked for
    drawing a circle in the window.
  prefs: []
  type: TYPE_NORMAL
- en: In the `drawshapes` function, the values of the color buffers are cleared, followed
    by clearing the buffers to preset values. The `glColor3f` function is invoked
    to set the color in which we want to draw the circle. I have set the color to
    green to draw the circle but you can choose any color. A group of statements meant
    for drawing a circle is collected within a pair of `glBegin` and `glEnd` functions.
    The `glBegin` function is supplied to the `GL_LINE_LOOP` keyword to indicate that
    the circle that we are going to draw will be made up of several small lines.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `glBegin` and `glEnd` functions, a `for` loop is used that executes
    from value 0 to 360; that is, a very small line will be drawn at every degree
    from 0 until 360 to give it the shape of a circle. The degree is first converted
    into radians and the line is drawn at the vertex location, *cos(angle) * radius,
    sin(angle)* radius*. When such small lines are drawn at every degree, it will
    give it the appearance of a circle on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error appears, that means the `opengldrawshapes2.c` program has successfully
    compiled into an executable file: `opengldrawshapes2.exe`. This file is executed
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2da366c-7cad-4c0f-a71d-0a79a25a9d78.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully learned how to draw a circle. Now let's move on
    to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a line between two mouse clicks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to draw a line between two mouse clicks. A mouse
    click is considered a procedure of pressing the mouse button and releasing it.
    You can draw as many lines as you want between a pair of mouse press and release
    events.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to draw a line between two mouse clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize GLUT, define the size of the top-level window, and display the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `drawLine` callback function that draws a line if any mouse click event
    occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `drawLine` function, the clear values for the clear buffers are specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `glutSwapBuffers()` function is invoked to swap the front and back buffers
    to display any frame that is rendered in the back buffer and is ready to be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `glutReshapeFunc` function is invoked to specify the reshape callback function
    that will be auto-invoked whenever the window is reshaped to redraw the lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the vertices of the line are rendered on the basis of the current state
    of the matrix, a matrix is set as the current matrix for the viewing and modeling
    transformations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A two-dimensional orthographic viewing region is also set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mouse callback function is set up with the name `mouseEvents`. The callback
    is invoked whenever the mouse button is pressed or released.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As per the coordinates where the mouse button is pressed and released, the `drawLine`
    function will be invoked to draw the lines between the two coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for drawing a line between two mouse clicks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GLUT is initialized and a top-level window is created with the label, `Displaying
    lines between two mouse clicks`. The window size is specified as 1,000 px wide
    and 1,000 px in height. The `drawLine` callback function is invoked for drawing
    lines if any mouse click event has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In the `drawLine` function, the clear values for the clear buffers are specified.
    Also, the buffers are cleared to preset values so that colors can be applied to
    them. Because no mouse click has occurred yet, the value of `noOfClicks` global
    variable is 0, and hence no line will be drawn at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The `glutSwapBuffers()` function is invoked to swap the front and back buffers
    to display any frame that is rendered in the back buffer and is ready to be displayed.
    Because no mouse click has been made yet, nothing will happen with this function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `glutReshapeFunc` function is invoked to specify the reshape callback
    function for the current window. The callback function projection will be invoked
    automatically whenever the window is reshaped, before the window's first display
    callback and after the window is created. In the projection callback, a viewport
    is set to define the vicinity in which we want the lines to be drawn. Thereafter,
    a matrix is set as the current matrix for the viewing and modeling transformations.
    Also, the vertices are rendered on the basis of the current state of the matrix,
    so the matrix is chosen accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, a two-dimensional orthographic viewing region is also set up.
    The mouse callback function is set up with the name `mouseEvents`, so whenever
    a mouse button is pressed or released, the `mouseEvents` callback function will
    be automatically invoked. In the callback function, the information about which
    mouse button is pressed and whether the mouse button is pressed or released is
    passed. Also, the *x* and *y* coordinates where the mouse action takes place are
    also passed to the `mouseEvents` callback function.
  prefs: []
  type: TYPE_NORMAL
- en: In the `mouseEvents` function, first, it checks whether the left mouse button
    is pressed. If yes, then the location where the mouse button is released, that
    location's *x* and *y* coordinates are picked up and assigned to the `coord` array.
    Basically, the mouse button has to be pressed and then released to store the coordinate
    values. When two mouse clicks and releases are observed, the `drawLine` function
    is invoked to draw the lines between the two coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error appears, that means the `openglmouseclick.c` program has successfully
    compiled into an executable file: `openglmouseclick.exe`. This file is executed
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f60dee79-2a14-4177-bcc0-67bbce7dba6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3
  prefs: []
  type: TYPE_NORMAL
- en: Once you implement this functionality, you can draw as many lines as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Making a bar graph of the supplied values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to draw bar charts. Let's assume we have data
    about the percentage of profit growth of a company for the last three years. We
    will assign that percentage of profit growth to an array, and on the basis of
    the values in the array, we will draw a bar chart with three bars on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps for drawing a bar chart with the values defined
    in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize GLUT, define the size of the top-level window, set its initial position
    for display, and display the window on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the callback function that is auto-invoked after creating a window for
    drawing the bar chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An array is defined in the callback that defines the height of the bar chart.
    The width of the bar chart is fixed at 2 px.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A two-dimensional orthographic viewing region is set up, that is, coordinates
    are set up for horizontal and vertical clipping planes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the horizontal and vertical *x* and *y* axes, the vertices for the
    two lines are grouped in a `glBegin` and `glEnd` pair with the `GL_LINES` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to display three bars, a `for` loop is set to execute three times.
    To display bars one beside the other, the *x* axis of the next bar is computed.
    The height of each bar is computed on the basis of the array defined in *step
    3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bar chart is displayed using the four vertices that are grouped in the `glBegin`
    and `glEnd` pair with the `GL_POLYGON` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for drawing a bar chart on the basis of values in an array is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GLUT is initialized and a top-level window is created with the label, `Displaying
    Bar Chart`. The initial position of the window is set at 0,0, that is, at the
    *x=0* and *y=0* coordinate location. The window size is specified as 500 px in
    width and 500 px in height. The `display` callback function is invoked for drawing
    the bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: In the display callback, a result array is initialized to three values. Basically,
    the values in the resulting array represent the growth in profit percentage of
    the company in the last three years. Let's assume the growth in the profit percentage
    of the company in 2019, 2018, and 2017 was 10%, 15%, and 5%, respectively. We
    want the three bars corresponding to this data to rest on the *x* axis, so the
    *y* coordinate is set to 0\. To make the first bar appear after some space, the
    *x* coordinate value is set to 1\. The width of each bar is set to 2\. The color
    for the bar chart is set to red.
  prefs: []
  type: TYPE_NORMAL
- en: A two-dimensional orthographic viewing region is set up, that is, coordinates
    are set up for the horizontal and vertical clipping planes. Before drawing the
    bar chart, the horizontal and vertical *x* and *y* axes have to be drawn, so vertices
    for two lines are grouped in the `glBegin` and `glEnd` pair with the `GL_LINES`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: After drawing the *x* and *y* axes, a `for` loop is set to execute three times
    because we need to draw three bars. Within the `for` loop, the bars are given
    a fixed width of 2 px, and, after every bar chart, the *x* axis of the next bar
    is computed. Also, the height of the bar – that is, the *y* coordinate – is computed
    on the basis of the profit percentage mentioned in each result array. The bar
    chart is displayed using the four vertices that are grouped in the `glBegin` and
    `glEnd` pair with the `GL_POLYGON` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error appears, that means the `opengldrawbar.c` program has successfully
    compiled into an executable file: `opengldrawbar.exe`. This file is executed using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f79d0021-098e-4f4a-b6be-7647cc1b6029.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully created a bar chart using data entered in an array.
    Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Making an animated bouncing ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to create an animation of a bouncing ball. The
    ball will be made to appear as if it is falling on the floor and then bouncing
    back up. To make the ball appear as falling to the floor, the ball is displayed
    at certain *x, y* coordinates; after drawing the ball, it is cleared from its
    current place and redrawn just below its original location. This process of drawing
    of the ball, erasing it, and redrawing at a lower *y* coordinate location in quick
    succession will make the ball appear as if it is falling to the ground. The reverse
    procedure can be used to show the ball bouncing back up.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to make a small animation of a bouncing ball:'
  prefs: []
  type: TYPE_NORMAL
- en: GLUT is initialized, the top-level window is defined as being of a specific
    size, its position is set, and, finally, the top-level window is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The callback function is invoked to display a bouncing ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the callback function, the color buffers are cleared and the color of the
    bouncing ball is set to green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `glPointSize` is set to 1 px because the circle will be drawn with the help
    of small points or dots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GL_PROJECTION` is set as the current matrix in order to enable parallel
    and perspective projections. Also, a two-dimensional orthographic viewing region
    is set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the falling section of the animation, a ball is drawn at some *x, y*
    coordinate. After drawing that ball, the screen is cleared, and the ball is redrawn
    at a lower location (at a lower *y* coordinate).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding step is repeated in quick succession to give the appearance of
    a falling ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the ball bounce back up, the ball is drawn, then the screen is cleared,
    and the ball is redrawn at a higher *y* coordinate that is just above the *ground*
    location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for making an animated bouncing ball is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GLUT is initialized and a top-level window is created with the label, `Animating
    a ball`. The initial position of the window is set at *0,0*, that is, at *x=0*
    and *y=0* coordinate location. The window size is specified with 1,000 px of width
    and 1,000 px of height. The callback function, `animball`, is invoked to display
    a bouncing ball.
  prefs: []
  type: TYPE_NORMAL
- en: In the `animball` callback function, the values of the color buffers are cleared.
    The color for drawing the bouncing ball is set to green. Because the ball will
    be drawn using small points or dots, the `glPointSize` is set to 1 px.
  prefs: []
  type: TYPE_NORMAL
- en: The `GL_PROJECTION` is set as the current matrix in order to enable parallel
    and perspective projections. Also, a two-dimensional orthographic viewing region
    is set up, defining the left and right vertical clipping planes and the bottom
    and top horizontal clipping planes.
  prefs: []
  type: TYPE_NORMAL
- en: To display a bouncing ball, we first make the ball drop down on the floor and
    then bounce back up. To make the falling ball, we draw a ball at some *x, y* coordinate.
    After drawing that ball, we clear the screen and redraw the ball just below the
    original coordinate, that is, after lowering the *y* coordinate. Clearing and
    redrawing the ball with successively falling *y* coordinates repetitively and
    swiftly will make the ball appear as if it's falling. We will do the reverse to
    make the ball bounce up. That is, the ball is drawn, the screen is cleared, and
    the ball is redrawn at successively higher *y* coordinates. The radius of the
    ball is assumed to be 100 px (but it can be any radius).
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the program, start the X server and give the following command to
    compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error appears, that means the `ballanim.c` program has successfully compiled
    into an executable file: `ballanim.exe`. This file is executed using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ced1c048-8a20-4f46-9276-9f474f4dfa88.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully created an animated bouncing ball.
  prefs: []
  type: TYPE_NORMAL
