["```cpp\n#include \"soundFoo\"\n// Create a client object with your app credentials.\nclient = soundFoo.new('YOUR_CLIENT_ID');\n// Fetch track to stream.\ntrack = client.get(\"/tracks/293\")\n// Get the tracks streaming URL.\nstream_url = client.get(track.stream_url, true); \n// stream URL, allow redirects\n// Print the tracks stream URL\nstd::cout << stream_url.location;\n```", "```cpp\n#include \"mainwindow.h\" \n#include <QApplication> \n\nint main(int argc, char *argv[]) { \n    QApplication a(argc, argv); \n    MainWindow w; \n    w.show(); \n\n    return a.exec(); \n} \n```", "```cpp\n#include <QMainWindow> \n\n#include <QAudioRecorder> \n#include <QAudioProbe> \n#include <QMediaPlayer> \n\nnamespace Ui { \n    class MainWindow; \n} \n\nclass MainWindow : public QMainWindow { \n    Q_OBJECT \n\npublic: \n    explicit MainWindow(QWidget *parent = nullptr); \n    ~MainWindow(); \n\npublic slots: \n    void playBluetooth(); \n    void stopBluetooth(); \n    void playOnlineStream(); \n    void stopOnlineStream(); \n    void playLocalFile(); \n    void stopLocalFile(); \n    void recordMessage(); \n    void playMessage(); \n\n    void errorString(QString err); \n\n    void quit(); \n\nprivate: \n    Ui::MainWindow *ui; \n\n    QMediaPlayer* player; \n    QAudioRecorder* audioRecorder; \n    QAudioProbe* audioProbe; \n\n    qint64 silence; // Microseconds of silence recorded so far. \n\nprivate slots: \n    void processBuffer(QAudioBuffer); \n}; \n```", "```cpp\n#include \"mainwindow.h\" \n#include \"ui_mainwindow.h\" \n\n#include \"voiceinput.h\" \n\n#include <QThread> \n#include <QMessageBox> \n\n#include <cmath> \n\n#define MSG_RECORD_MAX_SILENCE_US 5000000 \n\nMainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), \n    ui(new Ui::MainWindow) { \n    ui->setupUi(this); \n\n    // Set up menu connections. \n    connect(ui->actionQuit, SIGNAL(triggered()), this, SLOT(quit())); \n\n    // Set up UI connections. \n    connect(ui->playBluetoothButton, SIGNAL(pressed), this, SLOT(playBluetooth)); \n    connect(ui->stopBluetoothButton, SIGNAL(pressed), this, SLOT(stopBluetooth)); \n    connect(ui->playLocalAudioButton, SIGNAL(pressed), this, SLOT(playLocalFile)); \n    connect(ui->stopLocalAudioButton, SIGNAL(pressed), this, SLOT(stopLocalFile)); \n    connect(ui->playOnlineStreamButton, SIGNAL(pressed), this, SLOT(playOnlineStream)); \n    connect(ui->stopOnlineStreamButton, SIGNAL(pressed), this, SLOT(stopOnlineStream)); \n    connect(ui->recordMessageButton, SIGNAL(pressed), this, SLOT(recordMessage)); \n    connect(ui->playBackMessage, SIGNAL(pressed), this, SLOT(playMessage)); \n\n    // Defaults \n    silence = 0; \n\n    // Create the audio interface instances. \n    player = new QMediaPlayer(this); \n    audioRecorder = new QAudioRecorder(this); \n    audioProbe = new QAudioProbe(this); \n\n    // Configure the audio recorder. \n    QAudioEncoderSettings audioSettings; \n    audioSettings.setCodec(\"audio/amr\"); \n    audioSettings.setQuality(QMultimedia::HighQuality);     \n    audioRecorder->setEncodingSettings(audioSettings);     \n    audioRecorder->setOutputLocation(QUrl::fromLocalFile(\"message/last_message.amr\")); \n\n    // Configure audio probe. \n    connect(audioProbe, SIGNAL(audioBufferProbed(QAudioBuffer)), this, SLOT(processBuffer(QAudioBuffer))); \n    audioProbe->setSource(audioRecorder); \n\n    // Start the voice interface in its own thread and set up the connections. \n    QThread* thread = new QThread; \n    VoiceInput* vi = new VoiceInput(); \n    vi->moveToThread(thread); \n    connect(thread, SIGNAL(started()), vi, SLOT(run())); \n    connect(vi, SIGNAL(finished()), thread, SLOT(quit())); \n    connect(vi, SIGNAL(finished()), vi, SLOT(deleteLater())); \n    connect(thread, SIGNAL(finished()), thread, SLOT(deleteLater())); \n\n    connect(vi, SIGNAL(error(QString)), this, SLOT(errorString(QString))); \n    connect(vi, SIGNAL(playBluetooth), this, SLOT(playBluetooth)); \n    connect(vi, SIGNAL(stopBluetooth), this, SLOT(stopBluetooth)); \n    connect(vi, SIGNAL(playLocal), this, SLOT(playLocalFile)); \n    connect(vi, SIGNAL(stopLocal), this, SLOT(stopLocalFile)); \n    connect(vi, SIGNAL(playRemote), this, SLOT(playOnlineStream)); \n    connect(vi, SIGNAL(stopRemote), this, SLOT(stopOnlineStream)); \n    connect(vi, SIGNAL(recordMessage), this, SLOT(recordMessage)); \n    connect(vi, SIGNAL(playMessage), this, SLOT(playMessage)); \n\n    thread->start(); \n} \n```", "```cpp\nMainWindow::~MainWindow() { \n    delete ui; \n} \n\nvoid MainWindow::playBluetooth() { \n    // Use the link with the BlueZ Bluetooth stack in the Linux kernel to \n    // configure it to act as an A2DP sink for smartphones to connect to. \n} \n\n// --- STOP BLUETOOTH --- \nvoid MainWindow::stopBluetooth() { \n    // \n} \n```", "```cpp\nvoid MainWindow::playOnlineStream() { \n    // Connect to remote streaming service's API and start streaming. \n} \n\nvoid MainWindow::stopOnlineStream() { \n    // Stop streaming from remote service. \n} \n```", "```cpp\nvoid MainWindow::playLocalFile() { \n    player->setMedia(QUrl::fromLocalFile(\"music/coolsong.mp3\")); \n    player->setVolume(50); \n    player->play(); \n} \n\nvoid MainWindow::stopLocalFile() { \n    player->stop(); \n} \n```", "```cpp\nvoid MainWindow::recordMessage() { \n    audioRecorder->record(); \n} \n\nvoid MainWindow::playMessage() { \n    player->setMedia(QUrl::fromLocalFile(\"message/last_message.arm\")); \n    player->setVolume(50); \n    player->play(); \n} \n```", "```cpp\nvoid MainWindow::processBuffer(QAudioBuffer buffer) { \n    const quint16 *data = buffer.constData<quint16>(); \n\n    // Get RMS of buffer, if silence, add its duration to the counter. \n    int samples = buffer.sampleCount(); \n    double sumsquared = 0; \n    for (int i = 0; i < samples; i++) { \n        sumsquared += data[i] * data[i]; \n    } \n\n    double rms = sqrt((double(1) / samples)*(sumsquared)); \n\n    if (rms <= 100) { \n        silence += buffer.duration(); \n    } \n\n    if (silence >= MSG_RECORD_MAX_SILENCE_US) { \n        silence = 0; \n        audioRecorder->stop(); \n    } \n} \n```", "```cpp\nvoid MainWindow::errorString(QString err) { \n    QMessageBox::critical(this, tr(\"Error\"), err); \n} \n\nvoid MainWindow::quit() { \n    exit(0); \n} \n```", "```cpp\n#include <QObject> \n#include <QAudioInput> \n\nextern \"C\" { \n#include \"pocketsphinx.h\" \n} \n\nclass VoiceInput : public QObject { \n    Q_OBJECT \n\n    QAudioInput* audioInput; \n    QIODevice* audioDevice; \n    bool state; \n\npublic: \n    explicit VoiceInput(QObject *parent = nullptr); \n    bool checkState() { return state; } \n\nsignals: \n    void playBluetooth(); \n    void stopBluetooth(); \n    void playLocal(); \n    void stopLocal(); \n    void playRemote(); \n    void stopRemote(); \n    void recordMessage(); \n    void playMessage(); \n\n    void error(QString err); \n\npublic slots: \n    void run(); \n}; \n```", "```cpp\n#include <QDebug> \n#include <QThread> \n\n#include \"voiceinput.h\" \n\nextern \"C\" { \n#include <sphinxbase/err.h> \n#include <sphinxbase/ad.h> \n} \n\nVoiceInput::VoiceInput(QObject *parent) : QObject(parent) { \n    // \n} \n```", "```cpp\nvoid VoiceInput::run() { \n    const int32 buffsize = 2048; \n    int16 adbuf[buffsize]; \n    uint8 utt_started, in_speech; \n    uint32 k = 0; \n    char const* hyp; \n\n    static ps_decoder_t *ps; \n\n    state = true; \n\n    QAudioFormat format; \n    format.setSampleRate(16000); \n    format.setChannelCount(1); \n    format.setSampleSize(16); \n    format.setCodec(\"audio/pcm\"); \n    format.setByteOrder(QAudioFormat::LittleEndian); \n    format.setSampleType(QAudioFormat::UnSignedInt); \n\n    // Check that the audio device supports this format. \n    QAudioDeviceInfo info = QAudioDeviceInfo::defaultInputDevice(); \n    if (!info.isFormatSupported(format)) { \n       qWarning() << \"Default format not supported, aborting.\"; \n       state = false; \n       return; \n    } \n\n    audioInput = new QAudioInput(format, this); \n    audioInput->setBufferSize(buffsize * 2);    \n    audioDevice = audioInput->start(); \n\n    if (ps_start_utt(ps) < 0) { \n        E_FATAL(\"Failed to start utterance\\n\"); \n    } \n\n    utt_started = FALSE; \n    E_INFO(\"Ready....\\n\"); \n```", "```cpp\n    const char* keyfile = \"COMPUTER/3.16227766016838e-13/\\n\"; \n    if (ps_set_kws(ps, \"keyword_search\", keyfile) != 0) { \n        return; \n    } \n\n    if (ps_set_search(ps, \"keyword_search\") != 0) { \n        return; \n    } \n\n    const char* gramfile = \"grammar asr;\\ \n            \\ \n            public <rule> = <action> [<preposition>] [<objects>] [<preposition>] [<objects>];\\ \n            \\ \n            <action> = STOP | PLAY | RECORD;\\ \n            \\ \n            <objects> = BLUETOOTH | LOCAL | REMOTE | MESSAGE;\\ \n            \\ \n            <preposition> = FROM | TO;\"; \n    ps_set_jsgf_string(ps, \"jsgf\", gramfile); \n```", "```cpp\n    bool kws = true; \n    for (;;) { \n        if ((k = audioDevice->read((char*) &adbuf, 4096))) { \n            E_FATAL(\"Failed to read audio.\\n\"); \n        } \n\n        ps_process_raw(ps, adbuf, k, FALSE, FALSE); \n        in_speech = ps_get_in_speech(ps); \n\n        if (in_speech && !utt_started) { \n            utt_started = TRUE; \n            E_INFO(\"Listening...\\n\"); \n        } \n```", "```cpp\n        if (!in_speech && utt_started) { \n            ps_end_utt(ps); \n            hyp = ps_get_hyp(ps, nullptr); \n            if (hyp != nullptr) { \n                // We have a hypothesis. \n\n                if (kws && strstr(hyp, \"computer\") != nullptr) { \n                    if (ps_set_search(ps, \"jsgf\") != 0) { \n                        E_FATAL(\"ERROR: Cannot switch to jsgf mode.\\n\"); \n                    } \n\n                    kws = false; \n                    E_INFO(\"Switched to jsgf mode \\n\");                             \n                    E_INFO(\"Mode: %s\\n\", ps_get_search(ps)); \n                } \n                else if (!kws) { \n                    if (hyp != nullptr) { \n                        // Check each action. \n                        if (strncmp(hyp, \"play bluetooth\", 14) == 0) { \n                            emit playBluetooth(); \n                        } \n                        else if (strncmp(hyp, \"stop bluetooth\", 14) == 0) { \n                            emit stopBluetooth(); \n                        } \n                        else if (strncmp(hyp, \"play local\", 10) == 0) { \n                            emit playLocal(); \n                        } \n                        else if (strncmp(hyp, \"stop local\", 10) == 0) { \n                            emit stopLocal(); \n                        } \n                        else if (strncmp(hyp, \"play remote\", 11) == 0) { \n                            emit stopBluetooth(); \n                        } \n                        else if (strncmp(hyp, \"stop remote\", 11) == 0) { \n                            emit stopBluetooth(); \n                        } \n                        else if (strncmp(hyp, \"record message\", 14) == 0) { \n                            emit stopBluetooth(); \n                        } \n                        else if (strncmp(hyp, \"play message\", 12) == 0) { \n                            emit stopBluetooth(); \n                        } \n                    } \n                    else { \n                        if (ps_set_search(ps, \"keyword_search\") != 0){ \n                            E_FATAL(\"ERROR: Cannot switch to kws mode.\\n\"); \n                        } \n\n                        kws = true; \n                        E_INFO(\"Switched to kws mode.\\n\"); \n                    } \n                }                 \n            } \n\n            if (ps_start_utt(ps) < 0) { \n                E_FATAL(\"Failed to start utterance\\n\"); \n            } \n\n            utt_started = FALSE; \n            E_INFO(\"Ready....\\n\"); \n        } \n\n        QThread::msleep(100); \n    } \n\n} \n```", "```cpp\nmkdir build\ncd build\nqmake ..\nmake\n```"]