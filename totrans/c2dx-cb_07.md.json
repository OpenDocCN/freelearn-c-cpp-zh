["```cpp\nstd::vector<std::string> searchPaths; \nsearchPaths.push_back(\"ipad\"); \nFileUtils::setSearchPaths(searchPaths); \nSprite *sprite = Sprite::create(\"HelloWorld.png\");\nSprite *close  = Sprite::create(\"CloseNormal.png\");\n```", "```cpp\n{\n    \"packageUrl\" : \"http://example.com/assets_manager/\", \n    \"remoteVersionUrl\" : \n    \"http://example.com/assets_manager/version.manifest\", \n    \"remoteManifestUrl\" : \n    \"http://example.com/assets_manager/project.manifest\", \n    \"version\" : \"1.0.1\",}\n```", "```cpp\n{\n    \"packageUrl\" : \"http://example.com/assets_manager/\", \n    \"remoteVersionUrl\" : \"http://example.com/assets_manager/version.manifest\", \n    \"remoteManifestUrl\" : \"http://example.com/assets_manager/project.manifest\", \n    \"version\" : \"1.0.1\",\n    \"assets\" : {\n        \"HelloWorld.png\" : {\n            \"md5\" : \"b7892dc221c840550847eaffa1c0b0aa\" \n        }, \n        \"test.zip\" : {\n            \"md5\" : \"c7615739e7a9bcd1b66e0018aff07517\", \n            \"compressed\" : true\n        }\n    }\n}\n```", "```cpp\n{\n    \"packageUrl\" : \"http://example.com/assets_manager/\", \n    \"remoteVersionUrl\" : \n\"http://example.com/assets_manager/version.manifest\", \n    \"remoteManifestUrl\" : \n\"http://example.com/assets_manager/project.manifest\", \n    \"version\" : \"1.0.0\", \n}\n```", "```cpp\n#include \"cocos2d.h\"\n#include \"extensions/cocos-ext.h\"\n\nclass ResourceManager {\nprivate:\n    ResourceManager();\n    static ResourceManager* instance;\n\n    cocos2d::extension::AssetsManagerEx* _am; \n    cocos2d::extension::EventListenerAssetsManagerEx* _amListener; \n\npublic: \n    // custom event name \n    static const char* EVENT_PROGRESS; \n    static const char* EVENT_FINISHED; \n\n    virtual ~ResourceManager(); \n    static ResourceManager* getInstance(); \n\n    void updateAssets(std::string manifestPath); \n};\n```", "```cpp\n#include \"ResourceManager.h\"\n\nUSING_NS_CC;\nUSING_NS_CC_EXT;\n\n// custom event name\nconst char* ResourceManager::EVENT_PROGRESS = \"__cc_Resource_Event_Progress\"; \nconst char* ResourceManager::EVENT_FINISHED = \"__cc_Resource_Event_Finished\"; \n\nResourceManager* ResourceManager::instance = nullptr; \n\nResourceManager::~ResourceManager() {\n    CC_SAFE_RELEASE_NULL(_am);\n}\n\nResourceManager::ResourceManager()\n:_am(nullptr)\n,_amListener(nullptr)\n{\n\n}\n\nResourceManager* ResourceManager::getInstance() { \n    if (instance==nullptr) { \n        instance = new ResourceManager(); \n    } \n     return instance; \n}\n\nvoid ResourceManager::updateAssets(std::string manifestPath) \n{\n    std::string storagePath = FileUtils::getInstance()- \n    >getWritablePath(); \n    CCLOG(\"storage path = %s\", storagePath.c_str()); \n\n    if (_am!=nullptr) { \n        CC_SAFE_RELEASE_NULL(_am); \n    } \n    _am = AssetsManagerEx::create(manifestPath, storagePath); \n    _am->retain(); \n\n    if (!_am->getLocalManifest()->isLoaded()) { \n        CCLOG(\"Fail to update assets, step skipped.\"); \n    } else { \n        _amListener = EventListenerAssetsManagerEx::create(_am, \n[this](EventAssetsManagerEx* event){ \n            static int failCount = 0; \n            switch (event->getEventCode()) \n            {\n                case \nEventAssetsManagerEx::EventCode::ERROR_NO_LOCAL_MANIFEST: \n                { \n                    CCLOG(\"No local manifest file found, skip \n                    assets update.\");\n                    break; \n                } \n                case \nEventAssetsManagerEx::EventCode::UPDATE_PROGRESSION: \n                { \n                    std::string assetId = event->getAssetId(); \n                    float percent = event->getPercent(); \n                    std::string str; \n                    if (assetId == AssetsManagerEx::VERSION_ID) { \n                        // progress for version file\n                    } else if (assetId == \nAssetsManagerEx::MANIFEST_ID) {\n                        // progress for manifest file \n                    } else { \n                        // dispatch progress event \n                        CCLOG(\"%.2f Percent\", percent); \n                        auto event = \nEventCustom(ResourceManager::EVENT_PROGRESS); \n                        auto data = Value(percent); \n                        event.setUserData(&data); \n                        Director::getInstance()->getEventDispatcher()->dispatchEvent(&event); \n                    } \n\n                    break; \n                } \n                case \nEventAssetsManagerEx::EventCode::ERROR_DOWNLOAD_MANIFEST: \n                case \nEventAssetsManagerEx::EventCode::ERROR_PARSE_MANIFEST: \n\n                { \n                    CCLOG(\"Fail to download manifest file, update \nskipped.\"); \n                    break; \n                } \n                case \nEventAssetsManagerEx::EventCode::ALREADY_UP_TO_DATE: \n                case \nEventAssetsManagerEx::EventCode::UPDATE_FINISHED: \n                { \n                    CCLOG(\"Update finished. %s\", \n                    event->getMessage().c_str()); \n                    CC_SAFE_RELEASE_NULL(_am); \n                    // dispatch finished updating event \n                    Director::getInstance()->getEventDispatcher()- \n>dispatchCustomEvent(ResourceManager::EVENT_FINISHED); \n                    break; \n                } \n                case \nEventAssetsManagerEx::EventCode::UPDATE_FAILED: \n                { \n                    CCLOG(\"Update failed. %s\", event- \n>getMessage().c_str()); \n\n                    // retry 5 times, if error occurred \n                    failCount ++; \n                    if (failCount < 5) { \n                        _am->downloadFailedAssets(); \n                    } else { \n                        CCLOG(\"Reach maximum fail count, exit \nupdate process\"); \n                        failCount = 0; \n                    } \n                    break; \n                } \n                case \nEventAssetsManagerEx::EventCode::ERROR_UPDATING: \n                { \n                    CCLOG(\"Asset %s : %s\", event- \n>getAssetId().c_str(), event->getMessage().c_str()); \n                    break; \n                } \n                case \nEventAssetsManagerEx::EventCode::ERROR_DECOMPRESS: \n                { \n                    CCLOG(\"%s\", event->getMessage().c_str()); \n                    break;\n                } \n                default: \n                    break;\n            } \n        }); \n\n        // execute updating resources \n        Director::getInstance()->getEventDispatcher()- \n>addEventListenerWithFixedPriority(_amListener, 1); \n        _am->update(); \n    } \n}\n```", "```cpp\n// label for progress \nauto size = Director::getInstance()->getWinSize(); \nTTFConfig config(\"fonts/arial.ttf\", 30); \n_progress = Label::createWithTTF(config, \"0%\", \nTextHAlignment::CENTER); \n_progress->setPosition( Vec2(size.width/2, 50) ); \nthis->addChild(_progress); \n\n// progress event \ngetEventDispatcher()- \n>addCustomEventListener(ResourceManager::EVENT_PROGRESS, \n[this](EventCustom* event){ \n    auto data = (Value*)event->getUserData(); \n    float percent = data->asFloat(); \n    std::string str = StringUtils::format(\"%.2f\", percent) + \"%\"; \n    CCLOG(\"%.2f Percent\", percent); \n    if (this->_progress != nullptr) { \n        this->_progress->setString(str); \n    }\n}); \n\n// fnished updating event \ngetEventDispatcher()- \n>addCustomEventListener(ResourceManager::EVENT_FINISHED, \n[this](EventCustom* event){ \n    // clear cache \n    Director::getInstance()->getTextureCache()- \n>removeAllTextures(); \n    // reload scene \n    auto scene = HelloWorld::createScene(); \n    Director::getInstance()->replaceScene(scene); \n});\n\n// update resources \nResourceManager::getInstance()- \n>updateAssets(\"res/local.manifest\");\n```", "```cpp\nResourceManager::getInstance()->updateAssets(\"res/local.manifest\");\n```", "```cpp\n// clear cache Director::getInstance()->getTextureCache()->removeAllTextures();\n// reload sceneauto scene = HelloWorld::createScene(); \nDirector::getInstance()->replaceScene(scene);\n```", "```cpp\nLOCAL_SRC_FILES := hellocpp/main.cpp \\ \n                   ../../Classes/AppDelegate.cpp \\ \n                   ../../Classes/HelloWorldScene.cpp \\ \n                   ../../Classes/SQLiteManager.cpp \\ \n                   ../../Classes/sqlite/sqlite3.c\n```", "```cpp\n#include \"cocos2d.h\" #include \"sqlite/sqlite3.h\"\n\nclass SQLiteManager {\nprivate:\n    SQLiteManager();\n    static SQLiteManager* instance;\n    sqlite3 *_db;\n    bool open();\n    void close();\npublic:\n    virtual ~SQLiteManager();\n    static SQLiteManager* getInstance();\n    void insert(std::string key, std::string value);\n    std::string select(std::string key);\n};\n```", "```cpp\n    SQLiteManager* SQLiteManager::instance = nullptr; \n    SQLiteManager::~SQLiteManager() { \n    }\n\n    SQLiteManager::SQLiteManager()\n    {\n        if (this->open()) {\n            sqlite3_stmt* stmt;\n            // create table \n            std::string sql = \"CREATE TABLE IF NOT EXISTS \n    data(key TEXT PRIMARY KEY,value TEXT);\"; \n            if (sqlite3_prepare_v2(_db, sql.c_str(), -1, &stmt, \n    nullptr) == SQLITE_OK) { \n                if (sqlite3_step(stmt)!=SQLITE_DONE) { \n                    CCLOG(\"Error in CREATE TABLE\"); \n                }\n      } \n            sqlite3_reset(stmt); \n            sqlite3_finalize(stmt); \n            this->close(); \n       } \n    }\n\n    SQLiteManager* SQLiteManager::getInstance() { \n        if (instance==nullptr) { \n            instance = new SQLiteManager(); \n        }\n        return instance;\n    }\n    ```", "```cpp\n    bool SQLiteManager::open() \n    {\n        std::string path = FileUtils::getInstance()- \n    >getWritablePath()+\"test.sqlite\"; \n        return sqlite3_open(path.c_str(), &_db)==SQLITE_OK; \n    }\n\n    void SQLiteManager::close() \n    { \n        sqlite3_close(_db); \n    }\n    ```", "```cpp\n    void SQLiteManager::insert(std::string key, std::string value)\n    {\n        this->open();\n        // insert data\n        sqlite3_stmt* stmt;\n        std::string sql = \"INSERT INTO data (key, value) VALUES(?, ?)\";\n        if (sqlite3_prepare_v2(_db, sql.c_str(), -1, &stmt, nullptr) == SQLITE_OK) {\n            sqlite3_bind_text(stmt, 1, key.c_str(), -1, SQLITE_TRANSIENT);\n            sqlite3_bind_text(stmt, 2, value.c_str(), -1, SQLITE_TRANSIENT);\n            if (sqlite3_step(stmt)!=SQLITE_DONE) { \n                CCLOG(\"Error in INSERT 1, %s\", \n                sqlite3_errmsg(_db)); \n            }\n        }\n        sqlite3_reset(stmt);\n        sqlite3_finalize(stmt);\n        this->close();\n    }\n    ```", "```cpp\n    std::string SQLiteManager::select(std::string key){\n        this->open(); \n\n        // select data \n        std::string value; \n        sqlite3_stmt* stmt; \n        std::string sql = \"SELECT VALUE from data where key=?\"; \n        if (sqlite3_prepare_v2(_db, sql.c_str(), -1, &stmt, \n        NULL) == SQLITE_OK) { \n            sqlite3_bind_text(stmt, 1, key.c_str(), -1, \n            SQLITE_TRANSIENT); \n            if (sqlite3_step(stmt) == SQLITE_ROW) { \n                const unsigned char* val = \n                sqlite3_column_text(stmt, 0); \n                value = std::string((char*)val); \n                CCLOG(\"key=%s, value=%s\", key.c_str(), val); \n            } else {\n                CCLOG(\"Error in SELECT, %s\", \n                sqlite3_errmsg(_db));\n            }\n        } else {\n            CCLOG(\"Error in SELECT, %s\", sqlite3_errmsg(_db)); \n        } \n        sqlite3_reset(stmt); \n        sqlite3_finalize(stmt); \n        this->close(); \n        return value; \n    }\n    ```", "```cpp\n    SQLiteManager::getInstance()->insert(\"foo\", \"value1\");\n    ```", "```cpp\n    std::string value = SQLiteManager::getInstance()- \n    >select(\"foo\");\n    ```", "```cpp\nCREATE TABLE IF NOT EXISTS data(key TEXT PRIMARY KEY,value TEXT);\n```", "```cpp\nstd::string path = FileUtils::getInstance()->getWritablePath()+\"test.sqlite\";\n```", "```cpp\nSQLiteManager::getInstance()->insert(\"foo\", \"value1\");\n```", "```cpp\nstd::string value = SQLiteManager::getInstance()->select(\"foo\");\n```", "```cpp\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n    <key>key text</key>\n    <array>\n        <name>foo</name>\n        <name>bar</name>\n        <name>hoge</name>\n    </array>\n</root>\n```", "```cpp\n#include \"tinyxml2/tinyxml2.h\" \nusing namespace tinyxml2;\n```", "```cpp\nstd::string path = util->fullPathForFilename(\"res/test.xml\"); \nXMLDocument *doc = new XMLDocument();\nXMLError error = doc->LoadFile(path.c_str());\nif (error == 0) { \n    XMLElement *root = doc->RootElement(); \n    XMLElement *key = root->FirstChildElement(\"key\"); \n    if (key) { \n        CCLOG(\"key element = %s\", key->GetText()); \n    }\n    XMLElement *array = key->NextSiblingElement();\n    XMLElement *child = array->FirstChildElement();\n    while ( child ) {\n        CCLOG(\"child element= %s\", child->GetText());\n        child = child->NextSiblingElement();\n    }\n    delete doc;\n}\n```", "```cpp\nkey element = key text\nchild element= foo\nchild element= bar\nchild element= hoge\n```", "```cpp\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>foo</key>\n  <integer>1</integer>\n  <key>bar</key>\n  <string>This is string</string>\n</dict>\n</plist>\n```", "```cpp\nFileUtils* util = FileUtils::getInstance();\nstd::string path = util->fullPathForFilename(\"res/test.plist\");\nValueMap map = util->getValueMapFromFile(path); \nfor (auto element : map) { \n    std::string key = element.first; \n    Value value = element.second; \n    switch (value.getType()) { \n        case Value::Type::BOOLEAN: \n            CCLOG(\"%s, %s\", key.c_str(), \n            value.asBool()?\"true\":\"false\");\n            break; \n        case Value::Type::INTEGER: \n            CCLOG(\"%s, %d\", key.c_str(), value.asInt()); \n            break; \n        case Value::Type::FLOAT: \n            CCLOG(\"%s, %f\", key.c_str(), value.asFloat()); \n            break; \n        case Value::Type::DOUBLE: \n            CCLOG(\"%s, %f\", key.c_str(), value.asDouble()); \n            break; \n        case Value::Type::STRING: \n            CCLOG(\"%s, %s\", key.c_str(), \n            value.asString().c_str()); \n            break;        default: \n            break; \n    }\n}\n```", "```cpp\nValueMap map; for (int i=0; i<10; i++) { \n    std::string key = StringUtils::format(\"key_%d\", i); \n    Value val = Value(i); \n    map.insert(std::make_pair(key, val));\n}\nstd::string fullpath = util->getWritablePath() + \"/test.xml\"; \nFileUtils::getInstance()->writeToFile(map, fullpath);\n```", "```cpp\n#include \"json/rapidjson.h\"\n#include \"json/document.h\"\n```", "```cpp\nstd::string str = \"{\\\"hello\\\" : \\\"word\\\"}\";\n```", "```cpp\nrapidjson::Document d;\nd.Parse<0>(str.c_str());\nif (d.HasParseError()) { \n    CCLOG(\"GetParseError %s\\n\",d.GetParseError()); \n} else if (d.IsObject() && d.HasMember(\"hello\")) { \n    CCLOG(\"%s\\n\", d[\"hello\"].GetString()); \n}\n```", "```cpp\n[{\"name\":\"Tanaka\",\"age\":25}, {\"name\":\"Ichiro\",\"age\":40}]\n```", "```cpp\nstd::string jsonData = FileUtils::getInstance()- \n>getStringFromFile(\"res/test.json\"); \nCCLOG(\"%s\\n\", jsonData.c_str()); \nrapidjson::Document d; \nd.Parse<0>(jsonData.c_str()); \nif (d.HasParseError()) { \n    CCLOG(\"GetParseError %s\\n\",d.GetParseError()); \n} else { \n    if (d.IsArray()) { \n        for (rapidjson::SizeType i = 0; i < d.Size(); ++i) { \n            auto name = d[i][\"name\"].GetString(); \n            auto age = d[i][\"age\"].GetInt(); \n            CCLOG(\"name-%s, age=%d\", name, age); \n        }\n    }\n}\n```"]