<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-131"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-132"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.2.1">General-Purpose Peripherals</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Modern microcontrollers integrate several features that help in building stable and reliable embedded systems. </span><span class="koboSpan" id="kobo.3.2">Once the system is up and running, memory and peripherals can be accessed, and basic functionalities are in place. </span><span class="koboSpan" id="kobo.3.3">Only then can all the components of the system be initialized by activating the associated peripherals through the system registers, setting the correct frequencies for the clock lines, and configuring and activating interrupts. </span><span class="koboSpan" id="kobo.3.4">In this chapter, we will describe the interface exposed by the microcontroller to access built-in peripherals and some basic system functionalities. </span><span class="koboSpan" id="kobo.3.5">We will focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">interrupt controller</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">System time</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Generic timers</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.9.1">General-purpose </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.10.1">input/output</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.11.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.12.1">GPIO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.14.1">The watchdog</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">While these peripherals are often accessible through the hardware-support libraries implemented and distributed by chip manufacturers, our approach here involves fully understanding the hardware components and the meaning of all the registers involved. </span><span class="koboSpan" id="kobo.15.2">This will be achieved by configuring and using the functionalities in the microcontroller straight through the interface exported by the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">hardware logic.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">When designing drivers for a specific platform, it is necessary to study the interface provided by the microcontroller to access peripherals and CPU features. </span><span class="koboSpan" id="kobo.17.2">In the examples provided, the STM32F4 microcontroller is used as a reference target for implementing platform-specific features. </span><span class="koboSpan" id="kobo.17.3">Nevertheless, inspecting a possible implementation on our reference platform allows us to get better insight into how to interact with generic targets exposing similar functionalities using the documentation provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">silicon manufacturer.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.24.1">Bitwise operations</span></h2>
<p><span class="koboSpan" id="kobo.25.1">The</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.26.1"> examples associated with this chapter make extensive use of bitwise operations for checking, setting, and clearing single bits within larger registers (in most cases, 32-bit long). </span><span class="koboSpan" id="kobo.26.2">You should already be familiar with bitwise logic operations </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">in C.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">The operations commonly</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.29.1"> used in the examples are </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Setting the Nth bit in the register R via the assignment</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.32.1">R |= (1 &lt;&lt; N)</span></strong><span class="koboSpan" id="kobo.33.1">: The new value of the register R will contain the result of the bitwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">OR</span></strong><span class="koboSpan" id="kobo.35.1"> operation between its original value and a bitmask containing all zeros, except the bit corresponding to the value we want to set, which is set to the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">value one</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Clearing (resetting) the Nth bit in the register R via the assignment</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.38.1">R &amp;= ~(1 &lt;&lt; N)</span></strong><span class="koboSpan" id="kobo.39.1">: The new value of the register is the result of a bitwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">AND</span></strong><span class="koboSpan" id="kobo.41.1"> operation between its original value and a bitmask containing all ones, except the bit in the position we want to clear, which is set to the </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">value zero</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Checking whether the Nth bit of the register R is set or cleared, via the condition</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.44.1">(R &amp; (1 &lt;&lt; N) == (1 &lt;&lt; N))</span></strong><span class="koboSpan" id="kobo.45.1">: Returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">true</span></strong><span class="koboSpan" id="kobo.47.1"> only if the Nth bit of the register </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">is set</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.49.1">Let us quickly jump into the </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">first topic</span><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.52.1">The interrupt controller</span></h1>
<p><span class="koboSpan" id="kobo.53.1">Real-time systems</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.54.1"> have improved their accuracy thanks to the rapid evolution of modern embedded systems, in particular from the research on interrupt controllers. </span><span class="koboSpan" id="kobo.54.2">Assigning different priorities to interrupt lines guarantees a lower interrupt latency for higher-priority interrupt sources and makes the system react faster to prioritized events. </span><span class="koboSpan" id="kobo.54.3">Interrupts may, however, occur at any time while the system is running, including during the execution of another interrupt service routine. </span><span class="koboSpan" id="kobo.54.4">In this case, the interrupt controller provides a way to chain the interrupt handlers, and the order of execution depends on the priority levels assigned to the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">interrupt source.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">One of the </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.57.1">reasons for the popularity of the Cortex-M family of microprocessors among real-time and low-power embedded applications is perhaps the design of its programmable real-time controllerâ€”namely, the </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">Nested Vector Interrupt Controller</span></strong><span class="koboSpan" id="kobo.59.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">NVIC</span></strong><span class="koboSpan" id="kobo.61.1"> for short. </span><span class="koboSpan" id="kobo.61.2">The</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.62.1"> NVIC supports up to 240 interrupt sources, which can be grouped into up to 256 priority levels, depending on the bits reserved to store the priority in the microprocessor logic. </span><span class="koboSpan" id="kobo.62.2">These characteristics make it very flexible, as the priorities can also be changed while the system is running, maximizing the freedom of choice for the programmer. </span><span class="koboSpan" id="kobo.62.3">As we already know, the NVIC is connected to the vector table located at the beginning of the code region. </span><span class="koboSpan" id="kobo.62.4">Whenever an interrupt occurs, the current state of the executing application is pushed into the stack automatically by the processor, and the service routine associated with the interrupt line </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">is executed.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Systems that do not have an interrupt-priority mechanism implement back-to-back interrupt handling. </span><span class="koboSpan" id="kobo.64.2">In these cases, chaining interrupts implies that the context is restored at the end of the execution of the first service routine in line, and then saved again while entering the following one. </span><span class="koboSpan" id="kobo.64.3">The NVIC implements a tail-chaining mechanism to execute nested interrupts. </span><span class="koboSpan" id="kobo.64.4">If one or more interrupts occur while another service routine is executing, the pull operation normally occurring at the end of the interrupt to restore the context from the stack will be canceled, and the controller will instead fetch the location of the second handler in the interrupt vector and ensure it is executed immediately after the first. </span><span class="koboSpan" id="kobo.64.5">Because of the increased pace of the stack save and restore operations being implemented in hardware, the interrupt latency is significantly reduced in all those cases where interrupts are chained. </span><span class="koboSpan" id="kobo.64.6">Thanks to its implementation, NVIC allows us to change parameters while the system is running, and is able to reshuffle the order of execution of the interrupt service routines associated with the pending signals, according to the priority levels. </span><span class="koboSpan" id="kobo.64.7">Moreover, the same interrupt is not allowed to run twice in the same chain of handlers, which may be caused by altering the priorities in the other handlers. </span><span class="koboSpan" id="kobo.64.8">This is intrinsically enforced by the NVIC logic, which ensures that no loops are possible in </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">the ch</span><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.66.1">ain.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.67.1">Peripheralsâ€™ interrupt configuration</span></h2>
<p><span class="koboSpan" id="kobo.68.1">Each</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.69.1"> interrupt line can be enabled and disabled through the NVIC Interrupt Set/Clear Enable registers, </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">NVIC_ISER</span></strong><span class="koboSpan" id="kobo.71.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">NVIC_ICER</span></strong><span class="koboSpan" id="kobo.73.1">, located at addresses </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">0xE000E100</span></strong><span class="koboSpan" id="kobo.75.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">0xE000E180</span></strong><span class="koboSpan" id="kobo.77.1">, respectively. </span><span class="koboSpan" id="kobo.77.2">If the target supports more than 32 external interrupts, arrays of 32-bit registers </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.78.1">are mapped at the same locations. </span><span class="koboSpan" id="kobo.78.2">Each bit in the registers is used to activate a predefined interrupt line, associated with the bit position in that specific register. </span><span class="koboSpan" id="kobo.78.3">For example, on an STM32F4 microcontroller, in order to activate the interrupt line for </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.79.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Serial Peripheral Interface</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">SPI</span></strong><span class="koboSpan" id="kobo.83.1">) controller SPI1, which is associated with the number 35, the fourth bit should be set on the second register in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">NVIC_ISER</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1"> area.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">The generic NVIC function, to enable the interrupt, activates the flag corresponding to the NVIC interrupt number for the source, in the associate </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">NVIC_ISER</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.88.1"> register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.89.1">
#define NVIC_ISER_BASE (0xE000E100)
static inline void nvic_irq_enable(uint8_t n)
{
Â Â int i = n / 32;
Â Â volatile uint32_t *nvic_iser =
Â Â Â Â ((volatile uint32_t *)(NVIC_ISER_BASE + 4 * i));
Â Â *nvic_iser |= (1 &lt;&lt; (n % 32));
}</span></pre>
<p><span class="koboSpan" id="kobo.90.1">Similarly, to disable the interrupt, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">nvic_irq_disable</span></strong><span class="koboSpan" id="kobo.92.1"> function activates the corresponding bit in the interrupt </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">clear register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
#define NVIC_ICER_BASE (0xE000E180)
static inline void nvic_irq_disable(uint8_t n)
{
Â Â int i = n / 32;
Â Â volatile uint32_t *nvic_icer =
Â Â Â Â ((volatile uint32_t *)(NVIC_ICER_BASE + 4 * i));
Â Â *nvic_icer |= (1 &lt;&lt; (n % 32));
}</span></pre>
<p><span class="koboSpan" id="kobo.95.1">The</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.96.1"> interrupt priorities are mapped in an array of 8-bit registers, each containing the priority value for the corresponding</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.97.1"> interrupt line, starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">0xE000E400</span></strong><span class="koboSpan" id="kobo.99.1"> so that they can be accessed independently to change the priority </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">at runtime:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
#define NVIC_IPRI_BASE (0xE000E400)
static inline void nvic_irq_setprio(uint8_t n,
Â Â Â Â uint8_t prio)
{
Â Â volatile uint8_t *nvic_ipri = ((volatile uint8_t *)
Â Â Â (NVIC_IPRI_BASE + n));
Â Â *nvic_ipri = prio;
}</span></pre>
<p><span class="koboSpan" id="kobo.102.1">These functions will come in handy to route and prioritize interrupt lines whenever an interrupt is enabled for </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">a pe</span><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.104.1">ripheral.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.105.1">System time</span></h1>
<p><span class="koboSpan" id="kobo.106.1">Timekeeping </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.107.1">is a basic requirement for almost any embedded system. </span><span class="koboSpan" id="kobo.107.2">A microcontroller can be programmed </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.108.1">to trigger an interrupt at regular intervals, which is commonly used to increment the monotonic system clock. </span><span class="koboSpan" id="kobo.108.2">To do so, a few configuration steps must be performed at startup in order to have a stable tick interrupt. </span><span class="koboSpan" id="kobo.108.3">Many processors can run at custom frequencies while using the same oscillator as the source. </span><span class="koboSpan" id="kobo.108.4">The input frequency of the oscillator, which can be internal or external to the CPU, is used to derive the processorâ€™s main clock. </span><span class="koboSpan" id="kobo.108.5">The configurable logic integrated into the CPU is implemented </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.109.1">by a </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">phase-locked loop</span></strong><span class="koboSpan" id="kobo.111.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.112.1">PLL</span></strong><span class="koboSpan" id="kobo.113.1">) that multiplies the input clock from an external stable source and produces the desired frequencies used by the CPU and </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">integrated </span><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.115.1">peripherals.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.116.1">Adjusting the flash wait states</span></h2>
<p><span class="koboSpan" id="kobo.117.1">If the</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.118.1"> initialization code is running from flash, it might be necessary to set the wait state for the flash memory before altering the system clocks. </span><span class="koboSpan" id="kobo.118.2">If the microprocessor runs at high frequencies, it might require a few wait states in between </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.119.1">two consecutive access operations to persistent memory with </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">execute-in-place</span></strong><span class="koboSpan" id="kobo.121.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.122.1">XIP</span></strong><span class="koboSpan" id="kobo.123.1">) capabilities. </span><span class="koboSpan" id="kobo.123.2">Failing to set the correct wait states to match the ratio between the CPU speed and the access time of the flash would most likely result in a hard fault. </span><span class="koboSpan" id="kobo.123.3">The configuration registers for the flash memory are located in a platform-specific location within the internal peripheralâ€™s region. </span><span class="koboSpan" id="kobo.123.4">On STM32F407, the flash configuration registers are mapped starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">0x40023800</span></strong><span class="koboSpan" id="kobo.125.1">. </span><span class="koboSpan" id="kobo.125.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Access Control Register</span></strong><span class="koboSpan" id="kobo.127.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.128.1">ACR</span></strong><span class="koboSpan" id="kobo.129.1">), which</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.130.1"> is the one we need to access to set the wait states, is located at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the area:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
#define FLASH_BASE (0x40023C00)
#define FLASH_ACR (*(volatile uint32_t *)(FLASH_BASE +
Â Â Â 0x00))</span></pre>
<p><span class="koboSpan" id="kobo.133.1">The lowest three bits in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">FLASH_ACR</span></strong><span class="koboSpan" id="kobo.135.1"> register are used to set the number of wait states. </span><span class="koboSpan" id="kobo.135.2">According to the STM32F407 datasheet, the ideal number of wait states to access the flash while the system is running at 168 MHz is </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">5</span></strong><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">At the same time, we can enable the data and instruction cache by activating bits </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">10</span></strong><span class="koboSpan" id="kobo.139.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
void flash_set_waitstates(void) {
Â Â FLASH_ACR = 5 | (1 &lt;&lt; 10) | (1 &lt;&lt; 9);
}</span></pre>
<p><span class="koboSpan" id="kobo.143.1">After the wait states are set, it is safe to run the code from the flash after setting the CPU frequency at a higher speed, so we can proceed with the actual clock configuration and distribution to </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">t</span><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.145.1">he peripherals.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.146.1">Clock configuration</span></h2>
<p><span class="koboSpan" id="kobo.147.1">The</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.148.1"> configuration of the clocks in Cortex-M microcontrollers</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.149.1"> happens through the </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">Reset and Clock Control</span></strong><span class="koboSpan" id="kobo.151.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.152.1">RCC</span></strong><span class="koboSpan" id="kobo.153.1">) registers, located at a specific address within the internal peripheral region. </span><span class="koboSpan" id="kobo.153.2">The RCC configuration is vendor-specific, as it depends on the logic of the PLL implemented in the microcontroller. </span><span class="koboSpan" id="kobo.153.3">The registers are described in the documentation of the microcontroller, and often, example source code is provided by the chip manufacturer demonstrating how to properly configure the clocks on the microcontroller. </span><span class="koboSpan" id="kobo.153.4">On our reference target, STM32F407, assuming that an external 8 MHz oscillator is used as a source, the following procedure configures a 168 MHz system clock and ensures that the clock is also distributed to each peripheral bus. </span><span class="koboSpan" id="kobo.153.5">The following code ensures that the PLL is initialized with the required value and that the CPU clock is ticking at the desired frequency. </span><span class="koboSpan" id="kobo.153.6">This procedure is common among many STM Cortex-M microcontrollers, and the values for the PLL configurations can be obtained from the chip documentation, or calculated using software tools provided </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">by ST.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">The software examples provided after this point will make use of a system-specific module, exporting the functions needed to configure the clock and set the flash memory latency. </span><span class="koboSpan" id="kobo.155.2">We now analyze two possible implementations for the PLL configuration, on two different </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">Cortex-M microcontrollers.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">To access the configuration of the PLL in the STM32F407-Discovery, first, we define some shortcut macros to the addresses of the registers provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">RCC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
#define RCC_BASE (0x40023800)
#define RCC_CR (*(volatile uint32_t *)(RCC_BASE + 0x00))
#define RCC_PLLCFGR (*(volatile uint32_t *)(RCC_BASE +
Â Â Â Â 0x04))
#define RCC_CFGR (*(volatile uint32_t *)(RCC_BASE + 0x08))
#define RCC_CR (*(volatile uint32_t *)(RCC_BASE + 0x00))</span></pre>
<p><span class="koboSpan" id="kobo.162.1">For the sake of readability, and to ensure that the code is maintainable in the future, we also define the mnemonics associated with the single-bit values in the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">corresponding registers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
#define RCC_CR_PLLRDY (1 &lt;&lt; 25)
#define RCC_CR_PLLON (1 &lt;&lt; 24)
#define RCC_CR_HSERDY (1 &lt;&lt; 17)
#define RCC_CR_HSEON (1 &lt;&lt; 16)
#define RCC_CR_HSIRDY (1 &lt;&lt; 1)
#define RCC_CR_HSION (1 &lt;&lt; 0)
#define RCC_CFGR_SW_HSI 0x0
#define RCC_CFGR_SW_HSE 0x1
#define RCC_CFGR_SW_PLL 0x2
#define RCC_PLLCFGR_PLLSRC (1 &lt;&lt; 22)
#define RCC_PRESCALER_DIV_NONE 0
#define RCC_PRESCALER_DIV_2 8
#define RCC_PRESCALER_DIV_4 9</span></pre>
<p><span class="koboSpan" id="kobo.165.1">Finally, we </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.166.1">define the platform-specific constant values used to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">the PLL:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
#define CPU_FREQ (168000000)
#define PLL_FULL_MASK (0x7F037FFF)
#define PLLM 8
#define PLLN 336
#define PLLP 2
#define PLLQ 7
#define PLLR 0</span></pre>
<p><span class="koboSpan" id="kobo.169.1">One additional macro invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">DMB</span></strong><span class="koboSpan" id="kobo.171.1"> assembly instruction is defined, for brevity, as it will be used in the code to ensure that any pending memory transfer toward the configuration registers is completed before the execution of the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">next statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
#define DMB() asm volatile ("dmb");</span></pre>
<p><span class="koboSpan" id="kobo.174.1">The next function will then ensure that the PLL initialization sequence is performed, in order to </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.175.1">set the correct CPU frequency. </span><span class="koboSpan" id="kobo.175.2">First, it will enable the internal high-speed oscillator, and will wait until it is ready by polling </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">the CR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
void rcc_config(void)
{
Â Â uint32_t reg32;
Â Â RCC_CR |= RCC_CR_HSION;
Â Â DMB();
Â Â while ((RCC_CR &amp; RCC_CR_HSIRDY) == 0)
Â Â Â Â ;</span></pre>
<p><span class="koboSpan" id="kobo.178.1">The internal oscillator is then selected as a temporary </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">clock source:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
Â Â reg32 = RCC_CFGR;
Â Â reg32 &amp;= ~((1 &lt;&lt; 1) | (1 &lt;&lt; 0));
Â Â RCC_CFGR = (reg32 | RCC_CFGR_SW_HSI);
Â Â DMB();</span></pre>
<p><span class="koboSpan" id="kobo.181.1">The external oscillator is then activated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">same way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
Â Â RCC_CR |= RCC_CR_HSEON;
Â Â DMB();
Â Â while ((RCC_CR &amp; RCC_CR_HSERDY) == 0)
Â Â Â Â ;</span></pre>
<p><span class="koboSpan" id="kobo.184.1">On this device, the clock can be distributed to all the peripherals through three system buses. </span><span class="koboSpan" id="kobo.184.2">Using prescalers, the frequency of each bus can be scaled by a factor of two or four. </span><span class="koboSpan" id="kobo.184.3">In this case, we set the clock speed for HPRE, PPRE1, and PPRE2 to be 168, 84, and 46 MHz respectively on </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">this target:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
Â Â reg32 = RCC_CFGR;
Â Â reg32 &amp;= ~0xF0;
Â Â RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_NONE &lt;&lt; 4));
Â Â DMB();
Â Â reg32 = RCC_CFGR;
Â Â reg32 &amp;= ~0x1C00;
Â Â RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_2 &lt;&lt; 10));
Â Â DMB();
Â Â reg32 = RCC_CFGR;
Â Â reg32 &amp;= ~0x07 &lt;&lt; 13;
Â Â RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_4 &lt;&lt; 13));
Â Â DMB();</span></pre>
<p><span class="koboSpan" id="kobo.187.1">The </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.188.1">PLL configuration register is set to contain the parameters to correctly scale the external oscillator frequency to the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">desired value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
Â Â reg32 = RCC_PLLCFGR;
Â Â reg32 &amp;= ~PLL_FULL_MASK;
Â Â RCC_PLLCFGR = reg32 | RCC_PLLCFGR_PLLSRC | PLLM |
Â Â Â Â (PLLN &lt;&lt; 6) | (((PLLP &gt;&gt; 1) - 1) &lt;&lt; 16) |
Â Â Â Â (PLLQ &lt;&lt; 24);
Â Â DMB();</span></pre>
<p><span class="koboSpan" id="kobo.191.1">The PLL is then activated, and the execution is suspended until the output </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">is stable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
Â Â RCC_CR |= RCC_CR_PLLON;
Â Â DMB();
Â Â while ((RCC_CR &amp; RCC_CR_PLLRDY) == 0);</span></pre>
<p><span class="koboSpan" id="kobo.194.1">The PLL is selected as the final source for the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">system clock:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
Â Â reg32 = RCC_CFGR;
Â Â reg32 &amp;= ~((1 &lt;&lt; 1) | (1 &lt;&lt; 0));
Â Â RCC_CFGR = (reg32 | RCC_CFGR_SW_PLL);
Â Â DMB();
Â Â while ((RCC_CFGR &amp; ((1 &lt;&lt; 1) | (1 &lt;&lt; 0))) !=
Â Â Â Â RCC_CFGR_SW_PLL);</span></pre>
<p><span class="koboSpan" id="kobo.197.1">The</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.198.1"> internal oscillator is no longer in use and can be disabled. </span><span class="koboSpan" id="kobo.198.2">The control returns to the caller, and all the clocks are </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">successfully set.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">As mentioned earlier, the procedure for clock initialization is strictly dependent on the PLL configuration in the microcontroller. </span><span class="koboSpan" id="kobo.200.2">To properly initialize the system clocks required for the CPU and the peripherals to operate at the desired frequencies, it is always advised to refer to the datasheet of the microcontroller provided by the silicon manufacturer. </span><span class="koboSpan" id="kobo.200.3">As a second example, we can </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.201.1">verify how </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Quick EMUlator</span></strong><span class="koboSpan" id="kobo.203.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.204.1">QEMU</span></strong><span class="koboSpan" id="kobo.205.1">) is capable of emulating the behavior of the LM3S6965 microcontroller. </span><span class="koboSpan" id="kobo.205.2">The emulator provides a virtual clock, which is configurable using the same initialization procedure as described on the manufacturer datasheet. </span><span class="koboSpan" id="kobo.205.3">On this platform, two registers are used for clock configuration, referred to as </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">RCC</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.207.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">RCC2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
#define RCC (*(volatile uint32_t*))(0x400FE060)
#define RCC2 (*(volatile uint32_t*))(0x400FE070)</span></pre>
<p><span class="koboSpan" id="kobo.211.1">To reset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">RCC</span></strong><span class="koboSpan" id="kobo.213.1"> registers to a known state, the reset value must be written to these registers </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">at boot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
#define RCC_RESET (0x078E3AD1)
#define RCC2_RESET (0x07802810)</span></pre>
<p><span class="koboSpan" id="kobo.216.1">This microcontroller uses a raw interrupt to notify that the PLL is locked to the requested frequency. </span><span class="koboSpan" id="kobo.216.2">The </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.217.1">interrupt status can be checked by reading bit </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">6</span></strong><span class="koboSpan" id="kobo.219.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">Raw Interrupt Status</span></strong><span class="koboSpan" id="kobo.221.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.222.1">RIS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">) register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
#define RIS (*(volatile uint32_t*))(0x400FE050)
#define PLL_LRIS (1 &lt;&lt; 6)</span></pre>
<p><span class="koboSpan" id="kobo.225.1">The clock configuration routine in this case starts by resetting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">RCC</span></strong><span class="koboSpan" id="kobo.227.1"> registers and setting the appropriate values to configure the PLL. </span><span class="koboSpan" id="kobo.227.2">The PLL is configured to generate a 400 MHz clock from an 8 MHz </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">oscillator source:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
void rcc_config(void)
{
Â Â RCC = RCC_RESET;
Â Â RCC2 = RCC2_RESET;
Â Â DMB();
Â Â RCC = RCC_SYSDIV_50MHZ | RCC_PWMDIV_64 |
Â Â Â Â RCC_XTAL_8MHZ_400MHZ | RCC_USEPWMDIV;</span></pre>
<p><span class="koboSpan" id="kobo.230.1">The</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.231.1"> resultant 50 MHz CPU frequency is derived from this master 400 MHz clock using the system divider. </span><span class="koboSpan" id="kobo.231.2">The clock is pre-divided by two, and then a factor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">4</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.233.1">is applied:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
Â Â RCC2 = RCC2_SYSDIV2_4;
Â Â DMB();</span></pre>
<p><span class="koboSpan" id="kobo.235.1">The external oscillators are </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">powered on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
Â Â RCC &amp;= ~RCC_OFF;
Â Â RCC2 &amp;= ~RCC2_OFF;</span></pre>
<p><span class="koboSpan" id="kobo.238.1">And the system clock divider is powered on as well. </span><span class="koboSpan" id="kobo.238.2">At the same time, setting the bypass bit ensures that the oscillator is used as a source for the system clock, and the PLL </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">is bypassed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.240.1">
Â Â RCC |= RCC_BYPASS | RCC_USESYSDIV;
Â Â DMB();</span></pre>
<p><span class="koboSpan" id="kobo.241.1">The execution is held until the PLL is stable and has locked on the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">desired frequency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
 while ((RIS &amp; PLL_LRIS) == 0)Â Â Â ;</span></pre>
<p><span class="koboSpan" id="kobo.244.1">Disabling the bypass bits in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">RCC</span></strong><span class="koboSpan" id="kobo.246.1"> registers at this point is sufficient to connect the PLL output to the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">system clock:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
Â Â RCC &amp;= ~RCC_BYPASS;
Â Â RCC2 &amp;= ~RCC2_BYPASS;
}</span></pre>
<h2 id="_idParaDest-140"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.249.1">Clock distribution</span></h2>
<p><span class="koboSpan" id="kobo.250.1">Once the </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.251.1">bus clocks are available, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">RCC</span></strong><span class="koboSpan" id="kobo.253.1"> logic can be programmed to distribute the clock to single peripherals. </span><span class="koboSpan" id="kobo.253.2">To do so, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">RCC</span></strong><span class="koboSpan" id="kobo.255.1"> exposes bit-mapped peripheral clock source registers. </span><span class="koboSpan" id="kobo.255.2">Setting the corresponding bit in one of the registers enables the clock for each mapped peripheral in the microcontroller. </span><span class="koboSpan" id="kobo.255.3">Each register can control clock gating for </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">32 peripherals.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">The order of the peripherals, and consequently the corresponding register and bit, is strictly dependent on the specific microcontrollers. </span><span class="koboSpan" id="kobo.257.2">The STM32F4 has three registers dedicated to this purpose. </span><span class="koboSpan" id="kobo.257.3">For example, to enable the clock source for the internal watchdog, it is sufficient to set the bit number </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">9</span></strong><span class="koboSpan" id="kobo.259.1"> in the clock enable register at </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">0x40021001c</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
#define APB1_CLOCK_ER (*(uint32_t *)(0x4002001c))
#define WDG_APB1_CLOCK_ER_VAL (1 &lt;&lt; 9)
APB1_CLOCK_ER |= WDG_APB1_CLOCK_ER_VAL;</span></pre>
<p><span class="koboSpan" id="kobo.264.1">Keeping the clock source off for a peripheral that is not in use saves power; thus, if the target supports clock gating, it can implement optimization and fine-tuning of power consumption by disabling the single peripherals at runtime t</span><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.265.1">hrough their </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">clock gates.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.267.1">Enabling the SysTick</span></h2>
<p><span class="koboSpan" id="kobo.268.1">Once a </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.269.1">stable CPU frequency has been set up, we can configure the </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.270.1">main timer on the systemâ€”the SysTick. </span><span class="koboSpan" id="kobo.270.2">Since the implementation of a specific system timer is not mandatory on all Cortex-M, sometimes it is necessary to use an ordinary auxiliary timer to keep track of the system time. </span><span class="koboSpan" id="kobo.270.3">In most cases, though, the SysTick interrupt can be enabled by accessing its configuration, which is located in the system control block within the system configuration region. </span><span class="koboSpan" id="kobo.270.4">In all Cortex-M microcontrollers that include a system tick, the configuration can be found starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">0xE000E010</span></strong><span class="koboSpan" id="kobo.272.1">, and exposes </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">four registers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.274.1">The control/status register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">SYSTICK_CSR</span></strong><span class="koboSpan" id="kobo.276.1">) at </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">offset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">0</span></strong></span></li>
<li><span class="koboSpan" id="kobo.279.1">The reload value register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">SYSTICK_RVR</span></strong><span class="koboSpan" id="kobo.281.1">) at </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">offset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">4</span></strong></span></li>
<li><span class="koboSpan" id="kobo.284.1">The current value register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">SYSTICK_CVR</span></strong><span class="koboSpan" id="kobo.286.1">) at </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">offset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">8</span></strong></span></li>
<li><span class="koboSpan" id="kobo.289.1">The calibration register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">SYSTICK_CALIB</span></strong><span class="koboSpan" id="kobo.291.1">) at </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">offset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">12</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.294.1">The</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.295.1"> SysTick works </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.296.1">as a countdown timer. </span><span class="koboSpan" id="kobo.296.2">It holds a 24-bit value, which is decreased at every CPU clock tick. </span><span class="koboSpan" id="kobo.296.3">The timer reloads the same value every time it reaches </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">0</span></strong><span class="koboSpan" id="kobo.298.1"> and triggers the SysTick interrupt if it is configured to </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">As a shortcut to access the SysTick registers, we define </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">their locations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
#define SYSTICK_BASE (0xE000E010)
#define SYSTICK_CSR (*(volatile uint32_t *)(SYSTICK_BASE +
Â Â Â Â 0x00))
#define SYSTICK_RVR (*(volatile uint32_t *)(SYSTICK_BASE +
Â Â Â Â 0x04))
#define SYSTICK_CVR (*(volatile uint32_t *)(SYSTICK_BASE +
Â Â Â Â 0x08))
#define SYSTICK_CALIB (*(volatile uint32_t *)(SYSTICK_BASE
Â Â Â Â + 0x0C))</span></pre>
<p><span class="koboSpan" id="kobo.303.1">Since we know the frequency of the CPU in Hz, we can define the system tick interval by setting the value in </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.304.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">Reload Value Register</span></strong><span class="koboSpan" id="kobo.306.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.307.1">RVR</span></strong><span class="koboSpan" id="kobo.308.1">). </span><span class="koboSpan" id="kobo.308.2">For a 1 ms interval in between two consecutive ticks, we simply divide the frequency by 1,000, and we subtract 1 to account for the zero-based timer value, ensuring that the next interrupt will take place after the counter has been decreased exactly N times, which corresponds to counting down from N-1 to zero. </span><span class="koboSpan" id="kobo.308.3">We can also set the initial value for the timer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">0</span></strong><span class="koboSpan" id="kobo.310.1"> so that the first interrupt is immediately triggered after we enable the countdown. </span><span class="koboSpan" id="kobo.310.2">The SysTick can finally be enabled by configuring the control/status register. </span><span class="koboSpan" id="kobo.310.3">The meaning of the least significant three bits of the CSR is </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.312.1">Bit 0</span></strong><span class="koboSpan" id="kobo.313.1">: Enables</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.314.1"> countdown. </span><span class="koboSpan" id="kobo.314.2">After this bit is set, the counter in the SysTick timer is automatically decreased at every CPU </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">clock interval.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.316.1">Bit 1</span></strong><span class="koboSpan" id="kobo.317.1">: Enables </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.318.1">interrupt. </span><span class="koboSpan" id="kobo.318.2">If this bit is set when the counter reaches </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">0</span></strong><span class="koboSpan" id="kobo.320.1">, a SysTick interrupt will </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">be generated.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.322.1">Bit 2</span></strong><span class="koboSpan" id="kobo.323.1">: Source</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.324.1"> clock selection. </span><span class="koboSpan" id="kobo.324.2">If this bit is reset, an external reference clock is used as the source. </span><span class="koboSpan" id="kobo.324.3">The CPU clock is used as the source when this bit </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">is set.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.326.1">We are </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.327.1">going to</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.328.1"> define a custom SysTick interrupt handler, so we want to set bit </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">1</span></strong><span class="koboSpan" id="kobo.330.1"> as well. </span><span class="koboSpan" id="kobo.330.2">Because we configured the CPU clock correctly, and we are scaling the system tick interval reload value on that, we also want bit </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">2</span></strong><span class="koboSpan" id="kobo.332.1"> to be set. </span><span class="koboSpan" id="kobo.332.2">The last line of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">systick_enable</span></strong><span class="koboSpan" id="kobo.334.1"> routine will enable the three bits together in </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">the CSR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
void systick_enable(void) {
Â Â SYSTICK_RVR = ((CPU_FREQ / 1000) - 1);
Â Â SYSTICK_CVR = 0;
Â Â SYSTICK_CSR = (1 &lt;&lt; 0) | (1 &lt;&lt; 1) | (1 &lt;&lt; 2);
}</span></pre>
<p><span class="koboSpan" id="kobo.337.1">The system timer that we have configured is the same as that used by </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">real-time operating systems</span></strong><span class="koboSpan" id="kobo.339.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.340.1">RTOSs</span></strong><span class="koboSpan" id="kobo.341.1">) to </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.342.1">initiate process switches. </span><span class="koboSpan" id="kobo.342.2">In our case, it might be helpful to keep a monotonic system wall clock, measuring the time elapsed since the clock configuration. </span><span class="koboSpan" id="kobo.342.3">A minimalist implementation of the interrupt service routine for the system timer could be </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
volatile unsigned int jiffies = 0;
void isr_systick(void)
{
Â Â ++jiffies;
}</span></pre>
<p><span class="koboSpan" id="kobo.345.1">This simple function, and the associated global </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">volatile</span></strong><span class="koboSpan" id="kobo.347.1"> variable associated, are sufficient to keep track of the time transparently while the application is running. </span><span class="koboSpan" id="kobo.347.2">In fact, the system tick interrupt happens independently, at regular intervals, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">jiffies</span></strong><span class="koboSpan" id="kobo.349.1"> variable is incremented in the interrupt handler, without altering the flow of the main application. </span><span class="koboSpan" id="kobo.349.2">What actually happens is that every time the system tick counter reaches </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">0</span></strong><span class="koboSpan" id="kobo.351.1">, the execution is suspended, and the interrupt routine quickly executes. </span><span class="koboSpan" id="kobo.351.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">isr_systick</span></strong><span class="koboSpan" id="kobo.353.1"> returns, the flow of the main application is resumed by restoring exactly the same context of execution stored in memory a moment before the </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">interrupt occurred.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">The </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.356.1">reason why </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.357.1">the system timer variable must be defined and declared everywhere as </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">volatile</span></strong><span class="koboSpan" id="kobo.359.1"> is that its value is supposed to change while executing the application in a way that is independent of the behavior possibly predicted by the compiler for the local context of execution. </span><span class="koboSpan" id="kobo.359.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">volatile</span></strong><span class="koboSpan" id="kobo.361.1"> keyword in this case ensures that the compiler is forced to produce code that checks the value of the variable every time it is instantiated, by disallowing the use of optimizations based on the false assumption that the variable is not being modified by the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">local code.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Here is an example main program that uses the previous functions to boot the system, configure the master clock, and enable </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the SysTick:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
void main(void) {
Â Â flash_set_waitstates();
Â Â clock_config();
Â Â systick_enable();
Â Â while(1) {
Â Â Â Â WFI();
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.366.1">The shortcut </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.367.1">for the </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">WFI</span></strong><span class="koboSpan" id="kobo.369.1"> assembly instruction (short for </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">wait for interrupt</span></strong><span class="koboSpan" id="kobo.371.1">) is defined. </span><span class="koboSpan" id="kobo.371.2">It is used in the main application to keep the CPU inactive until the next </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">interrupt occurs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
#define WFI() asm volatile ("wfi")</span></pre>
<p><span class="koboSpan" id="kobo.374.1">To verify that the SysTick is actually running, the program can be executed with the debugger attached and stopped after a while. </span><span class="koboSpan" id="kobo.374.2">If the system tick has been configured correctly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">jiffies</span></strong><span class="koboSpan" id="kobo.376.1"> variable should always be displaying the t</span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.377.1">ime in milliseconds elapsed </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">since boot.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.379.1">Generic timers</span></h1>
<p><span class="koboSpan" id="kobo.380.1">Providing a</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.381.1"> SysTick timer is not mandatory for low-end microcontrollers. </span><span class="koboSpan" id="kobo.381.2">Some targets may not have a system timer, but all of them expose some kind of interface to program several general-purpose timers for the program to be able to implement time-driven operations. </span><span class="koboSpan" id="kobo.381.3">Timers in general are very flexible and easy to configure and are generally capable of triggering interrupts at regular intervals. </span><span class="koboSpan" id="kobo.381.4">The STM32F4 provides up to 17 timers, each with different characteristics. </span><span class="koboSpan" id="kobo.381.5">Timers are in general independent from each other, as each of them has its own interrupt line and a separate peripheral clock gate. </span><span class="koboSpan" id="kobo.381.6">On the STM32F4, for example, these are the steps needed to enable the clock source and the interrupt line for timer 2. </span><span class="koboSpan" id="kobo.381.7">The timer interface is based on a counter that is incremented or decremented at every tick. </span><span class="koboSpan" id="kobo.381.8">The interface exposed on this platform is very flexible and supports several features, including the selection of a different clock source for input, the possibility to concatenate timers, and even the internals of the timer implementation that can be programmed. </span><span class="koboSpan" id="kobo.381.9">It is possible to configure the timer to count up or down, and trigger interrupt events on different values of the internal counter. </span><span class="koboSpan" id="kobo.381.10">Timers can be one-shot </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">or continuous.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">An abstraction of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">timer</span></strong><span class="koboSpan" id="kobo.385.1"> interface can usually be found in support libraries provided by the silicon vendor, or in other open source libraries. </span><span class="koboSpan" id="kobo.385.2">However, in order to understand the interface exposed by the microcontroller, the example provided here is once again directly communicating with the peripherals using the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">configuration registers.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">This example mostly uses the default settings for a general-purpose timer on the STM32F407. </span><span class="koboSpan" id="kobo.387.2">By default, the counter is increased at every tick, up to its automatic reload value, and continuously generates interrupt events on overflow. </span><span class="koboSpan" id="kobo.387.3">A prescaler value can be set to divide the clock source to increase the range of possible intervals. </span><span class="koboSpan" id="kobo.387.4">To generate interrupts spread at a constant </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.388.1">given interval, only a few registers need to </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">be accessed:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.390.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">control registers 1</span></strong><span class="koboSpan" id="kobo.392.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">2</span></strong><span class="koboSpan" id="kobo.394.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.395.1">CR1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.396.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.397.1">CR2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.399.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">direct memory access (DMA)/Interrupt enable </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.401.1">register</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.403.1">DIER</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.405.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">status </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.407.1">register</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.409.1">SR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.411.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">prescaler </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.413.1">counter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.415.1">PSC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.417.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">auto-reload </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.419.1">register</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.421.1">ARR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.423.1">In general, the</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.424.1"> offsets for</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.425.1"> these registers are the same for all the timers so that, given the base address, they can be calculated using a macro. </span><span class="koboSpan" id="kobo.425.2">In this case, only the register for the timer in use </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">is defined:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
#define TIM2_BASE (0x40000000)
#define TIM2_CR1 (*(volatile uint32_t *)(TIM2_BASE + 0x00))
#define TIM2_DIER (*(volatile uint32_t *)(TIM2_BASE +
Â Â Â Â 0x0c))
#define TIM2_SR (*(volatile uint32_t *)(TIM2_BASE + 0x10))
#define TIM2_PSC (*(volatile uint32_t *)(TIM2_BASE + 0x28))
#define TIM2_ARR (*(volatile uint32_t *)(TIM2_BASE + 0x2c))</span></pre>
<p><span class="koboSpan" id="kobo.428.1">Also, for readability, we define some relevant bit positions in the registers that we are going </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">to configure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
#define TIM_DIER_UIE (1 &lt;&lt; 0)
#define TIM_SR_UIF (1 &lt;&lt; 0)
#define TIM_CR1_CLOCK_ENABLE (1 &lt;&lt; 0)
#define TIM_CR1_UPD_RS (1 &lt;&lt; 2)</span></pre>
<p><span class="koboSpan" id="kobo.431.1">First of all, we are going to define a service routine. </span><span class="koboSpan" id="kobo.431.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">timer</span></strong><span class="koboSpan" id="kobo.433.1"> interface requires us to clear one flag in the status register, to acknowledge the interrupt. </span><span class="koboSpan" id="kobo.433.2">In this simple case, all we do is increment a local variable so that we can verify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">timer</span></strong><span class="koboSpan" id="kobo.435.1"> is being executed by inspecting it in the debugger. </span><span class="koboSpan" id="kobo.435.2">We mark the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">timer2_ticks</span></strong><span class="koboSpan" id="kobo.437.1"> variable as </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">volatile</span></strong><span class="koboSpan" id="kobo.439.1"> so that it does not get optimized out by the compiler, since it is never used in </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
void isr_tim2(void)
{
Â Â static volatile uint32_t timer2_ticks = 0;
Â Â TIM2_SR &amp;= ~TIM_SR_UIF;
Â Â timer2_ticks++;
}</span></pre>
<p><span class="koboSpan" id="kobo.442.1">The service routine must be associated, by including a pointer to the function in the right position within the interrupt vector defined </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">startup.c</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
isr_tim2 , // TIM2_IRQ 28</span></pre>
<p><span class="koboSpan" id="kobo.447.1">If the</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.448.1"> timer is connected to a different branch in the clock tree, as in this case, we need to account for the additional scaling factor between the clock bus that feeds the timer and the actual CPU clock frequency, while calculating the values for the prescaler and the reload threshold. </span><span class="koboSpan" id="kobo.448.2">Timer 2 on STM32F407 is connected to the </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">Advanced Peripheral Bus</span></strong><span class="koboSpan" id="kobo.450.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.451.1">APB</span></strong><span class="koboSpan" id="kobo.452.1">) bus, which</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.453.1"> runs at half of the </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">CPU frequency.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">This initialization is an example of a function that automatically calculates </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">TIM2_PSC</span></strong><span class="koboSpan" id="kobo.457.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">TIM2_ARR</span></strong><span class="koboSpan" id="kobo.459.1"> values and initializes a timer based on the given interval, expressed in milliseconds. </span><span class="koboSpan" id="kobo.459.2">The clock variable must be set to the frequency of the clock source for the timer, which may differ from the </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">CPU frequency.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">The following definitions are specific to our platform, mapping the address for the clock gating configuration and the interrupt number of the device we want </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">to use:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
#define APB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))
#define APB1_CLOCK_RST (*(volatile uint32_t *)
Â Â Â Â Â (0x40023820))
#define TIM2_APB1_CLOCK_ER_VAL (1 &lt;&lt; 0)
#define NVIC_TIM2_IRQN (28)</span></pre>
<p><span class="koboSpan" id="kobo.464.1">And here is the function to invoke from </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">main</span></strong><span class="koboSpan" id="kobo.466.1"> to enable a continuous timer interrupt at the </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">desired interval:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
int timer_init(uint32_t clock, uint32_t interval_ms)
{
Â Â uint32_t val = 0;
Â Â uint32_t psc = 1;
Â Â uint32_t err = 0;
Â Â clock = (clock / 1000) * interval_ms;
Â Â while (psc &lt; 65535) {
Â Â Â Â val = clock / psc;
Â Â Â Â err = clock % psc;
Â Â Â Â if ((val &lt; 65535) &amp;&amp; (err == 0)) {
Â Â Â Â Â Â val--;
Â Â Â Â Â Â break;
Â Â Â Â }
Â Â Â Â val = 0;
Â Â Â Â psc++;
Â Â }
Â Â if (val == 0)
Â Â Â Â return -1;
Â Â nvic_irq_enable(NVIC_TIM2_IRQN);
Â Â nvic_irq_setprio(NVIC_TIM2_IRQN, 0);
Â Â APB1_CLOCK_RST |= TIM2_APB1_CLOCK_ER_VAL;
Â Â DMB();
Â Â TIM2_PSC = psc;
Â Â TIM2_ARR = val;
Â Â TIM2_CR1 |= TIM_CR1_CLOCK_ENABLE;
Â Â TIM2_DIER |= TIM_DIER_UIE;
Â Â DMB();
Â Â return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.469.1">The </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.470.1">example presented here is only one of the possible applications of system timers. </span><span class="koboSpan" id="kobo.470.2">On the reference platform, timers can be used for different purposes, such as measuring intervals between pulses, synchronizing with each other, or activating signals periodically, given a chosen frequency and duty cycle. </span><span class="koboSpan" id="kobo.470.3">This last usage will be explained in the </span><em class="italic"><span class="koboSpan" id="kobo.471.1">PWM</span></em><span class="koboSpan" id="kobo.472.1"> subsection later in this chapter. </span><span class="koboSpan" id="kobo.472.2">For all other uses of generic timers on the target, please refer to the reference manual of the microcontroller in use. </span><span class="koboSpan" id="kobo.472.3">Now that our system is configured and ready to run, and we have learned how to manage time and generate synchronous events, it is finally time to introduce our first peripherals to start communicating with the outside world. </span><span class="koboSpan" id="kobo.472.4">In the next section, we will introduce GPIO lines in their multiple configurations, which allow driving or sen</span><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.473.1">sing a voltage on single </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">microcontroller pins.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.475.1">GPIO</span></h1>
<p><span class="koboSpan" id="kobo.476.1">The </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.477.1">majority of the pins of a microcontroller chip represent configurable I/O lines. </span><span class="koboSpan" id="kobo.477.2">Each pin can be configured to represent a logic level by driving the voltage of the pin as a digital output or to sense the logic state by comparing the voltage as a digital input. </span><span class="koboSpan" id="kobo.477.3">Some of the generic pins, though, can be associated with alternate functions, such as analog input, a serial interface, or the output pulse from a timer. </span><span class="koboSpan" id="kobo.477.4">Pins may have several possible configurations, but only one is activated at a time. </span><span class="koboSpan" id="kobo.477.5">The GPIO controller exposes the configuration of all the pins and manages the association of the pins with the </span><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.478.1">subsystems when alternate functions are </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">in use.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.480.1">Pin configuration</span></h2>
<p><span class="koboSpan" id="kobo.481.1">Depending </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.482.1">on the logic of the GPIO controller, the pins can be activated all together, separately, or in groups. </span><span class="koboSpan" id="kobo.482.2">In order to implement a driver to set up the pins and use them as needed, it is possible to refer to the datasheet of the microcontroller or any example implementation provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">silicon vendor.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">In the case of the STM32F4, GPIO pins are divided into groups. </span><span class="koboSpan" id="kobo.484.2">Each group is connected to a separate clock gate, so, to use the pins associated with a group, the clock gate must be enabled. </span><span class="koboSpan" id="kobo.484.3">The following code will distribute the clock source to the GPIO controller for the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">group </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">D</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))
#define GPIOD_AHB1_CLOCK_ER (1 &lt;&lt; 3)
AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;</span></pre>
<p><span class="koboSpan" id="kobo.489.1">The</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.490.1"> configuration registers associated with the GPIO controllers are mapped to a specific area in the peripherals region as well. </span><span class="koboSpan" id="kobo.490.2">In the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">GPIOD</span></strong><span class="koboSpan" id="kobo.492.1"> controller, the base address is at </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">0x40020C00</span></strong><span class="koboSpan" id="kobo.494.1">. </span><span class="koboSpan" id="kobo.494.2">On the STM32F4 microcontrollers, there are 10 different registers for configuring and using each digital I/O group. </span><span class="koboSpan" id="kobo.494.3">As groups are composed of at most 16 pins, some registers may use a representation of 2 bits </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">per pin:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.496.1">Mode register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">0</span></strong><span class="koboSpan" id="kobo.498.1"> in the address space) selects the mode (among digital input, digital output, alternate function, or analog input), using 2 bits </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">per pin</span></span></li>
<li><span class="koboSpan" id="kobo.500.1">Output type register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">4</span></strong><span class="koboSpan" id="kobo.502.1">) selects the output signal driving logic (push-pull </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">or open-drain)</span></span></li>
<li><span class="koboSpan" id="kobo.504.1">Output speed register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">8</span></strong><span class="koboSpan" id="kobo.506.1">) selects output </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">drive speed</span></span></li>
<li><span class="koboSpan" id="kobo.508.1">Pull-up register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">12</span></strong><span class="koboSpan" id="kobo.510.1">) enables or disables the internal pull-up or </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">pull-down resistor</span></span></li>
<li><span class="koboSpan" id="kobo.512.1">Port input data (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">16</span></strong><span class="koboSpan" id="kobo.514.1">) is used to read the state of a digital </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">input pin</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">Port output data (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">20</span></strong><span class="koboSpan" id="kobo.518.1">) containing the current value of the </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">digital output</span></span></li>
<li><span class="koboSpan" id="kobo.520.1">Port bit set/reset (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">24</span></strong><span class="koboSpan" id="kobo.522.1">) used to drive a digital output signal high </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">or low</span></span></li>
<li><span class="koboSpan" id="kobo.524.1">Port configuration lock (</span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">offset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">28</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.528.1">Alternate function low bit register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">32</span></strong><span class="koboSpan" id="kobo.530.1">), 4 bits per pin, </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">pins 0-7</span></span></li>
<li><span class="koboSpan" id="kobo.532.1">Alternate function high bit register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">36</span></strong><span class="koboSpan" id="kobo.534.1">), 4 bits per pin, </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">pins 8-15</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.536.1">The pin must be configured before use, and the clock gating configured to route the source clock to the controller for the group. </span><span class="koboSpan" id="kobo.536.2">The configurations available on this GPIO controller can be </span><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.537.1">better explained by looking at </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">specific examples.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.539.1">Digital output</span></h2>
<p><span class="koboSpan" id="kobo.540.1">Enabling </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.541.1">a digital output is possible by setting the mode to output in the mode register bits corresponding to the given pin. </span><span class="koboSpan" id="kobo.541.2">To be able to control the level of pin D13, which is also connected to an LED on our reference platform, we need to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">following registers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
#define GPIOD_BASE 0x40020c00
#define GPIOD_MODE (*(volatile uint32_t *)(GPIOD_BASE +
Â Â Â Â 0x00))
#define GPIOD_OTYPE (*(volatile uint32_t *)(GPIOD_BASE +
Â Â Â Â 0x04))
#define GPIOD_PUPD (*(volatile uint32_t *)(GPIOD_BASE +
Â Â Â Â 0x0c))
#define GPIOD_ODR (*(volatile uint32_t *)(GPIOD_BASE +
Â Â Â Â 0x14))
#define GPIOD_BSRR (*(volatile uint32_t *)(GPIOD_BASE +
Â Â Â Â 0x18))</span></pre>
<p><span class="koboSpan" id="kobo.544.1">In later examples, alternate functions are used to change the pin assignment. </span><span class="koboSpan" id="kobo.544.2">The two registers containing the alternate function settings are </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
#define GPIOD_AFL (*(volatile uint32_t *)(GPIOD_BASE +
Â Â Â Â 0x20))
#define GPIOD_AFH (*(volatile uint32_t *)(GPIOD_BASE +
Â Â Â Â 0x24))</span></pre>
<p><span class="koboSpan" id="kobo.547.1">The following simple functions are meant to control the output of pin D15 connected to the blue LED on the STM32F4. </span><span class="koboSpan" id="kobo.547.2">The main program must call </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">led_setup</span></strong><span class="koboSpan" id="kobo.549.1"> before any other function call, in order to configure the pin as output and activate the pull-up/pull-down </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">internal resistor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.551.1">
#define LED_PIN (15)
void led_setup(void)
{
Â Â uint32_t mode_reg;</span></pre>
<p><span class="koboSpan" id="kobo.552.1">First, the clock gating is configured to enable the clock source for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">GPIOD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1"> controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
Â Â AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;</span></pre>
<p><span class="koboSpan" id="kobo.556.1">The </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.557.1">mode register is altered to set the mode for GPIO D15 to digital output. </span><span class="koboSpan" id="kobo.557.2">The operation is done in two steps. </span><span class="koboSpan" id="kobo.557.3">Any previous value set in the 2 bits corresponding to the position of the pin mode within the register </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">is erased:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
Â Â Â GPIOD_MODE &amp;= ~ (0x03 &lt;&lt; (LED_PIN * 2));</span></pre>
<p><span class="koboSpan" id="kobo.560.1">In the same position, the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">1</span></strong><span class="koboSpan" id="kobo.562.1"> is set, meaning that the pin is now configured as </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">digital output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
Â Â Â GPIOD_MODE |= 1 &lt;&lt; (LED_PIN * 2);</span></pre>
<p><span class="koboSpan" id="kobo.565.1">To enable the pull-up and pull-down internal resistors, we do the same. </span><span class="koboSpan" id="kobo.565.2">The value to set in this case is </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">2</span></strong><span class="koboSpan" id="kobo.567.1">, corresponding to </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
Â Â Â GPIOD_PUPD &amp;= ~(0x03 &lt;&lt; (LED_PIN * 2));
Â Â Â GPIOD_PUPD |= 0x02 &lt;&lt; (LED_PIN * 2);
}</span></pre>
<p><span class="koboSpan" id="kobo.570.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">setup</span></strong><span class="koboSpan" id="kobo.572.1"> function is invoked, the application and the interrupt handlers can call the functions exported, to set the value of the pin high or low, by acting on the bit </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">set/reset register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
void led_on(void)
{
Â Â GPIOD_BSRR |= 1 &lt;&lt; LED_PIN;
}</span></pre>
<p><span class="koboSpan" id="kobo.575.1">The highest half of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">BSRR</span></strong><span class="koboSpan" id="kobo.577.1"> is used to reset the pins. </span><span class="koboSpan" id="kobo.577.2">Writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">1</span></strong><span class="koboSpan" id="kobo.579.1"> in the reset register bit drives the pin logic level </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">to low:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
void led_off(void)
{
Â Â GPIOD_BSRR |= 1 &lt;&lt; (LED_PIN + 16);
}</span></pre>
<p><span class="koboSpan" id="kobo.582.1">A convenience function is defined, to toggle the LED value from on to off and </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">vice versa:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
void led_toggle(void)
{
Â Â if ((GPIOD_ODR &amp; (1 &lt;&lt; LED_PIN)) == (1 &lt;&lt; LED_PIN))
Â Â Â Â led_off();
Â Â else
Â Â Â Â led_on();
}</span></pre>
<p><span class="koboSpan" id="kobo.585.1">Using</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.586.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">timer</span></strong><span class="koboSpan" id="kobo.588.1"> configured in the previous section, it is possible to run a small program that blinks the blue LED on the STM32F407-Discovery. </span><span class="koboSpan" id="kobo.588.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">led_toggle</span></strong><span class="koboSpan" id="kobo.590.1"> function can be called from inside the service routine of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">timer</span></strong><span class="koboSpan" id="kobo.592.1"> implemented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">previous section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
void isr_tim2(void)
{
Â Â TIM2_SR &amp;= ~TIM_SR_UIF;
Â Â led_toggle();
}</span></pre>
<p><span class="koboSpan" id="kobo.595.1">In the main program, the LED driver must be initialized before starting </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">the timer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.597.1">
void main(void) {
Â Â flash_set_waitstates();
Â Â clock_config();
Â Â led_setup();
Â Â timer_init(CPU_FREQ, 1, 1000);
Â Â while(1)
Â Â WFI();
}</span></pre>
<p><span class="koboSpan" id="kobo.598.1">The</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.599.1"> main loop of the program is empty. </span><span class="koboSpan" id="kobo.599.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">led_to</span><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.601.1">ggle</span></strong><span class="koboSpan" id="kobo.602.1"> action is invoked every second to blink </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">the LED.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.604.1">PWM</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.605.1">Pulse Width Modulation</span></strong><span class="koboSpan" id="kobo.606.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">PWM</span></strong><span class="koboSpan" id="kobo.608.1"> for brevity, is a commonly used technique to control </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.609.1">different types of actuators, encode</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.610.1"> messages into signals with different pulse duration, and, in general, generate pulses with fixed frequency and variable duty cycles on digital output lines for </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">different purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">timer</span></strong><span class="koboSpan" id="kobo.614.1"> interface may allow associating pins to output a PWM signal. </span><span class="koboSpan" id="kobo.614.2">On our reference microcontroller, four output compare channels can be associated with general-purpose timers, and the pins connected to the OC channels may be configured to output the encoded output automatically. </span><span class="koboSpan" id="kobo.614.3">On the STM32F407-Discovery board, the blue LED pin PD15, used in the previous example to demonstrate digital output functionality, is associated with the OC4 that can be driven by timer 4. </span><span class="koboSpan" id="kobo.614.4">According to the chip documentation, selecting the alternate function 2 for the pin directly connects the output pin </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">to OC4.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">The following diagram shows the pin configuration to use alternate function 2 to connect it to the output of </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">the timer:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.618.1"><img alt="Figure 6.1 â€“ Configuring pin D15 to use alternate function 2 connects it to the output of the timer" src="image/B18730_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">Figure 6.1 â€“ Configuring pin D15 to use alternate function 2 connects it to the output of the timer</span></p>
<p><span class="koboSpan" id="kobo.620.1">The </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.621.1">pin is initialized, and set to use the alternate configuration instead of the plain digital output, by clearing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">MODE</span></strong><span class="koboSpan" id="kobo.623.1"> register bits and setting the value </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
GPIOD_MODE &amp;= ~ (0x03 &lt;&lt; (LED_PIN * 2));
GPIOD_MODE |= (2 &lt;&lt; (LED_PIN * 2));</span></pre>
<p><span class="koboSpan" id="kobo.628.1">Pins from 0 to 7 in this GPIO group use 4 bits each in the AFL register of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">GPIOD</span></strong><span class="koboSpan" id="kobo.630.1"> controller. </span><span class="koboSpan" id="kobo.630.2">Higher pins, in the range 8-15, use 4 bits each in the AFH register. </span><span class="koboSpan" id="kobo.630.3">Once the alternate mode is selected, the right alternate function number is programmed into the 4 bits associated with pin 15, so we are using the AFH register in </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">this case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
uint32_t value;
if (LED_PIN &lt; 8) {
Â Â Â value = GPIOD_AFL &amp; (~(0xf &lt;&lt; (LED_PIN * 4)));
Â Â Â GPIOD_AFL = value | (0x2 &lt;&lt; (LED_PIN * 4));
} else {
Â Â Â value = GPIOD_AFH &amp; (~(0xf &lt;&lt; ((LED_PIN - 8) * 4)));
Â Â Â GPIOD_AFH = value |(0x2 &lt;&lt; ((LED_PIN - 8) * 4));
}</span></pre>
<p><span class="koboSpan" id="kobo.633.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">pwm_led_init()</span></strong><span class="koboSpan" id="kobo.635.1"> function, which </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.636.1">we can call from the main program to configure the LED pin PD15, will look </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
void led_pwm_setup(void)
{
Â Â AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;
Â Â GPIOD_MODE &amp;= ~ (0x03 &lt;&lt; (LED_PIN * 2));
Â Â GPIOD_MODE |= (2 &lt;&lt; (LED_PIN * 2));
Â Â GPIOD_OSPD &amp;= ~(0x03 &lt;&lt; (LED_PIN * 2));
Â Â GPIOD_OSPD |= (0x03 &lt;&lt; (LED_PIN * 2));
Â Â GPIOD_PUPD &amp;= ~(0x03 &lt;&lt; (LED_PIN * 2));
Â Â GPIOD_PUPD |= (0x02 &lt;&lt; (LED_PIN * 2));
Â Â GPIOD_AFH &amp;= ~(0xf &lt;&lt; ((LED_PIN - 8) * 4));
Â Â GPIOD_AFH |= (0x2 &lt;&lt; ((LED_PIN - 8) * 4));
}</span></pre>
<p><span class="koboSpan" id="kobo.639.1">The function that sets up the timer for PWM generation is similar to the one used in the simple interrupt-generating timer in the digital output example, except that configuring the timer to output a </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.640.1">PWM involves modifying the value of four </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">additional registers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.642.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">capture/compare enable </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.644.1">register</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.646.1">CCER</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.648.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.649.1">capture/compare mode registers 1</span></strong><span class="koboSpan" id="kobo.650.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">2</span></strong><span class="koboSpan" id="kobo.652.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.653.1">CCMR1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.654.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.655.1">CCMR2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.657.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.658.1">capture channel 4</span></strong><span class="koboSpan" id="kobo.659.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.660.1">CC4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">) configuration</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.662.1">The signature of the function we will use in the example to configure a PWM with the given duty cycle has the </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">following signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.664.1">
int pwm_init(uint32_t clock, uint32_t dutycycle)
{</span></pre>
<p><span class="koboSpan" id="kobo.665.1">Enabling the clock gate to turn on timer 4 is </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">still required:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
Â Â APB1_CLOCK_RST &amp;= ~TIM4_APB1_CLOCK_ER_VAL;
Â Â APB1_CLOCK_ER |= TIM4_APB1_CLOCK_ER_VAL;</span></pre>
<p><span class="koboSpan" id="kobo.668.1">Both the </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.669.1">timer and its output compare channels are temporarily disabled to start the configuration from a </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">clean slate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
Â Â TIM4_CCER &amp;= ~TIM_CCER_CC4_ENABLE;
Â Â TIM4_CR1 = 0;
Â Â TIM4_PSC = 0;</span></pre>
<p><span class="koboSpan" id="kobo.672.1">For this example, we can use a fixed PWM frequency of 100 kHz, by setting the automatic reload value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">1</span></strong><span class="koboSpan" id="kobo.674.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">100000</span></strong><span class="koboSpan" id="kobo.676.1"> of the input clock, and enforcing no use of </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">the prescaler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
Â Â uint32_t val = clock / 100000;</span></pre>
<p><span class="koboSpan" id="kobo.679.1">The duty cycle is calculated according to the value that is passed as a second parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">pwm_init()</span></strong><span class="koboSpan" id="kobo.681.1">, expressed as a percentage. </span><span class="koboSpan" id="kobo.681.2">To calculate the corresponding threshold level, this simple formula is used so that, for example, a value of 80 means that the PWM will be active for 4/5 of the time. </span><span class="koboSpan" id="kobo.681.3">The resultant value is decremented by one, only if not zero to </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">avoid underflow:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.683.1">
Â Â lvl = (val * threshold) / 100;
Â Â if (lvl != 0)
Â Â Â Â lvl--;</span></pre>
<p><span class="koboSpan" id="kobo.684.1">Comparator value register </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">CCR4</span></strong><span class="koboSpan" id="kobo.686.1">, and auto-reload value register </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">ARR</span></strong><span class="koboSpan" id="kobo.688.1">, are set accordingly. </span><span class="koboSpan" id="kobo.688.2">Also, in this case, the value of ARR is decreased by 1, to account for the </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">zero-based counter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
Â Â TIM4_ARR = val - 1;
Â Â TIM4_CCR4 = lvl;</span></pre>
<p><span class="koboSpan" id="kobo.691.1">In order to correctly set up a PWM signal on this platform, we first ensure that the portions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">CCMR1</span></strong><span class="koboSpan" id="kobo.693.1"> register we are going to configure are correctly cleared. </span><span class="koboSpan" id="kobo.693.2">This includes the capture selection and the </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">mode configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
Â Â TIM4_CCMR1 &amp;= ~(0x03 &lt;&lt; 0);
Â Â TIM4_CCMR1 &amp;= ~(0x07 &lt;&lt; 4);</span></pre>
<p><span class="koboSpan" id="kobo.696.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">PWM1</span></strong><span class="koboSpan" id="kobo.698.1"> mode </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.699.1">selected is just one of the possible alternate configurations that are based on the capture/compare timer. </span><span class="koboSpan" id="kobo.699.2">To enable the mode, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">PWM1</span></strong><span class="koboSpan" id="kobo.701.1"> value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">CCMR2</span></strong><span class="koboSpan" id="kobo.703.1">, after clearing the relevant bits of </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">the registers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.705.1">
Â Â TIM4_CCMR1 &amp;= ~(0x03 &lt;&lt; 0);
Â Â TIM4_CCMR1 &amp;= ~(0x07 &lt;&lt; 4);
Â Â TIM4_CCMR1 |= TIM_CCMR1_OC1M_PWM1;
Â Â TIM4_CCMR2 &amp;= ~(0x03 &lt;&lt; 8);
Â Â TIM4_CCMR2 &amp;= ~(0x07 &lt;&lt; 12);
Â Â TIM4_CCMR2 |= TIM_CCMR2_OC4M_PWM1;</span></pre>
<p><span class="koboSpan" id="kobo.706.1">Finally, we enable the output comparator OC4. </span><span class="koboSpan" id="kobo.706.2">The timer is then set up to automatically reload its stored value every time the </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">counter overflows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.708.1">
Â Â TIM4_CCMR2 |= TIM_CCMR2_OC4M_PWM1;
Â Â TIM4_CCER |= TIM_CCER_CC4_ENABLE;
Â Â TIM4_CR1 |= TIM_CR1_CLOCK_ENABLE | TIM_CR1_ARPE;
}</span></pre>
<p><span class="koboSpan" id="kobo.709.1">Using a PWM to drive the voltage applied on the LED modifies its brightness, according to the configured duty cycle. </span><span class="koboSpan" id="kobo.709.2">An example program such as the following reduces the brightness of the LED to 50% if compared to that of an LED powered by a constant voltage output, such as the one in the digital </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">output example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.711.1">
void main(void) {
Â Â flash_set_waitstates();
Â Â clock_config();
Â Â led_pwm_setup();
Â Â pwm_init(CPU_FREQ, 50);
Â Â while(1)
Â Â Â Â WFI();
}</span></pre>
<p><span class="koboSpan" id="kobo.712.1">The </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.713.1">effect of the PWM on the LED brightness can be better visualized by dynamically altering the duty cycle. </span><span class="koboSpan" id="kobo.713.2">It is possible, for example, to set up a second timer to generate an interrupt every 50 ms. </span><span class="koboSpan" id="kobo.713.3">In the interrupt handler, the duty cycle factor is cycling in the range 0-80% and back, using 16 steps. </span><span class="koboSpan" id="kobo.713.4">In the first 8 steps, the duty cycle is increased by 10% at every interrupt, from 0 to 80%, and in the last 8 steps, it is reduced at the same rate, bringing the duty cycle back </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.717.1">
void isr_tim2(void) {
Â Â static uint32_t tim2_ticks = 0;
Â Â TIM2_SR &amp;= ~TIM_SR_UIF;
Â Â if (tim2_ticks &gt; 16)
Â Â Â Â tim2_ticks = 0;
Â Â if (tim2_ticks &gt; 8)
Â Â Â Â pwm_init(master_clock, 10 * (16 - tim2_ticks));
Â Â else
Â Â Â Â pwm_init(master_clock, 10 * tim2_ticks);
Â Â tim2_ticks++;
}</span></pre>
<p><span class="koboSpan" id="kobo.718.1">If we initialize timer 2 in the main program to trigger interrupts spread over constant intervals, as in the previous examples, we can see the LED pulsating, rhythmically fading in </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">and out.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">In this case, timer 2 is initialized by the main program, and its associated interrupt handler updates the settings for timer 4, 20 times </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">per second:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.722.1">
void main(void) {
Â Â flash_set_waitstates();
Â Â clock_config();
Â Â led_pwm_setup();
Â Â pwm_init(CPU_FREQ</span><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.723.1">, 0);
Â Â timer_init(CPU_FREQ, 1, 50);
Â Â while(1)
Â Â Â Â WFI();
}</span></pre>
<h2 id="_idParaDest-147"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.724.1">Digital input</span></h2>
<p><span class="koboSpan" id="kobo.725.1">A GPIO pin</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.726.1"> configured in input mode detects the logic level of the voltage applied to it. </span><span class="koboSpan" id="kobo.726.2">The logic value of all the input pins on a GPIO controller can be read from</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.727.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.728.1">input data register</span></strong><span class="koboSpan" id="kobo.729.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.730.1">IDR</span></strong><span class="koboSpan" id="kobo.731.1">). </span><span class="koboSpan" id="kobo.731.2">On the reference board, pin A0 is connected to the user button, so the status of the button can be read at any time while the application </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">is running.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">GPIOA</span></strong><span class="koboSpan" id="kobo.735.1"> controller can be turned on by </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">clock gating:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.737.1">
#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))
#define GPIOA_AHB1_CLOCK_ER (1 &lt;&lt; 0)</span></pre>
<p><span class="koboSpan" id="kobo.738.1">The controller itself is mapped at </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">0x40020000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.742.1">
#define GPIOA_BASE 0x40020000
#define GPIOA_MODE (*(volatile uint32_t *)(GPIOA_BASE +
Â Â Â Â Â 0x00))
#define GPIOA_IDR (*(volatile uint32_t *)(GPIOA_BASE +
Â Â Â Â Â 0x10))</span></pre>
<p><span class="koboSpan" id="kobo.743.1">To set up the pin for input, we only ensure that the mode is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">0</span></strong><span class="koboSpan" id="kobo.745.1">, by clearing the two mode bits relative to </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">pin </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.749.1">
#define BUTTON_PIN (0)
void button_setup(void)
{
Â Â AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
Â Â GPIOA_MODE &amp;= ~ (0x03 &lt;&lt; (BUTTON_PIN * 2));
}</span></pre>
<p><span class="koboSpan" id="kobo.750.1">The </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.751.1">application can now check the status of the button at any time by reading the lowest bit of the IDR. </span><span class="koboSpan" id="kobo.751.2">When the button is pressed, the reference voltage is connected to the pin, and the value of the bit corresponding to the pin changes from </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.753.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.756.1">
int button_is_pressed(vo</span><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.757.1">id)
{
Â Â return (GPIOA_IDR &amp; (1 &lt;&lt; BUTTON_PIN)) &gt;&gt; BUTTON_PIN;
}</span></pre>
<h2 id="_idParaDest-148"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.758.1">Interrupt-based input</span></h2>
<p><span class="koboSpan" id="kobo.759.1">Having </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.760.1">to proactively read the value of a pin by constantly polling the IDR is not convenient in many cases, where the application is supposed to react to state changes. </span><span class="koboSpan" id="kobo.760.2">Microcontrollers usually provide mechanisms to connect digital input pins to interrupt lines so that the application can react in real time to events related to the input because the execution is interrupted to execute the associated </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">service routine.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">On the </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.763.1">reference </span><strong class="bold"><span class="koboSpan" id="kobo.764.1">microcontroller unit</span></strong><span class="koboSpan" id="kobo.765.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.766.1">MCU</span></strong><span class="koboSpan" id="kobo.767.1">), pin A0 can be connected to the external interrupt and event controller, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.768.1">EXTI</span></strong><span class="koboSpan" id="kobo.769.1">. </span><span class="koboSpan" id="kobo.769.2">EXTI </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.770.1">offers edge-detection triggers that can be attached to interrupt lines. </span><span class="koboSpan" id="kobo.770.2">The number of the pin within the GPIO group determines the number of the EXTI interrupt that is associated with it so that the EXTI 0 interrupt routine may be connected to pin 0 of any GPIO group </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">if needed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.772.1"><img alt="Figure 6.2 â€“ EXTI0 controller associating edge detection triggers to the user button connected to PA0" src="image/B18730_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.773.1">Figure 6.2 â€“ EXTI0 controller associating edge detection triggers to the user button connected to PA0</span></p>
<p><span class="koboSpan" id="kobo.774.1">To</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.775.1"> associate </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">PA0</span></strong><span class="koboSpan" id="kobo.777.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">EXTI 0</span></strong><span class="koboSpan" id="kobo.779.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.780.1">EXTI configuration</span></strong><span class="koboSpan" id="kobo.781.1"> register must be modified to set the number of the GPIO group in the bits associated with </span><strong class="bold"><span class="koboSpan" id="kobo.782.1">EXTI 0</span></strong><span class="koboSpan" id="kobo.783.1">. </span><span class="koboSpan" id="kobo.783.2">In the STM32F4, the </span><strong class="bold"><span class="koboSpan" id="kobo.784.1">EXTI configuration</span></strong><span class="koboSpan" id="kobo.785.1"> registers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">EXTI_CR</span></strong><span class="koboSpan" id="kobo.787.1">) are located at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">0x40013808</span></strong><span class="koboSpan" id="kobo.789.1">. </span><span class="koboSpan" id="kobo.789.2">Each register is used to set the interrupt controller associated with an EXTI line. </span><span class="koboSpan" id="kobo.789.3">The lowest four bits of the first register are relative to EXTI line 0. </span><span class="koboSpan" id="kobo.789.4">The number for the GPIO group A is 0, so we need to ensure that the corresponding bits are cleared in the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">EXTI_CR</span></strong><span class="koboSpan" id="kobo.791.1"> register. </span><span class="koboSpan" id="kobo.791.2">The goal of the next example is to demonstrate how to enable the </span><strong class="bold"><span class="koboSpan" id="kobo.792.1">EXTI 0</span></strong><span class="koboSpan" id="kobo.793.1"> interrupt and associate it to pin A0, so the following definitions are provided to access the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">EXTI_CR</span></strong><span class="koboSpan" id="kobo.795.1"> register to set the GPIO </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">group A:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.797.1">
#define EXTI_CR_BASE (0x40013808)
#define EXTI_CR0 (*(volatile uint32_t *)(EXTI_CR_BASE +
Â Â Â Â 0x00))
#define EXTI_CR_EXTI0_MASK (0x0F)</span></pre>
<p><span class="koboSpan" id="kobo.798.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">EXTI0</span></strong><span class="koboSpan" id="kobo.800.1"> interrupt is connected to NVIC line number </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">6</span></strong><span class="koboSpan" id="kobo.802.1">, so we add this definition to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">the NVIC:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
#define NVIC_EXTI0_IRQN (6)</span></pre>
<p><span class="koboSpan" id="kobo.805.1">The </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.806.1">EXTI controller in STM32F4 microcontrollers is located at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">0x40013C00</span></strong><span class="koboSpan" id="kobo.808.1">, and provides the </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">following registers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.810.1">Interrupt mask register</span></strong><span class="koboSpan" id="kobo.811.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.812.1">IMR</span></strong><span class="koboSpan" id="kobo.813.1">) at </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.814.1">offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">0</span></strong><span class="koboSpan" id="kobo.816.1">. </span><span class="koboSpan" id="kobo.816.2">Sets/clears the corresponding bit to enable/disable the interrupt for each of the </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">EXTI lines.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.818.1">Event mask register</span></strong><span class="koboSpan" id="kobo.819.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.820.1">EMR</span></strong><span class="koboSpan" id="kobo.821.1">) at</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.822.1"> offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">4</span></strong><span class="koboSpan" id="kobo.824.1">. </span><span class="koboSpan" id="kobo.824.2">Sets/clears the corresponding bit to enable/disable the event trigger for the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">EXTI line.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.826.1">Rising trigger select register</span></strong><span class="koboSpan" id="kobo.827.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.828.1">RTSR</span></strong><span class="koboSpan" id="kobo.829.1">) at offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">8</span></strong><span class="koboSpan" id="kobo.831.1">. </span><span class="koboSpan" id="kobo.831.2">Sets the corresponding bit to </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.832.1">generate events and interrupts when the associated digital input level switches from 0 </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">to 1.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.834.1">Falling trigger select register</span></strong><span class="koboSpan" id="kobo.835.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.836.1">FTSR</span></strong><span class="koboSpan" id="kobo.837.1">) at offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">12</span></strong><span class="koboSpan" id="kobo.839.1">. </span><span class="koboSpan" id="kobo.839.2">Sets the corresponding bit to </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.840.1">generate events and interrupts when the associated signal falls from a logic value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">1</span></strong><span class="koboSpan" id="kobo.842.1"> back </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.846.1">Software interrupt enable register</span></strong><span class="koboSpan" id="kobo.847.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.848.1">SWIER</span></strong><span class="koboSpan" id="kobo.849.1">) at offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">16</span></strong><span class="koboSpan" id="kobo.851.1">. </span><span class="koboSpan" id="kobo.851.2">If a bit is set in this register, the </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.852.1">associated interrupt event will be immediately generated, and the service routine executed. </span><span class="koboSpan" id="kobo.852.2">This mechanism can be used to implement custom </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">software interrupts.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.854.1">Pending interrupt register</span></strong><span class="koboSpan" id="kobo.855.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.856.1">PR</span></strong><span class="koboSpan" id="kobo.857.1">) at offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">20</span></strong><span class="koboSpan" id="kobo.859.1">. </span><span class="koboSpan" id="kobo.859.2">To clear a pending interrupt, the</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.860.1"> service routine should set the bit corresponding to the EXTI line, or the interrupt will remain pending. </span><span class="koboSpan" id="kobo.860.2">A new service routine will be spawned until the PR bit for the EXTI line </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">is cleared.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.862.1">For convenience, we may define the registers </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.864.1">
#define EXTI_BASE (0x40013C00)
#define EXTI_IMR (*(volatile uint32_t *)(EXTI_BASE + 0x00))
#define EXTI_EMR (*(volatile uint32_t *)(EXTI_BASE + 0x04))
#define EXTI_RTSR (*(volatile uint32_t *)(EXTI_BASE +
Â Â Â Â 0x08))
#define EXTI_FTSR (*(volatile uint32_t *)(EXTI_BASE +
Â Â Â Â 0x0c))
#define EXTI_SWIER (*(volatile uint32_t *)(EXTI_BASE +
Â Â Â Â 0x10))
#define EXTI_PR (*(volatile uint32_t *)(EXTI_BASE + 0x14))</span></pre>
<p><span class="koboSpan" id="kobo.865.1">The </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.866.1">procedure to enable the interrupt on the rising edge of PA0, associated with the button press, is </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.868.1">
void button_setup(void)
{
Â Â AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
Â Â GPIOA_MODE &amp;= ~ (0x03 &lt;&lt; (BUTTON_PIN * 2));
Â Â EXTI_CR0 &amp;= ~EXTI_CR_EXTI0_MASK;
Â Â nvic_irq_enable(NVIC_EXTI0_IRQN);
Â Â EXTI_IMR |= 1 &lt;&lt; BUTTON_PIN;
Â Â EXTI_EMR |= 1 &lt;&lt; BUTTON_PIN;
Â Â EXTI_RTSR |= 1 &lt;&lt; BUTTON_PIN;
}</span></pre>
<p><span class="koboSpan" id="kobo.869.1">The ISR, IMR, and RTSR corresponding bits have been set, and the interrupt has been enabled in the NVIC. </span><span class="koboSpan" id="kobo.869.2">Instead of polling for the value of the digital input to change, we can now define a service routine that will be invoked every time the button </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">is pressed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.871.1">
volatile uint32_t button_presses = 0;
void isr_exti0(void)
{
Â Â EXTI_PR |= 1 &lt;&lt; BUTTON_PIN;
Â Â button_presses++;
}</span></pre>
<p><span class="koboSpan" id="kobo.872.1">In this simple example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">button_presses</span></strong><span class="koboSpan" id="kobo.874.1"> counter is expected to increase by one at every </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.875.1">button press event. </span><span class="koboSpan" id="kobo.875.2">In a real-life scenario, buttons based on mechanical contact (such as the one on the STM32F407-Discovery) are tricky to control using this mechanism. </span><span class="koboSpan" id="kobo.875.3">A single physical button press may in fact trigger the rising front interrupt multiple times during the transitory phase. </span><span class="koboSpan" id="kobo.875.4">This phenomenon, known as a button bouncing effect, can be </span><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.876.1">mitigated using specific </span><em class="italic"><span class="koboSpan" id="kobo.877.1">debounce</span></em><span class="koboSpan" id="kobo.878.1"> techniques, which are not </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">discussed here.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.880.1">Analog input</span></h2>
<p><span class="koboSpan" id="kobo.881.1">Some pins </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.882.1">have the possibility to measure the applied voltage dynamically and assign a discrete number to the measured value, using an </span><strong class="bold"><span class="koboSpan" id="kobo.883.1">analog-to-digital signal converter</span></strong><span class="koboSpan" id="kobo.884.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.885.1">ADC</span></strong><span class="koboSpan" id="kobo.886.1">. </span><span class="koboSpan" id="kobo.886.2">This</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.887.1"> is very useful to acquire data from a wide range of sensors, capable of conveying the information as output voltage or simply using a </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">variable resistor.</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">The configuration of the ADC subsystem may vary significantly across different platforms. </span><span class="koboSpan" id="kobo.889.2">ADCs on modern microcontrollers offer a wide range of configuration options. </span><span class="koboSpan" id="kobo.889.3">The reference microcontroller equips 3 separate ADC controllers, sharing 16 input channels, each one with a resolution of 12 bits. </span><span class="koboSpan" id="kobo.889.4">Multiple features are available, such as DMA transfer of the acquired data, and monitoring the signals in between two </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">watchdog thresholds.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">ADC controllers are generally designed to automatically sample input values multiple times per second and provide stable results that are immediately available. </span><span class="koboSpan" id="kobo.891.2">The case we analyze here is simpler and consists of a one-shot read operation for a </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">single conversion.</span></span></p>
<p><span class="koboSpan" id="kobo.893.1">Associating a specific pin to a controller is possible by checking how channels are mapped on the controllers if the pin supports it and it is connected through a channel to one of the configured as analog input and reading out the value, which results from the conversion of the analog signal. </span><span class="koboSpan" id="kobo.893.2">In this example, pin B1 is used as analog input and can be connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">ADB1</span></strong><span class="koboSpan" id="kobo.895.1"> controller through channel </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">9</span></strong><span class="koboSpan" id="kobo.897.1">. </span><span class="koboSpan" id="kobo.897.2">The following constants and registers are defined for the configuration of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">ADB1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.899.1"> controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.900.1">
#define APB2_CLOCK_ER (*(volatile uint32_t *)(0x40023844))
#define ADC1_APB2_CLOCK_ER_VAL (1 &lt;&lt; 8)
#define ADC1_BASE (0x40012000)
#define ADC1_SR (*(volatile uint32_t *)(ADC1_BASE + 0x00))
#define ADC1_CR1 (*(volatile uint32_t *)(ADC1_BASE +
Â Â Â Â Â 0x04))
#define ADC1_CR2 (*(volatile uint32_t *)(ADC1_BASE +
Â Â Â Â Â 0x08))
#define ADC1_SMPR1 (*(volatile uint32_t *)(ADC1_BASE +
Â Â Â Â Â 0x0c))
#define ADC1_SMPR2 (*(volatile uint32_t *)(ADC1_BASE +
Â Â Â Â Â 0x10))
#define ADC1_SQR3 (*(volatile uint32_t *)(ADC1_BASE +
Â Â Â Â Â 0x34))
#define ADC1_DR (*(volatile uint32_t *)(ADC1_BASE + 0x4c))
#define ADC_CR1_SCAN (1 &lt;&lt; 8)
#define ADC_CR2_EN (1 &lt;&lt; 0)
#define ADC_CR2_CONT (1 &lt;&lt; 1)
#define ADC_CR2_SWSTART (1 &lt;&lt; 30)
#define ADC_SR_EOC (1 &lt;&lt; 1)
#define ADC_SMPR_SMP_480CYC (0x7)</span></pre>
<p><span class="koboSpan" id="kobo.901.1">These are </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.902.1">the definitions to configure GPIO as usual, this time mapped </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">GPIOB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.906.1">
#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))
#define GPIOB_AHB1_CLOCK_ER (1 &lt;&lt; 1)
#define GPIOB_BASE (0x40020400)
#define GPIOB_MODE (*(volatile uint32_t *)(GPIOB_BASE +
Â Â Â Â Â 0x00))
#define ADC_PIN (1)
#define ADC_PIN_CHANNEL (9)</span></pre>
<p><span class="koboSpan" id="kobo.907.1">The </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.908.1">three ADCs share a few registers for common settings, such as the clock prescale factor, so they will all operate at the same frequency. </span><span class="koboSpan" id="kobo.908.2">The prescale factor for the ADC must be set within the working range of the converter recommended by the datasheetâ€”in the target platform, halving the frequency of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">APB2</span></strong><span class="koboSpan" id="kobo.910.1"> clock through the common prescaler. </span><span class="koboSpan" id="kobo.910.2">The common ADC configuration registers start at </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">0x40012300</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.914.1">
#define ADC_COM_BASE (0x40012300)
#define ADC_COM_CCR (*(volatile uint32_t *)(ADC_COM_BASE +
Â Â Â Â 0x04))</span></pre>
<p><span class="koboSpan" id="kobo.915.1">Based on these definitions, the initialization function can be written as follows. </span><span class="koboSpan" id="kobo.915.2">First, we enable the clock gating for both the ADC controller and the </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">GPIO group:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
int adc_init(void)
{
Â Â APB2_CLOCK_ER |= ADC1_APB2_CLOCK_ER_VAL;
Â Â AHB1_CLOCK_ER |= GPIOB_AHB1_CLOCK_ER;</span></pre>
<p><span class="koboSpan" id="kobo.918.1">PB1 is set to analog input mode, corresponding to the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">3</span></strong><span class="koboSpan" id="kobo.920.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">mode register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
Â Â GPIOB_MODE |= 0x03 &lt;&lt; (ADC_PIN * 2);</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">ADC1</span></strong><span class="koboSpan" id="kobo.924.1"> is temporarily switched off to set the desired configuration. </span><span class="koboSpan" id="kobo.924.2">The common clock prescaler is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">0</span></strong><span class="koboSpan" id="kobo.926.1">, meaning a divisor of 2 from the input clock. </span><span class="koboSpan" id="kobo.926.2">This ensures that the frequency fed to the ADC controller is within its operational range. </span><span class="koboSpan" id="kobo.926.3">Scan mode is disabled, and so is continuous mode, as we are not using these features in </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.928.1">
Â Â ADC1_CR2 &amp;= ~(ADC_CR2_EN);
Â Â ADC_COM_CCR &amp;= ~(0x03 &lt;&lt; 16);
Â Â ADC1_CR1 &amp;= ~(ADC_CR1_SCAN);
Â Â ADC1_CR2 &amp;= ~(ADC_CR2_CONT);</span></pre>
<p><span class="koboSpan" id="kobo.929.1">The sampling frequency can be set using the two registers </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">SMPR1</span></strong><span class="koboSpan" id="kobo.931.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">SMPR2</span></strong><span class="koboSpan" id="kobo.933.1">, depending on the channel in use. </span><span class="koboSpan" id="kobo.933.2">Each register represents one channel sample rate using 3 bits per register, so the channels </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">0</span></strong><span class="koboSpan" id="kobo.935.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">9</span></strong><span class="koboSpan" id="kobo.937.1"> are configurable using </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">SMPR1</span></strong><span class="koboSpan" id="kobo.939.1">, and all the others through </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">SMPR2</span></strong><span class="koboSpan" id="kobo.941.1">. </span><span class="koboSpan" id="kobo.941.2">The channel for PB1 is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">9</span></strong><span class="koboSpan" id="kobo.943.1">, so in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">SMPR1</span></strong><span class="koboSpan" id="kobo.945.1"> register</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.946.1"> is used, but to remind about this, the generic mechanism to set the sample rate on any channel </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">is provided:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.948.1">
Â Â if (ADC_PIN_CHANNEL &gt; 9) {
Â Â Â Â uint32_t val = ADC1_SMPR2;
Â Â Â Â val = ADC_SMPR_SMP_480CYC &lt;&lt; ((ADC_PIN_CHANNEL - 10) *
Â Â Â Â 3);
Â Â Â Â ADC1_SMPR2 = val;
Â Â } else {
Â Â Â Â uint32_t val = ADC1_SMPR1;
Â Â Â Â val = ADC_SMPR_SMP_480CYC &lt;&lt; (ADC_PIN_CHANNEL * 3);
Â Â Â Â ADC1_SMPR1 = val;
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.949.1">Finally, the channel is enabled in the conversion sequence of the ADC controller using the </span><strong class="bold"><span class="koboSpan" id="kobo.950.1">sequence registers</span></strong><span class="koboSpan" id="kobo.951.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.952.1">SQRs</span></strong><span class="koboSpan" id="kobo.953.1">). </span><span class="koboSpan" id="kobo.953.2">The </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.954.1">mechanisms foresee that multiple channels can be added to the same sequence on the controller, by populating the registers in inverse order, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">SQR3</span></strong><span class="koboSpan" id="kobo.956.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">SQR1</span></strong><span class="koboSpan" id="kobo.958.1">. </span><span class="koboSpan" id="kobo.958.2">Each source channel is represented in five bits, so each register contains up to six sources, except </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">SQR1</span></strong><span class="koboSpan" id="kobo.960.1">, which stores five, and reserves the higher bits to indicate the length of the stack stored in the registers, minus one. </span><span class="koboSpan" id="kobo.960.2">In our case, there is no need to set the length-minus-one field, as it would be zero for a single source </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">SQR1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.964.1">
Â Â ADC1_SQR3 |= (ADC_PIN_CHANNEL);</span></pre>
<p><span class="koboSpan" id="kobo.965.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">ADC1</span></strong><span class="koboSpan" id="kobo.967.1"> analog converter is enabled again by setting the enable bit in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">CR2</span></strong><span class="koboSpan" id="kobo.969.1"> control register and the initialization function </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">successfully returns:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.971.1">
Â Â ADC1_CR2 |= ADC_CR2_EN;
Â Â return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.972.1">After the ADC has been initialized and configured to convert the analog signal on PB1, the A/D conversion can be started at any time. </span><span class="koboSpan" id="kobo.972.2">A simple blocking read function would initiate the</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.973.1"> conversion, wait for the conversion to be successfully started, then wait until the conversion is completed by looking at the </span><strong class="bold"><span class="koboSpan" id="kobo.974.1">end of conversion</span></strong><span class="koboSpan" id="kobo.975.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.976.1">EOC</span></strong><span class="koboSpan" id="kobo.977.1">) bit</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.978.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">status register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.980.1">
int adc_read(void)
{
Â Â ADC1_CR2 |= ADC_CR2_SWSTART;
Â Â while (ADC1_CR2 &amp; ADC_CR2_SWSTART)
Â Â Â Â ;
Â Â while ((ADC1_SR &amp; ADC_SR_EOC) == 0)
Â Â Â Â ;</span></pre>
<p><span class="koboSpan" id="kobo.981.1">When the conversion is completed, the corresponding discrete value is available on the lowest 12 bits of the data register, and can be returned to </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">the caller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
Â Â return (int)(ADC1_DR);
}</span></pre>
<p><span class="koboSpan" id="kobo.984.1">We have learned how to communicate with the outside world using GPIOs. </span><span class="koboSpan" id="kobo.984.2">The same GPIO setup and management interface will be useful again in the next chapter to configure more complex, local bus interfaces, using the alternate functions for the associated </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">GPIO lines.</span></span></p>
<p><span class="koboSpan" id="kobo.986.1">The upcoming section introduces the watchdog, the last of the generic system features analyzed in this chapter. </span><span class="koboSpan" id="kobo.986.2">Commonly present in several microcontrollers, it provides a handy emergency recovery procedure whenever, for any reason, the system is frozen and will not resume its </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">normal execution.</span></span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.988.1">The watchdog</span></h1>
<p><span class="koboSpan" id="kobo.989.1">A common </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.990.1">feature in many microcontrollers is the presence of a watchdog timer. </span><span class="koboSpan" id="kobo.990.2">A watchdog ensures that the system is not stuck within an endless loop or any other blocking situation within the code. </span><span class="koboSpan" id="kobo.990.3">This is particularly useful in bare-metal applications that rely on an event-driven loop, where calls are required not to block, and to return to the main event loop within the allowed amount </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.992.1">The watchdog must be seen as the very last resort to recover an unresponsive system, by triggering a forced reboot regardless of the current state of execution in </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">the CPU.</span></span></p>
<p><span class="koboSpan" id="kobo.994.1">The reference platform provides one independent watchdog timer, with a counter similar to those of the generic timers, with a 12-bit granularity and a prescaler factor. </span><span class="koboSpan" id="kobo.994.2">The prescaler of the watchdog, however, is expressed in multiples of 2 and has a range between 4 (represented by the value 0) and 256 (</span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">value 6).</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">The clock source is connected to a lower-speed oscillator, through an independent branch of the clock distribution. </span><span class="koboSpan" id="kobo.996.2">For this reason, clock gating is not involved in the activation of </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">this peripheral.</span></span></p>
<p><span class="koboSpan" id="kobo.998.1">The watchdog configuration area is mapped within the peripherals address region, and consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">four registers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1000.1">The </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.1001.1">key register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">0</span></strong><span class="koboSpan" id="kobo.1003.1">), used to trigger the three unlock, start, and reset operations by writing predefined values in the lowest </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">16 bits</span></span></li>
<li><span class="koboSpan" id="kobo.1005.1">The </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.1006.1">prescale register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">4</span></strong><span class="koboSpan" id="kobo.1008.1">), to set the prescale factor of </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">the counter</span></span></li>
<li><span class="koboSpan" id="kobo.1010.1">The </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.1011.1">reload register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">8</span></strong><span class="koboSpan" id="kobo.1013.1">), containing the reload value for </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">the counter</span></span></li>
<li><span class="koboSpan" id="kobo.1015.1">The </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.1016.1">status register (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">12</span></strong><span class="koboSpan" id="kobo.1018.1">), providing the status flags to synchronize the </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">setup operations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1020.1">The registers can be referenced using </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">shortcut macros:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
#define IWDG_BASE (0x40003000)
#define IWDG_KR (*(volatile uint32_t *)(IWDG_BASE + 0x00))
#define IWDG_PR (*(volatile uint32_t *)(IWDG_BASE + 0x04))
#define IWDG_RLR (*(volatile uint32_t *)(IWDG_BASE + 0x08))
#define IWDG_SR (*(volatile uint32_t *)(IWDG_BASE + 0x0c))</span></pre>
<p><span class="koboSpan" id="kobo.1023.1">The three possible operations that can be triggered via the key register are </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1025.1">
#define IWDG_KR_RESET 0x0000AAAA
#define IWDG_KR_UNLOCK 0x00005555
#define IWDG_KR_START 0x0000CCCC</span></pre>
<p><span class="koboSpan" id="kobo.1026.1">Two </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.1027.1">meaningful status bits are provided in the status, and they must be checked to ensure that the watchdog is not busy before unlocking and setting the value for prescale </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">and reload:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1029.1">
#define IWDG_SR_RVU (1 &lt;&lt; 1)
#define IWDG_SR_PVU (1 &lt;&lt; 0)</span></pre>
<p><span class="koboSpan" id="kobo.1030.1">The initialization function to configure and start the watchdog may look like </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
int iwdt_init(uint32_t interval_ms)
{
Â Â Â uint32_t pre = 0;
Â Â Â uint32_t counter;</span></pre>
<p><span class="koboSpan" id="kobo.1033.1">In the next line, the input value in milliseconds is scaled to the frequency of the watchdog clock, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">32 kHz:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
Â Â Â counter = interval_ms &lt;&lt; 5;</span></pre>
<p><span class="koboSpan" id="kobo.1036.1">The minimum prescaler factor is 4, however, so the value should be divided again. </span><span class="koboSpan" id="kobo.1036.2">We then look for the minimum prescaler value that results in a counter that fits the 12 bits available, by halving the counter value and increasing the prescaler factor until the counter is </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">appropriately scaled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1038.1">
Â Â Â counter &gt;&gt;= 2;
Â Â Â while (counter &gt; 0xFFF) {
Â Â Â Â Â pre++;
Â Â Â Â Â counter &gt;&gt;= 1;
Â Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1039.1">The following checks ensure that the interval provided does not result in a zero counter or a value that is too large for the available </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">scaling factor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1041.1">
Â Â Â if (counter == 0)
Â Â Â Â Â counter = 1;
Â Â Â if (pre &gt; 6)
Â Â Â Â Â return -1;</span></pre>
<p><span class="koboSpan" id="kobo.1042.1">The </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.1043.1">actual initialization of the registers is done, but the device requires us to initiate the write with an unlock operation, and only after checking that the registers are available </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">for writing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
Â Â Â while(IWDG_SR &amp; IWDG_SR_PR_BUSY);
Â Â Â IWDG_KR = IWDG_KR_UNLOCK;
Â Â Â IWDG_PR = pre;
Â Â Â while (IWDG_SR &amp; IWDG_SR_RLR_BUSY);
Â Â Â IWDG_KR = IWDG_KR_UNLOCK;
Â Â Â IWDG_RLR = counter;</span></pre>
<p><span class="koboSpan" id="kobo.1046.1">Starting the watchdog simply consists of setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">START</span></strong><span class="koboSpan" id="kobo.1048.1"> command in the key register to initiate the </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">start operation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
Â Â Â IWDG_KR = IWDG_KR_START;
Â Â Â return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.1051.1">Once started, the watchdog cannot be stopped and will run forever, decreasing the counter until it reaches zero, and rebooting </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.1053.1">The only way to prevent the system from being rebooted is resetting the timer manually, an operation often referred to as </span><em class="italic"><span class="koboSpan" id="kobo.1054.1">kicking the watchdog</span></em><span class="koboSpan" id="kobo.1055.1">. </span><span class="koboSpan" id="kobo.1055.2">A watchdog driver should export a function that allows the application to reset the counterâ€”for example, at the end of each iteration in the main loop. </span><span class="koboSpan" id="kobo.1055.3">Here </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">is ours:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1057.1">
void iwdt_reset(void)
{
Â Â Â IWDG_KR = IWDG_KR_RESET;
}</span></pre>
<p><span class="koboSpan" id="kobo.1058.1">As a simple test for the watchdog driver, a watchdog counter of 2 seconds can be initialized </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1062.1">
void main(void) {
Â Â flash_set_waitstates();
Â Â clock_config();
Â Â button_setup();
Â Â iwdt_init(2000);
Â Â while(1)
Â Â Â Â WFI();
}</span></pre>
<p><span class="koboSpan" id="kobo.1063.1">The </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.1064.1">watchdog is reset upon button press, in the interrupt service routine of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">GPIO button:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1066.1">
void isr_exti0(void)
{
Â Â EXTI_PR |= (1 &lt;&lt; BUTTON_PIN);
Â Â iwdt_reset();
}</span></pre>
<p><span class="koboSpan" id="kobo.1067.1">In this test, the system will reboot if the user button is not pressed for 2 seconds</span><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.1068.1"> in a row, so the only way to keep the system running is by repeatedly pressing </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">the button.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.1070.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1071.1">The clock configuration, timers, and I/O lines are the general-purpose peripherals shown in this chapter, commonly supported by a wide range of microcontrollers. </span><span class="koboSpan" id="kobo.1071.2">Although implementation details such as register names and placement may differ on other targets, the proposed approach is valid on most embedded platforms, and the general-purpose peripherals are the bricks for building the most basic system functionalities as well as providing a means of interaction with sensors </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">and actuators.</span></span></p>
<p><span class="koboSpan" id="kobo.1073.1">In the next chapter, we will focus on serial communication channels provided by most microprocessors as communication interfaces toward other devices, and peripherals in the proximity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">target system.</span></span></p>
</div>
</body></html>