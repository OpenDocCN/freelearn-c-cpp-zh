<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-131"><a id="_idTextAnchor194"/>6</h1>
<h1 id="_idParaDest-132"><a id="_idTextAnchor195"/>General-Purpose Peripherals</h1>
<p>Modern microcontrollers integrate several features that help in building stable and reliable embedded systems. Once the system is up and running, memory and peripherals can be accessed, and basic functionalities are in place. Only then can all the components of the system be initialized by activating the associated peripherals through the system registers, setting the correct frequencies for the clock lines, and configuring and activating interrupts. In this chapter, we will describe the interface exposed by the microcontroller to access built-in peripherals and some basic system functionalities. We will focus on the following topics:</p>
<ul>
<li>The interrupt controller</li>
<li>System time</li>
<li>Generic timers</li>
<li><strong class="bold">General-purpose </strong><strong class="bold">input/output</strong> (<strong class="bold">GPIO</strong>)</li>
<li>The watchdog</li>
</ul>
<p>While these peripherals are often accessible through the hardware-support libraries implemented and distributed by chip manufacturers, our approach here involves fully understanding the hardware components and the meaning of all the registers involved. This will be achieved by configuring and using the functionalities in the microcontroller straight through the interface exported by the hardware logic.</p>
<p>When designing drivers for a specific platform, it is necessary to study the interface provided by the microcontroller to access peripherals and CPU features. In the examples provided, the STM32F4 microcontroller is used as a reference target for implementing platform-specific features. Nevertheless, inspecting a possible implementation on our reference platform allows us to get better insight into how to interact with generic targets exposing similar functionalities using the documentation provided by the silicon manufacturer.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor196"/>Technical requirements</h1>
<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6</a>.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor197"/>Bitwise operations</h2>
<p>The<a id="_idIndexMarker368"/> examples associated with this chapter make extensive use of bitwise operations for checking, setting, and clearing single bits within larger registers (in most cases, 32-bit long). You should already be familiar with bitwise logic operations in C.</p>
<p>The operations commonly<a id="_idIndexMarker369"/> used in the examples are the following:</p>
<ul>
<li><code>R |= (1 &lt;&lt; N)</code>: The new value of the register R will contain the result of the bitwise <code>OR</code> operation between its original value and a bitmask containing all zeros, except the bit corresponding to the value we want to set, which is set to the value one</li>
<li><code>R &amp;= ~(1 &lt;&lt; N)</code>: The new value of the register is the result of a bitwise <code>AND</code> operation between its original value and a bitmask containing all ones, except the bit in the position we want to clear, which is set to the value zero</li>
<li><code>(R &amp; (1 &lt;&lt; N) == (1 &lt;&lt; N))</code>: Returns <code>true</code> only if the Nth bit of the register is set</li>
</ul>
<p>Let us quickly jump into the first topic<a id="_idTextAnchor198"/>.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor199"/>The interrupt controller</h1>
<p>Real-time systems<a id="_idIndexMarker370"/> have improved their accuracy thanks to the rapid evolution of modern embedded systems, in particular from the research on interrupt controllers. Assigning different priorities to interrupt lines guarantees a lower interrupt latency for higher-priority interrupt sources and makes the system react faster to prioritized events. Interrupts may, however, occur at any time while the system is running, including during the execution of another interrupt service routine. In this case, the interrupt controller provides a way to chain the interrupt handlers, and the order of execution depends on the priority levels assigned to the interrupt source.</p>
<p>One of the <a id="_idIndexMarker371"/>reasons for the popularity of the Cortex-M family of microprocessors among real-time and low-power embedded applications is perhaps the design of its programmable real-time controller—namely, the <strong class="bold">Nested Vector Interrupt Controller</strong>, or <strong class="bold">NVIC</strong> for short. The<a id="_idIndexMarker372"/> NVIC supports up to 240 interrupt sources, which can be grouped into up to 256 priority levels, depending on the bits reserved to store the priority in the microprocessor logic. These characteristics make it very flexible, as the priorities can also be changed while the system is running, maximizing the freedom of choice for the programmer. As we already know, the NVIC is connected to the vector table located at the beginning of the code region. Whenever an interrupt occurs, the current state of the executing application is pushed into the stack automatically by the processor, and the service routine associated with the interrupt line is executed.</p>
<p>Systems that do not have an interrupt-priority mechanism implement back-to-back interrupt handling. In these cases, chaining interrupts implies that the context is restored at the end of the execution of the first service routine in line, and then saved again while entering the following one. The NVIC implements a tail-chaining mechanism to execute nested interrupts. If one or more interrupts occur while another service routine is executing, the pull operation normally occurring at the end of the interrupt to restore the context from the stack will be canceled, and the controller will instead fetch the location of the second handler in the interrupt vector and ensure it is executed immediately after the first. Because of the increased pace of the stack save and restore operations being implemented in hardware, the interrupt latency is significantly reduced in all those cases where interrupts are chained. Thanks to its implementation, NVIC allows us to change parameters while the system is running, and is able to reshuffle the order of execution of the interrupt service routines associated with the pending signals, according to the priority levels. Moreover, the same interrupt is not allowed to run twice in the same chain of handlers, which may be caused by altering the priorities in the other handlers. This is intrinsically enforced by the NVIC logic, which ensures that no loops are possible in the ch<a id="_idTextAnchor200"/>ain.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor201"/>Peripherals’ interrupt configuration</h2>
<p>Each<a id="_idIndexMarker373"/> interrupt line can be enabled and disabled through the NVIC Interrupt Set/Clear Enable registers, <code>NVIC_ISER</code> and <code>NVIC_ICER</code>, located at addresses <code>0xE000E100</code> and <code>0xE000E180</code>, respectively. If the target supports more than 32 external interrupts, arrays of 32-bit registers <a id="_idIndexMarker374"/>are mapped at the same locations. Each bit in the registers is used to activate a predefined interrupt line, associated with the bit position in that specific register. For example, on an STM32F4 microcontroller, in order to activate the interrupt line for <a id="_idIndexMarker375"/>the <code>NVIC_ISER</code> area.</p>
<p>The generic NVIC function, to enable the interrupt, activates the flag corresponding to the NVIC interrupt number for the source, in the associate <code>NVIC_ISER</code> register:</p>
<pre class="source-code">
#define NVIC_ISER_BASE (0xE000E100)
static inline void nvic_irq_enable(uint8_t n)
{
  int i = n / 32;
  volatile uint32_t *nvic_iser =
    ((volatile uint32_t *)(NVIC_ISER_BASE + 4 * i));
  *nvic_iser |= (1 &lt;&lt; (n % 32));
}</pre>
<p>Similarly, to disable the interrupt, the <code>nvic_irq_disable</code> function activates the corresponding bit in the interrupt clear register:</p>
<pre class="source-code">
#define NVIC_ICER_BASE (0xE000E180)
static inline void nvic_irq_disable(uint8_t n)
{
  int i = n / 32;
  volatile uint32_t *nvic_icer =
    ((volatile uint32_t *)(NVIC_ICER_BASE + 4 * i));
  *nvic_icer |= (1 &lt;&lt; (n % 32));
}</pre>
<p>The<a id="_idIndexMarker376"/> interrupt priorities are mapped in an array of 8-bit registers, each containing the priority value for the corresponding<a id="_idIndexMarker377"/> interrupt line, starting at address <code>0xE000E400</code> so that they can be accessed independently to change the priority at runtime:</p>
<pre class="source-code">
#define NVIC_IPRI_BASE (0xE000E400)
static inline void nvic_irq_setprio(uint8_t n,
    uint8_t prio)
{
  volatile uint8_t *nvic_ipri = ((volatile uint8_t *)
   (NVIC_IPRI_BASE + n));
  *nvic_ipri = prio;
}</pre>
<p>These functions will come in handy to route and prioritize interrupt lines whenever an interrupt is enabled for a pe<a id="_idTextAnchor202"/>ripheral.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor203"/>System time</h1>
<p>Timekeeping <a id="_idIndexMarker378"/>is a basic requirement for almost any embedded system. A microcontroller can be programmed <a id="_idIndexMarker379"/>to trigger an interrupt at regular intervals, which is commonly used to increment the monotonic system clock. To do so, a few configuration steps must be performed at startup in order to have a stable tick interrupt. Many processors can run at custom frequencies while using the same oscillator as the source. The input frequency of the oscillator, which can be internal or external to the CPU, is used to derive the processor’s main clock. The configurable logic integrated into the CPU is implemented <a id="_idIndexMarker380"/>by a <strong class="bold">phase-locked loop</strong> (<strong class="bold">PLL</strong>) that multiplies the input clock from an external stable source and produces the desired frequencies used by the CPU and integrated <a id="_idTextAnchor204"/>peripherals.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor205"/>Adjusting the flash wait states</h2>
<p>If the<a id="_idIndexMarker381"/> initialization code is running from flash, it might be necessary to set the wait state for the flash memory before altering the system clocks. If the microprocessor runs at high frequencies, it might require a few wait states in between <a id="_idIndexMarker382"/>two consecutive access operations to persistent memory with <code>0x40023800</code>. The <strong class="bold">Access Control Register</strong> (<strong class="bold">ACR</strong>), which<a id="_idIndexMarker383"/> is the one we need to access to set the wait states, is located at the beginning of the area:</p>
<pre class="source-code">
#define FLASH_BASE (0x40023C00)
#define FLASH_ACR (*(volatile uint32_t *)(FLASH_BASE +
   0x00))</pre>
<p>The lowest three bits in the <code>FLASH_ACR</code> register are used to set the number of wait states. According to the STM32F407 datasheet, the ideal number of wait states to access the flash while the system is running at 168 MHz is <code>5</code>. At the same time, we can enable the data and instruction cache by activating bits <code>10</code> and <code>9</code>, respectively:</p>
<pre class="source-code">
void flash_set_waitstates(void) {
  FLASH_ACR = 5 | (1 &lt;&lt; 10) | (1 &lt;&lt; 9);
}</pre>
<p>After the wait states are set, it is safe to run the code from the flash after setting the CPU frequency at a higher speed, so we can proceed with the actual clock configuration and distribution to t<a id="_idTextAnchor206"/>he peripherals.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor207"/>Clock configuration</h2>
<p>The<a id="_idIndexMarker384"/> configuration of the clocks in Cortex-M microcontrollers<a id="_idIndexMarker385"/> happens through the <strong class="bold">Reset and Clock Control</strong> (<strong class="bold">RCC</strong>) registers, located at a specific address within the internal peripheral region. The RCC configuration is vendor-specific, as it depends on the logic of the PLL implemented in the microcontroller. The registers are described in the documentation of the microcontroller, and often, example source code is provided by the chip manufacturer demonstrating how to properly configure the clocks on the microcontroller. On our reference target, STM32F407, assuming that an external 8 MHz oscillator is used as a source, the following procedure configures a 168 MHz system clock and ensures that the clock is also distributed to each peripheral bus. The following code ensures that the PLL is initialized with the required value and that the CPU clock is ticking at the desired frequency. This procedure is common among many STM Cortex-M microcontrollers, and the values for the PLL configurations can be obtained from the chip documentation, or calculated using software tools provided by ST.</p>
<p>The software examples provided after this point will make use of a system-specific module, exporting the functions needed to configure the clock and set the flash memory latency. We now analyze two possible implementations for the PLL configuration, on two different Cortex-M microcontrollers.</p>
<p>To access the configuration of the PLL in the STM32F407-Discovery, first, we define some shortcut macros to the addresses of the registers provided by the <code>RCC</code>:</p>
<pre class="source-code">
#define RCC_BASE (0x40023800)
#define RCC_CR (*(volatile uint32_t *)(RCC_BASE + 0x00))
#define RCC_PLLCFGR (*(volatile uint32_t *)(RCC_BASE +
    0x04))
#define RCC_CFGR (*(volatile uint32_t *)(RCC_BASE + 0x08))
#define RCC_CR (*(volatile uint32_t *)(RCC_BASE + 0x00))</pre>
<p>For the sake of readability, and to ensure that the code is maintainable in the future, we also define the mnemonics associated with the single-bit values in the corresponding registers:</p>
<pre class="source-code">
#define RCC_CR_PLLRDY (1 &lt;&lt; 25)
#define RCC_CR_PLLON (1 &lt;&lt; 24)
#define RCC_CR_HSERDY (1 &lt;&lt; 17)
#define RCC_CR_HSEON (1 &lt;&lt; 16)
#define RCC_CR_HSIRDY (1 &lt;&lt; 1)
#define RCC_CR_HSION (1 &lt;&lt; 0)
#define RCC_CFGR_SW_HSI 0x0
#define RCC_CFGR_SW_HSE 0x1
#define RCC_CFGR_SW_PLL 0x2
#define RCC_PLLCFGR_PLLSRC (1 &lt;&lt; 22)
#define RCC_PRESCALER_DIV_NONE 0
#define RCC_PRESCALER_DIV_2 8
#define RCC_PRESCALER_DIV_4 9</pre>
<p>Finally, we <a id="_idIndexMarker386"/>define the platform-specific constant values used to configure the PLL:</p>
<pre class="source-code">
#define CPU_FREQ (168000000)
#define PLL_FULL_MASK (0x7F037FFF)
#define PLLM 8
#define PLLN 336
#define PLLP 2
#define PLLQ 7
#define PLLR 0</pre>
<p>One additional macro invoking the <code>DMB</code> assembly instruction is defined, for brevity, as it will be used in the code to ensure that any pending memory transfer toward the configuration registers is completed before the execution of the next statement:</p>
<pre class="source-code">
#define DMB() asm volatile ("dmb");</pre>
<p>The next function will then ensure that the PLL initialization sequence is performed, in order to <a id="_idIndexMarker387"/>set the correct CPU frequency. First, it will enable the internal high-speed oscillator, and will wait until it is ready by polling the CR:</p>
<pre class="source-code">
void rcc_config(void)
{
  uint32_t reg32;
  RCC_CR |= RCC_CR_HSION;
  DMB();
  while ((RCC_CR &amp; RCC_CR_HSIRDY) == 0)
    ;</pre>
<p>The internal oscillator is then selected as a temporary clock source:</p>
<pre class="source-code">
  reg32 = RCC_CFGR;
  reg32 &amp;= ~((1 &lt;&lt; 1) | (1 &lt;&lt; 0));
  RCC_CFGR = (reg32 | RCC_CFGR_SW_HSI);
  DMB();</pre>
<p>The external oscillator is then activated in the same way:</p>
<pre class="source-code">
  RCC_CR |= RCC_CR_HSEON;
  DMB();
  while ((RCC_CR &amp; RCC_CR_HSERDY) == 0)
    ;</pre>
<p>On this device, the clock can be distributed to all the peripherals through three system buses. Using prescalers, the frequency of each bus can be scaled by a factor of two or four. In this case, we set the clock speed for HPRE, PPRE1, and PPRE2 to be 168, 84, and 46 MHz respectively on this target:</p>
<pre class="source-code">
  reg32 = RCC_CFGR;
  reg32 &amp;= ~0xF0;
  RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_NONE &lt;&lt; 4));
  DMB();
  reg32 = RCC_CFGR;
  reg32 &amp;= ~0x1C00;
  RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_2 &lt;&lt; 10));
  DMB();
  reg32 = RCC_CFGR;
  reg32 &amp;= ~0x07 &lt;&lt; 13;
  RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_4 &lt;&lt; 13));
  DMB();</pre>
<p>The <a id="_idIndexMarker388"/>PLL configuration register is set to contain the parameters to correctly scale the external oscillator frequency to the desired value:</p>
<pre class="source-code">
  reg32 = RCC_PLLCFGR;
  reg32 &amp;= ~PLL_FULL_MASK;
  RCC_PLLCFGR = reg32 | RCC_PLLCFGR_PLLSRC | PLLM |
    (PLLN &lt;&lt; 6) | (((PLLP &gt;&gt; 1) - 1) &lt;&lt; 16) |
    (PLLQ &lt;&lt; 24);
  DMB();</pre>
<p>The PLL is then activated, and the execution is suspended until the output is stable:</p>
<pre class="source-code">
  RCC_CR |= RCC_CR_PLLON;
  DMB();
  while ((RCC_CR &amp; RCC_CR_PLLRDY) == 0);</pre>
<p>The PLL is selected as the final source for the system clock:</p>
<pre class="source-code">
  reg32 = RCC_CFGR;
  reg32 &amp;= ~((1 &lt;&lt; 1) | (1 &lt;&lt; 0));
  RCC_CFGR = (reg32 | RCC_CFGR_SW_PLL);
  DMB();
  while ((RCC_CFGR &amp; ((1 &lt;&lt; 1) | (1 &lt;&lt; 0))) !=
    RCC_CFGR_SW_PLL);</pre>
<p>The<a id="_idIndexMarker389"/> internal oscillator is no longer in use and can be disabled. The control returns to the caller, and all the clocks are successfully set.</p>
<p>As mentioned earlier, the procedure for clock initialization is strictly dependent on the PLL configuration in the microcontroller. To properly initialize the system clocks required for the CPU and the peripherals to operate at the desired frequencies, it is always advised to refer to the datasheet of the microcontroller provided by the silicon manufacturer. As a second example, we can <a id="_idIndexMarker390"/>verify how <code>RCC</code> and <code>RCC2</code>:</p>
<pre class="source-code">
#define RCC (*(volatile uint32_t*))(0x400FE060)
#define RCC2 (*(volatile uint32_t*))(0x400FE070)</pre>
<p>To reset the <code>RCC</code> registers to a known state, the reset value must be written to these registers at boot:</p>
<pre class="source-code">
#define RCC_RESET (0x078E3AD1)
#define RCC2_RESET (0x07802810)</pre>
<p>This microcontroller uses a raw interrupt to notify that the PLL is locked to the requested frequency. The <a id="_idIndexMarker391"/>interrupt status can be checked by reading bit <code>6</code> in the <strong class="bold">Raw Interrupt Status</strong> (<strong class="bold">RIS</strong>) register:</p>
<pre class="source-code">
#define RIS (*(volatile uint32_t*))(0x400FE050)
#define PLL_LRIS (1 &lt;&lt; 6)</pre>
<p>The clock configuration routine in this case starts by resetting the <code>RCC</code> registers and setting the appropriate values to configure the PLL. The PLL is configured to generate a 400 MHz clock from an 8 MHz oscillator source:</p>
<pre class="source-code">
void rcc_config(void)
{
  RCC = RCC_RESET;
  RCC2 = RCC2_RESET;
  DMB();
  RCC = RCC_SYSDIV_50MHZ | RCC_PWMDIV_64 |
    RCC_XTAL_8MHZ_400MHZ | RCC_USEPWMDIV;</pre>
<p>The<a id="_idIndexMarker392"/> resultant 50 MHz CPU frequency is derived from this master 400 MHz clock using the system divider. The clock is pre-divided by two, and then a factor of <code>4</code> is applied:</p>
<pre class="source-code">
  RCC2 = RCC2_SYSDIV2_4;
  DMB();</pre>
<p>The external oscillators are powered on:</p>
<pre class="source-code">
  RCC &amp;= ~RCC_OFF;
  RCC2 &amp;= ~RCC2_OFF;</pre>
<p>And the system clock divider is powered on as well. At the same time, setting the bypass bit ensures that the oscillator is used as a source for the system clock, and the PLL is bypassed:</p>
<pre class="source-code">
  RCC |= RCC_BYPASS | RCC_USESYSDIV;
  DMB();</pre>
<p>The execution is held until the PLL is stable and has locked on the desired frequency:</p>
<pre class="source-code">
 while ((RIS &amp; PLL_LRIS) == 0)   ;</pre>
<p>Disabling the bypass bits in the <code>RCC</code> registers at this point is sufficient to connect the PLL output to the system clock:</p>
<pre class="source-code">
  RCC &amp;= ~RCC_BYPASS;
  RCC2 &amp;= ~RCC2_BYPASS;
}</pre>
<h2 id="_idParaDest-140"><a id="_idTextAnchor208"/>Clock distribution</h2>
<p>Once the <a id="_idIndexMarker393"/>bus clocks are available, the <code>RCC</code> logic can be programmed to distribute the clock to single peripherals. To do so, the <code>RCC</code> exposes bit-mapped peripheral clock source registers. Setting the corresponding bit in one of the registers enables the clock for each mapped peripheral in the microcontroller. Each register can control clock gating for 32 peripherals.</p>
<p>The order of the peripherals, and consequently the corresponding register and bit, is strictly dependent on the specific microcontrollers. The STM32F4 has three registers dedicated to this purpose. For example, to enable the clock source for the internal watchdog, it is sufficient to set the bit number <code>9</code> in the clock enable register at address <code>0x40021001c</code>:</p>
<pre class="source-code">
#define APB1_CLOCK_ER (*(uint32_t *)(0x4002001c))
#define WDG_APB1_CLOCK_ER_VAL (1 &lt;&lt; 9)
APB1_CLOCK_ER |= WDG_APB1_CLOCK_ER_VAL;</pre>
<p>Keeping the clock source off for a peripheral that is not in use saves power; thus, if the target supports clock gating, it can implement optimization and fine-tuning of power consumption by disabling the single peripherals at runtime t<a id="_idTextAnchor209"/>hrough their clock gates.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor210"/>Enabling the SysTick</h2>
<p>Once a <a id="_idIndexMarker394"/>stable CPU frequency has been set up, we can configure the <a id="_idIndexMarker395"/>main timer on the system—the SysTick. Since the implementation of a specific system timer is not mandatory on all Cortex-M, sometimes it is necessary to use an ordinary auxiliary timer to keep track of the system time. In most cases, though, the SysTick interrupt can be enabled by accessing its configuration, which is located in the system control block within the system configuration region. In all Cortex-M microcontrollers that include a system tick, the configuration can be found starting at address <code>0xE000E010</code>, and exposes four registers:</p>
<ul>
<li>The control/status register (<code>SYSTICK_CSR</code>) at offset <code>0</code></li>
<li>The reload value register (<code>SYSTICK_RVR</code>) at offset <code>4</code></li>
<li>The current value register (<code>SYSTICK_CVR</code>) at offset <code>8</code></li>
<li>The calibration register (<code>SYSTICK_CALIB</code>) at offset <code>12</code></li>
</ul>
<p>The<a id="_idIndexMarker396"/> SysTick works <a id="_idIndexMarker397"/>as a countdown timer. It holds a 24-bit value, which is decreased at every CPU clock tick. The timer reloads the same value every time it reaches <code>0</code> and triggers the SysTick interrupt if it is configured to do so.</p>
<p>As a shortcut to access the SysTick registers, we define their locations:</p>
<pre class="source-code">
#define SYSTICK_BASE (0xE000E010)
#define SYSTICK_CSR (*(volatile uint32_t *)(SYSTICK_BASE +
    0x00))
#define SYSTICK_RVR (*(volatile uint32_t *)(SYSTICK_BASE +
    0x04))
#define SYSTICK_CVR (*(volatile uint32_t *)(SYSTICK_BASE +
    0x08))
#define SYSTICK_CALIB (*(volatile uint32_t *)(SYSTICK_BASE
    + 0x0C))</pre>
<p>Since we know the frequency of the CPU in Hz, we can define the system tick interval by setting the value in <a id="_idIndexMarker398"/>the <code>0</code> so that the first interrupt is immediately triggered after we enable the countdown. The SysTick can finally be enabled by configuring the control/status register. The meaning of the least significant three bits of the CSR is as follows:</p>
<ul>
<li><strong class="bold">Bit 0</strong>: Enables<a id="_idIndexMarker399"/> countdown. After this bit is set, the counter in the SysTick timer is automatically decreased at every CPU clock interval.</li>
<li><code>0</code>, a SysTick interrupt will be generated.</li>
<li><strong class="bold">Bit 2</strong>: Source<a id="_idIndexMarker401"/> clock selection. If this bit is reset, an external reference clock is used as the source. The CPU clock is used as the source when this bit is set.</li>
</ul>
<p>We are <a id="_idIndexMarker402"/>going to<a id="_idIndexMarker403"/> define a custom SysTick interrupt handler, so we want to set bit <code>1</code> as well. Because we configured the CPU clock correctly, and we are scaling the system tick interval reload value on that, we also want bit <code>2</code> to be set. The last line of our <code>systick_enable</code> routine will enable the three bits together in the CSR:</p>
<pre class="source-code">
void systick_enable(void) {
  SYSTICK_RVR = ((CPU_FREQ / 1000) - 1);
  SYSTICK_CVR = 0;
  SYSTICK_CSR = (1 &lt;&lt; 0) | (1 &lt;&lt; 1) | (1 &lt;&lt; 2);
}</pre>
<p>The system timer that we have configured is the same as that used by <strong class="bold">real-time operating systems</strong> (<strong class="bold">RTOSs</strong>) to <a id="_idIndexMarker404"/>initiate process switches. In our case, it might be helpful to keep a monotonic system wall clock, measuring the time elapsed since the clock configuration. A minimalist implementation of the interrupt service routine for the system timer could be as follows:</p>
<pre class="source-code">
volatile unsigned int jiffies = 0;
void isr_systick(void)
{
  ++jiffies;
}</pre>
<p>This simple function, and the associated global <code>volatile</code> variable associated, are sufficient to keep track of the time transparently while the application is running. In fact, the system tick interrupt happens independently, at regular intervals, when the <code>jiffies</code> variable is incremented in the interrupt handler, without altering the flow of the main application. What actually happens is that every time the system tick counter reaches <code>0</code>, the execution is suspended, and the interrupt routine quickly executes. When <code>isr_systick</code> returns, the flow of the main application is resumed by restoring exactly the same context of execution stored in memory a moment before the interrupt occurred.</p>
<p>The <a id="_idIndexMarker405"/>reason why <a id="_idIndexMarker406"/>the system timer variable must be defined and declared everywhere as <code>volatile</code> is that its value is supposed to change while executing the application in a way that is independent of the behavior possibly predicted by the compiler for the local context of execution. The <code>volatile</code> keyword in this case ensures that the compiler is forced to produce code that checks the value of the variable every time it is instantiated, by disallowing the use of optimizations based on the false assumption that the variable is not being modified by the local code.</p>
<p>Here is an example main program that uses the previous functions to boot the system, configure the master clock, and enable the SysTick:</p>
<pre class="source-code">
void main(void) {
  flash_set_waitstates();
  clock_config();
  systick_enable();
  while(1) {
    WFI();
  }
}</pre>
<p>The shortcut <a id="_idIndexMarker407"/>for the <strong class="bold">WFI</strong> assembly instruction (short for <strong class="bold">wait for interrupt</strong>) is defined. It is used in the main application to keep the CPU inactive until the next interrupt occurs:</p>
<pre class="source-code">
#define WFI() asm volatile ("wfi")</pre>
<p>To verify that the SysTick is actually running, the program can be executed with the debugger attached and stopped after a while. If the system tick has been configured correctly, the <code>jiffies</code> variable should always be displaying the t<a id="_idTextAnchor211"/>ime in milliseconds elapsed since boot.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor212"/>Generic timers</h1>
<p>Providing a<a id="_idIndexMarker408"/> SysTick timer is not mandatory for low-end microcontrollers. Some targets may not have a system timer, but all of them expose some kind of interface to program several general-purpose timers for the program to be able to implement time-driven operations. Timers in general are very flexible and easy to configure and are generally capable of triggering interrupts at regular intervals. The STM32F4 provides up to 17 timers, each with different characteristics. Timers are in general independent from each other, as each of them has its own interrupt line and a separate peripheral clock gate. On the STM32F4, for example, these are the steps needed to enable the clock source and the interrupt line for timer 2. The timer interface is based on a counter that is incremented or decremented at every tick. The interface exposed on this platform is very flexible and supports several features, including the selection of a different clock source for input, the possibility to concatenate timers, and even the internals of the timer implementation that can be programmed. It is possible to configure the timer to count up or down, and trigger interrupt events on different values of the internal counter. Timers can be one-shot or continuous.</p>
<p>An abstraction of the <code>timer</code> interface can usually be found in support libraries provided by the silicon vendor, or in other open source libraries. However, in order to understand the interface exposed by the microcontroller, the example provided here is once again directly communicating with the peripherals using the configuration registers.</p>
<p>This example mostly uses the default settings for a general-purpose timer on the STM32F407. By default, the counter is increased at every tick, up to its automatic reload value, and continuously generates interrupt events on overflow. A prescaler value can be set to divide the clock source to increase the range of possible intervals. To generate interrupts spread at a constant <a id="_idIndexMarker409"/>given interval, only a few registers need to be accessed:</p>
<ul>
<li>The <strong class="bold">control registers 1</strong> and <strong class="bold">2</strong> (<strong class="bold">CR1</strong> and <strong class="bold">CR2</strong>)</li>
<li>The <strong class="bold">direct memory access (DMA)/Interrupt enable </strong><strong class="bold">register</strong> (<strong class="bold">DIER</strong>)</li>
<li>The <strong class="bold">status </strong><strong class="bold">register</strong> (<strong class="bold">SR</strong>)</li>
<li>The <strong class="bold">prescaler </strong><strong class="bold">counter</strong> (<strong class="bold">PSC</strong>)</li>
<li>The <strong class="bold">auto-reload </strong><strong class="bold">register</strong> (<strong class="bold">ARR</strong>)</li>
</ul>
<p>In general, the<a id="_idIndexMarker410"/> offsets for<a id="_idIndexMarker411"/> these registers are the same for all the timers so that, given the base address, they can be calculated using a macro. In this case, only the register for the timer in use is defined:</p>
<pre class="source-code">
#define TIM2_BASE (0x40000000)
#define TIM2_CR1 (*(volatile uint32_t *)(TIM2_BASE + 0x00))
#define TIM2_DIER (*(volatile uint32_t *)(TIM2_BASE +
    0x0c))
#define TIM2_SR (*(volatile uint32_t *)(TIM2_BASE + 0x10))
#define TIM2_PSC (*(volatile uint32_t *)(TIM2_BASE + 0x28))
#define TIM2_ARR (*(volatile uint32_t *)(TIM2_BASE + 0x2c))</pre>
<p>Also, for readability, we define some relevant bit positions in the registers that we are going to configure:</p>
<pre class="source-code">
#define TIM_DIER_UIE (1 &lt;&lt; 0)
#define TIM_SR_UIF (1 &lt;&lt; 0)
#define TIM_CR1_CLOCK_ENABLE (1 &lt;&lt; 0)
#define TIM_CR1_UPD_RS (1 &lt;&lt; 2)</pre>
<p>First of all, we are going to define a service routine. The <code>timer</code> interface requires us to clear one flag in the status register, to acknowledge the interrupt. In this simple case, all we do is increment a local variable so that we can verify that the <code>timer</code> is being executed by inspecting it in the debugger. We mark the <code>timer2_ticks</code> variable as <code>volatile</code> so that it does not get optimized out by the compiler, since it is never used in the code:</p>
<pre class="source-code">
void isr_tim2(void)
{
  static volatile uint32_t timer2_ticks = 0;
  TIM2_SR &amp;= ~TIM_SR_UIF;
  timer2_ticks++;
}</pre>
<p>The service routine must be associated, by including a pointer to the function in the right position within the interrupt vector defined in <code>startup.c</code>:</p>
<pre class="source-code">
isr_tim2 , // TIM2_IRQ 28</pre>
<p>If the<a id="_idIndexMarker412"/> timer is connected to a different branch in the clock tree, as in this case, we need to account for the additional scaling factor between the clock bus that feeds the timer and the actual CPU clock frequency, while calculating the values for the prescaler and the reload threshold. Timer 2 on STM32F407 is connected to the <strong class="bold">Advanced Peripheral Bus</strong> (<strong class="bold">APB</strong>) bus, which<a id="_idIndexMarker413"/> runs at half of the CPU frequency.</p>
<p>This initialization is an example of a function that automatically calculates <code>TIM2_PSC</code> and <code>TIM2_ARR</code> values and initializes a timer based on the given interval, expressed in milliseconds. The clock variable must be set to the frequency of the clock source for the timer, which may differ from the CPU frequency.</p>
<p>The following definitions are specific to our platform, mapping the address for the clock gating configuration and the interrupt number of the device we want to use:</p>
<pre class="source-code">
#define APB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))
#define APB1_CLOCK_RST (*(volatile uint32_t *)
     (0x40023820))
#define TIM2_APB1_CLOCK_ER_VAL (1 &lt;&lt; 0)
#define NVIC_TIM2_IRQN (28)</pre>
<p>And here is the function to invoke from <code>main</code> to enable a continuous timer interrupt at the desired interval:</p>
<pre class="source-code">
int timer_init(uint32_t clock, uint32_t interval_ms)
{
  uint32_t val = 0;
  uint32_t psc = 1;
  uint32_t err = 0;
  clock = (clock / 1000) * interval_ms;
  while (psc &lt; 65535) {
    val = clock / psc;
    err = clock % psc;
    if ((val &lt; 65535) &amp;&amp; (err == 0)) {
      val--;
      break;
    }
    val = 0;
    psc++;
  }
  if (val == 0)
    return -1;
  nvic_irq_enable(NVIC_TIM2_IRQN);
  nvic_irq_setprio(NVIC_TIM2_IRQN, 0);
  APB1_CLOCK_RST |= TIM2_APB1_CLOCK_ER_VAL;
  DMB();
  TIM2_PSC = psc;
  TIM2_ARR = val;
  TIM2_CR1 |= TIM_CR1_CLOCK_ENABLE;
  TIM2_DIER |= TIM_DIER_UIE;
  DMB();
  return 0;
}</pre>
<p>The <a id="_idIndexMarker414"/>example presented here is only one of the possible applications of system timers. On the reference platform, timers can be used for different purposes, such as measuring intervals between pulses, synchronizing with each other, or activating signals periodically, given a chosen frequency and duty cycle. This last usage will be explained in the <em class="italic">PWM</em> subsection later in this chapter. For all other uses of generic timers on the target, please refer to the reference manual of the microcontroller in use. Now that our system is configured and ready to run, and we have learned how to manage time and generate synchronous events, it is finally time to introduce our first peripherals to start communicating with the outside world. In the next section, we will introduce GPIO lines in their multiple configurations, which allow driving or sen<a id="_idTextAnchor213"/>sing a voltage on single microcontroller pins.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor214"/>GPIO</h1>
<p>The <a id="_idIndexMarker415"/>majority of the pins of a microcontroller chip represent configurable I/O lines. Each pin can be configured to represent a logic level by driving the voltage of the pin as a digital output or to sense the logic state by comparing the voltage as a digital input. Some of the generic pins, though, can be associated with alternate functions, such as analog input, a serial interface, or the output pulse from a timer. Pins may have several possible configurations, but only one is activated at a time. The GPIO controller exposes the configuration of all the pins and manages the association of the pins with the <a id="_idTextAnchor215"/>subsystems when alternate functions are in use.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor216"/>Pin configuration</h2>
<p>Depending <a id="_idIndexMarker416"/>on the logic of the GPIO controller, the pins can be activated all together, separately, or in groups. In order to implement a driver to set up the pins and use them as needed, it is possible to refer to the datasheet of the microcontroller or any example implementation provided by the silicon vendor.</p>
<p>In the case of the STM32F4, GPIO pins are divided into groups. Each group is connected to a separate clock gate, so, to use the pins associated with a group, the clock gate must be enabled. The following code will distribute the clock source to the GPIO controller for the group <code>D</code>:</p>
<pre class="source-code">
#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))
#define GPIOD_AHB1_CLOCK_ER (1 &lt;&lt; 3)
AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;</pre>
<p>The<a id="_idIndexMarker417"/> configuration registers associated with the GPIO controllers are mapped to a specific area in the peripherals region as well. In the case of the <code>GPIOD</code> controller, the base address is at <code>0x40020C00</code>. On the STM32F4 microcontrollers, there are 10 different registers for configuring and using each digital I/O group. As groups are composed of at most 16 pins, some registers may use a representation of 2 bits per pin:</p>
<ul>
<li>Mode register (offset <code>0</code> in the address space) selects the mode (among digital input, digital output, alternate function, or analog input), using 2 bits per pin</li>
<li>Output type register (offset <code>4</code>) selects the output signal driving logic (push-pull or open-drain)</li>
<li>Output speed register (offset <code>8</code>) selects output drive speed</li>
<li>Pull-up register (offset <code>12</code>) enables or disables the internal pull-up or pull-down resistor</li>
<li>Port input data (offset <code>16</code>) is used to read the state of a digital input pin</li>
<li>Port output data (offset <code>20</code>) containing the current value of the digital output</li>
<li>Port bit set/reset (offset <code>24</code>) used to drive a digital output signal high or low</li>
<li>Port configuration lock (offset <code>28</code>)</li>
<li>Alternate function low bit register (offset <code>32</code>), 4 bits per pin, pins 0-7</li>
<li>Alternate function high bit register (offset <code>36</code>), 4 bits per pin, pins 8-15</li>
</ul>
<p>The pin must be configured before use, and the clock gating configured to route the source clock to the controller for the group. The configurations available on this GPIO controller can be <a id="_idTextAnchor217"/>better explained by looking at specific examples.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor218"/>Digital output</h2>
<p>Enabling <a id="_idIndexMarker418"/>a digital output is possible by setting the mode to output in the mode register bits corresponding to the given pin. To be able to control the level of pin D13, which is also connected to an LED on our reference platform, we need to access the following registers:</p>
<pre class="source-code">
#define GPIOD_BASE 0x40020c00
#define GPIOD_MODE (*(volatile uint32_t *)(GPIOD_BASE +
    0x00))
#define GPIOD_OTYPE (*(volatile uint32_t *)(GPIOD_BASE +
    0x04))
#define GPIOD_PUPD (*(volatile uint32_t *)(GPIOD_BASE +
    0x0c))
#define GPIOD_ODR (*(volatile uint32_t *)(GPIOD_BASE +
    0x14))
#define GPIOD_BSRR (*(volatile uint32_t *)(GPIOD_BASE +
    0x18))</pre>
<p>In later examples, alternate functions are used to change the pin assignment. The two registers containing the alternate function settings are shown here:</p>
<pre class="source-code">
#define GPIOD_AFL (*(volatile uint32_t *)(GPIOD_BASE +
    0x20))
#define GPIOD_AFH (*(volatile uint32_t *)(GPIOD_BASE +
    0x24))</pre>
<p>The following simple functions are meant to control the output of pin D15 connected to the blue LED on the STM32F4. The main program must call <code>led_setup</code> before any other function call, in order to configure the pin as output and activate the pull-up/pull-down internal resistor:</p>
<pre class="source-code">
#define LED_PIN (15)
void led_setup(void)
{
  uint32_t mode_reg;</pre>
<p>First, the clock gating is configured to enable the clock source for the <code>GPIOD</code> controller:</p>
<pre class="source-code">
  AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;</pre>
<p>The <a id="_idIndexMarker419"/>mode register is altered to set the mode for GPIO D15 to digital output. The operation is done in two steps. Any previous value set in the 2 bits corresponding to the position of the pin mode within the register is erased:</p>
<pre class="source-code">
   GPIOD_MODE &amp;= ~ (0x03 &lt;&lt; (LED_PIN * 2));</pre>
<p>In the same position, the value <code>1</code> is set, meaning that the pin is now configured as digital output:</p>
<pre class="source-code">
   GPIOD_MODE |= 1 &lt;&lt; (LED_PIN * 2);</pre>
<p>To enable the pull-up and pull-down internal resistors, we do the same. The value to set in this case is <code>2</code>, corresponding to the following:</p>
<pre class="source-code">
   GPIOD_PUPD &amp;= ~(0x03 &lt;&lt; (LED_PIN * 2));
   GPIOD_PUPD |= 0x02 &lt;&lt; (LED_PIN * 2);
}</pre>
<p>After the <code>setup</code> function is invoked, the application and the interrupt handlers can call the functions exported, to set the value of the pin high or low, by acting on the bit set/reset register:</p>
<pre class="source-code">
void led_on(void)
{
  GPIOD_BSRR |= 1 &lt;&lt; LED_PIN;
}</pre>
<p>The highest half of the <code>BSRR</code> is used to reset the pins. Writing <code>1</code> in the reset register bit drives the pin logic level to low:</p>
<pre class="source-code">
void led_off(void)
{
  GPIOD_BSRR |= 1 &lt;&lt; (LED_PIN + 16);
}</pre>
<p>A convenience function is defined, to toggle the LED value from on to off and vice versa:</p>
<pre class="source-code">
void led_toggle(void)
{
  if ((GPIOD_ODR &amp; (1 &lt;&lt; LED_PIN)) == (1 &lt;&lt; LED_PIN))
    led_off();
  else
    led_on();
}</pre>
<p>Using<a id="_idIndexMarker420"/> the <code>timer</code> configured in the previous section, it is possible to run a small program that blinks the blue LED on the STM32F407-Discovery. The <code>led_toggle</code> function can be called from inside the service routine of the <code>timer</code> implemented in the previous section:</p>
<pre class="source-code">
void isr_tim2(void)
{
  TIM2_SR &amp;= ~TIM_SR_UIF;
  led_toggle();
}</pre>
<p>In the main program, the LED driver must be initialized before starting the timer:</p>
<pre class="source-code">
void main(void) {
  flash_set_waitstates();
  clock_config();
  led_setup();
  timer_init(CPU_FREQ, 1, 1000);
  while(1)
  WFI();
}</pre>
<p>The<a id="_idIndexMarker421"/> main loop of the program is empty. The <code>led_to<a id="_idTextAnchor219"/>ggle</code> action is invoked every second to blink the LED.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor220"/>PWM</h2>
<p><strong class="bold">Pulse Width Modulation</strong>, or <strong class="bold">PWM</strong> for brevity, is a commonly used technique to control <a id="_idIndexMarker422"/>different types of actuators, encode<a id="_idIndexMarker423"/> messages into signals with different pulse duration, and, in general, generate pulses with fixed frequency and variable duty cycles on digital output lines for different purposes.</p>
<p>The <code>timer</code> interface may allow associating pins to output a PWM signal. On our reference microcontroller, four output compare channels can be associated with general-purpose timers, and the pins connected to the OC channels may be configured to output the encoded output automatically. On the STM32F407-Discovery board, the blue LED pin PD15, used in the previous example to demonstrate digital output functionality, is associated with the OC4 that can be driven by timer 4. According to the chip documentation, selecting the alternate function 2 for the pin directly connects the output pin to OC4.</p>
<p>The following diagram shows the pin configuration to use alternate function 2 to connect it to the output of the timer:</p>
<div><div><img alt="Figure 6.1 – Configuring pin D15 to use alternate function 2 connects it to the output of the timer" src="img/B18730_06_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Configuring pin D15 to use alternate function 2 connects it to the output of the timer</p>
<p>The <a id="_idIndexMarker424"/>pin is initialized, and set to use the alternate configuration instead of the plain digital output, by clearing the <code>MODE</code> register bits and setting the value to <code>2</code>:</p>
<pre class="source-code">
GPIOD_MODE &amp;= ~ (0x03 &lt;&lt; (LED_PIN * 2));
GPIOD_MODE |= (2 &lt;&lt; (LED_PIN * 2));</pre>
<p>Pins from 0 to 7 in this GPIO group use 4 bits each in the AFL register of the <code>GPIOD</code> controller. Higher pins, in the range 8-15, use 4 bits each in the AFH register. Once the alternate mode is selected, the right alternate function number is programmed into the 4 bits associated with pin 15, so we are using the AFH register in this case:</p>
<pre class="source-code">
uint32_t value;
if (LED_PIN &lt; 8) {
   value = GPIOD_AFL &amp; (~(0xf &lt;&lt; (LED_PIN * 4)));
   GPIOD_AFL = value | (0x2 &lt;&lt; (LED_PIN * 4));
} else {
   value = GPIOD_AFH &amp; (~(0xf &lt;&lt; ((LED_PIN - 8) * 4)));
   GPIOD_AFH = value |(0x2 &lt;&lt; ((LED_PIN - 8) * 4));
}</pre>
<p>The <code>pwm_led_init()</code> function, which <a id="_idIndexMarker425"/>we can call from the main program to configure the LED pin PD15, will look like this:</p>
<pre class="source-code">
void led_pwm_setup(void)
{
  AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;
  GPIOD_MODE &amp;= ~ (0x03 &lt;&lt; (LED_PIN * 2));
  GPIOD_MODE |= (2 &lt;&lt; (LED_PIN * 2));
  GPIOD_OSPD &amp;= ~(0x03 &lt;&lt; (LED_PIN * 2));
  GPIOD_OSPD |= (0x03 &lt;&lt; (LED_PIN * 2));
  GPIOD_PUPD &amp;= ~(0x03 &lt;&lt; (LED_PIN * 2));
  GPIOD_PUPD |= (0x02 &lt;&lt; (LED_PIN * 2));
  GPIOD_AFH &amp;= ~(0xf &lt;&lt; ((LED_PIN - 8) * 4));
  GPIOD_AFH |= (0x2 &lt;&lt; ((LED_PIN - 8) * 4));
}</pre>
<p>The function that sets up the timer for PWM generation is similar to the one used in the simple interrupt-generating timer in the digital output example, except that configuring the timer to output a <a id="_idIndexMarker426"/>PWM involves modifying the value of four additional registers:</p>
<ul>
<li>The <strong class="bold">capture/compare enable </strong><strong class="bold">register</strong> (<strong class="bold">CCER</strong>)</li>
<li>The <strong class="bold">capture/compare mode registers 1</strong> and <strong class="bold">2</strong> (<strong class="bold">CCMR1</strong> and <strong class="bold">CCMR2</strong>)</li>
<li>The <strong class="bold">capture channel 4</strong> (<strong class="bold">CC4</strong>) configuration</li>
</ul>
<p>The signature of the function we will use in the example to configure a PWM with the given duty cycle has the following signature:</p>
<pre class="source-code">
int pwm_init(uint32_t clock, uint32_t dutycycle)
{</pre>
<p>Enabling the clock gate to turn on timer 4 is still required:</p>
<pre class="source-code">
  APB1_CLOCK_RST &amp;= ~TIM4_APB1_CLOCK_ER_VAL;
  APB1_CLOCK_ER |= TIM4_APB1_CLOCK_ER_VAL;</pre>
<p>Both the <a id="_idIndexMarker427"/>timer and its output compare channels are temporarily disabled to start the configuration from a clean slate:</p>
<pre class="source-code">
  TIM4_CCER &amp;= ~TIM_CCER_CC4_ENABLE;
  TIM4_CR1 = 0;
  TIM4_PSC = 0;</pre>
<p>For this example, we can use a fixed PWM frequency of 100 kHz, by setting the automatic reload value to <code>1</code>/<code>100000</code> of the input clock, and enforcing no use of the prescaler:</p>
<pre class="source-code">
  uint32_t val = clock / 100000;</pre>
<p>The duty cycle is calculated according to the value that is passed as a second parameter to <code>pwm_init()</code>, expressed as a percentage. To calculate the corresponding threshold level, this simple formula is used so that, for example, a value of 80 means that the PWM will be active for 4/5 of the time. The resultant value is decremented by one, only if not zero to avoid underflow:</p>
<pre class="source-code">
  lvl = (val * threshold) / 100;
  if (lvl != 0)
    lvl--;</pre>
<p>Comparator value register <code>CCR4</code>, and auto-reload value register <code>ARR</code>, are set accordingly. Also, in this case, the value of ARR is decreased by 1, to account for the zero-based counter:</p>
<pre class="source-code">
  TIM4_ARR = val - 1;
  TIM4_CCR4 = lvl;</pre>
<p>In order to correctly set up a PWM signal on this platform, we first ensure that the portions of the <code>CCMR1</code> register we are going to configure are correctly cleared. This includes the capture selection and the mode configuration:</p>
<pre class="source-code">
  TIM4_CCMR1 &amp;= ~(0x03 &lt;&lt; 0);
  TIM4_CCMR1 &amp;= ~(0x07 &lt;&lt; 4);</pre>
<p>The <code>PWM1</code> mode <a id="_idIndexMarker428"/>selected is just one of the possible alternate configurations that are based on the capture/compare timer. To enable the mode, we set the <code>PWM1</code> value in <code>CCMR2</code>, after clearing the relevant bits of the registers:</p>
<pre class="source-code">
  TIM4_CCMR1 &amp;= ~(0x03 &lt;&lt; 0);
  TIM4_CCMR1 &amp;= ~(0x07 &lt;&lt; 4);
  TIM4_CCMR1 |= TIM_CCMR1_OC1M_PWM1;
  TIM4_CCMR2 &amp;= ~(0x03 &lt;&lt; 8);
  TIM4_CCMR2 &amp;= ~(0x07 &lt;&lt; 12);
  TIM4_CCMR2 |= TIM_CCMR2_OC4M_PWM1;</pre>
<p>Finally, we enable the output comparator OC4. The timer is then set up to automatically reload its stored value every time the counter overflows:</p>
<pre class="source-code">
  TIM4_CCMR2 |= TIM_CCMR2_OC4M_PWM1;
  TIM4_CCER |= TIM_CCER_CC4_ENABLE;
  TIM4_CR1 |= TIM_CR1_CLOCK_ENABLE | TIM_CR1_ARPE;
}</pre>
<p>Using a PWM to drive the voltage applied on the LED modifies its brightness, according to the configured duty cycle. An example program such as the following reduces the brightness of the LED to 50% if compared to that of an LED powered by a constant voltage output, such as the one in the digital output example:</p>
<pre class="source-code">
void main(void) {
  flash_set_waitstates();
  clock_config();
  led_pwm_setup();
  pwm_init(CPU_FREQ, 50);
  while(1)
    WFI();
}</pre>
<p>The <a id="_idIndexMarker429"/>effect of the PWM on the LED brightness can be better visualized by dynamically altering the duty cycle. It is possible, for example, to set up a second timer to generate an interrupt every 50 ms. In the interrupt handler, the duty cycle factor is cycling in the range 0-80% and back, using 16 steps. In the first 8 steps, the duty cycle is increased by 10% at every interrupt, from 0 to 80%, and in the last 8 steps, it is reduced at the same rate, bringing the duty cycle back to <code>0</code>:</p>
<pre class="source-code">
void isr_tim2(void) {
  static uint32_t tim2_ticks = 0;
  TIM2_SR &amp;= ~TIM_SR_UIF;
  if (tim2_ticks &gt; 16)
    tim2_ticks = 0;
  if (tim2_ticks &gt; 8)
    pwm_init(master_clock, 10 * (16 - tim2_ticks));
  else
    pwm_init(master_clock, 10 * tim2_ticks);
  tim2_ticks++;
}</pre>
<p>If we initialize timer 2 in the main program to trigger interrupts spread over constant intervals, as in the previous examples, we can see the LED pulsating, rhythmically fading in and out.</p>
<p>In this case, timer 2 is initialized by the main program, and its associated interrupt handler updates the settings for timer 4, 20 times per second:</p>
<pre class="source-code">
void main(void) {
  flash_set_waitstates();
  clock_config();
  led_pwm_setup();
  pwm_init(CPU_FREQ<a id="_idTextAnchor221"/>, 0);
  timer_init(CPU_FREQ, 1, 50);
  while(1)
    WFI();
}</pre>
<h2 id="_idParaDest-147"><a id="_idTextAnchor222"/>Digital input</h2>
<p>A GPIO pin<a id="_idIndexMarker430"/> configured in input mode detects the logic level of the voltage applied to it. The logic value of all the input pins on a GPIO controller can be read from<a id="_idIndexMarker431"/> the <strong class="bold">input data register</strong> (<strong class="bold">IDR</strong>). On the reference board, pin A0 is connected to the user button, so the status of the button can be read at any time while the application is running.</p>
<p>The <code>GPIOA</code> controller can be turned on by clock gating:</p>
<pre class="source-code">
#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))
#define GPIOA_AHB1_CLOCK_ER (1 &lt;&lt; 0)</pre>
<p>The controller itself is mapped at address <code>0x40020000</code>:</p>
<pre class="source-code">
#define GPIOA_BASE 0x40020000
#define GPIOA_MODE (*(volatile uint32_t *)(GPIOA_BASE +
     0x00))
#define GPIOA_IDR (*(volatile uint32_t *)(GPIOA_BASE +
     0x10))</pre>
<p>To set up the pin for input, we only ensure that the mode is set to <code>0</code>, by clearing the two mode bits relative to pin <code>0</code>:</p>
<pre class="source-code">
#define BUTTON_PIN (0)
void button_setup(void)
{
  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
  GPIOA_MODE &amp;= ~ (0x03 &lt;&lt; (BUTTON_PIN * 2));
}</pre>
<p>The <a id="_idIndexMarker432"/>application can now check the status of the button at any time by reading the lowest bit of the IDR. When the button is pressed, the reference voltage is connected to the pin, and the value of the bit corresponding to the pin changes from <code>0</code> to <code>1</code>:</p>
<pre class="source-code">
int button_is_pressed(vo<a id="_idTextAnchor223"/>id)
{
  return (GPIOA_IDR &amp; (1 &lt;&lt; BUTTON_PIN)) &gt;&gt; BUTTON_PIN;
}</pre>
<h2 id="_idParaDest-148"><a id="_idTextAnchor224"/>Interrupt-based input</h2>
<p>Having <a id="_idIndexMarker433"/>to proactively read the value of a pin by constantly polling the IDR is not convenient in many cases, where the application is supposed to react to state changes. Microcontrollers usually provide mechanisms to connect digital input pins to interrupt lines so that the application can react in real time to events related to the input because the execution is interrupted to execute the associated service routine.</p>
<p>On the <a id="_idIndexMarker434"/>reference <strong class="bold">microcontroller unit</strong> (<strong class="bold">MCU</strong>), pin A0 can be connected to the external interrupt and event controller, also known as <strong class="bold">EXTI</strong>. EXTI <a id="_idIndexMarker435"/>offers edge-detection triggers that can be attached to interrupt lines. The number of the pin within the GPIO group determines the number of the EXTI interrupt that is associated with it so that the EXTI 0 interrupt routine may be connected to pin 0 of any GPIO group if needed:</p>
<div><div><img alt="Figure 6.2 – EXTI0 controller associating edge detection triggers to the user button connected to PA0" src="img/B18730_06_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – EXTI0 controller associating edge detection triggers to the user button connected to PA0</p>
<p>To<a id="_idIndexMarker436"/> associate <code>EXTI_CR</code>) are located at address <code>0x40013808</code>. Each register is used to set the interrupt controller associated with an EXTI line. The lowest four bits of the first register are relative to EXTI line 0. The number for the GPIO group A is 0, so we need to ensure that the corresponding bits are cleared in the first <code>EXTI_CR</code> register. The goal of the next example is to demonstrate how to enable the <code>EXTI_CR</code> register to set the GPIO group A:</p>
<pre class="source-code">
#define EXTI_CR_BASE (0x40013808)
#define EXTI_CR0 (*(volatile uint32_t *)(EXTI_CR_BASE +
    0x00))
#define EXTI_CR_EXTI0_MASK (0x0F)</pre>
<p>The <code>EXTI0</code> interrupt is connected to NVIC line number <code>6</code>, so we add this definition to configure the NVIC:</p>
<pre class="source-code">
#define NVIC_EXTI0_IRQN (6)</pre>
<p>The <a id="_idIndexMarker437"/>EXTI controller in STM32F4 microcontrollers is located at address <code>0x40013C00</code>, and provides the following registers:</p>
<ul>
<li><code>0</code>. Sets/clears the corresponding bit to enable/disable the interrupt for each of the EXTI lines.</li>
<li><code>4</code>. Sets/clears the corresponding bit to enable/disable the event trigger for the corresponding EXTI line.</li>
<li><code>8</code>. Sets the corresponding bit to <a id="_idIndexMarker440"/>generate events and interrupts when the associated digital input level switches from 0 to 1.</li>
<li><code>12</code>. Sets the corresponding bit to <a id="_idIndexMarker441"/>generate events and interrupts when the associated signal falls from a logic value of <code>1</code> back to <code>0</code>.</li>
<li><code>16</code>. If a bit is set in this register, the <a id="_idIndexMarker442"/>associated interrupt event will be immediately generated, and the service routine executed. This mechanism can be used to implement custom software interrupts.</li>
<li><code>20</code>. To clear a pending interrupt, the<a id="_idIndexMarker443"/> service routine should set the bit corresponding to the EXTI line, or the interrupt will remain pending. A new service routine will be spawned until the PR bit for the EXTI line is cleared.</li>
</ul>
<p>For convenience, we may define the registers as follows:</p>
<pre class="source-code">
#define EXTI_BASE (0x40013C00)
#define EXTI_IMR (*(volatile uint32_t *)(EXTI_BASE + 0x00))
#define EXTI_EMR (*(volatile uint32_t *)(EXTI_BASE + 0x04))
#define EXTI_RTSR (*(volatile uint32_t *)(EXTI_BASE +
    0x08))
#define EXTI_FTSR (*(volatile uint32_t *)(EXTI_BASE +
    0x0c))
#define EXTI_SWIER (*(volatile uint32_t *)(EXTI_BASE +
    0x10))
#define EXTI_PR (*(volatile uint32_t *)(EXTI_BASE + 0x14))</pre>
<p>The <a id="_idIndexMarker444"/>procedure to enable the interrupt on the rising edge of PA0, associated with the button press, is the following:</p>
<pre class="source-code">
void button_setup(void)
{
  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
  GPIOA_MODE &amp;= ~ (0x03 &lt;&lt; (BUTTON_PIN * 2));
  EXTI_CR0 &amp;= ~EXTI_CR_EXTI0_MASK;
  nvic_irq_enable(NVIC_EXTI0_IRQN);
  EXTI_IMR |= 1 &lt;&lt; BUTTON_PIN;
  EXTI_EMR |= 1 &lt;&lt; BUTTON_PIN;
  EXTI_RTSR |= 1 &lt;&lt; BUTTON_PIN;
}</pre>
<p>The ISR, IMR, and RTSR corresponding bits have been set, and the interrupt has been enabled in the NVIC. Instead of polling for the value of the digital input to change, we can now define a service routine that will be invoked every time the button is pressed:</p>
<pre class="source-code">
volatile uint32_t button_presses = 0;
void isr_exti0(void)
{
  EXTI_PR |= 1 &lt;&lt; BUTTON_PIN;
  button_presses++;
}</pre>
<p>In this simple example, the <code>button_presses</code> counter is expected to increase by one at every <a id="_idIndexMarker445"/>button press event. In a real-life scenario, buttons based on mechanical contact (such as the one on the STM32F407-Discovery) are tricky to control using this mechanism. A single physical button press may in fact trigger the rising front interrupt multiple times during the transitory phase. This phenomenon, known as a button bouncing effect, can be <a id="_idTextAnchor225"/>mitigated using specific <em class="italic">debounce</em> techniques, which are not discussed here.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor226"/>Analog input</h2>
<p>Some pins <a id="_idIndexMarker446"/>have the possibility to measure the applied voltage dynamically and assign a discrete number to the measured value, using an <strong class="bold">analog-to-digital signal converter</strong>, or <strong class="bold">ADC</strong>. This<a id="_idIndexMarker447"/> is very useful to acquire data from a wide range of sensors, capable of conveying the information as output voltage or simply using a variable resistor.</p>
<p>The configuration of the ADC subsystem may vary significantly across different platforms. ADCs on modern microcontrollers offer a wide range of configuration options. The reference microcontroller equips 3 separate ADC controllers, sharing 16 input channels, each one with a resolution of 12 bits. Multiple features are available, such as DMA transfer of the acquired data, and monitoring the signals in between two watchdog thresholds.</p>
<p>ADC controllers are generally designed to automatically sample input values multiple times per second and provide stable results that are immediately available. The case we analyze here is simpler and consists of a one-shot read operation for a single conversion.</p>
<p>Associating a specific pin to a controller is possible by checking how channels are mapped on the controllers if the pin supports it and it is connected through a channel to one of the configured as analog input and reading out the value, which results from the conversion of the analog signal. In this example, pin B1 is used as analog input and can be connected to the <code>ADB1</code> controller through channel <code>9</code>. The following constants and registers are defined for the configuration of the <code>ADB1</code> controller:</p>
<pre class="source-code">
#define APB2_CLOCK_ER (*(volatile uint32_t *)(0x40023844))
#define ADC1_APB2_CLOCK_ER_VAL (1 &lt;&lt; 8)
#define ADC1_BASE (0x40012000)
#define ADC1_SR (*(volatile uint32_t *)(ADC1_BASE + 0x00))
#define ADC1_CR1 (*(volatile uint32_t *)(ADC1_BASE +
     0x04))
#define ADC1_CR2 (*(volatile uint32_t *)(ADC1_BASE +
     0x08))
#define ADC1_SMPR1 (*(volatile uint32_t *)(ADC1_BASE +
     0x0c))
#define ADC1_SMPR2 (*(volatile uint32_t *)(ADC1_BASE +
     0x10))
#define ADC1_SQR3 (*(volatile uint32_t *)(ADC1_BASE +
     0x34))
#define ADC1_DR (*(volatile uint32_t *)(ADC1_BASE + 0x4c))
#define ADC_CR1_SCAN (1 &lt;&lt; 8)
#define ADC_CR2_EN (1 &lt;&lt; 0)
#define ADC_CR2_CONT (1 &lt;&lt; 1)
#define ADC_CR2_SWSTART (1 &lt;&lt; 30)
#define ADC_SR_EOC (1 &lt;&lt; 1)
#define ADC_SMPR_SMP_480CYC (0x7)</pre>
<p>These are <a id="_idIndexMarker448"/>the definitions to configure GPIO as usual, this time mapped for <code>GPIOB</code>:</p>
<pre class="source-code">
#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))
#define GPIOB_AHB1_CLOCK_ER (1 &lt;&lt; 1)
#define GPIOB_BASE (0x40020400)
#define GPIOB_MODE (*(volatile uint32_t *)(GPIOB_BASE +
     0x00))
#define ADC_PIN (1)
#define ADC_PIN_CHANNEL (9)</pre>
<p>The <a id="_idIndexMarker449"/>three ADCs share a few registers for common settings, such as the clock prescale factor, so they will all operate at the same frequency. The prescale factor for the ADC must be set within the working range of the converter recommended by the datasheet—in the target platform, halving the frequency of the <code>APB2</code> clock through the common prescaler. The common ADC configuration registers start at port <code>0x40012300</code>:</p>
<pre class="source-code">
#define ADC_COM_BASE (0x40012300)
#define ADC_COM_CCR (*(volatile uint32_t *)(ADC_COM_BASE +
    0x04))</pre>
<p>Based on these definitions, the initialization function can be written as follows. First, we enable the clock gating for both the ADC controller and the GPIO group:</p>
<pre class="source-code">
int adc_init(void)
{
  APB2_CLOCK_ER |= ADC1_APB2_CLOCK_ER_VAL;
  AHB1_CLOCK_ER |= GPIOB_AHB1_CLOCK_ER;</pre>
<p>PB1 is set to analog input mode, corresponding to the value <code>3</code> in the mode register:</p>
<pre class="source-code">
  GPIOB_MODE |= 0x03 &lt;&lt; (ADC_PIN * 2);</pre>
<p><code>ADC1</code> is temporarily switched off to set the desired configuration. The common clock prescaler is set to <code>0</code>, meaning a divisor of 2 from the input clock. This ensures that the frequency fed to the ADC controller is within its operational range. Scan mode is disabled, and so is continuous mode, as we are not using these features in this example:</p>
<pre class="source-code">
  ADC1_CR2 &amp;= ~(ADC_CR2_EN);
  ADC_COM_CCR &amp;= ~(0x03 &lt;&lt; 16);
  ADC1_CR1 &amp;= ~(ADC_CR1_SCAN);
  ADC1_CR2 &amp;= ~(ADC_CR2_CONT);</pre>
<p>The sampling frequency can be set using the two registers <code>SMPR1</code> and <code>SMPR2</code>, depending on the channel in use. Each register represents one channel sample rate using 3 bits per register, so the channels <code>0</code> to <code>9</code> are configurable using <code>SMPR1</code>, and all the others through <code>SMPR2</code>. The channel for PB1 is set to <code>9</code>, so in this case, the <code>SMPR1</code> register<a id="_idIndexMarker450"/> is used, but to remind about this, the generic mechanism to set the sample rate on any channel is provided:</p>
<pre class="source-code">
  if (ADC_PIN_CHANNEL &gt; 9) {
    uint32_t val = ADC1_SMPR2;
    val = ADC_SMPR_SMP_480CYC &lt;&lt; ((ADC_PIN_CHANNEL - 10) *
    3);
    ADC1_SMPR2 = val;
  } else {
    uint32_t val = ADC1_SMPR1;
    val = ADC_SMPR_SMP_480CYC &lt;&lt; (ADC_PIN_CHANNEL * 3);
    ADC1_SMPR1 = val;
  }</pre>
<p>Finally, the channel is enabled in the conversion sequence of the ADC controller using the <code>SQR3</code> to <code>SQR1</code>. Each source channel is represented in five bits, so each register contains up to six sources, except <code>SQR1</code>, which stores five, and reserves the higher bits to indicate the length of the stack stored in the registers, minus one. In our case, there is no need to set the length-minus-one field, as it would be zero for a single source in <code>SQR1</code>:</p>
<pre class="source-code">
  ADC1_SQR3 |= (ADC_PIN_CHANNEL);</pre>
<p>Finally, the <code>ADC1</code> analog converter is enabled again by setting the enable bit in the <code>CR2</code> control register and the initialization function successfully returns:</p>
<pre class="source-code">
  ADC1_CR2 |= ADC_CR2_EN;
  return 0;
}</pre>
<p>After the ADC has been initialized and configured to convert the analog signal on PB1, the A/D conversion can be started at any time. A simple blocking read function would initiate the<a id="_idIndexMarker452"/> conversion, wait for the conversion to be successfully started, then wait until the conversion is completed by looking at the <strong class="bold">end of conversion</strong> (<strong class="bold">EOC</strong>) bit<a id="_idIndexMarker453"/> in the status register:</p>
<pre class="source-code">
int adc_read(void)
{
  ADC1_CR2 |= ADC_CR2_SWSTART;
  while (ADC1_CR2 &amp; ADC_CR2_SWSTART)
    ;
  while ((ADC1_SR &amp; ADC_SR_EOC) == 0)
    ;</pre>
<p>When the conversion is completed, the corresponding discrete value is available on the lowest 12 bits of the data register, and can be returned to the caller:</p>
<pre class="source-code">
  return (int)(ADC1_DR);
}</pre>
<p>We have learned how to communicate with the outside world using GPIOs. The same GPIO setup and management interface will be useful again in the next chapter to configure more complex, local bus interfaces, using the alternate functions for the associated GPIO lines.</p>
<p>The upcoming section introduces the watchdog, the last of the generic system features analyzed in this chapter. Commonly present in several microcontrollers, it provides a handy emergency recovery procedure whenever, for any reason, the system is frozen and will not resume its normal execution.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor227"/>The watchdog</h1>
<p>A common <a id="_idIndexMarker454"/>feature in many microcontrollers is the presence of a watchdog timer. A watchdog ensures that the system is not stuck within an endless loop or any other blocking situation within the code. This is particularly useful in bare-metal applications that rely on an event-driven loop, where calls are required not to block, and to return to the main event loop within the allowed amount of time.</p>
<p>The watchdog must be seen as the very last resort to recover an unresponsive system, by triggering a forced reboot regardless of the current state of execution in the CPU.</p>
<p>The reference platform provides one independent watchdog timer, with a counter similar to those of the generic timers, with a 12-bit granularity and a prescaler factor. The prescaler of the watchdog, however, is expressed in multiples of 2 and has a range between 4 (represented by the value 0) and 256 (value 6).</p>
<p>The clock source is connected to a lower-speed oscillator, through an independent branch of the clock distribution. For this reason, clock gating is not involved in the activation of this peripheral.</p>
<p>The watchdog configuration area is mapped within the peripherals address region, and consists of four registers:</p>
<ul>
<li>The <a id="_idIndexMarker455"/>key register (offset <code>0</code>), used to trigger the three unlock, start, and reset operations by writing predefined values in the lowest 16 bits</li>
<li>The <a id="_idIndexMarker456"/>prescale register (offset <code>4</code>), to set the prescale factor of the counter</li>
<li>The <a id="_idIndexMarker457"/>reload register (offset <code>8</code>), containing the reload value for the counter</li>
<li>The <a id="_idIndexMarker458"/>status register (offset <code>12</code>), providing the status flags to synchronize the setup operations</li>
</ul>
<p>The registers can be referenced using shortcut macros:</p>
<pre class="source-code">
#define IWDG_BASE (0x40003000)
#define IWDG_KR (*(volatile uint32_t *)(IWDG_BASE + 0x00))
#define IWDG_PR (*(volatile uint32_t *)(IWDG_BASE + 0x04))
#define IWDG_RLR (*(volatile uint32_t *)(IWDG_BASE + 0x08))
#define IWDG_SR (*(volatile uint32_t *)(IWDG_BASE + 0x0c))</pre>
<p>The three possible operations that can be triggered via the key register are as follows:</p>
<pre class="source-code">
#define IWDG_KR_RESET 0x0000AAAA
#define IWDG_KR_UNLOCK 0x00005555
#define IWDG_KR_START 0x0000CCCC</pre>
<p>Two <a id="_idIndexMarker459"/>meaningful status bits are provided in the status, and they must be checked to ensure that the watchdog is not busy before unlocking and setting the value for prescale and reload:</p>
<pre class="source-code">
#define IWDG_SR_RVU (1 &lt;&lt; 1)
#define IWDG_SR_PVU (1 &lt;&lt; 0)</pre>
<p>The initialization function to configure and start the watchdog may look like the following:</p>
<pre class="source-code">
int iwdt_init(uint32_t interval_ms)
{
   uint32_t pre = 0;
   uint32_t counter;</pre>
<p>In the next line, the input value in milliseconds is scaled to the frequency of the watchdog clock, which is 32 kHz:</p>
<pre class="source-code">
   counter = interval_ms &lt;&lt; 5;</pre>
<p>The minimum prescaler factor is 4, however, so the value should be divided again. We then look for the minimum prescaler value that results in a counter that fits the 12 bits available, by halving the counter value and increasing the prescaler factor until the counter is appropriately scaled:</p>
<pre class="source-code">
   counter &gt;&gt;= 2;
   while (counter &gt; 0xFFF) {
     pre++;
     counter &gt;&gt;= 1;
   }</pre>
<p>The following checks ensure that the interval provided does not result in a zero counter or a value that is too large for the available scaling factor:</p>
<pre class="source-code">
   if (counter == 0)
     counter = 1;
   if (pre &gt; 6)
     return -1;</pre>
<p>The <a id="_idIndexMarker460"/>actual initialization of the registers is done, but the device requires us to initiate the write with an unlock operation, and only after checking that the registers are available for writing:</p>
<pre class="source-code">
   while(IWDG_SR &amp; IWDG_SR_PR_BUSY);
   IWDG_KR = IWDG_KR_UNLOCK;
   IWDG_PR = pre;
   while (IWDG_SR &amp; IWDG_SR_RLR_BUSY);
   IWDG_KR = IWDG_KR_UNLOCK;
   IWDG_RLR = counter;</pre>
<p>Starting the watchdog simply consists of setting the <code>START</code> command in the key register to initiate the start operation:</p>
<pre class="source-code">
   IWDG_KR = IWDG_KR_START;
   return 0;
}</pre>
<p>Once started, the watchdog cannot be stopped and will run forever, decreasing the counter until it reaches zero, and rebooting the system.</p>
<p>The only way to prevent the system from being rebooted is resetting the timer manually, an operation often referred to as <em class="italic">kicking the watchdog</em>. A watchdog driver should export a function that allows the application to reset the counter—for example, at the end of each iteration in the main loop. Here is ours:</p>
<pre class="source-code">
void iwdt_reset(void)
{
   IWDG_KR = IWDG_KR_RESET;
}</pre>
<p>As a simple test for the watchdog driver, a watchdog counter of 2 seconds can be initialized in <code>main()</code>:</p>
<pre class="source-code">
void main(void) {
  flash_set_waitstates();
  clock_config();
  button_setup();
  iwdt_init(2000);
  while(1)
    WFI();
}</pre>
<p>The <a id="_idIndexMarker461"/>watchdog is reset upon button press, in the interrupt service routine of the GPIO button:</p>
<pre class="source-code">
void isr_exti0(void)
{
  EXTI_PR |= (1 &lt;&lt; BUTTON_PIN);
  iwdt_reset();
}</pre>
<p>In this test, the system will reboot if the user button is not pressed for 2 seconds<a id="_idTextAnchor228"/> in a row, so the only way to keep the system running is by repeatedly pressing the button.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor229"/>Summary</h1>
<p>The clock configuration, timers, and I/O lines are the general-purpose peripherals shown in this chapter, commonly supported by a wide range of microcontrollers. Although implementation details such as register names and placement may differ on other targets, the proposed approach is valid on most embedded platforms, and the general-purpose peripherals are the bricks for building the most basic system functionalities as well as providing a means of interaction with sensors and actuators.</p>
<p>In the next chapter, we will focus on serial communication channels provided by most microprocessors as communication interfaces toward other devices, and peripherals in the proximity of the target system.</p>
</div>
</body></html>