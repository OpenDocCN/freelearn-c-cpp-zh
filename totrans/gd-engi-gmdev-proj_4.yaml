- en: Space Rocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 太空岩石
- en: By now, you should be getting more comfortable with working in Godot; adding
    nodes, creating scripts, modifying properties in the Inspector, and so on. As
    you progress through this book, you won't be forced to rehash the basics again
    and again. If you find yourself stuck, or feeling like you don't quite remember
    how something is done, feel free to jump back to a previous project where it was
    explained in more detail. As you repeat the more common actions in Godot, they
    will start to feel more and more familiar. At the same time, each chapter will
    introduce you to more nodes and techniques to expand your understanding of Godot's
    features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经对在Godot中工作感到更加得心应手；添加节点、创建脚本、在检查器中修改属性等等。随着您通过这本书的进展，您将不必反复重温基础知识。如果您发现自己遇到了困难，或者感觉不太记得如何做某事，请随时回到之前的项目中，那里有更详细的解释。随着您在Godot中重复执行更常见的操作，它们将变得越来越熟悉。同时，每一章都将向您介绍更多节点和技术，以扩展您对Godot功能的理解。
- en: 'In this next project, you''ll make a space shooter game similar to the arcade
    classic Asteroids. The player will control a ship that can rotate and move in
    any direction. The goal will be to avoid the floating *space rocks* and shoot
    them with the ship''s laser. Refer to the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，您将制作一个类似于街机经典游戏《小行星》的空间射击游戏。玩家将控制一艘可以旋转和向任何方向移动的飞船。目标将是避开漂浮的*太空岩石*并用飞船的激光射击它们。请参考以下截图：
- en: '![](img/3453005f-0741-4889-a4a9-4bbd9b686608.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/3453005f-0741-4889-a4a9-4bbd9b686608.png)'
- en: 'You will learn about the following key topics in this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将学习以下关键主题：
- en: Physics using `RigidBody2D`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RigidBody2D`的物理
- en: Finite State Machines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限状态机
- en: Building a dynamic, scalable UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建动态、可扩展的用户界面
- en: Sound and music
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频和音乐
- en: Particle effects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子效果
- en: Project setup
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Create a new project and download the project assets from [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并从[https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)下载项目资源。
- en: For this project, you'll set up custom input actions using the Input Map. Using
    this feature, you can define custom events and assign different keys, mouse events,
    or other inputs to them. This allows for more flexibility in designing your game,
    as your code can be written to respond to the `jump` input, for example, without
    needing to know exactly what input the user pressed to make the event happen.
    This allows you to make the same code work on different devices, even if they
    have different hardware. In addition, since many gamers expect to be able to customize
    a game's inputs, this enables you to provide that option to the user as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，您将使用输入映射来设置自定义输入操作。使用此功能，您可以定义自定义事件并将不同的键、鼠标事件或其他输入分配给它们。这使您在游戏设计上具有更大的灵活性，因为您的代码可以编写为响应例如`jump`输入，而无需确切知道用户按下了什么输入来触发事件。这允许您使相同的代码在不同的设备上工作，即使它们具有不同的硬件。此外，由于许多玩家期望能够自定义游戏的输入，这也使您能够为用户提供此选项。
- en: To set up the inputs for this game, open Project | Project Settings and select
    the Input Map tab.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个游戏的输入，请打开项目 | 项目设置并选择输入映射选项卡。
- en: 'You''ll need to create four new input actions: `rotate_left`, `rotate_right`,
    `thrust`, and `shoot`. Type the name of each action into the Action box and click
    Add. Then, for each action, click the + button and select the type of input to
    assign. For example, to allow the player to use both the arrow keys and the popular
    WASD alternative, the setup will look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建四个新的输入操作：`rotate_left`、`rotate_right`、`thrust`和`shoot`。将每个操作的名称输入到动作框中，然后点击添加。然后，对于每个操作，点击+按钮并选择要分配的输入类型。例如，为了允许玩家使用箭头键和流行的WASD替代方案，设置将如下所示：
- en: '![](img/e5e3ffae-1a9a-4712-b868-9c454b19d6cd.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e5e3ffae-1a9a-4712-b868-9c454b19d6cd.png)'
- en: 'If you have a gamepad or other controller connected to your computer, you can
    also add its inputs to the actions in the same way. Note: we''re only considering
    button-style inputs at this stage, so while you''ll be able to use a d-pad for
    this project, using an analog joystick would require changes to the project''s
    code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机连接了游戏手柄或其他控制器，您也可以以相同的方式将它的输入添加到操作中。注意：我们目前只考虑按钮式输入，因此虽然您可以使用这个项目中的十字键，但使用模拟摇杆将需要修改项目的代码。
- en: Rigid body physics
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚体物理
- en: In game development, you often need to know when two objects in the game space
    intersect or come into contact. This is known as *collision detection*. When a
    collision is detected, you typically want something to happen. This is known as *collision
    response*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，你经常需要知道游戏空间中的两个物体何时相交或接触。这被称为*碰撞检测*。当检测到碰撞时，你通常希望发生某些事情。这被称为*碰撞响应*。
- en: 'Godot offers three kinds of physics bodies, grouped under the `PhysicsBody2D`
    object type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Godot提供了三种类型的物理体，这些类型被归类在`PhysicsBody2D`对象类型下：
- en: '`StaticBody2D`: A static body is one that is not moved by the physics engine.
    It participates in collision detection, but does not move in response to the collision.
    This type of body is most often used for objects that are part of the environment
    or do not need to have any dynamic behavior, such as walls or the ground.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StaticBody2D`：静态体是物理引擎不会移动的物体。它参与碰撞检测，但不会因碰撞而移动。这种类型的物体通常用于环境中的物体或不需要任何动态行为的物体，例如墙壁或地面。'
- en: '`RigidBody2D`: This is the physics body in Godot that provides simulated physics.
    This means that you don''t control a `RigidBody2D` directly. Instead, you apply
    forces to it (gravity, impulses, and so on) and Godot''s built-in physics engine
    calculates the resultant movement, including collisions, bouncing, rotating, and
    other effects.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RigidBody2D`：这是Godot中提供模拟物理的物理体。这意味着你不会直接控制`RigidBody2D`。相反，你对其施加力（重力、冲量等），然后Godot的内置物理引擎计算结果运动，包括碰撞、弹跳、旋转和其他效果。'
- en: '`KinematicBody2D`: This body type provides collision detection, but no physics.
    All movement must be implemented in code, and you must implement any collision
    response yourself. Kinematic bodies are most often used for player characters
    or other actors that require *arcade-style* physics rather than realistic simulation.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KinematicBody2D`：这种物理体类型提供碰撞检测，但没有物理效果。所有运动都必须通过代码实现，你必须自己实现任何碰撞响应。运动学体通常用于需要*街机风格*物理而不是真实模拟的玩家角色或其他演员。'
- en: Understanding when to use a particular physics body type is a big part of building
    your game. Using the right node can simplify your development, while trying to
    force the wrong node to do the job can lead to frustration and poor results. As
    you work with each type of body, you'll come to learn their pros and cons and
    get a feel for when they can help build what you need.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时使用特定的物理体类型是构建游戏的重要组成部分。使用正确的节点可以简化你的开发过程，而试图强迫错误的节点完成工作可能会导致挫败感和不良结果。随着你与每种类型的物理体一起工作，你会逐渐了解它们的优缺点，并学会何时它们可以帮助构建你所需要的内容。
- en: In this project, you'll be using the `RigidBody2D` node for the player ship
    as well as the *space rocks* themselves. You'll learn about the other body types
    in later chapters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用`RigidBody2D`节点来控制玩家飞船以及*太空岩石*本身。你将在后面的章节中了解其他物理体类型。
- en: 'Individual `RigidBody2D` nodes have many properties you can use to customize
    their behavior, such as `Mass`, `Friction`, or `Bounce`. These properties can
    be set in the Inspector:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单个`RigidBody2D`节点有许多你可以用来自定义其行为的属性，例如`质量`、`摩擦`或`弹跳`。这些属性可以在检查器中设置：
- en: '![](img/4cc35f3b-a174-4d0a-960d-efeb1d86e285.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cc35f3b-a174-4d0a-960d-efeb1d86e285.png)'
- en: 'Rigid bodies are also affected by the world''s properties, which can be set
    in the Project Settings under Physics | 2D. These settings apply to all bodies
    in the world. Refer to the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体也受到世界属性的影响，这些属性可以在项目设置下的物理 | 2D 中设置。这些设置适用于世界中的所有物理体。请参考以下截图：
- en: '![](img/ef7f76ba-33f1-4c83-8317-d838b5d6e35a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef7f76ba-33f1-4c83-8317-d838b5d6e35a.png)'
- en: In most cases, you won't need to modify these settings. However, note that by
    default, gravity has a value of `98` and a direction of `(0, 1)` (downward). If
    you want to change the world gravity, you can do that here. You should also be
    aware of the last two properties, Default Linear Damp and Default Angular Damp.
    These properties control how quickly a body will lose forward speed and rotation
    speed, respectively. Setting them to lower values will make the world feel frictionless,
    while using larger values will feel like your objects are moving through mud.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要修改这些设置。然而，请注意，默认情况下，重力值为`98`，方向为`(0, 1)`（向下）。如果你想更改世界重力，你可以在这里进行更改。你还应该注意最后两个属性，默认线性阻尼和默认角阻尼。这些属性分别控制物体失去前进速度和旋转速度的快慢。将它们设置为较低的值会使世界感觉没有摩擦，而使用较大的值则感觉你的物体像是在泥中移动。
- en: '`Area2D` nodes can also be used to affect rigid body physics by using the Space
    Override property. Custom gravity and damping values will then be applied to any
    bodies that enter the area.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用空间覆盖属性来使用 `Area2D` 节点影响刚体物理。然后，将自定义的重力和阻尼值应用于进入该区域的任何物体。
- en: Since this game will be taking place in outer space, gravity won't be needed,
    so set Default Gravity to `0`. You can leave the other settings as they are.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个游戏将在外太空进行，因此不需要重力，所以将默认重力设置为 `0`。你可以保留其他设置不变。
- en: Player ship
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家飞船
- en: The player ship is the heart of the game. Most of the code you'll write for
    this project will be about making the ship work. It will be controlled in the
    classic Asteroids style, with left/right rotation and forward thrust. It will
    also detect the shoot input to allow the player to fire the laser and destroy
    the floating rocks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家飞船是游戏的核心。你将为这个项目编写的绝大部分代码都将关于使飞船工作。它将以经典的 Asteroids 风格进行控制，具有左右旋转和前进推进。它还将检测射击输入，允许玩家发射激光并摧毁漂浮的岩石。
- en: Body setup and physics
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身体设置和物理
- en: Create a new scene and add a `RigidBody2D` named `Player` as the root node,
    with `Sprite` and `CollisionShape2D` children. Add the `res://assets/player_ship.png`
    image to the Texture property of the `Sprite`. The ship image is quite large,
    so set the Scale property of the `Sprite` to `(0.5, 0.5)`and its Rotation to `90`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并将名为 `Player` 的 `RigidBody2D` 作为根节点添加，带有 `Sprite` 和 `CollisionShape2D`
    子节点。将 `res://assets/player_ship.png` 图像添加到 `Sprite` 的纹理属性中。飞船图像相当大，因此将 `Sprite`
    的缩放属性设置为 `(0.5, 0.5)`，并将其旋转设置为 `90`。
- en: The image for the ship is drawn pointing upwards. In Godot, a rotation of `0`
    degrees points to the right (along the *x* axis). This means you need to set the
    Rotation of the `Sprite` node to `90` so it will match the body's direction.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 船的图像是向上绘制的。在 Godot 中，`0` 度的旋转指向右侧（沿 *x* 轴）。这意味着你需要将 `Sprite` 节点的旋转设置为 `90`，以便与身体的朝向相匹配。
- en: 'In the Shape property of `CollisionShape2D`, add a `CircleShape2D` and scale
    it to cover the image as closely as possible (remember not to move the rectangular
    size handles):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CollisionShape2D` 的形状属性中添加一个 `CircleShape2D`，并将其缩放以尽可能紧密地覆盖图像（记住不要移动矩形大小手柄）：
- en: '![](img/77ab9da2-81c0-42d8-88cd-bfffa8e3d585.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![玩家飞船](img/77ab9da2-81c0-42d8-88cd-bfffa8e3d585.png)'
- en: Save the scene. When working on larger-scale projects, it is recommended to
    organize your scenes and scripts into folders based on each game object. For example,
    if you make a `player` folder, you can save player-related files there. This makes
    it easier to find and modify your files rather than having them all together in
    a single folder. While this project is relatively small, it's a good habit to
    adopt as your projects grow in size and complexity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景。在处理更大规模的项目时，建议根据每个游戏对象组织场景和脚本到文件夹中。例如，如果你创建一个 `player` 文件夹，你可以将玩家相关的文件保存在那里。这样，与将所有文件都放在一个文件夹中相比，更容易找到和修改你的文件。虽然这个项目相对较小，但随着项目规模和复杂性的增长，这是一个好习惯。
- en: State machines
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态机
- en: The player ship can be in a number of different states during gameplay. For
    example, when *alive,* the ship is visible and can be controlled by the player,
    but is vulnerable to being hit by rocks. On the other hand, when *invulnerable, *the
    ship should appear semi-transparent and immune to damage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏过程中，玩家飞船可以处于多种不同的状态。例如，当 *存活* 时，飞船是可见的，并且可以被玩家控制，但容易受到岩石的撞击。另一方面，当 *无敌* 时，飞船应该呈现半透明状态，并对伤害免疫。
- en: One way that programmers often handle situations like this is to add Boolean
    flag variables to the code. For example, the `invulnerable` flag is set to `true` when
    the player spawns, or when the `alive` flag is set to `false` when the player
    is dead. However, this can lead to errors and strange situations where both the
    `alive` and `invulnerable` flags are set to `true` at the same time. What happens
    when a rock hits the player in this situation? The two states are mutually exclusive,
    so this shouldn't be allowed to happen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常处理此类情况的一种方法是在代码中添加布尔标志变量。例如，当玩家生成时，将 `invulnerable` 标志设置为 `true`，或者当玩家死亡时，将
    `alive` 标志设置为 `false`。然而，这可能导致错误和奇怪的情况，即 `alive` 和 `invulnerable` 标志同时被设置为 `true`。在这种情况下，如果一块岩石撞击玩家，会发生什么？这两个状态是互斥的，因此不应该允许这种情况发生。
- en: One solution to this problem is to use a **Finite State Machine** (**FSM**).
    When using an FSM, an entity can only be in one state at a given time. To design
    your FSM, you define some number of states and what events or actions can cause
    a transition from one state to another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用**有限状态机**（**FSM**）。当使用FSM时，实体在给定时间只能处于一个状态。为了设计您的FSM，您定义一些状态以及什么事件或动作可以导致从一个状态转换到另一个状态。
- en: 'The following diagram outlines the FSM for the player ship:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图概述了玩家飞船的FSM：
- en: '![](img/1d5ed158-4b96-4c18-9a64-c488e2257e63.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d5ed158-4b96-4c18-9a64-c488e2257e63.png)'
- en: There are four states, and the arrows indicate what transitions are allowed,
    as well as what event triggers the transition. By checking the current state,
    you can decide what the player is allowed to do. For example, in the **DEAD**
    state, don't allow input, or in the **INVULNERABLE** state, don't allow shooting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种状态，箭头表示允许的转换以及触发转换的事件。通过检查当前状态，您可以决定玩家可以做什么。例如，在**DEAD**状态下，不允许输入，或者在**INVULNERABLE**状态下，不允许射击。
- en: Advanced FSM implementations can become quite complex, and the details are beyond
    the scope of this book (see the Appendix for further reading). In the purest sense,
    you technically won't be creating a true FSM, but for the purposes of this project,
    it will be sufficient to illustrate the concept and keep you from running into
    the Boolean flag problem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 高级FSM实现可能相当复杂，细节超出了本书的范围（参见附录以获取进一步阅读）。在纯粹的意义上，您实际上不会创建一个真正的FSM，但为了这个项目的目的，它将足以说明概念并防止您遇到布尔标志问题。
- en: 'Add a script to the `Player` node and start by creating the skeleton of the
    FSM implementation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到`Player`节点，并从创建FSM实现的骨架开始：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An `enum` (short for enumeration) is a convenient way to create a set of constants.
    The `enum` statement in the preceding code snippet is equivalent to the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`（枚举的简称）是一种创建一组常量的便捷方式。前面代码片段中的`enum`语句等同于以下代码：'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also assign a name to an `enum`, which is useful when you have more
    than one collection of constants in a single script. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以给`enum`赋予一个名称，这在您在单个脚本中有多个常量集合时很有用。例如：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, this isn't needed in this script, as you'll only be using the one `enum`
    to track the ship's states.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这个脚本中不需要这样做，因为您只会使用一个`enum`来跟踪飞船的状态。
- en: 'Next, create the `change_state` function to handle state transitions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`change_state`函数来处理状态转换：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Whenever you need to change the state of the player, you'll call the `change_state()` function
    and pass it the value of the new state. Then, by using a `match` statement, you
    can execute whatever code should accompany the transition to the new state. To
    illustrate this, the `CollisionShape2D` is being enabled/disabled by the `new_state`
    value. In `_ready()`, you specify the initial state—currently `ALIVE` so that
    you can test, but you'll change it to `INIT` later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要更改玩家的状态时，您将调用`change_state()`函数并传递新状态值。然后，通过使用`match`语句，您可以执行伴随状态转换到新状态的任何代码。为了说明这一点，`CollisionShape2D`是通过`new_state`值启用/禁用的。在`_ready()`中，您指定初始状态——目前是`ALIVE`以便进行测试，但稍后您会将其更改为`INIT`。
- en: Controls
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制方式
- en: 'Add the following variables to the script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下变量添加到脚本中：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`engine_power` and `spin_power` control how fast the ship can accelerate and
    turn. In the Inspector, set them to `500` and `15000`, respectively. `thrust` will
    represent the force being applied by the ship''s engine: either `(0, 0)` when
    coasting, or a vector with the length of `engine_power` when powered on. `rotation_dir`
    will represent what direction the ship is turning in and apply a torque, or rotational
    force.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine_power`和`spin_power`控制飞船加速和转向的速度。在检查器中，将它们分别设置为`500`和`15000`。`thrust`将代表飞船引擎施加的力：当滑行时为`(0,
    0)`，当开启动力时为一个长度为`engine_power`的向量。`rotation_dir`将代表飞船转向的方向并施加扭矩，即旋转力。'
- en: By default, the physics settings provide some *damping*, which reduces a body's
    velocity and spin. In space, there's no friction, so for realism there shouldn't
    be any damping at all. However, for an arcade-style feel, it's preferable that
    the ship should stop when you let go of the keys. In the Inspector, set the player's
    Linear/Damp to `1` and its Angular/Damp to `5`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，物理设置提供了一些*阻尼*，这会减少物体的速度和旋转。在太空中，没有摩擦，所以为了真实感，不应该有任何阻尼。然而，为了达到街机风格的体验，当您松开按键时，飞船应该停止。在检查器中，将玩家的线性/阻尼设置为`1`，其角/阻尼设置为`5`。
- en: 'The next step is to detect the input and move the ship:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检测输入并移动船只：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `get_input()` function captures the key actions and sets the ship's thrust
    on or off, and the rotation direction (`rotation_dir`) to a positive or negative
    value (representing clockwise or counter-clockwise rotation). This function is
    called every frame in `_process()`. Note that if the state is `INIT` or `DEAD`,
    `get_input()` will exit by using `return` before checking for key actions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_input()` 函数捕获按键动作，并设置船只的推力开启或关闭，以及旋转方向 (`rotation_dir`) 为正值或负值（表示顺时针或逆时针旋转）。这个函数在
    `_process()` 中每帧都会被调用。请注意，如果状态是 `INIT` 或 `DEAD`，`get_input()` 将在检查按键动作之前使用 `return`
    退出。'
- en: When using physics bodies, their movement and related functions should be called
    in `_physics_process()`. Here, you can use `set_applied_force()` to apply the
    engine thrust in whatever direction the ship is facing. Then, you can use `set_applied_torque()`
    to cause the ship to rotate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用物理体时，它们的移动和相关函数应该在 `_physics_process()` 中调用。在这里，你可以使用 `set_applied_force()`
    在船只面向的任何方向上施加引擎推力。然后，你可以使用 `set_applied_torque()` 使船只旋转。
- en: Play the scene and you should be able to fly around freely.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 播放场景，你应该能够自由飞行。
- en: Screen wrap
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕包裹
- en: 'Another feature of classic 2D arcade games is *screen wrap*. If the player
    goes off one side of the screen, they *appear* on the other side. In practice,
    you teleport or instantaneously change the ship''s position to the opposite side.
    Add the following to the class variables at the top of the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 经典 2D 街机游戏的一个特点是 *屏幕包裹*。如果玩家离开屏幕的一侧，他们*会出现在*另一侧。在实践中，你将传送或瞬间改变船只的位置到另一侧。将以下内容添加到脚本顶部的类变量中：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add this to `_ready()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将此内容添加到 `_ready()`：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Later, the game's main script will handle setting `screensize` for all of the
    game's objects, but for now, this will allow you to test the screen wrapping with
    just the player scene.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，游戏的主脚本将处理设置所有游戏对象的 `screensize`，但到目前为止，这将允许你仅使用玩家场景测试屏幕包裹。
- en: 'When first approaching this problem, you might think you could use the body''s
    `position` property and, if it exceeds the bounds of the screen, set it to the
    opposite side. However, when using `RigidBody2D`, you can''t directly set its
    `position`, because that would conflict with the movement that the physics engine
    is calculating. A common mistake is to try adding something like this to `_physics_process()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次接触这个问题时，你可能认为可以使用物体的 `position` 属性，如果它超出了屏幕的边界，就将其设置为相反的一侧。然而，当使用 `RigidBody2D`
    时，你不能直接设置其 `position`，因为这会与物理引擎正在计算的移动发生冲突。一个常见的错误是尝试在 `_physics_process()` 中添加类似以下的内容：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will fail, trapping the player on the edge of the screen (and occasionally
    *glitching* unpredictably at the corners). So, why doesn't this work? The Godot
    documentation recommends `_physics_process()` for physics-related code—it even
    has *physics* in the name. It makes sense at first glance that this should work
    correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将失败，玩家将被困在屏幕的边缘（并且偶尔在角落处不可预测地 *glitching*）。那么，为什么这不起作用呢？Godot 文档推荐使用 `_physics_process()`
    来编写与物理相关的代码——它甚至包含 *physics* 这个词。乍一看，这似乎应该能正常工作。
- en: In fact, the correct way to solve this problem is *not* to use `_physics_process()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，解决这个问题的正确方法*不是*使用 `_physics_process()`。
- en: 'To quote the `RigidBody2D` docs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 `RigidBody2D` 文档：
- en: '"You should not change a RigidBody2D''s position or linear_velocity every frame
    or even very often. If you need to directly affect the body''s state, use _integrate_forces,
    which allows you to directly access the physics state."'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"你不应该在每一帧或甚至非常频繁地更改 RigidBody2D 的位置或线性速度。如果你需要直接影响物体的状态，请使用 _integrate_forces，它允许你直接访问物理状态。"'
- en: 'And in the description for `_integrate_forces()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在 `_integrate_forces()` 的描述中：
- en: '"(It) Allows you to read and safely modify the simulation state for the object.
    Use this instead of _physics_process if you need to directly change the body''s
    position or other physics properties. (emphasis added)"'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '"(它)允许你读取并安全地修改对象的模拟状态。如果你需要直接改变物体的位置或其他物理属性，请使用此方法代替 _physics_process_。(强调已添加)"'
- en: The answer is to change the physics callback to `_integrate_forces()`, which
    gives you access to the body's `Physics2DDirectBodyState`. This is a Godot object
    containing a great deal of useful information about the current physics state
    of the body. In the case of location, the key piece of information is the body's
    `Transform2D`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是更改物理回调到 `_integrate_forces()`，这让你可以访问身体的 `Physics2DDirectBodyState`。这是一个包含大量关于身体当前物理状态的有用信息的
    Godot 对象。在位置方面，关键信息是身体的 `Transform2D`。
- en: A *transform* is a matrix representing one or more transformations in 2D space
    such as translation, rotation, and/or scaling. The translation (that is, position)
    information is found by accessing the `origin` property of the `Transform2D`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *变换* 是一个表示二维空间中一个或多个变换的矩阵，例如平移、旋转和/或缩放。通过访问 `Transform2D` 的 `origin` 属性可以找到平移（即位置）信息。
- en: 'Using this information, you can implement the wrap around effect by changing
    `_physics_process()` to `_integrate_forces()` and altering the transform''s origin:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，你可以通过将 `_physics_process()` 更改为 `_integrate_forces()` 并更改变换的原点来实现环绕效果。
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the function''s argument name has been changed to `physics_state`
    from its default: `state`. This is to prevent any possible confusion with the
    already existing `state` variable, which tracks what FSM state the player is currently
    assigned to.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数的参数名称已从默认的 `state` 更改为 `physics_state`。这是为了避免与已经存在的 `state` 变量产生任何可能的混淆，该变量跟踪玩家当前分配到的
    FSM 状态。
- en: Run the scene again and check that everything is working as expected. Make sure
    you try wrapping around in all four directions. A common mistake is to accidentally
    flip a greater-than or less-than sign, so check that first if you're having a
    problem with one or more screen edges.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行场景并检查一切是否按预期工作。确保你尝试在所有四个方向上环绕。一个常见的错误是意外地翻转大于或小于符号，所以如果你在屏幕边缘遇到问题，请首先检查这一点。
- en: Shooting
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击
- en: Now, it's time to give your ship some weapons. When pressing the `shoot` action,
    a bullet should be spawned at the front of the ship and travel in a straight line
    until it exits the screen. Then, the gun isn't allowed to fire again until a small
    amount of time has passed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候给你的飞船装备一些武器了。当按下 `shoot` 动作时，子弹应该从飞船的前端生成并沿直线飞行，直到它离开屏幕。然后，在经过一小段时间后，枪才能再次开火。
- en: Bullet scene
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子弹场景
- en: 'This is the node setup for the bullet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是子弹的节点设置：
- en: '`Area2D` (named `Bullet`)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Area2D`（命名为`Bullet`）'
- en: '`Sprite`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`'
- en: '`CollisionShape2D`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: '`VisibilityNotifier2D`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisibilityNotifier2D`'
- en: Use `res://assets/laser.png` from the assets folder for the texture of the `Sprite`,
    and a `CapsuleShape2D` for the collision shape. You'll have to set the Rotation of
    the `CollisionShape2D` to `90` so that it will fit correctly. You should also
    scale the `Sprite` down to half size (`(0.5, 0.5)`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从资源文件夹中的 `res://assets/laser.png` 作为 `Sprite` 的纹理，以及 `CapsuleShape2D` 作为碰撞形状。你必须将
    `CollisionShape2D` 的旋转设置为 `90`，以便它能够正确地适应。你还应该将 `Sprite` 缩小到一半大小（`(0.5, 0.5)`）。
- en: 'Add the following script to the `Bullet` node:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本添加到 `Bullet` 节点：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Set the exported `speed` property to `1000`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将导出的 `speed` 属性设置为 `1000`。
- en: 'The `VisibilityNotifier2D` is a node that can inform you (using signals) whenever
    a node becomes visible/invisible. You can use this to automatically delete a bullet
    when it goes off screen. Connect the `screen_exited` signal of `VisibilityNotifier2D`
    and add this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisibilityNotifier2D` 是一个节点，它可以通知你（使用信号）每当一个节点变为可见/不可见时。你可以使用这个功能自动删除离屏幕的子弹。连接
    `VisibilityNotifier2D` 的 `screen_exited` 信号并添加以下内容：'
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, connect the bullet''s `body_entered` signal so that you can detect
    when the bullet hits a rock. The bullet doesn''t need to *know* anything about
    rocks, just that it has hit something. When you create the rocks, you''ll add
    them to a group called `rocks` and give them an `explode()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接子弹的 `body_entered` 信号，以便你可以检测到子弹击中岩石的情况。子弹不需要 *知道* 任何关于岩石的信息，只需知道它击中了某个东西。当你创建岩石时，你将它们添加到名为
    `rocks` 的组中，并给它们一个 `explode()` 方法：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Firing bullets
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射子弹
- en: Now, you need instances of the bullet to be created whenever the player fires.
    However, if you make the bullet a child of the player, then it will move and rotate
    along with the player instead of moving independently. Instead, the bullet should
    be added as a child of the main scene. One way to do this would be to use `get_parent().add_child()`,
    since the `Main` scene will be the parent of the player when the game is running.
    However, this would mean you could no longer run the `Player` scene by itself
    like you have been doing, because `get_parent()` would produce an error. Or, if
    in the `Main` scene you decided to arrange things differently, making the player
    a child of some other node, the bullet wouldn't be added where you expect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当玩家开火时，需要创建子弹的实例。然而，如果你将子弹设置为玩家的子节点，那么它会随着玩家移动和旋转，而不是独立移动。相反，子弹应该被添加为场景的子节点。一种方法是通过使用`get_parent().add_child()`来实现，因为当游戏运行时，`Main`场景将是玩家的父节点。然而，这意味着你将无法像以前那样单独运行`Player`场景，因为`get_parent()`会产生错误。或者，如果在`Main`场景中你决定以不同的方式安排事物，将玩家设置为其他节点的子节点，子弹就不会出现在你期望的位置。
- en: In general, it is a bad idea to write code that assumes a fixed tree layout.
    Especially try to avoid using `get_parent()` if at all possible. You may find
    it difficult to think this way at first, but it will result in a much more modular
    design and prevent some common mistakes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编写假设固定树布局的代码是一个坏主意。特别是尽可能避免使用`get_parent()`。一开始你可能觉得很难这样思考，但这将导致一个更模块化的设计并防止一些常见的错误。
- en: Instead, the player will *give* the bullet to the main scene using a signal.
    In this way, the `Player` scene doesn't need to *know* anything about how the
    `Main` scene is set up, or even if the `Main` scene exists. Producing the bullet
    and handing it off is the `Player` object's only responsibility.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，玩家将通过信号将子弹“给予”主场景。这样，`Player`场景就不需要“知道”关于`Main`场景如何设置的信息，甚至不知道`Main`场景是否存在。生成子弹并将其传递是`Player`对象唯一的职责。
- en: Add a `Position2D` node to the player and name it `Muzzle`. This will mark the
    *muzzle* of the gun—the location where the bullet will spawn. Set its Position to
    `(50, 0)` to place it directly in front of the ship.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家上添加一个名为`Muzzle`的`Position2D`节点。这将标记枪的*枪口*——子弹将从中生成的位置。将其位置设置为`(50, 0)`以将其直接放置在船的前方。
- en: Next, add a `Timer` node named `GunTimer`. This will provide a *cooldown* to
    the gun, preventing a new bullet from firing until a certain amount of time has
    passed. Check the One Shot and Autoplay boxes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`GunTimer`的`Timer`节点。这将给枪提供一个*冷却时间*，防止在一段时间过去之前发射新的子弹。检查一次射击和自动播放框。
- en: 'Add these new variables to the player''s script:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下新变量添加到玩家的脚本中：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Drag the `Bullet.tscn` onto the new Bullet property in the Inspector, and set
    the Fire Rate to `0.25` (this value is in seconds).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Bullet.tscn`拖放到检查器中的新`Bullet`属性上，并将射击速率设置为`0.25`（此值以秒为单位）。
- en: 'Add this to `_ready()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '将以下内容添加到`_ready()`中:'
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And this to `get_input()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '然后这样调用`get_input()`:'
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, create the `shoot()` function, which will handle creating the bullet(s):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`shoot()`函数，该函数将处理创建子弹：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When emitting the `shoot` signal, you pass the `Bullet` itself plus its starting
    position and direction. Then, you disable shooting with the `can_shoot` flag and
    start the `GunTimer`. To allow the gun to shoot again, connect the `timeout` signal
    of the `GunTimer`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当发射`shoot`信号时，你传递子弹本身及其起始位置和方向。然后，通过`can_shoot`标志禁用射击并启动`GunTimer`。为了允许枪再次射击，连接`GunTimer`的`timeout`信号：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, make your Main scene. Add a `Node` named `Main` and a `Sprite` named `Background`.
    Use `res://assets/space_background.png` as the Texture*.* Add an instance of the
    `Player` to the scene.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建你的`Main`场景。添加一个名为`Main`的`Node`和一个名为`Background`的`Sprite`。使用`res://assets/space_background.png`作为纹理*.*将`Player`的实例添加到场景中。
- en: 'Add a script to `Main`, then connect the `Player` node''s `shoot` signal, and
    add the following to the created function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到`Main`中，然后连接`Player`节点的`shoot`信号，并将以下内容添加到创建的函数中：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Play the `Main` scene and test that you can fly and shoot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 播放`Main`场景并测试是否可以飞行和射击。
- en: Rocks
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 石头
- en: The goal of the game is to destroy the floating space rocks, so, now that you
    can shoot, it's time to add them. Like the ship, the rocks will also be `RigidBody2D`,
    which will make them travel in a straight line at a steady speed unless disturbed.
    They'll also bounce off each other in a realistic fashion. To make things more
    interesting, rocks will start out large and, when you shoot them, break into multiple
    smaller rocks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是摧毁漂浮的太空岩石，因此，既然你现在可以射击，那么就是时候添加它们了。和飞船一样，岩石也将是 `RigidBody2D` 类型，这将使它们以恒定的速度直线运动，除非受到干扰。它们还会以逼真的方式相互弹跳。为了让事情更有趣，岩石最初会很大，当你射击它们时，会分裂成多个更小的岩石。
- en: Scene setup
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: Start a new scene by making a `RigidBody2D`, naming it `Rock`, and adding a
    `Sprite` using the `res://assets/rock.png` texture. Add a `CollisionShape2D`,
    but *don't* add a shape to it yet. Because you'll be spawning different-sized
    rocks, the collision shape will need to be set in the code and adjusted to the
    correct size.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个 `RigidBody2D`，将其命名为 `Rock`，并使用 `res://assets/rock.png` 纹理添加一个 `Sprite`
    来开始一个新的场景。添加一个 `CollisionShape2D`，但暂时不要添加形状。因为你会生成不同大小的岩石，所以碰撞形状需要在代码中设置并调整到正确的大小。
- en: Set the Bounce property of the `Rock` to `1` and both Linear/Damp and Angular/Damp
    to `0`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Rock` 的弹跳属性设置为 `1`，并将线性/阻尼和角/阻尼都设置为 `0`。
- en: Variable size
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量大小
- en: 'Attach a script and define the member variables:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个脚本并定义成员变量：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Main` script will handle spawning new rocks, both at the beginning of a
    level as well as the smaller rocks that will appear after a large one explodes.
    A large rock will have a `size` of `3` and break into rocks of size `2`, and so
    on. The `scale_factor` is multiplied by `size` to set the sprite's scale, the
    collision radius, and so on. You can adjust it later to change how big each category
    of rock is.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 脚本将处理生成新的岩石，包括在关卡开始时以及在大岩石爆炸后出现的较小岩石。一个大的岩石将有一个 `size` 值为 `3`，并分裂成大小为
    `2` 的岩石，依此类推。`scale_factor` 将乘以 `size` 来设置精灵的缩放、碰撞半径等。你可以稍后调整它来改变每个岩石类别的尺寸。'
- en: 'All of this will be set by the `start()` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将通过 `start()` 方法设置：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here is where you calculate the correct collision shape based on the rock's
    `size` and add it to the `CollisionShape2D`. Note that since `size` is already
    in use as a class variable, you can use `_size` for the function argument.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是根据岩石的 `size` 计算正确的碰撞形状并将其添加到 `CollisionShape2D` 的地方。请注意，由于 `size` 已经作为类变量使用，你可以使用
    `_size` 作为函数参数。
- en: 'The rocks also need to wrap around the screen, so use the same technique you
    used for the `Player`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 岩石还需要在屏幕上循环，所以使用你为 `Player` 使用过的相同技术：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The difference here is that including the body's `radius` results in smoother-looking
    teleportation. The rock will appear to fully exit the screen before entering at
    the opposite side. You may want to do the same thing with the player ship. Try
    it and see which effect you like better.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于包括身体的 `radius` 会使得传送看起来更平滑。岩石看起来会完全退出屏幕，然后从对面进入。你可能也想对玩家飞船做同样的事情。试试看，看看你更喜欢哪种效果。
- en: Instancing
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化
- en: 'When new rocks are spawned, the main scene will need to pick a random start
    location. To do this, you could use some geometry to pick a random point along
    the perimeter of the screen, but instead you can take advantage of yet another
    Godot node type. You''ll draw a path around the edge of the screen, and the script
    will pick a random location along the path. Add a `Path2D` node and name it `RockPath`.
    When you click on the `Path2D`, you will see some new buttons appear at the top
    of the editor:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的岩石被生成时，主场景需要选择一个随机的起始位置。为此，你可以使用一些几何方法来选择屏幕边缘的随机点，但你可以利用另一种 Godot 节点类型。你将在屏幕边缘绘制一个路径，脚本将沿着路径选择一个随机位置。添加一个
    `Path2D` 节点并将其命名为 `RockPath`。当你点击 `Path2D` 时，你将在编辑器的顶部看到一些新的按钮：
- en: '![](img/049a9c5f-2720-4687-bf7d-d6720d98348b.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/049a9c5f-2720-4687-bf7d-d6720d98348b.png)'
- en: 'Select the middle one (Add Point) to draw the path by clicking to add the points
    shown. To make the points align, make sure Snap to grid is checked. This option
    is found under the Snapping Options button to the left of the `Lock` button. It
    appears as a series of three vertical dots. Refer to the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 选择中间的按钮（添加点）通过点击添加显示的点来绘制路径。为了使点对齐，请确保启用“吸附到网格”。此选项位于“锁定”按钮左侧的“吸附选项”按钮下。它看起来像一系列三个垂直点。请参考以下截图：
- en: '![](img/3adce6de-d266-4b9f-a639-51cae3a3a506.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3adce6de-d266-4b9f-a639-51cae3a3a506.png)'
- en: 'Draw the points in the order shown in the following screenshot. After clicking
    the fourth point, click the Close Curve button (**5**) and your path will be complete:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下截图所示的顺序绘制点。点击第四个点后，点击关闭曲线按钮（**5**），你的路径将完成：
- en: '![](img/da983698-1c01-432f-aa34-6b4d2efb4ceb.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da983698-1c01-432f-aa34-6b4d2efb4ceb.png)'
- en: Now that the path is defined, add a `PathFollow2D` node as a child of `RockPath`
    and name it `RockSpawn`. This node's purpose is to automatically follow a path
    as it moves, using its `set_offset()` method. The higher the offset, the further
    along the path it goes. Since our path is closed, it will loop around if the offset
    value is bigger than the path's length.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在路径已经定义，将一个`PathFollow2D`节点作为`RockPath`的子节点添加，并命名为`RockSpawn`。此节点的作用是在移动时自动跟随路径，使用其`set_offset()`方法。偏移量越高，它沿着路径移动的距离就越远。由于我们的路径是闭合的，如果偏移值大于路径长度，它将循环。
- en: Next, add a `Node` and name it `Rocks`. This node will serve as a container
    to hold all the rocks. By checking its number of children, you can tell if there
    are any rocks remaining.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个`Node`并将其命名为`Rocks`。这个节点将作为容器来存放所有的岩石。通过检查其子节点数量，你可以判断是否还有剩余的岩石。
- en: 'Now, add this to `Main.gd`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下内容添加到`Main.gd`：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The script starts by getting the `screensize` and passing that to the `Player`.
    Then, it spawns three rocks of size `3` using `spawn_rock()`, which is defined
    in the following code. Don''t forget to drag `Rock.tscn` onto the Rock property
    in the Inspector:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先获取`screensize`并将其传递给`Player`。然后，使用`spawn_rock()`函数（该函数定义在下面的代码中）生成三个大小为`3`的岩石。别忘了将`Rock.tscn`拖到检查器中的`Rock`属性上：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function will serve two purposes. When called with only a size parameter,
    it picks a random position along the `RockPath` and a random velocity. However,
    if those values are also provided, it will use them instead. This will let you
    spawn the smaller rocks at the location of the explosion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将有两个作用。当只传递大小参数时，它会在`RockPath`上随机选择一个位置和一个随机速度。然而，如果也提供了这些值，它将使用它们。这将允许你在爆炸的位置生成较小的岩石。
- en: Run the game and you should see three rocks floating around. However, your bullets
    don't affect them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你应该会看到三个岩石在周围漂浮。然而，你的子弹不会影响它们。
- en: Exploding rocks
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆炸岩石
- en: 'The `Bullet` is checking for bodies in the `rocks` group, so in the `Rock`
    scene, click on the Node tab and choose Groups. Type `rocks` and click Add:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`正在检查`rocks`组中的身体，所以请在`Rock`场景中点击节点标签，选择组。输入`rocks`并点击添加：'
- en: '![](img/e692448c-8b16-4c2d-996d-b09bd61a8df0.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e692448c-8b16-4c2d-996d-b09bd61a8df0.png)'
- en: 'Now, if you run the game and shoot a rock, you''ll see an error message because
    the bullet is trying to call the rock''s `explode()` method, which you haven''t
    defined yet. This method needs to do three things:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏并射击岩石，你会看到一个错误消息，因为子弹正在尝试调用岩石的`explode()`方法，但你还没有定义该方法。此方法需要做三件事：
- en: Remove the rock
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除岩石
- en: Play an explosion animation
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放爆炸动画
- en: Notify `Main` to spawn new, smaller rocks
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知`Main`生成新的、更小的岩石
- en: Explosion scene
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆炸场景
- en: 'The explosion will be a separate scene, which you can add to the `Rock` and
    later to the `Player`. It will contain two nodes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸将是一个独立的场景，你可以将其添加到`Rock`和`Player`。它将包含两个节点：
- en: '`Sprite` (named `Explosion`)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`（命名为`Explosion`）'
- en: '`AnimationPlayer`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimationPlayer`'
- en: For the sprite's Texture, use `res://assets/explosion.png`. You'll notice that
    this is a sprite sheet—an image made up of 64 smaller images laid out in a grid
    pattern. These images are the individual frames of the animation. You'll often
    find animations packaged this way, and Godot's `Sprite` node supports using them
    as individual frames.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于精灵的纹理，使用`res://assets/explosion.png`。你会注意到这是一个精灵图集——由64个较小的图像组成的网格图案。这些图像是动画的单独帧。你经常会以这种方式找到动画，Godot的`Sprite`节点支持将它们作为单独的帧使用。
- en: 'In the Inspector, find the sprite''s Animation section. Set the Vframes and
    Hframes both to `8`. This will *slice* the sprite sheet into its individual images.
    You can verify this by changing the Frame property to different values between
    `0` and `63`. Make sure to set Frames back to `0` when finished:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中找到精灵的动画部分。将Vframes和Hframes都设置为`8`。这将**切片**精灵图集成其单独的图像。你可以通过将帧属性更改为`0`到`63`之间的不同值来验证这一点。完成时，请确保将帧属性恢复到`0`：
- en: '![](img/e182f5e3-83a8-4d73-8aca-1d10c7187995.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e182f5e3-83a8-4d73-8aca-1d10c7187995.png)'
- en: 'The `AnimationPlayer` can be used to animate any property of any node. You''ll
    use the `AnimationPlayer` to change the Frame property over time. Start by clicking
    on the node and you''ll see the Animation panel open at the bottom, as shown in
    the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationPlayer` 可以用来动画化任何节点的任何属性。你将使用 `AnimationPlayer` 来随时间改变帧属性。首先点击节点，你会在底部看到打开的动画面板，如下截图所示：'
- en: '![](img/bd1ee949-0389-418e-811e-306d5e49c805.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd1ee949-0389-418e-811e-306d5e49c805.png)'
- en: Click the New Animation button and name it `explosion`. Set the Length to `0.64` and
    the Step to `0.01`. Now, click on the `Sprite` node and you'll notice that each
    property in the Inspector now has a key button next to it. Each time you click
    on the key, you create a keyframe in the current animation. The key button next
    to the Frame property also has a `+` symbol on it, indicating that it will automatically
    increment the value when you add a key frame.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 点击新建动画按钮，将其命名为 `explosion`。设置长度为 `0.64` 和步长为 `0.01`。现在，点击 `Sprite` 节点，你会注意到检查器中的每个属性旁边都有一个键按钮。每次点击键按钮，你都会在当前动画中创建一个关键帧。帧属性旁边的键按钮上还有一个
    `+` 符号，表示当你添加关键帧时，它会自动增加值。
- en: Click the key and confirm that you want to create a new animation track. Note
    that the Frame property has incremented to `1`. Click the key button repeatedly
    until you have reached the final frame (`63`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 点击键并确认你想要创建一个新的动画轨道。注意，帧属性已增加到 `1`。重复点击键按钮，直到达到最终帧（`63`）。
- en: Click the Play button in the Animation panel to see the animation being played.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画面板中点击播放按钮，以查看动画的播放。
- en: Adding to Rock
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到岩石
- en: 'In the `Rock` scene, add an instance of `Explosion` and add this line to `start()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Rock` 场景中添加一个 `Explosion` 实例，并将此行添加到 `start()` 中：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will ensure that the explosion is scaled to match the rock's size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保爆炸的缩放与岩石的大小相匹配。
- en: 'Add a signal called `exploded` at the top of the script, then add the `explode()` function,
    which will be called when the bullet hits the rock:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部添加一个名为 `exploded` 的信号，然后添加 `explode()` 函数，该函数将在子弹击中岩石时被调用：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `layers` property ensures that the explosion will be drawn on top of the
    other sprites on the screen. Then, you will send a signal that will let `Main`
    know to spawn new rocks. This signal also needs to pass the necessary data so
    that the new rocks will have the right properties.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`layers` 属性确保爆炸将在屏幕上的其他精灵之上绘制。然后，你将发送一个信号，让 `Main` 知道要生成新的岩石。此信号还需要传递必要的数据，以便新的岩石具有正确的属性。'
- en: 'When the animation finishes playing, the `AnimationPlayer` will emit a signal.
    To connect it, you need to make the `AnimationPlayer` node visible. Right-click
    on the instanced Explosion and select Editable Children, then select the `AnimationPlayer`
    and connect its `animation_finished` signal. Make sure to select the `Rock` in
    the Connect to Node section. The end of the animation means it is safe to delete
    the rock:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画播放完毕时，`AnimationPlayer` 将发出一个信号。要连接它，你需要使 `AnimationPlayer` 节点可见。右键单击实例化的爆炸，选择可编辑子项，然后选择
    `AnimationPlayer` 并连接其 `animation_finished` 信号。确保在连接到节点部分选择 `Rock`。动画的结束意味着可以安全地删除岩石：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, test the game and check that you can see explosions when you shoot the
    rocks. At this point, your rock scene should look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试游戏并检查当你射击岩石时是否可以看到爆炸。此时，你的岩石场景应该看起来像这样：
- en: '![](img/cae8a3e5-fe56-4935-9e81-36d0c6c3becb.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cae8a3e5-fe56-4935-9e81-36d0c6c3becb.png)'
- en: Spawning smaller rocks
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成较小的岩石
- en: 'The `Rock` is emitting the signal, but it needs to be connected in `Main`.
    You can''t use the Node tab to connect it, because the `Rock` instances are being
    created in code. Signals can be connected in code as well. Add this line to the
    end of `spawn_rock()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rock` 正在发出信号，但需要连接到 `Main`。你不能使用节点标签页来连接它，因为 `Rock` 实例是在代码中创建的。信号也可以在代码中连接。将以下行添加到
    `spawn_rock()` 的末尾：'
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This connects the rock''s signal to a function in `Main` called `_on_Rock_exploded()`.
    Create that function, which will be called whenever a rock sends its `exploded`
    signal:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将岩石的信号连接到 `Main` 中名为 `_on_Rock_exploded()` 的函数。创建该函数，它将在岩石发送其 `exploded` 信号时被调用：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this function, two new rocks are created unless the rock that was just destroyed
    was the smallest size it can be. The `offset` loop variable will ensure that they
    spawn and travel in opposite directions (that is, one will be the negative of
    the other). The `dir` variable finds the vector between the player and the rock,
    then uses `tangent()` to find the perpendicular to that vector. This ensures that
    the new rocks travel away from the player:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，除非刚刚被摧毁的岩石是其可能的最小尺寸，否则将创建两个新的岩石。`offset`循环变量将确保它们向相反方向生成和移动（即，一个将是另一个的负值）。`dir`变量找到玩家和岩石之间的向量，然后使用`tangent()`找到该向量的垂直向量。这确保了新岩石远离玩家移动：
- en: '![](img/db820982-ea51-4034-b9ac-631c5366ff93.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db820982-ea51-4034-b9ac-631c5366ff93.png)'
- en: Play the game once again and check that everything is working as expected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次玩游戏并检查一切是否按预期工作。
- en: UI
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面（UI）
- en: Creating a game UI can be very complex, or at least time-consuming. Precisely
    placing individual elements and ensuring they work on different-sized screens
    and devices is the least interesting part of game development for many programmers.
    Godot provides a wide variety of Control nodes to assist in this process. Learning
    how to use the various Control nodes will help lessen the pain of creating your
    game's UI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建游戏UI可能非常复杂，或者至少很耗时。精确放置单个元素并确保它们在不同大小的屏幕和设备上工作，对于许多程序员来说，是游戏开发中最不有趣的部分。Godot提供了一系列控制节点来协助这个过程。学习如何使用各种控制节点将有助于减轻创建游戏UI的痛苦。
- en: 'For this game, you don''t need a very complex UI. The game needs to provide
    the following information and interactions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你不需要一个非常复杂的UI。游戏需要提供以下信息和交互：
- en: Start button
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始按钮
- en: Status message (Get Ready or Game Over)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态信息（准备或游戏结束）
- en: Score
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分
- en: Lives counter
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值计数器
- en: 'The following is a preview of what you will be able to create:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将能够创建的预览：
- en: '![](img/3293fc90-2ae9-41da-8b77-176c6351824b.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3293fc90-2ae9-41da-8b77-176c6351824b.png)'
- en: Create a new scene, and add a `CanvasLayer` with the name `HUD` as its root
    node. The UI will be built on this layer by using Godot's `Control` Layout features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个名为`HUD`的`CanvasLayer`作为其根节点。将使用Godot的`Control`布局功能在此层上构建UI。
- en: Layout
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: Godot's `Control` nodes include a number of specialized containers. These nodes
    can be nested inside each other to create the precise layout you need. For example,
    a `MarginContainer` will automatically add padding around its contents, while
    `HBoxContainer` and `VBoxContainer` organize their contents in rows or columns,
    respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Godot的`Control`节点包括许多专用容器。这些节点可以嵌套在一起以创建所需的精确布局。例如，`MarginContainer`将自动在其内容周围添加填充，而`HBoxContainer`和`VBoxContainer`分别按行或列组织其内容。
- en: Start by adding a `MarginContainer`, which will hold the score and lives counter.
    Under the Layout menu, select Top Wide. Then, scroll down to the Custom Constants
    section and set all four margins to `20`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加一个`MarginContainer`，它将包含得分和生命值计数器。在布局菜单下，选择顶部宽。然后，向下滚动到自定义常量部分，并将所有四个边距设置为`20`。
- en: Next, add an `HBoxContainer`, which will hold the score counter on the left
    and the lives counter on the right. Under this container, add a `Label` (name
    it `ScoreLabel`) and another `HBoxContainer` (name it `LivesCounter`).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个`HBoxContainer`，它将包含左边的得分计数器和右边的生命值计数器。在此容器下，添加一个`Label`（命名为`ScoreLabel`）和另一个`HBoxContainer`（命名为`LivesCounter`）。
- en: Set the `ScoreLabel` Text to `0` and, under `Size Flags`, set Horizontal to
    Fill, Expand. Under Custom Fonts, add a `DynamicFont` like you did in [Chapter
    1](fee8a22d-c169-454d-be5e-cf6c0bc78ddb.xhtml), *Introduction*, using `res://assets/kenvector_future_thin.ttf`
    from the `assets` folder and setting the size to `64`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ScoreLabel`的文本设置为`0`，并在`Size Flags`下将水平设置为填充、扩展。在自定义字体中，添加一个`DynamicFont`，就像你在[第1章](fee8a22d-c169-454d-be5e-cf6c0bc78ddb.xhtml)中做的那样，*介绍*，使用`res://assets/kenvector_future_thin.ttf`从`assets`文件夹中设置大小为`64`。
- en: Under the `LivesCounter`, add a `TextureRect` and name it `L1`. Drag `res://assets/player_small.png`
    into the Texture property and set the Stretch Mode to Keep Aspect Centered. Make
    sure you have the `L1` node selected and press Duplicate (*Ctrl* + *D*) two times
    to create `L2` and `L3` (they'll be named automatically). During the game, the
    `HUD` will show/hide these three textures to indicate how many lives the user
    has left.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LivesCounter`下添加一个`TextureRect`，并将其命名为`L1`。将`res://assets/player_small.png`拖入纹理属性，并将拉伸模式设置为保持宽高比居中。确保选中`L1`节点，然后按两次Duplicate
    (*Ctrl* + *D*)来创建`L2`和`L3`（它们将被自动命名）。在游戏过程中，`HUD`将显示/隐藏这三个纹理，以指示用户剩余的生命值。
- en: In a larger, more complicated UI, you could save this section as its own scene
    and embed it in other sections of the UI. However, this game only needs a few
    more pieces for its UI, so it's fine to combine them all in one scene.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As a child of the `HUD` node, add a `TextureButton` (named `StartButton`), a
    `Label` (named `MessageLabel`), and a `Timer` (named `MessageTimer`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In the `res://assets` folder, there are two textures for the `StartButton`,
    one normal (`play_button.png`) and one to show when the mouse is hovering over
    it (`play_button_h.png`). Drag these to the Textures/Normal and Textures/Hover
    properties, respectively. In the Layout menu, choose Center.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: For the `MessageLabel`, make sure you set the font first before specifying the
    layout, or it won't be centered properly. You can use the same settings you used
    for the `ScoreLabel`. After setting the font, set the layout to Full Rect.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Finally, set the One Shot property of `MessageTimer` to On and its Wait Time
    to `2`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'When finished, your UI''s scene tree should look like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2c4ec3b-cd27-40db-a688-918f1b9f602d.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: UI functions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve completed the UI layout, so now let''s add a script to `HUD` so you
    can add the functionality:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `start_game` signal will be emitted when the player clicks the `StartButton`.
    The `lives_counter` variable is an array holding references to the three life
    counter images. The names are fairly long, so make sure to let the editor's autocomplete
    fill them in for you to avoid mistakes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need functions to handle updating the displayed information:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each function will be called when a value changes to update the display.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a function to handle the `Game Over` state:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, connect the `pressed` signal of the `StartButton` so that it can emit
    the signal to `Main`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, connect the `timeout` signal of `MessageTimer` so that it can hide
    the message:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Main scene code
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you can add an instance of the `HUD` to the `Main` scene. Add the following
    variables to `Main.gd`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These will track the named quantities. The following code will handle starting
    a new game:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, you need to make sure that you remove any existing rocks that are left
    over from the previous game and initialize the variables. Don't worry about the
    `start()` function on the player; you'll add that soon.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'After showing the `"Get Ready!"` message, you will use `yield` to wait for
    the message to disappear before actually starting the level:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function will be called every time the level changes. It announces the
    level number and spawns a number of rocks to match. Note—since you initialized
    `level` to `0,` this will set it to `1` for the first level.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect whether the level has ended, you continually check how many children
    the `Rocks` node has:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, you need to connect the HUD's `start_game` signal (emitted when the Play
    button is pressed) to the `new_game()` function. Select the `HUD`, click on the
    Node tab, and connect the `start_game` signal. Set Make Function to Off and type
    `new_game` in the Method In Node field.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将HUD的`start_game`信号（在按下播放按钮时发出）连接到`new_game()`函数。选择`HUD`，点击节点标签，并连接`start_game`信号。将“Make
    Function”设置为关闭，并在“Method In Node”字段中输入`new_game`。
- en: 'Next, add the following function to handle what happens when the game ends:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下函数来处理游戏结束时发生的情况：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Play the game and check that pressing the Play button starts the game. Note
    that the `Player` is currently stuck in the `INIT` state, so you can't fly around
    yet—the `Player` doesn't know the game has started.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并检查按下播放按钮是否开始游戏。注意，`Player`目前处于`INIT`状态，所以你还不能飞来飞去——`Player`不知道游戏已经开始。
- en: Player code
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家代码
- en: 'Add a new signal and a new variable to `Player.gd`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player.gd`中添加一个新的信号和一个新的变量：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `setget` statement in GDScript allows you to specify a function that will
    be called whenever the value of a given variable is changed. This means that when
    `lives` decreases, you can emit a signal to let the `HUD` know it needs to update
    the display:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: GDScript中的`setget`语句允许你指定一个函数，每当给定变量的值发生变化时，该函数将被调用。这意味着当`lives`减少时，你可以发出一个信号让`HUD`知道它需要更新显示：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `start()` function is called by `Main` when a new game starts:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当新游戏开始时，`Main`会调用`start()`函数：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When using `setget`, if you access the variable locally (in the local script),
    you must put `self.` in front of the variable name. If you don't, the `setget`
    function will not be called.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`setget`时，如果你在本地（在本地脚本中）访问变量，必须在变量名前加上`self.`。如果不这样做，`setget`函数将不会被调用。
- en: 'Now, you need to connect this signal from the `Player` to the `update_lives`
    method in the `HUD`. In `Main`, click on the `Player` instance and find its `lives_changed` signal
    in the Node tab. Click Connect, and in the connection window, under Connect to
    Node, choose the `HUD`. For Method In Node, type `update_lives`. Make sure you
    have Make Function off, and click Connect, as shown in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将这个信号从`Player`连接到`HUD`中的`update_lives`方法。在`Main`中，点击`Player`实例，并在节点标签中找到其`lives_changed`信号。点击连接，在连接窗口中，在“Connect
    to Node”下选择`HUD`。在“Method In Node”中输入`update_lives`。确保“Make Function”是关闭的，并点击连接，如图所示：
- en: '![](img/bb89e2c5-af5a-4ea2-92b7-407a9ed75cc4.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb89e2c5-af5a-4ea2-92b7-407a9ed75cc4.png)'
- en: Game over
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束
- en: In this section, you'll make the player detect when it is hit by rocks, add
    an invulnerability feature, and end the game when the player runs out of lives.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将让玩家检测自己被岩石击中，添加一个无敌特性，并在玩家生命耗尽时结束游戏。
- en: 'Add an instance of the `Explosion` to the `Player`, as well as a `Timer` node
    (named `InvulnerabilityTimer`). In the Inspector, set the Wait Time of `InvulnerabilityTimer`
    to `2` and its One Shot to On. Add this to the top of `Player.gd`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`中添加一个`Explosion`实例，以及一个名为`InvulnerabilityTimer`的计时器节点。在检查器中，将`InvulnerabilityTimer`的“Wait
    Time”设置为`2`，并将其One Shot设置为开启。将此添加到`Player.gd`的顶部：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This signal will notify the `Main` scene that the player has run out of lives
    and the game is over. Before that, however, you need to update the state machine
    to do a little more with each state:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号将通知`Main`场景玩家生命耗尽且游戏结束。然而，在此之前，你需要更新状态机以便每个状态都能做更多的事情：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `modulate.a` property of a sprite sets its alpha channel (transparency).
    Setting it to `0.5` makes it semi-transparent, while `1.0` is solid.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵的`modulate.a`属性设置其alpha通道（透明度）。将其设置为`0.5`使其半透明，而`1.0`则是实心的。
- en: 'After entering the `INVULNERABLE` state, you start the `InvulnerabilityTimer`.
    Connect its `timeout` signal:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`INVULNERABLE`状态后，你开始`InvulnerabilityTimer`。连接其`timeout`信号：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Also, connect the `animation_finished` signal from the `Explosion` animation
    like you did in the `Rock` scene:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像在`Rock`场景中做的那样，连接`Explosion`动画的`animation_finished`信号：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Detecting collisions between physics bodies
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测物理体之间的碰撞
- en: 'When you fly around, the player ship bounces off the rocks, because both bodies
    are `RigidBody2D` nodes. However, if you want to make something happen when two
    rigid bodies collide, you need to enable contact monitoring. Select the `Player`
    node and in the Inspector, set Contact Monitoring to On. By default, no contacts
    are reported, so you must also set Contacts Reported to `1`. Now, the body will
    emit a signal when it contacts another body. Click on the Node tab and connect
    the `body_entered` signal:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, go to the `Main` scene and connect the Player's `dead` signal to the `game_over()`
    function. Play the game and try running into a rock. Your ship should explode,
    become invulnerable (for two seconds), and lose one life. Check that the game
    ends if you get hit three times.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many games require some sort of pause mode to allow the player to take a break
    in the action. In Godot, pausing is a function of the scene tree and can be set
    using `get_tree().paused = true`. When the `SceneTree` is paused, three things
    happen:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The physics thread stops running
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_process` and `_physics_process` are no longer called, so no code in those
    methods is run'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_input` and `_input_event` are also not called'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the pause mode is triggered, every node in the running game can react accordingly,
    based on how you've configured it. This behavior is set via the node's Pause/Mode
    property, which you'll find all the way at the bottom of the Inspector list.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The pause mode can be set to three values: `INHERIT` (the default value), `STOP`,
    and `PROCESS`. `STOP` means the node will cease processing while the tree is paused,
    while `PROCESS` sets the node to continue running, ignoring the paused state of
    the tree. Because it would be very tedious to set this property on every node
    in the whole game, `INHERIT` lets the node use the same pause mode as its parent.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Open the Input Map tab (in Project Settings) and create a new input action called
    `pause`. Choose a key you'd like to use to toggle pause mode; for example, P is
    a good choice.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function to `Main.gd` to respond to the input action:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you ran the game now, you''d have a problem—all nodes are paused, including
    `Main`. This means that since it isn''t processing `_input`, it can''t detect
    the input again to unpause the game! To fix this, you need to set the Pause/Mode of
    `Main` to `PROCESS`. Now, you have the opposite problem: all the nodes below `Main`
    inherit this setting. This is fine for most of the nodes, but you need to set
    the mode to `STOP` on these three nodes: `Player`, `Rocks`, and `HUD`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Enemies
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Space is filled with more dangers than just rocks. In this section, you'll create
    an enemy spaceship that will periodically appear and shoot at the player.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Following a path
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the enemy appears, it should follow a path across the screen. To keep it
    from looking too repetitive, you can create multiple paths and randomly choose
    one when the enemy starts.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new scene and add a `Node`. Name it `EnemyPaths` and save the scene.
    To draw the path, add a `Path2D` node. As you saw earlier, this node allows you
    to draw a series of connected points. When you add the node, a new menu bar appears:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f219bd0e-6e72-4d6b-bcf1-f36c6f87d719.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'These buttons let you draw and modify the path''s points. Click the one with
    the + symbol to add points. Click to start the path somewhere just outside the
    game window (the bluish-purple rectangle), and then click a few more points to
    create a curve. Don''t worry about making it smooth just yet:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abefc450-e9d5-4d01-8549-2d4f26e64bc7.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: 'When the enemy ship follows the path, it will not look very smooth when it
    hits the sharp corners. To smooth the curve, click the second button in the path
    toolbar (its tooltip says Select Control Points). Now, if you click and drag any
    of the curve''s points, you will add a control point that allows you to angle
    and curve the line. Smoothing the preceding line results in something like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fc0ce46-0c81-475c-9576-628f03378275.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: 'Add a few more `Path2D` nodes to the scene and draw the paths however you like.
    Adding loops and curves rather than straight lines will make the enemy look more
    dynamic (and make it harder to hit). Remember that the first point you click will
    be the start of the path, so make sure to place them on different sides of the
    screen, for variety. Here are three example paths:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/669260e5-364c-4cac-a15f-00ae545ad22e.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Save the scene. You'll add this to the enemy's scene to give it the paths it
    can follow.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Enemy scene
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new scene for the Enemy, using an `Area2D` as its root node. Add a
    `Sprite` and use `res://assets/enemy_saucer.png` as its Texture. Set the Animation/HFrames to
    `3` so that you can choose between the different-colored ships:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b50b6fcd-0d06-441c-887c-912a9e9b5a3f.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: 'As you''ve done before, add a `CollisionShape2D` and give it a `CircleShape2D`
    scaled to cover the sprite image. Next, add an instance of the `EnemyPaths` scene
    and an `AnimationPlayer`. In the `AnimationPlayer`, you''ll need two animations:
    one to make the saucer spin as it moves, and the other to create a flash effect
    when the saucer is hit:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**Rotate animation**: Add a new animation named `rotate` and set its *Length* to
    `3`. Add a keyframe for the `Sprite` Transform/Rotation Degrees property after
    setting it to `0`, then drag the play bar to the end and add a keyframe with the
    rotation set to `360`. Click the Loop button and the Autoplay button.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hit animation**: Add a second animation named `flash`. Set its *Length* to
    `0.25` and the *Step* to `0.01`. The property you''ll be animating is the Sprite''s
    Modulate (found under *Visibility*). Add a keyframe for Modulate to create the
    track, then move the scrubber to `0.04` and change the Modulate color to red.
    Move forward another `0.04` and change the color back to white.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat this process two more times so that you have three flashes in total.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an instance of the `Explosion` scene as you did with the other objects.
    Also, like you did with the rocks, connect the explosion''s `AnimationPlayer` `animation_finished`
    signal and set it to delete the enemy when the explosion finishes:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next, add a `Timer` node called `GunTimer` that will control how often the enemy
    shoots at the player. Set its Wait Time to `1.5` and Autostart to `On`. Connect
    its `timeout` signal, but leave the code reading `pass` for now.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on the `Area2D` and the Node tab and add it to a group called
    `enemies`. As with the rocks, this will give you a way to identify the object,
    even if there are multiple enemies on the screen at the same time.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Moving the Enemy
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attach a script to the `Enemy` scene. To begin, you''ll make the code that
    will select a path and move the enemy along it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: A `PathFollow2D` node is one that can automatically move along a parent `Path2D`.
    By default, it is set to loop around the path, so you need to manually set the
    property to `false`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to move along the path:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can detect the end of the path when `offset` is greater than the total path
    length. However, it's more straightforward to use `unit_offset`, which varies
    from zero to one over the length of the path.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Spawning enemies
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Main` scene and add a `Timer` node called `EnemyTimer`. Set its One
    Shot property to `On`. Then, in `Main.gd`, add a variable to reference your enemy
    scene (drag it into the Inspector after saving the script):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the following code to `new_level()`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Connect the `EnemyTimer` `timeout` signal, and add the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This code instances the enemy whenever the `EnemyTimer` times out. When you
    add shooting to the enemy, it will use the same process you used for the `Player`,
    so you can reuse the same bullet-spawning function, which is `_on_Player_shoot()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Play the game, and you should see a flying saucer appear that will fly along
    one of your paths.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Enemy shooting and collisions
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The enemy needs to shoot at the player as well as react when hit by the player
    or the player's bullets.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Bullet` scene and choose Save Scene As to save it as `EnemyBullet.tscn`
    (afterwards, don''t forget to rename the root node as well). Remove the script
    by selecting the root node and clicking the Clear the script button:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/726a6bf4-6045-426c-8276-d91453272618.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: 'You also need to disconnect the signal connections by clicking the Node tab
    and choosing Disconnect:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45e9e2f5-6089-4049-b5e5-1cd63a8b22da.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: There is also a different texture in the `assets` folder you can use to make
    the enemy bullet appear distinct from the player's.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'The script will be very much the same as the regular bullet. Connect the area''s
    `body_entered` signal and the `screen_exited` signal of `VisibilityNotifier2D`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For now, the bullet won't do any damage to the player. You'll be adding a shield
    to the player in the next section, so you can add that at the same time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene and drag it into the Bullet property on the `Enemy`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景并将其拖动到`Enemy`上的子弹属性。
- en: 'In `Enemy.gd`, add the `shoot` function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Enemy.gd`中添加`shoot`函数：
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, you must find the vector pointing to the player's position, then add
    a little bit of randomness to it so that the bullets don't follow exactly the
    same path.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须找到指向玩家位置的矢量，然后在其上添加一点随机性，这样子弹就不会沿着完全相同的路径飞行。
- en: 'For an extra challenge, you can make the enemy shoot in *pulses*, or multiple
    rapid shots:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加额外的挑战，你可以让敌人以脉冲形式射击，或者进行多次快速射击：
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This function creates a given number of bullets with `delay` time between them.
    You can use this whenever the `GunTimer` triggers a shot:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建指定数量的子弹，子弹之间有`delay`时间间隔。你可以使用此函数 whenever `GunTimer` 触发射击：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will shoot a pulse of `3` bullets with `0.15` seconds between them. Tough
    to dodge!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发射一串`3`发子弹，子弹之间间隔`0.15`秒。很难躲避！
- en: Next, the enemy needs to take damage when it's hit by a shot from the player.
    It will flash using the animation you made, and then explode when its health reaches
    `0`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当敌人被玩家射中时，它需要受到伤害。它将使用你制作的动画闪烁，然后当其生命值达到`0`时爆炸。
- en: 'Add these functions to `Enemy.gd`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到`Enemy.gd`：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Also, connect the area''s `body_entered` signal so the enemy will explode if
    the player runs into it:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，连接区域的`body_entered`信号，这样当玩家撞到它时，敌人就会爆炸：
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Again, you're waiting for the player shield to add the damage to the player,
    so leave the `pass` placeholder there for now.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你正在等待玩家护盾将伤害添加到玩家身上，所以现在暂时留下`pass`占位符。
- en: 'Right now, the player''s bullet is only detecting physics bodies because its `body_entered` signal
    is connected. However, the enemy is an `Area2D`, so it will not trigger that signal.
    To detect the enemy, you need to also connect the  `area_entered` signal:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，玩家的子弹只检测物理体，因为它的`body_entered`信号被连接。然而，敌人是一个`Area2D`，所以它不会触发该信号。为了检测敌人，你还需要连接`area_entered`信号：
- en: '[PRE60]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Try playing the game again and you'll be doing battle with an aggressive alien
    opponent! Verify that all the collision combinations are being handled. Also note
    that the enemy's bullets can be blocked by rocks—maybe you can hide behind them
    for cover!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次玩游戏，你将与一个侵略性的外星对手战斗！验证所有碰撞组合是否被处理。此外，注意敌人的子弹可以被岩石阻挡——也许你可以躲在它们后面作为掩护！
- en: Additional features
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外功能
- en: 'The structure of the game is complete. You can start the game, play it through,
    and when it ends, play again. In this section, you''ll add some additional effects
    and features to the game to improve the gameplay experience. Effects is a broad
    term and can mean many different techniques, but in this case, you''ll specifically
    address three things:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的结构已经完整。你可以开始游戏，玩完一局，当游戏结束时，再次开始。在本节中，你将为游戏添加一些额外的效果和功能，以提升游戏体验。效果是一个广泛的概念，可以指代许多不同的技术，但在这个案例中，你将具体解决以下三个问题：
- en: '**Sound effects and music: **Audio is very often overlooked, but can be a very
    effective part of game design. Good sound improves the *feel* of the game. Bad
    or annoying sounds can create boredom or frustration. You''ll add some action-packed
    background music, and some sound effects for several actions in the game.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音效和音乐：**音频经常被忽视，但可以是游戏设计中的一个非常有效的部分。好的音效可以提升游戏的*感觉*。糟糕或令人讨厌的声音可以产生无聊或挫败感。你将为游戏中的几个动作添加一些充满动作的背景音乐和一些音效。'
- en: '**Particles: **Particle effects are images, usually small, that are generated
    in large numbers and animated by a particle system. They can be used for a countless
    number of impressive visual effects. Godot''s particle system is quite powerful;
    too powerful to fully explore here, but you''ll learn enough to get started experimenting
    with it.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子效果：**粒子效果是图像，通常是小的，由粒子系统生成并动画化。它们可以用于无数令人印象深刻的视觉效果。Godot的粒子系统非常强大；在这里无法完全探索，但你将学习足够的内容来开始实验。'
- en: '**Player shield: **If you''re finding the game too hard, especially on higher
    levels where there are a lot of rocks, adding a shield to the player will greatly
    increase your chances of survival. You can also make larger rocks do more damage
    to the shield than smaller ones. You''ll also make a nice display bar on the HUD
    to show the player''s remaining shield level.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家护盾：**如果你觉得游戏太难，尤其是在有大量岩石的高级关卡中，为玩家添加一个护盾将大大提高你的生存机会。你还可以让大岩石对护盾造成的伤害比小岩石更多。你还会在HUD上制作一个漂亮的显示条，以显示玩家的剩余护盾等级。'
- en: Sound/music
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频/音乐
- en: 'In the `res://assets/sounds` folder are several audio files containing different
    sounds in the OggVorbis format. By default, Godot sets `.ogg` files to loop when
    imported. In the case of `explosion.ogg`, `laser_blast.ogg`, and `levelup.ogg`,
    you don''t want the sounds to loop, so you need to change the import settings
    for those files. To do this, select the file in the FileSystem dock, and then
    click the Import tab located next to the Scene tab on the right-hand side of the
    editor window. Uncheck the box next to Loop and click Reimport. Do this for each
    of the three sounds. Refer to the following screenshot:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在`res://assets/sounds`文件夹中，有几个包含不同OggVorbis格式声音的音频文件。默认情况下，Godot将`.ogg`文件设置为导入时循环。在`explosion.ogg`、`laser_blast.ogg`和`levelup.ogg`的情况下，你不想让声音循环，所以需要更改这些文件的导入设置。为此，在FileSystem窗口中选择文件，然后点击位于编辑器窗口右侧场景标签旁边的导入标签。取消循环旁边的框，然后点击重新导入。为这三个声音都这样做。参考以下截图：
- en: '![](img/a9faaf00-0080-4d33-98f4-5afbebcb43f9.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9faaf00-0080-4d33-98f4-5afbebcb43f9.png)'
- en: 'To play a sound, it needs to be loaded by an `AudioStreamPlayer` node. Add
    two of these nodes to the `Player` scene, naming them `LaserSound` and `EngineSound`.
    Drag the respective sound into each node''s Stream property in the Inspector.
    To play the sound when shooting, add the following line to `shoot()` in `Player.gd`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放声音，需要通过`AudioStreamPlayer`节点加载。将两个这样的节点添加到`Player`场景中，分别命名为`LaserSound`和`EngineSound`。将相应的声音拖入每个节点的Inspector中的Stream属性。要在射击时播放声音，将以下行添加到`Player.gd`中的`shoot()`：
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Play the game and try shooting. If you find the sound a bit too loud, you can
    adjust the Volume Db property. Try a value of `-10`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并尝试射击。如果你觉得声音有点响，你可以调整音量Db属性。尝试一个值为`-10`。
- en: 'The engine sound works a little differently. It needs to play when the thrust
    is on, but if you try to just `play()` the sound in the `get_input()` function,
    it will restart the sound every frame as long as you have the input pressed. This
    doesn''t sound good, so you only want to start playing the sound if it isn''t
    already playing. Here is the relevant section from the `get_input()` function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎声音的工作方式略有不同。当推力开启时，它需要播放，但如果你尝试在`get_input()`函数中直接`play()`声音，只要按下输入，声音就会每帧重新启动。这听起来不太好，所以你只想在声音尚未播放时开始播放。以下是`get_input()`函数中的相关部分：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that a problem can occur—if the player dies while holding down the thrust
    key, the engine sound will remain stuck on. This can be solved by adding `$EngineSound.stop()` to
    the `DEAD` state in `change_state()`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能会出现一个问题——如果玩家在按住推力键时死亡，引擎声音将卡在原地。这可以通过在`change_state()`中的`DEAD`状态添加`$EngineSound.stop()`来解决。
- en: 'In the `Main` scene, add three more `AudioStreamPlayer` nodes: `ExplodeSound`,
    `LevelupSound`, and `Music`. In their Stream properties, drop `explosion.ogg`,
    `levelup.ogg`, and `Funky-Gameplay_Looping.ogg`.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`场景中，添加三个更多的`AudioStreamPlayer`节点：`ExplodeSound`、`LevelupSound`和`Music`。在它们的Stream属性中，将`explosion.ogg`、`levelup.ogg`和`Funky-Gameplay_Looping.ogg`拖入。
- en: Add `$ExplodeSound.play()` as the first line of `_on_Rock_exploded()`, and add
    `$LevelupSound.play()` to `new_level()`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 将`$ExplodeSound.play()`添加到`_on_Rock_exploded()`的第一行，并将`$LevelupSound.play()`添加到`new_level()`中。
- en: To start/stop the music, add `$Music.play()` to `new_game()` and `$Music.stop()`
    to `game_over()`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始/停止音乐，将`$Music.play()`添加到`new_game()`，并将`$Music.stop()`添加到`game_over()`中。
- en: The Enemy also needs an `ExplodeSound` and a `ShootSound`. You can use the same
    explosion as the player, but there is an `enemy_laser.wav` sound to use for the
    shot.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人也需要一个`ExplodeSound`和一个`ShootSound`。你可以使用与玩家相同的爆炸声，但有一个`enemy_laser.wav`声音用于射击。
- en: Particles
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子
- en: The player ship's thrust is a perfect use for particles, creating a streaming
    flame from the engine. Add a `Particles2D` node to the `Player` scene and name
    it `Exhaust`. You might want to zoom in on the ship image while you're doing this
    part.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家飞船的推力是使用粒子的完美用途，从引擎中创建一条流动的火焰。将一个`Particles2D`节点添加到`Player`场景中，并命名为`Exhaust`。你可能想在执行这部分时放大飞船图像。
- en: 'When first created, the `Particles2D` node has a warning: *A material to process
    the particles is not assigned*. Particles will not be emitted until you assign
    a `Process Material` in the Inspector. Two types of materials are possible: `ShaderMaterial`
    and `ParticlesMaterial`. `ShaderMaterial` allows you to write shader code in a
    GLSL-like language, while `ParticlesMaterial` is configured in the Inspector.
    Next to Particles Material, click the down-arrow and choose New ParticlesMaterial.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次创建时，`Particles2D`节点有一个警告：*未分配处理粒子的材质*。粒子将不会发射，直到你在检查器中分配一个`Process Material`。有两种类型的材质：`ShaderMaterial`和`ParticlesMaterial`。`ShaderMaterial`允许你使用类似GLSL的语言编写着色器代码，而`ParticlesMaterial`在检查器中配置。在`Particles
    Material`旁边点击向下箭头并选择新建`ParticlesMaterial`。
- en: You'll see a line of white dots streaming down from the center of the player
    ship. Your challenge now is to turn those into an exhaust flame.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一串白色圆点从玩家飞船的中心向下流动。你现在的挑战是将这些变成尾气火焰。
- en: 'There are a very large number of properties to choose from when configuring
    particles, especially under `ParticlesMaterial`. Before starting on that, set
    these properties of the `Particles2D`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置粒子时，有非常多的属性可供选择，尤其是在`ParticlesMaterial`下。在开始之前，设置`Particles2D`的这些属性：
- en: 'Amount: `25`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量：`25`
- en: Transform/Position*: *`(-28, 0)`
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换/位置：`(-28, 0)`
- en: 'Transform/Rotation: `180`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换/旋转：`180`
- en: 'Visibility/Show Behind Parent: `On`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性/显示在父项之后：`开启`
- en: Now, click on the `ParticlesMaterial`. This is where you'll find the majority
    of the properties that affect the particles' behavior. Start with Emission Shape—change
    it to Box. This will reveal Box Extents, which should be set to `(1, 5, 1)`. Now,
    the particles are emitted over a small area instead of a single point.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击`ParticlesMaterial`。这里你可以找到影响粒子行为的大多数属性。从发射形状开始——将其更改为Box。这将揭示Box Extents，应设置为`(1,
    5, 1)`。现在，粒子将在一个小区域内发射，而不是从单个点发射。
- en: Next, set Spread/Spread to `0` and Gravity/Gravity to `(0, 0, 0)`. Now, the
    particles aren't falling or spreading out, but they are moving very slowly.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将扩散/扩散设置为`0`并将重力/重力设置为`(0, 0, 0)`。现在，粒子不会下落或扩散，但它们移动得非常慢。
- en: The next property is Initial Velocity. Set Velocity to `400`. Then, scroll down
    to Scale and set it to `8`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性是初始速度。将速度设置为`400`。然后，向下滚动到缩放并将其设置为`8`。
- en: 'To make the size change over time, you can set a Scale Curve. Click on New
    CurveTexture and click on it. A new panel labeled Curve will appear. The left-hand
    dot represents the starting scale, and the right-hand dot represents the end.
    Drag the right-hand dot down until your curve looks something like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要使大小随时间变化，你可以设置一个缩放曲线。点击“新建曲线纹理”并点击它。会出现一个新的标签为“曲线”的面板。左侧的圆点代表起始缩放，右侧的圆点代表结束。将右侧的圆点向下拖动，直到你的曲线看起来像这样：
- en: '![](img/58feb303-62b9-4398-acc6-235920927aac.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58feb303-62b9-4398-acc6-235920927aac.png)'
- en: Now, the particles are shrinking as they age. Click the left arrow at the top
    of the Inspector to go back to the previous section.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，粒子在老化时会缩小。点击检查器顶部的左箭头返回到上一个部分。
- en: 'The final section to adjust is Color. To make the particles appear like a flame,
    the particles should start out a bright orange-yellow and shift to red while fading
    out. In the Color Ramp property, click on New GradientTexture. Then, in the Gradient
    property, choose New Gradient:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要调整的部分是颜色。为了让粒子看起来像火焰，粒子应该从明亮的橙黄色开始，在淡出时变为红色。在颜色渐变属性中，点击“新建渐变纹理”。然后在渐变属性中，选择新建渐变：
- en: '![](img/363872aa-232a-46a0-b454-55ba94fc2e84.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/363872aa-232a-46a0-b454-55ba94fc2e84.png)'
- en: The sliders labeled 1 and 2 select the starting and ending colors, while 3 shows
    what color is set on the currently selected slider. Click on slider 1 and then
    click 3 to choose an orange color, then click on slider 2 and set it to a deep
    red.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 标有1和2的滑块选择起始和结束颜色，而3显示当前所选滑块上设置的颜色。点击滑块1然后点击3选择橙色，然后点击滑块2并将其设置为深红色。
- en: Now that we can see what the particles are doing, they are lasting far too long.
    Go back to the `Exhaust` node and change the Lifetime to `0.1`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到粒子在做什么，它们持续的时间太长了。回到`Exhaust`节点并将寿命更改为`0.1`。
- en: Hopefully, your ship's exhaust looks somewhat like a flame. If it doesn't, feel
    free to adjust the `ParticlesMaterial` properties until you are happy with it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你的飞船尾气看起来有点像火焰。如果不像，请随意调整`ParticlesMaterial`属性，直到你满意为止。
- en: Now that the ship's `Exhaust` is configured, it needs to be turned on/off based
    on the player input. Go to the player script and add `$Exhaust.emitting = false`
    at the beginning of `get_input()`. Then, add `$Exhaust.emitting = true` under
    the `if` statement that checks for thrust input.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在船的 `Exhaust` 已配置，需要根据玩家输入开启/关闭。转到玩家脚本，并在 `get_input()` 的开头添加 `$Exhaust.emitting
    = false`。然后，在检查推力输入的 `if` 语句下添加 `$Exhaust.emitting = true`。
- en: Enemy trail
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人轨迹
- en: 'You can also use particles to make a trail effect behind the enemy. Add a `Particles2D`
    to the enemy scene and set the properties as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用粒子在敌人后面创建轨迹效果。将 `Particles2D` 添加到敌人场景中，并设置以下属性：
- en: 'Amount: `20`'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量：`20`
- en: 'Local Coords: `Off`'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地坐标：`Off`
- en: 'Texture: `res://assets/corona.png`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理：`res://assets/corona.png`
- en: 'Show Behind Parent: `On`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在父元素后面显示：`On`
- en: Note that the effect texture you're using is white on a black background. This
    image needs its blend mode changed. To do this, on the particle node, find the
    Material property (it is in the `CanvasItem` section). Select New CanvasItemMaterial
    and, in the resulting material, change the Blend Mode to `Add`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用的效果纹理在黑色背景上是白色的。这张图片需要更改其混合模式。为此，在粒子节点上，找到 Material 属性（它在 `CanvasItem`
    部分）。选择 New CanvasItemMaterial，并在生成的材质中，将混合模式更改为 `Add`。
- en: 'Now, create a `ParticlesMaterial` like you did previously, and use these settings:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个 `ParticlesMaterial`，就像你之前为玩家排气所做的那样，并使用以下设置：
- en: 'Emission Shape:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射形状：
- en: 'Shape: Box'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状：Box
- en: 'Box Extents: (`25`, `25`, `1`)'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子范围：(`25`, `25`, `1`)
- en: 'Spread: `25`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传播：`25`
- en: 'Gravity: (0, 0, 0)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力：`(0, 0, 0)`
- en: 'Now, create a `ScaleCurve` like you did for the player exhaust. This time,
    make the curve look something like the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个 `ScaleCurve`，就像你为玩家排气所做的那样。这次，使曲线看起来像以下这样：
- en: '![](img/2be98718-8357-43c4-a5cf-2d12d192aa25.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2be98718-8357-43c4-a5cf-2d12d192aa25.png)'
- en: Try running the game and see how it looks. Feel free to tinker with the settings
    until you have something you like.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并查看其外观。你可以随意调整设置，直到你满意为止。
- en: Player shield
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家护盾
- en: In this section, you'll add a shield to the player and a display element to
    the `HUD` showing the current shield level.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为玩家添加一个护盾，并在 `HUD` 中添加一个显示当前护盾级别的显示元素。
- en: 'First, add the following to the top of the `Player.gd` script:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下内容添加到 `Player.gd` 脚本的顶部：
- en: '[PRE63]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `shield` variable will work similarly to `lives`, emitting a signal to the
    `HUD` whenever it changes. Save the script and set `max_shield` to `100` and `shield_regen`
    to `5` in the Inspector.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`shield` 变量将类似于 `lives`，每当它更改时都会向 `HUD` 发出信号。保存脚本，并在检查器中将 `max_shield` 设置为
    `100`，将 `shield_regen` 设置为 `5`。'
- en: 'Next, add the following function, which handles changing the shield''s value:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下函数，该函数处理更改护盾的值：
- en: '[PRE64]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Also, since some things, such as regeneration, may add to the shield's value,
    you need to make sure it doesn't go above the maximum allowed value. Then, when
    you send the `shield_changed` signal, you pass the ratio of `shield/max_shield`.
    This way, the HUD's display doesn't need to know anything about the actual values,
    just the shield's relative state.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于一些事情，如再生，可能会增加护盾的值，你需要确保它不会超过允许的最大值。然后，当你发送 `shield_changed` 信号时，你传递 `shield/max_shield`
    的比率。这样，HUD 的显示就不需要了解实际值，只需了解护盾的相对状态。
- en: 'Add this line to `start()` and to `set_lives()`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行添加到 `start()` 和 `set_lives()` 中：
- en: '[PRE65]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Hitting a rock will damage the shield, and bigger rocks should do more damage:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 击中岩石会损坏护盾，较大的岩石应该造成更多伤害：
- en: '[PRE66]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The enemy''s bullets should also do damage, so make this change to `EnemyBullet.gd`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人的子弹也应该造成伤害，所以将此更改应用到 `EnemyBullet.gd`：
- en: '[PRE67]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Also, running into the enemy should damage the player, so update this in `Enemy.gd`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，撞到敌人也应该伤害玩家，所以更新 `Enemy.gd` 中的此内容：
- en: '[PRE68]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The last addition to the player script is to regenerate the shield each frame.
    Add this line to `_process()`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家脚本中的最后一个添加是每帧再生护盾。将此行添加到 `_process()`：
- en: '[PRE69]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The next step is to add the display element to the `HUD`. Rather than display
    the shield''s value in a `Label`, you''ll use a `TextureProgress` node. This is
    a `Control` node that is a type of `ProgressBar`: a node that displays a given
    value as a filled bar. The `TextureProgress` node allows you to assign a texture
    to be used for the bar''s display.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将显示元素添加到 `HUD` 中。而不是在 `Label` 中显示护盾的值，你将使用 `TextureProgress` 节点。这是一个 `Control`
    节点，它是一种 `ProgressBar`：一个显示给定值作为填充条的节点。`TextureProgress` 节点允许你为条的显示分配一个纹理。
- en: 'In the existing `HBoxContainer`, add `TextureRect` and `TextureProgress`. Place
    them after the `ScoreLabel` and before the `LivesCounter`. Change the name of
    the `TextureProgress` to ShieldBar. Your node setup should look like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的`HBoxContainer`中添加`TextureRect`和`TextureProgress`。在`ScoreLabel`之后和`LivesCounter`之前放置它们。将`TextureProgress`的名称更改为ShieldBar。你的节点设置应该看起来像这样：
- en: '![](img/d0792479-4e87-481b-8af5-87fb0ff32efa.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0792479-4e87-481b-8af5-87fb0ff32efa.png)'
- en: Drag the `res://assets/shield_gold.png` texture into the *Texture* property
    of `TextureRect`. This will be an icon indicating what the bar is displaying.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 将`res://assets/shield_gold.png`纹理拖入`TextureRect`的*纹理*属性。这将是一个表示条显示内容的图标。
- en: 'The ShieldBar has three texture properties: Under, Over, and Progress. Progress is
    the texture that will be displayed as the bar''s value. Drag `res://assets/barHorizontal_green_mid
    200.png` into this property. The other two texture properties allow you to customize
    the appearance by setting an image to be drawn below or above the progress texture.
    Drag `res://assets/glassPanel_200.png` into the *Over* texture property.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShieldBar`有三个纹理属性：下、上和进度。进度是作为条值显示的纹理。将`res://assets/barHorizontal_green_mid
    200.png`拖入此属性。其他两个纹理属性允许你通过设置图像来自定义外观，该图像将被绘制在进度纹理下方或上方。将`res://assets/glassPanel_200.png`拖入*上*纹理属性。'
- en: In the *Range* section, you can set the numeric properties of the bar. Min Value and
    Max Value should be set to `0` and `100`, as this bar will be showing the percentage
    value of the shield, not its raw value. Value is the property that controls the
    currently displayed fill value. Change it to `75` to see the bar partly filled.
    Also, set its Horizontal size flags to Fill, Expand.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在*范围*部分，你可以设置条的数值属性。最小值和最大值应设置为`0`和`100`，因为这条线将显示护盾的百分比值，而不是其原始值。值是控制当前显示填充值的属性。将其更改为`75`以查看部分填充的条。此外，设置其水平大小标志为填充、扩展。
- en: 'Now, you can update the HUD script to control the shield bar. Add these variables
    at the top:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以更新HUD脚本以控制护盾栏。在顶部添加以下变量：
- en: '[PRE70]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In addition to the green bar texture, you also have red and yellow bars in
    the `assets` folder. This will allow you to change the shield''s color as the
    value decreases. Loading the textures in this way makes them easier to access
    later in the script when you want to assign the appropriate image to the `TextureProgress`
    node:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绿色的条纹理外，你还在`assets`文件夹中有红色和黄色的条。这将允许你随着值的降低更改护盾的颜色。以这种方式加载纹理使得在脚本中稍后更容易访问，当你想要将适当的图像分配给`TextureProgress`节点时：
- en: '[PRE71]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Lastly, click on the `Main` scene's `Player` node and connect the `shield_changed`
    signal to the `update_shield()` function you just created. Run the game and verify
    that you can see the shield and that it is working. You may want to increase or
    decrease the regeneration rate to adjust it to a speed you like.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击`Main`场景的`Player`节点，并将`shield_changed`信号连接到你刚刚创建的`update_shield()`函数。运行游戏并验证你是否可以看到护盾以及它是否正常工作。你可能想要增加或减少再生速率以调整到你喜欢的高速。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work with `RigidBody2D` nodes and learned
    more about how Godot's physics works. You also implemented a basic Finite State
    Machine—something you'll find more and more useful as your projects grow larger.
    You saw how `Container` nodes help organize and keep UI nodes aligned. Finally,
    you added some sound effects and got your first taste of advanced visual effects
    by using the `AnimationPlayer` and `Particles2D` nodes.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何与`RigidBody2D`节点一起工作，并更多地了解了Godot物理的工作方式。你还实现了一个基本的有限状态机——随着你的项目变得更大，你会发现它越来越有用。你看到了`Container`节点如何帮助组织和保持UI节点对齐。最后，你添加了一些音效，并通过使用`AnimationPlayer`和`Particles2D`节点，第一次尝到了高级视觉效果。
- en: You also created a number of game objects using the standard Godot hierarchies,
    such as `CollisionShapes` being attached to `CollisionObjects`. At this point,
    some of these node configurations should be starting to look familiar to you.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你还使用标准的Godot层次结构创建了许多游戏对象，例如将`CollisionShapes`附加到`CollisionObjects`。在这个阶段，这些节点配置应该开始对你来说变得熟悉。
- en: Before moving on, look through the project again. Play it. Make sure you understand
    what each scene is doing, and read through the scripts to review how everything
    connects together.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，再次查看项目。运行它。确保你理解每个场景在做什么，并阅读脚本以回顾一切是如何连接在一起的。
- en: In the next chapter, you'll learn about kinematic bodies, and use them to create
    a side-scrolling platform game.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于运动学体，并使用它们来创建一个侧滚动平台游戏。
