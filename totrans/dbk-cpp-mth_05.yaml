- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a C++ Class, Order Must There Be
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*When law and order* *kill creativity*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Ordering items is essential across various domains to ensure organization, efficiency,
    and clarity. Whether in libraries or contact lists through alphabetical ordering,
    customer service queues or data analysis with numerical sorting, timelines or
    appointments by chronology, task management or emergency response prioritization,
    inventory or digital file categorization, competition rankings, clothing size
    arrangement, geographical routing in travel or mail delivery, sequential steps
    in manufacturing or software development, or hierarchical structuring in organizations
    and biological taxonomies, ordering helps streamline processes, improve accessibility,
    and enhance decision-making.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: By applying different criteria, such as alphabetical, numerical, chronological,
    priority, categorical, ranking, size, geographical, sequential, or hierarchical,
    ordering facilitates better management and optimal functioning in diverse contexts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore why it is important to have a specific order
    for members of a C++ class and what we can gain and lose when properly or improperly
    declaring the members of a class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will get a quick overview of what the order of operations is in C++,
    because that is a topic that to some extent can be quite confusing, even for more
    advanced programmers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'With this chapter, you will learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The importance of properly declaring class members in a specific order
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of initializing your class members in the required order
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proper order of operation executions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size does matter
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned in school about the alphabet, that puts all letters in a specific
    order, like A, B, C if you are English, or A, Ä‚, Ã‚ if youâ€™re Romanian (yes, there
    are a surprisingly large number of variations to the letter A at the beginning
    of the Romanian alphabet). Not everyone alive today is sure about the reasoning
    of the order, but since todaysâ€™ alphabets are based on older ones, such as Î‘,
    Î’, Î“ for the Greeks or ğ“€€, ğ“, ğ“£ and even ğ“· for our Ancient Egyptian ancestors,
    we canâ€™t really be sure why this succession of characters has emerged.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The alphabet is a very handy thing; it helps us organize and categorize everything
    that can be named. From insects, with ants being categorized before bees, through
    to the spices in your cupboard (except if you organize yours based on color or,
    even better, usage frequencyâ€¦ poor dear Zimbabwean mufushwa, youâ€™ll stay in the
    back for now), it helps us greatly in keeping our daily lives neat and organized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Before we venture too off topic, however, letâ€™s remember that this is a book
    about programming (more specifically, C++ programming), and thus we need to keep
    focused on our subject, and not get distracted talking about the bees and the
    birds (bees come before birds alphabetically, of course).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Organizing C++ concepts can, however, be a very daunting topic. By *concepts*
    , I mean functions, classes, and variables, and not the very handy feature called
    concepts introduced in C++20, which sadly is not the topic of this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: You canâ€™t really do it the way you want, because some functions need to see
    other functions and some blocks of code need to access variables that you have
    to make sure were defined before them. So, carefully crafting a C++ program can
    be very difficult.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Things change, however, when the discussion turns to C++ classes. You see, in
    a class, these visibility-related annoyances do not really matter. All the methods
    of a class see all the other methods of that class, and all member functions can
    be directly accessed in all the member functions, so life in a class is easyâ€¦
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, dear C++ disciple, I hear you cry, â€œBut you should never call the destructor
    or the constructor of a class from within the class!â€ I mostly agree, but thereâ€™s
    nothing stopping me from writing a method such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, if you write code like this, dear reader, you will suffer the consequences.
    But back to our initial topic: ordering.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Inherently, the human mind craves order. We need to be able to have an overview
    of what we are working with, where that information is, and how to locate it as
    easily as possible. It is imperative to easily and quickly find the required information,
    even if it is as insignificant as the whereabouts of a member of a class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after endless struggles with locating lost members of a class, it came
    as a revelation to one game programmer (letâ€™s call him Joe) who was happily working
    at the BigGameDev company that all the members of the class should be organized
    in alphabetical order. Brilliant, now everyone can easily locate where their required
    member is. And look how beautiful the code is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is not a particularly complicated use case; it is just a point in some
    game that tells us where a point is, by providing *x* , *y* , and *z* coordinates,
    and it gives a small insight into the workings of the point, to tell us whether
    that specific point is active or not. Life is good. The game runs neatly, and
    the players are happy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: However, at some point, the lead programmer of the game project thinks that
    some operations on that point take up too much time (Iâ€™ll spare you all the quirky
    details of what operations those are and why they need it) and those operations
    should be performed only if the point has recorded a change of values in all three
    coordinates. Joe, our programmer, is a good and very methodic programmer, and
    he knows that one solution would be to store three other **double** values, representing
    the previous *x* , *y* , and *z* coordinates, update those on change, if any,
    and perform the requested operation only if the values differ.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'However, he discards that idea and quickly concocts a different one: he will
    keep a **bool** flag for recording the change of each required coordinate, since
    he knows that a **bool** usually takes up only 1 byte, while a double on their
    platform boasts up to 8 bytes. That is a saving ofâ€¦ well, 21 bytes. So, here is
    Joeâ€™s new class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä»–æ”¾å¼ƒäº†é‚£ä¸ªæƒ³æ³•ï¼Œè¿…é€Ÿæƒ³å‡ºäº†å¦ä¸€ä¸ªä¸»æ„ï¼šä»–å°†ä¿ç•™ä¸€ä¸ªç”¨äºè®°å½•æ¯ä¸ªæ‰€éœ€åæ ‡å˜åŒ–çš„**å¸ƒå°”**æ ‡å¿—ï¼Œå› ä¸ºä»–çŸ¥é“**å¸ƒå°”**é€šå¸¸åªå ç”¨1ä¸ªå­—èŠ‚ï¼Œè€Œä»–ä»¬å¹³å°ä¸Šçš„**åŒç²¾åº¦æµ®ç‚¹æ•°**æœ€å¤šå ç”¨8ä¸ªå­—èŠ‚ã€‚è¿™æ ·èŠ‚çœäº†â€¦â€¦å¥½å§ï¼Œ21ä¸ªå­—èŠ‚ã€‚æ‰€ä»¥ï¼Œè¿™æ˜¯ä¹”çš„æ–°ç±»ï¼š
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Beautiful â€“ as with all the code he writes, itâ€™s almost like poetry. He submits
    the newly written piece of code to the repository, where it will be built overnight,
    and the freshly baked binary will be delivered for testing the next day. And then
    he does not go on vacation, because he is a diligent programmer; summer is still
    some time away, so he will wait for the testing team to approve the code before
    booking plane tickets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç¾ä¸½â€”â€”å°±åƒä»–å†™çš„æ‰€æœ‰ä»£ç ä¸€æ ·ï¼Œå®ƒå‡ ä¹å°±åƒè¯—æ­Œã€‚ä»–å°†æ–°ç¼–å†™çš„ä»£ç æäº¤åˆ°ä»“åº“ï¼Œé‚£é‡Œå°†åœ¨å¤œé—´æ„å»ºï¼Œç¬¬äºŒå¤©å°†äº¤ä»˜æ–°é²œå‡ºç‚‰çš„äºŒè¿›åˆ¶æ–‡ä»¶è¿›è¡Œæµ‹è¯•ã€‚ç„¶åä»–ä¸ä¼šå»åº¦å‡ï¼Œå› ä¸ºä»–æ˜¯ä¸€ä¸ªå‹¤å¥‹çš„ç¨‹åºå‘˜ï¼›å¤å¤©è¿˜æ—©ï¼Œæ‰€ä»¥ä»–å°†åœ¨æµ‹è¯•å›¢é˜Ÿæ‰¹å‡†ä»£ç åå†é¢„è®¢æœºç¥¨ã€‚
- en: Overnight, the automated tests explode, every suite fails, and the entire dashboard
    is red like the flag of some communist country. The next day, the entire testing
    department faces fatal failures, the game crashes, and 99.9% of the errors at
    some point relate to out-of-memory issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¸€å¤œï¼Œè‡ªåŠ¨åŒ–æµ‹è¯•çˆ†ç‚¸äº†ï¼Œæ¯ä¸ªæµ‹è¯•å¥—ä»¶éƒ½å¤±è´¥äº†ï¼Œæ•´ä¸ªä»ªè¡¨æ¿åƒæŸäº›å…±äº§ä¸»ä¹‰å›½å®¶çš„æ——å¸œä¸€æ ·å˜æˆäº†çº¢è‰²ã€‚ç¬¬äºŒå¤©ï¼Œæ•´ä¸ªæµ‹è¯•éƒ¨é—¨é¢ä¸´äº†è‡´å‘½çš„å¤±è´¥ï¼Œæ¸¸æˆå´©æºƒäº†ï¼Œ99.9%çš„é”™è¯¯åœ¨æŸä¸ªæ—¶åˆ»éƒ½ä¸å†…å­˜ä¸è¶³é—®é¢˜æœ‰å…³ã€‚
- en: The application suddenly consumes almost double the memory it was expected to
    consume, the test machines struggle to keep the desired frame rate, and everything
    is slowed down, except the memory allocation checks, which steadily show that
    the application now uses a lot more than yesterday.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: åº”ç”¨ç¨‹åºçªç„¶æ¶ˆè€—äº†å‡ ä¹æ˜¯å…¶é¢„æœŸæ¶ˆè€—é‡ä¸¤å€çš„å†…å­˜ï¼Œæµ‹è¯•æœºå™¨åŠªåŠ›ä¿æŒæ‰€éœ€çš„å¸§ç‡ï¼Œä¸€åˆ‡éƒ½åœ¨å˜æ…¢ï¼Œé™¤äº†å†…å­˜åˆ†é…æ£€æŸ¥ï¼Œå®ƒç¨³å®šåœ°æ˜¾ç¤ºåº”ç”¨ç¨‹åºç°åœ¨ä½¿ç”¨çš„å†…å­˜æ¯”æ˜¨å¤©å¤šå¾—å¤šã€‚
- en: There were not too many changes, besides Joeâ€™s own point class overhaul; some
    other developer had changed the background color in the main menu from dark gray
    to black (sadly, the developer who was supposed to implement the ground-breaking
    change that requested Joeâ€™s change had to stay at home with a sick child that
    day), so the development team gathers to discuss the newly found issue.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†ä¹”è‡ªå·±å¯¹å…¶ç‚¹ç±»çš„å…¨é¢é‡å†™ä¹‹å¤–ï¼Œå¹¶æ²¡æœ‰å¤ªå¤šå˜åŒ–ï¼›æœ‰å…¶ä»–å¼€å‘è€…å°†ä¸»èœå•çš„èƒŒæ™¯é¢œè‰²ä»æ·±ç°è‰²æ”¹ä¸ºäº†é»‘è‰²ï¼ˆé—æ†¾çš„æ˜¯ï¼Œæœ¬åº”å®æ–½ä¹”æ‰€è¯·æ±‚çš„å…·æœ‰é‡Œç¨‹ç¢‘æ„ä¹‰çš„å˜æ›´çš„å¼€å‘è€…é‚£å¤©ä¸å¾—ä¸åœ¨å®¶ç…§é¡¾ç”Ÿç—…çš„å­©å­ï¼‰ï¼Œå› æ­¤å¼€å‘å›¢é˜Ÿèšé›†åœ¨ä¸€èµ·è®¨è®ºæ–°å‘ç°çš„é—®é¢˜ã€‚
- en: The lead developer (letâ€™s call him Jimmy for his mastery in the programming
    languages) takes a look at the code and quickly proclaims, â€œJoe, mate, I really
    appreciate the neatness of your code, and that you organize the members alphabetically,
    but I will have to kindly ask you to change the order of them.â€
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»å¼€å‘äººå‘˜ï¼ˆè®©æˆ‘ä»¬ç§°ä»–ä¸ºå‰ç±³ï¼Œä»¥è¡¨å½°ä»–åœ¨ç¼–ç¨‹è¯­è¨€æ–¹é¢çš„ç²¾é€šï¼‰çœ‹äº†çœ‹ä»£ç ï¼Œå¹¶è¿…é€Ÿå®£å¸ƒï¼Œâ€œä¹”ï¼Œä¼™è®¡ï¼Œæˆ‘çœŸçš„å¾ˆæ¬£èµä½ ä»£ç çš„æ•´æ´æ€§ï¼Œä»¥åŠä½ æŒ‰å­—æ¯é¡ºåºç»„ç»‡æˆå‘˜çš„æ–¹å¼ï¼Œä½†æˆ‘å°†ä¸å¾—ä¸ç¤¼è²Œåœ°è¯·ä½ æ”¹å˜å®ƒä»¬çš„é¡ºåºã€‚â€
- en: Joe turns almost as red as the test failure indicators on the continuous integration
    monitoring screen, but since he is a reasonable person, he kindly asks why on
    Earth he should do that. Doesnâ€™t Jimmy see the beauty in the code?!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹”çš„è„¸è‰²å‡ ä¹å’ŒæŒç»­é›†æˆç›‘æ§å±å¹•ä¸Šçš„æµ‹è¯•å¤±è´¥æŒ‡ç¤ºå™¨ä¸€æ ·çº¢ï¼Œä½†ä»–æ˜¯ä¸€ä¸ªç†æ€§çš„äººï¼Œæ‰€ä»¥ä»–å‹å¥½åœ°è¯¢é—®ä¸ºä»€ä¹ˆä»–åº”è¯¥é‚£æ ·åšã€‚å‰ç±³çœ‹ä¸åˆ°ä»£ç ä¸­çš„ç¾å—?!
- en: The response from Jimmy stuns him. This is Jimmyâ€™s explanation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å‰ç±³çš„å›åº”è®©ä»–éœ‡æƒŠã€‚è¿™æ˜¯å‰ç±³çš„è§£é‡Šã€‚
- en: The memory layout of a C++ class is determined by several factors, including
    the size and alignment requirements of its members, the inheritance hierarchy,
    and padding added by the compiler to satisfy alignment constraints. When talking
    about size, each data member occupies a certain number of bytes based on its type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C++ç±»çš„å†…å­˜å¸ƒå±€ç”±å¤šä¸ªå› ç´ å†³å®šï¼ŒåŒ…æ‹¬å…¶æˆå‘˜çš„å¤§å°å’Œå¯¹é½è¦æ±‚ã€ç»§æ‰¿å±‚æ¬¡ç»“æ„ï¼Œä»¥åŠç¼–è¯‘å™¨ä¸ºäº†æ»¡è¶³å¯¹é½çº¦æŸè€Œæ·»åŠ çš„å¡«å……ã€‚å½“è°ˆåˆ°å¤§å°çš„æ—¶å€™ï¼Œæ¯ä¸ªæ•°æ®æˆå‘˜æ ¹æ®å…¶ç±»å‹å ç”¨ä¸€å®šæ•°é‡çš„å­—èŠ‚ã€‚
- en: Iâ€™m sure Joe was aware of this; however, what he might not have grasped entirely,
    looking at his solution, is the alignment of each member. Each data member must
    be stored at a memory address that is a multiple of its alignment requirement.
    The alignment requirement is typically the size of the type, but it can be adjusted
    with compiler-specific directives.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ç›¸ä¿¡Joeæ„è¯†åˆ°äº†è¿™ä¸€ç‚¹ï¼›ç„¶è€Œï¼Œä»ä»–çš„è§£å†³æ–¹æ¡ˆæ¥çœ‹ï¼Œä»–å¯èƒ½å¹¶æ²¡æœ‰å®Œå…¨ç†è§£æ¯ä¸ªæˆå‘˜çš„å¯¹é½æ–¹å¼ã€‚æ¯ä¸ªæ•°æ®æˆå‘˜å¿…é¡»å­˜å‚¨åœ¨æ»¡è¶³å…¶å¯¹é½è¦æ±‚çš„å†…å­˜åœ°å€ä¸Šã€‚å¯¹é½è¦æ±‚é€šå¸¸æ˜¯ç±»å‹çš„å¤§å°ï¼Œä½†å¯ä»¥é€šè¿‡ç¼–è¯‘å™¨ç‰¹å®šçš„æŒ‡ä»¤è¿›è¡Œè°ƒæ•´ã€‚
- en: Now, looking at padding, in order to satisfy these alignment constraints, the
    compiler may insert padding bytes between members, and to ensure the size of the
    class is a multiple of the largest alignment requirement, padding may be added
    at the end of the class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæ¥çœ‹å¡«å……ï¼Œä¸ºäº†æ»¡è¶³è¿™äº›å¯¹é½çº¦æŸï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šåœ¨æˆå‘˜ä¹‹é—´æ’å…¥å¡«å……å­—èŠ‚ï¼Œå¹¶ä¸”ä¸ºäº†ç¡®ä¿ç±»çš„å¤§å°æ˜¯æœ€å¤§å¯¹é½è¦æ±‚çš„å€æ•°ï¼Œå¯èƒ½éœ€è¦åœ¨ç±»çš„æœ«å°¾æ·»åŠ å¡«å……ã€‚
- en: 'Now, the class that the team had initially might have looked like the following
    when it was set up in memory, knowing that on their architecture, the size of
    a double is 8 bytes long:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå½“åœ¨å†…å­˜ä¸­è®¾ç½®æ—¶ï¼Œå›¢é˜Ÿæœ€åˆå¯èƒ½çœ‹èµ·æ¥å¦‚ä¸‹ï¼Œè€ƒè™‘åˆ°åœ¨ä»–ä»¬æ¶æ„ä¸Šï¼ŒåŒç²¾åº¦æµ®ç‚¹æ•°çš„å¤§å°æ˜¯8å­—èŠ‚ï¼š
- en: '![Figure 5.1 â€“ The initial class layout](img/B22235_05_1.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾5.1 â€“ åˆå§‹ç±»å¸ƒå±€](img/B22235_05_1.jpg)'
- en: Figure 5.1 â€“ The initial class layout
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾5.1 â€“ åˆå§‹ç±»å¸ƒå±€
- en: 'Using this alignment, the size of the class added up being 32 bytes. But now
    that Joe has have added three more **bool** s, each 1 byte long, the compiler
    might have organized the memory according to the following layout:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§å¯¹é½æ–¹å¼ï¼Œæ·»åŠ çš„ç±»å¤§å°æ€»è®¡ä¸º32å­—èŠ‚ã€‚ä½†ç°åœ¨ï¼Œç”±äºJoeæ·»åŠ äº†ä¸‰ä¸ªé¢å¤–çš„**bool**ç±»å‹ï¼Œæ¯ä¸ª1å­—èŠ‚é•¿ï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šæ ¹æ®ä»¥ä¸‹å¸ƒå±€ç»„ç»‡å†…å­˜ï¼š
- en: '![Figure 5.2 â€“ The class layout with the new members in the wrong order](img/B22235_05_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾5.2 â€“ æ–°æˆå‘˜é¡ºåºé”™è¯¯çš„ç±»å¸ƒå±€](img/B22235_05_2.jpg)'
- en: Figure 5.2 â€“ The class layout with the new members in the wrong order
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾5.2 â€“ æ–°æˆå‘˜é¡ºåºé”™è¯¯çš„ç±»å¸ƒå±€
- en: 'So, each byte of **bool** must have been padded up to 8 bytes, in order to
    allow the placement of the double that follows to the proper memory address. This
    made the size of the class grow to 56, because 4 **bool** s padded up to 8 bytes
    plus 3 **double** values, each of them 8 bytes, so the sum of these takes up a
    total of 56 bytes. Clang, the compiler, has a switch that allows us to inspect
    the memory layout of generated classes: **-fdump-record-layouts** . In order to
    put it into good use for this case, we have created a simple source file with
    the previous class definition and passed it down to the compiler in order to inspect
    it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ¯ä¸ª**bool**çš„å­—èŠ‚éƒ½å¿…é¡»å¡«å……åˆ°8å­—èŠ‚ï¼Œä»¥ä¾¿å°†éšåçš„åŒç²¾åº¦æµ®ç‚¹æ•°æ”¾ç½®åœ¨æ­£ç¡®çš„å†…å­˜åœ°å€ä¸Šã€‚è¿™ä½¿å¾—ç±»çš„å¤§å°å¢åŠ åˆ°56å­—èŠ‚ï¼Œå› ä¸º4ä¸ªå¡«å……åˆ°8å­—èŠ‚çš„**bool**åŠ ä¸Š3ä¸ª8å­—èŠ‚çš„åŒç²¾åº¦æµ®ç‚¹æ•°ï¼Œè¿™äº›åŠ èµ·æ¥æ€»å…±å ç”¨56å­—èŠ‚ã€‚Clangç¼–è¯‘å™¨æœ‰ä¸€ä¸ªå¼€å…³å…è®¸æˆ‘ä»¬æ£€æŸ¥ç”Ÿæˆçš„ç±»çš„å†…å­˜å¸ƒå±€ï¼š**-fdump-record-layouts**ã€‚ä¸ºäº†åœ¨è¿™ä¸ªæƒ…å†µä¸‹å……åˆ†åˆ©ç”¨å®ƒï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„æºæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«äº†ä¹‹å‰çš„ç±»å®šä¹‰ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™ç¼–è¯‘å™¨ä»¥è¿›è¡Œæ£€æŸ¥ï¼š
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding data clearly denotes what we suspected initially, that is, that
    the **bool** that was supposed to take 1 byte now officially occupies 8 (note
    that behind the scenes, we have created a file called **main.cpp** with the content
    of the **point** structure).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: å‰é¢çš„æ•°æ®æ¸…æ¥šåœ°è¡¨æ˜äº†æˆ‘ä»¬æœ€åˆæ€€ç–‘çš„æƒ…å†µï¼Œå³åŸæœ¬åº”è¯¥å ç”¨1å­—èŠ‚çš„**bool**ç°åœ¨æ­£å¼å ç”¨äº†8å­—èŠ‚ï¼ˆæ³¨æ„ï¼Œåœ¨å¹•åï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåä¸º**main.cpp**çš„æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«äº†**point**ç»“æ„çš„å†…å®¹ï¼‰ã€‚
- en: 'Now, in order to straighten out this unfortunate situation, we clearly need
    to take some further actions, so letâ€™s consider the reorganization of the members
    of the class in the following manner:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä¸ºäº†çº æ­£è¿™ç§ä¸å¹¸çš„æƒ…å†µï¼Œæˆ‘ä»¬æ˜¾ç„¶éœ€è¦é‡‡å–ä¸€äº›è¿›ä¸€æ­¥çš„è¡ŒåŠ¨ï¼Œå› æ­¤è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹æ–¹å¼é‡æ–°ç»„ç»‡ç±»çš„æˆå‘˜ï¼š
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is not a huge change, besides hurting Joeâ€™s feelings that the members are
    not organized alphabetically. We have grouped together the **bool** values so
    the class is as compact as possible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†ä¼¤å®³Joeçš„æ„Ÿæƒ…ï¼Œæˆå‘˜æ²¡æœ‰æŒ‰å­—æ¯é¡ºåºç»„ç»‡ä¹‹å¤–ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå·¨å¤§çš„å˜åŒ–ã€‚æˆ‘ä»¬å·²ç»å°†**bool**å€¼ç»„åˆåœ¨ä¸€èµ·ï¼Œä½¿ç±»å°½å¯èƒ½ç´§å‡‘ã€‚
- en: We have used the preceding information, especially taking into consideration
    the size requirements of each of the types, and concluded that it is always better
    to have small types grouped together (by *small types* , we mean variables whose
    type will take up the smallest number of bytes; for example, we know that the
    size of a **bool** variable is 1, at least for the implementation we are using).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»ä½¿ç”¨äº†å‰é¢çš„ä¿¡æ¯ï¼Œç‰¹åˆ«æ˜¯è€ƒè™‘åˆ°æ¯ç§ç±»å‹çš„å¤§å°è¦æ±‚ï¼Œå¹¶å¾—å‡ºç»“è®ºï¼Œå°†å°å‹ç±»å‹ç»„åˆåœ¨ä¸€èµ·æ€»æ˜¯æ›´å¥½çš„ï¼ˆæˆ‘ä»¬æ‰€è¯´çš„â€œå°å‹ç±»å‹â€æ˜¯æŒ‡ç±»å‹å°†å ç”¨æœ€å°‘çš„å­—èŠ‚æ•°çš„å˜é‡ï¼›ä¾‹å¦‚ï¼Œæˆ‘ä»¬çŸ¥é“**bool**å˜é‡çš„å¤§å°æ˜¯1ï¼Œè‡³å°‘å¯¹äºæˆ‘ä»¬æ‰€ä½¿ç”¨çš„å®ç°ï¼‰ã€‚
- en: 'By doing this, that is, by reorganizing the order in which the members are
    presented, we have created the following memory layout (or something similar but
    more optimal for our architecture):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 â€“ The class layout with the members in the proper order](img/B22235_05_3.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 â€“ The class layout with the members in the proper order
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, after checking with Clang again, the memory of the class looks very
    different from the previous version (please again ignore the fact that behind
    the scenes, we have modified our **main.cpp** to contain the preceding structure):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, as we can see now, the four **bool** values are placed in memory one after
    the other, and there is only one section of padding required to fill up the required
    space, for the **double** values to be aligned on the required memory addresses.
    Hypothetically, if we were to have a field with a size of **4** , we could nicely
    fit it after the last **bool** , before the first **double** , and we would not
    need any padding either.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Upon hearing Jimmyâ€™s explanation, Joe now understood the issue. He had never
    encountered alignment issues before, but he decided to read up on the subject.
    What he read was very interesting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: It explained that the alignment of variables in memory is necessary due to a
    combination of hardware requirements, performance optimization, and architectural
    constraints. Most modern processors are designed to access memory more efficiently
    when data is aligned to certain boundaries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: For example, an 8-byte double is typically best accessed at an address that
    is a multiple of 8, and when data is misaligned, the processor may need to perform
    multiple memory accesses to read or write the data, which can be significantly
    slower.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Some architectures, such as the older generation of ARM processors, PowerPC,
    and older MIPS processors, cannot properly handle misaligned access, and in these
    situations, they generate a **SIGBUS** fault, which results in the early termination
    of the application causing the fault. So, for example, the following application,
    when compiled, and the resulting binary executed on a processor of this generation
    will generate a **SIGBUS** fault:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The outcome of this highly unpleasant situation on an operating system not prepared
    to handle a misalignment error very often has quite drastic ramifications, such
    as an application crash. Older systems may even produce a system crash.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 â€“ Older system throwing a tantrum when seeing unaligned data](img/B22235_05_4.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 â€“ Older system throwing a tantrum when seeing unaligned data
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask what **error type 7** means. The answer is simple: 7 is the magic
    number that was assigned to the **SIGBUS** error. On the authorâ€™s Linux machine,
    it can be found in **/usr/include/x86_64-linux-gnu/bits/signum-arch.h** , on line
    34:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some other processors, such as the newer generation x86_64 processors, or even
    the older 80286 (and everything between, mostly adhering to the specifications
    of the x86 platform and beyond), handle these situations very gracefully, with
    a tiny time penalty concerning performance, but they can be easily convinced with
    the following assembly instructions to turn into a very moody persona of themselves:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›å…¶ä»–å¤„ç†å™¨ï¼Œä¾‹å¦‚è¾ƒæ–°çš„x86_64å¤„ç†å™¨ï¼Œæˆ–è€…ç”šè‡³è¾ƒè€çš„80286ï¼ˆä»¥åŠä¸¤è€…ä¹‹é—´çš„æ‰€æœ‰å¤„ç†å™¨ï¼Œå¤§å¤šæ•°éµå¾ªx86å¹³å°è§„èŒƒä»¥åŠæ›´è¿œï¼‰ï¼Œå¤„ç†è¿™äº›æƒ…å†µéå¸¸ä¼˜é›…ï¼Œåªæ˜¯åœ¨æ€§èƒ½ä¸Šç•¥æœ‰æ—¶é—´æŸå¤±ï¼Œä½†å®ƒä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ±‡ç¼–æŒ‡ä»¤è½»æ¾åœ°è¢«è¯´æœï¼Œå˜æˆä¸€ä¸ªéå¸¸å¤šå˜çš„ä¸ªæ€§ï¼š
- en: '| **AT&T (** **64 bit)** | **Intel (** **32 bit)** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **AT&T (** **64 bit)** | **Intel (** **32 bit)** |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **pushf****orl $0x40000,(%rsp)****popf** | **pushfd****or dword ptr [** **esp],
    40000h****popfd** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **pushf****orl $0x40000,(%rsp)****popf** | **pushfd****or dword ptr [** **esp],
    40000h****popfd** |'
- en: The code above modifies specific bits in the **EFLAGS** register using a bitwise
    OR operation. Specifically, the hexadecimal value **40000h** corresponds to setting
    the **AC** (which stands for alignment check) flag in the **EFLAGS** register,
    this flag is used to control alignment checking. When this flag is set and the
    **AM** (which stands for alignment mask) bit in the **CR0** register is also set,
    the processor checks whether data is aligned on natural boundaries. If data misalignment
    is detected, a fault is generated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ä»£ç ä½¿ç”¨ä½æˆ–æ“ä½œä¿®æ”¹äº†**EFLAGS**å¯„å­˜å™¨ä¸­çš„ç‰¹å®šä½ã€‚å…·ä½“æ¥è¯´ï¼Œåå…­è¿›åˆ¶å€¼**40000h**å¯¹åº”äºè®¾ç½®**EFLAGS**å¯„å­˜å™¨ä¸­çš„**AC**ï¼ˆä»£è¡¨å¯¹é½æ£€æŸ¥ï¼‰æ ‡å¿—ï¼Œè¿™ä¸ªæ ‡å¿—ç”¨äºæ§åˆ¶å¯¹é½æ£€æŸ¥ã€‚å½“æ­¤æ ‡å¿—è¢«è®¾ç½®ä¸”**CR0**å¯„å­˜å™¨ä¸­çš„**AM**ï¼ˆä»£è¡¨å¯¹é½æ©ç ï¼‰ä½ä¹Ÿè¢«è®¾ç½®æ—¶ï¼Œå¤„ç†å™¨ä¼šæ£€æŸ¥æ•°æ®æ˜¯å¦å¯¹é½åœ¨è‡ªç„¶è¾¹ç•Œä¸Šã€‚å¦‚æœæ£€æµ‹åˆ°æ•°æ®å¯¹é½é”™è¯¯ï¼Œåˆ™ä¼šç”Ÿæˆä¸€ä¸ªæ•…éšœã€‚
- en: The **EFLAGS** register is a special-purpose register used in x86 architecture
    CPUs that contains several flags reflecting the state of the processor. These
    flags can control or indicate various conditions, such as arithmetic conditions,
    control features, and system settings. The Intel developer center [1](B22235_05.xhtml#footnote-018)
    contains a plethora of information concerning these low-level programming features.
    We encourage anyone interested in this subject to go and browse that site for
    further information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**EFLAGS** å¯„å­˜å™¨æ˜¯x86æ¶æ„CPUä¸­ç”¨äºç‰¹æ®Šç›®çš„çš„å¯„å­˜å™¨ï¼Œå…¶ä¸­åŒ…å«åæ˜ å¤„ç†å™¨çŠ¶æ€çš„å‡ ä¸ªæ ‡å¿—ã€‚è¿™äº›æ ‡å¿—å¯ä»¥æ§åˆ¶æˆ–æŒ‡ç¤ºå„ç§æ¡ä»¶ï¼Œä¾‹å¦‚ç®—æœ¯æ¡ä»¶ã€æ§åˆ¶åŠŸèƒ½å’Œç³»ç»Ÿè®¾ç½®ã€‚è‹±ç‰¹å°”å¼€å‘è€…ä¸­å¿ƒ[1](B22235_05.xhtml#footnote-018)åŒ…å«æœ‰å…³è¿™äº›ä½çº§ç¼–ç¨‹ç‰¹æ€§çš„å¤§é‡ä¿¡æ¯ã€‚æˆ‘ä»¬é¼“åŠ±å¯¹è¿™ä¸€ä¸»é¢˜æ„Ÿå…´è¶£çš„äººå»æµè§ˆè¯¥ç½‘ç«™ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚'
- en: '[1](B22235_05.xhtml#footnote-018-backlink) [https://www.intel.com/content/www/us/en/resources-documentation/developer.html](https://www.intel.com/content/www/us/en/resources-documentation/developer.html)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22235_05.xhtml#footnote-018-backlink) [https://www.intel.com/content/www/us/en/resources-documentation/developer.html](https://www.intel.com/content/www/us/en/resources-documentation/developer.html)'
- en: When the previous code is inserted into the source code of an application, we
    can see the **SIGBUS** signal in action. Weâ€™ll spare listing that code here, because
    no one should write code that intentionally crashes their application, but instead
    letâ€™s examine another one of our friend Joeâ€™s encounters with the curiously occurring
    ordering of class members.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å‰é¢çš„ä»£ç è¢«æ’å…¥åˆ°åº”ç”¨ç¨‹åºçš„æºä»£ç ä¸­æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°**SIGBUS**ä¿¡å·åœ¨èµ·ä½œç”¨ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œçœç•¥äº†é‚£æ®µä»£ç ï¼Œå› ä¸ºæ²¡æœ‰äººåº”è¯¥ç¼–å†™æ•…æ„ä½¿ä»–ä»¬çš„åº”ç”¨ç¨‹åºå´©æºƒçš„ä»£ç ï¼Œè€Œæ˜¯è®©æˆ‘ä»¬æ¥æ£€æŸ¥ä¸€ä¸‹æˆ‘ä»¬çš„æœ‹å‹ä¹”ä¸ç±»æˆå‘˜å¥‡ç‰¹å‡ºç°é¡ºåºçš„å¦ä¸€æ¬¡é­é‡ã€‚
- en: The order that must be respected
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¿…é¡»éµå®ˆçš„é¡ºåº
- en: 'While working at BigGameDev, Joe was given another task that was vaguely related
    to character development â€“ in-game characters, that is, not his own character.
    The task was an easy one: it just required returning a formatted string that expressed
    the value of life points a character has.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨BigGameDevå·¥ä½œæœŸé—´ï¼Œä¹”è¢«åˆ†é…äº†å¦ä¸€ä¸ªä¸è§’è‰²å‘å±•ç•¥æœ‰ç›¸å…³çš„å·¥ä½œâ€”â€”æ¸¸æˆä¸­çš„è§’è‰²ï¼Œå³ä¸æ˜¯ä»–è‡ªå·±çš„è§’è‰²ã€‚è¿™é¡¹ä»»åŠ¡å¾ˆç®€å•ï¼šåªéœ€è¦è¿”å›ä¸€ä¸ªæ ¼å¼åŒ–çš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºè§’è‰²æ‹¥æœ‰çš„ç”Ÿå‘½å€¼ã€‚
- en: 'In order to implement this, Joe created the following class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œä¹”åˆ›å»ºäº†ä»¥ä¸‹ç±»ï¼š
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is as straightforward as it can be. It just takes the input data and stores
    the result in case one needs to access it again. Joe is very happy; the class
    members are organized nicely by type, but he is not sticking to alphabetical order
    anymore (he learned his lesson from the alignment discussion). He even uses modern
    C++, such as the format library or in-class initialization of members, in case
    some are not initialized (we could argue, though, that the strings are initialized
    to an empty string upon creation with the default constructor, so for them, this
    is not as relevant. This isnâ€™t the case for the **int** s), and he is generally
    happy with the code he has written.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯éå¸¸ç›´æ¥çš„ã€‚å®ƒåªæ˜¯æ¥æ”¶è¾“å…¥æ•°æ®å¹¶å°†ç»“æœå­˜å‚¨èµ·æ¥ï¼Œä»¥é˜²å°†æ¥éœ€è¦å†æ¬¡è®¿é—®ã€‚ä¹”éå¸¸é«˜å…´ï¼›ç±»æˆå‘˜æŒ‰ç±»å‹ç»„ç»‡å¾—å¾ˆå¥½ï¼Œä½†ä»–ä¸å†åšæŒæŒ‰å­—æ¯é¡ºåºæ’åˆ—ï¼ˆä»–ä»å¯¹é½è®¨è®ºä¸­å¸å–äº†æ•™è®­ï¼‰ã€‚ä»–ç”šè‡³ä½¿ç”¨äº†ç°ä»£C++ï¼Œæ¯”å¦‚æ ¼å¼åº“æˆ–æˆå‘˜çš„ç±»å†…åˆå§‹åŒ–ï¼Œä»¥é˜²æŸäº›æˆå‘˜æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼ˆæˆ‘ä»¬å¯ä»¥äº‰è®ºï¼Œå­—ç¬¦ä¸²åœ¨é»˜è®¤æ„é€ å‡½æ•°åˆ›å»ºæ—¶è¢«åˆå§‹åŒ–ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œæ‰€ä»¥å¯¹å®ƒä»¬æ¥è¯´ï¼Œè¿™å¹¶ä¸é‚£ä¹ˆç›¸å…³ã€‚å¯¹äº**int**æ¥è¯´å°±ä¸æ˜¯è¿™æ ·äº†ï¼‰ï¼Œä»–å¯¹æ‰€ç¼–å†™çš„ä»£ç æ€»ä½“ä¸Šæ„Ÿåˆ°æ»¡æ„ã€‚
- en: 'He would happily commit these into their repository right away, but common
    sense prevails. He does some quick tests, and after ensuring that everything works
    as expected, he asks his supervisor (the same Jimmy to whom we were introduced
    in the previous section) to do a quick review of the code. The code looks OK;
    it compiles and performs the required operations, and there are just two tiny
    observations that are to be added. Joe is given the following feedback: instead
    of doing the assignment of the members in the body of the constructor, an initializer
    list should be used instead. In addition, since he is going to use initializer
    lists anyway, he should make the members const, for some minor optimizations that
    the compiler might decide to throw in at some stage.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–æœ¬å¯ä»¥ç›´æ¥å°†è¿™äº›ä»£ç æäº¤åˆ°ä»–ä»¬çš„ä»“åº“ä¸­ï¼Œä½†å¸¸è¯†å äº†ä¸Šé£ã€‚ä»–è¿›è¡Œäº†ä¸€äº›å¿«é€Ÿæµ‹è¯•ï¼Œå¹¶åœ¨ç¡®ä¿ä¸€åˆ‡æŒ‰é¢„æœŸå·¥ä½œåï¼Œè¯·ä»–çš„ä¸»ç®¡ï¼ˆå³æˆ‘ä»¬åœ¨ä¸Šä¸€èŠ‚ä¸­ä»‹ç»è¿‡çš„Jimmyï¼‰å¿«é€Ÿå®¡æŸ¥ä¸€ä¸‹ä»£ç ã€‚ä»£ç çœ‹èµ·æ¥æ²¡é—®é¢˜ï¼›å®ƒç¼–è¯‘å¹¶æ‰§è¡Œäº†æ‰€éœ€çš„æ“ä½œï¼Œåªæœ‰ä¸¤ä¸ªå¾®å°çš„è§‚å¯Ÿéœ€è¦æ·»åŠ ã€‚ä¹”å¾—åˆ°äº†ä»¥ä¸‹åé¦ˆï¼šåœ¨æ„é€ å‡½æ•°çš„ä½“å†…åˆ†é…æˆå‘˜è€Œä¸æ˜¯ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ã€‚æ­¤å¤–ï¼Œç”±äºä»–æ— è®ºå¦‚ä½•éƒ½è¦ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ï¼Œæ‰€ä»¥ä»–åº”è¯¥å°†æˆå‘˜è®¾ç½®ä¸ºconstï¼Œä»¥å®ç°ä¸€äº›ç¼–è¯‘å™¨å¯èƒ½åœ¨æŸä¸ªé˜¶æ®µå†³å®šæä¾›çš„å¾®å°ä¼˜åŒ–ã€‚
- en: 'So, he should have the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä»–åº”è¯¥è¿™æ ·åšï¼š
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In C++, using an initialization list in constructors is generally preferred
    over in-body initialization due to several key advantages: it is more efficient
    since it initializes member variables directly rather than initializing them by
    default and then assigning them. Also, it ensures proper initialization of **const**
    and reference members, which cannot be dealt with properly in the body of the
    constructor.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨C++ä¸­ï¼Œç”±äºå‡ ä¸ªå…³é”®ä¼˜åŠ¿ï¼Œé€šå¸¸åœ¨æ„é€ å‡½æ•°ä¸­ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨è€Œä¸æ˜¯ä½“å†…åˆå§‹åŒ–ï¼šå®ƒæ›´é«˜æ•ˆï¼Œå› ä¸ºå®ƒç›´æ¥åˆå§‹åŒ–æˆå‘˜å˜é‡ï¼Œè€Œä¸æ˜¯å…ˆé»˜è®¤åˆå§‹åŒ–ç„¶åèµ‹å€¼ã€‚æ­¤å¤–ï¼Œå®ƒç¡®ä¿äº†**const**å’Œå¼•ç”¨æˆå‘˜çš„æ­£ç¡®åˆå§‹åŒ–ï¼Œè¿™äº›åœ¨æ„é€ å‡½æ•°çš„ä½“å†…æ— æ³•å¾—åˆ°å¦¥å–„å¤„ç†ã€‚
- en: 'Joe happily changes the code, and since not that much has changed, he â€œforgetsâ€
    to test it. Instead, he quickly submits the following sequence to review:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹”é«˜å…´åœ°ä¿®æ”¹äº†ä»£ç ï¼Œç”±äºå˜åŒ–ä¸å¤§ï¼Œä»–â€œå¿˜è®°â€æµ‹è¯•å®ƒäº†ã€‚ç›¸åï¼Œä»–è¿…é€Ÿæäº¤äº†ä»¥ä¸‹åºåˆ—ä»¥ä¾›å®¡æŸ¥ï¼š
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A response does not take too long to arrive and is surprisingly not the pat
    on the back he expected.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å“åº”ä¸ä¼šèŠ±è´¹å¤ªå¤šæ—¶é—´å°±åˆ°è¾¾äº†ï¼Œè€Œä¸”å‡ºäººæ„æ–™åœ°å¹¶ä¸æ˜¯ä»–é¢„æœŸçš„è¡¨æ‰¬ã€‚
- en: â€œJoe, did you test this code?â€
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: â€œä¹”ï¼Œä½ æµ‹è¯•è¿‡è¿™æ®µä»£ç å—ï¼Ÿâ€
- en: He has to admit that he did not consider it necessary, since not that much had
    changed. He just moved a few lines a bit above their previous positions, changed
    an equal sign to a pair of parentheses, and he was done with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–ä¸å¾—ä¸æ‰¿è®¤ï¼Œä»–æ²¡æœ‰è®¤ä¸ºè¿™æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºå˜åŒ–ä¸å¤§ã€‚ä»–åªæ˜¯å°†å‡ è¡Œä»£ç å‘ä¸Šç§»åŠ¨äº†ä¸€ç‚¹ï¼Œå°†ä¸€ä¸ªç­‰å·æ”¹ä¸ºä¸€å¯¹æ‹¬å·ï¼Œç„¶åä»–å°±å®Œæˆäº†ã€‚
- en: â€œOh, I seeâ€¦â€ said Jimmy, and he pulled out a fresh hardcopy of the latest available
    C++ standard from his back pocket.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: â€œå“¦ï¼Œæˆ‘æ˜ç™½äº†â€¦â€¦â€å‰ç±³è¯´ï¼Œä»–ä»åå£è¢‹é‡Œæå‡ºä¸€ä»½æœ€æ–°å¯ç”¨çš„C++æ ‡å‡†çš„æ–°ç‰ˆå°åˆ·æœ¬ã€‚
- en: 'The standard says the following, in the **[** **class.base.init]** section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: æ ‡å‡†åœ¨**[** **class.base.init]**éƒ¨åˆ†ä¸­å¦‚ä¸‹æ‰€è¿°ï¼š
- en: 'In a non-delegating constructor, initialization proceeds in the following order:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨éå§”æ‰˜æ„é€ å‡½æ•°ä¸­ï¼Œåˆå§‹åŒ–æŒ‰ç…§ä»¥ä¸‹é¡ºåºè¿›è¡Œï¼š
- en: First, and only for the constructor of the most derived class, virtual base
    classes are initialized in the order they appear on a depth-first left-to-right
    traversal of the directed acyclic graph of base classes, where â€œleft-to-rightâ€
    is the order of appearance of the base classes in the derived class base-specifier-list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œå¹¶ä¸”ä»…å¯¹äºæœ€æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°ï¼Œè™šæ‹ŸåŸºç±»å°†æŒ‰ç…§åœ¨åŸºç±»æŒ‡å®šåˆ—è¡¨ä¸­ä»æ·±åº¦ä¼˜å…ˆå·¦åˆ°å³éå†åŸºç±»æœ‰å‘æ— ç¯å›¾æ—¶å‡ºç°çš„é¡ºåºè¿›è¡Œåˆå§‹åŒ–ã€‚
- en: Then, direct base classes are initialized in declaration order as they appear
    in the base-specifier-list (regardless of the order of the mem-initializers).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œç›´æ¥åŸºç±»å°†æŒ‰ç…§å®ƒä»¬åœ¨åŸºç±»æŒ‡å®šåˆ—è¡¨ä¸­å‡ºç°çš„é¡ºåºè¿›è¡Œåˆå§‹åŒ–ï¼ˆä¸è€ƒè™‘åˆå§‹åŒ–å™¨æˆå‘˜çš„é¡ºåºï¼‰ã€‚
- en: Then, non-static data members are initialized in the order they were declared
    in the class definition (again regardless of the order of the mem-initializers).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œéé™æ€æ•°æ®æˆå‘˜å°†æŒ‰ç…§åœ¨ç±»å®šä¹‰ä¸­å£°æ˜çš„é¡ºåºè¿›è¡Œåˆå§‹åŒ–ï¼ˆå†æ¬¡ä¸è€ƒè™‘åˆå§‹åŒ–å™¨æˆå‘˜çš„é¡ºåºï¼‰ã€‚
- en: Finally, the compound-statement of the constructor body is executed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæ‰§è¡Œæ„é€ å‡½æ•°ä½“çš„å¤åˆè¯­å¥ã€‚
- en: This in practice means that regardless of the order in which you specified the
    members to be initialized in the initializer list, they still will be initialized
    in the order they were declared in the class, so **m_result** will be the first
    one to be initialized, and since it is using the other two data members, which
    have not been initialized yet, the result in the best case will be undefined behavior.
    In the worst case, during testing, you will get default values, and in production,
    the code will fail spectacularly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨å®è·µä¸­æ„å‘³ç€ï¼Œæ— è®ºä½ åœ¨åˆå§‹åŒ–åˆ—è¡¨ä¸­æŒ‡å®šæˆå‘˜åˆå§‹åŒ–çš„é¡ºåºå¦‚ä½•ï¼Œå®ƒä»¬ä»ç„¶ä¼šæŒ‰ç…§åœ¨ç±»ä¸­å£°æ˜çš„é¡ºåºè¿›è¡Œåˆå§‹åŒ–ï¼Œæ‰€ä»¥**m_result**å°†æ˜¯ç¬¬ä¸€ä¸ªè¢«åˆå§‹åŒ–çš„ï¼Œç”±äºå®ƒä½¿ç”¨äº†å…¶ä»–ä¸¤ä¸ªå°šæœªåˆå§‹åŒ–çš„æ•°æ®æˆå‘˜ï¼Œæ‰€ä»¥æœ€ä½³æƒ…å†µä¸‹ç»“æœå°†æ˜¯æœªå®šä¹‰è¡Œä¸ºã€‚åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œåœ¨æµ‹è¯•æœŸé—´ï¼Œä½ å°†å¾—åˆ°é»˜è®¤å€¼ï¼Œåœ¨ç”Ÿäº§ä¸­ï¼Œä»£ç å°†å¤±è´¥å¾—éå¸¸æ˜æ˜¾ã€‚
- en: 'Now, armed with this knowledge, Joe was finally able to deliver the code that
    was expected of him, on time and to the highest possible standard he could implement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå‡­å€Ÿè¿™äº›çŸ¥è¯†ï¼Œä¹”ç»ˆäºèƒ½å¤ŸæŒ‰æ—¶å¹¶ä»¥ä»–èƒ½å¤Ÿå®ç°çš„æœ€é«˜æ ‡å‡†äº¤ä»˜é¢„æœŸçš„ä»£ç ï¼š
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: He learned that while using initializer lists can be a godsend in certain situations,
    it can also throw your code to the mythical depths of the seven circles of compiler
    hell when not taking into consideration some basic rules that are set by the C++
    standard.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–äº†è§£åˆ°ï¼Œè™½ç„¶ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨åœ¨ç‰¹å®šæƒ…å†µä¸‹å¯èƒ½æ˜¯ä¸€ç§ç¥èµï¼Œä½†å¦‚æœå¿½ç•¥äº†C++æ ‡å‡†è®¾å®šçš„æŸäº›åŸºæœ¬è§„åˆ™ï¼Œå®ƒä¹Ÿå¯èƒ½å°†ä½ çš„ä»£ç æŠ›å…¥ç¥è¯èˆ¬çš„ä¸ƒä¸ªç¼–è¯‘å™¨åœ°ç‹±çš„æ·±æ¸Šã€‚
- en: The C++ standard makes it mandatory that member objects are initialized in the
    order they are declared within the class, regardless of the order specified in
    the constructor initializer list, because what happens if there is no initializer
    list, or if only some elements are initialized in it?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C++æ ‡å‡†è§„å®šï¼Œæˆå‘˜å¯¹è±¡å¿…é¡»æŒ‰ç…§åœ¨ç±»ä¸­å£°æ˜çš„é¡ºåºè¿›è¡Œåˆå§‹åŒ–ï¼Œæ— è®ºæ„é€ å‡½æ•°åˆå§‹åŒ–åˆ—è¡¨ä¸­æŒ‡å®šçš„é¡ºåºå¦‚ä½•ï¼Œå› ä¸ºå¦‚æœæ²¡æœ‰åˆå§‹åŒ–åˆ—è¡¨ï¼Œæˆ–è€…å…¶ä¸­åªåˆå§‹åŒ–äº†éƒ¨åˆ†å…ƒç´ ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: This order ensures consistency and predictability in the setup process of an
    object. When an object is constructed, initializing members in declaration order
    helps avoid potential issues that could arise if members were initialized out
    of order, especially if some members depend on others being initialized first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé¡ºåºç¡®ä¿äº†å¯¹è±¡è®¾ç½®è¿‡ç¨‹ä¸­çš„ä¸€è‡´æ€§å’Œå¯é¢„æµ‹æ€§ã€‚å½“ä¸€ä¸ªå¯¹è±¡è¢«æ„é€ æ—¶ï¼ŒæŒ‰ç…§å£°æ˜é¡ºåºåˆå§‹åŒ–æˆå‘˜æœ‰åŠ©äºé¿å…å¦‚æœæˆå‘˜åˆå§‹åŒ–é¡ºåºé”™è¯¯å¯èƒ½å‡ºç°çš„æ½œåœ¨é—®é¢˜ï¼Œç‰¹åˆ«æ˜¯å¦‚æœæŸäº›æˆå‘˜ä¾èµ–äºå…¶ä»–æˆå‘˜å…ˆè¢«åˆå§‹åŒ–ã€‚
- en: This mandated order of initialization directly influences the destruction order,
    which is the reverse of initialization. Ensuring that members are destroyed in
    the reverse order of their initialization guarantees that dependent members are
    still valid when they are needed during the destruction phase. This consistent
    and predictable cleanup process prevents potential errors and maintains the integrity
    of the objectâ€™s life cycle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§è§„å®šçš„åˆå§‹åŒ–é¡ºåºç›´æ¥å½±å“ææ„é¡ºåºï¼Œææ„é¡ºåºä¸åˆå§‹åŒ–é¡ºåºç›¸åã€‚ç¡®ä¿æˆå‘˜ä»¥åˆå§‹åŒ–é¡ºåºçš„ç›¸åé¡ºåºè¢«é”€æ¯ï¼Œç¡®ä¿åœ¨ææ„é˜¶æ®µéœ€è¦æ—¶ä¾èµ–æˆå‘˜ä»ç„¶æœ‰æ•ˆã€‚è¿™ç§ä¸€è‡´ä¸”å¯é¢„æµ‹çš„æ¸…ç†è¿‡ç¨‹é˜²æ­¢æ½œåœ¨é”™è¯¯å¹¶ä¿æŒå¯¹è±¡ç”Ÿå‘½å‘¨æœŸçš„å®Œæ•´æ€§ã€‚
- en: 'Building on this requirement of the language, we can easily provide an elegant
    and more concise solution to this problem, by using an interesting feature called
    **designated initializers** , which was introduced in C++20. Letâ€™s simplify our
    structure to look along the lines of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºè¯­è¨€çš„è¿™ä¸ªè¦æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ä¸€ä¸ªæœ‰è¶£çš„åŠŸèƒ½â€”â€”ç§°ä¸º**æŒ‡å®šåˆå§‹åŒ–å™¨**ï¼Œæ¥è½»æ¾åœ°æä¾›ä¸€ä¸ªä¼˜é›…ä¸”æ›´ç®€æ´çš„è§£å†³æ–¹æ¡ˆï¼Œè¿™ä¸ªåŠŸèƒ½æ˜¯åœ¨C++20ä¸­å¼•å…¥çš„ã€‚è®©æˆ‘ä»¬ç®€åŒ–æˆ‘ä»¬çš„ç»“æ„ï¼Œä½¿å…¶çœ‹èµ·æ¥åƒä»¥ä¸‹è¿™æ ·ï¼š
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These simple structures satisfy the requirements to be used as aggregates,
    which are required for the designated initializer feature to compile, and as you
    can see, the **m_result** member is using the already-initialized **m_player**
    and **m_points** members, during the construction of itself. Now, in the place
    where want to use the class, we just have to do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç®€å•çš„ç»“æ„æ»¡è¶³ç”¨ä½œèšåˆçš„è¦æ±‚ï¼Œè¿™å¯¹äºç¼–è¯‘æŒ‡å®šçš„åˆå§‹åŒ–å™¨ç‰¹æ€§æ˜¯å¿…éœ€çš„ï¼Œæ­£å¦‚ä½ æ‰€è§ï¼Œ**m_result** æˆå‘˜åœ¨è‡ªèº«æ„é€ è¿‡ç¨‹ä¸­ä½¿ç”¨äº†å·²ç»åˆå§‹åŒ–çš„ **m_player**
    å’Œ **m_points** æˆå‘˜ã€‚ç°åœ¨ï¼Œåœ¨æˆ‘ä»¬æƒ³è¦ä½¿ç”¨ç±»çš„ä½ç½®ï¼Œæˆ‘ä»¬åªéœ€åšä»¥ä¸‹æ“ä½œï¼š
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By adhering to this handy feature, we have explicitly specified which member
    should be initialized to which value (this can be very helpful if, for example,
    there are more than two integers that need to be initialized). Also, the feature
    requires the members to be specified in the order of their declaration, thus increasing
    the readability and maintainability of the code. The only drawback is that we
    had to dumb down our class to an **aggregate** , so no virtual functions, no constructors,
    no encapsulation â€“ none of the good stuff that raises a C++ class to mythical
    fame. But if itâ€™s good enough for Joe, we can live with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡éµå¾ªè¿™ä¸ªæ–¹ä¾¿çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬æ˜ç¡®æŒ‡å®šäº†å“ªä¸ªæˆå‘˜åº”è¯¥åˆå§‹åŒ–ä¸ºå“ªä¸ªå€¼ï¼ˆå¦‚æœéœ€è¦åˆå§‹åŒ–çš„æ•´æ•°è¶…è¿‡ä¸¤ä¸ªï¼Œè¿™å¯èƒ½ä¼šéå¸¸æœ‰å¸®åŠ©ï¼‰ã€‚æ­¤å¤–ï¼Œè¯¥ç‰¹æ€§è¦æ±‚æˆå‘˜æŒ‰ç…§å…¶å£°æ˜çš„é¡ºåºæŒ‡å®šï¼Œä»è€Œæé«˜äº†ä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚å”¯ä¸€çš„ç¼ºç‚¹æ˜¯æˆ‘ä»¬ä¸å¾—ä¸å°†æˆ‘ä»¬çš„ç±»ç®€åŒ–ä¸º
    **èšåˆä½“**ï¼Œå› æ­¤æ²¡æœ‰è™šæ‹Ÿå‡½æ•°ï¼Œæ²¡æœ‰æ„é€ å‡½æ•°ï¼Œæ²¡æœ‰å°è£…â€”â€”æ‰€æœ‰è¿™äº›å°† C++ ç±»æå‡åˆ°ç¥è¯èˆ¬åæœ›çš„å¥½ä¸œè¥¿éƒ½æ²¡æœ‰äº†ã€‚ä½†å¦‚æœè¿™å¯¹ä¹”æ¥è¯´è¶³å¤Ÿå¥½ï¼Œæˆ‘ä»¬å¯ä»¥å¿å—å®ƒã€‚
- en: Deep thoughts about order
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ·±å…¥æ€è€ƒå…³äºç§©åº
- en: 'The adventures of our friend Joe do not end here, because shortly after learning
    that the proper order of class members is not necessarily an alphabetical one,
    he was given a task that involved executing some code in a parallel manner. Since
    he learned everything about threads and associated features by watching a quick
    introductory tutorial to the subject by some guy on TikTok, he felt he was up
    to the task, and shortly, the following code was committed to the repository (please
    bear with the authors in this case; due to some pathological manifestations of
    copyright and intellectual property litigations, we cannot show the original code
    that took the entire development team two weeks to debug and fix. The example
    code is actually just trying to recreate the scenario that Joe so successfully
    implemented):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„æœ‹å‹ä¹”çš„å†’é™©å¹¶æ²¡æœ‰ç»“æŸï¼Œå› ä¸ºåœ¨ä»–äº†è§£åˆ°ç±»æˆå‘˜çš„æ­£ç¡®é¡ºåºä¸ä¸€å®šæ˜¯å­—æ¯é¡ºåºä¹‹åä¸ä¹…ï¼Œä»–è¢«åˆ†é…äº†ä¸€ä¸ªæ¶‰åŠä»¥å¹¶è¡Œæ–¹å¼æ‰§è¡Œä¸€äº›ä»£ç çš„ä»»åŠ¡ã€‚ç”±äºä»–é€šè¿‡è§‚çœ‹ TikTok
    ä¸ŠæŸä¸ªäººçš„å¿«é€Ÿå…¥é—¨æ•™ç¨‹å­¦ä¹ äº†æœ‰å…³çº¿ç¨‹åŠå…¶ç›¸å…³ç‰¹æ€§çš„æ‰€æœ‰å†…å®¹ï¼Œä»–è§‰å¾—è‡ªå·±èƒ½å¤Ÿèƒœä»»è¿™é¡¹ä»»åŠ¡ï¼Œä¸ä¹…ä¹‹åï¼Œä»¥ä¸‹ä»£ç è¢«æäº¤åˆ°ä»“åº“ä¸­ï¼ˆè¯·åœ¨è¿™ä¸ªé—®é¢˜ä¸Šå®½å®¹ä½œè€…ï¼›ç”±äºç‰ˆæƒå’ŒçŸ¥è¯†äº§æƒè¯‰è®¼çš„ä¸€äº›ç—…ç†è¡¨ç°ï¼Œæˆ‘ä»¬æ— æ³•å±•ç¤ºæ•´ä¸ªå¼€å‘å›¢é˜ŸèŠ±è´¹ä¸¤å‘¨æ—¶é—´è°ƒè¯•å’Œä¿®å¤çš„åŸå§‹ä»£ç ã€‚ç¤ºä¾‹ä»£ç å®é™…ä¸Šåªæ˜¯åœ¨å°è¯•é‡ç°ä¹”æˆåŠŸå®æ–½çš„åœºæ™¯ï¼‰ï¼š
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The given C++ program tries to get as close as possible to the simple multithreaded
    mayhem Joe created, using two friendly structures, named **bar** and **foo** (we
    let **baz** take a rest for a short while, but if you miss him, you can name the
    function **baz** ), creating a meaningful interaction in order to perform a task
    on a separate thread. The **bar** structure manages a dynamically allocated **long
    long** variable, **i** (because what else would we call a variable that has the
    role of an index?), which is continuously incremented in its **serve** method.
    When the increment count reaches **1024768** (letâ€™s just ignore the fact that
    1024x768 is also a screen resolution), then it pauses for 200 milliseconds, resets
    the counter **i** to **0** , and prints a dot to the console (in the real-life
    application, something else happened, but that is out of the scope of this book).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šçš„ C++ ç¨‹åºè¯•å›¾å°½å¯èƒ½æ¥è¿‘ä¹”åˆ›é€ çš„ç®€å•å¤šçº¿ç¨‹æ··ä¹±ï¼Œä½¿ç”¨ä¸¤ä¸ªå‹å¥½çš„ç»“æ„ï¼Œå‘½åä¸º **bar** å’Œ **foo**ï¼ˆæˆ‘ä»¬è®© **baz** ä¼‘æ¯ä¸€ä¼šå„¿ï¼Œä½†å¦‚æœä½ æƒ³å¿µä»–ï¼Œä½ å¯ä»¥å°†å‡½æ•°å‘½åä¸º
    **baz**ï¼‰ï¼Œä¸ºäº†åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸Šæ‰§è¡Œä»»åŠ¡ï¼Œåˆ›å»ºæœ‰æ„ä¹‰çš„äº¤äº’ã€‚**bar** ç»“æ„ç®¡ç†ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„ **long long** å˜é‡ï¼Œ**i**ï¼ˆå› ä¸ºæˆ‘ä»¬ä¼šå«ä¸€ä¸ªå…·æœ‰ç´¢å¼•è§’è‰²çš„å˜é‡å«ä»€ä¹ˆå‘¢ï¼Ÿï¼‰ï¼Œå®ƒåœ¨
    **serve** æ–¹æ³•ä¸­ä¸æ–­é€’å¢ã€‚å½“é€’å¢è®¡æ•°è¾¾åˆ° **1024768**ï¼ˆè®©æˆ‘ä»¬å¿½ç•¥ 1024x768 ä¹Ÿæ˜¯ä¸€ä¸ªå±å¹•åˆ†è¾¨ç‡çš„äº‹å®ï¼‰ï¼Œç„¶åå®ƒæš‚åœ 200 æ¯«ç§’ï¼Œå°†è®¡æ•°å™¨
    **i** é‡ç½®ä¸º **0**ï¼Œå¹¶åœ¨æ§åˆ¶å°æ‰“å°ä¸€ä¸ªç‚¹ï¼ˆåœ¨ç°å®ç”Ÿæ´»ä¸­çš„åº”ç”¨ç¨‹åºä¸­ï¼Œå‘ç”Ÿäº†å…¶ä»–äº‹æƒ…ï¼Œä½†è¿™è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ï¼‰ã€‚
- en: This loop continues indefinitely until **stopRequest** is set to **true** ,
    signaling the thread to exit. The constructor of **bar** initializes the counter
    **i** , and for our sole purpose of debugging, it prints a message, while the
    destructor handles memory cleanup and prints another message, ensuring that resources
    are properly managed. Why Joe does not use a smart pointer is another story, so
    letâ€™s not focus on that part for now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The **foo** structure is responsible for starting and stopping the thread that
    runs the **serve** method of a **bar** instance. Upon creation, **foo** initializes
    a **std::jthread** to run its **threadFunc** , which in turn calls the **serve**
    method of its **bar** instance. This setup allows the **serve** method to run
    concurrently with the **main** program. The **foo** destructor sets **stopRequest**
    to **true** , ensuring the thread exits gracefully. Again, it remained a mystery
    why Joe decided to pick this way of gracefully ending the thread, but since it
    worked (after the already-mentioned two weeks of debugging and troubleshooting
    sessions), the engineering team decided not to ever mention this sequence of code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In the **main** function, an instance of **foo** is created, starting the thread
    upon its creation, and the program sleeps for two seconds to allow the thread
    to run. For brevity, letâ€™s just assume that in the original application, there
    was no mention of any kind of sleeping; the real beauty of the solution came from
    some lengthy operations performed in the **main** and **bar** threads.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Dear seasoned C++ programmers: please do not focus on how this synthetic piece
    of code is handling the thread synchronization, or the fact that it allocates
    and releases memory, because that is not the purpose of it. The sole purpose of
    this code is to crash. For **std::jthread** , there are plenty of mechanisms to
    properly handle the execution, such as **std::stop_source** and **std::stop_token**
    , so please feel free to read up on them and let Joe suffer with his naive approach
    to threading for now.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code is executed, the following is the result, at least on the authorâ€™s
    Linux system:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, sometimes the output is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The same happened to Joe too. Occasionally, the application would go haywire
    and crash upon exit. Initially, this was not too much of a hassle because, well,
    if the application crashes at the end, thatâ€™s not the end of it. However, after
    a while, the code Joe wrote was introduced in a larger module, and thatâ€™s where
    chaos, mayhem, and the aforementioned two weeks of debugging sessions materialized.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the misdemeanor is quite simple. Jimmy, the master programmer
    discovered after consulting his pocket version of the C++ standard, specifically
    the **[class.dtor]** section of it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: After executing the body of the destructor and destroying any objects with automatic
    storage duration allocated within the body, a destructor for class X calls the
    destructors for Xâ€™s direct non-variant non-static data members, the destructors
    for Xâ€™s non-virtual direct base classes and, if X is the most derived class, its
    destructor calls the destructors for Xâ€™s virtual base classes. All destructors
    are called as if they were referenced with a qualified name, that is, ignoring
    any possible virtual overriding destructors in more derived classes. Bases and
    members are destroyed in the reverse order of the completion of their constructor.
    A return statement in a destructor might not directly return to the caller; before
    transferring control to the caller, the destructors for the members and bases
    are called. Destructors for elements of an array are called in reverse order of
    their construction.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ‰§è¡Œææ„å‡½æ•°çš„ä¸»ä½“å¹¶é”€æ¯åœ¨ä¸»ä½“å†…éƒ¨åˆ†é…çš„ä»»ä½•å…·æœ‰è‡ªåŠ¨å­˜å‚¨æœŸçš„å¯¹è±¡ä¹‹åï¼Œç±»Xçš„ææ„å‡½æ•°è°ƒç”¨Xçš„ç›´æ¥éå˜ä½“éé™æ€æ•°æ®æˆå‘˜çš„ææ„å‡½æ•°ï¼ŒXçš„ç›´æ¥éè™šåŸºç±»çš„ææ„å‡½æ•°ï¼Œå¦‚æœXæ˜¯æœ€æ´¾ç”Ÿç±»ï¼Œåˆ™å…¶ææ„å‡½æ•°è°ƒç”¨Xçš„è™šåŸºç±»çš„ææ„å‡½æ•°ã€‚æ‰€æœ‰ææ„å‡½æ•°éƒ½åƒä½¿ç”¨é™å®šåå¼•ç”¨ä¸€æ ·è¢«è°ƒç”¨ï¼Œå³å¿½ç•¥åœ¨æ›´æ´¾ç”Ÿç±»ä¸­å¯èƒ½å­˜åœ¨çš„ä»»ä½•å¯èƒ½çš„è™šè¦†ç›–ææ„å‡½æ•°ã€‚åŸºå’Œæˆå‘˜çš„é”€æ¯é¡ºåºä¸å®ƒä»¬æ„é€ å®Œæˆæ—¶çš„é¡ºåºç›¸åã€‚ææ„å‡½æ•°ä¸­çš„è¿”å›è¯­å¥å¯èƒ½ä¸ä¼šç›´æ¥è¿”å›åˆ°è°ƒç”¨è€…ï¼›åœ¨å°†æ§åˆ¶æƒä¼ é€’ç»™è°ƒç”¨è€…ä¹‹å‰ï¼Œä¼šè°ƒç”¨æˆå‘˜å’ŒåŸºçš„ææ„å‡½æ•°ã€‚æ•°ç»„å…ƒç´ çš„ææ„å‡½æ•°ä»¥å®ƒä»¬æ„é€ çš„ç›¸åé¡ºåºè¢«è°ƒç”¨ã€‚
- en: 'The key is that the objects are destroyed in reverse order of their creation,
    just like they would have been pushed onto a stack upon creation and popped off
    with grace in the reverse order upon destruction. The culprits for the erroneous
    behavior were quickly identified as being the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®åœ¨äºå¯¹è±¡è¢«é”€æ¯çš„é¡ºåºä¸å®ƒä»¬è¢«åˆ›å»ºçš„é¡ºåºç›¸åï¼Œå°±åƒå®ƒä»¬åœ¨åˆ›å»ºæ—¶è¢«æ¨å…¥æ ˆä¸­ï¼Œåœ¨é”€æ¯æ—¶ä»¥ä¼˜é›…çš„æ–¹å¼ä»æ ˆä¸­å¼¹å‡ºä¸€æ ·ã€‚å¯¼è‡´é”™è¯¯è¡Œä¸ºçš„ç½ªé­ç¥¸é¦–å¾ˆå¿«å°±è¢«è¯†åˆ«ä¸ºä»¥ä¸‹å†…å®¹ï¼š
- en: '**std::jthread thread;**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::jthread thread;**'
- en: '**bar b;**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**bar b;**'
- en: 'So, what happened here upon construction was that the thread was created and
    started running its thread method: **void threadFunc() { b.serve(); }** . Only
    after this unpredictable operation was initiated was the **bar b** object created.
    Then, upon exit, as per the design of the C++ language, the **bar b** object was
    deleted and its resources freed. While the thread was still possibly being blocked
    in the long operation, suddenly it was running on an object that was already deleted.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æ„å»ºè¿‡ç¨‹ä¸­å‘ç”Ÿçš„æƒ…å†µæ˜¯çº¿ç¨‹è¢«åˆ›å»ºå¹¶å¼€å§‹æ‰§è¡Œå…¶çº¿ç¨‹æ–¹æ³•ï¼š**void threadFunc() { b.serve(); }**ã€‚åªæœ‰åœ¨ä¸å¯é¢„æµ‹çš„æ“ä½œè¢«å¯åŠ¨ä¹‹åï¼Œ**bar
    b** å¯¹è±¡æ‰è¢«åˆ›å»ºã€‚ç„¶åï¼Œåœ¨é€€å‡ºæ—¶ï¼Œæ ¹æ®C++è¯­è¨€çš„è®¾è®¡ï¼Œ**bar b** å¯¹è±¡è¢«åˆ é™¤å¹¶ä¸”å…¶èµ„æºè¢«é‡Šæ”¾ã€‚å½“çº¿ç¨‹ä»ç„¶å¯èƒ½åœ¨é•¿æ—¶é—´æ“ä½œä¸­è¢«é˜»å¡æ—¶ï¼Œçªç„¶å®ƒå¼€å§‹åœ¨ä¸€ä¸ªå·²ç»è¢«åˆ é™¤çš„å¯¹è±¡ä¸Šè¿è¡Œã€‚
- en: 'The delay between the creation of the thread object, the actual starting of
    the thread routine, and the creation of the **bar b** object is so insignificant
    that catching the error in the creation phase is almost implausible. But letâ€™s
    modify the constructor of **bar** to be along the lines of the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿ç¨‹å¯¹è±¡åˆ›å»ºã€å®é™…å¯åŠ¨çº¿ç¨‹ä¾‹ç¨‹å’Œ**bar b**å¯¹è±¡åˆ›å»ºä¹‹é—´çš„å»¶è¿Ÿå¦‚æ­¤ä¹‹å°ï¼Œä»¥è‡³äºåœ¨åˆ›å»ºé˜¶æ®µæ•æ‰åˆ°é”™è¯¯å‡ ä¹æ˜¯ä¸å¯èƒ½çš„ã€‚ä½†è®©æˆ‘ä»¬ä¿®æ”¹**bar**çš„æ„é€ å‡½æ•°ï¼Œä½¿å…¶å¤§è‡´å¦‚ä¸‹ï¼š
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In an instant, we can see how the thread is running on an object whose creation
    was not entirely finished by the time the thread started using it. Certainly,
    this specific issue can be resolved easily, by simply switching the order of the
    members:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸€ç¬é—´ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°çº¿ç¨‹æ­£åœ¨è¿è¡Œä¸€ä¸ªåœ¨å…¶å¼€å§‹ä½¿ç”¨æ—¶åˆ›å»ºå¹¶æœªå®Œå…¨å®Œæˆçš„å¯¹è±¡ã€‚å½“ç„¶ï¼Œè¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡ç®€å•åœ°äº¤æ¢æˆå‘˜çš„é¡ºåºæ¥è½»æ¾è§£å†³ï¼š
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Threading is an interesting aspect of C++. While it comes with many benefits,
    it also introduces extra complexity. Properly writing correct and efficient multithreaded
    code requires careful consideration of synchronization and coordination between
    various threads.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿ç¨‹æ˜¯C++çš„ä¸€ä¸ªæœ‰è¶£æ–¹é¢ã€‚è™½ç„¶å®ƒå¸¦æ¥äº†è®¸å¤šå¥½å¤„ï¼Œä½†ä¹Ÿå¼•å…¥äº†é¢å¤–çš„å¤æ‚æ€§ã€‚æ­£ç¡®ç¼–å†™æ­£ç¡®ä¸”é«˜æ•ˆçš„çº¿ç¨‹ä»£ç éœ€è¦ä»”ç»†è€ƒè™‘å„ç§çº¿ç¨‹ä¹‹é—´çš„åŒæ­¥å’Œåè°ƒã€‚
- en: Debugging multithreaded applications can be challenging due to issues such as
    race conditions, deadlocks, and non-deterministic behavior, or the simple fact
    that the thread is stopped by the debugger, so upon inspecting it, no real work
    happens, and sometimes the success or failure of an application really hangs on
    the order in which the class members are declared. But for now, letâ€™s say goodbye
    to Joe and his friends. Letâ€™s hope they have got their AAAA title out on the door,
    and letâ€™s focus our attention on something else.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: è°ƒè¯•å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºå¯èƒ½å…·æœ‰æŒ‘æˆ˜æ€§ï¼Œå› ä¸ºå­˜åœ¨è¯¸å¦‚ç«äº‰æ¡ä»¶ã€æ­»é”å’Œéç¡®å®šæ€§è¡Œä¸ºç­‰é—®é¢˜ï¼Œæˆ–è€…ç®€å•çš„äº‹å®æ˜¯çº¿ç¨‹è¢«è°ƒè¯•å™¨åœæ­¢ï¼Œå› æ­¤åœ¨æ£€æŸ¥æ—¶æ²¡æœ‰å®é™…çš„å·¥ä½œå‘ç”Ÿï¼Œæœ‰æ—¶åº”ç”¨ç¨‹åºçš„æˆåŠŸæˆ–å¤±è´¥å®é™…ä¸Šå–å†³äºç±»æˆå‘˜å£°æ˜çš„é¡ºåºã€‚ä½†å°±ç›®å‰è€Œè¨€ï¼Œè®©æˆ‘ä»¬å’Œ
    Joe åŠä»–çš„æœ‹å‹ä»¬è¯´å†è§ã€‚è®©æˆ‘ä»¬å¸Œæœ›ä»–ä»¬å·²ç»å¾—åˆ°äº†ä»–ä»¬çš„ AAAA æ ‡é¢˜ï¼Œè®©æˆ‘ä»¬å°†æ³¨æ„åŠ›é›†ä¸­åœ¨å…¶ä»–äº‹æƒ…ä¸Šã€‚
- en: The dark orders of C++
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ çš„é»‘æš—ç§©åº
- en: 'There is one dark corner of the C++ language that is rarely touched by sunlight,
    and if a piece of code from these depths surfaces by any chance, a gang of hardcore
    developers immediately jumps on it and refactors it into digestible bits and bytes.
    Letâ€™s consider, for example, the very simple case of why the **a[2]** and **2[a]**
    expressions are equivalent when in C++, and **a** is an array of objects:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C++ è¯­è¨€ä¸­æœ‰ä¸€ä¸ªå¾ˆå°‘è¢«é˜³å…‰ç…§è€€çš„é˜´æš—è§’è½ï¼Œå¦‚æœè¿™äº›æ·±å±‚æ¬¡ä¸­çš„ä»£ç å¶ç„¶æµ®å‡ºæ°´é¢ï¼Œä¸€ç¾¤æ ¸å¿ƒå¼€å‘è€…ä¼šç«‹å³è·³ä¸Šå»ï¼Œå°†å…¶é‡æ„ä¸ºå¯æ¶ˆåŒ–çš„æ¯”ç‰¹å’Œå­—èŠ‚ã€‚è®©æˆ‘ä»¬ä»¥ä¸€ä¸ªéå¸¸ç®€å•çš„ä¾‹å­æ¥è€ƒè™‘ä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆåœ¨
    C++ ä¸­ï¼Œ**a[2]** å’Œ **2[a]** è¡¨è¾¾å¼æ˜¯ç­‰ä»·çš„ï¼Œå¹¶ä¸” **a** æ˜¯ä¸€ä¸ªå¯¹è±¡æ•°ç»„ï¼š
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding piece of code, despite the fact that it looks ugly, actually
    compiles. The reason is the following: in C++, the **operator []** array subscript
    is defined in terms of pointer arithmetic. The **a[i]** expression is translated
    by the compiler into ***(a + i)** , where **a** is a pointer to the first element
    of the array and **i** is the index. The **i[a]** expression at the end is also
    translated to the ***(i + a)** expression, where **i** is the index and **a**
    is the pointer to our arraysâ€™ first elements.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ä»£ç ï¼Œå°½ç®¡çœ‹èµ·æ¥å¾ˆä¸‘é™‹ï¼Œå®é™…ä¸Šæ˜¯å¯ä»¥ç¼–è¯‘çš„ã€‚åŸå› å¦‚ä¸‹ï¼šåœ¨ C++ ä¸­ï¼Œ**operator[]** æ•°ç»„ä¸‹æ ‡æ˜¯é€šè¿‡æŒ‡é’ˆç®—æœ¯å®šä¹‰çš„ã€‚**a[i]**
    è¡¨è¾¾å¼è¢«ç¼–è¯‘å™¨ç¿»è¯‘ä¸º ***(a + i)**ï¼Œå…¶ä¸­ **a** æ˜¯æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆï¼Œ**i** æ˜¯ç´¢å¼•ã€‚æœ€åçš„ **i[a]** è¡¨è¾¾å¼ä¹Ÿè¢«ç¿»è¯‘ä¸º ***(i
    + a)** è¡¨è¾¾å¼ï¼Œå…¶ä¸­ **i** æ˜¯ç´¢å¼•ï¼Œ**a** æ˜¯æˆ‘ä»¬æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆã€‚
- en: Since addition is commutative for the compiler, it does not really matter which
    comes first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå¯¹äºç¼–è¯‘å™¨æ¥è¯´åŠ æ³•æ˜¯äº¤æ¢çš„ï¼Œæ‰€ä»¥å“ªä¸ªå…ˆæ¥å¹¶ä¸é‡è¦ã€‚
- en: 'So, we have found a specific case where order doesnâ€™t really matter in C++.
    But this works only for old-style C arrays; **std::vector** and **std::array**
    do not accept this kind of out-of-order syntax. There is a very specific reasoning
    for that; the subscript operator for **std::vector** and **std::array** does not
    support the commutative behavior seen in raw arrays, namely the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬åœ¨ C++ ä¸­æ‰¾åˆ°äº†ä¸€ä¸ªç‰¹å®šçš„æ¡ˆä¾‹ï¼Œå…¶ä¸­é¡ºåºå¹¶ä¸é‡è¦ã€‚ä½†è¿™ä»…é€‚ç”¨äºæ—§å¼ C æ•°ç»„ï¼›**std::vector** å’Œ **std::array**
    ä¸æ¥å—è¿™ç§æ— åºè¯­æ³•ã€‚è¿™æœ‰ä¸€ä¸ªéå¸¸å…·ä½“çš„ç†ç”±ï¼›**std::vector** å’Œ **std::array** çš„ä¸‹æ ‡è¿ç®—ç¬¦ä¸æ”¯æŒåœ¨åŸå§‹æ•°ç»„ä¸­çœ‹åˆ°çš„äº¤æ¢è¡Œä¸ºï¼Œå³ä»¥ä¸‹å†…å®¹ï¼š
- en: '**Operator overloading** : The **operator[]** for **std::vector** and **std::array**
    is a member function, meaning it needs to be called on an instance of the class.
    It cannot be invoked with the index first, as member functions require the object
    to be on the left side of the call.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¿ç®—ç¬¦é‡è½½**ï¼šå¯¹äº **std::vector** å’Œ **std::array** çš„ **operator[]** æ˜¯ä¸€ä¸ªæˆå‘˜å‡½æ•°ï¼Œè¿™æ„å‘³ç€å®ƒéœ€è¦åœ¨ç±»çš„å®ä¾‹ä¸Šè°ƒç”¨ã€‚å®ƒä¸èƒ½é€šè¿‡ç´¢å¼•é¦–å…ˆè°ƒç”¨ï¼Œå› ä¸ºæˆå‘˜å‡½æ•°è¦æ±‚å¯¹è±¡ä½äºè°ƒç”¨å·¦ä¾§ã€‚'
- en: '**No pointer arithmetic** : The internal implementation of **std::vector**
    and **std::array** does not rely on raw pointer arithmetic for indexing. They
    manage their memory and bounds checking differently, ensuring safer access to
    elements.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ— æŒ‡é’ˆç®—æœ¯**ï¼š**std::vector** å’Œ **std::array** çš„å†…éƒ¨å®ç°ä¸ä¾èµ–äºåŸå§‹æŒ‡é’ˆç®—æœ¯è¿›è¡Œç´¢å¼•ã€‚å®ƒä»¬ä»¥ä¸åŒçš„æ–¹å¼ç®¡ç†å†…å­˜å’Œè¾¹ç•Œæ£€æŸ¥ï¼Œç¡®ä¿å¯¹å…ƒç´ çš„æ›´å®‰å…¨è®¿é—®ã€‚'
- en: 'At the current stage, the closest we can get to emulating the preceding unholy
    syntax for an object of type **std::vector** is the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å½“å‰é˜¶æ®µï¼Œæˆ‘ä»¬èƒ½å¤Ÿæœ€æ¥è¿‘æ¨¡æ‹Ÿç±»å‹ä¸º **std::vector** çš„å¯¹è±¡çš„å‰è¿°ä¸ç¥åœ£è¯­æ³•çš„ä»£ç å¦‚ä¸‹ï¼š
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After a quick examination of it, however, we, the authors (well, not actually
    both the authors, because Alex is innocent, at least concerning this code, so
    please consider this as the royal we), have decided that we are ashamed of it,
    and did not dare implement it for **std::array** or any other containers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç»è¿‡å¿«é€Ÿæ£€æŸ¥åï¼Œæˆ‘ä»¬ï¼ˆå¥½å§ï¼Œå®é™…ä¸Šå¹¶ä¸æ˜¯ä¸¤ä½ä½œè€…ï¼Œå› ä¸º Alex è‡³å°‘åœ¨è¿™æ®µä»£ç ä¸­æ˜¯æ— è¾œçš„ï¼Œæ‰€ä»¥è¯·å°†æ­¤è§†ä¸ºçš‡å®¶æˆ‘ä»¬ï¼‰ï¼Œæˆ‘ä»¬å†³å®šæˆ‘ä»¬å¯¹æ­¤æ„Ÿåˆ°ç¾æ„§ï¼Œä¸æ•¢å°†å…¶å®ç°ä¸º
    **std::array** æˆ–ä»»ä½•å…¶ä»–å®¹å™¨ã€‚
- en: 'But on a second look, we have some interesting code there. Our main goal was
    to recreate the orderless index access for vectors and arrays, but before we indulge
    ourselves in believing that it is possible, a harsh reality check: it is not.
    The reason for this is the following: if we try to compile the expression **2[vec];**
    , we get the following error:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This, translated to plain English, means the compiler cannot find an index operator
    that is applied to integers and takes in as parameter a vector of ints. As long
    as C++ is C++, this will not happen for two major reasons. The first is that **operator[]**
    needs to be a member function in a class. It is not possible to have a freestanding
    **[]** operator.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is a peculiar thing, called operator precedence. That is not an
    operator called *precedence* , but the following: in C++, the order of operations,
    also known as operator precedence, determines how operators are parsed concerning
    each other. Operators with higher precedence are evaluated before operators with
    lower precedence. When operators have the same precedence, their associativity
    determines the order of evaluation.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: While in the latest standard, [*Chapter 7*](B22235_07.xhtml#_idTextAnchor079)
    *, Expressions* (specifically the **[expr.pre]** section), mentions that â€œThe
    precedence of operators is not directly specified, but it can be derived from
    the syntaxâ€ there are official sources of information2 [2](B22235_05.xhtml#footnote-017)
    which contain the exact order of them so we really encourage you to go and dedicate
    proper time to study one of those sources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**[2](B22235_05.xhtml#footnote-017-backlink)** [https://en.cppreference.com/w/cpp/language/operator_precedence](https://en.cppreference.com/w/cpp/language/operator_precedence)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The most important question
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And now that youâ€™re back, dear reader, we are pretty sure that you can easily
    answer the following question. What is the output of the following program?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before you rush into feeding the code into your compiler, however, pause, sit
    back, and think thoroughly about what exactly is happening here. This section
    gave you all the hints, directions, and possible clues you needed in order to
    answer this correctly. We intentionally will not give the answer yet, nor a full
    explanation of the code, just a quick breakdown of whatâ€™s happening, which should
    be enough to figure it out:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the **auto a = 4;** expression, the **a** variable is declared with the **int**
    type and initialized to **4** . This is just the way **auto** and numbers work
    in modern C++.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now comes the tricky part. Parsing the code in our brain, it is obvious that
    the **sizeof(a)** expression evaluates to a **std::sizeof** type, and typically,
    **sizeof(int)** is 4 bytes on most systems. Certainly, older 16-bit systems have
    **sizeof(int)** as **2** ; some exotic systems can have **sizeof(int)** as **8**
    , but the author of these lines has never seen a system like that.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the crucial point where all our deduction has chicaned out. What kicks
    in is the operator precedence of C++. Hereâ€™s just a tiny extract from the preceding
    table, where we have kept just the parts relevant to our case:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '| **Precedence** | **Operator** | **Description** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| 1 | **::** | Scope resolution operator |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| 2 | **a++ a--** | Postfix increment and decrement |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '|  | **a()** | Function call |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '|  | **a[]** | Subscript |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| 3 | **++** **a --a** | Prefix increment and decrement |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '|  | **+** **a -a** | Unary plus and minus |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '|  | **! ~** | Logical NOT and bitwise NOT |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '|  | ***a** | Dereference |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '|  | **&a** | Address-of |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '|  | **sizeof** | Size of operator |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: Now, we can finally see that in our code, the expression **sizeof(a)** will
    never be evaluated. Due to the way the C++ compiler works, the **[]** operator
    has priority over **sizeof** , so what will be evaluated first is **(** **a)["Hello
    World"];** .
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Since in C++ **(a)** is almost always identical to **a** (except when you are
    dealing with the *most vexing parse* , but more on that at a later stage), the
    expression is identical to **sizeof** **a["Hello World"];** .
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have seen, this yields the same result as **sizeof "Hello World"[a];**
    , which, considering that today, **a** will most likely be **4** , gives us the
    character **'o'** . So, the entire expression is now reduced to **sizeof 'o'**
    , which, considering the way **sizeof** works, will always return **1** .
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We, the authors, think that at this stage, the answer to our question is obvious.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: When order does not matter
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one tiny thing we ought not to forget to mention before closing this
    chapter. Well, actually two. The first one is that in C++, the order in which
    function arguments are evaluated is unspecified. This means that when you call
    a function with multiple arguments, the compiler is free to evaluate the arguments
    in any order it chooses. This can lead to unexpected results if the arguments
    have side effects, such as modifying a variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s take, for example, the following program:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Regardless of what you think the output of this program is, it will be wrong.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is, again, as mentioned previously: the order of evaluation
    of the parameters is not specified. With good reason, you may ask, why? The reasons
    for this are a bit more complex and historical. But before delving deeper into
    that, letâ€™s amuse ourselves with the output that various compilers provide us
    with, courtesy of gcc.godbolt.org and some other sources.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compiler** | **Output** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| Microsoft Visual C++ ( after 2005) | **a=1** **b=1 c=1****f=3****i=4** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| Microsoft VS.NET 2003 | **a=3** **b=2 c=1****f=6****i=4** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| Microsoft Visual C++ 6 | **a=1** **b=1 c=1****f=3****i=4** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| ICC and Clang agree on thisâ€¦ | **f=a=1** **b=2 c=3****6****i=4** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| GCC, after 6.5 | **f=a=3** **b=2 c=1****6****i=4** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| GCC, before 6.5 | **a=3** **b=2 c=1****f=6****i=4** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| Turbo C Lite and Borland C++55 | **a=3** **b=2 c=1****f=6****i=1** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: So, we have a plethora of options to choose from, some more straightforward
    and others more exotic. All these weird values claim they are the right one, the
    one to rule them all, regardless of the fact that even different versions of the
    same compiler from the same provider provide different results. And they are all
    right in their belief.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Quite simply, the reasoning is that allowing the compiler the freedom to choose
    the order of evaluation enables it to make optimizations that can improve performance
    that we programmers may not notice. The compiler can reorder instructions to take
    advantage of CPU pipelines, minimize register usage, and enhance cache efficiency.
    Specifying a strict order would limit these optimization opportunities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Different hardware architectures may have different optimal evaluation strategies.
    By not specifying the order of evaluation, C++ code can be more easily optimized
    for a wide variety of architectures without requiring changes to the code itself.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Also, by not specifying the order of evaluation, the C++ language specification
    remains simpler. Specifying a strict order for all expressions would add complexity
    to the language definition and increase the burden on compiler developers. Not
    to mention that the current standard is almost 2,000 pages long, so maybe it is
    a good idea not to add several hundred pages detailing the complexities of the
    order of parameter evaluations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we promised to mention at the beginning of this section, however,
    comes up: while operator precedence and associativity dictate how expressions
    are grouped and parsed, they do not dictate the order of evaluation. This means
    that even though you know how expressions will be grouped, the actual order in
    which parts of the expression are evaluated can still vary.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s consider the following short application:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is really short â€“ it couldnâ€™t be shorter â€“ and it contains some quite nasty
    code, especially looking at **++i + i++** . That piece of code is so nasty that
    the compilers cannot really agree in which order to execute it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Some of them choose to execute **++i** (making **i** be **5** and also using
    it as the left side of the addition) first, and then **i++** (which will be using
    the new value of **i** , which was incremented already, then incrementing it again
    to reach **6** , but due to the way post-increment works, the value of **5** will
    be used for the right-hand side of the addition), and then assigning this value
    back to **i** . So, thatâ€™s 5 + 5 = 10.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: However, other compilers decide to execute **i++** first, thus keeping the value
    **4** on the right-hand side of the operation, while also incrementing the value
    of **i** to **6** . Now, **++i** is evaluated, which already sees the incremented
    value of **6** , decides to use it, and then increments it, thus obtaining **7**
    for the left-hand side of the addition. Thus, this will give 7 + 4 = 11.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, thinking a bit back, not having the evaluation order specified encourages
    developers aware of this uncanny feature to write code that does not expect specific
    evaluation orders. This can lead to more robust and portable code, as developers
    must avoid unintended dependencies on evaluation order. As such, the correct fix
    for the preceding situation would be some code along the lines of the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œç¨å¾®å›é¡¾ä¸€ä¸‹ï¼Œæ²¡æœ‰æŒ‡å®šè¯„ä¼°é¡ºåºä¼šé¼“åŠ±å¼€å‘è€…æ„è¯†åˆ°è¿™ä¸€å¥‡ç‰¹ç‰¹æ€§ï¼Œç¼–å†™ä¸æœŸæœ›ç‰¹å®šè¯„ä¼°é¡ºåºçš„ä»£ç ã€‚è¿™å¯ä»¥å¯¼è‡´æ›´å¥å£®å’Œå¯ç§»æ¤çš„ä»£ç ï¼Œå› ä¸ºå¼€å‘è€…å¿…é¡»é¿å…å¯¹è¯„ä¼°é¡ºåºçš„ä¸å½“ä¾èµ–ã€‚å› æ­¤ï¼Œå¯¹å‰è¿°æƒ…å†µçš„æ­£ç¡®ä¿®å¤å°†æ˜¯ä¸€äº›ç±»ä¼¼äºä»¥ä¸‹å†…å®¹çš„ä»£ç ï¼š
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While this might be a rare situation, because the preceding code is a bit artificial,
    it is an issue, especially still if we are dealing with situations like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™å¯èƒ½æ˜¯ç½•è§çš„æƒ…å†µï¼Œå› ä¸ºå‰é¢çš„ä»£ç æœ‰ç‚¹äººä¸ºï¼Œä½†è¿™ç¡®å®æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œå°¤å…¶æ˜¯å¦‚æœæˆ‘ä»¬å¤„ç†çš„æ˜¯ä»¥ä¸‹æƒ…å†µï¼š
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The value of **result** will be **3** regardless, but the output, depending
    on how the compiler decides to execute the two function calls, can be either **"fg"**
    or **"gf"** .
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**result**çš„å€¼æ— è®ºå¦‚ä½•éƒ½å°†ä¸º**3**ï¼Œä½†è¾“å‡ºå°†å–å†³äºç¼–è¯‘å™¨å¦‚ä½•å†³å®šæ‰§è¡Œä¸¤ä¸ªå‡½æ•°è°ƒç”¨ï¼Œå¯ä»¥æ˜¯**"fg"**æˆ–**"gf"**ã€‚'
- en: With all this in mind, we may think that we understand everything about ordering
    in C++. While in this chapter we have tried to cover all possible implications,
    we cannot promise that you will not find anything out of order. C++ is a language
    with a very wide scope and peculiar syntax, so if someone really wanted to, they
    could step on the toes of some compilers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘åˆ°æ‰€æœ‰è¿™äº›ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè®¤ä¸ºæˆ‘ä»¬å·²ç»äº†è§£äº†C++ä¸­å…³äºé¡ºåºçš„æ‰€æœ‰å†…å®¹ã€‚è™½ç„¶åœ¨æœ¬ç« ä¸­æˆ‘ä»¬è¯•å›¾æ¶µç›–æ‰€æœ‰å¯èƒ½çš„åæœï¼Œä½†æˆ‘ä»¬ä¸èƒ½ä¿è¯æ‚¨ä¸ä¼šå‘ç°ä»»ä½•é¡ºåºæ··ä¹±çš„æƒ…å†µã€‚C++æ˜¯ä¸€ç§å…·æœ‰éå¸¸å¹¿æ³›èŒƒå›´å’Œç‹¬ç‰¹è¯­æ³•çš„è¯­è¨€ï¼Œæ‰€ä»¥å¦‚æœæœ‰äººçœŸçš„æƒ³çš„è¯ï¼Œä»–ä»¬å¯èƒ½ä¼šè§¦åŠæŸäº›ç¼–è¯‘å™¨çš„ç—›è„šã€‚
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: With this chapter, we hope you have grasped the critical importance of following
    the specified order of everything C++-related to ensure predictable and error-free
    code execution. You should also understand the importance of not having a specified
    order of execution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æœ¬ç« ï¼Œæˆ‘ä»¬å¸Œæœ›æ‚¨å·²ç»æŒæ¡äº†éµå¾ªæ‰€æœ‰ä¸C++ç›¸å…³å†…å®¹æŒ‡å®šé¡ºåºçš„é‡è¦æ€§ï¼Œä»¥ç¡®ä¿ä»£ç æ‰§è¡Œçš„é¢„æµ‹æ€§å’Œæ— é”™è¯¯ã€‚æ‚¨è¿˜åº”è¯¥ç†è§£æ²¡æœ‰æŒ‡å®šæ‰§è¡Œé¡ºåºçš„é‡è¦æ€§ã€‚
- en: With this in mind, we encourage you to go and experiment with the online playground
    offered by Compiler Explorer. It offers a large collection of compilers. Just
    bear in mind that if two compilers have generated different results for the code
    you wrote, then maybe you have ventured into unspecified/undefined behavior territory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬é¼“åŠ±æ‚¨å»å°è¯•ä½¿ç”¨Compiler Exploreræä¾›çš„åœ¨çº¿æ¸¸ä¹åœºã€‚å®ƒæä¾›äº†ä¸€å¤§æ‰¹ç¼–è¯‘å™¨ã€‚åªéœ€è®°ä½ï¼Œå¦‚æœæ‚¨ç¼–å†™çš„ä»£ç åœ¨ä¸¤ä¸ªç¼–è¯‘å™¨ä¸Šç”Ÿæˆäº†ä¸åŒçš„ç»“æœï¼Œé‚£ä¹ˆæ‚¨å¯èƒ½å·²ç»è¿›å…¥äº†æœªæŒ‡å®š/æœªå®šä¹‰è¡Œä¸ºçš„é¢†åŸŸã€‚
- en: The next chapter explores the challenges of memory management in C++.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€ç« å°†æ¢è®¨C++ä¸­å†…å­˜ç®¡ç†çš„æŒ‘æˆ˜ã€‚
