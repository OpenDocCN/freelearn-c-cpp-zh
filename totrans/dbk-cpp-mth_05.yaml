- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a C++ Class, Order Must There Be
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*When law and order* *kill creativity*'
  prefs: []
  type: TYPE_NORMAL
- en: Ordering items is essential across various domains to ensure organization, efficiency,
    and clarity. Whether in libraries or contact lists through alphabetical ordering,
    customer service queues or data analysis with numerical sorting, timelines or
    appointments by chronology, task management or emergency response prioritization,
    inventory or digital file categorization, competition rankings, clothing size
    arrangement, geographical routing in travel or mail delivery, sequential steps
    in manufacturing or software development, or hierarchical structuring in organizations
    and biological taxonomies, ordering helps streamline processes, improve accessibility,
    and enhance decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: By applying different criteria, such as alphabetical, numerical, chronological,
    priority, categorical, ranking, size, geographical, sequential, or hierarchical,
    ordering facilitates better management and optimal functioning in diverse contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore why it is important to have a specific order
    for members of a C++ class and what we can gain and lose when properly or improperly
    declaring the members of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will get a quick overview of what the order of operations is in C++,
    because that is a topic that to some extent can be quite confusing, even for more
    advanced programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of properly declaring class members in a specific order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of initializing your class members in the required order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proper order of operation executions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size does matter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned in school about the alphabet, that puts all letters in a specific
    order, like A, B, C if you are English, or A, ƒÇ, √Ç if you‚Äôre Romanian (yes, there
    are a surprisingly large number of variations to the letter A at the beginning
    of the Romanian alphabet). Not everyone alive today is sure about the reasoning
    of the order, but since todays‚Äô alphabets are based on older ones, such as Œë,
    Œí, Œì for the Greeks or ìÄÄ, ìÅê, ìÅ£ and even ìÅ∑ for our Ancient Egyptian ancestors,
    we can‚Äôt really be sure why this succession of characters has emerged.
  prefs: []
  type: TYPE_NORMAL
- en: The alphabet is a very handy thing; it helps us organize and categorize everything
    that can be named. From insects, with ants being categorized before bees, through
    to the spices in your cupboard (except if you organize yours based on color or,
    even better, usage frequency‚Ä¶ poor dear Zimbabwean mufushwa, you‚Äôll stay in the
    back for now), it helps us greatly in keeping our daily lives neat and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Before we venture too off topic, however, let‚Äôs remember that this is a book
    about programming (more specifically, C++ programming), and thus we need to keep
    focused on our subject, and not get distracted talking about the bees and the
    birds (bees come before birds alphabetically, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Organizing C++ concepts can, however, be a very daunting topic. By *concepts*
    , I mean functions, classes, and variables, and not the very handy feature called
    concepts introduced in C++20, which sadly is not the topic of this book.
  prefs: []
  type: TYPE_NORMAL
- en: You can‚Äôt really do it the way you want, because some functions need to see
    other functions and some blocks of code need to access variables that you have
    to make sure were defined before them. So, carefully crafting a C++ program can
    be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Things change, however, when the discussion turns to C++ classes. You see, in
    a class, these visibility-related annoyances do not really matter. All the methods
    of a class see all the other methods of that class, and all member functions can
    be directly accessed in all the member functions, so life in a class is easy‚Ä¶
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, dear C++ disciple, I hear you cry, ‚ÄúBut you should never call the destructor
    or the constructor of a class from within the class!‚Äù I mostly agree, but there‚Äôs
    nothing stopping me from writing a method such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you write code like this, dear reader, you will suffer the consequences.
    But back to our initial topic: ordering.'
  prefs: []
  type: TYPE_NORMAL
- en: Inherently, the human mind craves order. We need to be able to have an overview
    of what we are working with, where that information is, and how to locate it as
    easily as possible. It is imperative to easily and quickly find the required information,
    even if it is as insignificant as the whereabouts of a member of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after endless struggles with locating lost members of a class, it came
    as a revelation to one game programmer (let‚Äôs call him Joe) who was happily working
    at the BigGameDev company that all the members of the class should be organized
    in alphabetical order. Brilliant, now everyone can easily locate where their required
    member is. And look how beautiful the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is not a particularly complicated use case; it is just a point in some
    game that tells us where a point is, by providing *x* , *y* , and *z* coordinates,
    and it gives a small insight into the workings of the point, to tell us whether
    that specific point is active or not. Life is good. The game runs neatly, and
    the players are happy.
  prefs: []
  type: TYPE_NORMAL
- en: However, at some point, the lead programmer of the game project thinks that
    some operations on that point take up too much time (I‚Äôll spare you all the quirky
    details of what operations those are and why they need it) and those operations
    should be performed only if the point has recorded a change of values in all three
    coordinates. Joe, our programmer, is a good and very methodic programmer, and
    he knows that one solution would be to store three other **double** values, representing
    the previous *x* , *y* , and *z* coordinates, update those on change, if any,
    and perform the requested operation only if the values differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, he discards that idea and quickly concocts a different one: he will
    keep a **bool** flag for recording the change of each required coordinate, since
    he knows that a **bool** usually takes up only 1 byte, while a double on their
    platform boasts up to 8 bytes. That is a saving of‚Ä¶ well, 21 bytes. So, here is
    Joe‚Äôs new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Beautiful ‚Äì as with all the code he writes, it‚Äôs almost like poetry. He submits
    the newly written piece of code to the repository, where it will be built overnight,
    and the freshly baked binary will be delivered for testing the next day. And then
    he does not go on vacation, because he is a diligent programmer; summer is still
    some time away, so he will wait for the testing team to approve the code before
    booking plane tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Overnight, the automated tests explode, every suite fails, and the entire dashboard
    is red like the flag of some communist country. The next day, the entire testing
    department faces fatal failures, the game crashes, and 99.9% of the errors at
    some point relate to out-of-memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: The application suddenly consumes almost double the memory it was expected to
    consume, the test machines struggle to keep the desired frame rate, and everything
    is slowed down, except the memory allocation checks, which steadily show that
    the application now uses a lot more than yesterday.
  prefs: []
  type: TYPE_NORMAL
- en: There were not too many changes, besides Joe‚Äôs own point class overhaul; some
    other developer had changed the background color in the main menu from dark gray
    to black (sadly, the developer who was supposed to implement the ground-breaking
    change that requested Joe‚Äôs change had to stay at home with a sick child that
    day), so the development team gathers to discuss the newly found issue.
  prefs: []
  type: TYPE_NORMAL
- en: The lead developer (let‚Äôs call him Jimmy for his mastery in the programming
    languages) takes a look at the code and quickly proclaims, ‚ÄúJoe, mate, I really
    appreciate the neatness of your code, and that you organize the members alphabetically,
    but I will have to kindly ask you to change the order of them.‚Äù
  prefs: []
  type: TYPE_NORMAL
- en: Joe turns almost as red as the test failure indicators on the continuous integration
    monitoring screen, but since he is a reasonable person, he kindly asks why on
    Earth he should do that. Doesn‚Äôt Jimmy see the beauty in the code?!
  prefs: []
  type: TYPE_NORMAL
- en: The response from Jimmy stuns him. This is Jimmy‚Äôs explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The memory layout of a C++ class is determined by several factors, including
    the size and alignment requirements of its members, the inheritance hierarchy,
    and padding added by the compiler to satisfy alignment constraints. When talking
    about size, each data member occupies a certain number of bytes based on its type.
  prefs: []
  type: TYPE_NORMAL
- en: I‚Äôm sure Joe was aware of this; however, what he might not have grasped entirely,
    looking at his solution, is the alignment of each member. Each data member must
    be stored at a memory address that is a multiple of its alignment requirement.
    The alignment requirement is typically the size of the type, but it can be adjusted
    with compiler-specific directives.
  prefs: []
  type: TYPE_NORMAL
- en: Now, looking at padding, in order to satisfy these alignment constraints, the
    compiler may insert padding bytes between members, and to ensure the size of the
    class is a multiple of the largest alignment requirement, padding may be added
    at the end of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the class that the team had initially might have looked like the following
    when it was set up in memory, knowing that on their architecture, the size of
    a double is 8 bytes long:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 ‚Äì The initial class layout](img/B22235_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 ‚Äì The initial class layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this alignment, the size of the class added up being 32 bytes. But now
    that Joe has have added three more **bool** s, each 1 byte long, the compiler
    might have organized the memory according to the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 ‚Äì The class layout with the new members in the wrong order](img/B22235_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 ‚Äì The class layout with the new members in the wrong order
  prefs: []
  type: TYPE_NORMAL
- en: 'So, each byte of **bool** must have been padded up to 8 bytes, in order to
    allow the placement of the double that follows to the proper memory address. This
    made the size of the class grow to 56, because 4 **bool** s padded up to 8 bytes
    plus 3 **double** values, each of them 8 bytes, so the sum of these takes up a
    total of 56 bytes. Clang, the compiler, has a switch that allows us to inspect
    the memory layout of generated classes: **-fdump-record-layouts** . In order to
    put it into good use for this case, we have created a simple source file with
    the previous class definition and passed it down to the compiler in order to inspect
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding data clearly denotes what we suspected initially, that is, that
    the **bool** that was supposed to take 1 byte now officially occupies 8 (note
    that behind the scenes, we have created a file called **main.cpp** with the content
    of the **point** structure).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to straighten out this unfortunate situation, we clearly need
    to take some further actions, so let‚Äôs consider the reorganization of the members
    of the class in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is not a huge change, besides hurting Joe‚Äôs feelings that the members are
    not organized alphabetically. We have grouped together the **bool** values so
    the class is as compact as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the preceding information, especially taking into consideration
    the size requirements of each of the types, and concluded that it is always better
    to have small types grouped together (by *small types* , we mean variables whose
    type will take up the smallest number of bytes; for example, we know that the
    size of a **bool** variable is 1, at least for the implementation we are using).
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, that is, by reorganizing the order in which the members are
    presented, we have created the following memory layout (or something similar but
    more optimal for our architecture):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 ‚Äì The class layout with the members in the proper order](img/B22235_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 ‚Äì The class layout with the members in the proper order
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, after checking with Clang again, the memory of the class looks very
    different from the previous version (please again ignore the fact that behind
    the scenes, we have modified our **main.cpp** to contain the preceding structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, as we can see now, the four **bool** values are placed in memory one after
    the other, and there is only one section of padding required to fill up the required
    space, for the **double** values to be aligned on the required memory addresses.
    Hypothetically, if we were to have a field with a size of **4** , we could nicely
    fit it after the last **bool** , before the first **double** , and we would not
    need any padding either.
  prefs: []
  type: TYPE_NORMAL
- en: Upon hearing Jimmy‚Äôs explanation, Joe now understood the issue. He had never
    encountered alignment issues before, but he decided to read up on the subject.
    What he read was very interesting.
  prefs: []
  type: TYPE_NORMAL
- en: It explained that the alignment of variables in memory is necessary due to a
    combination of hardware requirements, performance optimization, and architectural
    constraints. Most modern processors are designed to access memory more efficiently
    when data is aligned to certain boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an 8-byte double is typically best accessed at an address that
    is a multiple of 8, and when data is misaligned, the processor may need to perform
    multiple memory accesses to read or write the data, which can be significantly
    slower.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some architectures, such as the older generation of ARM processors, PowerPC,
    and older MIPS processors, cannot properly handle misaligned access, and in these
    situations, they generate a **SIGBUS** fault, which results in the early termination
    of the application causing the fault. So, for example, the following application,
    when compiled, and the resulting binary executed on a processor of this generation
    will generate a **SIGBUS** fault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The outcome of this highly unpleasant situation on an operating system not prepared
    to handle a misalignment error very often has quite drastic ramifications, such
    as an application crash. Older systems may even produce a system crash.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 ‚Äì Older system throwing a tantrum when seeing unaligned data](img/B22235_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 ‚Äì Older system throwing a tantrum when seeing unaligned data
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask what **error type 7** means. The answer is simple: 7 is the magic
    number that was assigned to the **SIGBUS** error. On the author‚Äôs Linux machine,
    it can be found in **/usr/include/x86_64-linux-gnu/bits/signum-arch.h** , on line
    34:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Some other processors, such as the newer generation x86_64 processors, or even
    the older 80286 (and everything between, mostly adhering to the specifications
    of the x86 platform and beyond), handle these situations very gracefully, with
    a tiny time penalty concerning performance, but they can be easily convinced with
    the following assembly instructions to turn into a very moody persona of themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **AT&T (** **64 bit)** | **Intel (** **32 bit)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **pushf****orl $0x40000,(%rsp)****popf** | **pushfd****or dword ptr [** **esp],
    40000h****popfd** |'
  prefs: []
  type: TYPE_TB
- en: The code above modifies specific bits in the **EFLAGS** register using a bitwise
    OR operation. Specifically, the hexadecimal value **40000h** corresponds to setting
    the **AC** (which stands for alignment check) flag in the **EFLAGS** register,
    this flag is used to control alignment checking. When this flag is set and the
    **AM** (which stands for alignment mask) bit in the **CR0** register is also set,
    the processor checks whether data is aligned on natural boundaries. If data misalignment
    is detected, a fault is generated.
  prefs: []
  type: TYPE_NORMAL
- en: The **EFLAGS** register is a special-purpose register used in x86 architecture
    CPUs that contains several flags reflecting the state of the processor. These
    flags can control or indicate various conditions, such as arithmetic conditions,
    control features, and system settings. The Intel developer center [1](B22235_05.xhtml#footnote-018)
    contains a plethora of information concerning these low-level programming features.
    We encourage anyone interested in this subject to go and browse that site for
    further information.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](B22235_05.xhtml#footnote-018-backlink) [https://www.intel.com/content/www/us/en/resources-documentation/developer.html](https://www.intel.com/content/www/us/en/resources-documentation/developer.html)'
  prefs: []
  type: TYPE_NORMAL
- en: When the previous code is inserted into the source code of an application, we
    can see the **SIGBUS** signal in action. We‚Äôll spare listing that code here, because
    no one should write code that intentionally crashes their application, but instead
    let‚Äôs examine another one of our friend Joe‚Äôs encounters with the curiously occurring
    ordering of class members.
  prefs: []
  type: TYPE_NORMAL
- en: The order that must be respected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working at BigGameDev, Joe was given another task that was vaguely related
    to character development ‚Äì in-game characters, that is, not his own character.
    The task was an easy one: it just required returning a formatted string that expressed
    the value of life points a character has.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this, Joe created the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is as straightforward as it can be. It just takes the input data and stores
    the result in case one needs to access it again. Joe is very happy; the class
    members are organized nicely by type, but he is not sticking to alphabetical order
    anymore (he learned his lesson from the alignment discussion). He even uses modern
    C++, such as the format library or in-class initialization of members, in case
    some are not initialized (we could argue, though, that the strings are initialized
    to an empty string upon creation with the default constructor, so for them, this
    is not as relevant. This isn‚Äôt the case for the **int** s), and he is generally
    happy with the code he has written.
  prefs: []
  type: TYPE_NORMAL
- en: 'He would happily commit these into their repository right away, but common
    sense prevails. He does some quick tests, and after ensuring that everything works
    as expected, he asks his supervisor (the same Jimmy to whom we were introduced
    in the previous section) to do a quick review of the code. The code looks OK;
    it compiles and performs the required operations, and there are just two tiny
    observations that are to be added. Joe is given the following feedback: instead
    of doing the assignment of the members in the body of the constructor, an initializer
    list should be used instead. In addition, since he is going to use initializer
    lists anyway, he should make the members const, for some minor optimizations that
    the compiler might decide to throw in at some stage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, he should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++, using an initialization list in constructors is generally preferred
    over in-body initialization due to several key advantages: it is more efficient
    since it initializes member variables directly rather than initializing them by
    default and then assigning them. Also, it ensures proper initialization of **const**
    and reference members, which cannot be dealt with properly in the body of the
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Joe happily changes the code, and since not that much has changed, he ‚Äúforgets‚Äù
    to test it. Instead, he quickly submits the following sequence to review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A response does not take too long to arrive and is surprisingly not the pat
    on the back he expected.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ÄúJoe, did you test this code?‚Äù
  prefs: []
  type: TYPE_NORMAL
- en: He has to admit that he did not consider it necessary, since not that much had
    changed. He just moved a few lines a bit above their previous positions, changed
    an equal sign to a pair of parentheses, and he was done with it.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ÄúOh, I see‚Ä¶‚Äù said Jimmy, and he pulled out a fresh hardcopy of the latest available
    C++ standard from his back pocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard says the following, in the **[** **class.base.init]** section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a non-delegating constructor, initialization proceeds in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: First, and only for the constructor of the most derived class, virtual base
    classes are initialized in the order they appear on a depth-first left-to-right
    traversal of the directed acyclic graph of base classes, where ‚Äúleft-to-right‚Äù
    is the order of appearance of the base classes in the derived class base-specifier-list.
  prefs: []
  type: TYPE_NORMAL
- en: Then, direct base classes are initialized in declaration order as they appear
    in the base-specifier-list (regardless of the order of the mem-initializers).
  prefs: []
  type: TYPE_NORMAL
- en: Then, non-static data members are initialized in the order they were declared
    in the class definition (again regardless of the order of the mem-initializers).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the compound-statement of the constructor body is executed.
  prefs: []
  type: TYPE_NORMAL
- en: This in practice means that regardless of the order in which you specified the
    members to be initialized in the initializer list, they still will be initialized
    in the order they were declared in the class, so **m_result** will be the first
    one to be initialized, and since it is using the other two data members, which
    have not been initialized yet, the result in the best case will be undefined behavior.
    In the worst case, during testing, you will get default values, and in production,
    the code will fail spectacularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, armed with this knowledge, Joe was finally able to deliver the code that
    was expected of him, on time and to the highest possible standard he could implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: He learned that while using initializer lists can be a godsend in certain situations,
    it can also throw your code to the mythical depths of the seven circles of compiler
    hell when not taking into consideration some basic rules that are set by the C++
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standard makes it mandatory that member objects are initialized in the
    order they are declared within the class, regardless of the order specified in
    the constructor initializer list, because what happens if there is no initializer
    list, or if only some elements are initialized in it?
  prefs: []
  type: TYPE_NORMAL
- en: This order ensures consistency and predictability in the setup process of an
    object. When an object is constructed, initializing members in declaration order
    helps avoid potential issues that could arise if members were initialized out
    of order, especially if some members depend on others being initialized first.
  prefs: []
  type: TYPE_NORMAL
- en: This mandated order of initialization directly influences the destruction order,
    which is the reverse of initialization. Ensuring that members are destroyed in
    the reverse order of their initialization guarantees that dependent members are
    still valid when they are needed during the destruction phase. This consistent
    and predictable cleanup process prevents potential errors and maintains the integrity
    of the object‚Äôs life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on this requirement of the language, we can easily provide an elegant
    and more concise solution to this problem, by using an interesting feature called
    **designated initializers** , which was introduced in C++20. Let‚Äôs simplify our
    structure to look along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These simple structures satisfy the requirements to be used as aggregates,
    which are required for the designated initializer feature to compile, and as you
    can see, the **m_result** member is using the already-initialized **m_player**
    and **m_points** members, during the construction of itself. Now, in the place
    where want to use the class, we just have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By adhering to this handy feature, we have explicitly specified which member
    should be initialized to which value (this can be very helpful if, for example,
    there are more than two integers that need to be initialized). Also, the feature
    requires the members to be specified in the order of their declaration, thus increasing
    the readability and maintainability of the code. The only drawback is that we
    had to dumb down our class to an **aggregate** , so no virtual functions, no constructors,
    no encapsulation ‚Äì none of the good stuff that raises a C++ class to mythical
    fame. But if it‚Äôs good enough for Joe, we can live with it.
  prefs: []
  type: TYPE_NORMAL
- en: Deep thoughts about order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The adventures of our friend Joe do not end here, because shortly after learning
    that the proper order of class members is not necessarily an alphabetical one,
    he was given a task that involved executing some code in a parallel manner. Since
    he learned everything about threads and associated features by watching a quick
    introductory tutorial to the subject by some guy on TikTok, he felt he was up
    to the task, and shortly, the following code was committed to the repository (please
    bear with the authors in this case; due to some pathological manifestations of
    copyright and intellectual property litigations, we cannot show the original code
    that took the entire development team two weeks to debug and fix. The example
    code is actually just trying to recreate the scenario that Joe so successfully
    implemented):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The given C++ program tries to get as close as possible to the simple multithreaded
    mayhem Joe created, using two friendly structures, named **bar** and **foo** (we
    let **baz** take a rest for a short while, but if you miss him, you can name the
    function **baz** ), creating a meaningful interaction in order to perform a task
    on a separate thread. The **bar** structure manages a dynamically allocated **long
    long** variable, **i** (because what else would we call a variable that has the
    role of an index?), which is continuously incremented in its **serve** method.
    When the increment count reaches **1024768** (let‚Äôs just ignore the fact that
    1024x768 is also a screen resolution), then it pauses for 200 milliseconds, resets
    the counter **i** to **0** , and prints a dot to the console (in the real-life
    application, something else happened, but that is out of the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: This loop continues indefinitely until **stopRequest** is set to **true** ,
    signaling the thread to exit. The constructor of **bar** initializes the counter
    **i** , and for our sole purpose of debugging, it prints a message, while the
    destructor handles memory cleanup and prints another message, ensuring that resources
    are properly managed. Why Joe does not use a smart pointer is another story, so
    let‚Äôs not focus on that part for now.
  prefs: []
  type: TYPE_NORMAL
- en: The **foo** structure is responsible for starting and stopping the thread that
    runs the **serve** method of a **bar** instance. Upon creation, **foo** initializes
    a **std::jthread** to run its **threadFunc** , which in turn calls the **serve**
    method of its **bar** instance. This setup allows the **serve** method to run
    concurrently with the **main** program. The **foo** destructor sets **stopRequest**
    to **true** , ensuring the thread exits gracefully. Again, it remained a mystery
    why Joe decided to pick this way of gracefully ending the thread, but since it
    worked (after the already-mentioned two weeks of debugging and troubleshooting
    sessions), the engineering team decided not to ever mention this sequence of code.
  prefs: []
  type: TYPE_NORMAL
- en: In the **main** function, an instance of **foo** is created, starting the thread
    upon its creation, and the program sleeps for two seconds to allow the thread
    to run. For brevity, let‚Äôs just assume that in the original application, there
    was no mention of any kind of sleeping; the real beauty of the solution came from
    some lengthy operations performed in the **main** and **bar** threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dear seasoned C++ programmers: please do not focus on how this synthetic piece
    of code is handling the thread synchronization, or the fact that it allocates
    and releases memory, because that is not the purpose of it. The sole purpose of
    this code is to crash. For **std::jthread** , there are plenty of mechanisms to
    properly handle the execution, such as **std::stop_source** and **std::stop_token**
    , so please feel free to read up on them and let Joe suffer with his naive approach
    to threading for now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code is executed, the following is the result, at least on the author‚Äôs
    Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, sometimes the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The same happened to Joe too. Occasionally, the application would go haywire
    and crash upon exit. Initially, this was not too much of a hassle because, well,
    if the application crashes at the end, that‚Äôs not the end of it. However, after
    a while, the code Joe wrote was introduced in a larger module, and that‚Äôs where
    chaos, mayhem, and the aforementioned two weeks of debugging sessions materialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the misdemeanor is quite simple. Jimmy, the master programmer
    discovered after consulting his pocket version of the C++ standard, specifically
    the **[class.dtor]** section of it:'
  prefs: []
  type: TYPE_NORMAL
- en: After executing the body of the destructor and destroying any objects with automatic
    storage duration allocated within the body, a destructor for class X calls the
    destructors for X‚Äôs direct non-variant non-static data members, the destructors
    for X‚Äôs non-virtual direct base classes and, if X is the most derived class, its
    destructor calls the destructors for X‚Äôs virtual base classes. All destructors
    are called as if they were referenced with a qualified name, that is, ignoring
    any possible virtual overriding destructors in more derived classes. Bases and
    members are destroyed in the reverse order of the completion of their constructor.
    A return statement in a destructor might not directly return to the caller; before
    transferring control to the caller, the destructors for the members and bases
    are called. Destructors for elements of an array are called in reverse order of
    their construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is that the objects are destroyed in reverse order of their creation,
    just like they would have been pushed onto a stack upon creation and popped off
    with grace in the reverse order upon destruction. The culprits for the erroneous
    behavior were quickly identified as being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**std::jthread thread;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**bar b;**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happened here upon construction was that the thread was created and
    started running its thread method: **void threadFunc() { b.serve(); }** . Only
    after this unpredictable operation was initiated was the **bar b** object created.
    Then, upon exit, as per the design of the C++ language, the **bar b** object was
    deleted and its resources freed. While the thread was still possibly being blocked
    in the long operation, suddenly it was running on an object that was already deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The delay between the creation of the thread object, the actual starting of
    the thread routine, and the creation of the **bar b** object is so insignificant
    that catching the error in the creation phase is almost implausible. But let‚Äôs
    modify the constructor of **bar** to be along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In an instant, we can see how the thread is running on an object whose creation
    was not entirely finished by the time the thread started using it. Certainly,
    this specific issue can be resolved easily, by simply switching the order of the
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Threading is an interesting aspect of C++. While it comes with many benefits,
    it also introduces extra complexity. Properly writing correct and efficient multithreaded
    code requires careful consideration of synchronization and coordination between
    various threads.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging multithreaded applications can be challenging due to issues such as
    race conditions, deadlocks, and non-deterministic behavior, or the simple fact
    that the thread is stopped by the debugger, so upon inspecting it, no real work
    happens, and sometimes the success or failure of an application really hangs on
    the order in which the class members are declared. But for now, let‚Äôs say goodbye
    to Joe and his friends. Let‚Äôs hope they have got their AAAA title out on the door,
    and let‚Äôs focus our attention on something else.
  prefs: []
  type: TYPE_NORMAL
- en: The dark orders of C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one dark corner of the C++ language that is rarely touched by sunlight,
    and if a piece of code from these depths surfaces by any chance, a gang of hardcore
    developers immediately jumps on it and refactors it into digestible bits and bytes.
    Let‚Äôs consider, for example, the very simple case of why the **a[2]** and **2[a]**
    expressions are equivalent when in C++, and **a** is an array of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding piece of code, despite the fact that it looks ugly, actually
    compiles. The reason is the following: in C++, the **operator []** array subscript
    is defined in terms of pointer arithmetic. The **a[i]** expression is translated
    by the compiler into ***(a + i)** , where **a** is a pointer to the first element
    of the array and **i** is the index. The **i[a]** expression at the end is also
    translated to the ***(i + a)** expression, where **i** is the index and **a**
    is the pointer to our arrays‚Äô first elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Since addition is commutative for the compiler, it does not really matter which
    comes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have found a specific case where order doesn‚Äôt really matter in C++.
    But this works only for old-style C arrays; **std::vector** and **std::array**
    do not accept this kind of out-of-order syntax. There is a very specific reasoning
    for that; the subscript operator for **std::vector** and **std::array** does not
    support the commutative behavior seen in raw arrays, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operator overloading** : The **operator[]** for **std::vector** and **std::array**
    is a member function, meaning it needs to be called on an instance of the class.
    It cannot be invoked with the index first, as member functions require the object
    to be on the left side of the call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No pointer arithmetic** : The internal implementation of **std::vector**
    and **std::array** does not rely on raw pointer arithmetic for indexing. They
    manage their memory and bounds checking differently, ensuring safer access to
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the current stage, the closest we can get to emulating the preceding unholy
    syntax for an object of type **std::vector** is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After a quick examination of it, however, we, the authors (well, not actually
    both the authors, because Alex is innocent, at least concerning this code, so
    please consider this as the royal we), have decided that we are ashamed of it,
    and did not dare implement it for **std::array** or any other containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'But on a second look, we have some interesting code there. Our main goal was
    to recreate the orderless index access for vectors and arrays, but before we indulge
    ourselves in believing that it is possible, a harsh reality check: it is not.
    The reason for this is the following: if we try to compile the expression **2[vec];**
    , we get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This, translated to plain English, means the compiler cannot find an index operator
    that is applied to integers and takes in as parameter a vector of ints. As long
    as C++ is C++, this will not happen for two major reasons. The first is that **operator[]**
    needs to be a member function in a class. It is not possible to have a freestanding
    **[]** operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is a peculiar thing, called operator precedence. That is not an
    operator called *precedence* , but the following: in C++, the order of operations,
    also known as operator precedence, determines how operators are parsed concerning
    each other. Operators with higher precedence are evaluated before operators with
    lower precedence. When operators have the same precedence, their associativity
    determines the order of evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: While in the latest standard, [*Chapter 7*](B22235_07.xhtml#_idTextAnchor079)
    *, Expressions* (specifically the **[expr.pre]** section), mentions that ‚ÄúThe
    precedence of operators is not directly specified, but it can be derived from
    the syntax‚Äù there are official sources of information2 [2](B22235_05.xhtml#footnote-017)
    which contain the exact order of them so we really encourage you to go and dedicate
    proper time to study one of those sources.
  prefs: []
  type: TYPE_NORMAL
- en: '**[2](B22235_05.xhtml#footnote-017-backlink)** [https://en.cppreference.com/w/cpp/language/operator_precedence](https://en.cppreference.com/w/cpp/language/operator_precedence)'
  prefs: []
  type: TYPE_NORMAL
- en: The most important question
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And now that you‚Äôre back, dear reader, we are pretty sure that you can easily
    answer the following question. What is the output of the following program?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you rush into feeding the code into your compiler, however, pause, sit
    back, and think thoroughly about what exactly is happening here. This section
    gave you all the hints, directions, and possible clues you needed in order to
    answer this correctly. We intentionally will not give the answer yet, nor a full
    explanation of the code, just a quick breakdown of what‚Äôs happening, which should
    be enough to figure it out:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **auto a = 4;** expression, the **a** variable is declared with the **int**
    type and initialized to **4** . This is just the way **auto** and numbers work
    in modern C++.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now comes the tricky part. Parsing the code in our brain, it is obvious that
    the **sizeof(a)** expression evaluates to a **std::sizeof** type, and typically,
    **sizeof(int)** is 4 bytes on most systems. Certainly, older 16-bit systems have
    **sizeof(int)** as **2** ; some exotic systems can have **sizeof(int)** as **8**
    , but the author of these lines has never seen a system like that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the crucial point where all our deduction has chicaned out. What kicks
    in is the operator precedence of C++. Here‚Äôs just a tiny extract from the preceding
    table, where we have kept just the parts relevant to our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Precedence** | **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | **::** | Scope resolution operator |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **a++ a--** | Postfix increment and decrement |'
  prefs: []
  type: TYPE_TB
- en: '|  | **a()** | Function call |'
  prefs: []
  type: TYPE_TB
- en: '|  | **a[]** | Subscript |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **++** **a --a** | Prefix increment and decrement |'
  prefs: []
  type: TYPE_TB
- en: '|  | **+** **a -a** | Unary plus and minus |'
  prefs: []
  type: TYPE_TB
- en: '|  | **! ~** | Logical NOT and bitwise NOT |'
  prefs: []
  type: TYPE_TB
- en: '|  | ***a** | Dereference |'
  prefs: []
  type: TYPE_TB
- en: '|  | **&a** | Address-of |'
  prefs: []
  type: TYPE_TB
- en: '|  | **sizeof** | Size of operator |'
  prefs: []
  type: TYPE_TB
- en: Now, we can finally see that in our code, the expression **sizeof(a)** will
    never be evaluated. Due to the way the C++ compiler works, the **[]** operator
    has priority over **sizeof** , so what will be evaluated first is **(** **a)["Hello
    World"];** .
  prefs: []
  type: TYPE_NORMAL
- en: Since in C++ **(a)** is almost always identical to **a** (except when you are
    dealing with the *most vexing parse* , but more on that at a later stage), the
    expression is identical to **sizeof** **a["Hello World"];** .
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have seen, this yields the same result as **sizeof "Hello World"[a];**
    , which, considering that today, **a** will most likely be **4** , gives us the
    character **'o'** . So, the entire expression is now reduced to **sizeof 'o'**
    , which, considering the way **sizeof** works, will always return **1** .
  prefs: []
  type: TYPE_NORMAL
- en: We, the authors, think that at this stage, the answer to our question is obvious.
  prefs: []
  type: TYPE_NORMAL
- en: When order does not matter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one tiny thing we ought not to forget to mention before closing this
    chapter. Well, actually two. The first one is that in C++, the order in which
    function arguments are evaluated is unspecified. This means that when you call
    a function with multiple arguments, the compiler is free to evaluate the arguments
    in any order it chooses. This can lead to unexpected results if the arguments
    have side effects, such as modifying a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs take, for example, the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of what you think the output of this program is, it will be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is, again, as mentioned previously: the order of evaluation
    of the parameters is not specified. With good reason, you may ask, why? The reasons
    for this are a bit more complex and historical. But before delving deeper into
    that, let‚Äôs amuse ourselves with the output that various compilers provide us
    with, courtesy of gcc.godbolt.org and some other sources.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compiler** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft Visual C++ ( after 2005) | **a=1** **b=1 c=1****f=3****i=4** |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft VS.NET 2003 | **a=3** **b=2 c=1****f=6****i=4** |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft Visual C++ 6 | **a=1** **b=1 c=1****f=3****i=4** |'
  prefs: []
  type: TYPE_TB
- en: '| ICC and Clang agree on this‚Ä¶ | **f=a=1** **b=2 c=3****6****i=4** |'
  prefs: []
  type: TYPE_TB
- en: '| GCC, after 6.5 | **f=a=3** **b=2 c=1****6****i=4** |'
  prefs: []
  type: TYPE_TB
- en: '| GCC, before 6.5 | **a=3** **b=2 c=1****f=6****i=4** |'
  prefs: []
  type: TYPE_TB
- en: '| Turbo C Lite and Borland C++55 | **a=3** **b=2 c=1****f=6****i=1** |'
  prefs: []
  type: TYPE_TB
- en: So, we have a plethora of options to choose from, some more straightforward
    and others more exotic. All these weird values claim they are the right one, the
    one to rule them all, regardless of the fact that even different versions of the
    same compiler from the same provider provide different results. And they are all
    right in their belief.
  prefs: []
  type: TYPE_NORMAL
- en: Quite simply, the reasoning is that allowing the compiler the freedom to choose
    the order of evaluation enables it to make optimizations that can improve performance
    that we programmers may not notice. The compiler can reorder instructions to take
    advantage of CPU pipelines, minimize register usage, and enhance cache efficiency.
    Specifying a strict order would limit these optimization opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Different hardware architectures may have different optimal evaluation strategies.
    By not specifying the order of evaluation, C++ code can be more easily optimized
    for a wide variety of architectures without requiring changes to the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Also, by not specifying the order of evaluation, the C++ language specification
    remains simpler. Specifying a strict order for all expressions would add complexity
    to the language definition and increase the burden on compiler developers. Not
    to mention that the current standard is almost 2,000 pages long, so maybe it is
    a good idea not to add several hundred pages detailing the complexities of the
    order of parameter evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we promised to mention at the beginning of this section, however,
    comes up: while operator precedence and associativity dictate how expressions
    are grouped and parsed, they do not dictate the order of evaluation. This means
    that even though you know how expressions will be grouped, the actual order in
    which parts of the expression are evaluated can still vary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs consider the following short application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is really short ‚Äì it couldn‚Äôt be shorter ‚Äì and it contains some quite nasty
    code, especially looking at **++i + i++** . That piece of code is so nasty that
    the compilers cannot really agree in which order to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Some of them choose to execute **++i** (making **i** be **5** and also using
    it as the left side of the addition) first, and then **i++** (which will be using
    the new value of **i** , which was incremented already, then incrementing it again
    to reach **6** , but due to the way post-increment works, the value of **5** will
    be used for the right-hand side of the addition), and then assigning this value
    back to **i** . So, that‚Äôs 5 + 5 = 10.
  prefs: []
  type: TYPE_NORMAL
- en: However, other compilers decide to execute **i++** first, thus keeping the value
    **4** on the right-hand side of the operation, while also incrementing the value
    of **i** to **6** . Now, **++i** is evaluated, which already sees the incremented
    value of **6** , decides to use it, and then increments it, thus obtaining **7**
    for the left-hand side of the addition. Thus, this will give 7 + 4 = 11.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, thinking a bit back, not having the evaluation order specified encourages
    developers aware of this uncanny feature to write code that does not expect specific
    evaluation orders. This can lead to more robust and portable code, as developers
    must avoid unintended dependencies on evaluation order. As such, the correct fix
    for the preceding situation would be some code along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While this might be a rare situation, because the preceding code is a bit artificial,
    it is an issue, especially still if we are dealing with situations like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The value of **result** will be **3** regardless, but the output, depending
    on how the compiler decides to execute the two function calls, can be either **"fg"**
    or **"gf"** .
  prefs: []
  type: TYPE_NORMAL
- en: With all this in mind, we may think that we understand everything about ordering
    in C++. While in this chapter we have tried to cover all possible implications,
    we cannot promise that you will not find anything out of order. C++ is a language
    with a very wide scope and peculiar syntax, so if someone really wanted to, they
    could step on the toes of some compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we hope you have grasped the critical importance of following
    the specified order of everything C++-related to ensure predictable and error-free
    code execution. You should also understand the importance of not having a specified
    order of execution.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we encourage you to go and experiment with the online playground
    offered by Compiler Explorer. It offers a large collection of compilers. Just
    bear in mind that if two compilers have generated different results for the code
    you wrote, then maybe you have ventured into unspecified/undefined behavior territory.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explores the challenges of memory management in C++.
  prefs: []
  type: TYPE_NORMAL
