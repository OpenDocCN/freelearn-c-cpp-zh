["```cpp\n#include <iostream>\nusing std::cout;    // preferred to: using namespace std;\nusing std::endl;\nusing std::string;\nusing std::to_string;\nclass Person\n{\nprivate: \n    string firstName;\n    string lastName;\n    char middleInitial = '\\0';  // in-class initialization\n    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.\nprotected:\n    void ModifyTitle(const string &);  \npublic:\n    Person() = default;   // default constructor\n    Person(const string &, const string &, char, \n           const string &);\n    Person(const Person &) = delete;  // prohibit copies\n    virtual ~Person();  // destructor prototype\n    const string &GetFirstName() const \n        { return firstName; }  \n    const string &GetLastName() const \n        { return lastName; }    \n    const string &GetTitle() const { return title; } \n    char GetMiddleInitial() const { return middleInitial; }\n};\n```", "```cpp\n// With in-class initialization, writing the default\n// constructor is no longer necessary.\n// Also, remember strings are member objects and will \n// be default constructed as empty.\nPerson::Person(const string &fn, const string &ln, char mi, \n               const string &t): firstName(fn),\n               lastName(ln), middleInitial(mi), title(t)\n{\n}\n// Simple destructor so we can trace the destruction chain\nPerson::~Person()  \n{\n    cout << \"Person destructor <\" << firstName << \" \" << \n            lastName << \">\" << endl;\n}\nvoid Person::ModifyTitle(const string &newTitle)\n{\n    title = newTitle;\n}\n```", "```cpp\nclass BillableEntity\n{\nprivate:\n    float invoiceAmt = 0.0;   // in-class initialization\npublic:\n    BillableEntity() = default;\n    BillableEntity(float amt) invoiceAmt(amt) { } \n    // prohibit copies with prototype below\n    BillableEntity(const BillableEntity &) = delete; \n    virtual ~BillableEntity();\n    void Pay(float amt) { invoiceAmt -= amt; }\n    float GetBalance() const { return invoiceAmt; }\n    void Balance() const;\n};\n// Simple destructor so we can trace destruction chain\nBillableEntity::~BillableEntity()\n{\n    cout << \"BillableEntity destructor\" << endl;\n}\nvoid BillableEntity::Balance() const\n{\n    if (invoiceAmt)\n       cout << \"Owed amount: $ \" << invoiceAmt << endl;\n    else\n       cout << \"Credit: $ \" << 0.0 - invoiceAmt << endl;\n}\n```", "```cpp\nclass Student: public Person, public BillableEntity\n{\nprivate: \n    float gpa = 0.0;   // in-class initialization\n    string currentCourse;\n    const string studentId;\n    static int numStudents;\npublic:\n    Student();  // default constructor\n    Student(const string &, const string &, char, \n            const string &, float, const string &, \n            const string &, float); \n    Student(const Student &) = delete;  // prohibit copies\n    ~Student() override; \n    void Print() const;\n    void EarnPhD();  \n    float GetGpa() const { return gpa; }\n    const string &GetCurrentCourse() const\n        { return currentCourse; }\n    const string &GetStudentId() const \n        { return studentId; }\n    void SetCurrentCourse(const string &);\n    static int GetNumberStudents();\n};\n// definition for static data member\nint Student::numStudents = 0;  // notice initial value of 0\ninline void Student::SetCurrentCourse(const string &c)\n{\n   currentCourse = c;\n}\ninline int Student::GetNumberStudents()\n{\n    return numStudents;\n}\n```", "```cpp\n// Due to non-specification in the member init list, this \n// constructor calls the default base class constructors\nStudent::Student() : studentId(to_string(numStudents + 100) \n                                         + \"Id\")\n{\n   // Note: since studentId is const, we need to set it at \n   // construction using member init list. Remember, string\n   // members are default constructed w an empty string. \n   numStudents++;\n}\n// The member initialization list specifies which versions\n// of each base class constructor should be utilized.\nStudent::Student(const string &fn, const string &ln, \n        char mi, const string &t, float avg, \n        const string &course, const string &id, float amt): \n        Person(fn, ln, mi, t), BillableEntity(amt),\n        gpa(avg), currentCourse(course), studentId(id)\n{\n   numStudents++;\n}\n// Simple destructor so we can trace destruction sequence\nStudent::~Student()\n{\n   numStudents--;\n   cout << \"Student destructor <\" << GetFirstName() << \" \"\n        << GetLastName() << \">\" << endl;\n}\nvoid Student::Print() const\n{\n    cout << GetTitle() << \" \" << GetFirstName() << \" \";\n    cout << GetMiddleInitial() << \". \" << GetLastName();\n    cout << \" with id: \" << studentId << \" has a gpa of: \";\n    cout << \" \" << gpa << \" and course: \" << currentCourse;\n    cout << \" with balance: $\" << GetBalance() << endl;\n}\nvoid Student::EarnPhD() \n{  \n    ModifyTitle(\"Dr.\"); \n}\n```", "```cpp\nint main()\n{\n    float tuition1 = 1000.00, tuition2 = 2000.00;\n    Student s1(\"Gabby\", \"Doone\", 'A', \"Ms.\", 3.9, \"C++\",\n               \"178GWU\", tuition1); \n    Student s2(\"Zack\", \"Moon\", 'R', \"Dr.\", 3.9, \"C++\",\n               \"272MIT\", tuition2); \n    // public mbrs. of Person, BillableEntity, Student are\n    // accessible from any scope, including main()\n    s1.Print();\n    s2.Print();\n    cout << s1.GetFirstName() << \" paid $500.00\" << endl;\n    s1.Pay(500.00);\n    cout << s2.GetFirstName() << \" paid $750.00\" << endl;\n    s2.Pay(750.00);\n    cout << s1.GetFirstName() << \": \";\n    s1.Balance();\n    cout << s2.GetFirstName() << \": \";\n    s2.Balance();\n    return 0;\n}\n```", "```cpp\nMs. Gabby A. Doone with id: 178GWU has a gpa of:  3.9 and course: C++ with balance: $1000\nDr. Zack R. Moon with id: 272MIT has a gpa of:  3.9 and course: C++ with balance: $2000\nGabby paid $500.00\nZack paid $750.00\nGabby: Owed amount: $ 500\nZack: Owed amount: $ 1250\nStudent destructor <Zack Moon>\nBillableEntity destructor\nPerson destructor <Zack Moon>\nStudent destructor <Gabby Doone>\nBillableEntity destructor\nPerson destructor <Gabby Doone>\n```", "```cpp\nclass Lifeform\n{   // abbreviated class definition – see full code online\nprivate:\n    int lifeExpectancy = 0;  // in-class initialization\npublic:\n    LifeForm(int life): lifeExpectancy(life) { }\n    [[nodiscard]] int GetLifeExpectancy() const \n        { return lifeExpectancy; }\n    // additional constructors, destructor, etc.\n    virtual void Print() const = 0; // pure virtual funcs.\n    virtual string IsA() const = 0;\n    virtual string Speak() const = 0;\n};\nclass Horse: public LifeForm\n{   // abbreviated class definition\nprivate:\n    string name;\n    static constexpr int HORSE_LIFE = 35; // life exp Horse\npublic:\n    Horse(): LifeForm(HORSE_LIFE) { }\n    // additional constructors, destructor, etc …\n    void Print() const override { cout << name << endl; }\n    string IsA() const override { return \"Horse\"; }\n    string Speak() const override { return \"Neigh!\"; }\n};\nclass Person: public LifeForm\n{   // abbreviated class definition\nprivate: \n    string firstName;\n    string lastName;\n    static constexpr int PERSON_LIFE = 80; // life expect.\n                                           // of Person\n    // additional data members (imagine them here)\npublic:\n    Person(): LifeForm(PERSON_LIFE) { }\n    // additional constructors, destructor, etc.\n    const string &GetFirstName() const \n        { return firstName; }\n    // additional access methods, etc. \n    void Print() const override\n        { cout << firstName << \" \" << lastName << endl; }\n    string IsA() const override { return \"Person\"; }\n    string Speak() const override { return \"Hello!\"; }\n};\n```", "```cpp\nclass Centaur: public Person, public Horse\n{   // abbreviated class definition\npublic:\n    // constructors, destructor, etc …\n    void Print() const override\n       { cout << GetFirstName() << endl; }\n    string IsA() const override { return \"Centaur\"; }\n    string Speak() const override\n       { return \"Neigh! and Hello!\"; }\n};\n```", "```cpp\nint main()\n{\n    Centaur beast(\"Wild\", \"Man\");\n    cout << beast.Speak() << \" I'm a \" << beast.IsA();\n    cout << endl;\n    // Ambiguous method call – which LifeForm sub-object?\n    // cout << beast.GetLifeExpectancy();  \n    cout << \"It is unclear how many years I will live: \";\n    cout << beast.Person::GetLifeExpectancy() << \" or \";\n    cout << beast.Horse::GetLifeExpectancy() << endl; \n    return 0;\n}\n```", "```cpp\nNeigh! and Hello! I'm a Centaur.\nIt is unclear how many years I will live: 80 or 35.\n```", "```cpp\n#include <iostream>\nusing std::cout;    // preferred to: using namespace std;\nusing std::endl;\nusing std::string;\nusing std::to_string;\nclass LifeForm\n{\nprivate:\n    int lifeExpectancy = 0;  // in-class initialization\npublic:\n    LifeForm() = default; \n    LifeForm(int life): lifeExpectancy(life) { }\n    // We're accepting default copy constructor, but if we\n    // wanted to write it, it would look like:\n    // LifeForm(const LifeForm &form): \n    //         lifeExpectancy(form.lifeExpectancy) { }\n    // prototype necessary to specify virtual dest. below\n    virtual ~LifeForm() = default;\n    [[nodiscard]] int GetLifeExpectancy() const \n        { return lifeExpectancy; }\n    virtual void Print() const = 0; \n    virtual string IsA() const = 0;   \n    virtual string Speak() const = 0;\n};\n```", "```cpp\nclass Horse: public virtual LifeForm\n{\nprivate:\n    string name;\n    static constexpr int HORSE_LIFE = 35; // Horse life exp\npublic:\n    Horse() : LifeForm(HORSE_LIFE) { }\n    Horse(const string &n);\n    // Remember, it isn't necessary to proto def. copy ctor\n    // Horse(const Horse &) = default; \n    // Because base class destructor is virtual, ~Horse()\n    // is automatically virtual (overridden) even w/o proto\n    // ~Horse() override = default;\n    const string &GetName() const { return name; }\n    void Print() const override \n        { cout << name << endl; }\n    string IsA() const override { return \"Horse\"; }\n    string Speak() const override { return \"Neigh!\"; }\n};\nHorse::Horse(const string &n) : LifeForm(HORSE_LIFE),\n                                name(n)\n{\n}\n// We are using the default copy constructor, but if we\n// wanted to write it, this is what it would look like:\n// Horse::Horse(const Horse &h): LifeForm (h), name(h.name)\n// {\n// }\n```", "```cpp\nclass Person: public virtual LifeForm\n{\nprivate: \n    string firstName;\n    string lastName;\n    char middleInitial = '\\0';  // in-class initialization\n    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.\n    static constexpr int PERSON_LIFE = 80; // Life expect.\nprotected:\n    void ModifyTitle(const string &);  \npublic:\n    Person();   // default constructor\n    Person(const string &, const string &, char, \n           const string &); \n    // Default copy constructor prototype is not necessary \n    // Person(const Person &) = default;  // copy ctor.\n    // Because base class destructor is virtual, ~Person()\n    // is automatically virtual (overridden) even w/o proto\n    // ~Person() override = default;  // destructor\n    const string &GetFirstName() const \n        { return firstName; }  \n    const string &GetLastName() const \n        { return lastName; }    \n    const string &GetTitle() const { return title; } \n    char GetMiddleInitial() const { return middleInitial; }\n    void Print() const override;\n    string IsA() const override;   \n    string Speak() const override;\n};\n```", "```cpp\nPerson::Person(): LifeForm(PERSON_LIFE)\n{  // Note that the base class init list specification of\n   // LifeForm(PERSON_LIFE) is ignored if LifeForm is a \n   // shared, virtual base class.\n}  // This is the same in all Person constructors.\nPerson::Person(const string &fn, const string &ln, char mi,\n               const string &t): LifeForm(PERSON_LIFE),\n               firstName(fn), lastName(ln),\n               middleInitial(mi), title(t)\n{\n}\n// We're using the default copy constructor, but if we \n// wrote/prototyped it, here's what the method would be:\n// Person::Person(const Person &p): LifeForm(p),\n//           firstName(p.firstName), lastName(p.lastName),\n//           middleInitial(p.middleInitial), title(p.title)\n// {\n// }\nvoid Person::ModifyTitle(const string &newTitle)\n{\n    title = newTitle;\n}\nvoid Person::Print() const\n{\n    cout << title << \" \" << firstName << \" \";\n    cout << middleInitial << \". \" << lastName << endl;\n}\nstring Person::IsA() const\n{  \n    return \"Person\"; \n}\nstring Person::Speak() const\n{   \n    return \"Hello!\"; \n}\n```", "```cpp\nclass Centaur: public Person, public Horse\n{\nprivate:\n    // no additional data members required, but the below\n    // static constexpr eliminates a magic number of 1000\n    static constexpr int CENTAUR_LIFE = 1000; //life expect\npublic:\n    Centaur(): LifeForm(CENTAUR_LIFE) { }\n    Centaur(const string &, const string &, char = ' ', \n            const string & = \"Mythological Creature\"); \n    // We don't want default copy constructor due to the\n    // needed virtual base class in the mbr init list below\n    Centaur(const Centaur &c): \n           Person(c), Horse(c), LifeForm(CENTAUR_LIFE) { }\n    // Because base class' destructors are virt, ~Centaur()\n    // is automatically virtual (overridden) w/o prototype\n    // ~Centaur() override = default;\n    void Print() const override;\n    string IsA() const override;\n    string Speak() const override;\n};\n// Constructors for Centaur need to specify how the shared\n// base class LifeForm will be initialized\nCentaur::Centaur(const string &fn, const string &ln, \n                 char mi, const string &title):\n                 Person(fn, ln, mi, title), Horse(fn),\n                 LifeForm(CENTAUR_LIFE)\n{\n   // All initialization has been taken care of in \n}  // member initialization list\nvoid Centaur::Print() const\n{\n    cout << \"My name is \" << GetFirstName();\n    cout << \".  I am a \" << GetTitle() << endl;\n}\nstring Centaur::IsA() const \n{ \n    return \"Centaur\"; \n}\nstring Centaur::Speak() const\n{\n    return \"Neigh! Hello! I'm a master of two languages.\";\n} \n```", "```cpp\nint main()\n{\n   Centaur beast(\"Wild\", \"Man\");\n   cout << beast.Speak() << endl;\n   cout << \" I'm a \" << beast.IsA() << \". \";\n   beast.Print();\n   cout << \"I will live: \";\n   cout << beast.GetLifeExpectancy();// no longer ambiguous\n   cout << \" years\" << endl; \n   return 0;\n}\n```", "```cpp\nNeigh! Hello! I'm a master of two languages.\nI am a Centaur. My name is Wild. I am a Mythological Creature.\nI will live: 1000 years.\n```"]