<html><head></head><body>
		<div><h1 class="chapterNumber">Chapter 0<a id="_idTextAnchor223"/>8</h1>
			<h1 id="_idParaDest-121" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor224"/>Inheritance and Polymorphism </h1>
			<p class="normal">This chapter is a continuation of the previous two chapters, where we introduced how you can do OOP in C and reached the concepts of composition and aggregation. This chapter mainly continues the discussion regarding relationships between objects and their corresponding classes and covers inheritance and polymorphism. As part of this chapter, we conclude this topic and we continue with <em class="italics">Abstraction</em> in the following chapter.</p>
			<p class="normal">This chapter is heavily dependent on the theory explained in the previous two chapters, where we were discussing the possible relationships between classes. We explained <em class="italics">composition</em> and <em class="italics">aggregation</em> relationships, and now we are going to talk about the <em class="italics">extension</em> or <em class="italics">inheritance</em> relationship in this chapter, along with a few other topics.</p>
			<p class="normal">The following are the topics that will be explained throughout this chapter:</p>
			<ul>
				<li class="list">As explained earlier, the inheritance relationship is the first topic that we discuss. The methods for implementing the inheritance relationship in C will be covered, and we will conduct a comparison between them.</li>
				<li class="list">The next big topic is <em class="italics">polymorphism</em>. Polymorphism allows us to have different versions of the same behavior in the child classes, in the case of having an inheritance relationship between those classes. We will discuss the methods for having a polymorphic function in C; this will be the first step in our understanding of how C++ offers polymorphism.</li>
			</ul>
			<p class="normal">Let's start our discussion with the inheritance relationship.</p>
			<h1 id="_idParaDest-122" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor225"/>Inheritance</h1>
			<p class="normal">We closed the previous<a id="_idIndexMarker574"/> chapter by talking about <em class="italics">to-have</em> relationships, which eventually led us to composition and aggregation relationships. In this section, we are going to talk about <em class="italics">to-be</em> or <em class="italics">is-a</em> relationships. The inheritance relationship is a to-be relationship. </p>
			<p class="normal">An inheritance<a id="_idIndexMarker575"/> relationship can also be called an <em class="italics">extension relationship</em> because it only adds extra attributes and behaviors to an existing object or class. In the following sections, we'll explain what inheritance means and how it can be implemented in C<a id="_idTextAnchor226"/>.</p>
			<p class="normal">There are situations when an object needs to have the same attributes that exist in another object. In other words, the new object is an extension to the other object.</p>
			<p class="normal">For example, a student has all the attributes of a person, but may also have extra attributes. See <em class="italics">Code Box 8-1</em>:</p>
			<pre>typedef struct {
  char first_name[32];
  char last_name[32];
  unsigned int birth_year;
} person_t;
typedef struct {
  char first_name[32];
  char last_name[32];
  unsigned int birth_year;
<strong class="highlight">  char student_number[16]; // Extra attribute</strong>
<strong class="highlight">  unsigned int passed_credits; // Extra attribute</strong>
} student_t;</pre>
			<p class="packt_figref">Code Box 8-1: The attribute structures of the Person class and the Student class</p>
			<p class="normal">This example clearly shows how <code class="Code-In-Text--PACKT-">student_t</code> extends the attributes of <code class="Code-In-Text--PACKT-">person_t</code> with new attributes, <code class="Code-In-Text--PACKT-">student_number</code> and <code class="Code-In-Text--PACKT-">passed_credits</code>, which are student-specific attributes. </p>
			<p class="normal">As we have pointed out before, inheritance (or extension) is a to-be relationship, unlike composition and aggregation, which are to-have relationships. Therefore, for the preceding example, we can say that "a student is a person," which seems to be correct in the domain of educational software. Whenever a to-be relationship exists in a domain, it is probably an inheritance relationship. In the preceding example, <code class="Code-In-Text--PACKT-">person_t</code> is usually called the <em class="italics">supertype</em>, or the <em class="italics">base</em> type, or simply the <em class="italics">parent</em> type, and <code class="Code-In-Text--PACKT-">student_t</code> is usually called the <em class="italics">child</em> type or the <em class="italics">inherited subtype</em><a id="_idTextAnchor227"/>.</p>
			<h2 id="_idParaDest-123" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor228"/>The nature of inheritance</h2>
			<p class="normal">If you were to dig <a id="_idIndexMarker576"/>deeper and see what an inheritance relationship really is, you would find out that it is really a composition relationship in its nature. For example, we can say that a student has a person's nature inside of them. In other words, we can suppose that there is a private person object inside the <code class="Code-In-Text--PACKT-">Student</code> class's attribute structure. That is, an inheritance relationship can be equivalent to a one-to-one composition relation<a id="_idTextAnchor229"/>ship.</p>
			<p class="normal">So, the structures in <em class="italics">Code Box 8-1</em> can be written as:</p>
			<pre>typedef struct {
  char first_name[32];
  char last_name[32];
  unsigned int birth_year;
} person_t;
typedef struct {
<strong class="highlight">  person_t person;</strong>
  char student_number[16]; // Extra attribute
  unsigned int passed_credits; // Extra attribute
} student_t;</pre>
			<p class="packt_figref">Code Box 8-2: The attribute structures of the Person and Student classes but nested this time</p>
			<p class="normal">This syntax is totally valid in C, and in fact nesting structures by using structure variables (not pointers) is a powerful setup. It allows you to have a structure variable inside your new structure that is really an extension to the former.</p>
			<p class="normal">With the preceding setup, necessarily having a field of type <code class="Code-In-Text--PACKT-">person_t</code> as the first field, a <code class="Code-In-Text--PACKT-">student_t</code> pointer can be easily cast to a <code class="Code-In-Text--PACKT-">person_t</code> pointer, and both of them can point to the same address in memory. </p>
			<p class="normal">This is called <em class="italics">upcasting</em>. In other words, casting a pointer of the type of the child's attribute structure to the type of the parent's attribute structure is upcasting. Note that with structure variables, you cannot have this feature.</p>
			<p class="normal"><em class="italics">Example 8.1</em> demonstrates this as follows:</p>
			<pre>#include &lt;stdio.h&gt;
typedef struct {
  char first_name[32];
  char last_name[32];
  unsigned int birth_year;
} person_t;
typedef struct {
  person_t person;
  char student_number[16]; // Extra attribute
  unsigned int passed_credits; // Extra attribute
} student_t;
int main(int argc, char** argv) {
  student_t s;
<strong class="highlight">  student_t* s_ptr = &amp;s;</strong>
<strong class="highlight">  person_t* p_ptr = (person_t*)&amp;s;</strong>
  printf("Student pointer points to %p\n", (void*)s_ptr);
  printf("Person pointer points to %p\n", (void*)p_ptr);
  return 0;
}</pre>
			<p class="packt_figref">Code Box 8-3 [ExtremeC_examples_chapter8_1.c]: Example 8.1, showing upcasting between Student and Person object pointers</p>
			<p class="normal">As you can see, we expect <a id="_idIndexMarker577"/>that the <code class="Code-In-Text--PACKT-">s_ptr</code> and <code class="Code-In-Text--PACKT-">p_ptr</code> pointers are pointing to the same address in memory. The following is the output after building and running <em class="italics">example 8.1</em>:</p>
			<pre><strong class="highlight">$ gcc ExtremeC_examples_chapter8_1.c -o ex8_1.out</strong>
<strong class="highlight">$ ./ex8_1.out</strong>
Student pointer points to 0x7ffeecd41810
Person pointer points to 0x7ffeecd41810
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 8-1: The output of example 8.1</p>
			<p class="normal">And yes, they are pointing to the same address. Note that the shown addresses can be different in each run, but the point is that the pointers are referring to the same address. This means that a structure variable of the type <code class="Code-In-Text--PACKT-">student_t</code> is really inheriting the <code class="Code-In-Text--PACKT-">person_t</code> structure in its memory layout. This implies that we can use the function behaviors of the <code class="Code-In-Text--PACKT-">Person</code> class with a pointer that is pointing to a <code class="Code-In-Text--PACKT-">student</code> object. In other words, the <code class="Code-In-Text--PACKT-">Person</code> class's behavior functions can be reused for the <code class="Code-In-Text--PACKT-">student</code> objects, which is a great achievement. </p>
			<p class="normal">Note that the following is wrong, and the code won't compile:</p>
			<pre>struct person_t;
typedef struct {
<strong class="highlight">  struct person_t person; // Generates an error! </strong>
  char student_number[16]; // Extra attribute
  unsigned int passed_credits; // Extra attribute
} student_t;</pre>
			<p class="packt_figref">Code Box 8-4: Establishing an inheritance relationship which doesn't compile!</p>
			<p class="normal">The line declaring the <code class="Code-In-Text--PACKT-">person</code><a id="_idIndexMarker578"/> field generates an error because you cannot create a variable from an <em class="italics">incomplete type</em>. You should remember that the forward declaration of a structure (similar to the first line in <em class="italics">Code Box 8-4</em>) results in the declaration of an incomplete type. You can have only pointers of incomplete types, <em class="italics">not</em> variables. As you've seen before, you cannot even allocate Heap memory for an incomplete type. </p>
			<p class="normal">So, what does this mean? It means that if you're going to use nested structure variables in order to implement inheritance, the <code class="Code-In-Text--PACKT-">student_t</code> structure should see the actual definition of <code class="Code-In-Text--PACKT-">person_t</code>, which, based on what we learned about encapsulation, should be private and not visible to any other class.</p>
			<p class="normal">Therefore, you have two approaches for implementing the inheritance relationship:</p>
			<ul>
				<li class="list">Make it so that the child class has access to the private implementation (actual definition) of the base class.</li>
				<li class="list">Make it so that the child class only has access to the public interface of the base cl<a id="_idTextAnchor230"/>ass.</li>
			</ul>
			<h3 id="_idParaDest-124" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor231"/>The first approach for having inheritance in C</h3>
			<p class="normal">We'll demonstrate the<a id="_idIndexMarker579"/> first approach in the following example, <em class="italics">example 8.2</em>, and the second approach in <em class="italics">example 8.3</em>, which will come up in the next section. Both of them represent the same classes, <code class="Code-In-Text--PACKT-">Student</code> and <code class="Code-In-Text--PACKT-">Person</code>, with some behavior functions, having some objects playing in a simple scenario in the <code class="Code-In-Text--PACKT-">main</code> function.</p>
			<p class="normal">We'll start with <em class="italics">example 8.2</em>, in which the <code class="Code-In-Text--PACKT-">Student</code> class needs to have access to the actual private definition of the <code class="Code-In-Text--PACKT-">Person</code> class's attribute structure. The following code boxes present the headers and the sources for the <code class="Code-In-Text--PACKT-">Student</code> and <code class="Code-In-Text--PACKT-">Person</code> classes together with the <code class="Code-In-Text--PACKT-">main</code> function. Let's start with the header file declaring the <code class="Code-In-Text--PACKT-">Person</code> class:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_2_PERSON_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_2_PERSON_H
// Forward declaration
struct person_t;
// Memory allocator
struct person_t* person_new();
// Constructor
void person_ctor(struct person_t*,
                 const char*  /* first name */,
                 const char*  /* last name */,
                 unsigned int /* birth year */);
// Destructor
void person_dtor(struct person_t*);
// Behavior functions
void person_get_first_name(struct person_t*, char*);
void person_get_last_name(struct person_t*, char*);
unsigned int person_get_birth_year(struct person_t*);
#endif</pre>
			<p class="packt_figref">Code Box 8-5 [ExtremeC_examples_chapter8_2_person.h]: Example 8.2, the public interface of the Person class</p>
			<p class="normal">Look at the constructor<a id="_idIndexMarker580"/> function in <em class="italics">Code Box 8-5</em>. It accepts all the values required for creating a <code class="Code-In-Text--PACKT-">person</code> object: <code class="Code-In-Text--PACKT-">first_name</code>, <code class="Code-In-Text--PACKT-">second_name</code>, and <code class="Code-In-Text--PACKT-">birth_year</code>. As you see, the attribute structure <code class="Code-In-Text--PACKT-">person_t</code> is incomplete, hence the <code class="Code-In-Text--PACKT-">Student</code> class cannot use the preceding header file for establishing an inheritance relationship, similar to what we demonstrated in the previous section.</p>
			<p class="normal">On the other hand, the preceding header file must not contain the actual definition of the attribute structure <code class="Code-In-Text--PACKT-">person_t</code>, since the preceding header file is going to be used by other parts of the code which should not know anything about the <code class="Code-In-Text--PACKT-">Person</code> internals. So, what should we do? We want a certain part of the logic to know about a structure definition that other parts of the code must not know about. That's where <em class="italics">private header files</em> jump in.</p>
			<p class="normal">A private header file is an ordinary header file that is supposed to be included and used by a certain part of code or a certain class that actually needs it. Regarding <em class="italics">example 8.2</em>, the actual definition of <code class="Code-In-Text--PACKT-">person_t</code> should be part of a private header. In the following code box, you will see an example of a private header file:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_2_PERSON_P_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_2_PERSON_P_H
// Private definition
typedef struct {
  char first_name[32];
  char last_name[32];
  unsigned int birth_year;
} person_t;
#endif</pre>
			<p class="packt_figref">Code Box 8-6 [ExtremeC_examples_chapter8_2_person_p.h]: The private header file which contains the actual definition of person_t</p>
			<p class="normal">As you see, it only contains<a id="_idIndexMarker581"/> the definition of the <code class="Code-In-Text--PACKT-">person_t</code> structure and nothing more than that. This is the part of the <code class="Code-In-Text--PACKT-">Person</code> class which should stay private, but it needs to become public to the <code class="Code-In-Text--PACKT-">Student</code> class. We are going to need this definition for defining the <code class="Code-In-Text--PACKT-">student_t</code> attribute structure. The next code box demonstrates the private implementation of the <code class="Code-In-Text--PACKT-">Person</code> class:</p>
			<pre>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
// person_t is defined in the following header file.
#include "ExtremeC_examples_chapter8_2_person_p.h"
// Memory allocator
person_t* person_new() {
  return (person_t*)malloc(sizeof(person_t));
}
// Constructor
void person_ctor(person_t* person,
                 const char* first_name,
                 const char* last_name,
                 unsigned int birth_year) {
  strcpy(person-&gt;first_name, first_name);
  strcpy(person-&gt;last_name, last_name);
  person-&gt;birth_year = birth_year;
}
// Destructor
void person_dtor(person_t* person) {
  // Nothing to do
}
// Behavior functions
void person_get_first_name(person_t* person, char* buffer) {
  strcpy(buffer, person-&gt;first_name);
}
void person_get_last_name(person_t* person, char* buffer) {
  strcpy(buffer, person-&gt;last_name);
}
unsigned int person_get_birth_year(person_t* person) {
  return person-&gt;birth_year;
}</pre>
			<p class="packt_figref">Code Box 8-7 [ExtremeC_examples_chapter8_2_person.c]: The definition of the Person class</p>
			<p class="normal">There is nothing special about<a id="_idIndexMarker582"/> the definition of the <code class="Code-In-Text--PACKT-">Person</code> class and it is like all previous examples. The following code box shows the public interface of the <code class="Code-In-Text--PACKT-">Student</code> class:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_2_STUDENT_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_2_STUDENT_H
//Forward declaration
struct student_t;
// Memory allocator
struct student_t* student_new();
// Constructor
void student_ctor(struct student_t*,
                  const char*  /* first name */,
                  const char*  /* last name */,
                  unsigned int /* birth year */,
                  const char*  /* student number */,
                  unsigned int /* passed credits */);
// Destructor
void student_dtor(struct student_t*);
// Behavior functions
void student_get_student_number(struct student_t*, char*);
unsigned int student_get_passed_credits(struct student_t*);
#endif</pre>
			<p class="packt_figref">Code Box 8-8 [ExtremeC_examples_chapter8_2_student.h]: The public interface of the Student class</p>
			<p class="normal">As you can see, the constructor<a id="_idIndexMarker583"/> of the class accepts similar arguments to the <code class="Code-In-Text--PACKT-">Person</code> class's constructor. That's because a <code class="Code-In-Text--PACKT-">student</code> object actually contains a <code class="Code-In-Text--PACKT-">person</code> object and it needs those values for populating its composed <code class="Code-In-Text--PACKT-">person</code> object. </p>
			<p class="normal">This implies that the <code class="Code-In-Text--PACKT-">student</code> constructor needs to set the attributes for the <code class="Code-In-Text--PACKT-">person</code> part of the <code class="Code-In-Text--PACKT-">student</code>.</p>
			<p class="normal">Note that we have only two additional behavior functions as part of the <code class="Code-In-Text--PACKT-">Student</code> class, and that's because we can use the <code class="Code-In-Text--PACKT-">Person</code> class's behavior functions for <code class="Code-In-Text--PACKT-">student</code> objects as well.</p>
			<p class="normal">The next code box contains the private implementation of the <code class="Code-In-Text--PACKT-">Student</code> class:</p>
			<pre>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "ExtremeC_examples_chapter8_2_person.h"
// person_t is defined in the following header
// file and we need it here.
<strong class="highlight">#include "ExtremeC_examples_chapter8_2_person_p.h"</strong>
//Forward declaration
typedef struct {
  // Here, we inherit all attributes from the person class and
  // also we can use all of its behavior functions because of
  // this nesting.
<strong class="highlight">  person_t person;</strong>
  char* student_number;
  unsigned int passed_credits;
} student_t;
// Memory allocator
student_t* student_new() {
  return (student_t*)malloc(sizeof(student_t));
}
// Constructor
void student_ctor(student_t* student,
                  const char* first_name,
                  const char* last_name,
                  unsigned int birth_year,
                  const char* student_number,
                  unsigned int passed_credits) {
  // Call the constructor of the parent class
<strong class="highlight">  person_ctor((struct person_t*)student,</strong>
<strong class="highlight">          first_name, last_name, birth_year);</strong>
  student-&gt;student_number = (char*)malloc(16 * sizeof(char));
  strcpy(student-&gt;student_number, student_number);
  student-&gt;passed_credits = passed_credits;
}
// Destructor
void student_dtor(student_t* student) {
  // We need to destruct the child object first.
  free(student-&gt;student_number);
  // Then, we need to call the destructor function
  // of the parent class
<strong class="highlight">  person_dtor((struct person_t*)student);</strong>
}
// Behavior functions
void student_get_student_number(student_t* student,
                                char* buffer) {
  strcpy(buffer, student-&gt;student_number);
}
unsigned int student_get_passed_credits(student_t* student) {
  return student-&gt;passed_credits;
}</pre>
			<p class="packt_figref">Code Box 8-9 [ExtremeC_examples_chapter8_2_student.c]: The private definition of the Student class</p>
			<p class="normal">The preceding code box <a id="_idIndexMarker584"/>contains the most important code regarding the inheritance relationship. Firstly, we needed to include the private header of the <code class="Code-In-Text--PACKT-">Person</code> class because as part of defining <code class="Code-In-Text--PACKT-">student_t</code>, we want to have the first field from the <code class="Code-In-Text--PACKT-">person_t</code> type. And, since that field is an actual variable and not a pointer, it requires that we have <code class="Code-In-Text--PACKT-">person_t</code> already defined. Note that this variable must be the <em class="italics">first field</em> in the structure. Otherwise, we lose the possibility of using the <code class="Code-In-Text--PACKT-">Person</code> class's behavior functions.</p>
			<p class="normal">Again, in the preceding code box, as part of the <code class="Code-In-Text--PACKT-">Student</code> class's constructor, we call the parent's constructor to initialize the attributes of the parent (composed) object. Look at how we cast the <code class="Code-In-Text--PACKT-">student_t</code> pointer to a <code class="Code-In-Text--PACKT-">person_t</code> pointer when passing it to the <code class="Code-In-Text--PACKT-">person_ctor</code> function. This is possible just because the <code class="Code-In-Text--PACKT-">person</code> field is the first member of <code class="Code-In-Text--PACKT-">student_t</code>.</p>
			<p class="normal">Similarly, as part of the <code class="Code-In-Text--PACKT-">Student</code> class's destructor, we called the parent's destructor. This destruction should <a id="_idIndexMarker585"/>happen first at the child level and then the parent level, in the opposite order of construction. The next code box contains <em class="italics">example 8.2</em>'s main scenario, which is going to use the <code class="Code-In-Text--PACKT-">Student</code> class and create an object of type <code class="Code-In-Text--PACKT-">Student</code>:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
<strong class="highlight">#include "ExtremeC_examples_chapter8_2_person.h"</strong>
<strong class="highlight">#include "ExtremeC_examples_chapter8_2_student.h"</strong>
int main(int argc, char** argv) {
  // Create and construct the student object
  struct student_t* student = student_new();
  student_ctor(student, "John", "Doe",
          1987, "TA5667", 134);
  // Now, we use person's behavior functions to
  // read person's attributes from the student object
  char buffer[32];
  // Upcasting to a pointer of parent type
<strong class="highlight">  struct person_t* person_ptr = (struct person_t*)student;</strong>
  person_get_first_name(person_ptr, buffer);
  printf("First name: %s\n", buffer);
  person_get_last_name(person_ptr, buffer);
  printf("Last name: %s\n", buffer);
  printf("Birth year: %d\n", person_get_birth_year(person_ptr)); 
  // Now, we read the attributes specific to the student object.
  student_get_student_number(student, buffer);
  printf("Student number: %s\n", buffer);
  printf("Passed credits: %d\n",
          student_get_passed_credits(student));
  // Destruct and free the student object
  student_dtor(student);
  free(student);
  return 0;
}</pre>
			<p class="packt_figref">Code Box 8-10 [ExtremeC_examples_chapter8_2_main.c]: The main scenario of example 8.2</p>
			<p class="normal">As you see in the main scenario, we have included the public interfaces of both the <code class="Code-In-Text--PACKT-">Person</code> and <code class="Code-In-Text--PACKT-">Student</code> classes (not the private header file), but we<a id="_idIndexMarker586"/> have only created one <code class="Code-In-Text--PACKT-">student</code> object. As you can see, the <code class="Code-In-Text--PACKT-">student</code> object has inherited all attributes from its internal <code class="Code-In-Text--PACKT-">person</code> object, and they can be read via the <code class="Code-In-Text--PACKT-">Person</code> class's behavior functions.</p>
			<p class="normal">The following shell box shows how to compile and run <em class="italics">example 8.2</em>:</p>
			<pre><strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_2_person.c -o person.o</strong>
<strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_2_student.c -o student.o</strong>
<strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_2_main.c -o main.o</strong>
<strong class="highlight">$ gcc person.o student.o main.o -o ex8_2.out</strong>
<strong class="highlight">$ ./ex8_2.out</strong>
First name: John
Last name: Doe
Birth year: 1987
Student number: TA5667
Passed credits: 134
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 8-2: Building and running example 8.2</p>
			<p class="normal">The following example, <em class="italics">example 8.3</em>, will address the second approach to implementing inheritance relationships in C. The output should be very similar to <a id="_idTextAnchor232"/><em class="italics">example 8.2</em>.</p>
			<h3 id="_idParaDest-125" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor233"/>The second approach to inheritance in C</h3>
			<p class="normal">Using the first <a id="_idIndexMarker587"/>approach, we kept a structure variable as the first field in the child's attribute structure. Now, using the second approach, we'll keep a pointer to the parent's structure variable. This way, the child class can be independent of the implementation of the parent class, which is a good thing, considering information-hiding concerns.</p>
			<p class="normal">We gain some advantages, and we lose some by choosing the second approach. After demonstrating <em class="italics">example 8.3</em> we will conduct a comparison between the two approaches, and you will see the advantages and disadvantages of using each of these techniques.</p>
			<p class="normal"><em class="italics">Example 8.3</em>, below, is<a id="_idIndexMarker588"/> remarkably similar to <em class="italics">example 8.2</em>, especially in terms of the output and the final results. However, the main difference is that as part of this example, the <code class="Code-In-Text--PACKT-">Student</code> class only relies on the public interface of the <code class="Code-In-Text--PACKT-">Person</code> class, and not its private definition. This is great because it decouples the classes and allows us to easily change the implementation of the parent class without altering the implementation of the child class.</p>
			<p class="normal">In the preceding example, the <code class="Code-In-Text--PACKT-">Student</code> class didn't strictly violate information-hiding principles, but it could have done that because it had access to the actual definition of <code class="Code-In-Text--PACKT-">person_t</code> and its fields. As a result, it could read or modify the fields without using <code class="Code-In-Text--PACKT-">Person</code>'s behavior functions.</p>
			<p class="normal">As noted, <em class="italics">example 8.3</em> is remarkably similar to <em class="italics">example 8.2</em>, but it has some fundamental differences. The <code class="Code-In-Text--PACKT-">Person</code> class has the same public interface as part of the new example. But this is not true regarding the <code class="Code-In-Text--PACKT-">Student</code> class and its public interface has to be changed. The following code box shows the <code class="Code-In-Text--PACKT-">Student</code> class's new public interface:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_3_STUDENT_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_3_STUDENT_H
//Forward declaration
struct student_t;
// Memory allocator
struct student_t* student_new();
// Constructor
void student_ctor(struct student_t*,
                  const char*  /* first name */,
                  const char*  /* last name */,
                  unsigned int /* birth year */,
                  const char*  /* student number */,
                  unsigned int /* passed credits */);
// Destructor
void student_dtor(struct student_t*);
// Behavior functions
void student_get_first_name(struct student_t*, char*);
void student_get_last_name(struct student_t*, char*);
unsigned int student_get_birth_year(struct student_t*);
void student_get_student_number(struct student_t*, char*);
unsigned int student_get_passed_credits(struct student_t*);
#endif</pre>
			<p class="packt_figref">Code Box 8-11 [ExtremeC_examples_chapter8_3_student.h]: The new public interface of the Student class</p>
			<p class="normal">For reasons you will <a id="_idIndexMarker589"/>realize shortly, the <code class="Code-In-Text--PACKT-">Student</code> class has to repeat all the behavior functions declared as part of the <code class="Code-In-Text--PACKT-">Person</code> class. That's because of the fact that we can no longer cast a <code class="Code-In-Text--PACKT-">student_t</code> pointer to a <code class="Code-In-Text--PACKT-">person_t</code> pointer. In other words, upcasting doesn't work anymore regarding <code class="Code-In-Text--PACKT-">Student</code> and <code class="Code-In-Text--PACKT-">Person</code> pointers.</p>
			<p class="normal">While the public interface of the <code class="Code-In-Text--PACKT-">Person</code> class is not changed from <em class="italics">example 8.2</em>, its implementation has changed. The following code box demonstrates the implementation of the <code class="Code-In-Text--PACKT-">Person</code> class as part of <em class="italics">example 8.3</em>:</p>
			<pre>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
// Private definition
typedef struct {
  char first_name[32];
  char last_name[32];
  unsigned int birth_year;
} person_t;
// Memory allocator
person_t* person_new() {
  return (person_t*)malloc(sizeof(person_t));
}
// Constructor
void person_ctor(person_t* person,
                 const char* first_name,
                 const char* last_name,
                 unsigned int birth_year) {
  strcpy(person-&gt;first_name, first_name);
  strcpy(person-&gt;last_name, last_name);
  person-&gt;birth_year = birth_year;
}
// Destructor
void person_dtor(person_t* person) {
  // Nothing to do
}
// Behavior functions
void person_get_first_name(person_t* person, char* buffer) {
  strcpy(buffer, person-&gt;first_name);
}
void person_get_last_name(person_t* person, char* buffer) {
  strcpy(buffer, person-&gt;last_name);
}
unsigned int person_get_birth_year(person_t* person) {
  return person-&gt;birth_year;
}</pre>
			<p class="packt_figref">Code Box 8-12 [ExtremeC_examples_chapter8_3_person.c]: The new implementation of the Person class</p>
			<p class="normal">As you see, the private<a id="_idIndexMarker590"/> definition of <code class="Code-In-Text--PACKT-">person_t</code> is placed inside the source file and we are not using a private header anymore. This means that we are not going to share the definition with other classes such as the <code class="Code-In-Text--PACKT-">Student</code> class at all. We want to conduct a complete encapsulation of the <code class="Code-In-Text--PACKT-">Person</code> class and hide all its implementation details.</p>
			<p class="normal">The following is the private implementation of the <code class="Code-In-Text--PACKT-">Student</code> class:</p>
			<pre>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
// Public interface of the person class
#include "ExtremeC_examples_chapter8_3_person.h"
//Forward declaration
typedef struct {
  char* student_number;
  unsigned int passed_credits;
  // We have to have a pointer here since the type
  // person_t is incomplete.
<strong class="highlight">  struct person_t* person;</strong>
} student_t;
// Memory allocator
student_t* student_new() {
  return (student_t*)malloc(sizeof(student_t));
}
// Constructor
void student_ctor(student_t* student,
                  const char* first_name,
                  const char* last_name,
                  unsigned int birth_year,
                  const char* student_number,
                  unsigned int passed_credits) {
  // Allocate memory for the parent object
<strong class="highlight">  student-&gt;person = person_new();</strong>
<strong class="highlight">  person_ctor(student-&gt;person, first_name,</strong>
<strong class="highlight">          last_name, birth_year);</strong>
  student-&gt;student_number = (char*)malloc(16 * sizeof(char));
  strcpy(student-&gt;student_number, student_number);
  student-&gt;passed_credits = passed_credits;
}
// Destructor
void student_dtor(student_t* student) {
  // We need to destruct the child object first.
  free(student-&gt;student_number);
  // Then, we need to call the destructor function
  // of the parent class
<strong class="highlight">  person_dtor(student-&gt;person);</strong>
  // And we need to free the parent object's allocated memory
<strong class="highlight">  free(student-&gt;person);</strong>
}
// Behavior functions
void student_get_first_name(student_t* student, char* buffer) {
  // We have to use person's behavior function
  person_get_first_name(student-&gt;person, buffer);
}
void student_get_last_name(student_t* student, char* buffer) {
  // We have to use person's behavior function
  person_get_last_name(student-&gt;person, buffer);
}
unsigned int student_get_birth_year(student_t* student) {
  // We have to use person's behavior function
  return person_get_birth_year(student-&gt;person);
}
void student_get_student_number(student_t* student,
                                char* buffer) {
  strcpy(buffer, student-&gt;student_number);
}
unsigned int student_get_passed_credits(student_t* student) {
  return student-&gt;passed_credits;
}</pre>
			<p class="packt_figref">Code Box 8-13 [ExtremeC_examples_chapter8_3_student.c]: The new implementation of the Student class</p>
			<p class="normal">As demonstrated in the preceding code box, we've used the <code class="Code-In-Text--PACKT-">Person</code> class's public interface by including its header file. In addition, as part of the definition of <code class="Code-In-Text--PACKT-">student_t</code>, we've added a pointer field, which points to the parent <code class="Code-In-Text--PACKT-">Person</code> object. This should remind you of the implementation of a composition relationship done as part of the previous chapter.</p>
			<p class="normal">Note that there is no need<a id="_idIndexMarker591"/> for this pointer field to be the first item in the attribute structure. This is in contrast to what we saw in the first approach. The pointers of the types <code class="Code-In-Text--PACKT-">student_t</code> and <code class="Code-In-Text--PACKT-">person_t</code> are no longer interchangeable, and they are pointing to different addresses in the memory that are not necessarily adjacent. This is again in contrast to what we did in the previous approach.</p>
			<p class="normal">Note that, as part of the <code class="Code-In-Text--PACKT-">Student</code> class's constructor, we instantiate the parent object. Then, we construct it by calling the <code class="Code-In-Text--PACKT-">Person</code> class's constructor and passing the required parameters. That's the same for destructors as well and we destruct the parent object lastly in the <code class="Code-In-Text--PACKT-">Student</code> class's destructor.</p>
			<p class="normal">Since we cannot use the behaviors of the <code class="Code-In-Text--PACKT-">Person</code> class to read the inherited attributes, the <code class="Code-In-Text--PACKT-">Student</code> class is required to offer its set of behavior functions to expose those inherited and private attributes. </p>
			<p class="normal">In other words, the <code class="Code-In-Text--PACKT-">Student</code> class has to provide some wrapper functions to expose the private attributes of its inner parent <code class="Code-In-Text--PACKT-">person</code> object. Note that the <code class="Code-In-Text--PACKT-">Student</code> object itself doesn't know anything about the private attributes of the <code class="Code-In-Text--PACKT-">Person</code> object, and this is in contrast with what we saw in the first approach.</p>
			<p class="normal">The main scenario <a id="_idIndexMarker592"/>is also very similar to how it was as part of <em class="italics">example 8.2</em>. The following code box demonstrates that:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "ExtremeC_examples_chapter8_3_student.h"
int main(int argc, char** argv) {
  // Create and construct the student object
  struct student_t* student = student_new();
  student_ctor(student, "John", "Doe",
          1987, "TA5667", 134);
  // We have to use student's behavior functions because the
  // student pointer is not a person pointer and we cannot
  // access to private parent pointer in the student object.
  char buffer[32];
  student_get_first_name(student, buffer);
  printf("First name: %s\n", buffer);
  student_get_last_name(student, buffer);
  printf("Last name: %s\n", buffer);
  printf("Birth year: %d\n", student_get_birth_year(student));
  student_get_student_number(student, buffer);
  printf("Student number: %s\n", buffer);
  printf("Passed credits: %d\n",
          student_get_passed_credits(student));
  // Destruct and free the student object
  student_dtor(student);
  free(student);
  return 0;
}</pre>
			<p class="packt_figref">Code Box 8-14 [ExtremeC_examples_chapter8_3_main.c]: The main scenario of example 8.3</p>
			<p class="normal">In comparison to the main function in <em class="italics">example 8.2</em>, we have not included the public interface of the <code class="Code-In-Text--PACKT-">Person</code> class. We have also needed to use the <code class="Code-In-Text--PACKT-">Student</code> class's behavior functions because the <code class="Code-In-Text--PACKT-">student_t</code> and <code class="Code-In-Text--PACKT-">person_t</code> pointers are not interchangeable anymore.</p>
			<p class="normal">The following shell box <a id="_idIndexMarker593"/>demonstrates how to compile and run <em class="italics">example 8.3</em>. As you might have guessed, the outputs are identical:</p>
			<pre><strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_3_person.c -o person.o</strong>
<strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_3_student.c -o student.o</strong>
<strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_3_main.c -o main.o</strong>
<strong class="highlight">$ gcc person.o student.o main.o -o ex8_3.out</strong>
<strong class="highlight">$ ./ex8_3.out</strong>
First name: John
Last name: Doe
Birth year: 1987
Student number: TA5667
Passed credits: 134
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 8-3: Building and running example 8.3</p>
			<p class="normal">In the following section, we're going to compare the aforementioned approaches to implement an inheritance<a id="_idTextAnchor234"/> relationship in C.</p>
			<h3 id="_idParaDest-126" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor235"/>Comparison of two approaches</h3>
			<p class="normal">Now that you've seen two<a id="_idIndexMarker594"/> different approaches that we can take to implement inheritance in C, we can compare them. The following bullet points outline the similarities and differences between the two approaches:</p>
			<ul>
				<li class="list">Both approaches intrinsically show composition relationships.</li>
				<li class="list">The first approach keeps a structure variable in the child's attribute structure and relies on having access to the private implementation of the parent class. However, the second approach keeps a structure pointer from the incomplete type of the parent's attribute structure, and hence, it doesn't rely on the private implementation of the parent class.</li>
				<li class="list">In the first approach, the parent and child types are strongly dependent. In the second approach, the classes are independent of each other, and everything inside the parent implementation is hidden from the child.</li>
				<li class="list">In the first approach, you can have only one parent. In other words, it is a way to implement <em class="italics">single inheritance</em> in C. However, in the second approach, you can have as many parents as you like, thereby demonstrating the concept of <em class="italics">multiple inheritance</em>.</li>
				<li class="list">In the first approach, the parent's structure variable must be the first field in the attribute structure of the child class, but in the second approach, the pointers to parent objects can be put anywhere in the structure.</li>
				<li class="list">In the first approach, there were no two separate parent and child objects. The parent object was included in the child object, and a pointer to the child object was actually a pointer to the parent object.</li>
				<li class="list">In the first approach, we <a id="_idIndexMarker595"/>could use the behavior functions of the parent class, but in the second approach, we needed to forward the parent's behavior functions through new behavior functions in the child class.</li>
			</ul>
			<p class="normal">So far, we have only talked about inheritance itself and we haven't gone through its usages. One of the most important usages of inheritance is to have <em class="italics">polymorphism</em> in your object model. In the following section, we're going to talk about polymorphism and how it can<a id="_idTextAnchor236"/> be implemented in C.</p>
			<h1 id="_idParaDest-127" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor237"/>Polymorphism</h1>
			<p class="normal">Polymorphism <a id="_idIndexMarker596"/>is not really a relationship between two classes. It is mostly a technique for keeping the same code while having different behaviors. It allows us to extend code or add functionalities without having to recompile the whole code base. </p>
			<p class="normal">In this section, we try to cover what polymorphism is and how we can have it in C. This also gives us a better view of how modern programming languages such as C++ implement polymorphism. We'll start by <a id="_idTextAnchor238"/>defining polymorphism.</p>
			<h2 id="_idParaDest-128" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor239"/>What is polymorphism?</h2>
			<p class="normal">Polymorphism <a id="_idIndexMarker597"/>simply means to have different behaviors by just using the same public interface (or set of behavior functions). </p>
			<p class="normal">Suppose that we have two classes, <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code>, and they each have a behavior function, <code class="Code-In-Text--PACKT-">sound</code>, which makes them print their specific sound. Explaining polymorphism is not an easy task to do and we'll try to take a top-down approach in explaining it. First, we'll try to give you an idea of how polymorphic code looks and how it behaves, and then we'll dive into implementing it in C. Once you get the idea, it will be easier to move into the implementation. In the following <a id="_idIndexMarker598"/>code boxes, we first create some objects, and then we see how we would expect a polymorphic function to behave if polymorphism was in place. First, let's create three objects. We have already assumed that both the <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code> classes are children of the <code class="Code-In-Text--PACKT-">Animal</code> class:</p>
			<pre>struct animal_t* animal = animal_malloc();
animal_ctor(animal);
struct cat_t* cat = cat_malloc();
cat_ctor(cat);
struct duck_t* duck = duck_malloc();
duck_ctor(duck);</pre>
			<p class="packt_figref">Code Box 8-15: Creating three objects of types Animal, Cat, and Duck</p>
			<p class="normal"><em class="italics">Without</em> polymorphism, we would have called the <code class="Code-In-Text--PACKT-">sound</code> behavior function for each object as follows:</p>
			<pre>// This is not a polymorphism
animal_sound(animal);
cat_sound(cat);
duck_sound(duck);</pre>
			<p class="packt_figref">Code Box 8-16: Calling the sound behavior function on the created objects</p>
			<p class="normal">And the output would be as follows:</p>
			<pre>Animal: Beeeep
Cat: Meow
Duck: Quack</pre>
			<p class="packt_figref">Shell Box 8-4: The output of the function calls</p>
			<p class="normal">The preceding code box is not demonstrating polymorphism because it uses different functions, <code class="Code-In-Text--PACKT-">cat_sound</code> and <code class="Code-In-Text--PACKT-">duck_sound</code>, to call specific behaviors from the <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code> objects. However, the following code box shows how we expect a polymorphic function to behave. The following code box contains a perfect example of polymorphism:</p>
			<pre>// This is a polymorphism
animal_sound(animal);
animal_sound((struct animal_t*)cat);
animal_sound((struct animal_t*)duck);</pre>
			<p class="packt_figref">Code Box 8-17: Calling the same sound behavior function on all three objects</p>
			<p class="normal">Despite calling the <a id="_idIndexMarker599"/>same function three times, we expect to see different behaviors. It seems that passing different object pointers changes the actual behavior behind <code class="Code-In-Text--PACKT-">animal_sound</code>. The following shell box would be the output of <em class="italics">Code Box 8-17</em> if <code class="Code-In-Text--PACKT-">animal_sound</code> was polymorphic:</p>
			<pre>Animal: Beeeep
Cat: Meow
Duck: Quake</pre>
			<p class="packt_figref">Shell Box 8-5: The output of the function calls</p>
			<p class="normal">As you see in <em class="italics">Code Box 8-17</em>, we have used the same function, <code class="Code-In-Text--PACKT-">animal_sound</code>, but with different pointers, and as a result, different functions have been invoked behind the scenes.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">CAUTION</strong>:</p>
					<p class="Information-Box--PACKT-">Please don't move forward if you're having trouble understanding the preceding code; if you are, please recap the previous section.</p>
				</div>
			</div>
			<p class="normal">The preceding polymorphic code implies that there should be an inheritance relationship between the <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code> classes with a third class, <code class="Code-In-Text--PACKT-">Animal</code>, because we want to be able to cast the <code class="Code-In-Text--PACKT-">duck_t</code> and <code class="Code-In-Text--PACKT-">cat_t</code> pointers to an <code class="Code-In-Text--PACKT-">animal_t</code> pointer. This also implies something else: we have to use the first approach of implementing inheritance in C in order to benefit from the polymorphism mechanism we introduced before.</p>
			<p class="normal">You may recall that in the first approach to implementing inheritance, the child class had access to the private implementation of the parent class, and here a structure variable from the <code class="Code-In-Text--PACKT-">animal_t</code> type should have been put as the first field in the definitions of the <code class="Code-In-Text--PACKT-">duck_t</code> and <code class="Code-In-Text--PACKT-">cat_t</code> attribute structures. The following code shows the relationship between these three classes:</p>
			<pre>typedef struct {
  ...} <strong class="highlight">animal_t;</strong>
typedef struct {
  animal_t animal;
  ...
} <strong class="highlight">cat_t;</strong>
typedef struct {
  animal_t animal;
  ...
} <strong class="highlight">duck_t;</strong></pre>
			<p class="packt_figref">Code Box 8-18: The definitions of the attribute structures of classes Animal, Cat, and Duck</p>
			<p class="normal">With this setup, we can cast the <code class="Code-In-Text--PACKT-">duck_t</code> and <code class="Code-In-Text--PACKT-">cat_t</code> pointers to the <code class="Code-In-Text--PACKT-">animal_t</code> pointers, and then we can use the same behavior functions for both child classes.</p>
			<p class="normal">So far, we have <a id="_idIndexMarker600"/>shown how a polymorphic function is expected to behave and how an inheritance relationship should be defined between the classes. What we haven't shown is how this polymorphic behavior is fulfilled. In other words, we haven't talked about the actual mechanism behind the polymorphism.</p>
			<p class="normal">Suppose that the behavior function <code class="Code-In-Text--PACKT-">animal_sound</code> is defined as it can be seen in code box 8-19. No matter the pointer you send inside as the argument, we will have always one behavior and the function calls won't be polymorphic without the underlying mechanism. The mechanism will be explained as part of <em class="italics">example 8.4</em> which you will see shortly:</p>
			<pre>void animal_sound(animal_t* ptr) {
  printf("Animal: Beeeep");
}
// This could be a polymorphism, but it is NOT!
animal_sound(animal);
animal_sound((struct animal_t*)cat);
animal_sound((struct animal_t*)duck);</pre>
			<p class="packt_figref">Code Box 8-19: The function animal_sound is not polymorphic yet!</p>
			<p class="normal">As you see next, calling the behavior function <code class="Code-In-Text--PACKT-">animal_sound</code> with various pointers won't change the logic of the behavior function; in other words, it is not polymorphic. We will make this function polymorphic as part of the next example, <em class="italics">example 8.4</em>:</p>
			<pre>Animal: Beeeep
Animal: Beeeep
Animal: Beeeep</pre>
			<p class="packt_figref">Shell Box 8-6: The output of the functional calls in Code Box 8-19</p>
			<p class="normal">So, what is the underlying mechanism that enables polymorphic behavior functions? We answer that question in the upcoming sections, but before that we need to know why we want to have polymo<a id="_idTextAnchor240"/>rphism in the first place.</p>
			<h2 id="_idParaDest-129" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor241"/>Why do we need polymorphism?</h2>
			<p class="normal">Before talking<a id="_idIndexMarker601"/> further about the way in which we're going to implement polymorphism in C, we should spend some time talking about the reasons behind the need for polymorphism. The main reason why polymorphism is needed is that we want to keep a piece of code "as is," even when using it with various subtypes of a base type. You are going to see some demonstration of this shortly in the examples.</p>
			<p class="normal">We don't want to modify the current logic very often when we add new subtypes to the system, or when the behavior of one subtype is being changed. It's just not realistic to have zero changes when a new feature is added – there will always be some changes – but using polymorphism, we can significantly reduce the number of changes that are needed.</p>
			<p class="normal">Another motivation for having polymorphism is due to the concept of <em class="italics">abstraction</em>. When we have abstract types (or classes), they usually have some vague or unimplemented behavior functions that need to be <em class="italics">overridden</em> in child classes and polymorphism is the key way to do this.</p>
			<p class="normal">Since we want to use abstract types to write our logic, we need a way to call the proper implementation when dealing with pointers of very abstract types. This is another place where polymorphism comes in. No matter what the language is, we need a way to have polymorphic behaviors, otherwise the cost of maintaining a big project can grow quickly, for instance when we are going to add a new subtype to our code.</p>
			<p class="normal">Now that we've established the importance of polymorphism, it's time to expla<a id="_idTextAnchor242"/>in how we can have it in C.</p>
			<h2 id="_idParaDest-130" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor243"/>How to have polymorphic behavior in C</h2>
			<p class="normal">If we want to have<a id="_idIndexMarker602"/> polymorphism in C, we need to use the first approach we explored to implementing inheritance in C. To achieve polymorphic behavior, we can utilize <em class="italics">function pointers</em>. However, this time, these function pointers need to be kept as some fields in the attribute structure. Let's implement the animal sound example to illustrate this.</p>
			<p class="normal">We have three classes, <code class="Code-In-Text--PACKT-">Animal</code>, <code class="Code-In-Text--PACKT-">Cat</code>, and <code class="Code-In-Text--PACKT-">Duck</code>, and <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code> are subtypes of <code class="Code-In-Text--PACKT-">Animal</code>. Each class has one header and one source. The <code class="Code-In-Text--PACKT-">Animal</code> class has an extra private header file that contains the actual definition of its attribute structure. This private header is required since we are taking the first approach to implement inheritance. The private header is going to be used by the <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code> classes.</p>
			<p class="normal">The following code box <a id="_idIndexMarker603"/>shows the public interface of the <code class="Code-In-Text--PACKT-">Animal</code> class:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_4_ANIMAL_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_4_ANIMAL_H
// Forward declaration
struct animal_t;
// Memory allocator
struct animal_t* animal_new();
// Constructor
void animal_ctor(struct animal_t*);
// Destructor
void animal_dtor(struct animal_t*);
// Behavior functions
<strong class="highlight">void animal_get_name(struct animal_t*, char*);</strong>
<strong class="highlight">void animal_sound(struct animal_t*);</strong>
#endif</pre>
			<p class="packt_figref">Code Box 8-20 [ExtremeC_examples_chapter8_4_animal.h]: The public interface of the Animal class</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">Animal</code> class has two behavior functions. The <code class="Code-In-Text--PACKT-">animal_sound</code> function is supposed to be polymorphic and can be overridden by the child classes, while the other behavior function, <code class="Code-In-Text--PACKT-">animal_get_name</code>, is not polymorphic, and children cannot override it.</p>
			<p class="normal">The following is the private definition of the <code class="Code-In-Text--PACKT-">animal_t</code> attribute structure:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_4_ANIMAL_P_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_4_ANIMAL_P_H
// The function pointer type needed to point to
// different morphs of animal_sound
<strong class="highlight">typedef void (*sound_func_t)(void*);</strong>
// Forward declaration
typedef struct {
  char* name;
  // This member is a pointer to the function which
  // performs the actual sound behavior
<strong class="highlight">  sound_func_t sound_func;</strong>
} animal_t;
#endif</pre>
			<p class="packt_figref">Code Box 8-21 [ExtremeC_examples_chapter8_4_animal_p.h]: The private header of the Animal class</p>
			<p class="normal">In polymorphism, every<a id="_idIndexMarker604"/> child class can provide its own version of the <code class="Code-In-Text--PACKT-">animal_sound</code> function. In other words, every child class can override the function inherited from its parent class. Therefore, we need to have a different function for each child class that wants to override it. This means, if the child class has overridden the <code class="Code-In-Text--PACKT-">animal_sound</code>, its own overridden function should be called.</p>
			<p class="normal">That's why we are using function pointers here. Each instance of <code class="Code-In-Text--PACKT-">animal_t</code> will have a function pointer dedicated to the behavior <code class="Code-In-Text--PACKT-">animal_sound</code>, and that pointer is pointing to the actual definition of the polymorphic function inside the class.</p>
			<p class="normal">For each polymorphic behavior function, we have a dedicated function pointer. Here, you will see how we use this function pointer to do the correct function call in each subclass. In other words, we show how the polymorphism actually works.</p>
			<p class="normal">The following code box shows the definition of the <code class="Code-In-Text--PACKT-">Animal</code> class:</p>
			<pre>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include "ExtremeC_examples_chapter8_4_animal_p.h"
// Default definition of the animal_sound at the parent level
<strong class="highlight">void __animal_sound(void* this_ptr) {</strong>
<strong class="highlight">  animal_t* animal = (animal_t*)this_ptr;</strong>
<strong class="highlight">  printf("%s: Beeeep\n", animal-&gt;name);</strong>
<strong class="highlight">}</strong>
// Memory allocator
animal_t* animal_new() {
  return (animal_t*)malloc(sizeof(animal_t));
}
// Constructor
void animal_ctor(animal_t* animal) {
  animal-&gt;name = (char*)malloc(10 * sizeof(char));
  strcpy(animal-&gt;name, "Animal");
  // Set the function pointer to point to the default definition
<strong class="highlight">  animal-&gt;sound_func = __animal_sound;</strong>
}
// Destructor
void animal_dtor(animal_t* animal) {
  free(animal-&gt;name);
}
// Behavior functions
void animal_get_name(animal_t* animal, char* buffer) {
  strcpy(buffer, animal-&gt;name);
}
void animal_sound(animal_t* animal) {
  // Call the function which is pointed by the function pointer.
<strong class="highlight">  animal-&gt;sound_func(animal);</strong>
}</pre>
			<p class="packt_figref">Code Box 8-22 [ExtremeC_examples_chapter8_4_animal.c]: The definition of the Animal class</p>
			<p class="normal">The actual <a id="_idIndexMarker605"/>polymorphic behavior is happening in <em class="italics">Code Box 8-22</em>, inside the function <code class="Code-In-Text--PACKT-">animal_sound</code>. The private function <code class="Code-In-Text--PACKT-">__animal_sound</code> is supposed to be the default behavior of the <code class="Code-In-Text--PACKT-">animal_sound</code> function when the subclasses decide not to override it. You will see in the next chapter that polymorphic behavior functions have a default definition which will get inherited and used if the subclass doesn't provide the overridden version.</p>
			<p class="normal">Moving on, inside the constructor <code class="Code-In-Text--PACKT-">animal_ctor</code>, we store the address of <code class="Code-In-Text--PACKT-">__animal_sound</code> into the <code class="Code-In-Text--PACKT-">sound_func</code> field of the <code class="Code-In-Text--PACKT-">animal</code> object. Remember that <code class="Code-In-Text--PACKT-">sound_func</code> is a function pointer. In this setup, every child object inherits this function pointer, which points to the default definition <code class="Code-In-Text--PACKT-">__animal_sound</code>.</p>
			<p class="normal">And the final step, inside the behavior function <code class="Code-In-Text--PACKT-">animal_sound</code>, we just call the function that is being pointed to by the <code class="Code-In-Text--PACKT-">sound_func</code> field. Again, <code class="Code-In-Text--PACKT-">sound_func</code> is the function pointer field pointing to the actual definition of the sound behavior which in the preceding case is <code class="Code-In-Text--PACKT-">__animal_sound</code>. Note that the <code class="Code-In-Text--PACKT-">animal_sound</code> function behaves more like a relay to the actual behavior function.</p>
			<p class="normal">Using this setup, if the <code class="Code-In-Text--PACKT-">sound_func</code> field was pointing to another function, then that function would have been called if <code class="Code-In-Text--PACKT-">animal_sound</code> was invoked. That's the trick we are going to use in the <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code> classes to override the default definition of the <code class="Code-In-Text--PACKT-">sound</code> behavior.</p>
			<p class="normal">Now, it's time to <a id="_idIndexMarker606"/>show the <code class="Code-In-Text--PACKT-">Cat</code> and <code class="Code-In-Text--PACKT-">Duck</code> classes. The following code boxes will show the <code class="Code-In-Text--PACKT-">Cat</code> class's public interface and private implementation. First, we show the <code class="Code-In-Text--PACKT-">Cat</code> class's public interface:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_4_CAT_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_4_CAT_H
// Forward declaration
struct cat_t;
// Memory allocator
struct cat_t* cat_new();
// Constructor
void cat_ctor(struct cat_t*);
// Destructor
void cat_dtor(struct cat_t*);
// All behavior functions are inherited from the animal class.
#endif</pre>
			<p class="packt_figref">Code Box 8-23 [ExtremeC_examples_chapter8_4_cat.h]: The public interface of the Cat class</p>
			<p class="normal">As you will see shortly, it will inherit the <code class="Code-In-Text--PACKT-">sound</code> behavior from its parent class, the <code class="Code-In-Text--PACKT-">Animal</code> class. </p>
			<p class="normal">The following code box shows the definition of the <code class="Code-In-Text--PACKT-">Cat</code> class:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "ExtremeC_examples_chapter8_4_animal.h"
#include "ExtremeC_examples_chapter8_4_animal_p.h"
typedef struct {
  animal_t animal;
} cat_t;
// Define a new behavior for the cat's sound
<strong class="highlight">void __cat_sound(void* ptr) {</strong>
<strong class="highlight">  animal_t* animal = (animal_t*)ptr;</strong>
<strong class="highlight">  printf("%s: Meow\n", animal-&gt;name);</strong>
<strong class="highlight">}</strong>
// Memory allocator
cat_t* cat_new() {
  return (cat_t*)malloc(sizeof(cat_t));
}
// Constructor
void cat_ctor(cat_t* cat) {
  animal_ctor((struct animal_t*)cat);
  strcpy(cat-&gt;animal.name, "Cat");
  // Point to the new behavior function. Overriding
  // is actually happening here.
<strong class="highlight">  cat-&gt;animal.sound_func = __cat_sound;</strong>
}
// Destructor
void cat_dtor(cat_t* cat) {
  animal_dtor((struct animal_t*)cat);
}</pre>
			<p class="packt_figref">Code Box 8-24 [ExtremeC_examples_chapter8_4_cat.c]: The private implementation of the Cat class</p>
			<p class="normal">As you see in the <a id="_idIndexMarker607"/>previous code box, we have defined a new function for the cat's sound, <code class="Code-In-Text--PACKT-">__cat_sound</code>. Then inside the constructor, we make the <code class="Code-In-Text--PACKT-">sound_func</code> pointer point to this function. </p>
			<p class="normal">Now, overriding is happening, and from now on, all <code class="Code-In-Text--PACKT-">cat</code> objects will actually call <code class="Code-In-Text--PACKT-">__cat_sound</code> instead of <code class="Code-In-Text--PACKT-">__animal_sound</code>. The same technique is used for the <code class="Code-In-Text--PACKT-">Duck</code> class.</p>
			<p class="normal">The following code box shows the public interface of the <code class="Code-In-Text--PACKT-">Duck</code> class:</p>
			<pre>#ifndef EXTREME_C_EXAMPLES_CHAPTER_8_4_DUCK_H
#define EXTREME_C_EXAMPLES_CHAPTER_8_4_DUCK_H
// Forward declaration
struct duck_t;
// Memory allocator
struct duck_t* duck_new();
// Constructor
void duck_ctor(struct duck_t*);
// Destructor
void duck_dtor(struct duck_t*);
// All behavior functions are inherited from the animal class.
#endif</pre>
			<p class="packt_figref">Code Box 8-25 [ExtremeC_examples_chapter8_4_duck.h]: The public interface of the Duck class</p>
			<p class="normal">As you see, that's<a id="_idIndexMarker608"/> quite similar to the <code class="Code-In-Text--PACKT-">Cat</code> class. Let's bring up the private definition of the <code class="Code-In-Text--PACKT-">Duck</code> class:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "ExtremeC_examples_chapter8_4_animal.h"
#include "ExtremeC_examples_chapter8_4_animal_p.h"
typedef struct {
  animal_t animal;
} duck_t;
// Define a new behavior for the duck's sound
<strong class="highlight">void __duck_sound(void* ptr) {</strong>
<strong class="highlight">  animal_t* animal = (animal_t*)ptr;</strong>
<strong class="highlight">  printf("%s: Quacks\n", animal-&gt;name);</strong>
<strong class="highlight">}</strong>
// Memory allocator
duck_t* duck_new() {
  return (duck_t*)malloc(sizeof(duck_t));
}
// Constructor
void duck_ctor(duck_t* duck) {
  animal_ctor((struct animal_t*)duck);
  strcpy(duck-&gt;animal.name, "Duck");
  // Point to the new behavior function. Overriding
  // is actually happening here.
<strong class="highlight">  duck-&gt;animal.sound_func = __duck_sound;</strong>
}
// Destructor
void duck_dtor(duck_t* duck) {
  animal_dtor((struct animal_t*)duck);
}</pre>
			<p class="packt_figref">Code Box 8-26 [ExtremeC_examples_chapter8_4_duck.c]: The private implementation of the Duck class</p>
			<p class="normal">As you can see, the<a id="_idIndexMarker609"/> technique has been used to override the default definition of the <code class="Code-In-Text--PACKT-">sound</code> behavior. A new private behavior function, <code class="Code-In-Text--PACKT-">__duck_sound</code>, has been defined that does the duck-specific sound, and the <code class="Code-In-Text--PACKT-">sound_func</code> pointer is updated to point to this function. This is basically the way that polymorphism is introduced to C++. We will talk more about this in the next chapter.</p>
			<p class="normal">Finally, the following code box demonstrates the main scenario of <em class="italics">example 8.4</em>:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
// Only public interfaces
#include "ExtremeC_examples_chapter8_4_animal.h"
#include "ExtremeC_examples_chapter8_4_cat.h"
#include "ExtremeC_examples_chapter8_4_duck.h"
int main(int argc, char** argv) {
  struct animal_t* animal = animal_new();
  struct cat_t* cat = cat_new();
  struct duck_t* duck = duck_new();
  animal_ctor(animal);
  cat_ctor(cat);
  duck_ctor(duck);
<strong class="highlight">  animal_sound(animal);</strong>
<strong class="highlight">  animal_sound((struct animal_t*)cat);</strong>
<strong class="highlight">  animal_sound((struct animal_t*)duck);</strong>
  animal_dtor(animal);
  cat_dtor(cat);
  duck_dtor(duck);
  free(duck);
  free(cat);
  free(animal);
  return 0;
}</pre>
			<p class="packt_figref">Code Box 8-27 [ExtremeC_examples_chapter8_4_main.c]: The main scenario of example 8.4</p>
			<p class="normal">As you see in the preceding code box, we are only using the public interfaces of the <code class="Code-In-Text--PACKT-">Animal</code>, <code class="Code-In-Text--PACKT-">Cat</code>, and <code class="Code-In-Text--PACKT-">Duck</code> classes. So, the <code class="Code-In-Text--PACKT-">main</code> function doesn't know anything about the internal implementation of <a id="_idIndexMarker610"/>the classes. Calling the <code class="Code-In-Text--PACKT-">animal_sound</code> function with passing different pointers demonstrates how a polymorphic behavior should work. Let's look at the output of the example.</p>
			<p class="normal">The following shell box shows how to compile and run <em class="italics">example 8.4</em>:</p>
			<pre><strong class="highlight">$ gcc -c E</strong><strong class="highlight">xtremeC_examples_chapter8_4_animal.c -o animal.o</strong>
<strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_4_cat.c -o cat.o</strong>
<strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_4_duck.c -o duck.o</strong>
<strong class="highlight">$ gcc -c ExtremeC_examples_chapter8_4_main.c -o main.o</strong>
<strong class="highlight">$ gcc animal.o cat.o duck.o main.o -o ex8_4.out</strong>
<strong class="highlight">$ ./ex8_4.out</strong>
Animal: Beeeep
Cat: Meow
Duck: Quake
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 8-7: The compilation, execution, and output of example 8.4</p>
			<p class="normal">As you can see in <em class="italics">example 8.4</em>, in class-based programming languages the behavior functions which we want to be polymorphic need special care and should be treated differently. Otherwise, a simple behavior function without the underlying mechanism that we discussed as part of <em class="italics">example 8.4</em> cannot be polymorphic. That's why we have a special name for these behavior functions, and why we use specific keywords to denote a function to be polymorphic in a language such as C++. These functions are called <em class="italics">virtual</em> functions. Virtual functions are behavior functions that can be overridden by child classes. Virtual functions need to be tracked by the compiler, and proper pointers should be placed in the corresponding objects to point to the actual definitions<a id="_idIndexMarker611"/> when overridden. These pointers are used at runtime to execute the right version of the function.</p>
			<p class="normal">In the next chapter, we'll see how C++ handles object-oriented relationships between classes. Also, we will find out how C++ implements polymorphism. We will also discuss <em class="italics">Abstraction</em> which is a direct result of polymorphism.</p>
			<h1 id="_idParaDest-131" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor244"/>Summary</h1>
			<p class="normal">In this chapter, we continued our exploration of topics in OOP, picking up from where we left off in the previous chapter. The following topics were discussed in this chapter:</p>
			<ul>
				<li class="list">We explained how inheritance works and looked at the two approaches that we can use to implement inheritance in C.</li>
				<li class="list">The first approach allows direct access to all the private attributes of the parent class, but the second approach has a more conservative approach, hiding the private attributes of the parent class.</li>
				<li class="list">We compared these approaches, and we saw that each of them can be suitable in some use cases.</li>
				<li class="list">Polymorphism was the next topic that we explored. To put it simply, it allows us to have different versions of the same behavior and invoke the correct behavior using the public API of an abstract supertype.</li>
				<li class="list">We saw how to write polymorphic code in C and saw how function pointers contribute to choosing the correct version<a id="_idTextAnchor245"/> of a particular behavior at runtime.</li>
			</ul>
			<p class="normal">The next chapter will be our final chapter about object orientation. As part of it, we'll explore how C++ handles encapsulation, inheritance, and polymorphism. More than that, we will discuss the topic of abstraction and how it leads to a bizarre type of class which is called an <em class="italics">abstract class</em>. We cannot create objects from these classes!</p>
		</div>
</body></html>