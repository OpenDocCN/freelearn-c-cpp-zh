<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer106">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 class="chapterTitle" id="_idParaDest-426"><span class="koboSpan" id="kobo.2.1">Working with Files and Streams</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">One of the most important parts of the C++ standard library is the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">input/output</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">I/O</span></strong><span class="koboSpan" id="kobo.7.1">) stream-based library</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.8.1"> that enables developers to work with files, memory streams, or other types of I/O devices. </span><span class="koboSpan" id="kobo.8.2">The first part of this chapter provides solutions to some common stream operations, such as reading and writing data, localization settings, and manipulating the input and output of a stream. </span><span class="koboSpan" id="kobo.8.3">The second part of the chapter explores the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.9.1">filesystem</span></code><span class="koboSpan" id="kobo.10.1"> library, which enables developers to perform operations with the filesystem and its objects, such as files and directories.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">The recipes covered in this chapter are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Reading and writing raw data from/to binary files</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Reading and writing objects from/to binary files</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Using streams on fixed-size external buffers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Using localized settings for streams</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Using I/O manipulators to control the output of a stream</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Using monetary I/O manipulators</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Using time I/O manipulators</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Working with filesystem paths</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Creating, copying, and deleting files and directories</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Removing content from a file</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Checking the properties of an existing file or directory</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Enumerating the content of a directory</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Finding a file</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.25.1">We will start the chapter with a couple of recipes on how to serialize and deserialize data to/from files.</span></p>
<h1 class="heading-1" id="_idParaDest-427"><span class="koboSpan" id="kobo.26.1">Reading and writing raw data from/to binary files</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.27.1">Some of the</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.28.1"> data programs you work with must be persisted to disk files in various ways, including storing data in a database or flat files, either as text or binary data. </span><span class="koboSpan" id="kobo.28.2">This recipe, and the next one, are focused on persisting and</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.29.1"> loading both raw data and objects from and to binary files. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.30.1">In this context, raw data means unstructured data, and, in this recipe, we will consider writing and reading the content of a buffer (that is, a contiguous sequence of memory), which can either be an array, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.31.1">std::vector</span></code><span class="koboSpan" id="kobo.32.1">, or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">std::array</span></code><span class="koboSpan" id="kobo.34.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-428"><span class="koboSpan" id="kobo.35.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.36.1">For this recipe, you should be familiar with the standard stream I/O library, although some explanations, to the extent that is required to understand this recipe, are provided next. </span><span class="koboSpan" id="kobo.36.2">You should also be familiar with the differences between binary and text files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">In this recipe, we will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.38.1">ofstream</span></code><span class="koboSpan" id="kobo.39.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.40.1">ifstream</span></code><span class="koboSpan" id="kobo.41.1"> classes, which are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.42.1">std</span></code><span class="koboSpan" id="kobo.43.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.44.1">&lt;fstream&gt;</span></code><span class="koboSpan" id="kobo.45.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-429"><span class="koboSpan" id="kobo.46.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.47.1">To write the content of a buffer (in our example, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.48.1">std::vector</span></code><span class="koboSpan" id="kobo.49.1">) to a binary file, you should perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.50.1">Open a file stream for writing in binary mode by creating an instance of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">std::ofstream</span></code><span class="koboSpan" id="kobo.52.1"> class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.53.1">std::ofstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.54.1">ofile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.55.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.56.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.57.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.58.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.59.1">Ensure that the file is actually open before writing data to the file:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.60.1">if</span></span><span class="koboSpan" id="kobo.61.1">(ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.62.1">is_open</span></span><span class="koboSpan" id="kobo.63.1">())
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.64.1">// streamed file operations</span></span><span class="koboSpan" id="kobo.65.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.66.1">Write the data to the file by providing a pointer to the array of characters and the number of characters to write. </span><span class="koboSpan" id="kobo.66.2">In the following example, we write the content of a local vector; however, typically, this data comes from a different context:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.67.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.68.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.69.1">char</span></span><span class="koboSpan" id="kobo.70.1">&gt; output {</span><span class="hljs-number"><span class="koboSpan" id="kobo.71.1">0</span></span><span class="koboSpan" id="kobo.72.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.73.1">1</span></span><span class="koboSpan" id="kobo.74.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.75.1">2</span></span><span class="koboSpan" id="kobo.76.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.77.1">3</span></span><span class="koboSpan" id="kobo.78.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.79.1">4</span></span><span class="koboSpan" id="kobo.80.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.81.1">5</span></span><span class="koboSpan" id="kobo.82.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.83.1">6</span></span><span class="koboSpan" id="kobo.84.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.85.1">7</span></span><span class="koboSpan" id="kobo.86.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.87.1">8</span></span><span class="koboSpan" id="kobo.88.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.89.1">9</span></span><span class="koboSpan" id="kobo.90.1">};
ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.91.1">write</span></span><span class="koboSpan" id="kobo.92.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.93.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.94.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.95.1">char</span></span><span class="koboSpan" id="kobo.96.1">*&gt;(output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.97.1">data</span></span><span class="koboSpan" id="kobo.98.1">()), output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.99.1">size</span></span><span class="koboSpan" id="kobo.100.1">());
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.101.1">Optionally, you </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.102.1">can flush the content of the stream’s output buffer to the actual disk file by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">flush()</span></code><span class="koboSpan" id="kobo.104.1"> method. </span><span class="koboSpan" id="kobo.104.2">This determines the uncommitted changes in the stream to be synchronized with the external destination, which, in this case, is a disk file.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.105.1">Close the stream by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">close()</span></code><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">This, in turn, calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">flush()</span></code><span class="koboSpan" id="kobo.109.1">, making the preceding step unnecessary in most contexts:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.110.1">ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.111.1">close</span></span><span class="koboSpan" id="kobo.112.1">();
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.113.1">To read the </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.114.1">entire content of a binary file to a buffer, you should perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.115.1">Open a file stream to read from a file in binary mode by creating an instance of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">std::ifstream</span></code><span class="koboSpan" id="kobo.117.1"> class. </span><span class="koboSpan" id="kobo.117.2">The path to the file can be absolute or relative to the current working directory (not to the path of the executable). </span><span class="koboSpan" id="kobo.117.3">In this example, the path is relative:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.118.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.119.1">ifile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.120.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.121.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.122.1">sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.123.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.124.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.125.1">Ensure that the file is actually open before reading data from it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.126.1">if</span></span><span class="koboSpan" id="kobo.127.1">(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.128.1">is_open</span></span><span class="koboSpan" id="kobo.129.1">())
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.130.1">// streamed file operations</span></span><span class="koboSpan" id="kobo.131.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.132.1">Determine the length of the file by positioning the input position indicator to the end of the file, read its value, and then move the indicator to the beginning:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.133.1">ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.134.1">seekg</span></span><span class="koboSpan" id="kobo.135.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.136.1">0</span></span><span class="koboSpan" id="kobo.137.1">, std::ios_base::end);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.138.1">auto</span></span><span class="koboSpan" id="kobo.139.1"> length = ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.140.1">tellg</span></span><span class="koboSpan" id="kobo.141.1">();
ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.142.1">seekg</span></span><span class="koboSpan" id="kobo.143.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.144.1">0</span></span><span class="koboSpan" id="kobo.145.1">, std::ios_base::beg);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.146.1">Allocate memory to read the content of the file:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.147.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.148.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.149.1">char</span></span><span class="koboSpan" id="kobo.150.1">&gt; input;
input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.151.1">resize</span></span><span class="koboSpan" id="kobo.152.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.153.1">static_cast</span></span><span class="koboSpan" id="kobo.154.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.155.1">size_t</span></span><span class="koboSpan" id="kobo.156.1">&gt;(length));
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.157.1">Read the</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.158.1"> content of the file to the allocated buffer by providing a pointer to the array of characters for receiving the data and the number of characters to read:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.159.1">ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.160.1">read</span></span><span class="koboSpan" id="kobo.161.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.162.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.163.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.164.1">char</span></span><span class="koboSpan" id="kobo.165.1">*&gt;(input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.166.1">data</span></span><span class="koboSpan" id="kobo.167.1">()), length);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.168.1">Check </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.169.1">that the read operation is completed successfully:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.170.1">auto</span></span><span class="koboSpan" id="kobo.171.1"> success = !ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.172.1">fail</span></span><span class="koboSpan" id="kobo.173.1">() &amp;&amp; length == ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.174.1">gcount</span></span><span class="koboSpan" id="kobo.175.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.176.1">Finally, close the file stream:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.177.1">ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.178.1">close</span></span><span class="koboSpan" id="kobo.179.1">();
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-430"><span class="koboSpan" id="kobo.180.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.181.1">The standard stream-based I/O library provides various classes that implement high-level input, output, or both input and output file stream, string stream and character array operations, manipulators that control how these streams behave, and several predefined stream objects (</span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">cin</span></code><span class="koboSpan" id="kobo.183.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.184.1">wcin</span></code><span class="koboSpan" id="kobo.185.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">cout</span></code><span class="koboSpan" id="kobo.187.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">wcout</span></code><span class="koboSpan" id="kobo.189.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">cerr</span></code><span class="koboSpan" id="kobo.191.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">wcerr</span></code><span class="koboSpan" id="kobo.193.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">clog</span></code><span class="koboSpan" id="kobo.195.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">wclog</span></code><span class="koboSpan" id="kobo.197.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.198.1">These streams are implemented as class templates and, for files, the library provides several (non-copyable) classes:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.200.1"> implements the I/O operations for a raw file and is similar in semantics to a C </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">FILE</span></code><span class="koboSpan" id="kobo.202.1"> stream.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">basic_ifstream</span></code><span class="koboSpan" id="kobo.204.1"> implements the high-level file stream input operations defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">basic_istream</span></code><span class="koboSpan" id="kobo.206.1"> stream interface, internally using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.208.1"> object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">basic_ofstream</span></code><span class="koboSpan" id="kobo.210.1"> implements the high-level file stream output operations defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">basic_ostream</span></code><span class="koboSpan" id="kobo.212.1"> stream interface, internally using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.214.1"> object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">basic_fstream</span></code><span class="koboSpan" id="kobo.216.1"> implements the high-level file stream input and output operations defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">basic_iostream</span></code><span class="koboSpan" id="kobo.218.1"> stream interface, internally using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.220.1"> object.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.221.1">These classes are represented in the following class diagram to better understand their relationship:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.222.1"><img alt="" src="../Images/B21549_07_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.223.1">Figure 7.1: Stream class diagram</span></p>
<p class="normal"><span class="koboSpan" id="kobo.224.1">Notice that this</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.225.1"> diagram also features several </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.226.1">classes designed to work with a string-based stream. </span><span class="koboSpan" id="kobo.226.2">These streams, however, will not be discussed here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.227.1">Several typedefs for the class templates mentioned earlier are also defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">&lt;fstream&gt;</span></code><span class="koboSpan" id="kobo.229.1"> header, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">std</span></code><span class="koboSpan" id="kobo.231.1"> namespace. </span><span class="koboSpan" id="kobo.231.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">ofstream</span></code><span class="koboSpan" id="kobo.233.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">ifstream</span></code><span class="koboSpan" id="kobo.235.1"> objects are the type synonyms used in the preceding examples:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.236.1">typedef</span></span><span class="koboSpan" id="kobo.237.1"> basic_ifstream&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.238.1">char</span></span><span class="koboSpan" id="kobo.239.1">&gt;    ifstream;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.240.1">typedef</span></span><span class="koboSpan" id="kobo.241.1"> basic_ifstream&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.242.1">wchar_t</span></span><span class="koboSpan" id="kobo.243.1">&gt; wifstream;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.244.1">typedef</span></span><span class="koboSpan" id="kobo.245.1"> basic_ofstream&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.246.1">char</span></span><span class="koboSpan" id="kobo.247.1">&gt;    ofstream;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.248.1">typedef</span></span><span class="koboSpan" id="kobo.249.1"> basic_ofstream&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.250.1">wchar_t</span></span><span class="koboSpan" id="kobo.251.1">&gt; wofstream;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.252.1">typedef</span></span><span class="koboSpan" id="kobo.253.1"> basic_fstream&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.254.1">char</span></span><span class="koboSpan" id="kobo.255.1">&gt;     fstream;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.256.1">typedef</span></span><span class="koboSpan" id="kobo.257.1"> basic_fstream&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.258.1">wchar_t</span></span><span class="koboSpan" id="kobo.259.1">&gt;  wfstream;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.260.1">In the previous section, you saw how we can write and read raw data to and from a file stream. </span><span class="koboSpan" id="kobo.260.2">Now, we’ll cover this process in more detail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.261.1">To write data to</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.262.1"> a file, we instantiated an object of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">std::ofstream</span></code><span class="koboSpan" id="kobo.264.1">. </span><span class="koboSpan" id="kobo.264.2">In the constructor, we passed the name of the file to be opened and the stream’s open mode, for which we specified </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">std::ios::binary</span></code><span class="koboSpan" id="kobo.266.1"> to indicate binary mode. </span><span class="koboSpan" id="kobo.266.2">Opening the file like this discards the previous file content. </span><span class="koboSpan" id="kobo.266.3">If you want to append content to an existing file, you should also use the flag </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">std::ios::app</span></code><span class="koboSpan" id="kobo.268.1"> (that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">std::ios::app | std::ios::binary</span></code><span class="koboSpan" id="kobo.270.1">). </span><span class="koboSpan" id="kobo.270.2">This constructor internally calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">open()</span></code><span class="koboSpan" id="kobo.272.1"> on its underlying</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.273.1"> raw file object (that is, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.275.1"> object). </span><span class="koboSpan" id="kobo.275.2">If this operation fails, a fail bit is set. </span><span class="koboSpan" id="kobo.275.3">To check whether the stream has been successfully associated with a file device, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">is_open()</span></code><span class="koboSpan" id="kobo.277.1"> (this internally calls the method with the same name from the underlying </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.279.1">). </span><span class="koboSpan" id="kobo.279.2">Writing data to the file stream is done using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">write()</span></code><span class="koboSpan" id="kobo.281.1"> method, which takes a pointer to the string of characters to write and the number of characters to write. </span><span class="koboSpan" id="kobo.281.2">Since this method operates with strings of characters, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.283.1"> is necessary if data is of another type, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">unsigned char</span></code><span class="koboSpan" id="kobo.285.1">, in our example. </span><span class="koboSpan" id="kobo.285.2">The write operation does not set a fail bit in the case of a failure, but it may throw a </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">std::ios_base::failure</span></code><span class="koboSpan" id="kobo.287.1"> exception. </span><span class="koboSpan" id="kobo.287.2">However, data is not written directly to the file device but stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.289.1"> object. </span><span class="koboSpan" id="kobo.289.2">To write it to the file, the buffer needs to be flushed, which is done by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">flush()</span></code><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">This is done automatically when closing the file stream, as shown in the preceding example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">To read data from a file, we instantiated an object of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">std::ifstream</span></code><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">In the constructor, we passed the same arguments that we used for opening the file to write the name of the file and the open mode (that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">std::ios::binary</span></code><span class="koboSpan" id="kobo.296.1">). </span><span class="koboSpan" id="kobo.296.2">The constructor internally calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">open()</span></code><span class="koboSpan" id="kobo.298.1"> on the underlying </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">std::basic_filebuf</span></code><span class="koboSpan" id="kobo.300.1"> object. </span><span class="koboSpan" id="kobo.300.2">To check whether the stream has been successfully associated with a file device, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">is_open()</span></code><span class="koboSpan" id="kobo.302.1"> (this internally calls the method with the same name from the underlying </span><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">basic_filebuf</span></code><span class="koboSpan" id="kobo.304.1">). </span><span class="koboSpan" id="kobo.304.2">In this example, we read the entire content of the file to a memory buffer, in particular, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">std::vector</span></code><span class="koboSpan" id="kobo.306.1">. </span><span class="koboSpan" id="kobo.306.2">Before we can read the data, we must know the size of the file in order to allocate a buffer that is large enough to hold that data. </span><span class="koboSpan" id="kobo.306.3">To do this, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">seekg()</span></code><span class="koboSpan" id="kobo.308.1"> to move the input position indicator to the end of the file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.309.1">Then, we called </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">tellg()</span></code><span class="koboSpan" id="kobo.311.1"> to return the current position, which, in this case, indicates the size of the file, in bytes, and then we moved the input position indicator to the beginning of the file to be able to start reading from the beginning. </span><span class="koboSpan" id="kobo.311.2">Calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">seekg()</span></code><span class="koboSpan" id="kobo.313.1"> to move the position indicator to the end can be avoided by opening the file with the position indicator moved directly to the end. </span><span class="koboSpan" id="kobo.313.2">This can be achieved by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">std::ios::ate</span></code><span class="koboSpan" id="kobo.315.1"> opening flag in the constructor (or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">open()</span></code><span class="koboSpan" id="kobo.317.1"> method). </span><span class="koboSpan" id="kobo.317.2">After allocating enough memory</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.318.1"> for the content of the file, we copied the data from the file into memory using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">read()</span></code><span class="koboSpan" id="kobo.320.1"> method. </span><span class="koboSpan" id="kobo.320.2">This takes a pointer to the string of characters that receives the data read from the stream and the number of characters to be read. </span><span class="koboSpan" id="kobo.320.3">Since the stream operates on characters, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.322.1"> expression is necessary if the buffer contains other types of data, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.323.1">unsigned char</span></code><span class="koboSpan" id="kobo.324.1"> in our example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.325.1">This </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.326.1">operation throws a </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">std::basic_ios::failure</span></code><span class="koboSpan" id="kobo.328.1"> exception if an error occurs. </span><span class="koboSpan" id="kobo.328.2">To determine the number of characters that have been successfully read from the stream, we can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">gcount()</span></code><span class="koboSpan" id="kobo.330.1"> method. </span><span class="koboSpan" id="kobo.330.2">Upon completing the read operation, we close the file stream.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.331.1">An alternative to the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">seekg()</span></code><span class="koboSpan" id="kobo.333.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">tellg()</span></code><span class="koboSpan" id="kobo.335.1"> approach described here for determining the size of an open file is to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">std::filesystem::file_size()</span></code><span class="koboSpan" id="kobo.337.1"> function from the filesystem library. </span><span class="koboSpan" id="kobo.337.2">This requires a path only; it does not need the file to be opened. </span><span class="koboSpan" id="kobo.337.3">It can also determine the size of a directory, but this is implementation-defined. </span><span class="koboSpan" id="kobo.337.4">This function is presented later in the chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.338.1">Checking the properties of an existing file or directory</span></em><span class="koboSpan" id="kobo.339.1"> recipe.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.340.1">The operations shown in these examples are the minimum ones required to write and read data to and from file streams. </span><span class="koboSpan" id="kobo.340.2">It is important, though, that you perform appropriate checks for the success of the operations and to catch any possible exceptions that could occur.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.341.1">An important thing to notice is the value of the argument representing the number of characters to write or read. </span><span class="koboSpan" id="kobo.341.2">In the examples seen so far, we have used buffers of </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">unsigned char</span></code><span class="koboSpan" id="kobo.343.1">. </span><span class="koboSpan" id="kobo.343.2">The size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">unsigned char</span></code><span class="koboSpan" id="kobo.345.1"> is 1, as with </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">char</span></code><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">Therefore, the count of characters is the number of elements in the buffer. </span><span class="koboSpan" id="kobo.347.3">However, if the buffer contains </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">int</span></code><span class="koboSpan" id="kobo.349.1"> elements, for instance, things change. </span><span class="koboSpan" id="kobo.349.2">An </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">int</span></code><span class="koboSpan" id="kobo.351.1"> is, typically, 32-bit, which means that, reinterpreted as </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">char</span></code><span class="koboSpan" id="kobo.353.1">, it is equivalent to 4 characters. </span><span class="koboSpan" id="kobo.353.2">This means that when we write anything that has a size greater than 1, we need to multiply the number of elements by the size of an element, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.354.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.355.1">int</span></span><span class="koboSpan" id="kobo.356.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.357.1">0</span></span><span class="koboSpan" id="kobo.358.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.359.1">1</span></span><span class="koboSpan" id="kobo.360.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.361.1">2</span></span><span class="koboSpan" id="kobo.362.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.363.1">3</span></span><span class="koboSpan" id="kobo.364.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.365.1">4</span></span><span class="koboSpan" id="kobo.366.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.367.1">5</span></span><span class="koboSpan" id="kobo.368.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.369.1">6</span></span><span class="koboSpan" id="kobo.370.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.371.1">7</span></span><span class="koboSpan" id="kobo.372.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.373.1">8</span></span><span class="koboSpan" id="kobo.374.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.375.1">9</span></span><span class="koboSpan" id="kobo.376.1"> };
</span><span class="hljs-function"><span class="koboSpan" id="kobo.377.1">std::ofstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.378.1">ofile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.379.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.380.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.381.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.382.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.383.1">if</span></span><span class="koboSpan" id="kobo.384.1"> (ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.385.1">is_open</span></span><span class="koboSpan" id="kobo.386.1">())
{
   ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.387.1">write</span></span><span class="koboSpan" id="kobo.388.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.389.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.390.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.391.1">char</span></span><span class="koboSpan" id="kobo.392.1">*&gt;(numbers.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.393.1">data</span></span><span class="koboSpan" id="kobo.394.1">()), 
               numbers.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.395.1">size</span></span><span class="koboSpan" id="kobo.396.1">() * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.397.1">sizeof</span></span><span class="koboSpan" id="kobo.398.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.399.1">int</span></span><span class="koboSpan" id="kobo.400.1">));
   ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.401.1">close</span></span><span class="koboSpan" id="kobo.402.1">();
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.403.1">Similarly, when</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.404.1"> we read, we need to account for the size of the elements we read from the file, which is exemplified next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.405.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.406.1">int</span></span><span class="koboSpan" id="kobo.407.1">&gt; input;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.408.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.409.1">ifile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.410.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.411.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.412.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.413.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.414.1">if</span></span><span class="koboSpan" id="kobo.415.1"> (ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.416.1">is_open</span></span><span class="koboSpan" id="kobo.417.1">())
{
   ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.418.1">seekg</span></span><span class="koboSpan" id="kobo.419.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.420.1">0</span></span><span class="koboSpan" id="kobo.421.1">, std::ios_base::end);
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.422.1">auto</span></span><span class="koboSpan" id="kobo.423.1"> length = ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.424.1">tellg</span></span><span class="koboSpan" id="kobo.425.1">();
   ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.426.1">seekg</span></span><span class="koboSpan" id="kobo.427.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.428.1">0</span></span><span class="koboSpan" id="kobo.429.1">, std::ios_base::beg);
   input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.430.1">resize</span></span><span class="koboSpan" id="kobo.431.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.432.1">static_cast</span></span><span class="koboSpan" id="kobo.433.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.434.1">size_t</span></span><span class="koboSpan" id="kobo.435.1">&gt;(length) / </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.436.1">sizeof</span></span><span class="koboSpan" id="kobo.437.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.438.1">int</span></span><span class="koboSpan" id="kobo.439.1">));
   ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.440.1">read</span></span><span class="koboSpan" id="kobo.441.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.442.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.443.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.444.1">char</span></span><span class="koboSpan" id="kobo.445.1">*&gt;(input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.446.1">data</span></span><span class="koboSpan" id="kobo.447.1">()), length);
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.448.1">assert</span></span><span class="koboSpan" id="kobo.449.1">(!ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.450.1">fail</span></span><span class="koboSpan" id="kobo.451.1">() &amp;&amp; length == ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.452.1">gcount</span></span><span class="koboSpan" id="kobo.453.1">());
   ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.454.1">close</span></span><span class="koboSpan" id="kobo.455.1">();
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.456.1">The </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.457.1">example code discussed so far in this recipe can be reorganized in the form of two general functions for writing and reading data to and from a file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.458.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.459.1">write_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.460.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.461.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.462.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.463.1"> * </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.464.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.465.1"> filename,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.466.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.467.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.468.1"> * </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.469.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.470.1"> data,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.471.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.472.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.473.1"> size)</span></span><span class="koboSpan" id="kobo.474.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">auto</span></span><span class="koboSpan" id="kobo.476.1"> success = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.477.1">false</span></span><span class="koboSpan" id="kobo.478.1">;
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.479.1">std::ofstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.480.1">ofile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.481.1">(filename, std::ios::binary)</span></span><span class="koboSpan" id="kobo.482.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.483.1">if</span></span><span class="koboSpan" id="kobo.484.1">(ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.485.1">is_open</span></span><span class="koboSpan" id="kobo.486.1">())
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.487.1">try</span></span><span class="koboSpan" id="kobo.488.1">
    {
      ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.489.1">write</span></span><span class="koboSpan" id="kobo.490.1">(data, size);
      success = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.491.1">true</span></span><span class="koboSpan" id="kobo.492.1">;
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.493.1">catch</span></span><span class="koboSpan" id="kobo.494.1">(std::ios_base::failure &amp;)
    {
      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.495.1">// handle the error</span></span><span class="koboSpan" id="kobo.496.1">
    }
    ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.497.1">close</span></span><span class="koboSpan" id="kobo.498.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.499.1">return</span></span><span class="koboSpan" id="kobo.500.1"> success;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.501.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.502.1">read_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.503.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.504.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.505.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.506.1"> * </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.507.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.508.1"> filename,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.509.1">                 std::function&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.510.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.511.1">*(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.512.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.513.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.514.1">)&gt; allocator)</span></span><span class="koboSpan" id="kobo.515.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.516.1">size_t</span></span><span class="koboSpan" id="kobo.517.1"> readbytes = </span><span class="hljs-number"><span class="koboSpan" id="kobo.518.1">0</span></span><span class="koboSpan" id="kobo.519.1">;
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.520.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.521.1">ifile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.522.1">(filename, std::ios::ate | std::ios::binary)</span></span><span class="koboSpan" id="kobo.523.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.524.1">if</span></span><span class="koboSpan" id="kobo.525.1">(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.526.1">is_open</span></span><span class="koboSpan" id="kobo.527.1">())
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.528.1">auto</span></span><span class="koboSpan" id="kobo.529.1"> length = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.530.1">static_cast</span></span><span class="koboSpan" id="kobo.531.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.532.1">size_t</span></span><span class="koboSpan" id="kobo.533.1">&gt;(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.534.1">tellg</span></span><span class="koboSpan" id="kobo.535.1">());
    ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.536.1">seekg</span></span><span class="koboSpan" id="kobo.537.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.538.1">0</span></span><span class="koboSpan" id="kobo.539.1">, std::ios_base::beg);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.540.1">auto</span></span><span class="koboSpan" id="kobo.541.1"> buffer = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.542.1">allocator</span></span><span class="koboSpan" id="kobo.543.1">(length);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.544.1">try</span></span><span class="koboSpan" id="kobo.545.1">
    {
      ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.546.1">read</span></span><span class="koboSpan" id="kobo.547.1">(buffer, length);
      readbytes = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.548.1">static_cast</span></span><span class="koboSpan" id="kobo.549.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.550.1">size_t</span></span><span class="koboSpan" id="kobo.551.1">&gt;(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.552.1">gcount</span></span><span class="koboSpan" id="kobo.553.1">());
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.554.1">catch</span></span><span class="koboSpan" id="kobo.555.1"> (std::ios_base::failure &amp;)
    {
      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.556.1">// handle the error</span></span><span class="koboSpan" id="kobo.557.1">
    }
    ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.558.1">close</span></span><span class="koboSpan" id="kobo.559.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.560.1">return</span></span><span class="koboSpan" id="kobo.561.1"> readbytes;
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">write_data()</span></code><span class="koboSpan" id="kobo.563.1"> is a </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.564.1">function that takes the name of a file, a pointer to an array of characters, and the length of this array as arguments </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.565.1">and writes the characters to the specified file. </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">read_data()</span></code><span class="koboSpan" id="kobo.567.1"> is a function that takes the name of a file and a function that allocates a buffer and reads the entire content of the file to the buffer that is returned by the allocated function. </span><span class="koboSpan" id="kobo.567.2">The following is an example of how these functions can be used:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.568.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.569.1">int</span></span><span class="koboSpan" id="kobo.570.1">&gt; output {</span><span class="hljs-number"><span class="koboSpan" id="kobo.571.1">0</span></span><span class="koboSpan" id="kobo.572.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.573.1">1</span></span><span class="koboSpan" id="kobo.574.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.575.1">2</span></span><span class="koboSpan" id="kobo.576.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.577.1">3</span></span><span class="koboSpan" id="kobo.578.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.579.1">4</span></span><span class="koboSpan" id="kobo.580.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.581.1">5</span></span><span class="koboSpan" id="kobo.582.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.583.1">6</span></span><span class="koboSpan" id="kobo.584.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.585.1">7</span></span><span class="koboSpan" id="kobo.586.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.587.1">8</span></span><span class="koboSpan" id="kobo.588.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.589.1">9</span></span><span class="koboSpan" id="kobo.590.1">};
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.591.1">int</span></span><span class="koboSpan" id="kobo.592.1">&gt; input;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.593.1">if</span></span><span class="koboSpan" id="kobo.594.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.595.1">write_data</span></span><span class="koboSpan" id="kobo.596.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.597.1">"sample.bin"</span></span><span class="koboSpan" id="kobo.598.1">,
              </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.599.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.600.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.601.1">char</span></span><span class="koboSpan" id="kobo.602.1">*&gt;(output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.603.1">data</span></span><span class="koboSpan" id="kobo.604.1">()),
              output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.605.1">size</span></span><span class="koboSpan" id="kobo.606.1">() * sizeof(int)))
{
  auto lalloc = [&amp;input](</span><span class="hljs-type"><span class="koboSpan" id="kobo.607.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.608.1">const</span></span><span class="koboSpan" id="kobo.609.1"> length) 
  {
    input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.610.1">resize</span></span><span class="koboSpan" id="kobo.611.1">(length) / sizeof(int);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.612.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.613.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.614.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.615.1">char</span></span><span class="koboSpan" id="kobo.616.1">*&gt;(input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.617.1">data</span></span><span class="koboSpan" id="kobo.618.1">());
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.619.1">};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.620.1">if</span></span><span class="koboSpan" id="kobo.621.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.622.1">read_data</span></span><span class="koboSpan" id="kobo.623.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.624.1">"sample.bin"</span></span><span class="koboSpan" id="kobo.625.1">, lalloc) &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.626.1">0</span></span><span class="koboSpan" id="kobo.627.1">)
  {
    std::cout &lt;&lt; (output == input ? </span><span class="hljs-string"><span class="koboSpan" id="kobo.628.1">"equal"</span></span><span class="koboSpan" id="kobo.629.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.630.1">"not equal"</span></span><span class="koboSpan" id="kobo.631.1">)
              &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.632.1">'\n'</span></span><span class="koboSpan" id="kobo.633.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.634.1">Alternatively, we</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.635.1"> could use a dynamically allocated </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.636.1">buffer, instead of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">std::vector</span></code><span class="koboSpan" id="kobo.638.1">; the changes required for this are small in the overall example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.639.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.640.1">int</span></span><span class="koboSpan" id="kobo.641.1">&gt; output {</span><span class="hljs-number"><span class="koboSpan" id="kobo.642.1">0</span></span><span class="koboSpan" id="kobo.643.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.644.1">1</span></span><span class="koboSpan" id="kobo.645.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.646.1">2</span></span><span class="koboSpan" id="kobo.647.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.648.1">3</span></span><span class="koboSpan" id="kobo.649.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.650.1">4</span></span><span class="koboSpan" id="kobo.651.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.652.1">5</span></span><span class="koboSpan" id="kobo.653.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.654.1">6</span></span><span class="koboSpan" id="kobo.655.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.656.1">7</span></span><span class="koboSpan" id="kobo.657.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.658.1">8</span></span><span class="koboSpan" id="kobo.659.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.660.1">9</span></span><span class="koboSpan" id="kobo.661.1">};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.662.1">std::unique_ptr&lt;int[]&gt; input = nullptr;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.663.1">size_t</span></span><span class="koboSpan" id="kobo.664.1"> readb = </span><span class="hljs-number"><span class="koboSpan" id="kobo.665.1">0</span></span><span class="koboSpan" id="kobo.666.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.667.1">if</span></span><span class="koboSpan" id="kobo.668.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.669.1">write_data</span></span><span class="koboSpan" id="kobo.670.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.671.1">"sample.bin"</span></span><span class="koboSpan" id="kobo.672.1">,
              </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.673.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.674.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.675.1">char</span></span><span class="koboSpan" id="kobo.676.1">*&gt;(output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.677.1">data</span></span><span class="koboSpan" id="kobo.678.1">()),
              output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.679.1">size</span></span><span class="koboSpan" id="kobo.680.1">() * sizeof(int)))
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.681.1">if</span></span><span class="koboSpan" id="kobo.682.1">((readb = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.683.1">read_data</span></span><span class="koboSpan" id="kobo.684.1">(
     </span><span class="hljs-string"><span class="koboSpan" id="kobo.685.1">"sample.bin"</span></span><span class="koboSpan" id="kobo.686.1">,
     [&amp;input](</span><span class="hljs-type"><span class="koboSpan" id="kobo.687.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.688.1">const</span></span><span class="koboSpan" id="kobo.689.1"> length) {
       input.reset(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.690.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.691.1">int</span></span><span class="koboSpan" id="kobo.692.1">[length / sizeof(int)]);
       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.693.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.694.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.695.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.696.1">char</span></span><span class="koboSpan" id="kobo.697.1">*&gt;(input.get()); })) &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.698.1">0</span></span><span class="koboSpan" id="kobo.699.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.700.1">auto</span></span><span class="koboSpan" id="kobo.701.1"> cmp = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.702.1">memcmp</span></span><span class="koboSpan" id="kobo.703.1">(output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.704.1">data</span></span><span class="koboSpan" id="kobo.705.1">(), input.get(), output.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.706.1">size</span></span><span class="koboSpan" id="kobo.707.1">());
    std::cout &lt;&lt; (cmp == </span><span class="hljs-number"><span class="koboSpan" id="kobo.708.1">0</span></span><span class="koboSpan" id="kobo.709.1"> ? </span><span class="hljs-string"><span class="koboSpan" id="kobo.710.1">"equal"</span></span><span class="koboSpan" id="kobo.711.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.712.1">"not equal"</span></span><span class="koboSpan" id="kobo.713.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.714.1">'\n'</span></span><span class="koboSpan" id="kobo.715.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.716.1">However, this alternative is only provided to show that </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">read_data()</span></code><span class="koboSpan" id="kobo.718.1"> can be used with different kinds </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.719.1">of input buffers. </span><span class="koboSpan" id="kobo.719.2">It is recommended that you avoid the explicit dynamic allocation of </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.720.1">memory whenever possible.</span></p>
<h2 class="heading-2" id="_idParaDest-431"><span class="koboSpan" id="kobo.721.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.722.1">The way of reading data from a file to memory, as shown in this recipe, is only one of several. </span><span class="koboSpan" id="kobo.722.2">The following is a list of possible alternatives for reading data from a file stream:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.723.1">Initializing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">std::vector</span></code><span class="koboSpan" id="kobo.725.1"> directly using </span><code class="inlineCode"><span class="koboSpan" id="kobo.726.1">std::istreambuf_iterator</span></code><span class="koboSpan" id="kobo.727.1"> iterators (similarly, this can be used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">std::string</span></code><span class="koboSpan" id="kobo.729.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.730.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.731.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.732.1">char</span></span><span class="koboSpan" id="kobo.733.1">&gt; input;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.734.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.735.1">ifile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.736.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.737.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.738.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.739.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.740.1">if</span></span><span class="koboSpan" id="kobo.741.1">(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.742.1">is_open</span></span><span class="koboSpan" id="kobo.743.1">())
{
  input = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.744.1">vector</span></span><span class="koboSpan" id="kobo.745.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.746.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.747.1">char</span></span><span class="koboSpan" id="kobo.748.1">&gt;(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.749.1">istreambuf_iterator</span></span><span class="koboSpan" id="kobo.750.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.751.1">char</span></span><span class="koboSpan" id="kobo.752.1">&gt;(ifile),
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.753.1">istreambuf_iterator</span></span><span class="koboSpan" id="kobo.754.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.755.1">char</span></span><span class="koboSpan" id="kobo.756.1">&gt;());
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.757.1">close</span></span><span class="koboSpan" id="kobo.758.1">();
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.759.1">Assigning the content of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">std::vector</span></code><span class="koboSpan" id="kobo.761.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">std::istreambuf_iterator</span></code><span class="koboSpan" id="kobo.763.1"> iterators:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.764.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.765.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.766.1">char</span></span><span class="koboSpan" id="kobo.767.1">&gt; input;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.768.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.769.1">ifile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.770.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.771.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.772.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.773.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">if</span></span><span class="koboSpan" id="kobo.775.1">(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.776.1">is_open</span></span><span class="koboSpan" id="kobo.777.1">())
{
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.778.1">seekg</span></span><span class="koboSpan" id="kobo.779.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.780.1">0</span></span><span class="koboSpan" id="kobo.781.1">, std::ios_base::end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.782.1">auto</span></span><span class="koboSpan" id="kobo.783.1"> length = ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.784.1">tellg</span></span><span class="koboSpan" id="kobo.785.1">();
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.786.1">seekg</span></span><span class="koboSpan" id="kobo.787.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.788.1">0</span></span><span class="koboSpan" id="kobo.789.1">, std::ios_base::beg);
  input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.790.1">reserve</span></span><span class="koboSpan" id="kobo.791.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.792.1">static_cast</span></span><span class="koboSpan" id="kobo.793.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.794.1">size_t</span></span><span class="koboSpan" id="kobo.795.1">&gt;(length));
    input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.796.1">assign</span></span><span class="koboSpan" id="kobo.797.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.798.1">istreambuf_iterator</span></span><span class="koboSpan" id="kobo.799.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.800.1">char</span></span><span class="koboSpan" id="kobo.801.1">&gt;(ifile),
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.802.1">istreambuf_iterator</span></span><span class="koboSpan" id="kobo.803.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.804.1">char</span></span><span class="koboSpan" id="kobo.805.1">&gt;());
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.806.1">close</span></span><span class="koboSpan" id="kobo.807.1">();
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.808.1">Copying the content of the file stream to a vector using </span><code class="inlineCode"><span class="koboSpan" id="kobo.809.1">std::istreambuf_iterator</span></code><span class="koboSpan" id="kobo.810.1"> iterators and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.811.1">std::back_inserter</span></code><span class="koboSpan" id="kobo.812.1"> adapter to write to the end of the vector:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.813.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.814.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.815.1">char</span></span><span class="koboSpan" id="kobo.816.1">&gt; input;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.817.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.818.1">ifile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.819.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.820.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.821.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.822.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.823.1">if</span></span><span class="koboSpan" id="kobo.824.1">(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.825.1">is_open</span></span><span class="koboSpan" id="kobo.826.1">())
{
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.827.1">seekg</span></span><span class="koboSpan" id="kobo.828.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.829.1">0</span></span><span class="koboSpan" id="kobo.830.1">, std::ios_base::end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.831.1">auto</span></span><span class="koboSpan" id="kobo.832.1"> length = ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.833.1">tellg</span></span><span class="koboSpan" id="kobo.834.1">();
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.835.1">seekg</span></span><span class="koboSpan" id="kobo.836.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.837.1">0</span></span><span class="koboSpan" id="kobo.838.1">, std::ios_base::beg);
  input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.839.1">reserve</span></span><span class="koboSpan" id="kobo.840.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.841.1">static_cast</span></span><span class="koboSpan" id="kobo.842.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.843.1">size_t</span></span><span class="koboSpan" id="kobo.844.1">&gt;(length));
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.845.1">copy</span></span><span class="koboSpan" id="kobo.846.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.847.1">istreambuf_iterator</span></span><span class="koboSpan" id="kobo.848.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.849.1">char</span></span><span class="koboSpan" id="kobo.850.1">&gt;(ifile),
            std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.851.1">istreambuf_iterator</span></span><span class="koboSpan" id="kobo.852.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.853.1">char</span></span><span class="koboSpan" id="kobo.854.1">&gt;(),
            std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.855.1">back_inserter</span></span><span class="koboSpan" id="kobo.856.1">(input));
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.857.1">close</span></span><span class="koboSpan" id="kobo.858.1">();
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.859.1">Compared </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.860.1">to these alternatives, however, the method </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.861.1">described in the </span><em class="italic"><span class="koboSpan" id="kobo.862.1">How to do it...</span></em><span class="koboSpan" id="kobo.863.1"> section is the fastest one, even though the alternatives may look more appealing from an object-oriented perspective. </span><span class="koboSpan" id="kobo.863.2">It is beyond the scope of this recipe to compare the performance of these alternatives, but you can try it as an exercise.</span></p>
<h2 class="heading-2" id="_idParaDest-432"><span class="koboSpan" id="kobo.864.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.865.1">Reading and writing objects from/to binary files</span></em><span class="koboSpan" id="kobo.866.1">, to learn how to serialize and deserialize objects to and from binary files</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.867.1">Using I/O manipulators to control the output of a stream</span></em><span class="koboSpan" id="kobo.868.1">, to learn about the use of helper functions, called manipulators, that control input and output streams using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.869.1">&lt;&lt;</span></code><span class="koboSpan" id="kobo.870.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.871.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.872.1"> stream operators</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-433"><span class="koboSpan" id="kobo.873.1">Reading and writing objects from/to binary files</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.874.1">In the </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.875.1">previous recipe, we learned how to write and</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.876.1"> read raw data (that is, unstructured data) to and from a file. </span><span class="koboSpan" id="kobo.876.2">Many times, however, we must persist and load objects instead. </span><span class="koboSpan" id="kobo.876.3">Writing and reading in the manner shown in the previous recipe works for POD types only. </span><span class="koboSpan" id="kobo.876.4">For anything else, we must explicitly decide what is actually written or read, since writing or reading pointers (including those to virtual tables) and any sort of metadata is not only irrelevant but also semantically wrong. </span><span class="koboSpan" id="kobo.876.5">These operations are commonly referred to as serialization and deserialization. </span><span class="koboSpan" id="kobo.876.6">In this recipe, we will learn how to serialize and deserialize both POD and non-POD types to and from binary files.</span></p>
<h2 class="heading-2" id="_idParaDest-434"><span class="koboSpan" id="kobo.877.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.878.1">For the </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.879.1">examples in this recipe, we will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.880.1">foo</span></code><span class="koboSpan" id="kobo.881.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">foopod</span></code><span class="koboSpan" id="kobo.883.1"> classes, as </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.884.1">follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.885.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.886.1">foo</span></span><span class="koboSpan" id="kobo.887.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.888.1">int</span></span><span class="koboSpan" id="kobo.889.1">         i;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.890.1">char</span></span><span class="koboSpan" id="kobo.891.1">        c;
  std::string s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.892.1">public</span></span><span class="koboSpan" id="kobo.893.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.894.1">foo</span></span><span class="koboSpan" id="kobo.895.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.896.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.897.1">const</span></span><span class="koboSpan" id="kobo.898.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.899.1">0</span></span><span class="koboSpan" id="kobo.900.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.901.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.902.1">const</span></span><span class="koboSpan" id="kobo.903.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.904.1">0</span></span><span class="koboSpan" id="kobo.905.1">, std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.906.1">const</span></span><span class="koboSpan" id="kobo.907.1"> &amp; s = {}):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.908.1">i</span></span><span class="koboSpan" id="kobo.909.1">(i), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.910.1">c</span></span><span class="koboSpan" id="kobo.911.1">(c), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.912.1">s</span></span><span class="koboSpan" id="kobo.913.1">(s)
  {}
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.914.1">foo</span></span><span class="koboSpan" id="kobo.915.1">(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.916.1">const</span></span><span class="koboSpan" id="kobo.917.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.918.1">default</span></span><span class="koboSpan" id="kobo.919.1">;
  foo&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.920.1">operator</span></span><span class="koboSpan" id="kobo.921.1">=(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.922.1">const</span></span><span class="koboSpan" id="kobo.923.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.924.1">default</span></span><span class="koboSpan" id="kobo.925.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.926.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.927.1">operator</span></span><span class="koboSpan" id="kobo.928.1">==(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.929.1">const</span></span><span class="koboSpan" id="kobo.930.1"> &amp; rhv) </span><span class="hljs-type"><span class="koboSpan" id="kobo.931.1">const</span></span><span class="koboSpan" id="kobo.932.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.933.1">return</span></span><span class="koboSpan" id="kobo.934.1"> i == rhv.i &amp;&amp;
           c == rhv.c &amp;&amp;
           s == rhv.s;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.935.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.936.1">operator</span></span><span class="koboSpan" id="kobo.937.1">!=(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.938.1">const</span></span><span class="koboSpan" id="kobo.939.1"> &amp; rhv) </span><span class="hljs-type"><span class="koboSpan" id="kobo.940.1">const</span></span><span class="koboSpan" id="kobo.941.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.942.1">return</span></span><span class="koboSpan" id="kobo.943.1"> !(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.944.1">this</span></span><span class="koboSpan" id="kobo.945.1"> == rhv);
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.946.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.947.1">foopod</span></span><span class="koboSpan" id="kobo.948.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.949.1">bool</span></span><span class="koboSpan" id="kobo.950.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.951.1">char</span></span><span class="koboSpan" id="kobo.952.1"> b;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.953.1">int</span></span><span class="koboSpan" id="kobo.954.1">  c[</span><span class="hljs-number"><span class="koboSpan" id="kobo.955.1">2</span></span><span class="koboSpan" id="kobo.956.1">];
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.957.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.958.1">operator</span></span><span class="koboSpan" id="kobo.959.1">==(foopod </span><span class="hljs-type"><span class="koboSpan" id="kobo.960.1">const</span></span><span class="koboSpan" id="kobo.961.1"> &amp; f1, foopod </span><span class="hljs-type"><span class="koboSpan" id="kobo.962.1">const</span></span><span class="koboSpan" id="kobo.963.1"> &amp; f2)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.964.1">return</span></span><span class="koboSpan" id="kobo.965.1"> f1.a == f2.a &amp;&amp; f1.b == f2.b &amp;&amp;
         f1.c[</span><span class="hljs-number"><span class="koboSpan" id="kobo.966.1">0</span></span><span class="koboSpan" id="kobo.967.1">] == f2.c[</span><span class="hljs-number"><span class="koboSpan" id="kobo.968.1">0</span></span><span class="koboSpan" id="kobo.969.1">] &amp;&amp; f1.c[</span><span class="hljs-number"><span class="koboSpan" id="kobo.970.1">1</span></span><span class="koboSpan" id="kobo.971.1">] == f2.c[</span><span class="hljs-number"><span class="koboSpan" id="kobo.972.1">1</span></span><span class="koboSpan" id="kobo.973.1">];
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.974.1">It is recommended that </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.975.1">you first read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.976.1">Reading and writing raw data from/to binary files</span></em><span class="koboSpan" id="kobo.977.1">, before you continue. </span><span class="koboSpan" id="kobo.977.2">You should also </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.978.1">know what POD (a type that is both trivial and has a standard layout) and non-POD types are and how operators can be overloaded. </span><span class="koboSpan" id="kobo.978.2">You can check the closing notes of the </span><em class="italic"><span class="koboSpan" id="kobo.979.1">Using type traits to query properties of types</span></em><span class="koboSpan" id="kobo.980.1"> recipe, in </span><em class="chapterRef"><span class="koboSpan" id="kobo.981.1">Chapter 6</span></em><span class="koboSpan" id="kobo.982.1">, </span><em class="italic"><span class="koboSpan" id="kobo.983.1">General-Purpose Utilities</span></em><span class="koboSpan" id="kobo.984.1">, for further details on POD types.</span></p>
<h2 class="heading-2" id="_idParaDest-435"><span class="koboSpan" id="kobo.985.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.986.1">To serialize/deserialize POD types that do not contain pointers, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.987.1">ofstream::write()</span></code><span class="koboSpan" id="kobo.988.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">ifstream::read()</span></code><span class="koboSpan" id="kobo.990.1">, as shown in the previous recipe:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.991.1">Serialize objects to a binary file using </span><code class="inlineCode"><span class="koboSpan" id="kobo.992.1">ofstream</span></code><span class="koboSpan" id="kobo.993.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.994.1">write()</span></code><span class="koboSpan" id="kobo.995.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.996.1">std::vector&lt;foopod&gt; output {
  {</span><span class="hljs-literal"><span class="koboSpan" id="kobo.997.1">true</span></span><span class="koboSpan" id="kobo.998.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.999.1">'1'</span></span><span class="koboSpan" id="kobo.1000.1">, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1001.1">1</span></span><span class="koboSpan" id="kobo.1002.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1003.1">2</span></span><span class="koboSpan" id="kobo.1004.1">}},
  {</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1005.1">true</span></span><span class="koboSpan" id="kobo.1006.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1007.1">'2'</span></span><span class="koboSpan" id="kobo.1008.1">, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1009.1">3</span></span><span class="koboSpan" id="kobo.1010.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1011.1">4</span></span><span class="koboSpan" id="kobo.1012.1">}},
  {</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1013.1">false</span></span><span class="koboSpan" id="kobo.1014.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1015.1">'3'</span></span><span class="koboSpan" id="kobo.1016.1">, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1017.1">4</span></span><span class="koboSpan" id="kobo.1018.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1019.1">5</span></span><span class="koboSpan" id="kobo.1020.1">}}
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1021.1">std::ofstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1022.1">ofile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1023.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1024.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1025.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.1026.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1027.1">if</span></span><span class="koboSpan" id="kobo.1028.1">(ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1029.1">is_open</span></span><span class="koboSpan" id="kobo.1030.1">())
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1031.1">for</span></span><span class="koboSpan" id="kobo.1032.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1033.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1034.1">const</span></span><span class="koboSpan" id="kobo.1035.1"> &amp; value : output)
  {
    ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1036.1">write</span></span><span class="koboSpan" id="kobo.1037.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1038.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1039.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1040.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1041.1">char</span></span><span class="koboSpan" id="kobo.1042.1">*&gt;(&amp;value),
                </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1043.1">sizeof</span></span><span class="koboSpan" id="kobo.1044.1">(value));
  }
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1045.1">close</span></span><span class="koboSpan" id="kobo.1046.1">();
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1047.1">Deserialize objects from a binary file using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1048.1">ifstream</span></code><span class="koboSpan" id="kobo.1049.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1050.1">read()</span></code><span class="koboSpan" id="kobo.1051.1"> methods:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1052.1">std::vector&lt;foopod&gt; input;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1053.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1054.1">ifile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1055.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1056.1">"sample.bin"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1057.1">, std::ios::binary)</span></span><span class="koboSpan" id="kobo.1058.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1059.1">if</span></span><span class="koboSpan" id="kobo.1060.1">(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1061.1">is_open</span></span><span class="koboSpan" id="kobo.1062.1">())
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1063.1">while</span></span><span class="koboSpan" id="kobo.1064.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1065.1">true</span></span><span class="koboSpan" id="kobo.1066.1">)
  {
    foopod value;
    ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1067.1">read</span></span><span class="koboSpan" id="kobo.1068.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1069.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1070.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1071.1">char</span></span><span class="koboSpan" id="kobo.1072.1">*&gt;(&amp;value), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1073.1">sizeof</span></span><span class="koboSpan" id="kobo.1074.1">(value));
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1075.1">if</span></span><span class="koboSpan" id="kobo.1076.1">(ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1077.1">fail</span></span><span class="koboSpan" id="kobo.1078.1">() || ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1079.1">eof</span></span><span class="koboSpan" id="kobo.1080.1">()) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1081.1">break</span></span><span class="koboSpan" id="kobo.1082.1">;
    input.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1083.1">push_back</span></span><span class="koboSpan" id="kobo.1084.1">(value);
  }
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1085.1">close</span></span><span class="koboSpan" id="kobo.1086.1">();
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1087.1">To serialize</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.1088.1"> non-POD types (or POD types that contain pointers), you must explicitly write the value of the data members to a file, and to </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.1089.1">deserialize, you must explicitly read from the file to the data members in the same order. </span><span class="koboSpan" id="kobo.1089.2">To demonstrate this, we will consider the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">foo</span></code><span class="koboSpan" id="kobo.1091.1"> class that we defined earlier:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1092.1">Add a member function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">write()</span></code><span class="koboSpan" id="kobo.1094.1"> to serialize objects of this class. </span><span class="koboSpan" id="kobo.1094.2">The method takes a reference to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">ofstream</span></code><span class="koboSpan" id="kobo.1096.1"> and returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1097.1">bool</span></code><span class="koboSpan" id="kobo.1098.1"> indicating whether the operation was successful or not:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1099.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1100.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1101.1">(std::ofstream&amp; ofile)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1102.1">const</span></span><span class="koboSpan" id="kobo.1103.1">
{
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1104.1">write</span></span><span class="koboSpan" id="kobo.1105.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1106.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1107.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1108.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1109.1">char</span></span><span class="koboSpan" id="kobo.1110.1">*&gt;(&amp;i), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1111.1">sizeof</span></span><span class="koboSpan" id="kobo.1112.1">(i));
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1113.1">write</span></span><span class="koboSpan" id="kobo.1114.1">(&amp;c, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1115.1">sizeof</span></span><span class="koboSpan" id="kobo.1116.1">(c));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1117.1">auto</span></span><span class="koboSpan" id="kobo.1118.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1119.1">static_cast</span></span><span class="koboSpan" id="kobo.1120.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1121.1">int</span></span><span class="koboSpan" id="kobo.1122.1">&gt;(s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1123.1">size</span></span><span class="koboSpan" id="kobo.1124.1">());
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1125.1">write</span></span><span class="koboSpan" id="kobo.1126.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1127.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1128.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1129.1">char</span></span><span class="koboSpan" id="kobo.1130.1">*&gt;(&amp;size), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1131.1">sizeof</span></span><span class="koboSpan" id="kobo.1132.1">(size));
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1133.1">write</span></span><span class="koboSpan" id="kobo.1134.1">(s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1135.1">data</span></span><span class="koboSpan" id="kobo.1136.1">(), s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1137.1">size</span></span><span class="koboSpan" id="kobo.1138.1">());
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1139.1">return</span></span><span class="koboSpan" id="kobo.1140.1"> !ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1141.1">fail</span></span><span class="koboSpan" id="kobo.1142.1">();
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1143.1">Add a member function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1144.1">read()</span></code><span class="koboSpan" id="kobo.1145.1"> to deserialize the objects of this class. </span><span class="koboSpan" id="kobo.1145.2">This method takes a reference to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">ifstream</span></code><span class="koboSpan" id="kobo.1147.1"> and returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1148.1">bool</span></code><span class="koboSpan" id="kobo.1149.1"> indicating whether the operation was successful or not:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1150.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1151.1">read</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1152.1">(std::ifstream&amp; ifile)</span></span><span class="koboSpan" id="kobo.1153.1">
{
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1154.1">read</span></span><span class="koboSpan" id="kobo.1155.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1156.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1157.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1158.1">char</span></span><span class="koboSpan" id="kobo.1159.1">*&gt;(&amp;i), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1160.1">sizeof</span></span><span class="koboSpan" id="kobo.1161.1">(i));
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1162.1">read</span></span><span class="koboSpan" id="kobo.1163.1">(&amp;c, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1164.1">sizeof</span></span><span class="koboSpan" id="kobo.1165.1">(c));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1166.1">auto</span></span><span class="koboSpan" id="kobo.1167.1"> size {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1168.1">0</span></span><span class="koboSpan" id="kobo.1169.1">};
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1170.1">read</span></span><span class="koboSpan" id="kobo.1171.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1172.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1173.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1174.1">char</span></span><span class="koboSpan" id="kobo.1175.1">*&gt;(&amp;size), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1176.1">sizeof</span></span><span class="koboSpan" id="kobo.1177.1">(size));
  s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1178.1">resize</span></span><span class="koboSpan" id="kobo.1179.1">(size);
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1180.1">read</span></span><span class="koboSpan" id="kobo.1181.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1182.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1183.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1184.1">char</span></span><span class="koboSpan" id="kobo.1185.1">*&gt;(&amp;s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1186.1">front</span></span><span class="koboSpan" id="kobo.1187.1">()), size);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1188.1">return</span></span><span class="koboSpan" id="kobo.1189.1"> !ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1190.1">fail</span></span><span class="koboSpan" id="kobo.1191.1">();
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1192.1">An</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.1193.1"> alternative to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1194.1">write()</span></code><span class="koboSpan" id="kobo.1195.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1196.1">read()</span></code><span class="koboSpan" id="kobo.1197.1"> member </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.1198.1">functions demonstrated earlier is to overload </span><code class="inlineCode"><span class="koboSpan" id="kobo.1199.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.1200.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1201.1">operator&gt;&gt;</span></code><span class="koboSpan" id="kobo.1202.1">. </span><span class="koboSpan" id="kobo.1202.2">To do this, you should perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1203.1">Add </span><code class="inlineCode"><span class="koboSpan" id="kobo.1204.1">friend</span></code><span class="koboSpan" id="kobo.1205.1"> declarations for the non-member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1206.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.1207.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1208.1">operator&gt;&gt;</span></code><span class="koboSpan" id="kobo.1209.1"> to the class to be serialized/deserialized (in this case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1210.1">foo</span></code><span class="koboSpan" id="kobo.1211.1"> class):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1212.1">friend</span></span><span class="koboSpan" id="kobo.1213.1"> std::ofstream&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1214.1">operator</span></span><span class="koboSpan" id="kobo.1215.1">&lt;&lt;(std::ofstream&amp; ofile, foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.1216.1">const</span></span><span class="koboSpan" id="kobo.1217.1">&amp; f);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1218.1">friend</span></span><span class="koboSpan" id="kobo.1219.1"> std::ifstream&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1220.1">operator</span></span><span class="koboSpan" id="kobo.1221.1">&gt;&gt;(std::ifstream&amp; ifile, foo&amp; f);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1222.1">Overload </span><code class="inlineCode"><span class="koboSpan" id="kobo.1223.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.1224.1"> for your class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1225.1">std::ofstream&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1226.1">operator</span></span><span class="koboSpan" id="kobo.1227.1">&lt;&lt;(std::ofstream&amp; ofile, foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.1228.1">const</span></span><span class="koboSpan" id="kobo.1229.1">&amp; f)
{
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1230.1">write</span></span><span class="koboSpan" id="kobo.1231.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1232.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1233.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1234.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1235.1">char</span></span><span class="koboSpan" id="kobo.1236.1">*&gt;(&amp;f.i),
              </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1237.1">sizeof</span></span><span class="koboSpan" id="kobo.1238.1">(f.i));
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1239.1">write</span></span><span class="koboSpan" id="kobo.1240.1">(&amp;f.c, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1241.1">sizeof</span></span><span class="koboSpan" id="kobo.1242.1">(f.c));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1243.1">auto</span></span><span class="koboSpan" id="kobo.1244.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1245.1">static_cast</span></span><span class="koboSpan" id="kobo.1246.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1247.1">int</span></span><span class="koboSpan" id="kobo.1248.1">&gt;(f.s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1249.1">size</span></span><span class="koboSpan" id="kobo.1250.1">());
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1251.1">write</span></span><span class="koboSpan" id="kobo.1252.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1253.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1254.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1255.1">char</span></span><span class="koboSpan" id="kobo.1256.1">*&gt;(&amp;size), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1257.1">sizeof</span></span><span class="koboSpan" id="kobo.1258.1">(size));
  ofile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1259.1">write</span></span><span class="koboSpan" id="kobo.1260.1">(f.s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1261.1">data</span></span><span class="koboSpan" id="kobo.1262.1">(), f.s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1263.1">size</span></span><span class="koboSpan" id="kobo.1264.1">());
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1265.1">return</span></span><span class="koboSpan" id="kobo.1266.1"> ofile;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1267.1">Overload </span><code class="inlineCode"><span class="koboSpan" id="kobo.1268.1">operator&gt;&gt;</span></code><span class="koboSpan" id="kobo.1269.1"> for your class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1270.1">std::ifstream&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1271.1">operator</span></span><span class="koboSpan" id="kobo.1272.1">&gt;&gt;(std::ifstream&amp; ifile, foo&amp; f)
{
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1273.1">read</span></span><span class="koboSpan" id="kobo.1274.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1275.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1276.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1277.1">char</span></span><span class="koboSpan" id="kobo.1278.1">*&gt;(&amp;f.i), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1279.1">sizeof</span></span><span class="koboSpan" id="kobo.1280.1">(f.i));
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1281.1">read</span></span><span class="koboSpan" id="kobo.1282.1">(&amp;f.c, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1283.1">sizeof</span></span><span class="koboSpan" id="kobo.1284.1">(f.c));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1285.1">auto</span></span><span class="koboSpan" id="kobo.1286.1"> size {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1287.1">0</span></span><span class="koboSpan" id="kobo.1288.1">};
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1289.1">read</span></span><span class="koboSpan" id="kobo.1290.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1291.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1292.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1293.1">char</span></span><span class="koboSpan" id="kobo.1294.1">*&gt;(&amp;size), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1295.1">sizeof</span></span><span class="koboSpan" id="kobo.1296.1">(size));
  f.s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1297.1">resize</span></span><span class="koboSpan" id="kobo.1298.1">(size);
  ifile.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1299.1">read</span></span><span class="koboSpan" id="kobo.1300.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1301.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1302.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1303.1">char</span></span><span class="koboSpan" id="kobo.1304.1">*&gt;(&amp;f.s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1305.1">front</span></span><span class="koboSpan" id="kobo.1306.1">()), size);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1307.1">return</span></span><span class="koboSpan" id="kobo.1308.1"> ifile;
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-436"><span class="koboSpan" id="kobo.1309.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1310.1">Regardless</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.1311.1"> of </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.1312.1">whether we serialize the entire object (for POD types) or only parts of it, we use the same stream classes that we discussed in the previous recipe: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1313.1">ofstream</span></code><span class="koboSpan" id="kobo.1314.1"> for output file streams and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1315.1">ifstream</span></code><span class="koboSpan" id="kobo.1316.1"> for input file streams. </span><span class="koboSpan" id="kobo.1316.2">Details about writing and reading data using these standard classes have been discussed in that recipe and will not be reiterated here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1317.1">When you serialize and deserialize objects to and from files, you should avoid writing the values of the pointers to a file. </span><span class="koboSpan" id="kobo.1317.2">Additionally, you must not read pointer values from the file since these represent memory addresses and are meaningless across processes, and even in the same process some moments later. </span><span class="koboSpan" id="kobo.1317.3">Instead, you should write data referred by a pointer and read data into objects referred by a pointer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1318.1">This is a general principle, and, in practice, you may encounter situations where a source may have multiple pointers to the same object; in this case, you might want to write only one copy and also handle the reading in a corresponding manner.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1319.1">If the objects you want to serialize are of the POD type, you can do it just like we did when we discussed raw data. </span><span class="koboSpan" id="kobo.1319.2">In the example in this recipe, we serialized a sequence of objects of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1320.1">foopod</span></code><span class="koboSpan" id="kobo.1321.1"> type. </span><span class="koboSpan" id="kobo.1321.2">When we deserialize, we read from the file stream in a loop until the end of the file is read or a failure occurs. </span><span class="koboSpan" id="kobo.1321.3">The way we read, in this case, may look counterintuitive, but doing it differently may lead to the duplication of the last read value:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1322.1">Reading is done in an infinite loop.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1323.1">A read operation is performed in the loop.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1324.1">A check for a failure or the end of file is performed, and if either of them has occurred, the infinite loop is exited.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1325.1">The value is added to the input sequence and the looping continues.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1326.1">If reading is done using a loop with an exit condition that checks the end of the file bit, that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1327.1">while(!ifile.eof())</span></code><span class="koboSpan" id="kobo.1328.1">, the last value will be added to the input sequence twice. </span><span class="koboSpan" id="kobo.1328.2">The reason for this is that upon reading the last value, the end of the file has not yet been encountered (as that is a mark beyond the last byte of the file). </span><span class="koboSpan" id="kobo.1328.3">The end of the file mark is only</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.1329.1"> reached at the next read attempt, which, therefore, sets the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">eofbit</span></code><span class="koboSpan" id="kobo.1331.1"> of the stream. </span><span class="koboSpan" id="kobo.1331.2">However, the input variable still has the last value since it hasn’t been overwritten with anything, and this is added to the input vector for a second time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1332.1">If the </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.1333.1">objects you want to serialize and deserialize are of non-POD types, writing/reading these objects as raw data is not possible. </span><span class="koboSpan" id="kobo.1333.2">For instance, such an object may have a virtual table. </span><span class="koboSpan" id="kobo.1333.3">Writing the virtual table to a file does not cause problems, even though it does not have any value; however, reading from a file, and, therefore, overwriting the virtual table of an object, will have catastrophic effects on the object and the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1334.1">When serializing/deserializing non-POD types, there are various alternatives, and some of them have been discussed in the previous section. </span><span class="koboSpan" id="kobo.1334.2">All of them provide explicit methods for writing and reading or overloading the standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.1335.1">&lt;&lt;</span></code><span class="koboSpan" id="kobo.1336.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1337.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.1338.1"> operators. </span><span class="koboSpan" id="kobo.1338.2">The second approach has an advantage in that it enables the use of your class in generic code, where objects are written and read to and from stream files using these operators.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1339.1">When you plan to serialize and deserialize your objects, consider versioning your data from the very beginning to avoid problems if the structure of your data changes over time. </span><span class="koboSpan" id="kobo.1339.2">How versioning should be done is beyond the scope of this recipe.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-437"><span class="koboSpan" id="kobo.1340.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1341.1">Reading and writing raw data from/to binary files</span></em><span class="koboSpan" id="kobo.1342.1">, to learn how to write and read unstructured data to binary files</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1343.1">Using I/O manipulators to control the output of a stream</span></em><span class="koboSpan" id="kobo.1344.1">, to learn about the use of helper functions, called manipulators, that control input and output streams using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1345.1">&lt;&lt;</span></code><span class="koboSpan" id="kobo.1346.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1347.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.1348.1"> stream operators</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-438"><span class="koboSpan" id="kobo.1349.1">Using streams on fixed-size external buffers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1350.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1351.1">&lt;strstream&gt;</span></code><span class="koboSpan" id="kobo.1352.1"> header</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.1353.1"> has been part of the standard I/O library from its beginning. </span><span class="koboSpan" id="kobo.1353.2">It contains classes that provide stream operations on sequences of characters stored in an array. </span><span class="koboSpan" id="kobo.1353.3">However, this header was</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.1354.1"> deprecated a long time ago, in C++98, although it’s still available because a replacement wasn’t available. </span><span class="koboSpan" id="kobo.1354.2">The C++20 standard has introduced the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1355.1">std::span</span></code><span class="koboSpan" id="kobo.1356.1"> class, which is a non-owning view of a sequence of objects. </span><span class="koboSpan" id="kobo.1356.2">In C++23, a new header, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1357.1">&lt;spanstream&gt;</span></code><span class="koboSpan" id="kobo.1358.1">, has been added as a replacement for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1359.1">&lt;strstream&gt;</span></code><span class="koboSpan" id="kobo.1360.1">. </span><span class="koboSpan" id="kobo.1360.2">This contains classes that provide stream operations on externally provided memory buffers. </span><span class="koboSpan" id="kobo.1360.3">In this recipe, we’ll learn how to parse or write text using the I/O span streams.</span></p>
<h2 class="heading-2" id="_idParaDest-439"><span class="koboSpan" id="kobo.1361.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1362.1">Use the new C++23 span streams as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1363.1">To parse text from an external array, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1364.1">std::ispanstream</span></code><span class="koboSpan" id="kobo.1365.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1366.1">char</span></span><span class="koboSpan" id="kobo.1367.1"> text[] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1368.1">"1 1 2 3 5 8"</span></span><span class="koboSpan" id="kobo.1369.1">;
std::ispanstream is{ std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1370.1">char</span></span><span class="koboSpan" id="kobo.1371.1">&gt;{text} };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1372.1">int</span></span><span class="koboSpan" id="kobo.1373.1"> value;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1374.1">while</span></span><span class="koboSpan" id="kobo.1375.1"> (is &gt;&gt; value)
{
   std::cout &lt;&lt; value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1376.1">'\n'</span></span><span class="koboSpan" id="kobo.1377.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1378.1">To write text to an external array, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1379.1">std::ospanstream</span></code><span class="koboSpan" id="kobo.1380.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1381.1">char</span></span><span class="koboSpan" id="kobo.1382.1"> text[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1383.1">15</span></span><span class="koboSpan" id="kobo.1384.1">]{};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1385.1">int</span></span><span class="koboSpan" id="kobo.1386.1"> numbers[]{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1387.1">1</span></span><span class="koboSpan" id="kobo.1388.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1389.1">1</span></span><span class="koboSpan" id="kobo.1390.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1391.1">2</span></span><span class="koboSpan" id="kobo.1392.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1393.1">3</span></span><span class="koboSpan" id="kobo.1394.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1395.1">5</span></span><span class="koboSpan" id="kobo.1396.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1397.1">8</span></span><span class="koboSpan" id="kobo.1398.1"> };
std::ospanstream os{ std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1399.1">char</span></span><span class="koboSpan" id="kobo.1400.1">&gt;{text} };         
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1401.1">for</span></span><span class="koboSpan" id="kobo.1402.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1403.1">int</span></span><span class="koboSpan" id="kobo.1404.1"> n : numbers)
{
   os &lt;&lt; n &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1405.1">' '</span></span><span class="koboSpan" id="kobo.1406.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1407.1">To both read and write to the same external array, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1408.1">std::spanstream</span></code><span class="koboSpan" id="kobo.1409.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1410.1">char</span></span><span class="koboSpan" id="kobo.1411.1"> text[] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1412.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1413.1">1 1 2 3 5 8 "</span></span><span class="koboSpan" id="kobo.1414.1">;
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1415.1">int</span></span><span class="koboSpan" id="kobo.1416.1">&gt; numbers;
std::spanstream ss{ std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1417.1">char</span></span><span class="koboSpan" id="kobo.1418.1">&gt;{text} };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1419.1">int</span></span><span class="koboSpan" id="kobo.1420.1"> value;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1421.1">while</span></span><span class="koboSpan" id="kobo.1422.1"> (ss &gt;&gt; value)
{
   numbers.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1423.1">push_back</span></span><span class="koboSpan" id="kobo.1424.1">(value);
}
ss.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1425.1">clear</span></span><span class="koboSpan" id="kobo.1426.1">();
ss.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1427.1">seekp</span></span><span class="koboSpan" id="kobo.1428.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1429.1">0</span></span><span class="koboSpan" id="kobo.1430.1">);
std::for_each(numbers.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1431.1">rbegin</span></span><span class="koboSpan" id="kobo.1432.1">(), numbers.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1433.1">rend</span></span><span class="koboSpan" id="kobo.1434.1">(), 
              [&amp;ss](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1435.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1436.1">int</span></span><span class="koboSpan" id="kobo.1437.1"> n) { ss &lt;&lt; n &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1438.1">' '</span></span><span class="koboSpan" id="kobo.1439.1">; });
std::cout &lt;&lt; text &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1440.1">'\n'</span></span><span class="koboSpan" id="kobo.1441.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1442.1">// prints 8 5 3 2 1 1</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-440"><span class="koboSpan" id="kobo.1443.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1444.1">Stream input/output operations </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.1445.1">can be </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.1446.1">used with externally allocated buffers. </span><span class="koboSpan" id="kobo.1446.2">However, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1447.1">&lt;strstream&gt;</span></code><span class="koboSpan" id="kobo.1448.1"> header and its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1449.1">strstream</span></code><span class="koboSpan" id="kobo.1450.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1451.1">istrstream</span></code><span class="koboSpan" id="kobo.1452.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1453.1">ostrstream</span></code><span class="koboSpan" id="kobo.1454.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1455.1">strstreambuf</span></code><span class="koboSpan" id="kobo.1456.1"> classes were deprecated in C++98 without any replacement available. </span><span class="koboSpan" id="kobo.1456.2">The reasons for deprecating them include safety, since </span><code class="inlineCode"><span class="koboSpan" id="kobo.1457.1">strstreambuf</span></code><span class="koboSpan" id="kobo.1458.1"> does not enforce bounds checking, and inflexibility, due to its limitations in resizing the underlying buffer. </span><span class="koboSpan" id="kobo.1458.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1459.1">std::stringstream</span></code><span class="koboSpan" id="kobo.1460.1"> was the only recommended alternative.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1461.1">In C++23, a new set of similar classes is available in the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.1462.1">&lt;spanstream&gt;</span></code><span class="koboSpan" id="kobo.1463.1"> header: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1464.1">basic_spanstream</span></code><span class="koboSpan" id="kobo.1465.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1466.1">basic_ispanstream</span></code><span class="koboSpan" id="kobo.1467.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1468.1">basic_ospanstream</span></code><span class="koboSpan" id="kobo.1469.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1470.1">basic_spanbuf</span></code><span class="koboSpan" id="kobo.1471.1">. </span><span class="koboSpan" id="kobo.1471.2">These enable stream operations on externally allocated fixed-size buffers. </span><span class="koboSpan" id="kobo.1471.3">These classes do not provide support for ownership or reallocation of the buffer. </span><span class="koboSpan" id="kobo.1471.4">For such scenarios, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1472.1">std::stringstream</span></code><span class="koboSpan" id="kobo.1473.1"> should be used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1474.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1475.1">std::basic_spanbuf</span></code><span class="koboSpan" id="kobo.1476.1"> controls input and output to a sequence of characters. </span><span class="koboSpan" id="kobo.1476.2">Its associated sequence (the source for input, and the sink for output) is an externally allocated buffer of a fixed size that can be initialized from or made available as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1477.1">std::span</span></code><span class="koboSpan" id="kobo.1478.1">. </span><span class="koboSpan" id="kobo.1478.2">This is wrapped by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1479.1">std::basic_ispanstream</span></code><span class="koboSpan" id="kobo.1480.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1481.1">std::basic_ospanstream</span></code><span class="koboSpan" id="kobo.1482.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1483.1">std::basic_spanstream</span></code><span class="koboSpan" id="kobo.1484.1">, which provide higher-level interfaces for input/output operations, as defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1485.1">std::basic_istream</span></code><span class="koboSpan" id="kobo.1486.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1487.1">std::basic_ostream</span></code><span class="koboSpan" id="kobo.1488.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1489.1">std::basic_stream</span></code><span class="koboSpan" id="kobo.1490.1"> classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1491.1">Let’s take another example to look at this. </span><span class="koboSpan" id="kobo.1491.2">Consider we have a string that contains a sequence of key-value pairs separated by a comma. </span><span class="koboSpan" id="kobo.1491.3">We want to read these pairs and put them in a map. </span><span class="koboSpan" id="kobo.1491.4">We can write the following code in C++23:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1492.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1493.1">const</span></span><span class="koboSpan" id="kobo.1494.1"> text[] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1495.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1496.1">severity=1,code=42,message=generic error"</span></span><span class="koboSpan" id="kobo.1497.1">;
std::unordered_map&lt;std::string, std::string&gt; m;
std::string key, val;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1498.1">std::ispanstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1499.1">is</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1500.1">(text)</span></span><span class="koboSpan" id="kobo.1501.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1502.1">while</span></span><span class="koboSpan" id="kobo.1503.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1504.1">getline</span></span><span class="koboSpan" id="kobo.1505.1">(is, key, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1506.1">'='</span></span><span class="koboSpan" id="kobo.1507.1">) &gt;&gt; std::ws)
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1508.1">if</span></span><span class="koboSpan" id="kobo.1509.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1510.1">getline</span></span><span class="koboSpan" id="kobo.1511.1">(is, val, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1512.1">','</span></span><span class="koboSpan" id="kobo.1513.1">))
      m[key] = val;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1514.1">for</span></span><span class="koboSpan" id="kobo.1515.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1516.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1517.1">const</span></span><span class="koboSpan" id="kobo.1518.1"> &amp; [k, v] : m)
{
   std::cout &lt;&lt; k &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1519.1">" : "</span></span><span class="koboSpan" id="kobo.1520.1"> &lt;&lt; v &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1521.1">'\n'</span></span><span class="koboSpan" id="kobo.1522.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1523.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1524.1">std::getline()</span></code><span class="koboSpan" id="kobo.1525.1"> function </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.1526.1">allows us to read characters from an input stream either until its end or until a specified delimiter is </span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.1527.1">encountered. </span><span class="koboSpan" id="kobo.1527.2">Using it, we split the text first using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1528.1">=</span></code><span class="koboSpan" id="kobo.1529.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1530.1">,</span></code><span class="koboSpan" id="kobo.1531.1"> delimiters. </span><span class="koboSpan" id="kobo.1531.2">The sequence of characters until </span><code class="inlineCode"><span class="koboSpan" id="kobo.1532.1">=</span></code><span class="koboSpan" id="kobo.1533.1"> represents the key, and everything after </span><code class="inlineCode"><span class="koboSpan" id="kobo.1534.1">=</span></code><span class="koboSpan" id="kobo.1535.1"> until the next comma or the end is the value. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1536.1">std::ws</span></code><span class="koboSpan" id="kobo.1537.1"> is an I/O manipulator that discards whitespaces from an input stream. </span><span class="koboSpan" id="kobo.1537.2">In simple terms, we read until we find an equals sign; all the text until there is the key. </span><span class="koboSpan" id="kobo.1537.3">Then, we read until we find a comma (or reach the end); all the text until there is the value. </span><span class="koboSpan" id="kobo.1537.4">We do this in a loop as long as we keep encountering an equals sign.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1538.1">Reading from a fixed-size buffer is not very difficult, but writing requires more checks because writing cannot exceed the bounds of the buffer, in which case, a write operation fails. </span><span class="koboSpan" id="kobo.1538.2">Let’s take an example to understand this better:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1539.1">char</span></span><span class="koboSpan" id="kobo.1540.1"> text[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1541.1">3</span></span><span class="koboSpan" id="kobo.1542.1">]{};
std::ospanstream os{ std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1543.1">char</span></span><span class="koboSpan" id="kobo.1544.1">&gt;{text} };
os &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1545.1">"42"</span></span><span class="koboSpan" id="kobo.1546.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1547.1">auto</span></span><span class="koboSpan" id="kobo.1548.1"> pos = os.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1549.1">tellp</span></span><span class="koboSpan" id="kobo.1550.1">();
os &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1551.1">"44"</span></span><span class="koboSpan" id="kobo.1552.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1553.1">if</span></span><span class="koboSpan" id="kobo.1554.1"> (!os.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1555.1">good</span></span><span class="koboSpan" id="kobo.1556.1">())
{
   os.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1557.1">clear</span></span><span class="koboSpan" id="kobo.1558.1">();
   os.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1559.1">seekp</span></span><span class="koboSpan" id="kobo.1560.1">(pos);
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1561.1">// text is {'4','2','4'}</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1562.1">// prints (examples): 424╠╠╠╠╠... </span><span class="koboSpan" id="kobo.1562.2">or 424MƂ</span><span class="koboSpan" id="kobo.1563.1"><img alt="" src="../Images/11.png"/></span><span class="koboSpan" id="kobo.1564.1"> etc.</span></span><span class="koboSpan" id="kobo.1565.1">
std::cout &lt;&lt; text &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1566.1">'\n'</span></span><span class="koboSpan" id="kobo.1567.1">;
os &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1568.1">'\0'</span></span><span class="koboSpan" id="kobo.1569.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1570.1">// text is {'4','2','\0'}</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1571.1">// prints: 42</span></span><span class="koboSpan" id="kobo.1572.1">
std::cout &lt;&lt; text &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1573.1">'\n'</span></span><span class="koboSpan" id="kobo.1574.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1575.1">The </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.1576.1">external array has 3 bytes. </span><span class="koboSpan" id="kobo.1576.2">We write the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.1577.1">42</span></code><span class="koboSpan" id="kobo.1578.1">, and this operation succeeds. </span><span class="koboSpan" id="kobo.1578.2">Then, we attempt to write the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.1579.1">44</span></code><span class="koboSpan" id="kobo.1580.1">. </span><span class="koboSpan" id="kobo.1580.2">However, this would require that the external buffer has 4 bytes, but it only has 3. </span><span class="koboSpan" id="kobo.1580.3">Therefore, after </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.1581.1">writing the character </span><code class="inlineCode"><span class="koboSpan" id="kobo.1582.1">4</span></code><span class="koboSpan" id="kobo.1583.1">, the operation fails. </span><span class="koboSpan" id="kobo.1583.2">At this point, the content of the text buffer is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1584.1">'</span></code><code class="inlineCode"><span class="koboSpan" id="kobo.1585.1">4'</span></code><span class="koboSpan" id="kobo.1586.1">,</span><code class="inlineCode"><span class="koboSpan" id="kobo.1587.1">'2'</span></code><span class="koboSpan" id="kobo.1588.1">,</span><code class="inlineCode"><span class="koboSpan" id="kobo.1589.1">'4'</span></code><span class="koboSpan" id="kobo.1590.1">, and there is no null-terminating character. </span><span class="koboSpan" id="kobo.1590.2">If we print this to the console, after </span><code class="inlineCode"><span class="koboSpan" id="kobo.1591.1">424</span></code><span class="koboSpan" id="kobo.1592.1">, there will be some gibberish based on the content found in memory until the first 0. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1593.1">To check whether the writing operation failed, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1594.1">good()</span></code><span class="koboSpan" id="kobo.1595.1"> member function. </span><span class="koboSpan" id="kobo.1595.2">If this returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1596.1">false</span></code><span class="koboSpan" id="kobo.1597.1">, then we need to clear the error flags. </span><span class="koboSpan" id="kobo.1597.2">We also set the stream’s output position indicator to the value it had before attempting the read (which can be retrieved with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1598.1">tellp()</span></code><span class="koboSpan" id="kobo.1599.1"> member function). </span><span class="koboSpan" id="kobo.1599.2">At this point, if we write a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1600.1">0</span></code><span class="koboSpan" id="kobo.1601.1"> to the output buffer, its content will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1602.1">'4'</span></code><span class="koboSpan" id="kobo.1603.1">,</span><code class="inlineCode"><span class="koboSpan" id="kobo.1604.1">'2'</span></code><span class="koboSpan" id="kobo.1605.1">,</span><code class="inlineCode"><span class="koboSpan" id="kobo.1606.1">'\0'</span></code><span class="koboSpan" id="kobo.1607.1">, so printing it to the console will show the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.1608.1">42</span></code><span class="koboSpan" id="kobo.1609.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1610.1">If you want to both read and write to the same buffer, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1611.1">std::spanstream</span></code><span class="koboSpan" id="kobo.1612.1"> class, which provides both input and output stream operations. </span><span class="koboSpan" id="kobo.1612.2">An example was shown in the </span><em class="italic"><span class="koboSpan" id="kobo.1613.1">How to do it…</span></em><span class="koboSpan" id="kobo.1614.1"> section.</span></p>
<h2 class="heading-2" id="_idParaDest-441"><span class="koboSpan" id="kobo.1615.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1616.1">Chapter 6</span></em><span class="koboSpan" id="kobo.1617.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1618.1">Using std::span for contiguous sequences of objects</span></em><span class="koboSpan" id="kobo.1619.1">, to learn how to use non-owning views over contiguous sequences of elements</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-442"><span class="koboSpan" id="kobo.1620.1">Using localized settings for streams</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1621.1">How </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.1622.1">writing or reading to and from streams is performed may depend on the language and regional settings. </span><span class="koboSpan" id="kobo.1622.2">Examples include writing and parsing numbers, time values, or monetary values, or comparing (collating) strings. </span><span class="koboSpan" id="kobo.1622.3">The C++ I/O library provides a general-purpose mechanism for handling internationalization features through </span><em class="italic"><span class="koboSpan" id="kobo.1623.1">locales</span></em><span class="koboSpan" id="kobo.1624.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1625.1">facets</span></em><span class="koboSpan" id="kobo.1626.1">. </span><span class="koboSpan" id="kobo.1626.2">In this recipe, you will learn how to use locales to control the behavior of input/output streams.</span></p>
<h2 class="heading-2" id="_idParaDest-443"><span class="koboSpan" id="kobo.1627.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1628.1">All of the </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.1629.1">examples in this recipe use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1630.1">std::cout</span></code><span class="koboSpan" id="kobo.1631.1"> predefined console stream object. </span><span class="koboSpan" id="kobo.1631.2">However, the same applies to all I/O stream objects. </span><span class="koboSpan" id="kobo.1631.3">Also, in these recipe examples, we will use the following objects and lambda function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1632.1">auto</span></span><span class="koboSpan" id="kobo.1633.1"> now = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1634.1">now</span></span><span class="koboSpan" id="kobo.1635.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1636.1">auto</span></span><span class="koboSpan" id="kobo.1637.1"> stime = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1638.1">to_time_t</span></span><span class="koboSpan" id="kobo.1639.1">(now);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1640.1">auto</span></span><span class="koboSpan" id="kobo.1641.1"> ltime = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1642.1">localtime</span></span><span class="koboSpan" id="kobo.1643.1">(&amp;stime);
std::vector&lt;std::string&gt; names
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1644.1">"John"</span></span><span class="koboSpan" id="kobo.1645.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1646.1">"adele"</span></span><span class="koboSpan" id="kobo.1647.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1648.1">"Øivind"</span></span><span class="koboSpan" id="kobo.1649.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1650.1">"François"</span></span><span class="koboSpan" id="kobo.1651.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1652.1">"Robert"</span></span><span class="koboSpan" id="kobo.1653.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1654.1">"Åke"</span></span><span class="koboSpan" id="kobo.1655.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1656.1">auto</span></span><span class="koboSpan" id="kobo.1657.1"> sort_and_print = [](std::vector&lt;std::string&gt; v,
                         std::locale </span><span class="hljs-type"><span class="koboSpan" id="kobo.1658.1">const</span></span><span class="koboSpan" id="kobo.1659.1"> &amp; loc)
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1660.1">sort</span></span><span class="koboSpan" id="kobo.1661.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1662.1">begin</span></span><span class="koboSpan" id="kobo.1663.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1664.1">end</span></span><span class="koboSpan" id="kobo.1665.1">(), loc);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1666.1">for</span></span><span class="koboSpan" id="kobo.1667.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1668.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1669.1">const</span></span><span class="koboSpan" id="kobo.1670.1"> &amp; s : v) std::cout &lt;&lt; s &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1671.1">' '</span></span><span class="koboSpan" id="kobo.1672.1">;
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1673.1">'\n'</span></span><span class="koboSpan" id="kobo.1674.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1675.1">The names Øivind and Åke contain the Danish/Norwegian-specific characters Ø and Å. </span><span class="koboSpan" id="kobo.1675.2">In the Danish/Norwegian alphabet, these are the last two letters (in this order) of the alphabet. </span><span class="koboSpan" id="kobo.1675.3">These are used to exemplify the effect of using locales.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1676.1">The locale names used in this recipe (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1677.1">en_US.utf8</span></code><span class="koboSpan" id="kobo.1678.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1679.1">de_DE.utf8</span></code><span class="koboSpan" id="kobo.1680.1">, and so on) are the ones that are used on UNIX systems. </span><span class="koboSpan" id="kobo.1680.2">The following table lists their equivalents for Windows systems:</span></p>
<table class="table-container" id="table001-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1681.1">UNIX</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1682.1">Windows</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1683.1">en_US.utf8</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1684.1">English_US.1252</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1685.1">en_GB.utf8</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1686.1">English_UK.1252</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1687.1">de_DE.utf8</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1688.1">German_Germany.1252</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1689.1">no_NO.utf8</span></code></p>
</td>
<td class="table-cell">
<p class="normal"> <code class="inlineCode"><span class="koboSpan" id="kobo.1690.1">Norwegian_Norway.1252</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1691.1">Table 7.1: List of UNIX and Windows names of locales used in this recipe</span></p>
<h2 class="heading-2" id="_idParaDest-444"><span class="koboSpan" id="kobo.1692.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1693.1">To control the </span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.1694.1">localization settings of a stream, you </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.1695.1">must do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1696.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1697.1">std::locale</span></code><span class="koboSpan" id="kobo.1698.1"> class to represent the localization settings. </span><span class="koboSpan" id="kobo.1698.2">There are various ways in which to construct locale objects, including the following:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1699.1">Default construct is to use the global locale (by default, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1700.1">C</span></code><span class="koboSpan" id="kobo.1701.1"> locale at the program startup)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1702.1">From a local name, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1703.1">C</span></code><span class="koboSpan" id="kobo.1704.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1705.1">POSIX,</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">en_US.utf8</span></code><span class="koboSpan" id="kobo.1707.1">, and so on, if supported by the operating system</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1708.1">From another locale, except for a specified facet</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1709.1">From another locale, except for all of the facets from a specified category that are copied from another specified locale:
            </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1710.1">// default construct</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1711.1">auto</span></span><span class="koboSpan" id="kobo.1712.1"> loc_def = std::locale {};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1713.1">// from a name</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1714.1">auto</span></span><span class="koboSpan" id="kobo.1715.1"> loc_us = std::locale {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1716.1">"en_US.utf8"</span></span><span class="koboSpan" id="kobo.1717.1">};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1718.1">// from another locale except for a facet</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1719.1">auto</span></span><span class="koboSpan" id="kobo.1720.1"> loc1 = std::locale {loc_def, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1721.1">new</span></span><span class="koboSpan" id="kobo.1722.1"> std::collate&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1723.1">wchar_t</span></span><span class="koboSpan" id="kobo.1724.1">&gt;};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1725.1">// from another local, except the facet in a category</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1726.1">auto</span></span><span class="koboSpan" id="kobo.1727.1"> loc2 = std::locale {loc_def, loc_us, std::locale::collate};
</span></code></pre>
</li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1728.1">To get a copy of the default </span><code class="inlineCode"><span class="koboSpan" id="kobo.1729.1">C</span></code><span class="koboSpan" id="kobo.1730.1"> locale, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1731.1">std::locale::classic()</span></code><span class="koboSpan" id="kobo.1732.1"> static method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1733.1">auto</span></span><span class="koboSpan" id="kobo.1734.1"> loc = std::locale::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1735.1">classic</span></span><span class="koboSpan" id="kobo.1736.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1737.1">To change the default locale that is copied every time a locale is default-constructed, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1738.1">std::locale::global()</span></code><span class="koboSpan" id="kobo.1739.1"> static method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1740.1">std::locale::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1741.1">global</span></span><span class="koboSpan" id="kobo.1742.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1743.1">locale</span></span><span class="koboSpan" id="kobo.1744.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1745.1">"en_US.utf8"</span></span><span class="koboSpan" id="kobo.1746.1">));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1747.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1748.1">imbue()</span></code><span class="koboSpan" id="kobo.1749.1"> method to change the current locale of an I/O stream:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1750.1">std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1751.1">imbue</span></span><span class="koboSpan" id="kobo.1752.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1753.1">locale</span></span><span class="koboSpan" id="kobo.1754.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1755.1">"en_US.utf8"</span></span><span class="koboSpan" id="kobo.1756.1">));
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1757.1">The </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.1758.1">following</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.1759.1"> list shows examples of using various locales:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1760.1">Use a particular locale, indicated by its name. </span><span class="koboSpan" id="kobo.1760.2">In this example, the locale is for German:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1761.1">auto</span></span><span class="koboSpan" id="kobo.1762.1"> loc = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1763.1">locale</span></span><span class="koboSpan" id="kobo.1764.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1765.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1766.1">de_DE.utf8"</span></span><span class="koboSpan" id="kobo.1767.1">);
std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1768.1">imbue</span></span><span class="koboSpan" id="kobo.1769.1">(loc);
std::cout &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1770.1">1000.50</span></span><span class="koboSpan" id="kobo.1771.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1772.1">'\n'</span></span><span class="koboSpan" id="kobo.1773.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1774.1">// 1.000,5</span></span><span class="koboSpan" id="kobo.1775.1">
std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1776.1">put_money</span></span><span class="koboSpan" id="kobo.1777.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1778.1">1050</span></span><span class="koboSpan" id="kobo.1779.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1780.1">'\n'</span></span><span class="koboSpan" id="kobo.1781.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1782.1">// 10,50 €</span></span><span class="koboSpan" id="kobo.1783.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1784.1">put_time</span></span><span class="koboSpan" id="kobo.1785.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1786.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1787.1">%c"</span></span><span class="koboSpan" id="kobo.1788.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1789.1">'\n'</span></span><span class="koboSpan" id="kobo.1790.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1791.1">// So 04 Dez 2016 17:54:06 JST</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1792.1">sort_and_print</span></span><span class="koboSpan" id="kobo.1793.1">(names, loc);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1794.1">// adele Åke François John Øivind Robert</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1795.1">Use a locale that corresponds to the user settings (as defined in the system). </span><span class="koboSpan" id="kobo.1795.2">This is done by constructing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1796.1">std::locale</span></code><span class="koboSpan" id="kobo.1797.1"> object from an empty string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1798.1">auto</span></span><span class="koboSpan" id="kobo.1799.1"> loc = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1800.1">locale</span></span><span class="koboSpan" id="kobo.1801.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1802.1">""</span></span><span class="koboSpan" id="kobo.1803.1">);
std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1804.1">imbue</span></span><span class="koboSpan" id="kobo.1805.1">(loc);
std::cout &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1806.1">1000.50</span></span><span class="koboSpan" id="kobo.1807.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1808.1">'\n'</span></span><span class="koboSpan" id="kobo.1809.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1810.1">// 1,000.5</span></span><span class="koboSpan" id="kobo.1811.1">
std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1812.1">put_money</span></span><span class="koboSpan" id="kobo.1813.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1814.1">1050</span></span><span class="koboSpan" id="kobo.1815.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1816.1">'\n'</span></span><span class="koboSpan" id="kobo.1817.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1818.1">// $10.50</span></span><span class="koboSpan" id="kobo.1819.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1820.1">put_time</span></span><span class="koboSpan" id="kobo.1821.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1822.1">"%c"</span></span><span class="koboSpan" id="kobo.1823.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1824.1">'\n'</span></span><span class="koboSpan" id="kobo.1825.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1826.1">// Sun 04 Dec 2016 05:54:06 PM JST</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1827.1">sort_and_print</span></span><span class="koboSpan" id="kobo.1828.1">(names, loc);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1829.1">// adele Åke François John Øivind Robert</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1830.1">Set and </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.1831.1">use the global locale:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1832.1">std::locale::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1833.1">global</span></span><span class="koboSpan" id="kobo.1834.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1835.1">locale</span></span><span class="koboSpan" id="kobo.1836.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1837.1">"no_NO.utf8"</span></span><span class="koboSpan" id="kobo.1838.1">)); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1839.1">// set global</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1840.1">auto</span></span><span class="koboSpan" id="kobo.1841.1"> loc = std::locale{};                       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1842.1">// use global</span></span><span class="koboSpan" id="kobo.1843.1">
std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1844.1">imbue</span></span><span class="koboSpan" id="kobo.1845.1">(loc);
std::cout &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1846.1">1000.50</span></span><span class="koboSpan" id="kobo.1847.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1848.1">'\n'</span></span><span class="koboSpan" id="kobo.1849.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1850.1">// 1 000,5</span></span><span class="koboSpan" id="kobo.1851.1">
std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1852.1">put_money</span></span><span class="koboSpan" id="kobo.1853.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1854.1">1050</span></span><span class="koboSpan" id="kobo.1855.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1856.1">'\n'</span></span><span class="koboSpan" id="kobo.1857.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1858.1">// 10,50 kr</span></span><span class="koboSpan" id="kobo.1859.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1860.1">put_time</span></span><span class="koboSpan" id="kobo.1861.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1862.1">"%c"</span></span><span class="koboSpan" id="kobo.1863.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1864.1">'\n'</span></span><span class="koboSpan" id="kobo.1865.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1866.1">// sön 4 dec 2016 18:02:29</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1867.1">sort_and_print</span></span><span class="koboSpan" id="kobo.1868.1">(names, loc);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1869.1">// adele François John Robert Øivind Åke </span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1870.1">Use the </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.1871.1">default </span><code class="inlineCode"><span class="koboSpan" id="kobo.1872.1">C</span></code><span class="koboSpan" id="kobo.1873.1"> locale:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1874.1">auto</span></span><span class="koboSpan" id="kobo.1875.1"> loc = std::locale::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1876.1">classic</span></span><span class="koboSpan" id="kobo.1877.1">();
std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1878.1">imbue</span></span><span class="koboSpan" id="kobo.1879.1">(loc);
std::cout &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1880.1">1000.50</span></span><span class="koboSpan" id="kobo.1881.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1882.1">'\n'</span></span><span class="koboSpan" id="kobo.1883.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1884.1">// 1000.5</span></span><span class="koboSpan" id="kobo.1885.1">
std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1886.1">put_money</span></span><span class="koboSpan" id="kobo.1887.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1888.1">1050</span></span><span class="koboSpan" id="kobo.1889.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1890.1">'\n'</span></span><span class="koboSpan" id="kobo.1891.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1892.1">// 1050</span></span><span class="koboSpan" id="kobo.1893.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1894.1">put_time</span></span><span class="koboSpan" id="kobo.1895.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1896.1">"%c"</span></span><span class="koboSpan" id="kobo.1897.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1898.1">'\n'</span></span><span class="koboSpan" id="kobo.1899.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1900.1">// Sun Dec 4 17:55:14 2016</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1901.1">sort_and_print</span></span><span class="koboSpan" id="kobo.1902.1">(names, loc);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1903.1">// François John Robert adele Åke Øivind</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-445"><span class="koboSpan" id="kobo.1904.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1905.1">A locale object does not actually store localized settings. </span><span class="koboSpan" id="kobo.1905.2">A </span><em class="italic"><span class="koboSpan" id="kobo.1906.1">locale</span></em><span class="koboSpan" id="kobo.1907.1"> is a</span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.1908.1"> heterogeneous container of facets. </span><span class="koboSpan" id="kobo.1908.2">A </span><em class="italic"><span class="koboSpan" id="kobo.1909.1">facet</span></em><span class="koboSpan" id="kobo.1910.1"> is an</span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.1911.1"> object that defines the localization and internationalization settings. </span><span class="koboSpan" id="kobo.1911.2">The standard defines a list of facets that each locale must contain. </span><span class="koboSpan" id="kobo.1911.3">In addition to this, a locale can contain any other user-defined facets. </span><span class="koboSpan" id="kobo.1911.4">The following is a list of all </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.1912.1">standard-defined facets:</span></p>
<table class="table-container" id="table002-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1913.1">std::collate&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1914.1">std::collate&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1915.1">std::ctype&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1916.1">std::ctype&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1917.1">std::codecvt&lt;char,char,mbstate_t&gt;</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1918.1">std::codecvt&lt;char16_t,char,mbstate_t&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1919.1">std::codecvt&lt;char32_t,char,mbstate_t&gt;</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1920.1">std::codecvt&lt;wchar_t,char,mbstate_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1921.1">std::moneypunct&lt;char&gt;</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1922.1">std::moneypunct&lt;char,true&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1923.1">std::moneypunct&lt;wchar_t&gt;</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1924.1">std::moneypunct&lt;wchar_t,true&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1925.1">std::money_get&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1926.1">std::money_get&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1927.1">std::money_put&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1928.1">std::money_put&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1929.1">std::numpunct&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1930.1">std::numpunct&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1931.1">std::num_get&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1932.1">std::num_get&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1933.1">std::num_put&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1934.1">std::num_put&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1935.1">std::time_get&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1936.1">std::time_get&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1937.1">std::time_put&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1938.1">std::time_put&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1939.1">std::messages&lt;char&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1940.1">std::messages&lt;wchar_t&gt;</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1941.1">Table 7.2: List of standard facets</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1942.1">It is </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.1943.1">beyond the </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.1944.1">scope of this recipe to go through this list and discuss all of these facets. </span><span class="koboSpan" id="kobo.1944.2">However, we will mention that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1945.1">std::money_get</span></code><span class="koboSpan" id="kobo.1946.1"> is a facet that encapsulates the rules for parsing monetary values from character streams, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1947.1">std::money_put</span></code><span class="koboSpan" id="kobo.1948.1"> is a facet that encapsulates the rules for formatting monetary values as strings. </span><span class="koboSpan" id="kobo.1948.2">In a similar manner, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1949.1">std::time_get</span></code><span class="koboSpan" id="kobo.1950.1"> encapsulates rules for data and time parsing, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1951.1">std::time_put</span></code><span class="koboSpan" id="kobo.1952.1"> encapsulates rules for data and time formatting. </span><span class="koboSpan" id="kobo.1952.2">These will form the subject of the next couple of recipes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1953.1">A locale is an</span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.1954.1"> immutable object containing immutable facet objects. </span><span class="koboSpan" id="kobo.1954.2">Locales are implemented as a reference-counted array of reference-counted pointers to facets. </span><span class="koboSpan" id="kobo.1954.3">The array is indexed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1955.1">std::locale::id</span></code><span class="koboSpan" id="kobo.1956.1">, and all facets must be derived from the base class </span><code class="inlineCode"><span class="koboSpan" id="kobo.1957.1">std::locale::facet</span></code><span class="koboSpan" id="kobo.1958.1"> and must have a public static member of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1959.1">std::locale::id</span></code><span class="koboSpan" id="kobo.1960.1"> type, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1961.1">id</span></code><span class="koboSpan" id="kobo.1962.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1963.1">It is only possible </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.1964.1">to create a locale object using one of the overloaded constructors or with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1965.1">combine()</span></code><span class="koboSpan" id="kobo.1966.1"> method, which, as the name implies, combines the current locale with a new compile-time identifiable facet and returns a new locale object. </span><span class="koboSpan" id="kobo.1966.2">The next example shows the use of the US English locale but with the numerical punctuation settings from the Norwegian locale:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1967.1">std::locale loc = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1968.1">locale</span></span><span class="koboSpan" id="kobo.1969.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1970.1">"English_US.1252"</span></span><span class="koboSpan" id="kobo.1971.1">)
                  .combine&lt;std::numpunct&lt;char&gt;&gt;(
                     std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1972.1">locale</span></span><span class="koboSpan" id="kobo.1973.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1974.1">"Norwegian_Norway.1252"</span></span><span class="koboSpan" id="kobo.1975.1">));
std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1976.1">imbue</span></span><span class="koboSpan" id="kobo.1977.1">(loc);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1978.1">"en_US locale with no_NO numpunct: "</span></span><span class="koboSpan" id="kobo.1979.1"> &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1980.1">42.99</span></span><span class="koboSpan" id="kobo.1981.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1982.1">'\n'</span></span><span class="koboSpan" id="kobo.1983.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1984.1">// en_US locale with no_NO numpunct: 42,99</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1985.1">On the other hand, it is possible to determine whether a locale contains a particular facet using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1986.1">std::has_facet()</span></code><span class="koboSpan" id="kobo.1987.1"> function template, or to obtain a reference to a facet implemented by a particular locale using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1988.1">std::use_facet()</span></code><span class="koboSpan" id="kobo.1989.1"> function template.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1990.1">In the preceding examples, we sorted a vector of strings and passed a locale object as the third argument to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1991.1">std::sort()</span></code><span class="koboSpan" id="kobo.1992.1"> general algorithm. </span><span class="koboSpan" id="kobo.1992.2">This third argument is supposed to be a comparison function object. </span><span class="koboSpan" id="kobo.1992.3">Passing a locale object works because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1993.1">std::locale</span></code><span class="koboSpan" id="kobo.1994.1"> has an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1995.1">operator()</span></code><span class="koboSpan" id="kobo.1996.1"> that lexicographically compares two strings using its collate facet. </span><span class="koboSpan" id="kobo.1996.2">This is actually the only localization functionality that is directly provided by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1997.1">std::locale</span></code><span class="koboSpan" id="kobo.1998.1">; however, what this does is invoke the collate facet’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.1999.1">compare()</span></code><span class="koboSpan" id="kobo.2000.1"> method, which performs the string comparison based on the facet’s rules.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2001.1">Every program has a global locale created when the program starts. </span><span class="koboSpan" id="kobo.2001.2">The content of this global locale is copied into every default-constructed locale. </span><span class="koboSpan" id="kobo.2001.3">The global locale can be replaced using the static method </span><code class="inlineCode"><span class="koboSpan" id="kobo.2002.1">std::locale::global()</span></code><span class="koboSpan" id="kobo.2003.1">. </span><span class="koboSpan" id="kobo.2003.2">By default, the global locale is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2004.1">C</span></code><span class="koboSpan" id="kobo.2005.1"> locale, which is a locale equivalent to ANSI C’s locale with the same name. </span><span class="koboSpan" id="kobo.2005.2">This locale was created to handle simple English text, and it is the default one in C++ that provides compatibility with C. </span><span class="koboSpan" id="kobo.2005.3">A reference to this locale can be obtained with the static method </span><code class="inlineCode"><span class="koboSpan" id="kobo.2006.1">std::locale::classic()</span></code><span class="koboSpan" id="kobo.2007.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2008.1">By default, all </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.2009.1">streams use the classic locale to write or parse text. </span><span class="koboSpan" id="kobo.2009.2">However, it is possible to change the locale used by a stream using the stream’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.2010.1">imbue()</span></code><span class="koboSpan" id="kobo.2011.1"> method. </span><span class="koboSpan" id="kobo.2011.2">This is a member of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2012.1">std::ios_base</span></code><span class="koboSpan" id="kobo.2013.1"> class, which is the base for all I/O streams. </span><span class="koboSpan" id="kobo.2013.2">A companion member is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2014.1">getloc()</span></code><span class="koboSpan" id="kobo.2015.1"> method, which returns a copy of the current stream’s locale.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.2016.1">In the preceding examples, we changed the locale for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2017.1">std::cout</span></code><span class="koboSpan" id="kobo.2018.1"> stream object. </span><span class="koboSpan" id="kobo.2018.2">In practice, you may want to set the same locale for all stream objects associated with the standard C streams: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2019.1">cin</span></code><span class="koboSpan" id="kobo.2020.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2021.1">cout</span></code><span class="koboSpan" id="kobo.2022.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2023.1">cerr</span></code><span class="koboSpan" id="kobo.2024.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2025.1">clog</span></code><span class="koboSpan" id="kobo.2026.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2027.1">wcin</span></code><span class="koboSpan" id="kobo.2028.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2029.1">wcout</span></code><span class="koboSpan" id="kobo.2030.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2031.1">wcerr</span></code><span class="koboSpan" id="kobo.2032.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2033.1">wclog</span></code><span class="koboSpan" id="kobo.2034.1">).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2035.1">When you </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.2036.1">want to use a particular locale (such as German or Norwegian, as shown in this recipe), you must make sure they are available on your system. </span><span class="koboSpan" id="kobo.2036.2">On Windows, this should not be a problem, but on a Linux system, they might not be installed. </span><span class="koboSpan" id="kobo.2036.3">In this case, trying to instantiate a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2037.1">std::locale</span></code><span class="koboSpan" id="kobo.2038.1"> object, such as with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2039.1">std::locale("de_DE.utf8")</span></code><span class="koboSpan" id="kobo.2040.1">, would result in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2041.1">std::runtime_error</span></code><span class="koboSpan" id="kobo.2042.1"> exception being thrown. </span><span class="koboSpan" id="kobo.2042.2">To install a locale on your system, consult its documentation to find the necessary steps you have to perform.</span></p>
<h2 class="heading-2" id="_idParaDest-446"><span class="koboSpan" id="kobo.2043.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2044.1">Using I/O manipulators to control the output of a stream</span></em><span class="koboSpan" id="kobo.2045.1">, to learn about the use of helper functions, called manipulators, that control input and output streams using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2046.1">&lt;&lt;</span></code><span class="koboSpan" id="kobo.2047.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2048.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.2049.1"> stream operators</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2050.1">Using monetary I/O manipulators</span></em><span class="koboSpan" id="kobo.2051.1">, to learn how to use standard manipulators to write and read monetary values</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2052.1">Using time I/O manipulators</span></em><span class="koboSpan" id="kobo.2053.1">, to learn how to use standard manipulators to write and read date and time values</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-447"><span class="koboSpan" id="kobo.2054.1">Using I/O manipulators to control the output of a stream</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2055.1">Apart from </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.2056.1">the stream-based I/O library, the standard library provides a series of helper functions, called manipulators, that control the input and output streams using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2057.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.2058.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2059.1">operator&gt;&gt;</span></code><span class="koboSpan" id="kobo.2060.1">. </span><span class="koboSpan" id="kobo.2060.2">In this recipe, we will look at some of these manipulators and demonstrate their use through some examples that format the output to the console. </span><span class="koboSpan" id="kobo.2060.3">We will continue covering more manipulators in the upcoming recipes.</span></p>
<h2 class="heading-2" id="_idParaDest-448"><span class="koboSpan" id="kobo.2061.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2062.1">The I/O manipulators are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2063.1">std</span></code><span class="koboSpan" id="kobo.2064.1"> namespace in the headers </span><code class="inlineCode"><span class="koboSpan" id="kobo.2065.1">&lt;ios&gt;</span></code><span class="koboSpan" id="kobo.2066.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2067.1">&lt;istream&gt;</span></code><span class="koboSpan" id="kobo.2068.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2069.1">&lt;ostream&gt;</span></code><span class="koboSpan" id="kobo.2070.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2071.1">&lt;iomanip&gt;</span></code><span class="koboSpan" id="kobo.2072.1">. </span><span class="koboSpan" id="kobo.2072.2">In this recipe, we will only discuss some of the manipulators from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2073.1">&lt;ios&gt;</span></code><span class="koboSpan" id="kobo.2074.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2075.1">&lt;iomanip&gt;</span></code><span class="koboSpan" id="kobo.2076.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-449"><span class="koboSpan" id="kobo.2077.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2078.1">The following manipulators can be used to control the output or input of a stream:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2079.1">boolalpha</span></code><span class="koboSpan" id="kobo.2080.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2081.1">noboolalpha</span></code><span class="koboSpan" id="kobo.2082.1"> enable and disable the textual representation of Booleans:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2083.1">std::cout &lt;&lt; std::boolalpha &lt;&lt; </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2084.1">true</span></span><span class="koboSpan" id="kobo.2085.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2086.1">'\n'</span></span><span class="koboSpan" id="kobo.2087.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2088.1">// true</span></span><span class="koboSpan" id="kobo.2089.1">
std::cout &lt;&lt; </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2090.1">false</span></span><span class="koboSpan" id="kobo.2091.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2092.1">'\n'</span></span><span class="koboSpan" id="kobo.2093.1">;                     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2094.1">// false</span></span><span class="koboSpan" id="kobo.2095.1">
std::cout &lt;&lt; std::noboolalpha &lt;&lt; </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2096.1">false</span></span><span class="koboSpan" id="kobo.2097.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2098.1">'\n'</span></span><span class="koboSpan" id="kobo.2099.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2100.1">// 0</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2101.1">left</span></code><span class="koboSpan" id="kobo.2102.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2103.1">right</span></code><span class="koboSpan" id="kobo.2104.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2105.1">internal</span></code><span class="koboSpan" id="kobo.2106.1"> affect the alignment of the fill characters; </span><code class="inlineCode"><span class="koboSpan" id="kobo.2107.1">left</span></code><span class="koboSpan" id="kobo.2108.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2109.1">right</span></code><span class="koboSpan" id="kobo.2110.1"> affect all text, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.2111.1">internal</span></code><span class="koboSpan" id="kobo.2112.1"> affects only the integer, floating-point, and monetary output:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2113.1">std::cout &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2114.1">setw</span></span><span class="koboSpan" id="kobo.2115.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2116.1">10</span></span><span class="koboSpan" id="kobo.2117.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2118.1">"right\n"</span></span><span class="koboSpan" id="kobo.2119.1">;
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2120.1">setw</span></span><span class="koboSpan" id="kobo.2121.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2122.1">10</span></span><span class="koboSpan" id="kobo.2123.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2124.1">"text\n"</span></span><span class="koboSpan" id="kobo.2125.1">;
std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2126.1">setw</span></span><span class="koboSpan" id="kobo.2127.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2128.1">10</span></span><span class="koboSpan" id="kobo.2129.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2130.1">"left\n"</span></span><span class="koboSpan" id="kobo.2131.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2132.1">fixed</span></code><span class="koboSpan" id="kobo.2133.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2134.1">scientific</span></code><span class="koboSpan" id="kobo.2135.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2136.1">hexfloat</span></code><span class="koboSpan" id="kobo.2137.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2138.1">defaultfloat</span></code><span class="koboSpan" id="kobo.2139.1"> change the formatting used for floating-point types (for both the input and output streams). </span><span class="koboSpan" id="kobo.2139.2">The latter two have only been available since C++11:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2140.1">std::cout &lt;&lt; std::fixed &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2141.1">0.25</span></span><span class="koboSpan" id="kobo.2142.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2143.1">'\n'</span></span><span class="koboSpan" id="kobo.2144.1">;         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2145.1">// 0.250000</span></span><span class="koboSpan" id="kobo.2146.1">
std::cout &lt;&lt; std::scientific &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2147.1">0.25</span></span><span class="koboSpan" id="kobo.2148.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2149.1">'\n'</span></span><span class="koboSpan" id="kobo.2150.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2151.1">// 2.500000e-01</span></span><span class="koboSpan" id="kobo.2152.1">
std::cout &lt;&lt; std::hexfloat &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2153.1">0.25</span></span><span class="koboSpan" id="kobo.2154.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2155.1">'\n'</span></span><span class="koboSpan" id="kobo.2156.1">;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2157.1">// 0x1p-2</span></span><span class="koboSpan" id="kobo.2158.1">
std::cout &lt;&lt; std::defaultfloat &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2159.1">0.25</span></span><span class="koboSpan" id="kobo.2160.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2161.1">'\n'</span></span><span class="koboSpan" id="kobo.2162.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2163.1">// 0.25</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2164.1">dec</span></code><span class="koboSpan" id="kobo.2165.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2166.1">hex</span></code><span class="koboSpan" id="kobo.2167.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2168.1">oct</span></code><span class="koboSpan" id="kobo.2169.1"> control the base that is used for the integer types (in both the input and output streams):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2170.1">std::cout &lt;&lt; std::oct &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2171.1">42</span></span><span class="koboSpan" id="kobo.2172.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2173.1">'\n'</span></span><span class="koboSpan" id="kobo.2174.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2175.1">// 52</span></span><span class="koboSpan" id="kobo.2176.1">
std::cout &lt;&lt; std::hex &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2177.1">42</span></span><span class="koboSpan" id="kobo.2178.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2179.1">'\n'</span></span><span class="koboSpan" id="kobo.2180.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2181.1">// 2a</span></span><span class="koboSpan" id="kobo.2182.1">
std::cout &lt;&lt; std::dec &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2183.1">42</span></span><span class="koboSpan" id="kobo.2184.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2185.1">'\n'</span></span><span class="koboSpan" id="kobo.2186.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2187.1">// 42</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2188.1">setw</span></code><span class="koboSpan" id="kobo.2189.1"> changes </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.2190.1">the width of the next input or output field. </span><span class="koboSpan" id="kobo.2190.2">The default width is 0.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2191.1">setfill</span></code><span class="koboSpan" id="kobo.2192.1"> changes the fill character for the output stream; this is the character that is used to fill the next fields until the specified width is reached. </span><span class="koboSpan" id="kobo.2192.2">The default fill character is whitespace:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2193.1">std::cout &lt;&lt; std::right
          &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2194.1">setfill</span></span><span class="koboSpan" id="kobo.2195.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2196.1">'.'</span></span><span class="koboSpan" id="kobo.2197.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2198.1">setw</span></span><span class="koboSpan" id="kobo.2199.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2200.1">10</span></span><span class="koboSpan" id="kobo.2201.1">)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2202.1">"right"</span></span><span class="koboSpan" id="kobo.2203.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2204.1">'\n'</span></span><span class="koboSpan" id="kobo.2205.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2206.1">// .....right</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2207.1">setprecision</span></code><span class="koboSpan" id="kobo.2208.1"> changes the decimal precision (how many digits are generated) for the floating-point types in both the input and output streams. </span><span class="koboSpan" id="kobo.2208.2">The default precision is 6:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2209.1">std::cout &lt;&lt; std::fixed &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2210.1">setprecision</span></span><span class="koboSpan" id="kobo.2211.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2212.1">2</span></span><span class="koboSpan" id="kobo.2213.1">) &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2214.1">12.345</span></span><span class="koboSpan" id="kobo.2215.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2216.1">'\n'</span></span><span class="koboSpan" id="kobo.2217.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2218.1">// 12.35</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-450"><span class="koboSpan" id="kobo.2219.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2220.1">All of the I/O manipulators listed earlier (with the exception of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2221.1">setw</span></code><span class="koboSpan" id="kobo.2222.1">, which only refers to the next output field) affect the stream. </span><span class="koboSpan" id="kobo.2222.2">Additionally, all consecutive writing or reading operations use the last specified format until another manipulator is used again.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2223.1">Some of these manipulators are called without arguments. </span><span class="koboSpan" id="kobo.2223.2">Examples include </span><code class="inlineCode"><span class="koboSpan" id="kobo.2224.1">boolalpha</span></code><span class="koboSpan" id="kobo.2225.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2226.1">noboolalpha</span></code><span class="koboSpan" id="kobo.2227.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2228.1">dec</span></code><span class="koboSpan" id="kobo.2229.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2230.1">hex</span></code><span class="koboSpan" id="kobo.2231.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2232.1">oct</span></code><span class="koboSpan" id="kobo.2233.1">. </span><span class="koboSpan" id="kobo.2233.2">These manipulators are functions that take a single argument (that is, a reference to a string) and return a reference to the same stream:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2234.1">std::ios_base&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2235.1">hex</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2236.1">(std::ios_base&amp; str)</span></span><span class="koboSpan" id="kobo.2237.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2238.1">Expressions, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2239.1">std::cout &lt;&lt; std::hex</span></code><span class="koboSpan" id="kobo.2240.1">, are possible because both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2241.1">basic_ostream::operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.2242.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2243.1">basic_istream::operator&gt;&gt;</span></code><span class="koboSpan" id="kobo.2244.1"> have special overloads that take a pointer to these functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2245.1">Other </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.2246.1">manipulators, including some that are not mentioned here, are invoked with arguments. </span><span class="koboSpan" id="kobo.2246.2">These manipulators are functions that take one or more arguments and return an object of an unspecified type:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2247.1">template</span></span><span class="koboSpan" id="kobo.2248.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2249.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2250.1">CharT</span></span><span class="koboSpan" id="kobo.2251.1">&gt;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2252.1">/*unspecified*/</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2253.1">setfill</span></span><span class="koboSpan" id="kobo.2254.1">(CharT c);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2255.1">To better demonstrate the use of these manipulators, we will consider two examples that format output to the console.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2256.1">In the first example, we will list the table of contents of a book with the following requirements:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2257.1">The chapter number is right-aligned and shown with Roman numerals.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2258.1">The chapter title is left-aligned and the remaining space until the page number is filled with dots.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2259.1">The page number of the chapter is right-aligned.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2260.1">For this example, we will use the following classes and helper function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2261.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2262.1">Chapter</span></span><span class="koboSpan" id="kobo.2263.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2264.1">int</span></span><span class="koboSpan" id="kobo.2265.1"> Number;
  std::string Title;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2266.1">int</span></span><span class="koboSpan" id="kobo.2267.1"> Page;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2268.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2269.1">BookPart</span></span><span class="koboSpan" id="kobo.2270.1">
{
  std::string Title;
  std::vector&lt;Chapter&gt; Chapters;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2271.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2272.1">Book</span></span><span class="koboSpan" id="kobo.2273.1">
{
  std::string Title;
  std::vector&lt;BookPart&gt; Parts;
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2274.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2275.1">to_roman</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2276.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2277.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2278.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2279.1"> value)</span></span><span class="koboSpan" id="kobo.2280.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2281.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2282.1">roman_t</span></span><span class="koboSpan" id="kobo.2283.1"> { </span><span class="hljs-type"><span class="koboSpan" id="kobo.2284.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2285.1">int</span></span><span class="koboSpan" id="kobo.2286.1"> value; </span><span class="hljs-type"><span class="koboSpan" id="kobo.2287.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2288.1">const</span></span><span class="koboSpan" id="kobo.2289.1">* numeral; };
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2290.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2291.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2292.1">roman_t</span></span><span class="koboSpan" id="kobo.2293.1"> rarr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2294.1">13</span></span><span class="koboSpan" id="kobo.2295.1">] =
  {
    {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2296.1">1000</span></span><span class="koboSpan" id="kobo.2297.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2298.1">"M"</span></span><span class="koboSpan" id="kobo.2299.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2300.1">900</span></span><span class="koboSpan" id="kobo.2301.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2302.1">"CM"</span></span><span class="koboSpan" id="kobo.2303.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2304.1">500</span></span><span class="koboSpan" id="kobo.2305.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2306.1">"D"</span></span><span class="koboSpan" id="kobo.2307.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2308.1">400</span></span><span class="koboSpan" id="kobo.2309.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2310.1">"CD"</span></span><span class="koboSpan" id="kobo.2311.1">},
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2312.1">100</span></span><span class="koboSpan" id="kobo.2313.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2314.1">"C"</span></span><span class="koboSpan" id="kobo.2315.1">}, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2316.1">90</span></span><span class="koboSpan" id="kobo.2317.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2318.1">"XC"</span></span><span class="koboSpan" id="kobo.2319.1">}, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2320.1">50</span></span><span class="koboSpan" id="kobo.2321.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2322.1">"L"</span></span><span class="koboSpan" id="kobo.2323.1">}, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2324.1">40</span></span><span class="koboSpan" id="kobo.2325.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2326.1">"XL"</span></span><span class="koboSpan" id="kobo.2327.1">},
    {  </span><span class="hljs-number"><span class="koboSpan" id="kobo.2328.1">10</span></span><span class="koboSpan" id="kobo.2329.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2330.1">"X"</span></span><span class="koboSpan" id="kobo.2331.1">}, {  </span><span class="hljs-number"><span class="koboSpan" id="kobo.2332.1">9</span></span><span class="koboSpan" id="kobo.2333.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2334.1">"IX"</span></span><span class="koboSpan" id="kobo.2335.1">}, {  </span><span class="hljs-number"><span class="koboSpan" id="kobo.2336.1">5</span></span><span class="koboSpan" id="kobo.2337.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2338.1">"V"</span></span><span class="koboSpan" id="kobo.2339.1">}, {  </span><span class="hljs-number"><span class="koboSpan" id="kobo.2340.1">4</span></span><span class="koboSpan" id="kobo.2341.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2342.1">"IV"</span></span><span class="koboSpan" id="kobo.2343.1">},
    {   </span><span class="hljs-number"><span class="koboSpan" id="kobo.2344.1">1</span></span><span class="koboSpan" id="kobo.2345.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2346.1">"I"</span></span><span class="koboSpan" id="kobo.2347.1">}
  };
  std::string result;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2348.1">for</span></span><span class="koboSpan" id="kobo.2349.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2350.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2351.1">const</span></span><span class="koboSpan" id="kobo.2352.1"> &amp; number : rarr)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2353.1">while</span></span><span class="koboSpan" id="kobo.2354.1"> (value &gt;= number.value)
    {
      result += number.numeral;
      value -= number.value;
    }
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2355.1">return</span></span><span class="koboSpan" id="kobo.2356.1"> result;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2357.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2358.1">print_toc()</span></code><span class="koboSpan" id="kobo.2359.1"> function, as </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.2360.1">shown in the following code snippet, takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2361.1">Book</span></code><span class="koboSpan" id="kobo.2362.1"> as its argument and prints its content to the console according to the specified requirements. </span><span class="koboSpan" id="kobo.2362.2">For this purpose, we use the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2363.1">std::left</span></code><span class="koboSpan" id="kobo.2364.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2365.1">std::right</span></code><span class="koboSpan" id="kobo.2366.1"> specify the text alignment</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2367.1">std::setw</span></code><span class="koboSpan" id="kobo.2368.1"> specifies the width of each output field</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2369.1">std::fill</span></code><span class="koboSpan" id="kobo.2370.1"> specifies the fill character (a blank space for the chapter number and a dot for the chapter title)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2371.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2372.1">print_toc()</span></code><span class="koboSpan" id="kobo.2373.1"> function is listed here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2374.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2375.1">print_toc</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2376.1">(Book </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2377.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2378.1"> &amp; book)</span></span><span class="koboSpan" id="kobo.2379.1">
{
  std::cout &lt;&lt; book.Title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2380.1">'\n'</span></span><span class="koboSpan" id="kobo.2381.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2382.1">for</span></span><span class="koboSpan" id="kobo.2383.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2384.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2385.1">const</span></span><span class="koboSpan" id="kobo.2386.1"> &amp; part : book.Parts)
  {
    std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2387.1">setw</span></span><span class="koboSpan" id="kobo.2388.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2389.1">15</span></span><span class="koboSpan" id="kobo.2390.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2391.1">setfill</span></span><span class="koboSpan" id="kobo.2392.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2393.1">' '</span></span><span class="koboSpan" id="kobo.2394.1">)
              &lt;&lt; part.Title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2395.1">'\n'</span></span><span class="koboSpan" id="kobo.2396.1">;
    std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2397.1">setw</span></span><span class="koboSpan" id="kobo.2398.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2399.1">15</span></span><span class="koboSpan" id="kobo.2400.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2401.1">setfill</span></span><span class="koboSpan" id="kobo.2402.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2403.1">'-'</span></span><span class="koboSpan" id="kobo.2404.1">)
              &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2405.1">'-'</span></span><span class="koboSpan" id="kobo.2406.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2407.1">'\n'</span></span><span class="koboSpan" id="kobo.2408.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2409.1">for</span></span><span class="koboSpan" id="kobo.2410.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2411.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2412.1">const</span></span><span class="koboSpan" id="kobo.2413.1"> &amp; chapter : part.Chapters)
    {
      std::cout &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2414.1">setw</span></span><span class="koboSpan" id="kobo.2415.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2416.1">4</span></span><span class="koboSpan" id="kobo.2417.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2418.1">setfill</span></span><span class="koboSpan" id="kobo.2419.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2420.1">' '</span></span><span class="koboSpan" id="kobo.2421.1">)
                &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2422.1">to_roman</span></span><span class="koboSpan" id="kobo.2423.1">(chapter.Number) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2424.1">' '</span></span><span class="koboSpan" id="kobo.2425.1">;
      std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2426.1">setw</span></span><span class="koboSpan" id="kobo.2427.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2428.1">35</span></span><span class="koboSpan" id="kobo.2429.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2430.1">setfill</span></span><span class="koboSpan" id="kobo.2431.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2432.1">'.'</span></span><span class="koboSpan" id="kobo.2433.1">)
                &lt;&lt; chapter.Title;
      std::cout &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2434.1">setw</span></span><span class="koboSpan" id="kobo.2435.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2436.1">3</span></span><span class="koboSpan" id="kobo.2437.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2438.1">setfill</span></span><span class="koboSpan" id="kobo.2439.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2440.1">'.'</span></span><span class="koboSpan" id="kobo.2441.1">)
                &lt;&lt; chapter.Page &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2442.1">'\n'</span></span><span class="koboSpan" id="kobo.2443.1">;
    }
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2444.1">The </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.2445.1">following example uses this method with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2446.1">Book</span></code><span class="koboSpan" id="kobo.2447.1"> object describing the table of contents from the book </span><em class="italic"><span class="koboSpan" id="kobo.2448.1">The Fellowship of the Ring</span></em><span class="koboSpan" id="kobo.2449.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2450.1">auto</span></span><span class="koboSpan" id="kobo.2451.1"> book = Book
{
  </span><span class="hljs-string"><span class="koboSpan" id="kobo.2452.1">"THE FELLOWSHIP OF THE RING"</span></span><span class="koboSpan" id="kobo.2453.1">s,
  {
    {
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.2454.1">"BOOK ONE"</span></span><span class="koboSpan" id="kobo.2455.1">s,
      {
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2456.1">1</span></span><span class="koboSpan" id="kobo.2457.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2458.1">"A Long-expected Party"</span></span><span class="koboSpan" id="kobo.2459.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2460.1">21</span></span><span class="koboSpan" id="kobo.2461.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2462.1">2</span></span><span class="koboSpan" id="kobo.2463.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2464.1">"The Shadow of the Past"</span></span><span class="koboSpan" id="kobo.2465.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2466.1">42</span></span><span class="koboSpan" id="kobo.2467.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2468.1">3</span></span><span class="koboSpan" id="kobo.2469.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2470.1">"Three Is Company"</span></span><span class="koboSpan" id="kobo.2471.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2472.1">65</span></span><span class="koboSpan" id="kobo.2473.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2474.1">4</span></span><span class="koboSpan" id="kobo.2475.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2476.1">"A Short Cut to Mushrooms"</span></span><span class="koboSpan" id="kobo.2477.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2478.1">86</span></span><span class="koboSpan" id="kobo.2479.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2480.1">5</span></span><span class="koboSpan" id="kobo.2481.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2482.1">"A Conspiracy Unmasked"</span></span><span class="koboSpan" id="kobo.2483.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2484.1">98</span></span><span class="koboSpan" id="kobo.2485.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2486.1">6</span></span><span class="koboSpan" id="kobo.2487.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2488.1">"The Old Forest"</span></span><span class="koboSpan" id="kobo.2489.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2490.1">109</span></span><span class="koboSpan" id="kobo.2491.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2492.1">7</span></span><span class="koboSpan" id="kobo.2493.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2494.1">"In the House of Tom Bombadil"</span></span><span class="koboSpan" id="kobo.2495.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2496.1">123</span></span><span class="koboSpan" id="kobo.2497.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2498.1">8</span></span><span class="koboSpan" id="kobo.2499.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2500.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2501.1">Fog on the Barrow-downs"</span></span><span class="koboSpan" id="kobo.2502.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2503.1">135</span></span><span class="koboSpan" id="kobo.2504.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2505.1">9</span></span><span class="koboSpan" id="kobo.2506.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2507.1">"At the Sign of The Prancing Pony"</span></span><span class="koboSpan" id="kobo.2508.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2509.1">149</span></span><span class="koboSpan" id="kobo.2510.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2511.1">10</span></span><span class="koboSpan" id="kobo.2512.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2513.1">"Strider"</span></span><span class="koboSpan" id="kobo.2514.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2515.1">163</span></span><span class="koboSpan" id="kobo.2516.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2517.1">11</span></span><span class="koboSpan" id="kobo.2518.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2519.1">"A Knife in the Dark"</span></span><span class="koboSpan" id="kobo.2520.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2521.1">176</span></span><span class="koboSpan" id="kobo.2522.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2523.1">12</span></span><span class="koboSpan" id="kobo.2524.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2525.1">"Flight to the Ford"</span></span><span class="koboSpan" id="kobo.2526.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2527.1">197</span></span><span class="koboSpan" id="kobo.2528.1">},
      },
    },
    {
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.2529.1">"BOOK TWO"</span></span><span class="koboSpan" id="kobo.2530.1">s,
      {
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2531.1">1</span></span><span class="koboSpan" id="kobo.2532.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2533.1">"Many Meetings"</span></span><span class="koboSpan" id="kobo.2534.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2535.1">219</span></span><span class="koboSpan" id="kobo.2536.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2537.1">2</span></span><span class="koboSpan" id="kobo.2538.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2539.1">"The Council of Elrond"</span></span><span class="koboSpan" id="kobo.2540.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2541.1">239</span></span><span class="koboSpan" id="kobo.2542.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2543.1">3</span></span><span class="koboSpan" id="kobo.2544.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2545.1">"The Ring Goes South"</span></span><span class="koboSpan" id="kobo.2546.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2547.1">272</span></span><span class="koboSpan" id="kobo.2548.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2549.1">4</span></span><span class="koboSpan" id="kobo.2550.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2551.1">"A Journey in the Dark"</span></span><span class="koboSpan" id="kobo.2552.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2553.1">295</span></span><span class="koboSpan" id="kobo.2554.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2555.1">5</span></span><span class="koboSpan" id="kobo.2556.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2557.1">"The Bridge of Khazad-dum"</span></span><span class="koboSpan" id="kobo.2558.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2559.1">321</span></span><span class="koboSpan" id="kobo.2560.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2561.1">6</span></span><span class="koboSpan" id="kobo.2562.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2563.1">"Lothlorien"</span></span><span class="koboSpan" id="kobo.2564.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2565.1">333</span></span><span class="koboSpan" id="kobo.2566.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2567.1">7</span></span><span class="koboSpan" id="kobo.2568.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2569.1">"The Mirror of Galadriel"</span></span><span class="koboSpan" id="kobo.2570.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2571.1">353</span></span><span class="koboSpan" id="kobo.2572.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2573.1">8</span></span><span class="koboSpan" id="kobo.2574.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2575.1">"Farewell to Lorien"</span></span><span class="koboSpan" id="kobo.2576.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2577.1">367</span></span><span class="koboSpan" id="kobo.2578.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2579.1">9</span></span><span class="koboSpan" id="kobo.2580.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2581.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2582.1">The Great River"</span></span><span class="koboSpan" id="kobo.2583.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2584.1">380</span></span><span class="koboSpan" id="kobo.2585.1">},
        {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2586.1">10</span></span><span class="koboSpan" id="kobo.2587.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2588.1">"The Breaking of the Fellowship"</span></span><span class="koboSpan" id="kobo.2589.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2590.1">390</span></span><span class="koboSpan" id="kobo.2591.1">},
      },
    },
  }
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2592.1">print_toc</span></span><span class="koboSpan" id="kobo.2593.1">(book);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2594.1">In this case, the </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.2595.1">output is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2596.1">THE FELLOWSHIP OF THE RING
BOOK ONE
---------------
   I A Long-expected Party...............21
  II The Shadow of the Past..............42
 III Three Is Company....................65
  IV A Short Cut to Mushrooms............86
   V A Conspiracy Unmasked...............98
  VI The Old Forest.....................109
 VII In the House of Tom Bombadil.......123
VIII Fog on the Barrow-downs............135
  IX At the Sign of The Prancing Pony...149
   X Strider............................163
  XI A Knife in the Dark................176
 XII Flight to the Ford.................197
BOOK TWO
---------------
   I Many Meetings......................219
  II The Council of Elrond..............239
 III The Ring Goes South................272
  IV A Journey in the Dark..............295
   V The Bridge of Khazad-dum...........321
  VI Lothlorien.........................333
 VII The Mirror of Galadriel............353
VIII Farewell to Lorien.................367
  IX The Great River....................380
   X The Breaking of the Fellowship.....390
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2597.1">For the</span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.2598.1"> second example, our goal is to output a table that lists the largest companies in the world by revenue. </span><span class="koboSpan" id="kobo.2598.2">The table will have columns for the company name, the industry, the revenue (in USD billions), the increase/decrease in revenue growth, the revenue growth, the number of employees, and the country of origin. </span><span class="koboSpan" id="kobo.2598.3">For this example, we will use the following class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2599.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2600.1">Company</span></span><span class="koboSpan" id="kobo.2601.1">
{
  std::string Name;
  std::string Industry;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2602.1">double</span></span><span class="koboSpan" id="kobo.2603.1">      Revenue;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2604.1">bool</span></span><span class="koboSpan" id="kobo.2605.1">        RevenueIncrease;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2606.1">double</span></span><span class="koboSpan" id="kobo.2607.1">      Growth;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2608.1">int</span></span><span class="koboSpan" id="kobo.2609.1">         Employees;
  std::string Country;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2610.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2611.1">print_companies()</span></code><span class="koboSpan" id="kobo.2612.1"> function in the following code snippet uses several additional manipulators to the ones shown in the previous example:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2613.1">std::boolalpha</span></code><span class="koboSpan" id="kobo.2614.1"> displays Boolean values as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2615.1">true</span></code><span class="koboSpan" id="kobo.2616.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2617.1">false</span></code><span class="koboSpan" id="kobo.2618.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2619.1">1</span></code><span class="koboSpan" id="kobo.2620.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2621.1">0</span></code><span class="koboSpan" id="kobo.2622.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2623.1">std::fixed</span></code><span class="koboSpan" id="kobo.2624.1"> indicates a fixed floating-point representation, and then </span><code class="inlineCode"><span class="koboSpan" id="kobo.2625.1">std::defaultfloat</span></code><span class="koboSpan" id="kobo.2626.1"> reverts to the default floating-point representation.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2627.1">std::setprecision</span></code><span class="koboSpan" id="kobo.2628.1"> specifies the number of decimal digits to be displayed in the output. </span><span class="koboSpan" id="kobo.2628.2">Together with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2629.1">std::fixed</span></code><span class="koboSpan" id="kobo.2630.1">, this is used to indicate a fixed representation with a decimal digit for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2631.1">Growth</span></code><span class="koboSpan" id="kobo.2632.1"> field.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2633.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2634.1">print_companies()</span></code><span class="koboSpan" id="kobo.2635.1"> function is listed here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2636.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2637.1">print_companies</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2638.1">(std::vector&lt;Company&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2639.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2640.1"> &amp; companies)</span></span><span class="koboSpan" id="kobo.2641.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2642.1">for</span></span><span class="koboSpan" id="kobo.2643.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2644.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2645.1">const</span></span><span class="koboSpan" id="kobo.2646.1"> &amp; company : companies)
  {
    std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2647.1">setw</span></span><span class="koboSpan" id="kobo.2648.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2649.1">26</span></span><span class="koboSpan" id="kobo.2650.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2651.1">setfill</span></span><span class="koboSpan" id="kobo.2652.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2653.1">' '</span></span><span class="koboSpan" id="kobo.2654.1">)
              &lt;&lt; company.Name;
    std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2655.1">setw</span></span><span class="koboSpan" id="kobo.2656.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2657.1">18</span></span><span class="koboSpan" id="kobo.2658.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2659.1">setfill</span></span><span class="koboSpan" id="kobo.2660.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2661.1">' '</span></span><span class="koboSpan" id="kobo.2662.1">)
              &lt;&lt; company.Industry;
    std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2663.1">setw</span></span><span class="koboSpan" id="kobo.2664.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2665.1">5</span></span><span class="koboSpan" id="kobo.2666.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2667.1">setfill</span></span><span class="koboSpan" id="kobo.2668.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2669.1">' '</span></span><span class="koboSpan" id="kobo.2670.1">)
              &lt;&lt; company.Revenue;
    std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2671.1">setw</span></span><span class="koboSpan" id="kobo.2672.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2673.1">5</span></span><span class="koboSpan" id="kobo.2674.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2675.1">setfill</span></span><span class="koboSpan" id="kobo.2676.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2677.1">' '</span></span><span class="koboSpan" id="kobo.2678.1">)
              &lt;&lt; std::boolalpha &lt;&lt; company.RevenueIncrease
              &lt;&lt; std::noboolalpha;
    std::cout &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2679.1">setw</span></span><span class="koboSpan" id="kobo.2680.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2681.1">5</span></span><span class="koboSpan" id="kobo.2682.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2683.1">setfill</span></span><span class="koboSpan" id="kobo.2684.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2685.1">' '</span></span><span class="koboSpan" id="kobo.2686.1">)
              &lt;&lt; std::fixed &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2687.1">setprecision</span></span><span class="koboSpan" id="kobo.2688.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2689.1">1</span></span><span class="koboSpan" id="kobo.2690.1">) &lt;&lt; company.Growth
              &lt;&lt; std::defaultfloat &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2691.1">setprecision</span></span><span class="koboSpan" id="kobo.2692.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2693.1">6</span></span><span class="koboSpan" id="kobo.2694.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2695.1">' '</span></span><span class="koboSpan" id="kobo.2696.1">;
    std::cout &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2697.1">setw</span></span><span class="koboSpan" id="kobo.2698.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2699.1">8</span></span><span class="koboSpan" id="kobo.2700.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2701.1">setfill</span></span><span class="koboSpan" id="kobo.2702.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2703.1">' '</span></span><span class="koboSpan" id="kobo.2704.1">)
              &lt;&lt; company.Employees &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2705.1">' '</span></span><span class="koboSpan" id="kobo.2706.1">;
    std::cout &lt;&lt; std::left &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2707.1">setw</span></span><span class="koboSpan" id="kobo.2708.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2709.1">2</span></span><span class="koboSpan" id="kobo.2710.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2711.1">setfill</span></span><span class="koboSpan" id="kobo.2712.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2713.1">' '</span></span><span class="koboSpan" id="kobo.2714.1">)
              &lt;&lt; company.Country
              &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2715.1">'\n'</span></span><span class="koboSpan" id="kobo.2716.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2717.1">The following </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.2718.1">is an example of calling this method. </span><span class="koboSpan" id="kobo.2718.2">The source of the data shown here is Wikipedia (</span><a href="https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue"><span class="url"><span class="koboSpan" id="kobo.2719.1">https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue</span></span></a><span class="koboSpan" id="kobo.2720.1">, as of 2016):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2721.1">std::vector&lt;Company&gt; companies
{
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.2722.1">"Walmart"</span></span><span class="koboSpan" id="kobo.2723.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2724.1">"Retail"</span></span><span class="koboSpan" id="kobo.2725.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2726.1">482</span></span><span class="koboSpan" id="kobo.2727.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2728.1">false</span></span><span class="koboSpan" id="kobo.2729.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2730.1">0.71</span></span><span class="koboSpan" id="kobo.2731.1">,
    </span><span class="hljs-number"><span class="koboSpan" id="kobo.2732.1">2300000</span></span><span class="koboSpan" id="kobo.2733.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2734.1">"US"</span></span><span class="koboSpan" id="kobo.2735.1">s},
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.2736.1">"State Grid"</span></span><span class="koboSpan" id="kobo.2737.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2738.1">"Electric utility"</span></span><span class="koboSpan" id="kobo.2739.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2740.1">330</span></span><span class="koboSpan" id="kobo.2741.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2742.1">false</span></span><span class="koboSpan" id="kobo.2743.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2744.1">2.91</span></span><span class="koboSpan" id="kobo.2745.1">,
    </span><span class="hljs-number"><span class="koboSpan" id="kobo.2746.1">927839</span></span><span class="koboSpan" id="kobo.2747.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2748.1">"China"</span></span><span class="koboSpan" id="kobo.2749.1">s},
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.2750.1">"Saudi Aramco"</span></span><span class="koboSpan" id="kobo.2751.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2752.1">"Oil and gas"</span></span><span class="koboSpan" id="kobo.2753.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2754.1">311</span></span><span class="koboSpan" id="kobo.2755.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2756.1">true</span></span><span class="koboSpan" id="kobo.2757.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2758.1">40.11</span></span><span class="koboSpan" id="kobo.2759.1">,
    </span><span class="hljs-number"><span class="koboSpan" id="kobo.2760.1">65266</span></span><span class="koboSpan" id="kobo.2761.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2762.1">"SA"</span></span><span class="koboSpan" id="kobo.2763.1">s},
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.2764.1">"China National Petroleum"</span></span><span class="koboSpan" id="kobo.2765.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2766.1">"Oil and gas"</span></span><span class="koboSpan" id="kobo.2767.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2768.1">299</span></span><span class="koboSpan" id="kobo.2769.1">,
    </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2770.1">false</span></span><span class="koboSpan" id="kobo.2771.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2772.1">30.21</span></span><span class="koboSpan" id="kobo.2773.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2774.1">1589508</span></span><span class="koboSpan" id="kobo.2775.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2776.1">"China"</span></span><span class="koboSpan" id="kobo.2777.1">s},
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.2778.1">"Sinopec Group"</span></span><span class="koboSpan" id="kobo.2779.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2780.1">"Oil and gas"</span></span><span class="koboSpan" id="kobo.2781.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2782.1">294</span></span><span class="koboSpan" id="kobo.2783.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2784.1">false</span></span><span class="koboSpan" id="kobo.2785.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2786.1">34.11</span></span><span class="koboSpan" id="kobo.2787.1">,
    </span><span class="hljs-number"><span class="koboSpan" id="kobo.2788.1">810538</span></span><span class="koboSpan" id="kobo.2789.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2790.1">"China"</span></span><span class="koboSpan" id="kobo.2791.1">s},
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2792.1">print_companies</span></span><span class="koboSpan" id="kobo.2793.1">(companies);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2794.1">In this case, the output has a table-based format, as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2795.1">Walmart                   Retail            482  false  0.7  2300000 US
State Grid                Electric utility  330  false  2.9   927839 China
Saudi Aramco              Oil and gas       311  true  40.1    65266 SA
China National Petroleum  Oil and gas       299  false 30.2  1589508 China
Sinopec Group             Oil and gas       294  false 34.1   810538 China
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2796.1">As an exercise, you can try adding a table heading or even a grid line to precede these lines for a better </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.2797.1">tabulation of the data.</span></p>
<h2 class="heading-2" id="_idParaDest-451"><span class="koboSpan" id="kobo.2798.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2799.1">Reading and writing raw data from/to binary files</span></em><span class="koboSpan" id="kobo.2800.1">, to learn how to write and read unstructured data to binary files</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2801.1">Using monetary I/O manipulators</span></em><span class="koboSpan" id="kobo.2802.1">, to learn how to use standard manipulators to write and read monetary values</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2803.1">Using time I/O manipulators</span></em><span class="koboSpan" id="kobo.2804.1">, to learn how to use standard manipulators to write and read date and time values</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-452"><span class="koboSpan" id="kobo.2805.1">Using monetary I/O manipulators</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2806.1">In the previous</span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.2807.1"> recipe, we looked at some of the manipulators that can be used to control input and output streams. </span><span class="koboSpan" id="kobo.2807.2">The manipulators that we discussed were related to numeric values and text values. </span><span class="koboSpan" id="kobo.2807.3">In this recipe, we will look at how to use standard manipulators to write and read monetary values.</span></p>
<h2 class="heading-2" id="_idParaDest-453"><span class="koboSpan" id="kobo.2808.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2809.1">You should now be familiar with locales and how to set them for a stream. </span><span class="koboSpan" id="kobo.2809.2">This topic was discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.2810.1">Using localized settings for streams</span></em><span class="koboSpan" id="kobo.2811.1"> recipe. </span><span class="koboSpan" id="kobo.2811.2">It is recommended that you read that recipe before continuing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2812.1">The manipulators discussed in this recipe are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2813.1">std</span></code><span class="koboSpan" id="kobo.2814.1"> namespace, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2815.1">&lt;iomanip&gt;</span></code><span class="koboSpan" id="kobo.2816.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-454"><span class="koboSpan" id="kobo.2817.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2818.1">To write a</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.2819.1"> monetary value to an output stream, you should do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2820.1">Set the desired locale for controlling the monetary format:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2821.1">std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2822.1">imbue</span></span><span class="koboSpan" id="kobo.2823.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2824.1">locale</span></span><span class="koboSpan" id="kobo.2825.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2826.1">"en_GB.utf8"</span></span><span class="koboSpan" id="kobo.2827.1">));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2828.1">Use either a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2829.1">long double</span></code><span class="koboSpan" id="kobo.2830.1"> or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2831.1">std::basic_string</span></code><span class="koboSpan" id="kobo.2832.1"> value for the amount:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2833.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2834.1">double</span></span><span class="koboSpan" id="kobo.2835.1"> mon = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2836.1">12345.67</span></span><span class="koboSpan" id="kobo.2837.1">;
std::string smon = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2838.1">"12345.67"</span></span><span class="koboSpan" id="kobo.2839.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2840.1">Use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2841.1">std::put_money</span></code><span class="koboSpan" id="kobo.2842.1"> manipulator with a single argument (the monetary value) to display the value using the currency symbol (if any is available):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2843.1">std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2844.1">put_money</span></span><span class="koboSpan" id="kobo.2845.1">(mon)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2846.1">'\n'</span></span><span class="koboSpan" id="kobo.2847.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2848.1">// £123.46</span></span><span class="koboSpan" id="kobo.2849.1">
std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2850.1">put_money</span></span><span class="koboSpan" id="kobo.2851.1">(smon)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2852.1">'\n'</span></span><span class="koboSpan" id="kobo.2853.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2854.1">// £123.46</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2855.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2856.1">std::put_money</span></code><span class="koboSpan" id="kobo.2857.1"> with two arguments (the monetary value and a Boolean flag set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2858.1">true</span></code><span class="koboSpan" id="kobo.2859.1">) to indicate the use of an international currency string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2860.1">std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2861.1">put_money</span></span><span class="koboSpan" id="kobo.2862.1">(mon, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2863.1">true</span></span><span class="koboSpan" id="kobo.2864.1">)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2865.1">'\n'</span></span><span class="koboSpan" id="kobo.2866.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2867.1">// GBP 123.46</span></span><span class="koboSpan" id="kobo.2868.1">
std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2869.1">put_money</span></span><span class="koboSpan" id="kobo.2870.1">(smon, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2871.1">true</span></span><span class="koboSpan" id="kobo.2872.1">)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2873.1">'\n'</span></span><span class="koboSpan" id="kobo.2874.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2875.1">// GBP 123.46</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2876.1">To read a monetary value from an input stream, you should do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2877.1">Set the desired locale to control the monetary format:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2878.1">std::istringstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2879.1">stext</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2880.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2881.1">"$123.45 567.89 USD"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2882.1">)</span></span><span class="koboSpan" id="kobo.2883.1">;
stext.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2884.1">imbue</span></span><span class="koboSpan" id="kobo.2885.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2886.1">locale</span></span><span class="koboSpan" id="kobo.2887.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2888.1">"en_US.utf8"</span></span><span class="koboSpan" id="kobo.2889.1">));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2890.1">Use either a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2891.1">long double</span></code><span class="koboSpan" id="kobo.2892.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2893.1">std::basic_string</span></code><span class="koboSpan" id="kobo.2894.1"> value to read the amount from the input stream:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2895.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2896.1">double</span></span><span class="koboSpan" id="kobo.2897.1"> v1 = 0;
std::string v2;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2898.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2899.1">std::get_money()</span></code><span class="koboSpan" id="kobo.2900.1"> with a single argument (the variable where the monetary value is to be written) if a currency symbol might be used in the input stream:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2901.1">stext &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2902.1">get_money</span></span><span class="koboSpan" id="kobo.2903.1">(v1) &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2904.1">get_money</span></span><span class="koboSpan" id="kobo.2905.1">(v2);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2906.1">// v1 = 12345, v2 = "56789"</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2907.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2908.1">std::get_money()</span></code><span class="koboSpan" id="kobo.2909.1"> with two arguments (the variable where the monetary</span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.2910.1"> value is to be written and a Boolean flag set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2911.1">true</span></code><span class="koboSpan" id="kobo.2912.1">) to indicate the presence of an international currency string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2913.1">std::istringstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2914.1">stext</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2915.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2916.1">"123.45 567.89"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2917.1">)</span></span><span class="koboSpan" id="kobo.2918.1">;
stext.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2919.1">imbue</span></span><span class="koboSpan" id="kobo.2920.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2921.1">locale</span></span><span class="koboSpan" id="kobo.2922.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2923.1">"en_US.utf8"</span></span><span class="koboSpan" id="kobo.2924.1">));
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2925.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2926.1">double</span></span><span class="koboSpan" id="kobo.2927.1"> v1 = 0;
std::string v2;
stext &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2928.1">get_money</span></span><span class="koboSpan" id="kobo.2929.1">(v1, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2930.1">true</span></span><span class="koboSpan" id="kobo.2931.1">) &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2932.1">get_money</span></span><span class="koboSpan" id="kobo.2933.1">(v2, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2934.1">true</span></span><span class="koboSpan" id="kobo.2935.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2936.1">// v1 = 12345, v2 = "56789"</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-455"><span class="koboSpan" id="kobo.2937.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2938.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2939.1">put_money()</span></code><span class="koboSpan" id="kobo.2940.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2941.1">get_money()</span></code><span class="koboSpan" id="kobo.2942.1"> manipulators are very similar. </span><span class="koboSpan" id="kobo.2942.2">They are both function templates that take an argument representing either the monetary value to be written to the output stream or a variable to hold the monetary value read from an input stream, and a second, optional parameter to indicate whether an international currency string is used. </span><span class="koboSpan" id="kobo.2942.3">The default alternative is the currency symbol, if one is available. </span><code class="inlineCode"><span class="koboSpan" id="kobo.2943.1">put_money()</span></code><span class="koboSpan" id="kobo.2944.1"> uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2945.1">std::money_put()</span></code><span class="koboSpan" id="kobo.2946.1"> facet settings to output a monetary value, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2947.1">get_money()</span></code><span class="koboSpan" id="kobo.2948.1"> uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2949.1">std::money_get()</span></code><span class="koboSpan" id="kobo.2950.1"> facet to parse a monetary value. </span><span class="koboSpan" id="kobo.2950.2">Both manipulator function templates return an object of an unspecified type. </span><span class="koboSpan" id="kobo.2950.3">These functions do not throw exceptions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2951.1">template</span></span><span class="koboSpan" id="kobo.2952.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2953.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2954.1">MoneyT</span></span><span class="koboSpan" id="kobo.2955.1">&gt;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2956.1">/*unspecified*/</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2957.1">put_money</span></span><span class="koboSpan" id="kobo.2958.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2959.1">const</span></span><span class="koboSpan" id="kobo.2960.1"> MoneyT&amp; mon, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2961.1">bool</span></span><span class="koboSpan" id="kobo.2962.1"> intl = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2963.1">false</span></span><span class="koboSpan" id="kobo.2964.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2965.1">template</span></span><span class="koboSpan" id="kobo.2966.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2967.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2968.1">MoneyT</span></span><span class="koboSpan" id="kobo.2969.1">&gt;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2970.1">/*unspecified*/</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2971.1">get_money</span></span><span class="koboSpan" id="kobo.2972.1">(MoneyT&amp; mon, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2973.1">bool</span></span><span class="koboSpan" id="kobo.2974.1"> intl = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2975.1">false</span></span><span class="koboSpan" id="kobo.2976.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2977.1">Both of these manipulator functions require the monetary value to be either a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2978.1">long double</span></code><span class="koboSpan" id="kobo.2979.1"> or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2980.1">std::basic_string</span></code><span class="koboSpan" id="kobo.2981.1">.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.2982.1">However, it is important to note that monetary values are stored as integral numbers of the smallest denomination of the currency defined by the locale in use. </span><span class="koboSpan" id="kobo.2982.2">Considering US dollars as that currency, $100.00 is stored as </span><strong class="keyWord"><span class="koboSpan" id="kobo.2983.1">10000.0</span></strong><span class="koboSpan" id="kobo.2984.1">, and 1 cent (that is, $0.01) is stored as </span><strong class="keyWord"><span class="koboSpan" id="kobo.2985.1">1.0</span></strong><span class="koboSpan" id="kobo.2986.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2987.1">When writing a</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.2988.1"> monetary value to an output stream, it is important to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2989.1">std::showbase</span></code><span class="koboSpan" id="kobo.2990.1"> manipulator if you want to display the currency symbol or the international currency string. </span><span class="koboSpan" id="kobo.2990.2">This is normally used to indicate the prefix of a numeric base (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2991.1">0x</span></code><span class="koboSpan" id="kobo.2992.1"> for hexadecimal); however, for monetary values, it is used to indicate whether the currency symbol/string should be displayed or not. </span><span class="koboSpan" id="kobo.2992.2">The following snippet provides an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2993.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2994.1">put_money</span></span><span class="koboSpan" id="kobo.2995.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2996.1">12345.67</span></span><span class="koboSpan" id="kobo.2997.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2998.1">'\n'</span></span><span class="koboSpan" id="kobo.2999.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3000.1">// prints 123.46</span></span><span class="koboSpan" id="kobo.3001.1">
std::cout &lt;&lt; std::showbase &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3002.1">put_money</span></span><span class="koboSpan" id="kobo.3003.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3004.1">12345.67</span></span><span class="koboSpan" id="kobo.3005.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3006.1">'\n'</span></span><span class="koboSpan" id="kobo.3007.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3008.1">// prints £123.46</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3009.1">In the preceding snippet, the first line will just print the numerical value representing a currency amount, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3010.1">123.46</span></code><span class="koboSpan" id="kobo.3011.1">, while the second line will print the same numerical value but preceded by the currency symbol.</span></p>
<h2 class="heading-2" id="_idParaDest-456"><span class="koboSpan" id="kobo.3012.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3013.1">Using I/O manipulators to control the output of a stream</span></em><span class="koboSpan" id="kobo.3014.1">, to learn about the use of helper functions, called manipulators, that control input and output streams using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3015.1">&lt;&lt;</span></code><span class="koboSpan" id="kobo.3016.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3017.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.3018.1"> stream operators</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3019.1">Using time I/O manipulators</span></em><span class="koboSpan" id="kobo.3020.1">, to learn how to use standard manipulators to write and read date and time values</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-457"><span class="koboSpan" id="kobo.3021.1">Using time I/O manipulators</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3022.1">Similar to the</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.3023.1"> monetary I/O manipulators that we discussed in the previous recipe, the C++11 standard provides manipulators that control the writing and reading of time values to and from streams, where time values are represented in the form of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3024.1">std::tm</span></code><span class="koboSpan" id="kobo.3025.1"> object that holds a calendar date and time. </span><span class="koboSpan" id="kobo.3025.2">In this recipe, you will learn how to use these time manipulators.</span></p>
<h2 class="heading-2" id="_idParaDest-458"><span class="koboSpan" id="kobo.3026.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3027.1">Time values </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.3028.1">used by the time I/O manipulators are expressed in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3029.1">std::tm</span></code><span class="koboSpan" id="kobo.3030.1"> values. </span><span class="koboSpan" id="kobo.3030.2">You should be familiar with this structure from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3031.1">&lt;ctime&gt;</span></code><span class="koboSpan" id="kobo.3032.1"> header.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3033.1">You should also be familiar with locales and how to set them for a stream. </span><span class="koboSpan" id="kobo.3033.2">This topic was discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.3034.1">Using localized settings for streams</span></em><span class="koboSpan" id="kobo.3035.1"> recipe. </span><span class="koboSpan" id="kobo.3035.2">It is recommended that you read that recipe before continuing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3036.1">The manipulators discussed in this recipe are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3037.1">std</span></code><span class="koboSpan" id="kobo.3038.1"> namespace, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3039.1">&lt;iomanip&gt;</span></code><span class="koboSpan" id="kobo.3040.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-459"><span class="koboSpan" id="kobo.3041.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3042.1">To write a time value to an output stream, you should perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3043.1">Obtain a calendar date and time value corresponding to a given time. </span><span class="koboSpan" id="kobo.3043.2">There are various ways in which to do this. </span><span class="koboSpan" id="kobo.3043.3">The following shows several examples of how to convert the current time to a local time that is expressed as a calendar date and time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3044.1">auto</span></span><span class="koboSpan" id="kobo.3045.1"> now = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3046.1">now</span></span><span class="koboSpan" id="kobo.3047.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3048.1">auto</span></span><span class="koboSpan" id="kobo.3049.1"> stime = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3050.1">to_time_t</span></span><span class="koboSpan" id="kobo.3051.1">(now);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3052.1">auto</span></span><span class="koboSpan" id="kobo.3053.1"> ltime = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3054.1">localtime</span></span><span class="koboSpan" id="kobo.3055.1">(&amp;stime);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3056.1">auto</span></span><span class="koboSpan" id="kobo.3057.1"> ttime = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3058.1">time</span></span><span class="koboSpan" id="kobo.3059.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.3060.1">nullptr</span></span><span class="koboSpan" id="kobo.3061.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3062.1">auto</span></span><span class="koboSpan" id="kobo.3063.1"> ltime = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3064.1">localtime</span></span><span class="koboSpan" id="kobo.3065.1">(&amp;ttime);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3066.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3067.1">std::put_time()</span></code><span class="koboSpan" id="kobo.3068.1"> to supply a pointer to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3069.1">std::tm</span></code><span class="koboSpan" id="kobo.3070.1"> object, representing the calendar date and time, and a pointer to a null-terminated character string, representing the format. </span><span class="koboSpan" id="kobo.3070.2">The C++11 standard provides a long list of formats that can be used; this list can be consulted at </span><a href="http://en.cppreference.com/w/cpp/io/manip/put_time"><span class="url"><span class="koboSpan" id="kobo.3071.1">http://en.cppreference.com/w/cpp/io/manip/put_time</span></span></a><span class="koboSpan" id="kobo.3072.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.3073.1">To write a standard date and time string according to the settings of a specific locale, first set the locale for the stream by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.3074.1">imbue()</span></code><span class="koboSpan" id="kobo.3075.1"> and then use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3076.1">std::put_time()</span></code><span class="koboSpan" id="kobo.3077.1"> manipulator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3078.1">std::cout.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3079.1">imbue</span></span><span class="koboSpan" id="kobo.3080.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3081.1">locale</span></span><span class="koboSpan" id="kobo.3082.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3083.1">"en_GB.utf8"</span></span><span class="koboSpan" id="kobo.3084.1">));
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3085.1">put_time</span></span><span class="koboSpan" id="kobo.3086.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3087.1">"%c"</span></span><span class="koboSpan" id="kobo.3088.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3089.1">'\n'</span></span><span class="koboSpan" id="kobo.3090.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3091.1">// Sun 04 Dec 2016 05:26:47 JST</span></span>
</code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3092.1">The following</span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.3093.1"> list shows some examples of supported time formats:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3094.1">ISO 8601 date format </span><code class="inlineCode"><span class="koboSpan" id="kobo.3095.1">"%F"</span></code><span class="koboSpan" id="kobo.3096.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3097.1">"%Y-%m-%d"</span></code><span class="koboSpan" id="kobo.3098.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3099.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3100.1">put_time</span></span><span class="koboSpan" id="kobo.3101.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3102.1">"%F"</span></span><span class="koboSpan" id="kobo.3103.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3104.1">'\n'</span></span><span class="koboSpan" id="kobo.3105.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3106.1">// 2016-12-04</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3107.1">ISO 8601 time format </span><code class="inlineCode"><span class="koboSpan" id="kobo.3108.1">"%T"</span></code><span class="koboSpan" id="kobo.3109.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3110.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3111.1">put_time</span></span><span class="koboSpan" id="kobo.3112.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3113.1">"%T"</span></span><span class="koboSpan" id="kobo.3114.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3115.1">'\n'</span></span><span class="koboSpan" id="kobo.3116.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3117.1">// 05:26:47</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3118.1">ISO 8601 combined date and time in UTC format </span><code class="inlineCode"><span class="koboSpan" id="kobo.3119.1">"%FT%T%z"</span></code><span class="koboSpan" id="kobo.3120.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3121.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3122.1">put_time</span></span><span class="koboSpan" id="kobo.3123.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3124.1">"%FT%T%z"</span></span><span class="koboSpan" id="kobo.3125.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3126.1">'\n'</span></span><span class="koboSpan" id="kobo.3127.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3128.1">// 2016-12-04T05:26:47+0900</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3129.1">ISO 8601 week format </span><code class="inlineCode"><span class="koboSpan" id="kobo.3130.1">"%Y-W%V"</span></code><span class="koboSpan" id="kobo.3131.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3132.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3133.1">put_time</span></span><span class="koboSpan" id="kobo.3134.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3135.1">"%Y-W%V"</span></span><span class="koboSpan" id="kobo.3136.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3137.1">'\n'</span></span><span class="koboSpan" id="kobo.3138.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3139.1">// 2016-W48</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3140.1">ISO 8601 date with week number format </span><code class="inlineCode"><span class="koboSpan" id="kobo.3141.1">"</span></code><code class="inlineCode"><span class="koboSpan" id="kobo.3142.1">%Y-W%V-%u"</span></code><span class="koboSpan" id="kobo.3143.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3144.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3145.1">put_time</span></span><span class="koboSpan" id="kobo.3146.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3147.1">"%Y-W%V-%u"</span></span><span class="koboSpan" id="kobo.3148.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3149.1">'\n'</span></span><span class="koboSpan" id="kobo.3150.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3151.1">// 2016-W48-7</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3152.1">ISO 8601 ordinal date format </span><code class="inlineCode"><span class="koboSpan" id="kobo.3153.1">"%Y-%j"</span></code><span class="koboSpan" id="kobo.3154.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3155.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3156.1">put_time</span></span><span class="koboSpan" id="kobo.3157.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3158.1">"%Y-%j"</span></span><span class="koboSpan" id="kobo.3159.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3160.1">'\n'</span></span><span class="koboSpan" id="kobo.3161.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3162.1">// 2016-339</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3163.1">To read a time value from an input stream, you should perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3164.1">Declare an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3165.1">std::tm</span></code><span class="koboSpan" id="kobo.3166.1"> type to hold the time value read from the stream:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3167.1">auto</span></span><span class="koboSpan" id="kobo.3168.1"> time = std::tm {};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3169.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3170.1">std::get_time()</span></code><span class="koboSpan" id="kobo.3171.1"> to supply a pointer to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3172.1">std::tm</span></code><span class="koboSpan" id="kobo.3173.1"> object, which will hold the time value, and a pointer to a null-terminated character string, which represents the format. </span><span class="koboSpan" id="kobo.3173.2">The list of possible formats can be consulted at </span><a href="http://en.cppreference.com/w/cpp/io/manip/get_time"><span class="url"><span class="koboSpan" id="kobo.3174.1">http://en.cppreference.com/w/cpp/io/manip/get_time</span></span></a><span class="koboSpan" id="kobo.3175.1">. </span><span class="koboSpan" id="kobo.3175.2">The following example parses an ISO 8601 combined date and time value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3176.1">std::istringstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3177.1">stext</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3178.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3179.1">"2016-12-04T05:26:47+0900"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3180.1">)</span></span><span class="koboSpan" id="kobo.3181.1">;
stext &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3182.1">get_time</span></span><span class="koboSpan" id="kobo.3183.1">(&amp;time, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3184.1">"%Y-%m-%dT%H:%M:%S"</span></span><span class="koboSpan" id="kobo.3185.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3186.1">if</span></span><span class="koboSpan" id="kobo.3187.1"> (!stext.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3188.1">fail</span></span><span class="koboSpan" id="kobo.3189.1">()) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3190.1">/* do something */</span></span><span class="koboSpan" id="kobo.3191.1"> }
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3192.1">To </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.3193.1">read a standard date and time string according to the settings of a specific locale, first set the locale for the stream by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.3194.1">imbue()</span></code><span class="koboSpan" id="kobo.3195.1"> and then use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3196.1">std::get_time()</span></code><span class="koboSpan" id="kobo.3197.1"> manipulator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3198.1">std::istringstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3199.1">stext</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3200.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3201.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3202.1">Sun 04 Dec 2016 05:35:30 JST"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3203.1">)</span></span><span class="koboSpan" id="kobo.3204.1">;
stext.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3205.1">imbue</span></span><span class="koboSpan" id="kobo.3206.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3207.1">locale</span></span><span class="koboSpan" id="kobo.3208.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3209.1">"en_GB.utf8"</span></span><span class="koboSpan" id="kobo.3210.1">));
stext &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3211.1">get_time</span></span><span class="koboSpan" id="kobo.3212.1">(&amp;time, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3213.1">"%c"</span></span><span class="koboSpan" id="kobo.3214.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3215.1">if</span></span><span class="koboSpan" id="kobo.3216.1"> (stext.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3217.1">fail</span></span><span class="koboSpan" id="kobo.3218.1">()) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3219.1">/* do something else */</span></span><span class="koboSpan" id="kobo.3220.1"> }
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-460"><span class="koboSpan" id="kobo.3221.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3222.1">The two manipulators for time values, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3223.1">put_time()</span></code><span class="koboSpan" id="kobo.3224.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3225.1">get_time()</span></code><span class="koboSpan" id="kobo.3226.1">, are very similar: they are both function templates with two arguments. </span><span class="koboSpan" id="kobo.3226.2">The first argument is a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3227.1">std::tm</span></code><span class="koboSpan" id="kobo.3228.1"> object representing the calendar date and time, which holds the value to be written to the stream or the value that is read from the stream. </span><span class="koboSpan" id="kobo.3228.2">The second argument is a pointer to a null-terminated character string representing the format of the time text. </span><code class="inlineCode"><span class="koboSpan" id="kobo.3229.1">put_time()</span></code><span class="koboSpan" id="kobo.3230.1"> uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3231.1">std::time_put()</span></code><span class="koboSpan" id="kobo.3232.1"> facet to output a date and time value, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3233.1">get_time()</span></code><span class="koboSpan" id="kobo.3234.1"> uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3235.1">std::time_get()</span></code><span class="koboSpan" id="kobo.3236.1"> facet to parse a date and time value. </span><span class="koboSpan" id="kobo.3236.2">Both manipulator function templates return an object of an unspecified type. </span><span class="koboSpan" id="kobo.3236.3">These functions do not throw exceptions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3237.1">template</span></span><span class="koboSpan" id="kobo.3238.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3239.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3240.1">CharT</span></span><span class="koboSpan" id="kobo.3241.1">&gt;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3242.1">/*unspecified*/</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3243.1">put_time</span></span><span class="koboSpan" id="kobo.3244.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3245.1">const</span></span><span class="koboSpan" id="kobo.3246.1"> std::tm* tmb, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3247.1">const</span></span><span class="koboSpan" id="kobo.3248.1"> CharT* fmt);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3249.1">template</span></span><span class="koboSpan" id="kobo.3250.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3251.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3252.1">CharT</span></span><span class="koboSpan" id="kobo.3253.1">&gt;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3254.1">/*unspecified*/</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3255.1">get_time</span></span><span class="koboSpan" id="kobo.3256.1">(std::tm* tmb, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3257.1">const</span></span><span class="koboSpan" id="kobo.3258.1"> CharT* fmt);
</span></code></pre>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.3259.1">The string that results from using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3260.1">put_time()</span></code><span class="koboSpan" id="kobo.3261.1"> to write a date and time value to an output stream is the same as the one that results from a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3262.1">std::strftime()</span></code><span class="koboSpan" id="kobo.3263.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3264.1">std::wcsftime()</span></code><span class="koboSpan" id="kobo.3265.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3266.1">The standard </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.3267.1">defines a long list of available conversion specifiers that compose the format string. </span><span class="koboSpan" id="kobo.3267.2">These specifiers are prefixed with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3268.1">%</span></code><span class="koboSpan" id="kobo.3269.1">, and, in some cases, are followed by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3270.1">E</span></code><span class="koboSpan" id="kobo.3271.1"> or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3272.1">0</span></code><span class="koboSpan" id="kobo.3273.1">. </span><span class="koboSpan" id="kobo.3273.2">Some of them are also equivalent; for instance, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3274.1">%F</span></code><span class="koboSpan" id="kobo.3275.1"> is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3276.1">%Y-%m-%d</span></code><span class="koboSpan" id="kobo.3277.1"> (this is the ISO 8601 date format), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3278.1">%T</span></code><span class="koboSpan" id="kobo.3279.1"> is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3280.1">%H:%M:%S</span></code><span class="koboSpan" id="kobo.3281.1"> (this is the ISO 8601 time format). </span><span class="koboSpan" id="kobo.3281.2">The examples in this recipe mention only a few of the conversion specifiers, referring to ISO 8601 date and time formats. </span><span class="koboSpan" id="kobo.3281.3">For the complete list of conversion specifiers, refer to the C++ standard or follow the links that were mentioned earlier.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3282.1">It is important to note that not all of the conversion specifiers supported by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3283.1">put_time()</span></code><span class="koboSpan" id="kobo.3284.1"> are also supported by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3285.1">get_time()</span></code><span class="koboSpan" id="kobo.3286.1">. </span><span class="koboSpan" id="kobo.3286.2">Examples include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3287.1">z</span></code><span class="koboSpan" id="kobo.3288.1"> (offset from UTC in the ISO 8601 format) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3289.1">Z</span></code><span class="koboSpan" id="kobo.3290.1"> (time zone name or abbreviation) specifiers, which can only be used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3291.1">put_time()</span></code><span class="koboSpan" id="kobo.3292.1">. </span><span class="koboSpan" id="kobo.3292.2">This is demonstrated in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3293.1">std::istringstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3294.1">stext</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3295.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3296.1">"2016-12-04T05:26:47+0900"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3297.1">)</span></span><span class="koboSpan" id="kobo.3298.1">;
</span><span class="hljs-string"><span class="koboSpan" id="kobo.3299.1">auto time = std::tm {};</span></span><span class="koboSpan" id="kobo.3300.1">
stext &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3301.1">get_time</span></span><span class="koboSpan" id="kobo.3302.1">(&amp;time, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3303.1">"%Y-%m-%dT%H:%M:%S%z"</span></span><span class="koboSpan" id="kobo.3304.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3305.1">// fails</span></span><span class="koboSpan" id="kobo.3306.1">
stext &gt;&gt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3307.1">get_time</span></span><span class="koboSpan" id="kobo.3308.1">(&amp;time, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3309.1">"%Y-%m-%dT%H:%M:%S"</span></span><span class="koboSpan" id="kobo.3310.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3311.1">// OK</span></span>
</code></pre>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3312.1">The text represented by some conversion specifiers is locale-dependent. </span><span class="koboSpan" id="kobo.3312.2">All specifiers prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3313.1">E</span></code><span class="koboSpan" id="kobo.3314.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3315.1">0</span></code><span class="koboSpan" id="kobo.3316.1"> are locale-dependent. </span><span class="koboSpan" id="kobo.3316.2">To set a particular locale for the stream, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3317.1">imbue()</span></code><span class="koboSpan" id="kobo.3318.1"> method, as demonstrated in the examples in the </span><em class="italic"><span class="koboSpan" id="kobo.3319.1">How to do it...</span></em><span class="koboSpan" id="kobo.3320.1"> section.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3321.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3322.1">std::localtime()</span></code><span class="koboSpan" id="kobo.3323.1"> function used in an earlier example returns a pointer to a static internal </span><code class="inlineCode"><span class="koboSpan" id="kobo.3324.1">std::tm</span></code><span class="koboSpan" id="kobo.3325.1"> object if it succeeds (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3326.1">nullptr</span></code><span class="koboSpan" id="kobo.3327.1"> otherwise). </span><span class="koboSpan" id="kobo.3327.2">You should not attempt to free this pointer!</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-461"><span class="koboSpan" id="kobo.3328.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3329.1">Using I/O manipulators to control the output of a stream</span></em><span class="koboSpan" id="kobo.3330.1">, to learn about the use of helper functions, called manipulators, that control input and output streams using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3331.1">&lt;&lt;</span></code><span class="koboSpan" id="kobo.3332.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3333.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.3334.1"> stream operators</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3335.1">Using monetary I/O manipulators</span></em><span class="koboSpan" id="kobo.3336.1">, to learn how to use standard manipulators to write and read monetary values</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-462"><span class="koboSpan" id="kobo.3337.1">Working with filesystem paths</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3338.1">An </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.3339.1">important addition to the C++17 standard is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3340.1">filesystem</span></code><span class="koboSpan" id="kobo.3341.1"> library, which enables us to work with paths, files, and directories in hierarchical filesystems (such as Windows or POSIX filesystems). </span><span class="koboSpan" id="kobo.3341.2">This standard library has been developed based on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3342.1">boost.filesystem</span></code><span class="koboSpan" id="kobo.3343.1"> library. </span><span class="koboSpan" id="kobo.3343.2">In the next few recipes, we will explore those features of the library that enable us to perform operations with files and directories, such as creating, moving, or deleting them, but also querying properties and searching. </span><span class="koboSpan" id="kobo.3343.3">It is important, however, to first look at how this library handles paths.</span></p>
<h2 class="heading-2" id="_idParaDest-463"><span class="koboSpan" id="kobo.3344.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3345.1">For this recipe, we will consider most of the examples using Windows paths. </span><span class="koboSpan" id="kobo.3345.2">In the accompanying code, all examples have both Windows and POSIX alternatives.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3346.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3347.1">filesystem</span></code><span class="koboSpan" id="kobo.3348.1"> library is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3349.1">std::filesystem</span></code><span class="koboSpan" id="kobo.3350.1"> namespace, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3351.1">&lt;filesystem&gt;</span></code><span class="koboSpan" id="kobo.3352.1"> header. </span><span class="koboSpan" id="kobo.3352.2">To simplify the code, we will use the following namespace alias in all of the examples:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3353.1">namespace</span></span><span class="koboSpan" id="kobo.3354.1"> fs = std::filesystem;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3355.1">A path to a filesystem component (file, directory, hard link, or soft link) is represented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3356.1">path</span></code><span class="koboSpan" id="kobo.3357.1"> class.</span></p>
<h2 class="heading-2" id="_idParaDest-464"><span class="koboSpan" id="kobo.3358.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3359.1">The following is a list of the most common operations on paths:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3360.1">Create a path using the constructor, the assignment operator, or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3361.1">assign()</span></code><span class="koboSpan" id="kobo.3362.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.3363.1">// Windows</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3364.1">auto</span></span><span class="koboSpan" id="kobo.3365.1"> path = fs::path{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3366.1">"C:\\Users\\Marius\\Documents"</span></span><span class="koboSpan" id="kobo.3367.1">};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3368.1">// POSIX</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3369.1">auto</span></span><span class="koboSpan" id="kobo.3370.1"> path = fs::path{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3371.1">"/home/marius/docs"</span></span><span class="koboSpan" id="kobo.3372.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3373.1">Append</span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.3374.1"> elements to a path by including a directory separator using the member </span><code class="inlineCode"><span class="koboSpan" id="kobo.3375.1">operator /=</span></code><span class="koboSpan" id="kobo.3376.1">, the non-member </span><code class="inlineCode"><span class="koboSpan" id="kobo.3377.1">operator /</span></code><span class="koboSpan" id="kobo.3378.1">, or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3379.1">append()</span></code><span class="koboSpan" id="kobo.3380.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3381.1">path /= </span><span class="hljs-string"><span class="koboSpan" id="kobo.3382.1">"Book"</span></span><span class="koboSpan" id="kobo.3383.1">;
path = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3384.1">"Modern"</span></span><span class="koboSpan" id="kobo.3385.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3386.1">"Cpp"</span></span><span class="koboSpan" id="kobo.3387.1">;
path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3388.1">append</span></span><span class="koboSpan" id="kobo.3389.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3390.1">"Programming"</span></span><span class="koboSpan" id="kobo.3391.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3392.1">// Windows: C:\Users\Marius\Documents\Book\Modern\Cpp\Programming</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3393.1">// POSIX:   /home/marius/docs/Book/Modern/Cpp/Programming</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3394.1">Concatenate elements to a path without including a directory separator by using the member </span><code class="inlineCode"><span class="koboSpan" id="kobo.3395.1">operator +=</span></code><span class="koboSpan" id="kobo.3396.1">, the non-member </span><code class="inlineCode"><span class="koboSpan" id="kobo.3397.1">operator +</span></code><span class="koboSpan" id="kobo.3398.1">, or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3399.1">concat()</span></code><span class="koboSpan" id="kobo.3400.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3401.1">auto</span></span><span class="koboSpan" id="kobo.3402.1"> path = fs::path{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3403.1">"C:\\Users\\Marius\\Documents"</span></span><span class="koboSpan" id="kobo.3404.1"> };
path += </span><span class="hljs-string"><span class="koboSpan" id="kobo.3405.1">"\\Book"</span></span><span class="koboSpan" id="kobo.3406.1">;
path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3407.1">concat</span></span><span class="koboSpan" id="kobo.3408.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3409.1">"\\Modern"</span></span><span class="koboSpan" id="kobo.3410.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3411.1">// path = C:\Users\Marius\Documents\Book\Modern</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3412.1">Decompose the elements of a path into its parts, such as the root, root directory, parent path, filename, extension, and so on, using member functions such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3413.1">root_name()</span></code><span class="koboSpan" id="kobo.3414.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3415.1">root_dir()</span></code><span class="koboSpan" id="kobo.3416.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3417.1">filename()</span></code><span class="koboSpan" id="kobo.3418.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3419.1">stem()</span></code><span class="koboSpan" id="kobo.3420.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3421.1">extension()</span></code><span class="koboSpan" id="kobo.3422.1">, and so on (all of them are shown in the following example):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3423.1">auto</span></span><span class="koboSpan" id="kobo.3424.1"> path =
  fs::path{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3425.1">"C:\\Users\\Marius\\Documents\\sample.file.txt"</span></span><span class="koboSpan" id="kobo.3426.1">};
std::cout
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3427.1">"root: "</span></span><span class="koboSpan" id="kobo.3428.1">        &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3429.1">root_name</span></span><span class="koboSpan" id="kobo.3430.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3431.1">'\n'</span></span><span class="koboSpan" id="kobo.3432.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3433.1">"root dir: "</span></span><span class="koboSpan" id="kobo.3434.1">    &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3435.1">root_directory</span></span><span class="koboSpan" id="kobo.3436.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3437.1">'\n'</span></span><span class="koboSpan" id="kobo.3438.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3439.1">"root path: "</span></span><span class="koboSpan" id="kobo.3440.1">   &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3441.1">root_path</span></span><span class="koboSpan" id="kobo.3442.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3443.1">'\n'</span></span><span class="koboSpan" id="kobo.3444.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3445.1">"rel path: "</span></span><span class="koboSpan" id="kobo.3446.1">    &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3447.1">relative_path</span></span><span class="koboSpan" id="kobo.3448.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3449.1">'\n'</span></span><span class="koboSpan" id="kobo.3450.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3451.1">"parent path: "</span></span><span class="koboSpan" id="kobo.3452.1"> &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3453.1">parent_path</span></span><span class="koboSpan" id="kobo.3454.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3455.1">'\n'</span></span><span class="koboSpan" id="kobo.3456.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3457.1">"filename: "</span></span><span class="koboSpan" id="kobo.3458.1">    &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3459.1">filename</span></span><span class="koboSpan" id="kobo.3460.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3461.1">'\n'</span></span><span class="koboSpan" id="kobo.3462.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3463.1">"stem: "</span></span><span class="koboSpan" id="kobo.3464.1">        &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3465.1">stem</span></span><span class="koboSpan" id="kobo.3466.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3467.1">'\n'</span></span><span class="koboSpan" id="kobo.3468.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3469.1">"extension: "</span></span><span class="koboSpan" id="kobo.3470.1">   &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3471.1">extension</span></span><span class="koboSpan" id="kobo.3472.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3473.1">'\n'</span></span><span class="koboSpan" id="kobo.3474.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3475.1">Query whether parts of a part are available using member functions such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3476.1">has_root_name()</span></code><span class="koboSpan" id="kobo.3477.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3478.1">has_root_directory()</span></code><span class="koboSpan" id="kobo.3479.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3480.1">has_filename()</span></code><span class="koboSpan" id="kobo.3481.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3482.1">has_stem()</span></code><span class="koboSpan" id="kobo.3483.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3484.1">has_extension()</span></code><span class="koboSpan" id="kobo.3485.1"> (all of these are shown in the following example):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3486.1">auto</span></span><span class="koboSpan" id="kobo.3487.1"> path =
  fs::path{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3488.1">"C:\\Users\\Marius\\Documents\\sample.file.txt"</span></span><span class="koboSpan" id="kobo.3489.1">};
std::cout
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3490.1">"has root: "</span></span><span class="koboSpan" id="kobo.3491.1">        &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3492.1">has_root_name</span></span><span class="koboSpan" id="kobo.3493.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3494.1">'\n'</span></span><span class="koboSpan" id="kobo.3495.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3496.1">"has root dir: "</span></span><span class="koboSpan" id="kobo.3497.1">    &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3498.1">has_root_directory</span></span><span class="koboSpan" id="kobo.3499.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3500.1">'\n'</span></span><span class="koboSpan" id="kobo.3501.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3502.1">"has root path: "</span></span><span class="koboSpan" id="kobo.3503.1">   &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3504.1">has_root_path</span></span><span class="koboSpan" id="kobo.3505.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3506.1">'\n'</span></span><span class="koboSpan" id="kobo.3507.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3508.1">"has rel path: "</span></span><span class="koboSpan" id="kobo.3509.1">    &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3510.1">has_relative_path</span></span><span class="koboSpan" id="kobo.3511.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3512.1">'\n'</span></span><span class="koboSpan" id="kobo.3513.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3514.1">"has parent path: "</span></span><span class="koboSpan" id="kobo.3515.1"> &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3516.1">has_parent_path</span></span><span class="koboSpan" id="kobo.3517.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3518.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3519.1">\n'</span></span><span class="koboSpan" id="kobo.3520.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3521.1">"has filename: "</span></span><span class="koboSpan" id="kobo.3522.1">    &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3523.1">has_filename</span></span><span class="koboSpan" id="kobo.3524.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3525.1">'\n'</span></span><span class="koboSpan" id="kobo.3526.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3527.1">"has stem: "</span></span><span class="koboSpan" id="kobo.3528.1">        &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3529.1">has_stem</span></span><span class="koboSpan" id="kobo.3530.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3531.1">'\n'</span></span><span class="koboSpan" id="kobo.3532.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3533.1">"has extension: "</span></span><span class="koboSpan" id="kobo.3534.1">   &lt;&lt; path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3535.1">has_extension</span></span><span class="koboSpan" id="kobo.3536.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3537.1">'\n'</span></span><span class="koboSpan" id="kobo.3538.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3539.1">Check</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.3540.1"> whether a path is relative or absolute:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3541.1">auto</span></span><span class="koboSpan" id="kobo.3542.1"> path2 = fs::path{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3543.1">"marius\\temp"</span></span><span class="koboSpan" id="kobo.3544.1"> };
std::cout
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3545.1">"absolute: "</span></span><span class="koboSpan" id="kobo.3546.1"> &lt;&lt; path1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3547.1">is_absolute</span></span><span class="koboSpan" id="kobo.3548.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3549.1">'\n'</span></span><span class="koboSpan" id="kobo.3550.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3551.1">"absolute: "</span></span><span class="koboSpan" id="kobo.3552.1"> &lt;&lt; path2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3553.1">is_absolute</span></span><span class="koboSpan" id="kobo.3554.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3555.1">'\n'</span></span><span class="koboSpan" id="kobo.3556.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3557.1">Modify individual parts of the path, such as the filename with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3558.1">replace_filename()</span></code><span class="koboSpan" id="kobo.3559.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3560.1">remove_filename()</span></code><span class="koboSpan" id="kobo.3561.1">, and the extension with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3562.1">replace_extension()</span></code><span class="koboSpan" id="kobo.3563.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3564.1">auto</span></span><span class="koboSpan" id="kobo.3565.1"> path =
  fs::path{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3566.1">"C:\\Users\\Marius\\Documents\\sample.file.txt"</span></span><span class="koboSpan" id="kobo.3567.1">};
path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3568.1">replace_filename</span></span><span class="koboSpan" id="kobo.3569.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3570.1">"output"</span></span><span class="koboSpan" id="kobo.3571.1">);
path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3572.1">replace_extension</span></span><span class="koboSpan" id="kobo.3573.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3574.1">".log"</span></span><span class="koboSpan" id="kobo.3575.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3576.1">// path = C:\Users\Marius\Documents\output.log</span></span><span class="koboSpan" id="kobo.3577.1">
path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3578.1">remove_filename</span></span><span class="koboSpan" id="kobo.3579.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3580.1">// path = C:\Users\Marius\Documents</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3581.1">Convert the directory separator to the system-preferred separator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.3582.1">// Windows</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3583.1">auto</span></span><span class="koboSpan" id="kobo.3584.1"> path = fs::path{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3585.1">"Users/Marius/Documents"</span></span><span class="koboSpan" id="kobo.3586.1">};
path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3587.1">make_preferred</span></span><span class="koboSpan" id="kobo.3588.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3589.1">// path = Users\Marius\Documents</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3590.1">// POSIX</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3591.1">auto</span></span><span class="koboSpan" id="kobo.3592.1"> path = fs::path{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3593.1">"\\home\\marius\\docs"</span></span><span class="koboSpan" id="kobo.3594.1"> };
path.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3595.1">make_preferred</span></span><span class="koboSpan" id="kobo.3596.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3597.1">// path = /home/marius/docs</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-465"><span class="koboSpan" id="kobo.3598.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3599.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3600.1">std::filesystem::path</span></code><span class="koboSpan" id="kobo.3601.1"> class</span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.3602.1"> models paths to filesystem components. </span><span class="koboSpan" id="kobo.3602.2">However, it only handles the syntax and does not validate the existence of a component (such as a file or a directory) represented by the path.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3603.1">The library defines a portable, generic syntax for paths that can accommodate various filesystems, such as POSIX or Windows, including </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.3604.1">the Microsoft Windows </span><strong class="keyWord"><span class="koboSpan" id="kobo.3605.1">Universal Naming Convention</span></strong><span class="koboSpan" id="kobo.3606.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.3607.1">UNC</span></strong><span class="koboSpan" id="kobo.3608.1">) format. </span><span class="koboSpan" id="kobo.3608.2">Both of them differ in several key aspects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3609.1">POSIX systems have a single tree, no root name, a single root directory called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3610.1">/</span></code><span class="koboSpan" id="kobo.3611.1">, and a single current directory. </span><span class="koboSpan" id="kobo.3611.2">Additionally, they use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3612.1">/</span></code><span class="koboSpan" id="kobo.3613.1"> as the directory separator. </span><span class="koboSpan" id="kobo.3613.2">Paths are represented as null-terminated strings of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3614.1">char</span></code><span class="koboSpan" id="kobo.3615.1"> encoded as UTF-8.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3616.1">Windows systems have multiple trees, each with a root name (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3617.1">C:</span></code><span class="koboSpan" id="kobo.3618.1">), a root directory (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3619.1">\</span></code><span class="koboSpan" id="kobo.3620.1">), and a current directory (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3621.1">C:\Windows\System32</span></code><span class="koboSpan" id="kobo.3622.1">). </span><span class="koboSpan" id="kobo.3622.2">Paths are represented as null-terminated strings of wide characters encoded as UTF-16.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3623.1">You should not mix path formats across different systems. </span><span class="koboSpan" id="kobo.3623.2">Although Windows can handle POSIX paths, the other way around is not true. </span><span class="koboSpan" id="kobo.3623.3">Use the path format specific to each system. </span><span class="koboSpan" id="kobo.3623.4">Additionally, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3624.1">filesystem::path</span></code><span class="koboSpan" id="kobo.3625.1"> functionality, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3626.1">operator /=</span></code><span class="koboSpan" id="kobo.3627.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3628.1">append()</span></code><span class="koboSpan" id="kobo.3629.1"> function, as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3630.1">preferred_separator</span></code><span class="koboSpan" id="kobo.3631.1"> static member to build paths in a portable manner.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3632.1">A pathname, as defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3633.1">filesystem</span></code><span class="koboSpan" id="kobo.3634.1"> library, has the following syntax:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3635.1">An optional root name (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3636.1">C:</span></code><span class="koboSpan" id="kobo.3637.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3638.1">//localhost</span></code><span class="koboSpan" id="kobo.3639.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3640.1">An optional root directory</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3641.1">Zero or more filenames (which may refer to a file, a directory, a hard link, or a symbolic link) or directory separators</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3642.1">There are two special filenames that are recognized: the single dot (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3643.1">.</span></code><span class="koboSpan" id="kobo.3644.1">), which represents the current directory, and the double dot (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3645.1">..</span></code><span class="koboSpan" id="kobo.3646.1">), which represents the parent directory. </span><span class="koboSpan" id="kobo.3646.2">The directory separator can be repeated, in which case it is treated as a single separator (in other words, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3647.1">/home////docs</span></code><span class="koboSpan" id="kobo.3648.1"> is the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3649.1">/home/marius/docs</span></code><span class="koboSpan" id="kobo.3650.1">). </span><span class="koboSpan" id="kobo.3650.2">A path that has no redundant current directory name (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3651.1">.</span></code><span class="koboSpan" id="kobo.3652.1">), no redundant parent directory name (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3653.1">..</span></code><span class="koboSpan" id="kobo.3654.1">), and no redundant directory separators is said to be in a normal form.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3655.1">The </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.3656.1">path operations presented in the previous section are the most common operations with paths. </span><span class="koboSpan" id="kobo.3656.2">However, their implementation defines additional querying and modifying methods, iterators, non-member comparison operators, and more. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.3657.1">The following sample iterates through the parts of a path and prints them to the console:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3658.1">auto</span></span><span class="koboSpan" id="kobo.3659.1"> path =
  fs::path{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3660.1">"C:\\Users\\Marius\\Documents\\sample.file.txt"</span></span><span class="koboSpan" id="kobo.3661.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3662.1">for</span></span><span class="koboSpan" id="kobo.3663.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3664.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3665.1">const</span></span><span class="koboSpan" id="kobo.3666.1"> &amp; part : path)
{
  std::cout &lt;&lt; part &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3667.1">'\n'</span></span><span class="koboSpan" id="kobo.3668.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3669.1">The following listing represents its result:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3670.1">C:
Users
Marius
Documents
sample.file.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3671.1">In this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3672.1">sample.file.txt</span></code><span class="koboSpan" id="kobo.3673.1"> is the filename. </span><span class="koboSpan" id="kobo.3673.2">This is basically the part from the last directory separator to the end of the path. </span><span class="koboSpan" id="kobo.3673.3">This is what the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.3674.1">filename()</span></code><span class="koboSpan" id="kobo.3675.1"> would be returning for the given path. </span><span class="koboSpan" id="kobo.3675.2">The extension for this file is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3676.1">.txt</span></code><span class="koboSpan" id="kobo.3677.1">, which is the string returned by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3678.1">extension()</span></code><span class="koboSpan" id="kobo.3679.1"> member function. </span><span class="koboSpan" id="kobo.3679.2">To retrieve the filename without an extension, another member function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3680.1">stem()</span></code><span class="koboSpan" id="kobo.3681.1"> is available. </span><span class="koboSpan" id="kobo.3681.2">Here, the string returned by this method is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3682.1">sample.file</span></code><span class="koboSpan" id="kobo.3683.1">. </span><span class="koboSpan" id="kobo.3683.2">For all of these methods, but also all of the other decomposition methods, there is a corresponding querying method with the same name and the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.3684.1">has_</span></code><span class="koboSpan" id="kobo.3685.1">, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3686.1">has_filename()</span></code><span class="koboSpan" id="kobo.3687.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3688.1">has_stem()</span></code><span class="koboSpan" id="kobo.3689.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3690.1">has_extension()</span></code><span class="koboSpan" id="kobo.3691.1">. </span><span class="koboSpan" id="kobo.3691.2">All of these methods return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3692.1">bool</span></code><span class="koboSpan" id="kobo.3693.1"> value to indicate whether the path has the corresponding part.</span></p>
<h2 class="heading-2" id="_idParaDest-466"><span class="koboSpan" id="kobo.3694.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3695.1">Creating, copying, and deleting files and directories</span></em><span class="koboSpan" id="kobo.3696.1">, to learn how to perform these basic operations with files and directories independently of the filesystem in use</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3697.1">Checking the properties of an existing file or directory</span></em><span class="koboSpan" id="kobo.3698.1">, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-467"><span class="koboSpan" id="kobo.3699.1">Creating, copying, and deleting files and directories</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3700.1">Operations with files, such as copying, moving, and deleting, or with directories, such as creating, renaming, and </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.3701.1">deleting, are all supported by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3702.1">filesystem</span></code><span class="koboSpan" id="kobo.3703.1"> library. </span><span class="koboSpan" id="kobo.3703.2">Files and directories </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.3704.1">are identified using a path (which can be absolute, canonical, or relative), a topic that was covered in the previous recipes. </span><span class="koboSpan" id="kobo.3704.2">In this recipe, we will look at</span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.3705.1"> what the standard functions for the previously mentioned operations are and how they work.</span></p>
<h2 class="heading-2" id="_idParaDest-468"><span class="koboSpan" id="kobo.3706.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3707.1">Before going forward, you should read the </span><em class="italic"><span class="koboSpan" id="kobo.3708.1">Working with filesystem paths</span></em><span class="koboSpan" id="kobo.3709.1"> recipe. </span><span class="koboSpan" id="kobo.3709.2">The introductory notes from that recipe also apply here. </span><span class="koboSpan" id="kobo.3709.3">However, all of the examples in this recipe are platform-independent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3710.1">For all of the following examples, we will use the following variables and assume the current path is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3711.1">C:\Users\Marius\Documents</span></code><span class="koboSpan" id="kobo.3712.1"> on Windows and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3713.1">/home/marius/docs</span></code><span class="koboSpan" id="kobo.3714.1"> for a POSIX system:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3715.1">auto</span></span><span class="koboSpan" id="kobo.3716.1"> err = std::error_code{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3717.1">auto</span></span><span class="koboSpan" id="kobo.3718.1"> basepath = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3719.1">current_path</span></span><span class="koboSpan" id="kobo.3720.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3721.1">auto</span></span><span class="koboSpan" id="kobo.3722.1"> path = basepath / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3723.1">"temp"</span></span><span class="koboSpan" id="kobo.3724.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3725.1">auto</span></span><span class="koboSpan" id="kobo.3726.1"> filepath = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3727.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3728.1">sample.txt"</span></span><span class="koboSpan" id="kobo.3729.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3730.1">We will also assume the presence of a file called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3731.1">sample.txt</span></code><span class="koboSpan" id="kobo.3732.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3733.1">temp</span></code><span class="koboSpan" id="kobo.3734.1"> subdirectory of the current path (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3735.1">C:\Users\Marius\Documents\temp\sample.txt</span></code><span class="koboSpan" id="kobo.3736.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3737.1">/home/marius/docs/temp/sample.txt</span></code><span class="koboSpan" id="kobo.3738.1">).</span></p>
<h2 class="heading-2" id="_idParaDest-469"><span class="koboSpan" id="kobo.3739.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3740.1">Use the </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.3741.1">following </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.3742.1">library functions to perform operations </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.3743.1">with directories:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3744.1">To create a new directory, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3745.1">create_directory()</span></code><span class="koboSpan" id="kobo.3746.1">. </span><span class="koboSpan" id="kobo.3746.2">This method does nothing if the directory already exists; however, it does not create directories recursively:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3747.1">auto</span></span><span class="koboSpan" id="kobo.3748.1"> success = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3749.1">create_directory</span></span><span class="koboSpan" id="kobo.3750.1">(path, err);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3751.1">To create new directories recursively, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3752.1">create_directories()</span></code><span class="koboSpan" id="kobo.3753.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3754.1">auto</span></span><span class="koboSpan" id="kobo.3755.1"> temp = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3756.1">"tmp1"</span></span><span class="koboSpan" id="kobo.3757.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3758.1">"tmp2"</span></span><span class="koboSpan" id="kobo.3759.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3760.1">"tmp3"</span></span><span class="koboSpan" id="kobo.3761.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3762.1">auto</span></span><span class="koboSpan" id="kobo.3763.1"> success = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3764.1">create_directories</span></span><span class="koboSpan" id="kobo.3765.1">(temp, err);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3766.1">To move an existing directory, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3767.1">rename()</span></code><span class="koboSpan" id="kobo.3768.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3769.1">auto</span></span><span class="koboSpan" id="kobo.3770.1"> temp = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3771.1">"tmp1"</span></span><span class="koboSpan" id="kobo.3772.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3773.1">"tmp2"</span></span><span class="koboSpan" id="kobo.3774.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3775.1">"tmp3"</span></span><span class="koboSpan" id="kobo.3776.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3777.1">auto</span></span><span class="koboSpan" id="kobo.3778.1"> newtemp = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3779.1">"tmp1"</span></span><span class="koboSpan" id="kobo.3780.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3781.1">"tmp3"</span></span><span class="koboSpan" id="kobo.3782.1">;
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3783.1">rename</span></span><span class="koboSpan" id="kobo.3784.1">(temp, newtemp, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3785.1">if</span></span><span class="koboSpan" id="kobo.3786.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3787.1">message</span></span><span class="koboSpan" id="kobo.3788.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3789.1">'\n'</span></span><span class="koboSpan" id="kobo.3790.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3791.1">To rename an existing directory, also use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3792.1">rename()</span></code><span class="koboSpan" id="kobo.3793.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3794.1">auto</span></span><span class="koboSpan" id="kobo.3795.1"> temp = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3796.1">"tmp1"</span></span><span class="koboSpan" id="kobo.3797.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3798.1">"tmp3"</span></span><span class="koboSpan" id="kobo.3799.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3800.1">auto</span></span><span class="koboSpan" id="kobo.3801.1"> newtemp = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3802.1">"tmp1"</span></span><span class="koboSpan" id="kobo.3803.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3804.1">"tmp4"</span></span><span class="koboSpan" id="kobo.3805.1">;
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3806.1">rename</span></span><span class="koboSpan" id="kobo.3807.1">(temp, newtemp, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3808.1">if</span></span><span class="koboSpan" id="kobo.3809.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3810.1">message</span></span><span class="koboSpan" id="kobo.3811.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3812.1">'\n'</span></span><span class="koboSpan" id="kobo.3813.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3814.1">To copy an existing directory, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3815.1">copy()</span></code><span class="koboSpan" id="kobo.3816.1">. </span><span class="koboSpan" id="kobo.3816.2">To recursively copy the entire content of a directory, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3817.1">copy_options::recursive</span></code><span class="koboSpan" id="kobo.3818.1"> flag:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3819.1">fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3820.1">copy</span></span><span class="koboSpan" id="kobo.3821.1">(path, basepath / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3822.1">"temp2"</span></span><span class="koboSpan" id="kobo.3823.1">,
         fs::copy_options::recursive, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3824.1">if</span></span><span class="koboSpan" id="kobo.3825.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3826.1">message</span></span><span class="koboSpan" id="kobo.3827.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3828.1">'\n'</span></span><span class="koboSpan" id="kobo.3829.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3830.1">To create a symbolic link to a directory, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3831.1">create_directory_symlink()</span></code><span class="koboSpan" id="kobo.3832.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3833.1">auto</span></span><span class="koboSpan" id="kobo.3834.1"> linkdir = basepath / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3835.1">"templink"</span></span><span class="koboSpan" id="kobo.3836.1">;
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3837.1">create_directory_symlink</span></span><span class="koboSpan" id="kobo.3838.1">(path, linkdir, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3839.1">if</span></span><span class="koboSpan" id="kobo.3840.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3841.1">message</span></span><span class="koboSpan" id="kobo.3842.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3843.1">'\n'</span></span><span class="koboSpan" id="kobo.3844.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3845.1">To remove an empty directory, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3846.1">remove()</span></code><span class="koboSpan" id="kobo.3847.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3848.1">auto</span></span><span class="koboSpan" id="kobo.3849.1"> temp = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3850.1">"tmp1"</span></span><span class="koboSpan" id="kobo.3851.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3852.1">"tmp4"</span></span><span class="koboSpan" id="kobo.3853.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3854.1">auto</span></span><span class="koboSpan" id="kobo.3855.1"> success = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3856.1">remove</span></span><span class="koboSpan" id="kobo.3857.1">(temp, err);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3858.1">To remove the entire content of a directory recursively and the directory itself, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3859.1">remove_all()</span></code><span class="koboSpan" id="kobo.3860.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3861.1">auto</span></span><span class="koboSpan" id="kobo.3862.1"> success = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3863.1">remove_all</span></span><span class="koboSpan" id="kobo.3864.1">(path, err) !=
               </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3865.1">static_cast</span></span><span class="koboSpan" id="kobo.3866.1">&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.3867.1">uintmax_t</span></span><span class="koboSpan" id="kobo.3868.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3869.1">-1</span></span><span class="koboSpan" id="kobo.3870.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3871.1">To </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.3872.1">change </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.3873.1">permissions on a directory or a file, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3874.1">permissions()</span></code><span class="koboSpan" id="kobo.3875.1">, specifying permissions options from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3876.1">perms</span></code><span class="koboSpan" id="kobo.3877.1"> enum. </span><span class="koboSpan" id="kobo.3877.2">Unless </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.3878.1">you specify an operation type (replace, add, or remove) from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3879.1">perm_options</span></code><span class="koboSpan" id="kobo.3880.1"> enum, the default action is to replace all existing permissions with the specified ones:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.3881.1">// replace permissions with specified ones</span></span><span class="koboSpan" id="kobo.3882.1">
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3883.1">permissions</span></span><span class="koboSpan" id="kobo.3884.1">(temp, fs::perms::owner_all | 
                      fs::perms::group_all, err);
if (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3885.1">message</span></span><span class="koboSpan" id="kobo.3886.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3887.1">'\n'</span></span><span class="koboSpan" id="kobo.3888.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3889.1">// remove specified permissions</span></span><span class="koboSpan" id="kobo.3890.1">
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3891.1">permissions</span></span><span class="koboSpan" id="kobo.3892.1">(temp, fs::perms::group_exec,
                      fs::perm_options::remove, err);
if (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3893.1">message</span></span><span class="koboSpan" id="kobo.3894.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3895.1">'\n'</span></span><span class="koboSpan" id="kobo.3896.1">;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3897.1">Use the following library functions to perform operations with files:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3898.1">To copy a file, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3899.1">copy()</span></code><span class="koboSpan" id="kobo.3900.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3901.1">copy_file()</span></code><span class="koboSpan" id="kobo.3902.1">. </span><span class="koboSpan" id="kobo.3902.2">The next section explains the difference between the two:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3903.1">auto</span></span><span class="koboSpan" id="kobo.3904.1"> success = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3905.1">copy_file</span></span><span class="koboSpan" id="kobo.3906.1">(filepath, path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3907.1">"sample.bak"</span></span><span class="koboSpan" id="kobo.3908.1">, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3909.1">if</span></span><span class="koboSpan" id="kobo.3910.1"> (!success) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3911.1">message</span></span><span class="koboSpan" id="kobo.3912.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3913.1">'\n'</span></span><span class="koboSpan" id="kobo.3914.1">;
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3915.1">copy</span></span><span class="koboSpan" id="kobo.3916.1">(filepath, path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3917.1">"sample.cpy"</span></span><span class="koboSpan" id="kobo.3918.1">, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3919.1">if</span></span><span class="koboSpan" id="kobo.3920.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3921.1">message</span></span><span class="koboSpan" id="kobo.3922.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3923.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3924.1">\n'</span></span><span class="koboSpan" id="kobo.3925.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3926.1">To rename a file, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3927.1">rename()</span></code><span class="koboSpan" id="kobo.3928.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3929.1">auto</span></span><span class="koboSpan" id="kobo.3930.1"> newpath = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3931.1">"sample.log"</span></span><span class="koboSpan" id="kobo.3932.1">;
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3933.1">rename</span></span><span class="koboSpan" id="kobo.3934.1">(filepath, newpath, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3935.1">if</span></span><span class="koboSpan" id="kobo.3936.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3937.1">message</span></span><span class="koboSpan" id="kobo.3938.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3939.1">'\n'</span></span><span class="koboSpan" id="kobo.3940.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3941.1">To move a file, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3942.1">rename()</span></code><span class="koboSpan" id="kobo.3943.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3944.1">auto</span></span><span class="koboSpan" id="kobo.3945.1"> newpath = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3946.1">"sample.log"</span></span><span class="koboSpan" id="kobo.3947.1">;
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3948.1">rename</span></span><span class="koboSpan" id="kobo.3949.1">(newpath, path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3950.1">"tmp1"</span></span><span class="koboSpan" id="kobo.3951.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3952.1">"sample.log"</span></span><span class="koboSpan" id="kobo.3953.1">, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3954.1">if</span></span><span class="koboSpan" id="kobo.3955.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3956.1">message</span></span><span class="koboSpan" id="kobo.3957.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3958.1">'\n'</span></span><span class="koboSpan" id="kobo.3959.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3960.1">To </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.3961.1">create a symbolic link to a file, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3962.1">create_symlink()</span></code><span class="koboSpan" id="kobo.3963.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3964.1">auto</span></span><span class="koboSpan" id="kobo.3965.1"> linkpath = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3966.1">"sample.txt.link"</span></span><span class="koboSpan" id="kobo.3967.1">;
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3968.1">create_symlink</span></span><span class="koboSpan" id="kobo.3969.1">(filepath, linkpath, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3970.1">if</span></span><span class="koboSpan" id="kobo.3971.1"> (err) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3972.1">message</span></span><span class="koboSpan" id="kobo.3973.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3974.1">'\n'</span></span><span class="koboSpan" id="kobo.3975.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3976.1">To delete a file, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3977.1">remove()</span></code><span class="koboSpan" id="kobo.3978.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3979.1">auto</span></span><span class="koboSpan" id="kobo.3980.1"> success = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3981.1">remove</span></span><span class="koboSpan" id="kobo.3982.1">(path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.3983.1">"sample.cpy"</span></span><span class="koboSpan" id="kobo.3984.1">, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3985.1">if</span></span><span class="koboSpan" id="kobo.3986.1"> (!success) std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3987.1">message</span></span><span class="koboSpan" id="kobo.3988.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3989.1">'\n'</span></span><span class="koboSpan" id="kobo.3990.1">;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-470"><span class="koboSpan" id="kobo.3991.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3992.1">All of the</span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.3993.1"> functions mentioned in this recipe, and other similar functions</span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.3994.1"> that are not discussed here, have multiple overloads that can be grouped into two categories:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3995.1">Overloads that take, as the last argument, a reference to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3996.1">std::error_code</span></code><span class="koboSpan" id="kobo.3997.1">: these overloads do not throw an exception (they are defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3998.1">noexcept</span></code><span class="koboSpan" id="kobo.3999.1"> specification). </span><span class="koboSpan" id="kobo.3999.2">Instead, they set the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4000.1">error_code</span></code><span class="koboSpan" id="kobo.4001.1"> object to the operating system error code if an operating system error has occurred. </span><span class="koboSpan" id="kobo.4001.2">If no such error has occurred, then the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4002.1">clear()</span></code><span class="koboSpan" id="kobo.4003.1"> method on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4004.1">error_code</span></code><span class="koboSpan" id="kobo.4005.1"> object is called to reset any possible previously set code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4006.1">Overloads that do not take the last argument of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4007.1">std::error_code</span></code><span class="koboSpan" id="kobo.4008.1"> type: these overloads throw exceptions if errors occur. </span><span class="koboSpan" id="kobo.4008.2">If an operating system error occurs, they throw a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4009.1">std::filesystem::filesystem_error</span></code><span class="koboSpan" id="kobo.4010.1"> exception. </span><span class="koboSpan" id="kobo.4010.2">On the other hand, if memory allocation fails, these functions throw a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4011.1">std::bad_alloc</span></code><span class="koboSpan" id="kobo.4012.1"> exception.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4013.1">All the </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.4014.1">examples in the previous section used the overload that does not throw exceptions but, instead, sets a code when an error occurs. </span><span class="koboSpan" id="kobo.4014.2">Some</span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.4015.1"> functions return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4016.1">bool</span></code><span class="koboSpan" id="kobo.4017.1"> to indicate a success or a failure. </span><span class="koboSpan" id="kobo.4017.2">You can check whether the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4018.1">error_code</span></code><span class="koboSpan" id="kobo.4019.1"> object </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.4020.1">holds the code of an error by either checking whether the value of the error code, returned by the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.4021.1">value()</span></code><span class="koboSpan" id="kobo.4022.1">, is different from 0, or by using the conversion </span><code class="inlineCode"><span class="koboSpan" id="kobo.4023.1">operator bool</span></code><span class="koboSpan" id="kobo.4024.1">, which returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.4025.1">true</span></code><span class="koboSpan" id="kobo.4026.1"> for the same case and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4027.1">false</span></code><span class="koboSpan" id="kobo.4028.1"> otherwise. </span><span class="koboSpan" id="kobo.4028.2">To retrieve the explanatory string for the error code, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4029.1">message()</span></code><span class="koboSpan" id="kobo.4030.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4031.1">Some </span><code class="inlineCode"><span class="koboSpan" id="kobo.4032.1">filesystem</span></code><span class="koboSpan" id="kobo.4033.1"> library functions are common for both files and directories. </span><span class="koboSpan" id="kobo.4033.2">This is the case for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4034.1">rename()</span></code><span class="koboSpan" id="kobo.4035.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4036.1">remove()</span></code><span class="koboSpan" id="kobo.4037.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4038.1">copy()</span></code><span class="koboSpan" id="kobo.4039.1">. </span><span class="koboSpan" id="kobo.4039.2">The working details of each of these functions can be complex, especially in the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4040.1">copy()</span></code><span class="koboSpan" id="kobo.4041.1">, and are beyond the scope of this recipe. </span><span class="koboSpan" id="kobo.4041.2">You should refer to the reference documentation if you need to perform anything other than the simple operations covered here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4042.1">When it comes to copying files, there are two functions that can be used: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4043.1">copy()</span></code><span class="koboSpan" id="kobo.4044.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4045.1">copy_file()</span></code><span class="koboSpan" id="kobo.4046.1">. </span><span class="koboSpan" id="kobo.4046.2">These have equivalent overloads with identical signatures and, apparently, work the same way. </span><span class="koboSpan" id="kobo.4046.3">However, there is an important difference (other than the fact that </span><code class="inlineCode"><span class="koboSpan" id="kobo.4047.1">copy()</span></code><span class="koboSpan" id="kobo.4048.1"> also works for directories): </span><code class="inlineCode"><span class="koboSpan" id="kobo.4049.1">copy_file()</span></code><span class="koboSpan" id="kobo.4050.1"> follows symbolic links. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4051.1">To avoid doing that and, instead, copy the actual symbolic link, you must use either </span><code class="inlineCode"><span class="koboSpan" id="kobo.4052.1">copy_symlink()</span></code><span class="koboSpan" id="kobo.4053.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4054.1">copy()</span></code><span class="koboSpan" id="kobo.4055.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4056.1">copy_options::copy_symlinks</span></code><span class="koboSpan" id="kobo.4057.1"> flag. </span><span class="koboSpan" id="kobo.4057.2">Both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4058.1">copy()</span></code><span class="koboSpan" id="kobo.4059.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4060.1">copy_file()</span></code><span class="koboSpan" id="kobo.4061.1"> functions have an overload that takes an argument of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4062.1">std::filesystem::copy_options</span></code><span class="koboSpan" id="kobo.4063.1"> type, which defines how the operation should be performed. </span><code class="inlineCode"><span class="koboSpan" id="kobo.4064.1">copy_options</span></code><span class="koboSpan" id="kobo.4065.1"> is a scoped </span><code class="inlineCode"><span class="koboSpan" id="kobo.4066.1">enum</span></code><span class="koboSpan" id="kobo.4067.1"> with the following definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4068.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4069.1">copy_options</span></span><span class="koboSpan" id="kobo.4070.1">
{
  none               = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4071.1">0</span></span><span class="koboSpan" id="kobo.4072.1">,
  skip_existing      = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4073.1">1</span></span><span class="koboSpan" id="kobo.4074.1">,
  overwrite_existing = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4075.1">2</span></span><span class="koboSpan" id="kobo.4076.1">,
  update_existing    = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4077.1">4</span></span><span class="koboSpan" id="kobo.4078.1">,
  recursive          = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4079.1">8</span></span><span class="koboSpan" id="kobo.4080.1">,
  copy_symlinks      = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4081.1">16</span></span><span class="koboSpan" id="kobo.4082.1">,
  skip_symlinks      = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4083.1">32</span></span><span class="koboSpan" id="kobo.4084.1">,
  directories_only   = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4085.1">64</span></span><span class="koboSpan" id="kobo.4086.1">,
  create_symlinks    = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4087.1">128</span></span><span class="koboSpan" id="kobo.4088.1">,
  create_hard_links  = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4089.1">256</span></span><span class="koboSpan" id="kobo.4090.1">
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4091.1">The following table defines how each of these flags affects a copy operation, either with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4092.1">copy()</span></code><span class="koboSpan" id="kobo.4093.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4094.1">copy_file()</span></code><span class="koboSpan" id="kobo.4095.1">. </span><span class="koboSpan" id="kobo.4095.2">The table is taken</span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.4096.1"> from the 31.12.8.3 paragraph</span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.4097.1"> from</span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.4098.1"> the N4917 version of the C++ standard:</span></p>
<table class="table-container" id="table003-3">
<tbody>
<tr>
<td class="table-cell" colspan="2">
<p class="normal"><span class="koboSpan" id="kobo.4099.1">Option group controlling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4100.1">copy_file</span></code><span class="koboSpan" id="kobo.4101.1"> function effects for existing target files</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4102.1">none</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4103.1">(Default) Error; file already exists</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4104.1">skip_existing</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4105.1">Do not overwrite existing file; do not report an error</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4106.1">overwrite_existing</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4107.1">Overwrite the existing file</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4108.1">update_existing</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4109.1">Overwrite the existing file if it is older than the replacement file</span></p>
</td>
</tr>
<tr>
<td class="table-cell" colspan="2">
<p class="normal"><span class="koboSpan" id="kobo.4110.1">Option group controlling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4111.1">copy</span></code><span class="koboSpan" id="kobo.4112.1"> function effects for subdirectories</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4113.1">none</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4114.1">(Default) Do not copy subdirectories</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4115.1">recursive</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4116.1">Recursively copy subdirectories and their contents</span></p>
</td>
</tr>
<tr>
<td class="table-cell" colspan="2">
<p class="normal"><span class="koboSpan" id="kobo.4117.1">Option group controlling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4118.1">copy</span></code><span class="koboSpan" id="kobo.4119.1"> function effects for symbolic links</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4120.1">none</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4121.1">(Default) Follow symbolic links</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4122.1">copy_symlinks</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4123.1">Copy symbolic links as symbolic links rather than copying the files that they point to</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4124.1">skip_symlinks</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4125.1">Ignore symbolic links</span></p>
</td>
</tr>
<tr>
<td class="table-cell" colspan="2">
<p class="normal"><span class="koboSpan" id="kobo.4126.1">Option group controlling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4127.1">copy</span></code><span class="koboSpan" id="kobo.4128.1"> function effects for choosing the form of copying</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4129.1">none</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4130.1">(Default) Copy contents</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4131.1">directories_only</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4132.1">Copy the directory structure only; do not copy non-directory files</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4133.1">create_symlinks</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4134.1">Make symbolic links instead of copies of files; the source path will be an absolute path unless the destination path is in the current directory</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4135.1">create_hard_links</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4136.1">Make hard links instead of copies of files</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4137.1">Table 7.3: A breakdown of how copy_operation flags affect the copy operation</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4138.1">Another </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.4139.1">aspect that should be mentioned is related to symbolic links: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4140.1">create_directory_symlink()</span></code><span class="koboSpan" id="kobo.4141.1"> creates a symbolic link to a directory, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.4142.1">create_symlink()</span></code><span class="koboSpan" id="kobo.4143.1"> creates symbolic links to either files or directories. </span><span class="koboSpan" id="kobo.4143.2">On POSIX systems, the two are</span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.4144.1"> identical when it comes to directories. </span><span class="koboSpan" id="kobo.4144.2">On other systems (such as Windows), symbolic links to directories are created</span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.4145.1"> differently than symbolic links to files. </span><span class="koboSpan" id="kobo.4145.2">Therefore, it is recommended that you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4146.1">create_directory_symlink()</span></code><span class="koboSpan" id="kobo.4147.1"> for directories in order to write code that works correctly on all systems.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.4148.1">When you perform operations with files and directories, such as the ones described in this recipe, and you use the overloads that may throw exceptions, ensure that you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4149.1">try</span></code><span class="koboSpan" id="kobo.4150.1">-</span><code class="inlineCode"><span class="koboSpan" id="kobo.4151.1">catch</span></code><span class="koboSpan" id="kobo.4152.1"> on the calls. </span><span class="koboSpan" id="kobo.4152.2">Regardless of the type of overload used, you should check the success of the operation and take appropriate action in the case of a failure.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.4153.1">If you need to change permissions for a file or directory, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4154.1">permissions()</span></code><span class="koboSpan" id="kobo.4155.1"> function. </span><span class="koboSpan" id="kobo.4155.2">It has several overloads that allow you to specify a range of permission options. </span><span class="koboSpan" id="kobo.4155.3">These are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4156.1">std::filesystem::perms</span></code><span class="koboSpan" id="kobo.4157.1"> enumeration. </span><span class="koboSpan" id="kobo.4157.2">If you don’t specify a particular change operation, a complete replacement of existing permissions is performed. </span><span class="koboSpan" id="kobo.4157.3">However, you can specify to add or remove permissions using the options available from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4158.1">std::filesystem::perm_options</span></code><span class="koboSpan" id="kobo.4159.1"> enumeration. </span><span class="koboSpan" id="kobo.4159.2">Apart from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4160.1">replace</span></code><span class="koboSpan" id="kobo.4161.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4162.1">add</span></code><span class="koboSpan" id="kobo.4163.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4164.1">remove</span></code><span class="koboSpan" id="kobo.4165.1">, there is a fourth option, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4166.1">nofollow</span></code><span class="koboSpan" id="kobo.4167.1">. </span><span class="koboSpan" id="kobo.4167.2">This applies to symlinks, so that the permissions are changed on the symlink itself and not to the file it resolves to.</span></p>
<h2 class="heading-2" id="_idParaDest-471"><span class="koboSpan" id="kobo.4168.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4169.1">Working with filesystem paths</span></em><span class="koboSpan" id="kobo.4170.1">, to learn about the C++17 standard support for filesystem paths</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4171.1">Removing content from a file</span></em><span class="koboSpan" id="kobo.4172.1">, to explore the possible ways of removing parts of the content of a file</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4173.1">Checking the properties of an existing file or directory</span></em><span class="koboSpan" id="kobo.4174.1">, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-472"><span class="koboSpan" id="kobo.4175.1">Removing content from a file</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4176.1">Operations </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.4177.1">such as copying, renaming, moving, or deleting files are directly provided by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4178.1">filesystem</span></code><span class="koboSpan" id="kobo.4179.1"> library. </span><span class="koboSpan" id="kobo.4179.2">However, when it comes to removing content from a file, you must perform explicit actions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4180.1">Regardless of whether you need to do this for text or binary files, you could implement the following pattern:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.4181.1">Create a temporary file.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.4182.1">Copy only the content that you want from the original file to the temporary file.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.4183.1">Delete the original file.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.4184.1">Rename/move the temporary file to the name/location of the original file.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.4185.1">In this recipe, we will learn how to implement this pattern for a text file.</span></p>
<h2 class="heading-2" id="_idParaDest-473"><span class="koboSpan" id="kobo.4186.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4187.1">For the purpose of this recipe, we will consider removing empty lines, or lines that start with a semicolon (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4188.1">;</span></code><span class="koboSpan" id="kobo.4189.1">), from a text file. </span><span class="koboSpan" id="kobo.4189.2">For this example, we will have an initial file, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4190.1">sample.dat</span></code><span class="koboSpan" id="kobo.4191.1">, that contains the names of Shakespeare’s plays, but also empty lines and lines that start with a semicolon. </span><span class="koboSpan" id="kobo.4191.2">The following is a partial listing of this file (from the beginning):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4192.1">;Shakespeare</span><span class="hljs-number"><span class="koboSpan" id="kobo.4193.1">'</span></span><span class="koboSpan" id="kobo.4194.1">s plays, listed by genre
;TRAGEDIES
Troilus </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4195.1">and</span></span><span class="koboSpan" id="kobo.4196.1"> Cressida
Coriolanus
Titus Andronicus
Romeo </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4197.1">and</span></span><span class="koboSpan" id="kobo.4198.1"> Juliet
Timon of Athens
Julius Caesar
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4199.1">The code</span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.4200.1"> samples listed in the next section use the following variables:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4201.1">auto</span></span><span class="koboSpan" id="kobo.4202.1"> path = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4203.1">current_path</span></span><span class="koboSpan" id="kobo.4204.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4205.1">auto</span></span><span class="koboSpan" id="kobo.4206.1"> filepath = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.4207.1">"sample.dat"</span></span><span class="koboSpan" id="kobo.4208.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4209.1">auto</span></span><span class="koboSpan" id="kobo.4210.1"> temppath = path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.4211.1">"sample.tmp"</span></span><span class="koboSpan" id="kobo.4212.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4213.1">auto</span></span><span class="koboSpan" id="kobo.4214.1"> err = std::error_code{};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4215.1">We will learn how to put this pattern into code in the following section.</span></p>
<h2 class="heading-2" id="_idParaDest-474"><span class="koboSpan" id="kobo.4216.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4217.1">Perform the following operations to remove content from a file:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.4218.1">Open the file for reading:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4219.1">std::ifstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4220.1">in</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4221.1">(filepath)</span></span><span class="koboSpan" id="kobo.4222.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4223.1">if</span></span><span class="koboSpan" id="kobo.4224.1"> (!in.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4225.1">is_open</span></span><span class="koboSpan" id="kobo.4226.1">())
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4227.1">"File could not be opened!"</span></span><span class="koboSpan" id="kobo.4228.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4229.1">'\n'</span></span><span class="koboSpan" id="kobo.4230.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4231.1">return</span></span><span class="koboSpan" id="kobo.4232.1">;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4233.1">Open another temporary file for writing; if the file already exists, truncate its content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4234.1">std::ofstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4235.1">out</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4236.1">(temppath, std::ios::trunc)</span></span><span class="koboSpan" id="kobo.4237.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4238.1">if</span></span><span class="koboSpan" id="kobo.4239.1"> (!out.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4240.1">is_open</span></span><span class="koboSpan" id="kobo.4241.1">())
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4242.1">"Temporary file could not be created!"</span></span><span class="koboSpan" id="kobo.4243.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4244.1">'\n'</span></span><span class="koboSpan" id="kobo.4245.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4246.1">return</span></span><span class="koboSpan" id="kobo.4247.1">;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4248.1">Read, line by line, from the input file and copy the selected content to the output file:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4249.1">auto</span></span><span class="koboSpan" id="kobo.4250.1"> line = std::string{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4251.1">while</span></span><span class="koboSpan" id="kobo.4252.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4253.1">getline</span></span><span class="koboSpan" id="kobo.4254.1">(in, line))
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4255.1">if</span></span><span class="koboSpan" id="kobo.4256.1"> (!line.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4257.1">empty</span></span><span class="koboSpan" id="kobo.4258.1">() &amp;&amp; line.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4259.1">at</span></span><span class="koboSpan" id="kobo.4260.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4261.1">0</span></span><span class="koboSpan" id="kobo.4262.1">) != </span><span class="hljs-string"><span class="koboSpan" id="kobo.4263.1">';'</span></span><span class="koboSpan" id="kobo.4264.1">)
  {
    out &lt;&lt; line &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4265.1">'n'</span></span><span class="koboSpan" id="kobo.4266.1">;
  }
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4267.1">Close </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.4268.1">both the input and output files:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4269.1">in.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4270.1">close</span></span><span class="koboSpan" id="kobo.4271.1">();
out.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4272.1">close</span></span><span class="koboSpan" id="kobo.4273.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4274.1">Delete the original file:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4275.1">auto</span></span><span class="koboSpan" id="kobo.4276.1"> success = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4277.1">remove</span></span><span class="koboSpan" id="kobo.4278.1">(filepath, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4279.1">if</span></span><span class="koboSpan" id="kobo.4280.1">(!success || err)
{
  std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4281.1">message</span></span><span class="koboSpan" id="kobo.4282.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4283.1">'\n'</span></span><span class="koboSpan" id="kobo.4284.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4285.1">return</span></span><span class="koboSpan" id="kobo.4286.1">;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4287.1">Rename/move the temporary file to the name/location of the original file:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4288.1">fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4289.1">rename</span></span><span class="koboSpan" id="kobo.4290.1">(temppath, filepath, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4291.1">if</span></span><span class="koboSpan" id="kobo.4292.1"> (err)
{
  std::cout &lt;&lt; err.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4293.1">message</span></span><span class="koboSpan" id="kobo.4294.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4295.1">'\n'</span></span><span class="koboSpan" id="kobo.4296.1">;
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-475"><span class="koboSpan" id="kobo.4297.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4298.1">The pattern described here is the same for binary files too; however, to keep this short, we are only discussing an example with text files. </span><span class="koboSpan" id="kobo.4298.2">The temporary file in this example is in the same directory as the original file. </span><span class="koboSpan" id="kobo.4298.3">Alternatively, this can be located in a separate directory, such as a user temporary directory. </span><span class="koboSpan" id="kobo.4298.4">To get a path to a temporary directory, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4299.1">std::filesystem::temp_directory_path()</span></code><span class="koboSpan" id="kobo.4300.1">. </span><span class="koboSpan" id="kobo.4300.2">On Windows systems, this function returns the same directory as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4301.1">GetTempPath()</span></code><span class="koboSpan" id="kobo.4302.1">. </span><span class="koboSpan" id="kobo.4302.2">On POSIX systems, it returns the path specified in one of the environment variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.4303.1">TMPDIR</span></code><span class="koboSpan" id="kobo.4304.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4305.1">TMP</span></code><span class="koboSpan" id="kobo.4306.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4307.1">TEMP</span></code><span class="koboSpan" id="kobo.4308.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4309.1">TEMPDIR</span></code><span class="koboSpan" id="kobo.4310.1">, or, if none of them are available, it returns the path </span><code class="inlineCode"><span class="koboSpan" id="kobo.4311.1">/tmp</span></code><span class="koboSpan" id="kobo.4312.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4313.1">How content from the original file is copied to the temporary file varies from one case to another, depending on what needs to be copied. </span><span class="koboSpan" id="kobo.4313.2">In the preceding example, we have copied entire lines, unless they are empty or start with a semicolon. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4314.1">For this purpose, we read the content</span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.4315.1"> of the original file, line by line, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4316.1">std::getline()</span></code><span class="koboSpan" id="kobo.4317.1">, until there are no more lines to read. </span><span class="koboSpan" id="kobo.4317.2">After all the necessary content has been copied, the files should be closed so they can be moved or deleted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4318.1">To complete the operation, there are three options:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4319.1">Delete the original file and rename the temporary file to the same name as the original one if they are in the same directory, or move the temporary file to the original file location if they are in different directories. </span><span class="koboSpan" id="kobo.4319.2">This is the approach taken in this recipe. </span><span class="koboSpan" id="kobo.4319.3">For this, we used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4320.1">remove()</span></code><span class="koboSpan" id="kobo.4321.1"> function to delete the original file and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4322.1">rename()</span></code><span class="koboSpan" id="kobo.4323.1"> to rename the temporary file to the original filename.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4324.1">Copy the content of the temporary file to the original file (for this, you can use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4325.1">copy()</span></code><span class="koboSpan" id="kobo.4326.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4327.1">copy_file()</span></code><span class="koboSpan" id="kobo.4328.1"> functions) and then delete the temporary file (use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4329.1">remove()</span></code><span class="koboSpan" id="kobo.4330.1"> for this).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4331.1">Rename the original file (for instance, changing the extension or the name) and then use the original filename to rename/move the temporary file.</span></li>
</ul>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.4332.1">If you take the first approach mentioned here, then you must make sure that the temporary file that is later replacing the original file has the same file permissions as the original file; otherwise, depending on the context of your solution, it can lead to problems.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-476"><span class="koboSpan" id="kobo.4333.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4334.1">Creating, copying, and deleting files and directories</span></em><span class="koboSpan" id="kobo.4335.1">, to learn how to perform these basic operations with files and directories independently of the filesystem in use</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-477"><span class="koboSpan" id="kobo.4336.1">Checking the properties of an existing file or directory</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4337.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4338.1">filesystem</span></code><span class="koboSpan" id="kobo.4339.1"> library </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.4340.1">provides functions and types that enable developers to check for the existence of a filesystem object, such as a file or directory, its properties, such as the type (the file, directory, symbolic link, and more), the last write time, permissions, and more. </span><span class="koboSpan" id="kobo.4340.2">In this recipe, we will look at what these types and functions are and how they can be used.</span></p>
<h2 class="heading-2" id="_idParaDest-478"><span class="koboSpan" id="kobo.4341.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4342.1">For the</span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.4343.1"> following code samples, we will use the namespace alias </span><code class="inlineCode"><span class="koboSpan" id="kobo.4344.1">fs</span></code><span class="koboSpan" id="kobo.4345.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4346.1">std::filesystem</span></code><span class="koboSpan" id="kobo.4347.1"> namespace. </span><span class="koboSpan" id="kobo.4347.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4348.1">filesystem</span></code><span class="koboSpan" id="kobo.4349.1"> library is available in the header with the same name, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4350.1">&lt;filesystem&gt;</span></code><span class="koboSpan" id="kobo.4351.1">. </span><span class="koboSpan" id="kobo.4351.2">Also, we will use the variables shown here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4352.1">path</span></code><span class="koboSpan" id="kobo.4353.1"> for the path of a file, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4354.1">err</span></code><span class="koboSpan" id="kobo.4355.1"> for receiving potential operating system error codes from the filesystem APIs:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4356.1">auto</span></span><span class="koboSpan" id="kobo.4357.1"> path = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4358.1">current_path</span></span><span class="koboSpan" id="kobo.4359.1">() / </span><span class="hljs-string"><span class="koboSpan" id="kobo.4360.1">"main.cpp"</span></span><span class="koboSpan" id="kobo.4361.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4362.1">auto</span></span><span class="koboSpan" id="kobo.4363.1"> err = std::error_code{};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4364.1">Also, the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.4365.1">to_time_t</span></code><span class="koboSpan" id="kobo.4366.1"> shown here will be referred to in this recipe:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4367.1">template</span></span><span class="koboSpan" id="kobo.4368.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4369.1">typename</span></span><span class="koboSpan" id="kobo.4370.1"> TP&gt;
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.4371.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4372.1">time_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4373.1">to_time_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4374.1">(TP tp)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4375.1">{
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4376.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4377.1">namespace</span></span><span class="koboSpan" id="kobo.4378.1"> std::chrono;
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4379.1">auto</span></span><span class="koboSpan" id="kobo.4380.1"> sctp = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4381.1">time_point_cast</span></span><span class="koboSpan" id="kobo.4382.1">&lt;system_clock::duration&gt;(
       tp - TP::clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4383.1">now</span></span><span class="koboSpan" id="kobo.4384.1">() + system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4385.1">now</span></span><span class="koboSpan" id="kobo.4386.1">());
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4387.1">return</span></span><span class="koboSpan" id="kobo.4388.1"> system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4389.1">to_time_t</span></span><span class="koboSpan" id="kobo.4390.1">(sctp);
  }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4391.1">Before continuing with this recipe, you should read the </span><em class="italic"><span class="koboSpan" id="kobo.4392.1">Working with filesystem paths</span></em><span class="koboSpan" id="kobo.4393.1"> recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-479"><span class="koboSpan" id="kobo.4394.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4395.1">Use the following library functions to retrieve information about filesystem objects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4396.1">To check whether a path refers to an existing filesystem object, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4397.1">exists()</span></code><span class="koboSpan" id="kobo.4398.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4399.1">auto</span></span><span class="koboSpan" id="kobo.4400.1"> exists = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4401.1">exists</span></span><span class="koboSpan" id="kobo.4402.1">(path, err);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4403.1">"file exists: "</span></span><span class="koboSpan" id="kobo.4404.1"> &lt;&lt; std::boolalpha
          &lt;&lt; exists &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4405.1">'\n'</span></span><span class="koboSpan" id="kobo.4406.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4407.1">To check whether two different paths refer to the same filesystem object, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4408.1">equivalent()</span></code><span class="koboSpan" id="kobo.4409.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4410.1">auto</span></span><span class="koboSpan" id="kobo.4411.1"> same = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4412.1">equivalent</span></span><span class="koboSpan" id="kobo.4413.1">(path,
               fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4414.1">current_path</span></span><span class="koboSpan" id="kobo.4415.1">() / </span><span class="hljs-string"><span class="koboSpan" id="kobo.4416.1">"."</span></span><span class="koboSpan" id="kobo.4417.1"> / </span><span class="hljs-string"><span class="koboSpan" id="kobo.4418.1">"main.cpp"</span></span><span class="koboSpan" id="kobo.4419.1">, err);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4420.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4421.1">equivalent: "</span></span><span class="koboSpan" id="kobo.4422.1"> &lt;&lt; same &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4423.1">'\n'</span></span><span class="koboSpan" id="kobo.4424.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4425.1">To retrieve the size of a file in bytes, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4426.1">file_size()</span></code><span class="koboSpan" id="kobo.4427.1">. </span><span class="koboSpan" id="kobo.4427.2">This does not require the file to be opened, so it should be preferred over the approach of opening the file and then using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4428.1">seekg()</span></code><span class="koboSpan" id="kobo.4429.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.4430.1">tellg()</span></code><span class="koboSpan" id="kobo.4431.1"> functions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4432.1">auto</span></span><span class="koboSpan" id="kobo.4433.1"> size = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4434.1">file_size</span></span><span class="koboSpan" id="kobo.4435.1">(path, err);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4436.1">"file size: "</span></span><span class="koboSpan" id="kobo.4437.1"> &lt;&lt; size &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4438.1">'\n'</span></span><span class="koboSpan" id="kobo.4439.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4440.1">To </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.4441.1">retrieve the count of hard links to a filesystem object, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4442.1">hard_link_count()</span></code><span class="koboSpan" id="kobo.4443.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4444.1">auto</span></span><span class="koboSpan" id="kobo.4445.1"> links = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4446.1">hard_link_count</span></span><span class="koboSpan" id="kobo.4447.1">(path, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4448.1">if</span></span><span class="koboSpan" id="kobo.4449.1">(links != </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4450.1">static_cast</span></span><span class="koboSpan" id="kobo.4451.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4452.1">uintmax_t</span></span><span class="koboSpan" id="kobo.4453.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4454.1">-1</span></span><span class="koboSpan" id="kobo.4455.1">))
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4456.1">"hard links: "</span></span><span class="koboSpan" id="kobo.4457.1"> &lt;&lt; links &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4458.1">'\n'</span></span><span class="koboSpan" id="kobo.4459.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4460.1">else</span></span><span class="koboSpan" id="kobo.4461.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4462.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4463.1">hard links: error"</span></span><span class="koboSpan" id="kobo.4464.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4465.1">'\n'</span></span><span class="koboSpan" id="kobo.4466.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4467.1">To retrieve or set the last modification time for a filesystem object, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4468.1">last_write_time()</span></code><span class="koboSpan" id="kobo.4469.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4470.1">auto</span></span><span class="koboSpan" id="kobo.4471.1"> lwt = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4472.1">last_write_time</span></span><span class="koboSpan" id="kobo.4473.1">(path, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4474.1">auto</span></span><span class="koboSpan" id="kobo.4475.1"> time = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4476.1">to_time_t</span></span><span class="koboSpan" id="kobo.4477.1">(lwt);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4478.1">auto</span></span><span class="koboSpan" id="kobo.4479.1"> localtime = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4480.1">localtime</span></span><span class="koboSpan" id="kobo.4481.1">(&amp;time);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4482.1">"last write time: "</span></span><span class="koboSpan" id="kobo.4483.1">
          &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4484.1">put_time</span></span><span class="koboSpan" id="kobo.4485.1">(localtime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4486.1">"%c"</span></span><span class="koboSpan" id="kobo.4487.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4488.1">'\n'</span></span><span class="koboSpan" id="kobo.4489.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4490.1">To retrieve the file attributes, such as the type and permissions (as if returned by the POSIX </span><code class="inlineCode"><span class="koboSpan" id="kobo.4491.1">stat</span></code><span class="koboSpan" id="kobo.4492.1"> function), use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4493.1">status()</span></code><span class="koboSpan" id="kobo.4494.1"> function. </span><span class="koboSpan" id="kobo.4494.2">This function follows symbolic links. </span><span class="koboSpan" id="kobo.4494.3">To retrieve the file attributes of a symbolic link without following it, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4495.1">symlink_status()</span></code><span class="koboSpan" id="kobo.4496.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4497.1">auto</span></span><span class="koboSpan" id="kobo.4498.1"> print_perm = [](fs::perms p)
{
  std::cout
    &lt;&lt; ((p &amp; fs::perms::owner_read) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4499.1">"r"</span></span><span class="koboSpan" id="kobo.4500.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4501.1">"-"</span></span><span class="koboSpan" id="kobo.4502.1">)
    &lt;&lt; ((p &amp; fs::perms::owner_write) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4503.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4504.1">w"</span></span><span class="koboSpan" id="kobo.4505.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4506.1">"-"</span></span><span class="koboSpan" id="kobo.4507.1">)
    &lt;&lt; ((p &amp; fs::perms::owner_exec) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4508.1">"x"</span></span><span class="koboSpan" id="kobo.4509.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4510.1">"-"</span></span><span class="koboSpan" id="kobo.4511.1">)
    &lt;&lt; ((p &amp; fs::perms::group_read) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4512.1">"r"</span></span><span class="koboSpan" id="kobo.4513.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4514.1">"-"</span></span><span class="koboSpan" id="kobo.4515.1">)
    &lt;&lt; ((p &amp; fs::perms::group_write) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4516.1">"w"</span></span><span class="koboSpan" id="kobo.4517.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4518.1">"-"</span></span><span class="koboSpan" id="kobo.4519.1">)
    &lt;&lt; ((p &amp; fs::perms::group_exec) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4520.1">"x"</span></span><span class="koboSpan" id="kobo.4521.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4522.1">"-"</span></span><span class="koboSpan" id="kobo.4523.1">)
    &lt;&lt; ((p &amp; fs::perms::others_read) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4524.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4525.1">r"</span></span><span class="koboSpan" id="kobo.4526.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4527.1">"-"</span></span><span class="koboSpan" id="kobo.4528.1">)
    &lt;&lt; ((p &amp; fs::perms::others_write) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4529.1">"w"</span></span><span class="koboSpan" id="kobo.4530.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4531.1">"-"</span></span><span class="koboSpan" id="kobo.4532.1">)
    &lt;&lt; ((p &amp; fs::perms::others_exec) != fs::perms::none ?
       </span><span class="hljs-string"><span class="koboSpan" id="kobo.4533.1">"x"</span></span><span class="koboSpan" id="kobo.4534.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.4535.1">"-"</span></span><span class="koboSpan" id="kobo.4536.1">)
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4537.1">'\n'</span></span><span class="koboSpan" id="kobo.4538.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4539.1">auto</span></span><span class="koboSpan" id="kobo.4540.1"> status = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4541.1">status</span></span><span class="koboSpan" id="kobo.4542.1">(path, err);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4543.1">"type: "</span></span><span class="koboSpan" id="kobo.4544.1"> &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4545.1">static_cast</span></span><span class="koboSpan" id="kobo.4546.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4547.1">int</span></span><span class="koboSpan" id="kobo.4548.1">&gt;(status.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4549.1">type</span></span><span class="koboSpan" id="kobo.4550.1">()) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4551.1">'\n'</span></span><span class="koboSpan" id="kobo.4552.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4553.1">"permissions: "</span></span><span class="koboSpan" id="kobo.4554.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4555.1">print_perm</span></span><span class="koboSpan" id="kobo.4556.1">(status.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4557.1">permissions</span></span><span class="koboSpan" id="kobo.4558.1">());
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4559.1">To </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.4560.1">check whether a path refers to a particular type of filesystem object, such as a file, directory, symbolic link, and so on, use the functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.4561.1">is_regular_file()</span></code><span class="koboSpan" id="kobo.4562.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4563.1">is_directory()</span></code><span class="koboSpan" id="kobo.4564.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4565.1">is_symlink()</span></code><span class="koboSpan" id="kobo.4566.1">, and so on:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4567.1">std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4568.1">"regular file? </span><span class="koboSpan" id="kobo.4568.2">"</span></span><span class="koboSpan" id="kobo.4569.1"> &lt;&lt;
          fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4570.1">is_regular_file</span></span><span class="koboSpan" id="kobo.4571.1">(path, err) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4572.1">'\n'</span></span><span class="koboSpan" id="kobo.4573.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4574.1">"directory? </span><span class="koboSpan" id="kobo.4574.2">"</span></span><span class="koboSpan" id="kobo.4575.1"> &lt;&lt;
          fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4576.1">is_directory</span></span><span class="koboSpan" id="kobo.4577.1">(path, err) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4578.1">'\n'</span></span><span class="koboSpan" id="kobo.4579.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4580.1">"char file? </span><span class="koboSpan" id="kobo.4580.2">"</span></span><span class="koboSpan" id="kobo.4581.1"> &lt;&lt;
          fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4582.1">is_character_file</span></span><span class="koboSpan" id="kobo.4583.1">(path, err) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4584.1">'\n'</span></span><span class="koboSpan" id="kobo.4585.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4586.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4587.1">symlink? </span><span class="koboSpan" id="kobo.4587.2">"</span></span><span class="koboSpan" id="kobo.4588.1"> &lt;&lt;
          fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4589.1">is_symlink</span></span><span class="koboSpan" id="kobo.4590.1">(path, err) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4591.1">'\n'</span></span><span class="koboSpan" id="kobo.4592.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4593.1">To check whether a file or directory is empty, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4594.1">is_empty()</span></code><span class="koboSpan" id="kobo.4595.1"> function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4596.1">bool</span></span><span class="koboSpan" id="kobo.4597.1"> empty = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4598.1">is_empty</span></span><span class="koboSpan" id="kobo.4599.1">(path, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4600.1">if</span></span><span class="koboSpan" id="kobo.4601.1"> (!err)
{
   std::cout &lt;&lt; std::boolalpha
             &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4602.1">"is_empty(): "</span></span><span class="koboSpan" id="kobo.4603.1"> &lt;&lt; empty &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4604.1">'\n'</span></span><span class="koboSpan" id="kobo.4605.1">;
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-480"><span class="koboSpan" id="kobo.4606.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4607.1">These</span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.4608.1"> functions (used to retrieve information about the filesystem files and directories) are, in general, simple and straightforward. </span><span class="koboSpan" id="kobo.4608.2">However, some considerations are necessary:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4609.1">Checking whether a filesystem object exists can be done using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4610.1">exists()</span></code><span class="koboSpan" id="kobo.4611.1">, either by passing the path or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4612.1">std::filesystem::file_status</span></code><span class="koboSpan" id="kobo.4613.1"> object that was previously retrieved using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4614.1">status()</span></code><span class="koboSpan" id="kobo.4615.1"> function.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4616.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4617.1">equivalent()</span></code><span class="koboSpan" id="kobo.4618.1"> function determines whether two filesystem objects have the same status, as retrieved by the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.4619.1">status()</span></code><span class="koboSpan" id="kobo.4620.1">. </span><span class="koboSpan" id="kobo.4620.2">If neither path exists, or if both exist but neither is a file, directory, or symbolic link, then the function returns an error. </span><span class="koboSpan" id="kobo.4620.3">Hard links to the same file object are equivalent. </span><span class="koboSpan" id="kobo.4620.4">A symbolic link and its target are also equivalent.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4621.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4622.1">file_size()</span></code><span class="koboSpan" id="kobo.4623.1"> function can only be used to determine the size of regular files and symbolic links that target a regular file. </span><span class="koboSpan" id="kobo.4623.2">For any other types of file objects, such as directories, this function fails. </span><span class="koboSpan" id="kobo.4623.3">This function returns the size of the file in bytes, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4624.1">-1</span></code><span class="koboSpan" id="kobo.4625.1"> if an error has occurred. </span><span class="koboSpan" id="kobo.4625.2">If you want to determine whether a file is empty, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4626.1">is_empty()</span></code><span class="koboSpan" id="kobo.4627.1"> function. </span><span class="koboSpan" id="kobo.4627.2">This works for all types of filesystem objects, including directories.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4628.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4629.1">last_write_time()</span></code><span class="koboSpan" id="kobo.4630.1"> function has two sets of overloads: one that is used to retrieve the last modification time of the filesystem object and one that is used to set the last modification time. </span><span class="koboSpan" id="kobo.4630.2">Time is indicated by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4631.1">std::filesystem::file_time_type</span></code><span class="koboSpan" id="kobo.4632.1"> object, which is basically a type alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4633.1">std::chrono::time_point</span></code><span class="koboSpan" id="kobo.4634.1">. </span><span class="koboSpan" id="kobo.4634.2">The following example changes the last write time for a file to 30 minutes earlier than its previous value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4635.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4636.1">namespace</span></span><span class="koboSpan" id="kobo.4637.1"> std::chrono_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4638.1">auto</span></span><span class="koboSpan" id="kobo.4639.1"> lwt = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4640.1">last_write_time</span></span><span class="koboSpan" id="kobo.4641.1">(path, err);
fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4642.1">last_write_time</span></span><span class="koboSpan" id="kobo.4643.1">(path, lwt - </span><span class="hljs-number"><span class="koboSpan" id="kobo.4644.1">30</span></span><span class="koboSpan" id="kobo.4645.1">min);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4646.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4647.1">status()</span></code><span class="koboSpan" id="kobo.4648.1"> function determines the type and permissions of a filesystem object. </span><span class="koboSpan" id="kobo.4648.2">If the file is a symbolic link, the information returned is about the target of the symbolic link. </span><span class="koboSpan" id="kobo.4648.3">To retrieve information about the symbolic link itself, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4649.1">symlink_status()</span></code><span class="koboSpan" id="kobo.4650.1"> function must be used. </span><span class="koboSpan" id="kobo.4650.2">These functions return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4651.1">std::filesystem::file_status</span></code><span class="koboSpan" id="kobo.4652.1"> object. 
    </span><p class="bulletList"><span class="koboSpan" id="kobo.4653.1">This class has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4654.1">type()</span></code><span class="koboSpan" id="kobo.4655.1"> member function to retrieve the file type, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4656.1">permissions()</span></code><span class="koboSpan" id="kobo.4657.1"> member function to retrieve the file permissions. </span><span class="koboSpan" id="kobo.4657.2">The type of a file is defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4658.1">std::filesystem::file_type</span></code><span class="koboSpan" id="kobo.4659.1"> enumeration. </span><span class="koboSpan" id="kobo.4659.2">Permissions of a file are defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4660.1">std::filesystem::perms</span></code><span class="koboSpan" id="kobo.4661.1"> enumeration. </span><span class="koboSpan" id="kobo.4661.2">Not all the enumerators of this enumeration represent permissions; some of them represent controlling bits, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4662.1">add_perms</span></code><span class="koboSpan" id="kobo.4663.1">, to indicate that permissions should </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.4664.1">be added, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4665.1">remove_perms</span></code><span class="koboSpan" id="kobo.4666.1">, to indicate that permissions should be removed. </span><span class="koboSpan" id="kobo.4666.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4667.1">permissions()</span></code><span class="koboSpan" id="kobo.4668.1"> function can be used to modify the permissions of a file or a directory. </span><span class="koboSpan" id="kobo.4668.2">The following example adds all permissions to the owner and user group of a file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4669.1">fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4670.1">permissions</span></span><span class="koboSpan" id="kobo.4671.1">(
  path,
  fs::perms::add_perms |
  fs::perms::owner_all | fs::perms::group_all,
  err);
</span></code></pre></li>
</ul>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4672.1">To determine the type of a filesystem object, such as a file, directory, or symbolic link, there are two options available: retrieve the file status and then check the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4673.1">type</span></code><span class="koboSpan" id="kobo.4674.1"> property, or use one of the available filesystem functions, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4675.1">is_regular_file()</span></code><span class="koboSpan" id="kobo.4676.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4677.1">is_symlink()</span></code><span class="koboSpan" id="kobo.4678.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4679.1">is_directory()</span></code><span class="koboSpan" id="kobo.4680.1">. </span><span class="koboSpan" id="kobo.4680.2">The following examples that check whether a path refers to a regular file are equivalent:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4681.1">auto</span></span><span class="koboSpan" id="kobo.4682.1"> s = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4683.1">status</span></span><span class="koboSpan" id="kobo.4684.1">(path, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4685.1">auto</span></span><span class="koboSpan" id="kobo.4686.1"> isfile = s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4687.1">type</span></span><span class="koboSpan" id="kobo.4688.1">() == std::filesystem::file_type::regular;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4689.1">auto</span></span><span class="koboSpan" id="kobo.4690.1"> isfile = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4691.1">is_regular_file</span></span><span class="koboSpan" id="kobo.4692.1">(path, err);
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4693.1">All of the functions discussed in this recipe have an overload that throws exceptions if an error occurs, and an overload that does not throw but returns an error code via a function parameter. </span><span class="koboSpan" id="kobo.4693.2">All of the examples in this recipe used this approach. </span><span class="koboSpan" id="kobo.4693.3">More information about these sets of overloads can be found in the </span><em class="italic"><span class="koboSpan" id="kobo.4694.1">Creating, copying, and deleting files and directories</span></em><span class="koboSpan" id="kobo.4695.1"> recipe. </span><span class="koboSpan" id="kobo.4695.2">Although the snippets in this recipe don’t show it (for simplicity), it’s important that you check the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4696.1">error_code</span></code><span class="koboSpan" id="kobo.4697.1"> value returned by these functions. </span><span class="koboSpan" id="kobo.4697.2">The actual meaning of each value it holds depends on the call that returned it and the value category (such as system, I/O streams, or generic) it belongs to. </span><span class="koboSpan" id="kobo.4697.3">However, the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.4698.1">0</span></code><span class="koboSpan" id="kobo.4699.1"> is considered to indicate success in all value categories. </span><span class="koboSpan" id="kobo.4699.2">Therefore, you can check for success as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4700.1">auto</span></span><span class="koboSpan" id="kobo.4701.1"> lwt = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4702.1">last_write_time</span></span><span class="koboSpan" id="kobo.4703.1">(path, err);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4704.1">if</span></span><span class="koboSpan" id="kobo.4705.1"> (!err) </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4706.1">// success</span></span><span class="koboSpan" id="kobo.4707.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4708.1">auto</span></span><span class="koboSpan" id="kobo.4709.1"> time = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4710.1">to_time_t</span></span><span class="koboSpan" id="kobo.4711.1">(lwt);
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4712.1">auto</span></span><span class="koboSpan" id="kobo.4713.1"> localtime = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4714.1">localtime</span></span><span class="koboSpan" id="kobo.4715.1">(&amp;time);
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4716.1">"last write time: "</span></span><span class="koboSpan" id="kobo.4717.1">
             &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4718.1">put_time</span></span><span class="koboSpan" id="kobo.4719.1">(localtime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4720.1">"%c"</span></span><span class="koboSpan" id="kobo.4721.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4722.1">'\n'</span></span><span class="koboSpan" id="kobo.4723.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4724.1">If you </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.4725.1">use the overloads that don’t return an error code but throw an exception, then you need to catch that possible exception. </span><span class="koboSpan" id="kobo.4725.2">Here is an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4726.1">try</span></span><span class="koboSpan" id="kobo.4727.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4728.1">auto</span></span><span class="koboSpan" id="kobo.4729.1"> exists = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4730.1">exists</span></span><span class="koboSpan" id="kobo.4731.1">(path);
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4732.1">"file exists: "</span></span><span class="koboSpan" id="kobo.4733.1"> &lt;&lt; std::boolalpha &lt;&lt; exists &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4734.1">'\n'</span></span><span class="koboSpan" id="kobo.4735.1">;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4736.1">catch</span></span><span class="koboSpan" id="kobo.4737.1"> (std::filesystem::filesystem_error </span><span class="hljs-type"><span class="koboSpan" id="kobo.4738.1">const</span></span><span class="koboSpan" id="kobo.4739.1">&amp; ex)
{
   std::cerr &lt;&lt; ex.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4740.1">what</span></span><span class="koboSpan" id="kobo.4741.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4742.1">'\n'</span></span><span class="koboSpan" id="kobo.4743.1">;
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-481"><span class="koboSpan" id="kobo.4744.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4745.1">Working with filesystem paths</span></em><span class="koboSpan" id="kobo.4746.1">, to learn about the C++17-standard support for filesystem paths</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4747.1">Creating, copying, and deleting files and directories</span></em><span class="koboSpan" id="kobo.4748.1">, to learn how to perform these basic operations with files and directories independently of the filesystem in use</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4749.1">Enumerating the content of a directory</span></em><span class="koboSpan" id="kobo.4750.1">, to learn how to iterate through the files and subdirectories of a directory</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-482"><span class="koboSpan" id="kobo.4751.1">Enumerating the content of a directory</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4752.1">So far in this chapter, we </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.4753.1">have looked at many of the functionalities provided by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4754.1">filesystem</span></code><span class="koboSpan" id="kobo.4755.1"> library, such as working with paths, performing operations with files and directories (creating, moving, renaming, deleting, and so on), and querying or modifying properties. </span><span class="koboSpan" id="kobo.4755.2">Another useful functionality when working with the filesystem is to iterate through the content of a directory. </span><span class="koboSpan" id="kobo.4755.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4756.1">filesystem</span></code><span class="koboSpan" id="kobo.4757.1"> library provides two directory iterators, one called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4758.1">directory_iterator</span></code><span class="koboSpan" id="kobo.4759.1">, which iterates the content of a directory, and one called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4760.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.4761.1">, which recursively iterates the content of a directory and its subdirectories. </span><span class="koboSpan" id="kobo.4761.2">In this recipe, we will learn how to use them.</span></p>
<h2 class="heading-2" id="_idParaDest-483"><span class="koboSpan" id="kobo.4762.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4763.1">For this recipe, we will consider a directory with the following structure:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4764.1">test/
├──data/
│ ├──input.dat
│ └──output.dat
├──file_1.txt
├──file_2.txt
└──file_3.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4765.1">In the following snippets, we will refer to the following function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4766.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4767.1">print_line</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4768.1">(std::string_view prefix, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4769.1">                std::filesystem::path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4770.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4771.1">&amp; path)</span></span><span class="koboSpan" id="kobo.4772.1">
{
   std::cout &lt;&lt; prefix &lt;&lt; path &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4773.1">'\n'</span></span><span class="koboSpan" id="kobo.4774.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4775.1">In this recipe, we will work with filesystem paths and check the properties of a filesystem object. </span><span class="koboSpan" id="kobo.4775.2">Therefore, it is recommended that you first read the </span><em class="italic"><span class="koboSpan" id="kobo.4776.1">Working with filesystem paths</span></em><span class="koboSpan" id="kobo.4777.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.4778.1">Checking the properties of an existing file or directory</span></em><span class="koboSpan" id="kobo.4779.1"> recipes.</span></p>
<h2 class="heading-2" id="_idParaDest-484"><span class="koboSpan" id="kobo.4780.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4781.1">Use the following patterns to enumerate the content of a directory:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4782.1">To iterate only the content of a directory without recursively visiting its subdirectories, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4783.1">directory_iterator</span></code><span class="koboSpan" id="kobo.4784.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4785.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4786.1">visit_directory</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4787.1">(fs::path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4788.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4789.1"> &amp; dir)</span></span><span class="koboSpan" id="kobo.4790.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4791.1">if</span></span><span class="koboSpan" id="kobo.4792.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4793.1">exists</span></span><span class="koboSpan" id="kobo.4794.1">(dir) &amp;&amp; fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4795.1">is_directory</span></span><span class="koboSpan" id="kobo.4796.1">(dir))
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4797.1">for</span></span><span class="koboSpan" id="kobo.4798.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4799.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4800.1">const</span></span><span class="koboSpan" id="kobo.4801.1"> &amp; entry : fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4802.1">directory_iterator</span></span><span class="koboSpan" id="kobo.4803.1">(dir))
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4804.1">auto</span></span><span class="koboSpan" id="kobo.4805.1"> filename = entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4806.1">path</span></span><span class="koboSpan" id="kobo.4807.1">().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4808.1">filename</span></span><span class="koboSpan" id="kobo.4809.1">();
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4810.1">if</span></span><span class="koboSpan" id="kobo.4811.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4812.1">is_directory</span></span><span class="koboSpan" id="kobo.4813.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4814.1">status</span></span><span class="koboSpan" id="kobo.4815.1">()))
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4816.1">"[+]",</span></span><span class="koboSpan" id="kobo.4817.1"> filename</span><span class="hljs-string"><span class="koboSpan" id="kobo.4818.1">)</span></span><span class="koboSpan" id="kobo.4819.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4820.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4821.1">if</span></span><span class="koboSpan" id="kobo.4822.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4823.1">is_symlink</span></span><span class="koboSpan" id="kobo.4824.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4825.1">status</span></span><span class="koboSpan" id="kobo.4826.1">()))
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4827.1">"[&gt;]",</span></span><span class="koboSpan" id="kobo.4828.1"> filename);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4829.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4830.1">if</span></span><span class="koboSpan" id="kobo.4831.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4832.1">is_regular_file</span></span><span class="koboSpan" id="kobo.4833.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4834.1">status</span></span><span class="koboSpan" id="kobo.4835.1">()))
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4836.1">" ",</span></span><span class="koboSpan" id="kobo.4837.1"> filename);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4838.1">else</span></span><span class="koboSpan" id="kobo.4839.1">
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4840.1">"[?]"</span></span><span class="koboSpan" id="kobo.4841.1">, filename);
    }
  }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4842.1">To iterate </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.4843.1">all the content of a directory, including its subdirectories, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4844.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.4845.1"> when the order of processing the entries does not matter:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4846.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4847.1">visit_directory_rec</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4848.1">(fs::path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4849.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4850.1"> &amp; dir)</span></span><span class="koboSpan" id="kobo.4851.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4852.1">if</span></span><span class="koboSpan" id="kobo.4853.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4854.1">exists</span></span><span class="koboSpan" id="kobo.4855.1">(dir) &amp;&amp; fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4856.1">is_directory</span></span><span class="koboSpan" id="kobo.4857.1">(dir))
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4858.1">for</span></span><span class="koboSpan" id="kobo.4859.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4860.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4861.1">const</span></span><span class="koboSpan" id="kobo.4862.1"> &amp; entry :
         fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4863.1">recursive_directory_iterator</span></span><span class="koboSpan" id="kobo.4864.1">(dir))
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4865.1">auto</span></span><span class="koboSpan" id="kobo.4866.1"> filename = entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4867.1">path</span></span><span class="koboSpan" id="kobo.4868.1">().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4869.1">filename</span></span><span class="koboSpan" id="kobo.4870.1">();
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4871.1">if</span></span><span class="koboSpan" id="kobo.4872.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4873.1">is_directory</span></span><span class="koboSpan" id="kobo.4874.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4875.1">status</span></span><span class="koboSpan" id="kobo.4876.1">()))
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4877.1">"[+]"</span></span><span class="koboSpan" id="kobo.4878.1">, filename);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4879.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4880.1">if</span></span><span class="koboSpan" id="kobo.4881.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4882.1">is_symlink</span></span><span class="koboSpan" id="kobo.4883.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4884.1">status</span></span><span class="koboSpan" id="kobo.4885.1">()))
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4886.1">"[&gt;]"</span></span><span class="koboSpan" id="kobo.4887.1">,filename);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4888.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4889.1">if</span></span><span class="koboSpan" id="kobo.4890.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4891.1">is_regular_file</span></span><span class="koboSpan" id="kobo.4892.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4893.1">status</span></span><span class="koboSpan" id="kobo.4894.1">()))
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4895.1">" "</span></span><span class="koboSpan" id="kobo.4896.1">,filename);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4897.1">else</span></span><span class="koboSpan" id="kobo.4898.1">
        print_line(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4899.1">"[?]"</span></span><span class="koboSpan" id="kobo.4900.1">,filename);
    }
  }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4901.1">To iterate all the content of a directory, including its subdirectories, in a structured manner, such as traversing a tree, use a function similar to the one in the first example, which uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.4902.1">directory_iterator</span></code><span class="koboSpan" id="kobo.4903.1"> to iterate the content </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.4904.1">of a directory. </span><span class="koboSpan" id="kobo.4904.2">However, instead, call it recursively for each subdirectory:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4905.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4906.1">visit_directory_rec_ordered</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4907.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4908.1">  fs::path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4909.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4910.1"> &amp; dir,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4911.1">bool</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4912.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4913.1"> recursive = </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.4914.1">false</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4915.1">,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4916.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4917.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4918.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4919.1"> level = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4920.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4921.1">)</span></span><span class="koboSpan" id="kobo.4922.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4923.1">if</span></span><span class="koboSpan" id="kobo.4924.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4925.1">exists</span></span><span class="koboSpan" id="kobo.4926.1">(dir) &amp;&amp; fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4927.1">is_directory</span></span><span class="koboSpan" id="kobo.4928.1">(dir))
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4929.1">auto</span></span><span class="koboSpan" id="kobo.4930.1"> lead = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4931.1">string</span></span><span class="koboSpan" id="kobo.4932.1">(level*</span><span class="hljs-number"><span class="koboSpan" id="kobo.4933.1">3</span></span><span class="koboSpan" id="kobo.4934.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4935.1">' '</span></span><span class="koboSpan" id="kobo.4936.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4937.1">for</span></span><span class="koboSpan" id="kobo.4938.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4939.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4940.1">const</span></span><span class="koboSpan" id="kobo.4941.1"> &amp; entry : fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4942.1">directory_iterator</span></span><span class="koboSpan" id="kobo.4943.1">(dir))
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4944.1">auto</span></span><span class="koboSpan" id="kobo.4945.1"> filename = entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4946.1">path</span></span><span class="koboSpan" id="kobo.4947.1">().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4948.1">filename</span></span><span class="koboSpan" id="kobo.4949.1">();
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4950.1">if</span></span><span class="koboSpan" id="kobo.4951.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4952.1">is_directory</span></span><span class="koboSpan" id="kobo.4953.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4954.1">status</span></span><span class="koboSpan" id="kobo.4955.1">()))
      {
        print_line(lead + </span><span class="hljs-string"><span class="koboSpan" id="kobo.4956.1">"[+]"</span></span><span class="koboSpan" id="kobo.4957.1">, filename);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4958.1">if</span></span><span class="koboSpan" id="kobo.4959.1">(recursive)
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4960.1">visit_directory_rec_ordered</span></span><span class="koboSpan" id="kobo.4961.1">(entry, recursive, 
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.4962.1">level+</span><span class="hljs-number"><span class="koboSpan" id="kobo.4963.1">1</span></span><span class="koboSpan" id="kobo.4964.1">);
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4965.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4966.1">if</span></span><span class="koboSpan" id="kobo.4967.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4968.1">is_symlink</span></span><span class="koboSpan" id="kobo.4969.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4970.1">status</span></span><span class="koboSpan" id="kobo.4971.1">()))
        print_line(lead + </span><span class="hljs-string"><span class="koboSpan" id="kobo.4972.1">"[&gt;]"</span></span><span class="koboSpan" id="kobo.4973.1">, filename);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4974.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4975.1">if</span></span><span class="koboSpan" id="kobo.4976.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4977.1">is_regular_file</span></span><span class="koboSpan" id="kobo.4978.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4979.1">status</span></span><span class="koboSpan" id="kobo.4980.1">()))
        print_line(lead + </span><span class="hljs-string"><span class="koboSpan" id="kobo.4981.1">" "</span></span><span class="koboSpan" id="kobo.4982.1">, filename);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4983.1">else</span></span><span class="koboSpan" id="kobo.4984.1">
        print_line(lead + </span><span class="hljs-string"><span class="koboSpan" id="kobo.4985.1">"[?]"</span></span><span class="koboSpan" id="kobo.4986.1">, filename);
    }
  }
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-485"><span class="koboSpan" id="kobo.4987.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4988.1">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4989.1">directory_iterator</span></code><span class="koboSpan" id="kobo.4990.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4991.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.4992.1"> are input iterators that iterate over the entries of a directory. </span><span class="koboSpan" id="kobo.4992.2">The difference is that the first one does not visit the subdirectories recursively, while the second one, as its name implies, does. </span><span class="koboSpan" id="kobo.4992.3">They both share a similar behavior:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4993.1">The order of iteration is unspecified.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4994.1">Each directory entry is visited only once.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4995.1">The special paths dot (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4996.1">.</span></code><span class="koboSpan" id="kobo.4997.1">) and dot-dot (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4998.1">..</span></code><span class="koboSpan" id="kobo.4999.1">) are skipped.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5000.1">A default-constructed iterator is the end iterator, and two end iterators are always equal.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5001.1">When iterated past the last directory entries, it becomes equal to the end iterator.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5002.1">The standard does not specify what happens if a directory entry is added to, or deleted from, the iterated directory after the iterator has been created.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5003.1">The standard defines the non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.5004.1">begin()</span></code><span class="koboSpan" id="kobo.5005.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5006.1">end()</span></code><span class="koboSpan" id="kobo.5007.1"> for both </span><code class="inlineCode"><span class="koboSpan" id="kobo.5008.1">directory_iterator</span></code><span class="koboSpan" id="kobo.5009.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5010.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.5011.1">, which enables us to use these iterators in range-based </span><code class="inlineCode"><span class="koboSpan" id="kobo.5012.1">for</span></code><span class="koboSpan" id="kobo.5013.1"> loops, as shown in the examples earlier.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5014.1">Both</span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.5015.1"> iterators have overloaded constructors. </span><span class="koboSpan" id="kobo.5015.2">Some overloads of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5016.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.5017.1"> constructor take an argument of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5018.1">std::filesystem::directory_options</span></code><span class="koboSpan" id="kobo.5019.1"> type, which specifies additional options for the iteration:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5020.1">none</span></code><span class="koboSpan" id="kobo.5021.1">: This is the default, which does not specify anything.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5022.1">follow_directory_symlink</span></code><span class="koboSpan" id="kobo.5023.1">: This specifies that the iteration should follow symbolic links instead of serving the link itself.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5024.1">skip_permission_denied</span></code><span class="koboSpan" id="kobo.5025.1">: This specifies that you should ignore and skip the directories that could trigger an access denied error.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5026.1">The elements that both directory iterators point to are of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5027.1">directory_entry</span></code><span class="koboSpan" id="kobo.5028.1"> type. </span><span class="koboSpan" id="kobo.5028.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5029.1">path()</span></code><span class="koboSpan" id="kobo.5030.1"> member function returns the path of the filesystem object represented by this object. </span><span class="koboSpan" id="kobo.5030.2">The status of the filesystem object can be retrieved with the member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.5031.1">status()</span></code><span class="koboSpan" id="kobo.5032.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5033.1">symlink_status()</span></code><span class="koboSpan" id="kobo.5034.1"> for symbolic links.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5035.1">The preceding examples follow a common pattern:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.5036.1">Verify that the path to iterate actually exists.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5037.1">Use a range-based </span><code class="inlineCode"><span class="koboSpan" id="kobo.5038.1">for</span></code><span class="koboSpan" id="kobo.5039.1"> loop to iterate all the entries of a directory.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5040.1">Use one of the two directory iterators available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5041.1">filesystem</span></code><span class="koboSpan" id="kobo.5042.1"> library, depending on the way the iteration is supposed to be done.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5043.1">Process each entry according to the requirements.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.5044.1">In our examples, we simply printed the names of the directory entries to the console. </span><span class="koboSpan" id="kobo.5044.2">It is important to note, as we specified earlier, that the content of the directory is iterated in an unspecified order. </span><span class="koboSpan" id="kobo.5044.3">If you want to process the content in a structured manner, such as showing subdirectories and their entries indented (for this particular case) or in a tree (in other types of applications), then using </span><code class="inlineCode"><span class="koboSpan" id="kobo.5045.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.5046.1"> is not appropriate. </span><span class="koboSpan" id="kobo.5046.2">Instead, you should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5047.1">directory_iterator</span></code><span class="koboSpan" id="kobo.5048.1"> in a function that is called recursively from the iteration, for each subdirectory, as shown in the last example from the previous section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5049.1">Considering the </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.5050.1">directory structure presented at the beginning of this recipe (relative to the current path), we get the following output when using the recursive iterator, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.5051.1">visit_directory_rec</span></span><span class="koboSpan" id="kobo.5052.1">(fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5053.1">current_path</span></span><span class="koboSpan" id="kobo.5054.1">() / </span><span class="hljs-string"><span class="koboSpan" id="kobo.5055.1">"test"</span></span><span class="koboSpan" id="kobo.5056.1">);
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5057.1">[+]data
   input.dat
   output.dat
   file_1.txt
   file_2.txt
   file_3.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5058.1">On the other hand, when using the recursive function from the third example, as shown in the following listing, the output is displayed in order of sublevels, as intended:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.5059.1">visit_directory_rec_ordered</span></span><span class="koboSpan" id="kobo.5060.1">(fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5061.1">current_path</span></span><span class="koboSpan" id="kobo.5062.1">() / </span><span class="hljs-string"><span class="koboSpan" id="kobo.5063.1">"test"</span></span><span class="koboSpan" id="kobo.5064.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5065.1">true</span></span><span class="koboSpan" id="kobo.5066.1">);
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5067.1">[+]data
      input.dat
      output.dat
   file_1.txt
   file_2.txt
   file_3.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5068.1">Remember that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5069.1">visit_directory_rec()</span></code><span class="koboSpan" id="kobo.5070.1"> function is a non-recursive function that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.5071.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.5072.1">, while the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5073.1">visit_directory_rec_ordered()</span></code><span class="koboSpan" id="kobo.5074.1"> function is a recursive function that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.5075.1">directory_iterator</span></code><span class="koboSpan" id="kobo.5076.1">. </span><span class="koboSpan" id="kobo.5076.2">This example should help you to understand the difference between the two iterators.</span></p>
<h2 class="heading-2" id="_idParaDest-486"><span class="koboSpan" id="kobo.5077.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5078.1">In the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.5079.1">Checking the properties of an existing file or directory</span></em><span class="koboSpan" id="kobo.5080.1">, we discussed, among other things, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5081.1">file_size()</span></code><span class="koboSpan" id="kobo.5082.1"> function, which returns the size of a file in bytes. </span><span class="koboSpan" id="kobo.5082.2">However, this function fails if the specified path is a directory. </span><span class="koboSpan" id="kobo.5082.3">To determine the size of a directory, we need to iterate recursively through the content of a directory, retrieve the size of the regular files or symbolic links, and add them together.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5083.1">Consider the following function to exemplify this case:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5084.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5085.1">uintmax_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5086.1">dir_size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5087.1">(fs::path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5088.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5089.1"> &amp; path)</span></span><span class="koboSpan" id="kobo.5090.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5091.1">if</span></span><span class="koboSpan" id="kobo.5092.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5093.1">exists</span></span><span class="koboSpan" id="kobo.5094.1">(path) &amp;&amp; fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5095.1">is_directory</span></span><span class="koboSpan" id="kobo.5096.1">(path))
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5097.1">auto</span></span><span class="koboSpan" id="kobo.5098.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5099.1">static_cast</span></span><span class="koboSpan" id="kobo.5100.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5101.1">uintmax_t</span></span><span class="koboSpan" id="kobo.5102.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5103.1">0</span></span><span class="koboSpan" id="kobo.5104.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5105.1">for</span></span><span class="koboSpan" id="kobo.5106.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5107.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5108.1">const</span></span><span class="koboSpan" id="kobo.5109.1"> &amp; entry :
           fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5110.1">recursive_directory_iterator</span></span><span class="koboSpan" id="kobo.5111.1">(path))
      {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5112.1">if</span></span><span class="koboSpan" id="kobo.5113.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5114.1">is_regular_file</span></span><span class="koboSpan" id="kobo.5115.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5116.1">status</span></span><span class="koboSpan" id="kobo.5117.1">()) ||
            fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5118.1">is_symlink</span></span><span class="koboSpan" id="kobo.5119.1">(entry.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5120.1">status</span></span><span class="koboSpan" id="kobo.5121.1">()))
         {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5122.1">auto</span></span><span class="koboSpan" id="kobo.5123.1"> err = std::error_code{};
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5124.1">auto</span></span><span class="koboSpan" id="kobo.5125.1"> filesize = fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5126.1">file_size</span></span><span class="koboSpan" id="kobo.5127.1">(entry, err);
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5128.1">if</span></span><span class="koboSpan" id="kobo.5129.1"> (!err)
               size += filesize;
         }
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5130.1">return</span></span><span class="koboSpan" id="kobo.5131.1"> size;
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5132.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5133.1">static_cast</span></span><span class="koboSpan" id="kobo.5134.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5135.1">uintmax_t</span></span><span class="koboSpan" id="kobo.5136.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5137.1">-1</span></span><span class="koboSpan" id="kobo.5138.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5139.1">The </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.5140.1">preceding </span><code class="inlineCode"><span class="koboSpan" id="kobo.5141.1">dir_size()</span></code><span class="koboSpan" id="kobo.5142.1"> function returns the size of all the files in a directory (recursively), or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5143.1">-1</span></code><span class="koboSpan" id="kobo.5144.1">, as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5145.1">uintmax_t</span></code><span class="koboSpan" id="kobo.5146.1">, in the case of an error (the path does not exist or does not represent a directory).</span></p>
<h2 class="heading-2" id="_idParaDest-487"><span class="koboSpan" id="kobo.5147.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5148.1">Checking the properties of an existing file or directory</span></em><span class="koboSpan" id="kobo.5149.1">, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5150.1">Finding a file</span></em><span class="koboSpan" id="kobo.5151.1">, to learn how to search for files based on their name, extension, or other properties</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-488"><span class="koboSpan" id="kobo.5152.1">Finding a file</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5153.1">In the </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.5154.1">previous recipe, we learned how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5155.1">directory_iterator</span></code><span class="koboSpan" id="kobo.5156.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5157.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.5158.1"> to enumerate the content of a directory. </span><span class="koboSpan" id="kobo.5158.2">Displaying the content of a directory, as we did in the previous recipe, is only one of the scenarios in which this is needed. </span><span class="koboSpan" id="kobo.5158.3">The other major scenario is when searching for particular entries in a directory, such as files with a particular name, extension, and so on. </span><span class="koboSpan" id="kobo.5158.4">In this recipe, we will demonstrate how we can use the directory iterators and the iterating patterns shown earlier to find files that match a given criterion.</span></p>
<h2 class="heading-2" id="_idParaDest-489"><span class="koboSpan" id="kobo.5159.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5160.1">You should read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.5161.1">Enumerating the content of a directory</span></em><span class="koboSpan" id="kobo.5162.1">, for details about directory iterators. </span><span class="koboSpan" id="kobo.5162.2">In this recipe, we will also use the same test directory structure that was presented in the previous recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-490"><span class="koboSpan" id="kobo.5163.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5164.1">To find files that match particular criteria, use the following pattern:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.5165.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5166.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.5167.1"> to iterate through all the entries of a directory and recursively through its subdirectories.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5168.1">Consider regular files (and any other types of files you may need to process).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5169.1">Use a function object (such as a lambda expression) to filter only the files that match your criteria.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5170.1">Add the selected entries to a container (such as a vector).</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.5171.1">This pattern is exemplified in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5172.1">find_files()</span></code><span class="koboSpan" id="kobo.5173.1"> function shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5174.1">std::vector&lt;fs::path&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5175.1">find_files</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5176.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.5177.1">    fs::path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5178.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5179.1"> &amp; dir,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.5180.1">    std::function&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5181.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5182.1">(fs::path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5183.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5184.1">&amp;)&gt; filter)</span></span><span class="koboSpan" id="kobo.5185.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5186.1">auto</span></span><span class="koboSpan" id="kobo.5187.1"> result = std::vector&lt;fs::path&gt;{};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5188.1">if</span></span><span class="koboSpan" id="kobo.5189.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5190.1">exists</span></span><span class="koboSpan" id="kobo.5191.1">(dir))
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5192.1">for</span></span><span class="koboSpan" id="kobo.5193.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5194.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5195.1">const</span></span><span class="koboSpan" id="kobo.5196.1"> &amp; entry :
      fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5197.1">recursive_directory_iterator</span></span><span class="koboSpan" id="kobo.5198.1">(
        dir,
        fs::directory_options::follow_directory_symlink))
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5199.1">if</span></span><span class="koboSpan" id="kobo.5200.1"> (fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5201.1">is_regular_file</span></span><span class="koboSpan" id="kobo.5202.1">(entry) &amp;&amp;
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5203.1">filter</span></span><span class="koboSpan" id="kobo.5204.1">(entry))
      {
        result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5205.1">push_back</span></span><span class="koboSpan" id="kobo.5206.1">(entry);
      }
    }
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5207.1">return</span></span><span class="koboSpan" id="kobo.5208.1"> result;
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-491"><span class="koboSpan" id="kobo.5209.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5210.1">When we want to </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.5211.1">find files in a directory, the structure of the directory and the order in which its entries, including subdirectories, are visited are probably not important. </span><span class="koboSpan" id="kobo.5211.2">Therefore, we can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5212.1">recursive_directory_iterator</span></code><span class="koboSpan" id="kobo.5213.1"> to iterate through the entries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5214.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5215.1">find_files()</span></code><span class="koboSpan" id="kobo.5216.1"> function takes two arguments: a path and a function wrapper that is used to select the entries that should be returned. </span><span class="koboSpan" id="kobo.5216.2">The return type is a vector of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5217.1">filesystem::path</span></code><span class="koboSpan" id="kobo.5218.1">, though. </span><span class="koboSpan" id="kobo.5218.2">Alternatively, it could also be a vector of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5219.1">filesystem::directory_entry</span></code><span class="koboSpan" id="kobo.5220.1">. </span><span class="koboSpan" id="kobo.5220.2">The recursive directory iterator used in this example does not follow symbolic links, returning the link itself and not the target. </span><span class="koboSpan" id="kobo.5220.3">This behavior can be changed by using a constructor overload that has an argument of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.5221.1">filesystem::directory_options</span></code><span class="koboSpan" id="kobo.5222.1"> and passing </span><code class="inlineCode"><span class="koboSpan" id="kobo.5223.1">follow_directory_symlink</span></code><span class="koboSpan" id="kobo.5224.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5225.1">In the preceding example, we only consider the regular files and ignore the other types of filesystem objects. </span><span class="koboSpan" id="kobo.5225.2">The predicate is applied to the directory entry and, if it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5226.1">true</span></code><span class="koboSpan" id="kobo.5227.1">, the entry is added to the result.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5228.1">The following example uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5229.1">find_files()</span></code><span class="koboSpan" id="kobo.5230.1"> function to find all of the files in the test directory that start with the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.5231.1">file_</span></code><span class="koboSpan" id="kobo.5232.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5233.1">auto</span></span><span class="koboSpan" id="kobo.5234.1"> results = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5235.1">find_files</span></span><span class="koboSpan" id="kobo.5236.1">(
          fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5237.1">current_path</span></span><span class="koboSpan" id="kobo.5238.1">() / </span><span class="hljs-string"><span class="koboSpan" id="kobo.5239.1">"test"</span></span><span class="koboSpan" id="kobo.5240.1">,
          [](fs::path </span><span class="hljs-type"><span class="koboSpan" id="kobo.5241.1">const</span></span><span class="koboSpan" id="kobo.5242.1"> &amp; p) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5243.1">auto</span></span><span class="koboSpan" id="kobo.5244.1"> filename = p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5245.1">wstring</span></span><span class="koboSpan" id="kobo.5246.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5247.1">return</span></span><span class="koboSpan" id="kobo.5248.1"> filename.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5249.1">find</span></span><span class="koboSpan" id="kobo.5250.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5251.1">L"file_"</span></span><span class="koboSpan" id="kobo.5252.1">) != std::wstring::npos;
});
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5253.1">for</span></span><span class="koboSpan" id="kobo.5254.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5255.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5256.1">const</span></span><span class="koboSpan" id="kobo.5257.1"> &amp; path : results)
{
  std::cout &lt;&lt; path &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5258.1">'\n'</span></span><span class="koboSpan" id="kobo.5259.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5260.1">The output of executing this program, with paths relative to the current path, is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5261.1">test\file_1.txt
test\file_2.txt
test\file_3.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5262.1">A second </span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.5263.1">example shows how to find files that have a particular extension, in this case, the extension </span><code class="inlineCode"><span class="koboSpan" id="kobo.5264.1">.dat</span></code><span class="koboSpan" id="kobo.5265.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5266.1">auto</span></span><span class="koboSpan" id="kobo.5267.1"> results = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5268.1">find_files</span></span><span class="koboSpan" id="kobo.5269.1">(
       fs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5270.1">current_path</span></span><span class="koboSpan" id="kobo.5271.1">() / </span><span class="hljs-string"><span class="koboSpan" id="kobo.5272.1">"test"</span></span><span class="koboSpan" id="kobo.5273.1">,
       [](fs::path </span><span class="hljs-type"><span class="koboSpan" id="kobo.5274.1">const</span></span><span class="koboSpan" id="kobo.5275.1"> &amp; p) {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5276.1">return</span></span><span class="koboSpan" id="kobo.5277.1"> p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5278.1">extension</span></span><span class="koboSpan" id="kobo.5279.1">() == </span><span class="hljs-string"><span class="koboSpan" id="kobo.5280.1">L".dat"</span></span><span class="koboSpan" id="kobo.5281.1">;});
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5282.1">for</span></span><span class="koboSpan" id="kobo.5283.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5284.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5285.1">const</span></span><span class="koboSpan" id="kobo.5286.1"> &amp; path : results)
{
  std::cout &lt;&lt; path &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5287.1">'\n'</span></span><span class="koboSpan" id="kobo.5288.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5289.1">The output, again relative to the current path, is shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5290.1">test\data\input.dat
test\data\output.dat
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5291.1">These two examples are very similar. </span><span class="koboSpan" id="kobo.5291.2">The only thing that is different is the code in the lambda function, which checks the path received as an argument.</span></p>
<h2 class="heading-2" id="_idParaDest-492"><span class="koboSpan" id="kobo.5292.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5293.1">Checking the properties of an existing file or directory</span></em><span class="koboSpan" id="kobo.5294.1">, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5295.1">Enumerating the content of a directory</span></em><span class="koboSpan" id="kobo.5296.1">, to learn how to iterate through the files and subdirectories of a directory</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.5297.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5298.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_07.xhtml"><span class="url"><span class="koboSpan" id="kobo.5299.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.5300.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>