<html><head></head><body>
<div><h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-426">Working with Files and Streams</h1>
<p class="normal">One of the most important parts of the C++ standard library is the <strong class="keyWord">input/output</strong> (<strong class="keyWord">I/O</strong>) stream-based library<a id="_idIndexMarker820"/> that enables developers to work with files, memory streams, or other types of I/O devices. The first part of this chapter provides solutions to some common stream operations, such as reading and writing data, localization settings, and manipulating the input and output of a stream. The second part of the chapter explores the C++17 <code class="inlineCode">filesystem</code> library, which enables developers to perform operations with the filesystem and its objects, such as files and directories.</p>
<p class="normal">The recipes covered in this chapter are as follows:</p>
<ul>
<li class="bulletList">Reading and writing raw data from/to binary files</li>
<li class="bulletList">Reading and writing objects from/to binary files</li>
<li class="bulletList">Using streams on fixed-size external buffers</li>
<li class="bulletList">Using localized settings for streams</li>
<li class="bulletList">Using I/O manipulators to control the output of a stream</li>
<li class="bulletList">Using monetary I/O manipulators</li>
<li class="bulletList">Using time I/O manipulators</li>
<li class="bulletList">Working with filesystem paths</li>
<li class="bulletList">Creating, copying, and deleting files and directories</li>
<li class="bulletList">Removing content from a file</li>
<li class="bulletList">Checking the properties of an existing file or directory</li>
<li class="bulletList">Enumerating the content of a directory</li>
<li class="bulletList">Finding a file</li>
</ul>
<p class="normal">We will start the chapter with a couple of recipes on how to serialize and deserialize data to/from files.</p>
<h1 class="heading-1" id="_idParaDest-427">Reading and writing raw data from/to binary files</h1>
<p class="normal">Some of the<a id="_idIndexMarker821"/> data programs you work with must be persisted to disk files in various ways, including storing data in a database or flat files, either as text or binary data. This recipe, and the next one, are focused on persisting and<a id="_idIndexMarker822"/> loading both raw data and objects from and to binary files. </p>
<p class="normal">In this context, raw data means unstructured data, and, in this recipe, we will consider writing and reading the content of a buffer (that is, a contiguous sequence of memory), which can either be an array, a <code class="inlineCode">std::vector</code>, or a <code class="inlineCode">std::array</code>.</p>
<h2 class="heading-2" id="_idParaDest-428">Getting ready</h2>
<p class="normal">For this recipe, you should be familiar with the standard stream I/O library, although some explanations, to the extent that is required to understand this recipe, are provided next. You should also be familiar with the differences between binary and text files.</p>
<p class="normal">In this recipe, we will use the <code class="inlineCode">ofstream</code> and <code class="inlineCode">ifstream</code> classes, which are available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;fstream&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-429">How to do it...</h2>
<p class="normal">To write the content of a buffer (in our example, a <code class="inlineCode">std::vector</code>) to a binary file, you should perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open a file stream for writing in binary mode by creating an instance of the <code class="inlineCode">std::ofstream</code> class:
        <pre class="programlisting code"><code class="hljs-code">std::ofstream ofile("sample.bin", std::ios::binary);
</code></pre>
</li>
<li class="numberedList">Ensure that the file is actually open before writing data to the file:
        <pre class="programlisting code"><code class="hljs-code">if(ofile.is_open())
{
  // streamed file operations
}
</code></pre>
</li>
<li class="numberedList">Write the data to the file by providing a pointer to the array of characters and the number of characters to write. In the following example, we write the content of a local vector; however, typically, this data comes from a different context:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;unsigned char&gt; output {0,1,2,3,4,5,6,7,8,9};
ofile.write(reinterpret_cast&lt;char*&gt;(output.data()), output.size());
</code></pre>
</li>
<li class="numberedList">Optionally, you <a id="_idIndexMarker823"/>can flush the content of the stream’s output buffer to the actual disk file by calling the <code class="inlineCode">flush()</code> method. This determines the uncommitted changes in the stream to be synchronized with the external destination, which, in this case, is a disk file.</li>
<li class="numberedList">Close the stream by calling <code class="inlineCode">close()</code>. This, in turn, calls <code class="inlineCode">flush()</code>, making the preceding step unnecessary in most contexts:
        <pre class="programlisting code"><code class="hljs-code">ofile.close();
</code></pre>
</li>
</ol>
<p class="normal">To read the <a id="_idIndexMarker824"/>entire content of a binary file to a buffer, you should perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open a file stream to read from a file in binary mode by creating an instance of the <code class="inlineCode">std::ifstream</code> class. The path to the file can be absolute or relative to the current working directory (not to the path of the executable). In this example, the path is relative:
        <pre class="programlisting code"><code class="hljs-code">std::ifstream ifile("sample.bin", std::ios::binary);
</code></pre>
</li>
<li class="numberedList">Ensure that the file is actually open before reading data from it:
        <pre class="programlisting code"><code class="hljs-code">if(ifile.is_open())
{
  // streamed file operations
}
</code></pre>
</li>
<li class="numberedList">Determine the length of the file by positioning the input position indicator to the end of the file, read its value, and then move the indicator to the beginning:
        <pre class="programlisting code"><code class="hljs-code">ifile.seekg(0, std::ios_base::end);
auto length = ifile.tellg();
ifile.seekg(0, std::ios_base::beg);
</code></pre>
</li>
<li class="numberedList">Allocate memory to read the content of the file:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;unsigned char&gt; input;
input.resize(static_cast&lt;size_t&gt;(length));
</code></pre>
</li>
<li class="numberedList">Read the<a id="_idIndexMarker825"/> content of the file to the allocated buffer by providing a pointer to the array of characters for receiving the data and the number of characters to read:
        <pre class="programlisting code"><code class="hljs-code">ifile.read(reinterpret_cast&lt;char*&gt;(input.data()), length);
</code></pre>
</li>
<li class="numberedList">Check <a id="_idIndexMarker826"/>that the read operation is completed successfully:
        <pre class="programlisting code"><code class="hljs-code">auto success = !ifile.fail() &amp;&amp; length == ifile.gcount();
</code></pre>
</li>
<li class="numberedList">Finally, close the file stream:
        <pre class="programlisting code"><code class="hljs-code">ifile.close();
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-430">How it works...</h2>
<p class="normal">The standard stream-based I/O library provides various classes that implement high-level input, output, or both input and output file stream, string stream and character array operations, manipulators that control how these streams behave, and several predefined stream objects (<code class="inlineCode">cin</code>/<code class="inlineCode">wcin</code>, <code class="inlineCode">cout</code>/<code class="inlineCode">wcout</code>, <code class="inlineCode">cerr</code>/<code class="inlineCode">wcerr</code>, and <code class="inlineCode">clog</code>/<code class="inlineCode">wclog</code>).</p>
<p class="normal">These streams are implemented as class templates and, for files, the library provides several (non-copyable) classes:</p>
<ul>
<li class="bulletList"><code class="inlineCode">basic_filebuf</code> implements the I/O operations for a raw file and is similar in semantics to a C <code class="inlineCode">FILE</code> stream.</li>
<li class="bulletList"><code class="inlineCode">basic_ifstream</code> implements the high-level file stream input operations defined by the <code class="inlineCode">basic_istream</code> stream interface, internally using a <code class="inlineCode">basic_filebuf</code> object.</li>
<li class="bulletList"><code class="inlineCode">basic_ofstream</code> implements the high-level file stream output operations defined by the <code class="inlineCode">basic_ostream</code> stream interface, internally using a <code class="inlineCode">basic_filebuf</code> object.</li>
<li class="bulletList"><code class="inlineCode">basic_fstream</code> implements the high-level file stream input and output operations defined by the <code class="inlineCode">basic_iostream</code> stream interface, internally using a <code class="inlineCode">basic_filebuf</code> object.</li>
</ul>
<p class="normal">These classes are represented in the following class diagram to better understand their relationship:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_07_01.png"/></figure>
<p class="packt_figref">Figure 7.1: Stream class diagram</p>
<p class="normal">Notice that this<a id="_idIndexMarker827"/> diagram also features several <a id="_idIndexMarker828"/>classes designed to work with a string-based stream. These streams, however, will not be discussed here.</p>
<p class="normal">Several typedefs for the class templates mentioned earlier are also defined in the <code class="inlineCode">&lt;fstream&gt;</code> header, in the <code class="inlineCode">std</code> namespace. The <code class="inlineCode">ofstream</code> and <code class="inlineCode">ifstream</code> objects are the type synonyms used in the preceding examples:</p>
<pre class="programlisting code"><code class="hljs-code">typedef basic_ifstream&lt;char&gt;    ifstream;
typedef basic_ifstream&lt;wchar_t&gt; wifstream;
typedef basic_ofstream&lt;char&gt;    ofstream;
typedef basic_ofstream&lt;wchar_t&gt; wofstream;
typedef basic_fstream&lt;char&gt;     fstream;
typedef basic_fstream&lt;wchar_t&gt;  wfstream;
</code></pre>
<p class="normal">In the previous section, you saw how we can write and read raw data to and from a file stream. Now, we’ll cover this process in more detail.</p>
<p class="normal">To write data to<a id="_idIndexMarker829"/> a file, we instantiated an object of the type <code class="inlineCode">std::ofstream</code>. In the constructor, we passed the name of the file to be opened and the stream’s open mode, for which we specified <code class="inlineCode">std::ios::binary</code> to indicate binary mode. Opening the file like this discards the previous file content. If you want to append content to an existing file, you should also use the flag <code class="inlineCode">std::ios::app</code> (that is, <code class="inlineCode">std::ios::app | std::ios::binary</code>). This constructor internally calls <code class="inlineCode">open()</code> on its underlying<a id="_idIndexMarker830"/> raw file object (that is, a <code class="inlineCode">basic_filebuf</code> object). If this operation fails, a fail bit is set. To check whether the stream has been successfully associated with a file device, we used <code class="inlineCode">is_open()</code> (this internally calls the method with the same name from the underlying <code class="inlineCode">basic_filebuf</code>). Writing data to the file stream is done using the <code class="inlineCode">write()</code> method, which takes a pointer to the string of characters to write and the number of characters to write. Since this method operates with strings of characters, a <code class="inlineCode">reinterpret_cast</code> is necessary if data is of another type, such as <code class="inlineCode">unsigned char</code>, in our example. The write operation does not set a fail bit in the case of a failure, but it may throw a <code class="inlineCode">std::ios_base::failure</code> exception. However, data is not written directly to the file device but stored in the <code class="inlineCode">basic_filebuf</code> object. To write it to the file, the buffer needs to be flushed, which is done by calling <code class="inlineCode">flush()</code>. This is done automatically when closing the file stream, as shown in the preceding example.</p>
<p class="normal">To read data from a file, we instantiated an object of type <code class="inlineCode">std::ifstream</code>. In the constructor, we passed the same arguments that we used for opening the file to write the name of the file and the open mode (that is, <code class="inlineCode">std::ios::binary</code>). The constructor internally calls <code class="inlineCode">open()</code> on the underlying <code class="inlineCode">std::basic_filebuf</code> object. To check whether the stream has been successfully associated with a file device, we use <code class="inlineCode">is_open()</code> (this internally calls the method with the same name from the underlying <code class="inlineCode">basic_filebuf</code>). In this example, we read the entire content of the file to a memory buffer, in particular, a <code class="inlineCode">std::vector</code>. Before we can read the data, we must know the size of the file in order to allocate a buffer that is large enough to hold that data. To do this, we used <code class="inlineCode">seekg()</code> to move the input position indicator to the end of the file.</p>
<p class="normal">Then, we called <code class="inlineCode">tellg()</code> to return the current position, which, in this case, indicates the size of the file, in bytes, and then we moved the input position indicator to the beginning of the file to be able to start reading from the beginning. Calling <code class="inlineCode">seekg()</code> to move the position indicator to the end can be avoided by opening the file with the position indicator moved directly to the end. This can be achieved by using the <code class="inlineCode">std::ios::ate</code> opening flag in the constructor (or the <code class="inlineCode">open()</code> method). After allocating enough memory<a id="_idIndexMarker831"/> for the content of the file, we copied the data from the file into memory using the <code class="inlineCode">read()</code> method. This takes a pointer to the string of characters that receives the data read from the stream and the number of characters to be read. Since the stream operates on characters, a <code class="inlineCode">reinterpret_cast</code> expression is necessary if the buffer contains other types of data, such as <code class="inlineCode">unsigned char</code> in our example.</p>
<p class="normal">This <a id="_idIndexMarker832"/>operation throws a <code class="inlineCode">std::basic_ios::failure</code> exception if an error occurs. To determine the number of characters that have been successfully read from the stream, we can use the <code class="inlineCode">gcount()</code> method. Upon completing the read operation, we close the file stream.</p>
<div><p class="normal">An alternative to the use of the <code class="inlineCode">seekg()</code>/<code class="inlineCode">tellg()</code> approach described here for determining the size of an open file is to use the <code class="inlineCode">std::filesystem::file_size()</code> function from the filesystem library. This requires a path only; it does not need the file to be opened. It can also determine the size of a directory, but this is implementation-defined. This function is presented later in the chapter in the <em class="italic">Checking the properties of an existing file or directory</em> recipe.</p>
</div>
<p class="normal">The operations shown in these examples are the minimum ones required to write and read data to and from file streams. It is important, though, that you perform appropriate checks for the success of the operations and to catch any possible exceptions that could occur.</p>
<p class="normal">An important thing to notice is the value of the argument representing the number of characters to write or read. In the examples seen so far, we have used buffers of <code class="inlineCode">unsigned char</code>. The size of <code class="inlineCode">unsigned char</code> is 1, as with <code class="inlineCode">char</code>. Therefore, the count of characters is the number of elements in the buffer. However, if the buffer contains <code class="inlineCode">int</code> elements, for instance, things change. An <code class="inlineCode">int</code> is, typically, 32-bit, which means that, reinterpreted as <code class="inlineCode">char</code>, it is equivalent to 4 characters. This means that when we write anything that has a size greater than 1, we need to multiply the number of elements by the size of an element, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
std::ofstream ofile("sample.bin", std::ios::binary);
if (ofile.is_open())
{
   ofile.write(reinterpret_cast&lt;char*&gt;(numbers.data()), 
               numbers.size() * sizeof(int));
   ofile.close();
}
</code></pre>
<p class="normal">Similarly, when<a id="_idIndexMarker833"/> we read, we need to account for the size of the elements we read from the file, which is exemplified next:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; input;
std::ifstream ifile("sample.bin", std::ios::binary);
if (ifile.is_open())
{
   ifile.seekg(0, std::ios_base::end);
   auto length = ifile.tellg();
   ifile.seekg(0, std::ios_base::beg);
   input.resize(static_cast&lt;size_t&gt;(length) / sizeof(int));
   ifile.read(reinterpret_cast&lt;char*&gt;(input.data()), length);
   assert(!ifile.fail() &amp;&amp; length == ifile.gcount());
   ifile.close();
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker834"/>example code discussed so far in this recipe can be reorganized in the form of two general functions for writing and reading data to and from a file:</p>
<pre class="programlisting code"><code class="hljs-code">bool write_data(char const * const filename,
 char const * const data,
 size_t const size)
{
  auto success = false;
  std::ofstream ofile(filename, std::ios::binary);
  if(ofile.is_open())
  {
    try
    {
      ofile.write(data, size);
      success = true;
    }
    catch(std::ios_base::failure &amp;)
    {
      // handle the error
    }
    ofile.close();
  }
  return success;
}
size_t read_data(char const * const filename,
                 std::function&lt;char*(size_t const)&gt; allocator)
{
  size_t readbytes = 0;
  std::ifstream ifile(filename, std::ios::ate | std::ios::binary);
  if(ifile.is_open())
  {
    auto length = static_cast&lt;size_t&gt;(ifile.tellg());
    ifile.seekg(0, std::ios_base::beg);
    auto buffer = allocator(length);
    try
    {
      ifile.read(buffer, length);
      readbytes = static_cast&lt;size_t&gt;(ifile.gcount());
    }
    catch (std::ios_base::failure &amp;)
    {
      // handle the error
    }
    ifile.close();
  }
  return readbytes;
}
</code></pre>
<p class="normal"><code class="inlineCode">write_data()</code> is a <a id="_idIndexMarker835"/>function that takes the name of a file, a pointer to an array of characters, and the length of this array as arguments <a id="_idIndexMarker836"/>and writes the characters to the specified file. <code class="inlineCode">read_data()</code> is a function that takes the name of a file and a function that allocates a buffer and reads the entire content of the file to the buffer that is returned by the allocated function. The following is an example of how these functions can be used:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; output {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector&lt;int&gt; input;
if(write_data("sample.bin",
              reinterpret_cast&lt;char*&gt;(output.data()),
              output.size() * sizeof(int)))
{
  auto lalloc = [&amp;input](size_t const length) 
  {
    input.resize(length) / sizeof(int);
    return reinterpret_cast&lt;char*&gt;(input.data());
 };
  if(read_data("sample.bin", lalloc) &gt; 0)
  {
    std::cout &lt;&lt; (output == input ? "equal": "not equal")
              &lt;&lt; '\n';
  }
}
</code></pre>
<p class="normal">Alternatively, we<a id="_idIndexMarker837"/> could use a dynamically allocated <a id="_idIndexMarker838"/>buffer, instead of the <code class="inlineCode">std::vector</code>; the changes required for this are small in the overall example:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; output {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
std::unique_ptr&lt;int[]&gt; input = nullptr;
size_t readb = 0;
if(write_data("sample.bin",
              reinterpret_cast&lt;char*&gt;(output.data()),
              output.size() * sizeof(int)))
{
  if((readb = read_data(
     "sample.bin",
     [&amp;input](size_t const length) {
       input.reset(new int[length / sizeof(int)]);
       return reinterpret_cast&lt;char*&gt;(input.get()); })) &gt; 0)
  {
    auto cmp = memcmp(output.data(), input.get(), output.size());
    std::cout &lt;&lt; (cmp == 0 ? "equal": "not equal") &lt;&lt; '\n';
  }
}
</code></pre>
<p class="normal">However, this alternative is only provided to show that <code class="inlineCode">read_data()</code> can be used with different kinds <a id="_idIndexMarker839"/>of input buffers. It is recommended that you avoid the explicit dynamic allocation of <a id="_idIndexMarker840"/>memory whenever possible.</p>
<h2 class="heading-2" id="_idParaDest-431">There’s more...</h2>
<p class="normal">The way of reading data from a file to memory, as shown in this recipe, is only one of several. The following is a list of possible alternatives for reading data from a file stream:</p>
<ul>
<li class="bulletList">Initializing a <code class="inlineCode">std::vector</code> directly using <code class="inlineCode">std::istreambuf_iterator</code> iterators (similarly, this can be used with <code class="inlineCode">std::string</code>):
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;unsigned char&gt; input;
std::ifstream ifile("sample.bin", std::ios::binary);
if(ifile.is_open())
{
  input = std::vector&lt;unsigned char&gt;(
    std::istreambuf_iterator&lt;char&gt;(ifile),
    std::istreambuf_iterator&lt;char&gt;());
  ifile.close();
}
</code></pre>
</li>
<li class="bulletList">Assigning the content of a <code class="inlineCode">std::vector</code> from <code class="inlineCode">std::istreambuf_iterator</code> iterators:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;unsigned char&gt; input;
std::ifstream ifile("sample.bin", std::ios::binary);
if(ifile.is_open())
{
  ifile.seekg(0, std::ios_base::end);
  auto length = ifile.tellg();
  ifile.seekg(0, std::ios_base::beg);
  input.reserve(static_cast&lt;size_t&gt;(length));
    input.assign(
    std::istreambuf_iterator&lt;char&gt;(ifile),
    std::istreambuf_iterator&lt;char&gt;());
  ifile.close();
}
</code></pre>
</li>
<li class="bulletList">Copying the content of the file stream to a vector using <code class="inlineCode">std::istreambuf_iterator</code> iterators and a <code class="inlineCode">std::back_inserter</code> adapter to write to the end of the vector:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;unsigned char&gt; input;
std::ifstream ifile("sample.bin", std::ios::binary);
if(ifile.is_open())
{
  ifile.seekg(0, std::ios_base::end);
  auto length = ifile.tellg();
  ifile.seekg(0, std::ios_base::beg);
  input.reserve(static_cast&lt;size_t&gt;(length));
  std::copy(std::istreambuf_iterator&lt;char&gt;(ifile),
            std::istreambuf_iterator&lt;char&gt;(),
            std::back_inserter(input));
  ifile.close();
}
</code></pre>
</li>
</ul>
<p class="normal">Compared <a id="_idIndexMarker841"/>to these alternatives, however, the method <a id="_idIndexMarker842"/>described in the <em class="italic">How to do it...</em> section is the fastest one, even though the alternatives may look more appealing from an object-oriented perspective. It is beyond the scope of this recipe to compare the performance of these alternatives, but you can try it as an exercise.</p>
<h2 class="heading-2" id="_idParaDest-432">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Reading and writing objects from/to binary files</em>, to learn how to serialize and deserialize objects to and from binary files</li>
<li class="bulletList"><em class="italic">Using I/O manipulators to control the output of a stream</em>, to learn about the use of helper functions, called manipulators, that control input and output streams using the <code class="inlineCode">&lt;&lt;</code> and <code class="inlineCode">&gt;&gt;</code> stream operators</li>
</ul>
<h1 class="heading-1" id="_idParaDest-433">Reading and writing objects from/to binary files</h1>
<p class="normal">In the <a id="_idIndexMarker843"/>previous recipe, we learned how to write and<a id="_idIndexMarker844"/> read raw data (that is, unstructured data) to and from a file. Many times, however, we must persist and load objects instead. Writing and reading in the manner shown in the previous recipe works for POD types only. For anything else, we must explicitly decide what is actually written or read, since writing or reading pointers (including those to virtual tables) and any sort of metadata is not only irrelevant but also semantically wrong. These operations are commonly referred to as serialization and deserialization. In this recipe, we will learn how to serialize and deserialize both POD and non-POD types to and from binary files.</p>
<h2 class="heading-2" id="_idParaDest-434">Getting ready</h2>
<p class="normal">For the <a id="_idIndexMarker845"/>examples in this recipe, we will use the <code class="inlineCode">foo</code> and <code class="inlineCode">foopod</code> classes, as <a id="_idIndexMarker846"/>follows:</p>
<pre class="programlisting code"><code class="hljs-code">class foo
{
  int         i;
  char        c;
  std::string s;
public:
  foo(int const i = 0, char const c = 0, std::string const &amp; s = {}):
    i(i), c(c), s(s)
  {}
  foo(foo const &amp;) = default;
  foo&amp; operator=(foo const &amp;) = default;
  bool operator==(foo const &amp; rhv) const
  {
    return i == rhv.i &amp;&amp;
           c == rhv.c &amp;&amp;
           s == rhv.s;
  }
  bool operator!=(foo const &amp; rhv) const
  {
    return !(*this == rhv);
  }
};
struct foopod
{
  bool a;
  char b;
  int  c[2];
};
bool operator==(foopod const &amp; f1, foopod const &amp; f2)
{
  return f1.a == f2.a &amp;&amp; f1.b == f2.b &amp;&amp;
         f1.c[0] == f2.c[0] &amp;&amp; f1.c[1] == f2.c[1];
}
</code></pre>
<p class="normal">It is recommended that <a id="_idIndexMarker847"/>you first read the previous recipe, <em class="italic">Reading and writing raw data from/to binary files</em>, before you continue. You should also <a id="_idIndexMarker848"/>know what POD (a type that is both trivial and has a standard layout) and non-POD types are and how operators can be overloaded. You can check the closing notes of the <em class="italic">Using type traits to query properties of types</em> recipe, in <em class="chapterRef">Chapter 6</em>, <em class="italic">General-Purpose Utilities</em>, for further details on POD types.</p>
<h2 class="heading-2" id="_idParaDest-435">How to do it...</h2>
<p class="normal">To serialize/deserialize POD types that do not contain pointers, use <code class="inlineCode">ofstream::write()</code> and <code class="inlineCode">ifstream::read()</code>, as shown in the previous recipe:</p>
<ul>
<li class="bulletList">Serialize objects to a binary file using <code class="inlineCode">ofstream</code> and the <code class="inlineCode">write()</code> method:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;foopod&gt; output {
  {true, '1', {1, 2}},
  {true, '2', {3, 4}},
  {false, '3', {4, 5}}
};
std::ofstream ofile("sample.bin", std::ios::binary);
if(ofile.is_open())
{
  for(auto const &amp; value : output)
  {
    ofile.write(reinterpret_cast&lt;const char*&gt;(&amp;value),
                sizeof(value));
  }
  ofile.close();
}
</code></pre>
</li>
<li class="bulletList">Deserialize objects from a binary file using the <code class="inlineCode">ifstream</code> and <code class="inlineCode">read()</code> methods:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;foopod&gt; input;
std::ifstream ifile("sample.bin", std::ios::binary);
if(ifile.is_open())
{
  while(true)
  {
    foopod value;
    ifile.read(reinterpret_cast&lt;char*&gt;(&amp;value), sizeof(value));
    if(ifile.fail() || ifile.eof()) break;
    input.push_back(value);
  }
  ifile.close();
}
</code></pre>
</li>
</ul>
<p class="normal">To serialize<a id="_idIndexMarker849"/> non-POD types (or POD types that contain pointers), you must explicitly write the value of the data members to a file, and to <a id="_idIndexMarker850"/>deserialize, you must explicitly read from the file to the data members in the same order. To demonstrate this, we will consider the <code class="inlineCode">foo</code> class that we defined earlier:</p>
<ul>
<li class="bulletList">Add a member function called <code class="inlineCode">write()</code> to serialize objects of this class. The method takes a reference to an <code class="inlineCode">ofstream</code> and returns a <code class="inlineCode">bool</code> indicating whether the operation was successful or not:
        <pre class="programlisting code"><code class="hljs-code">bool write(std::ofstream&amp; ofile) const
{
  ofile.write(reinterpret_cast&lt;const char*&gt;(&amp;i), sizeof(i));
  ofile.write(&amp;c, sizeof(c));
  auto size = static_cast&lt;int&gt;(s.size());
  ofile.write(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size));
  ofile.write(s.data(), s.size());
  return !ofile.fail();
}
</code></pre>
</li>
<li class="bulletList">Add a member function called <code class="inlineCode">read()</code> to deserialize the objects of this class. This method takes a reference to an <code class="inlineCode">ifstream</code> and returns a <code class="inlineCode">bool</code> indicating whether the operation was successful or not:
        <pre class="programlisting code"><code class="hljs-code">bool read(std::ifstream&amp; ifile)
{
  ifile.read(reinterpret_cast&lt;char*&gt;(&amp;i), sizeof(i));
  ifile.read(&amp;c, sizeof(c));
  auto size {0};
  ifile.read(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size));
  s.resize(size);
  ifile.read(reinterpret_cast&lt;char*&gt;(&amp;s.front()), size);
  return !ifile.fail();
}
</code></pre>
</li>
</ul>
<p class="normal">An<a id="_idIndexMarker851"/> alternative to the <code class="inlineCode">write()</code> and <code class="inlineCode">read()</code> member <a id="_idIndexMarker852"/>functions demonstrated earlier is to overload <code class="inlineCode">operator&lt;&lt;</code> and <code class="inlineCode">operator&gt;&gt;</code>. To do this, you should perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Add <code class="inlineCode">friend</code> declarations for the non-member <code class="inlineCode">operator&lt;&lt;</code> and <code class="inlineCode">operator&gt;&gt;</code> to the class to be serialized/deserialized (in this case, the <code class="inlineCode">foo</code> class):
        <pre class="programlisting code"><code class="hljs-code">friend std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; ofile, foo const&amp; f);
friend std::ifstream&amp; operator&gt;&gt;(std::ifstream&amp; ifile, foo&amp; f);
</code></pre>
</li>
<li class="numberedList">Overload <code class="inlineCode">operator&lt;&lt;</code> for your class:
        <pre class="programlisting code"><code class="hljs-code">std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; ofile, foo const&amp; f)
{
  ofile.write(reinterpret_cast&lt;const char*&gt;(&amp;f.i),
              sizeof(f.i));
  ofile.write(&amp;f.c, sizeof(f.c));
  auto size = static_cast&lt;int&gt;(f.s.size());
  ofile.write(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size));
  ofile.write(f.s.data(), f.s.size());
  return ofile;
}
</code></pre>
</li>
<li class="numberedList">Overload <code class="inlineCode">operator&gt;&gt;</code> for your class:
        <pre class="programlisting code"><code class="hljs-code">std::ifstream&amp; operator&gt;&gt;(std::ifstream&amp; ifile, foo&amp; f)
{
  ifile.read(reinterpret_cast&lt;char*&gt;(&amp;f.i), sizeof(f.i));
  ifile.read(&amp;f.c, sizeof(f.c));
  auto size {0};
  ifile.read(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size));
  f.s.resize(size);
  ifile.read(reinterpret_cast&lt;char*&gt;(&amp;f.s.front()), size);
  return ifile;
}
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-436">How it works...</h2>
<p class="normal">Regardless<a id="_idIndexMarker853"/> of <a id="_idIndexMarker854"/>whether we serialize the entire object (for POD types) or only parts of it, we use the same stream classes that we discussed in the previous recipe: <code class="inlineCode">ofstream</code> for output file streams and <code class="inlineCode">ifstream</code> for input file streams. Details about writing and reading data using these standard classes have been discussed in that recipe and will not be reiterated here.</p>
<p class="normal">When you serialize and deserialize objects to and from files, you should avoid writing the values of the pointers to a file. Additionally, you must not read pointer values from the file since these represent memory addresses and are meaningless across processes, and even in the same process some moments later. Instead, you should write data referred by a pointer and read data into objects referred by a pointer.</p>
<p class="normal">This is a general principle, and, in practice, you may encounter situations where a source may have multiple pointers to the same object; in this case, you might want to write only one copy and also handle the reading in a corresponding manner.</p>
<p class="normal">If the objects you want to serialize are of the POD type, you can do it just like we did when we discussed raw data. In the example in this recipe, we serialized a sequence of objects of the <code class="inlineCode">foopod</code> type. When we deserialize, we read from the file stream in a loop until the end of the file is read or a failure occurs. The way we read, in this case, may look counterintuitive, but doing it differently may lead to the duplication of the last read value:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Reading is done in an infinite loop.</li>
<li class="numberedList">A read operation is performed in the loop.</li>
<li class="numberedList">A check for a failure or the end of file is performed, and if either of them has occurred, the infinite loop is exited.</li>
<li class="numberedList">The value is added to the input sequence and the looping continues.</li>
</ol>
<p class="normal">If reading is done using a loop with an exit condition that checks the end of the file bit, that is, <code class="inlineCode">while(!ifile.eof())</code>, the last value will be added to the input sequence twice. The reason for this is that upon reading the last value, the end of the file has not yet been encountered (as that is a mark beyond the last byte of the file). The end of the file mark is only<a id="_idIndexMarker855"/> reached at the next read attempt, which, therefore, sets the <code class="inlineCode">eofbit</code> of the stream. However, the input variable still has the last value since it hasn’t been overwritten with anything, and this is added to the input vector for a second time.</p>
<p class="normal">If the <a id="_idIndexMarker856"/>objects you want to serialize and deserialize are of non-POD types, writing/reading these objects as raw data is not possible. For instance, such an object may have a virtual table. Writing the virtual table to a file does not cause problems, even though it does not have any value; however, reading from a file, and, therefore, overwriting the virtual table of an object, will have catastrophic effects on the object and the program.</p>
<p class="normal">When serializing/deserializing non-POD types, there are various alternatives, and some of them have been discussed in the previous section. All of them provide explicit methods for writing and reading or overloading the standard <code class="inlineCode">&lt;&lt;</code> and <code class="inlineCode">&gt;&gt;</code> operators. The second approach has an advantage in that it enables the use of your class in generic code, where objects are written and read to and from stream files using these operators.</p>
<div><p class="normal">When you plan to serialize and deserialize your objects, consider versioning your data from the very beginning to avoid problems if the structure of your data changes over time. How versioning should be done is beyond the scope of this recipe.</p>
</div>
<h2 class="heading-2" id="_idParaDest-437">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Reading and writing raw data from/to binary files</em>, to learn how to write and read unstructured data to binary files</li>
<li class="bulletList"><em class="italic">Using I/O manipulators to control the output of a stream</em>, to learn about the use of helper functions, called manipulators, that control input and output streams using the <code class="inlineCode">&lt;&lt;</code> and <code class="inlineCode">&gt;&gt;</code> stream operators</li>
</ul>
<h1 class="heading-1" id="_idParaDest-438">Using streams on fixed-size external buffers</h1>
<p class="normal">The <code class="inlineCode">&lt;strstream&gt;</code> header<a id="_idIndexMarker857"/> has been part of the standard I/O library from its beginning. It contains classes that provide stream operations on sequences of characters stored in an array. However, this header was<a id="_idIndexMarker858"/> deprecated a long time ago, in C++98, although it’s still available because a replacement wasn’t available. The C++20 standard has introduced the <code class="inlineCode">std::span</code> class, which is a non-owning view of a sequence of objects. In C++23, a new header, <code class="inlineCode">&lt;spanstream&gt;</code>, has been added as a replacement for <code class="inlineCode">&lt;strstream&gt;</code>. This contains classes that provide stream operations on externally provided memory buffers. In this recipe, we’ll learn how to parse or write text using the I/O span streams.</p>
<h2 class="heading-2" id="_idParaDest-439">How to do it…</h2>
<p class="normal">Use the new C++23 span streams as follows:</p>
<ul>
<li class="bulletList">To parse text from an external array, use <code class="inlineCode">std::ispanstream</code>:
        <pre class="programlisting code"><code class="hljs-code">char text[] = "1 1 2 3 5 8";
std::ispanstream is{ std::span&lt;char&gt;{text} };
int value;
while (is &gt;&gt; value)
{
   std::cout &lt;&lt; value &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">To write text to an external array, use <code class="inlineCode">std::ospanstream</code>:
        <pre class="programlisting code"><code class="hljs-code">char text[15]{};
int numbers[]{ 1, 1, 2, 3, 5, 8 };
std::ospanstream os{ std::span&lt;char&gt;{text} };         
for (int n : numbers)
{
   os &lt;&lt; n &lt;&lt; ' ';
}
</code></pre>
</li>
<li class="bulletList">To both read and write to the same external array, use <code class="inlineCode">std::spanstream</code>:
        <pre class="programlisting code"><code class="hljs-code">char text[] = "1 1 2 3 5 8 ";
std::vector&lt;int&gt; numbers;
std::spanstream ss{ std::span&lt;char&gt;{text} };
int value;
while (ss &gt;&gt; value)
{
   numbers.push_back(value);
}
ss.clear();
ss.seekp(0);
std::for_each(numbers.rbegin(), numbers.rend(), 
              [&amp;ss](const int n) { ss &lt;&lt; n &lt;&lt; ' '; });
std::cout &lt;&lt; text &lt;&lt; '\n'; // prints 8 5 3 2 1 1
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-440">How it works…</h2>
<p class="normal">Stream input/output operations <a id="_idIndexMarker859"/>can be <a id="_idIndexMarker860"/>used with externally allocated buffers. However, the <code class="inlineCode">&lt;strstream&gt;</code> header and its <code class="inlineCode">strstream</code>, <code class="inlineCode">istrstream</code>, <code class="inlineCode">ostrstream</code>, and <code class="inlineCode">strstreambuf</code> classes were deprecated in C++98 without any replacement available. The reasons for deprecating them include safety, since <code class="inlineCode">strstreambuf</code> does not enforce bounds checking, and inflexibility, due to its limitations in resizing the underlying buffer. The <code class="inlineCode">std::stringstream</code> was the only recommended alternative.</p>
<p class="normal">In C++23, a new set of similar classes is available in the new <code class="inlineCode">&lt;spanstream&gt;</code> header: <code class="inlineCode">basic_spanstream</code>, <code class="inlineCode">basic_ispanstream</code>, <code class="inlineCode">basic_ospanstream</code>, and <code class="inlineCode">basic_spanbuf</code>. These enable stream operations on externally allocated fixed-size buffers. These classes do not provide support for ownership or reallocation of the buffer. For such scenarios, <code class="inlineCode">std::stringstream</code> should be used.</p>
<p class="normal">The <code class="inlineCode">std::basic_spanbuf</code> controls input and output to a sequence of characters. Its associated sequence (the source for input, and the sink for output) is an externally allocated buffer of a fixed size that can be initialized from or made available as a <code class="inlineCode">std::span</code>. This is wrapped by the <code class="inlineCode">std::basic_ispanstream</code>, <code class="inlineCode">std::basic_ospanstream</code>, and <code class="inlineCode">std::basic_spanstream</code>, which provide higher-level interfaces for input/output operations, as defined by the <code class="inlineCode">std::basic_istream</code>, <code class="inlineCode">std::basic_ostream</code>, and <code class="inlineCode">std::basic_stream</code> classes.</p>
<p class="normal">Let’s take another example to look at this. Consider we have a string that contains a sequence of key-value pairs separated by a comma. We want to read these pairs and put them in a map. We can write the following code in C++23:</p>
<pre class="programlisting code"><code class="hljs-code">char const text[] = "severity=1,code=42,message=generic error";
std::unordered_map&lt;std::string, std::string&gt; m;
std::string key, val;
std::ispanstream is(text);
while (std::getline(is, key, '=') &gt;&gt; std::ws)
{
   if(std::getline(is, val, ','))
      m[key] = val;
}
for (auto const &amp; [k, v] : m)
{
   std::cout &lt;&lt; k &lt;&lt; " : " &lt;&lt; v &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The <code class="inlineCode">std::getline()</code> function <a id="_idIndexMarker861"/>allows us to read characters from an input stream either until its end or until a specified delimiter is <a id="_idIndexMarker862"/>encountered. Using it, we split the text first using the <code class="inlineCode">=</code> and <code class="inlineCode">,</code> delimiters. The sequence of characters until <code class="inlineCode">=</code> represents the key, and everything after <code class="inlineCode">=</code> until the next comma or the end is the value. <code class="inlineCode">std::ws</code> is an I/O manipulator that discards whitespaces from an input stream. In simple terms, we read until we find an equals sign; all the text until there is the key. Then, we read until we find a comma (or reach the end); all the text until there is the value. We do this in a loop as long as we keep encountering an equals sign.</p>
<p class="normal">Reading from a fixed-size buffer is not very difficult, but writing requires more checks because writing cannot exceed the bounds of the buffer, in which case, a write operation fails. Let’s take an example to understand this better:</p>
<pre class="programlisting code"><code class="hljs-code">char text[3]{};
std::ospanstream os{ std::span&lt;char&gt;{text} };
os &lt;&lt; "42";
auto pos = os.tellp();
os &lt;&lt; "44";
if (!os.good())
{
   os.clear();
   os.seekp(pos);
}
// text is {'4','2','4'}
// prints (examples): 424╠╠╠╠╠... or 424MƂ<img alt="" src="img/11.png"/> etc.
std::cout &lt;&lt; text &lt;&lt; '\n';
os &lt;&lt; '\0';
// text is {'4','2','\0'}
// prints: 42
std::cout &lt;&lt; text &lt;&lt; '\n';
</code></pre>
<p class="normal">The <a id="_idIndexMarker863"/>external array has 3 bytes. We write the text <code class="inlineCode">42</code>, and this operation succeeds. Then, we attempt to write the text <code class="inlineCode">44</code>. However, this would require that the external buffer has 4 bytes, but it only has 3. Therefore, after <a id="_idIndexMarker864"/>writing the character <code class="inlineCode">4</code>, the operation fails. At this point, the content of the text buffer is <code class="inlineCode">'</code><code class="inlineCode">4'</code>,<code class="inlineCode">'2'</code>,<code class="inlineCode">'4'</code>, and there is no null-terminating character. If we print this to the console, after <code class="inlineCode">424</code>, there will be some gibberish based on the content found in memory until the first 0. </p>
<p class="normal">To check whether the writing operation failed, we use the <code class="inlineCode">good()</code> member function. If this returns <code class="inlineCode">false</code>, then we need to clear the error flags. We also set the stream’s output position indicator to the value it had before attempting the read (which can be retrieved with the <code class="inlineCode">tellp()</code> member function). At this point, if we write a <code class="inlineCode">0</code> to the output buffer, its content will be <code class="inlineCode">'4'</code>,<code class="inlineCode">'2'</code>,<code class="inlineCode">'\0'</code>, so printing it to the console will show the text <code class="inlineCode">42</code>.</p>
<p class="normal">If you want to both read and write to the same buffer, you can use the <code class="inlineCode">std::spanstream</code> class, which provides both input and output stream operations. An example was shown in the <em class="italic">How to do it…</em> section.</p>
<h2 class="heading-2" id="_idParaDest-441">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 6</em>, <em class="italic">Using std::span for contiguous sequences of objects</em>, to learn how to use non-owning views over contiguous sequences of elements</li>
</ul>
<h1 class="heading-1" id="_idParaDest-442">Using localized settings for streams</h1>
<p class="normal">How <a id="_idIndexMarker865"/>writing or reading to and from streams is performed may depend on the language and regional settings. Examples include writing and parsing numbers, time values, or monetary values, or comparing (collating) strings. The C++ I/O library provides a general-purpose mechanism for handling internationalization features through <em class="italic">locales</em> and <em class="italic">facets</em>. In this recipe, you will learn how to use locales to control the behavior of input/output streams.</p>
<h2 class="heading-2" id="_idParaDest-443">Getting ready</h2>
<p class="normal">All of the <a id="_idIndexMarker866"/>examples in this recipe use the <code class="inlineCode">std::cout</code> predefined console stream object. However, the same applies to all I/O stream objects. Also, in these recipe examples, we will use the following objects and lambda function:</p>
<pre class="programlisting code"><code class="hljs-code">auto now = std::chrono::system_clock::now();
auto stime = std::chrono::system_clock::to_time_t(now);
auto ltime = std::localtime(&amp;stime);
std::vector&lt;std::string&gt; names
  {"John", "adele", "Øivind", "François", "Robert", "Åke"};
auto sort_and_print = [](std::vector&lt;std::string&gt; v,
                         std::locale const &amp; loc)
{
  std::sort(v.begin(), v.end(), loc);
  for (auto const &amp; s : v) std::cout &lt;&lt; s &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
};
</code></pre>
<p class="normal">The names Øivind and Åke contain the Danish/Norwegian-specific characters Ø and Å. In the Danish/Norwegian alphabet, these are the last two letters (in this order) of the alphabet. These are used to exemplify the effect of using locales.</p>
<p class="normal">The locale names used in this recipe (<code class="inlineCode">en_US.utf8</code>, <code class="inlineCode">de_DE.utf8</code>, and so on) are the ones that are used on UNIX systems. The following table lists their equivalents for Windows systems:</p>
<table class="table-container" id="table001-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">UNIX</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Windows</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">en_US.utf8</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">English_US.1252</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">en_GB.utf8</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">English_UK.1252</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">de_DE.utf8</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">German_Germany.1252</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">no_NO.utf8</code></p>
</td>
<td class="table-cell">
<p class="normal"> <code class="inlineCode">Norwegian_Norway.1252</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 7.1: List of UNIX and Windows names of locales used in this recipe</p>
<h2 class="heading-2" id="_idParaDest-444">How to do it...</h2>
<p class="normal">To control the <a id="_idIndexMarker867"/>localization settings of a stream, you <a id="_idIndexMarker868"/>must do the following:</p>
<ul>
<li class="bulletList">Use the <code class="inlineCode">std::locale</code> class to represent the localization settings. There are various ways in which to construct locale objects, including the following:<ul>
<li class="bulletList">Default construct is to use the global locale (by default, the <code class="inlineCode">C</code> locale at the program startup)</li>
<li class="bulletList">From a local name, such as <code class="inlineCode">C</code>, <code class="inlineCode">POSIX,</code> <code class="inlineCode">en_US.utf8</code>, and so on, if supported by the operating system</li>
<li class="bulletList">From another locale, except for a specified facet</li>
<li class="bulletList">From another locale, except for all of the facets from a specified category that are copied from another specified locale:
            <pre class="programlisting code"><code class="hljs-code">// default construct
auto loc_def = std::locale {};
// from a name
auto loc_us = std::locale {"en_US.utf8"};
// from another locale except for a facet
auto loc1 = std::locale {loc_def, new std::collate&lt;wchar_t&gt;};
// from another local, except the facet in a category
auto loc2 = std::locale {loc_def, loc_us, std::locale::collate};
</code></pre>
</li>
</ul>
</li>
<li class="bulletList">To get a copy of the default <code class="inlineCode">C</code> locale, use the <code class="inlineCode">std::locale::classic()</code> static method:
        <pre class="programlisting code"><code class="hljs-code">auto loc = std::locale::classic();
</code></pre>
</li>
<li class="bulletList">To change the default locale that is copied every time a locale is default-constructed, use the <code class="inlineCode">std::locale::global()</code> static method:
        <pre class="programlisting code"><code class="hljs-code">std::locale::global(std::locale("en_US.utf8"));
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">imbue()</code> method to change the current locale of an I/O stream:
        <pre class="programlisting code"><code class="hljs-code">std::cout.imbue(std::locale("en_US.utf8"));
</code></pre>
</li>
</ul>
<p class="normal">The <a id="_idIndexMarker869"/>following<a id="_idIndexMarker870"/> list shows examples of using various locales:</p>
<ul>
<li class="bulletList">Use a particular locale, indicated by its name. In this example, the locale is for German:
        <pre class="programlisting code"><code class="hljs-code">auto loc = std::locale("de_DE.utf8");
std::cout.imbue(loc);
std::cout &lt;&lt; 1000.50 &lt;&lt; '\n';
// 1.000,5
std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(1050) &lt;&lt; '\n';
// 10,50 €
std::cout &lt;&lt; std::put_time(ltime, "%c") &lt;&lt; '\n';
// So 04 Dez 2016 17:54:06 JST
sort_and_print(names, loc);
// adele Åke François John Øivind Robert
</code></pre>
</li>
<li class="bulletList">Use a locale that corresponds to the user settings (as defined in the system). This is done by constructing a <code class="inlineCode">std::locale</code> object from an empty string:
        <pre class="programlisting code"><code class="hljs-code">auto loc = std::locale("");
std::cout.imbue(loc);
std::cout &lt;&lt; 1000.50 &lt;&lt; '\n';
// 1,000.5
std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(1050) &lt;&lt; '\n';
// $10.50
std::cout &lt;&lt; std::put_time(ltime, "%c") &lt;&lt; '\n';
// Sun 04 Dec 2016 05:54:06 PM JST
sort_and_print(names, loc);
// adele Åke François John Øivind Robert
</code></pre>
</li>
<li class="bulletList">Set and <a id="_idIndexMarker871"/>use the global locale:
        <pre class="programlisting code"><code class="hljs-code">std::locale::global(std::locale("no_NO.utf8")); // set global
auto loc = std::locale{};                       // use global
std::cout.imbue(loc);
std::cout &lt;&lt; 1000.50 &lt;&lt; '\n';
// 1 000,5
std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(1050) &lt;&lt; '\n';
// 10,50 kr
std::cout &lt;&lt; std::put_time(ltime, "%c") &lt;&lt; '\n';
// sön 4 dec 2016 18:02:29
sort_and_print(names, loc);
// adele François John Robert Øivind Åke 
</code></pre>
</li>
<li class="bulletList">Use the <a id="_idIndexMarker872"/>default <code class="inlineCode">C</code> locale:
        <pre class="programlisting code"><code class="hljs-code">auto loc = std::locale::classic();
std::cout.imbue(loc);
std::cout &lt;&lt; 1000.50 &lt;&lt; '\n';
// 1000.5
std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(1050) &lt;&lt; '\n';
// 1050
std::cout &lt;&lt; std::put_time(ltime, "%c") &lt;&lt; '\n';
// Sun Dec 4 17:55:14 2016
sort_and_print(names, loc);
// François John Robert adele Åke Øivind
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-445">How it works...</h2>
<p class="normal">A locale object does not actually store localized settings. A <em class="italic">locale</em> is a<a id="_idIndexMarker873"/> heterogeneous container of facets. A <em class="italic">facet</em> is an<a id="_idIndexMarker874"/> object that defines the localization and internationalization settings. The standard defines a list of facets that each locale must contain. In addition to this, a locale can contain any other user-defined facets. The following is a list of all <a id="_idIndexMarker875"/>standard-defined facets:</p>
<table class="table-container" id="table002-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::collate&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::collate&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::ctype&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::ctype&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::codecvt&lt;char,char,mbstate_t&gt;</code></p>
<p class="normal"><code class="inlineCode">std::codecvt&lt;char16_t,char,mbstate_t&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::codecvt&lt;char32_t,char,mbstate_t&gt;</code></p>
<p class="normal"><code class="inlineCode">std::codecvt&lt;wchar_t,char,mbstate_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::moneypunct&lt;char&gt;</code></p>
<p class="normal"><code class="inlineCode">std::moneypunct&lt;char,true&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::moneypunct&lt;wchar_t&gt;</code></p>
<p class="normal"><code class="inlineCode">std::moneypunct&lt;wchar_t,true&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::money_get&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::money_get&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::money_put&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::money_put&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::numpunct&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::numpunct&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::num_get&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::num_get&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::num_put&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::num_put&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::time_get&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::time_get&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::time_put&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::time_put&lt;wchar_t&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::messages&lt;char&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::messages&lt;wchar_t&gt;</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 7.2: List of standard facets</p>
<p class="normal">It is <a id="_idIndexMarker876"/>beyond the <a id="_idIndexMarker877"/>scope of this recipe to go through this list and discuss all of these facets. However, we will mention that <code class="inlineCode">std::money_get</code> is a facet that encapsulates the rules for parsing monetary values from character streams, while <code class="inlineCode">std::money_put</code> is a facet that encapsulates the rules for formatting monetary values as strings. In a similar manner, <code class="inlineCode">std::time_get</code> encapsulates rules for data and time parsing, while <code class="inlineCode">std::time_put</code> encapsulates rules for data and time formatting. These will form the subject of the next couple of recipes.</p>
<p class="normal">A locale is an<a id="_idIndexMarker878"/> immutable object containing immutable facet objects. Locales are implemented as a reference-counted array of reference-counted pointers to facets. The array is indexed by <code class="inlineCode">std::locale::id</code>, and all facets must be derived from the base class <code class="inlineCode">std::locale::facet</code> and must have a public static member of the <code class="inlineCode">std::locale::id</code> type, called <code class="inlineCode">id</code>.</p>
<p class="normal">It is only possible <a id="_idIndexMarker879"/>to create a locale object using one of the overloaded constructors or with the <code class="inlineCode">combine()</code> method, which, as the name implies, combines the current locale with a new compile-time identifiable facet and returns a new locale object. The next example shows the use of the US English locale but with the numerical punctuation settings from the Norwegian locale:</p>
<pre class="programlisting code"><code class="hljs-code">std::locale loc = std::locale("English_US.1252")
                  .combine&lt;std::numpunct&lt;char&gt;&gt;(
                     std::locale("Norwegian_Norway.1252"));
std::cout.imbue(loc);
std::cout &lt;&lt; "en_US locale with no_NO numpunct: " &lt;&lt; 42.99 &lt;&lt; '\n';
// en_US locale with no_NO numpunct: 42,99
</code></pre>
<p class="normal">On the other hand, it is possible to determine whether a locale contains a particular facet using the <code class="inlineCode">std::has_facet()</code> function template, or to obtain a reference to a facet implemented by a particular locale using the <code class="inlineCode">std::use_facet()</code> function template.</p>
<p class="normal">In the preceding examples, we sorted a vector of strings and passed a locale object as the third argument to the <code class="inlineCode">std::sort()</code> general algorithm. This third argument is supposed to be a comparison function object. Passing a locale object works because <code class="inlineCode">std::locale</code> has an <code class="inlineCode">operator()</code> that lexicographically compares two strings using its collate facet. This is actually the only localization functionality that is directly provided by <code class="inlineCode">std::locale</code>; however, what this does is invoke the collate facet’s <code class="inlineCode">compare()</code> method, which performs the string comparison based on the facet’s rules.</p>
<p class="normal">Every program has a global locale created when the program starts. The content of this global locale is copied into every default-constructed locale. The global locale can be replaced using the static method <code class="inlineCode">std::locale::global()</code>. By default, the global locale is the <code class="inlineCode">C</code> locale, which is a locale equivalent to ANSI C’s locale with the same name. This locale was created to handle simple English text, and it is the default one in C++ that provides compatibility with C. A reference to this locale can be obtained with the static method <code class="inlineCode">std::locale::classic()</code>.</p>
<p class="normal">By default, all <a id="_idIndexMarker880"/>streams use the classic locale to write or parse text. However, it is possible to change the locale used by a stream using the stream’s <code class="inlineCode">imbue()</code> method. This is a member of the <code class="inlineCode">std::ios_base</code> class, which is the base for all I/O streams. A companion member is the <code class="inlineCode">getloc()</code> method, which returns a copy of the current stream’s locale.</p>
<div><p class="normal">In the preceding examples, we changed the locale for the <code class="inlineCode">std::cout</code> stream object. In practice, you may want to set the same locale for all stream objects associated with the standard C streams: <code class="inlineCode">cin</code>, <code class="inlineCode">cout</code>, <code class="inlineCode">cerr</code>, and <code class="inlineCode">clog</code> (or <code class="inlineCode">wcin</code>, <code class="inlineCode">wcout</code>, <code class="inlineCode">wcerr</code>, and <code class="inlineCode">wclog</code>).</p>
</div>
<p class="normal">When you <a id="_idIndexMarker881"/>want to use a particular locale (such as German or Norwegian, as shown in this recipe), you must make sure they are available on your system. On Windows, this should not be a problem, but on a Linux system, they might not be installed. In this case, trying to instantiate a <code class="inlineCode">std::locale</code> object, such as with <code class="inlineCode">std::locale("de_DE.utf8")</code>, would result in a <code class="inlineCode">std::runtime_error</code> exception being thrown. To install a locale on your system, consult its documentation to find the necessary steps you have to perform.</p>
<h2 class="heading-2" id="_idParaDest-446">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using I/O manipulators to control the output of a stream</em>, to learn about the use of helper functions, called manipulators, that control input and output streams using the <code class="inlineCode">&lt;&lt;</code> and <code class="inlineCode">&gt;&gt;</code> stream operators</li>
<li class="bulletList"><em class="italic">Using monetary I/O manipulators</em>, to learn how to use standard manipulators to write and read monetary values</li>
<li class="bulletList"><em class="italic">Using time I/O manipulators</em>, to learn how to use standard manipulators to write and read date and time values</li>
</ul>
<h1 class="heading-1" id="_idParaDest-447">Using I/O manipulators to control the output of a stream</h1>
<p class="normal">Apart from <a id="_idIndexMarker882"/>the stream-based I/O library, the standard library provides a series of helper functions, called manipulators, that control the input and output streams using <code class="inlineCode">operator&lt;&lt;</code> and <code class="inlineCode">operator&gt;&gt;</code>. In this recipe, we will look at some of these manipulators and demonstrate their use through some examples that format the output to the console. We will continue covering more manipulators in the upcoming recipes.</p>
<h2 class="heading-2" id="_idParaDest-448">Getting ready</h2>
<p class="normal">The I/O manipulators are available in the <code class="inlineCode">std</code> namespace in the headers <code class="inlineCode">&lt;ios&gt;</code>, <code class="inlineCode">&lt;istream&gt;</code>, <code class="inlineCode">&lt;ostream&gt;</code>, and <code class="inlineCode">&lt;iomanip&gt;</code>. In this recipe, we will only discuss some of the manipulators from <code class="inlineCode">&lt;ios&gt;</code> and <code class="inlineCode">&lt;iomanip&gt;</code>.</p>
<h2 class="heading-2" id="_idParaDest-449">How to do it...</h2>
<p class="normal">The following manipulators can be used to control the output or input of a stream:</p>
<ul>
<li class="bulletList"><code class="inlineCode">boolalpha</code> and <code class="inlineCode">noboolalpha</code> enable and disable the textual representation of Booleans:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::boolalpha &lt;&lt; true &lt;&lt; '\n';    // true
std::cout &lt;&lt; false &lt;&lt; '\n';                     // false
std::cout &lt;&lt; std::noboolalpha &lt;&lt; false &lt;&lt; '\n'; // 0
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">left</code>, <code class="inlineCode">right</code>, and <code class="inlineCode">internal</code> affect the alignment of the fill characters; <code class="inlineCode">left</code> and <code class="inlineCode">right</code> affect all text, but <code class="inlineCode">internal</code> affects only the integer, floating-point, and monetary output:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::right &lt;&lt; std::setw(10) &lt;&lt; "right\n";
std::cout &lt;&lt; std::setw(10) &lt;&lt; "text\n";
std::cout &lt;&lt; std::left &lt;&lt; std::setw(10) &lt;&lt; "left\n";
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">fixed</code>, <code class="inlineCode">scientific</code>, <code class="inlineCode">hexfloat</code>, and <code class="inlineCode">defaultfloat</code> change the formatting used for floating-point types (for both the input and output streams). The latter two have only been available since C++11:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::fixed &lt;&lt; 0.25 &lt;&lt; '\n';         // 0.250000
std::cout &lt;&lt; std::scientific &lt;&lt; 0.25 &lt;&lt; '\n';    // 2.500000e-01
std::cout &lt;&lt; std::hexfloat &lt;&lt; 0.25 &lt;&lt; '\n';      // 0x1p-2
std::cout &lt;&lt; std::defaultfloat &lt;&lt; 0.25 &lt;&lt; '\n';  // 0.25
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">dec</code>, <code class="inlineCode">hex</code>, and <code class="inlineCode">oct</code> control the base that is used for the integer types (in both the input and output streams):
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::oct &lt;&lt; 42 &lt;&lt; '\n'; // 52
std::cout &lt;&lt; std::hex &lt;&lt; 42 &lt;&lt; '\n'; // 2a
std::cout &lt;&lt; std::dec &lt;&lt; 42 &lt;&lt; '\n'; // 42
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">setw</code> changes <a id="_idIndexMarker883"/>the width of the next input or output field. The default width is 0.</li>
<li class="bulletList"><code class="inlineCode">setfill</code> changes the fill character for the output stream; this is the character that is used to fill the next fields until the specified width is reached. The default fill character is whitespace:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::right
          &lt;&lt; std::setfill('.') &lt;&lt; std::setw(10)
          &lt;&lt; "right" &lt;&lt; '\n';
// .....right
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">setprecision</code> changes the decimal precision (how many digits are generated) for the floating-point types in both the input and output streams. The default precision is 6:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; 12.345 &lt;&lt; '\n';
// 12.35
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-450">How it works...</h2>
<p class="normal">All of the I/O manipulators listed earlier (with the exception of <code class="inlineCode">setw</code>, which only refers to the next output field) affect the stream. Additionally, all consecutive writing or reading operations use the last specified format until another manipulator is used again.</p>
<p class="normal">Some of these manipulators are called without arguments. Examples include <code class="inlineCode">boolalpha</code>/<code class="inlineCode">noboolalpha</code> or <code class="inlineCode">dec</code>/<code class="inlineCode">hex</code>/<code class="inlineCode">oct</code>. These manipulators are functions that take a single argument (that is, a reference to a string) and return a reference to the same stream:</p>
<pre class="programlisting code"><code class="hljs-code">std::ios_base&amp; hex(std::ios_base&amp; str);
</code></pre>
<p class="normal">Expressions, such as <code class="inlineCode">std::cout &lt;&lt; std::hex</code>, are possible because both <code class="inlineCode">basic_ostream::operator&lt;&lt;</code> and <code class="inlineCode">basic_istream::operator&gt;&gt;</code> have special overloads that take a pointer to these functions.</p>
<p class="normal">Other <a id="_idIndexMarker884"/>manipulators, including some that are not mentioned here, are invoked with arguments. These manipulators are functions that take one or more arguments and return an object of an unspecified type:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class CharT&gt;
/*unspecified*/ setfill(CharT c);
</code></pre>
<p class="normal">To better demonstrate the use of these manipulators, we will consider two examples that format output to the console.</p>
<p class="normal">In the first example, we will list the table of contents of a book with the following requirements:</p>
<ul>
<li class="bulletList">The chapter number is right-aligned and shown with Roman numerals.</li>
<li class="bulletList">The chapter title is left-aligned and the remaining space until the page number is filled with dots.</li>
<li class="bulletList">The page number of the chapter is right-aligned.</li>
</ul>
<p class="normal">For this example, we will use the following classes and helper function:</p>
<pre class="programlisting code"><code class="hljs-code">struct Chapter
{
  int Number;
  std::string Title;
  int Page;
};
struct BookPart
{
  std::string Title;
  std::vector&lt;Chapter&gt; Chapters;
};
struct Book
{
  std::string Title;
  std::vector&lt;BookPart&gt; Parts;
};
std::string to_roman(unsigned int value)
{
  struct roman_t { unsigned int value; char const* numeral; };
  const static roman_t rarr[13] =
  {
    {1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"},
    { 100, "C"}, { 90, "XC"}, { 50, "L"}, { 40, "XL"},
    {  10, "X"}, {  9, "IX"}, {  5, "V"}, {  4, "IV"},
    {   1, "I"}
  };
  std::string result;
  for (auto const &amp; number : rarr)
  {
    while (value &gt;= number.value)
    {
      result += number.numeral;
      value -= number.value;
    }
  }
  return result;
}
</code>
Book</code> as its argument and prints its content to the console according to the specified requirements. For this purpose, we use the following:</pre>
<ul>
<li class="bulletList"><code class="inlineCode">std::left</code> and <code class="inlineCode">std::right</code> specify the text alignment</li>
<li class="bulletList"><code class="inlineCode">std::setw</code> specifies the width of each output field</li>
<li class="bulletList"><code class="inlineCode">std::fill</code> specifies the fill character (a blank space for the chapter number and a dot for the chapter title)</li>
</ul>
<p class="normal">The implementation of the <code class="inlineCode">print_toc()</code> function is listed here:</p>
<pre class="programlisting code"><code class="hljs-code">void print_toc(Book const &amp; book)
{
  std::cout &lt;&lt; book.Title &lt;&lt; '\n';
  for(auto const &amp; part : book.Parts)
  {
    std::cout &lt;&lt; std::left &lt;&lt; std::setw(15) &lt;&lt; std::setfill(' ')
              &lt;&lt; part.Title &lt;&lt; '\n';
    std::cout &lt;&lt; std::left &lt;&lt; std::setw(15) &lt;&lt; std::setfill('-')
              &lt;&lt; '-' &lt;&lt; '\n';
    for(auto const &amp; chapter : part.Chapters)
    {
      std::cout &lt;&lt; std::right &lt;&lt; std::setw(4) &lt;&lt; std::setfill(' ')
                &lt;&lt; to_roman(chapter.Number) &lt;&lt; ' ';
      std::cout &lt;&lt; std::left &lt;&lt; std::setw(35) &lt;&lt; std::setfill('.')
                &lt;&lt; chapter.Title;
      std::cout &lt;&lt; std::right &lt;&lt; std::setw(3) &lt;&lt; std::setfill('.')
                &lt;&lt; chapter.Page &lt;&lt; '\n';
    }
  }
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker886"/>following example uses this method with a <code class="inlineCode">Book</code> object describing the table of contents from the book <em class="italic">The Fellowship of the Ring</em>:</p>
<pre class="programlisting code"><code class="hljs-code">auto book = Book
{
  "THE FELLOWSHIP OF THE RING"s,
  {
    {
      "BOOK ONE"s,
      {
        {1, "A Long-expected Party"s, 21},
        {2, "The Shadow of the Past"s, 42},
        {3, "Three Is Company"s, 65},
        {4, "A Short Cut to Mushrooms"s, 86},
        {5, "A Conspiracy Unmasked"s, 98},
        {6, "The Old Forest"s, 109},
        {7, "In the House of Tom Bombadil"s, 123},
        {8, "Fog on the Barrow-downs"s, 135},
        {9, "At the Sign of The Prancing Pony"s, 149},
        {10, "Strider"s, 163},
        {11, "A Knife in the Dark"s, 176},
        {12, "Flight to the Ford"s, 197},
      },
    },
    {
      "BOOK TWO"s,
      {
        {1, "Many Meetings"s, 219},
        {2, "The Council of Elrond"s, 239},
        {3, "The Ring Goes South"s, 272},
        {4, "A Journey in the Dark"s, 295},
        {5, "The Bridge of Khazad-dum"s, 321},
        {6, "Lothlorien"s, 333},
        {7, "The Mirror of Galadriel"s, 353},
        {8, "Farewell to Lorien"s, 367},
        {9, "The Great River"s, 380},
        {10, "The Breaking of the Fellowship"s, 390},
      },
    },
  }
};
print_toc(book);
</code></pre>
<p class="normal">In this case, the <a id="_idIndexMarker887"/>output is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">THE FELLOWSHIP OF THE RING
BOOK ONE
---------------
   I A Long-expected Party...............21
  II The Shadow of the Past..............42
 III Three Is Company....................65
  IV A Short Cut to Mushrooms............86
   V A Conspiracy Unmasked...............98
  VI The Old Forest.....................109
 VII In the House of Tom Bombadil.......123
VIII Fog on the Barrow-downs............135
  IX At the Sign of The Prancing Pony...149
   X Strider............................163
  XI A Knife in the Dark................176
 XII Flight to the Ford.................197
BOOK TWO
---------------
   I Many Meetings......................219
  II The Council of Elrond..............239
 III The Ring Goes South................272
  IV A Journey in the Dark..............295
   V The Bridge of Khazad-dum...........321
  VI Lothlorien.........................333
 VII The Mirror of Galadriel............353
VIII Farewell to Lorien.................367
  IX The Great River....................380
   X The Breaking of the Fellowship.....390
</code></pre>
<p class="normal">For the<a id="_idIndexMarker888"/> second example, our goal is to output a table that lists the largest companies in the world by revenue. The table will have columns for the company name, the industry, the revenue (in USD billions), the increase/decrease in revenue growth, the revenue growth, the number of employees, and the country of origin. For this example, we will use the following class:</p>
<pre class="programlisting code"><code class="hljs-code">struct Company
{
  std::string Name;
  std::string Industry;
  double      Revenue;
  bool        RevenueIncrease;
  double      Growth;
  int         Employees;
  std::string Country;
};
</code></pre>
<p class="normal">The <code class="inlineCode">print_companies()</code> function in the following code snippet uses several additional manipulators to the ones shown in the previous example:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::boolalpha</code> displays Boolean values as <code class="inlineCode">true</code> and <code class="inlineCode">false</code> instead of <code class="inlineCode">1</code> and <code class="inlineCode">0</code>.</li>
<li class="bulletList"><code class="inlineCode">std::fixed</code> indicates a fixed floating-point representation, and then <code class="inlineCode">std::defaultfloat</code> reverts to the default floating-point representation.</li>
<li class="bulletList"><code class="inlineCode">std::setprecision</code> specifies the number of decimal digits to be displayed in the output. Together with <code class="inlineCode">std::fixed</code>, this is used to indicate a fixed representation with a decimal digit for the <code class="inlineCode">Growth</code> field.</li>
</ul>
<p class="normal">The implementation of the <code class="inlineCode">print_companies()</code> function is listed here:</p>
<pre class="programlisting code"><code class="hljs-code">void print_companies(std::vector&lt;Company&gt; const &amp; companies)
{
  for(auto const &amp; company : companies)
  {
    std::cout &lt;&lt; std::left &lt;&lt; std::setw(26) &lt;&lt; std::setfill(' ')
              &lt;&lt; company.Name;
    std::cout &lt;&lt; std::left &lt;&lt; std::setw(18) &lt;&lt; std::setfill(' ')
              &lt;&lt; company.Industry;
    std::cout &lt;&lt; std::left &lt;&lt; std::setw(5) &lt;&lt; std::setfill(' ')
              &lt;&lt; company.Revenue;
    std::cout &lt;&lt; std::left &lt;&lt; std::setw(5) &lt;&lt; std::setfill(' ')
              &lt;&lt; std::boolalpha &lt;&lt; company.RevenueIncrease
              &lt;&lt; std::noboolalpha;
    std::cout &lt;&lt; std::right &lt;&lt; std::setw(5) &lt;&lt; std::setfill(' ')
              &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; company.Growth
              &lt;&lt; std::defaultfloat &lt;&lt; std::setprecision(6) &lt;&lt; ' ';
    std::cout &lt;&lt; std::right &lt;&lt; std::setw(8) &lt;&lt; std::setfill(' ')
              &lt;&lt; company.Employees &lt;&lt; ' ';
    std::cout &lt;&lt; std::left &lt;&lt; std::setw(2) &lt;&lt; std::setfill(' ')
              &lt;&lt; company.Country
              &lt;&lt; '\n';
  }
}
</code></pre>
<p class="normal">The following <a id="_idIndexMarker889"/>is an example of calling this method. The source of the data shown here is Wikipedia (<a href="https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue">https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue</a>, as of 2016):</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;Company&gt; companies
{
  {"Walmart"s, "Retail"s, 482, false, 0.71,
    2300000, "US"s},
  {"State Grid"s, "Electric utility"s, 330, false, 2.91,
    927839, "China"s},
  {"Saudi Aramco"s, "Oil and gas"s, 311, true, 40.11,
    65266, "SA"s},
  {"China National Petroleum"s, "Oil and gas"s, 299,
    false, 30.21, 1589508, "China"s},
  {"Sinopec Group"s, "Oil and gas"s, 294, false, 34.11,
    810538, "China"s},
};
print_companies(companies);
</code></pre>
<p class="normal">In this case, the output has a table-based format, as follows:</p>
<pre class="programlisting con"><code class="hljs-con">Walmart                   Retail            482  false  0.7  2300000 US
State Grid                Electric utility  330  false  2.9   927839 China
Saudi Aramco              Oil and gas       311  true  40.1    65266 SA
China National Petroleum  Oil and gas       299  false 30.2  1589508 China
Sinopec Group             Oil and gas       294  false 34.1   810538 China
</code></pre>
<p class="normal">As an exercise, you can try adding a table heading or even a grid line to precede these lines for a better <a id="_idIndexMarker890"/>tabulation of the data.</p>
<h2 class="heading-2" id="_idParaDest-451">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Reading and writing raw data from/to binary files</em>, to learn how to write and read unstructured data to binary files</li>
<li class="bulletList"><em class="italic">Using monetary I/O manipulators</em>, to learn how to use standard manipulators to write and read monetary values</li>
<li class="bulletList"><em class="italic">Using time I/O manipulators</em>, to learn how to use standard manipulators to write and read date and time values</li>
</ul>
<h1 class="heading-1" id="_idParaDest-452">Using monetary I/O manipulators</h1>
<p class="normal">In the previous<a id="_idIndexMarker891"/> recipe, we looked at some of the manipulators that can be used to control input and output streams. The manipulators that we discussed were related to numeric values and text values. In this recipe, we will look at how to use standard manipulators to write and read monetary values.</p>
<h2 class="heading-2" id="_idParaDest-453">Getting ready</h2>
<p class="normal">You should now be familiar with locales and how to set them for a stream. This topic was discussed in the <em class="italic">Using localized settings for streams</em> recipe. It is recommended that you read that recipe before continuing.</p>
<p class="normal">The manipulators discussed in this recipe are available in the <code class="inlineCode">std</code> namespace, in the <code class="inlineCode">&lt;iomanip&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-454">How to do it...</h2>
<p class="normal">To write a<a id="_idIndexMarker892"/> monetary value to an output stream, you should do the following:</p>
<ul>
<li class="bulletList">Set the desired locale for controlling the monetary format:
        <pre class="programlisting code"><code class="hljs-code">std::cout.imbue(std::locale("en_GB.utf8"));
</code></pre>
</li>
<li class="bulletList">Use either a <code class="inlineCode">long double</code> or a <code class="inlineCode">std::basic_string</code> value for the amount:
        <pre class="programlisting code"><code class="hljs-code">long double mon = 12345.67;
std::string smon = "12345.67";
</code></pre>
</li>
<li class="bulletList">Use a <code class="inlineCode">std::put_money</code> manipulator with a single argument (the monetary value) to display the value using the currency symbol (if any is available):
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(mon)
          &lt;&lt; '\n'; // £123.46
std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(smon)
          &lt;&lt; '\n'; // £123.46
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::put_money</code> with two arguments (the monetary value and a Boolean flag set to <code class="inlineCode">true</code>) to indicate the use of an international currency string:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(mon, true)
          &lt;&lt; '\n'; // GBP 123.46
std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(smon, true)
          &lt;&lt; '\n'; // GBP 123.46
</code></pre>
</li>
</ul>
<p class="normal">To read a monetary value from an input stream, you should do the following:</p>
<ul>
<li class="bulletList">Set the desired locale to control the monetary format:
        <pre class="programlisting code"><code class="hljs-code">std::istringstream stext("$123.45 567.89 USD");
stext.imbue(std::locale("en_US.utf8"));
</code></pre>
</li>
<li class="bulletList">Use either a <code class="inlineCode">long double</code> or <code class="inlineCode">std::basic_string</code> value to read the amount from the input stream:
        <pre class="programlisting code"><code class="hljs-code">long double v1 = 0;
std::string v2;
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::get_money()</code> with a single argument (the variable where the monetary value is to be written) if a currency symbol might be used in the input stream:
        <pre class="programlisting code"><code class="hljs-code">stext &gt;&gt; std::get_money(v1) &gt;&gt; std::get_money(v2);
// v1 = 12345, v2 = "56789"
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::get_money()</code> with two arguments (the variable where the monetary<a id="_idIndexMarker893"/> value is to be written and a Boolean flag set to <code class="inlineCode">true</code>) to indicate the presence of an international currency string:
        <pre class="programlisting code"><code class="hljs-code">std::istringstream stext("123.45 567.89");
stext.imbue(std::locale("en_US.utf8"));
long double v1 = 0;
std::string v2;
stext &gt;&gt; std::get_money(v1, true) &gt;&gt; std::get_money(v2, true);
// v1 = 12345, v2 = "56789"
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-455">How it works...</h2>
<p class="normal">The <code class="inlineCode">put_money()</code> and <code class="inlineCode">get_money()</code> manipulators are very similar. They are both function templates that take an argument representing either the monetary value to be written to the output stream or a variable to hold the monetary value read from an input stream, and a second, optional parameter to indicate whether an international currency string is used. The default alternative is the currency symbol, if one is available. <code class="inlineCode">put_money()</code> uses the <code class="inlineCode">std::money_put()</code> facet settings to output a monetary value, and <code class="inlineCode">get_money()</code> uses the <code class="inlineCode">std::money_get()</code> facet to parse a monetary value. Both manipulator function templates return an object of an unspecified type. These functions do not throw exceptions:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class MoneyT&gt;
/*unspecified*/ put_money(const MoneyT&amp; mon, bool intl = false);
template &lt;class MoneyT&gt;
/*unspecified*/ get_money(MoneyT&amp; mon, bool intl = false);
</code></pre>
<p class="normal">Both of these manipulator functions require the monetary value to be either a <code class="inlineCode">long double</code> or a <code class="inlineCode">std::basic_string</code>.</p>
<div><p class="normal">However, it is important to note that monetary values are stored as integral numbers of the smallest denomination of the currency defined by the locale in use. Considering US dollars as that currency, $100.00 is stored as <strong class="keyWord">10000.0</strong>, and 1 cent (that is, $0.01) is stored as <strong class="keyWord">1.0</strong>.</p>
</div>
<p class="normal">When writing a<a id="_idIndexMarker894"/> monetary value to an output stream, it is important to use the <code class="inlineCode">std::showbase</code> manipulator if you want to display the currency symbol or the international currency string. This is normally used to indicate the prefix of a numeric base (such as <code class="inlineCode">0x</code> for hexadecimal); however, for monetary values, it is used to indicate whether the currency symbol/string should be displayed or not. The following snippet provides an example:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::put_money(12345.67) &lt;&lt; '\n';
// prints 123.46
std::cout &lt;&lt; std::showbase &lt;&lt; std::put_money(12345.67) &lt;&lt; '\n';
// prints £123.46
</code>
123.46</code>, while the second line will print the same numerical value but preceded by the currency symbol.</pre>
<h2 class="heading-2" id="_idParaDest-456">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using I/O manipulators to control the output of a stream</em>, to learn about the use of helper functions, called manipulators, that control input and output streams using the <code class="inlineCode">&lt;&lt;</code> and <code class="inlineCode">&gt;&gt;</code> stream operators</li>
<li class="bulletList"><em class="italic">Using time I/O manipulators</em>, to learn how to use standard manipulators to write and read date and time values</li>
</ul>
<h1 class="heading-1" id="_idParaDest-457">Using time I/O manipulators</h1>
<p class="normal">Similar to the<a id="_idIndexMarker895"/> monetary I/O manipulators that we discussed in the previous recipe, the C++11 standard provides manipulators that control the writing and reading of time values to and from streams, where time values are represented in the form of a <code class="inlineCode">std::tm</code> object that holds a calendar date and time. In this recipe, you will learn how to use these time manipulators.</p>
<h2 class="heading-2" id="_idParaDest-458">Getting ready</h2>
<p class="normal">Time values <a id="_idIndexMarker896"/>used by the time I/O manipulators are expressed in <code class="inlineCode">std::tm</code> values. You should be familiar with this structure from the <code class="inlineCode">&lt;ctime&gt;</code> header.</p>
<p class="normal">You should also be familiar with locales and how to set them for a stream. This topic was discussed in the <em class="italic">Using localized settings for streams</em> recipe. It is recommended that you read that recipe before continuing.</p>
<p class="normal">The manipulators discussed in this recipe are available in the <code class="inlineCode">std</code> namespace, in the <code class="inlineCode">&lt;iomanip&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-459">How to do it...</h2>
<p class="normal">To write a time value to an output stream, you should perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Obtain a calendar date and time value corresponding to a given time. There are various ways in which to do this. The following shows several examples of how to convert the current time to a local time that is expressed as a calendar date and time:
        <pre class="programlisting code"><code class="hljs-code">auto now = std::chrono::system_clock::now();
auto stime = std::chrono::system_clock::to_time_t(now);
auto ltime = std::localtime(&amp;stime);
auto ttime = std::time(nullptr);
auto ltime = std::localtime(&amp;ttime);
</code></pre>
</li>
<li class="numberedList">Use <code class="inlineCode">std::put_time()</code> to supply a pointer to the <code class="inlineCode">std::tm</code> object, representing the calendar date and time, and a pointer to a null-terminated character string, representing the format. The C++11 standard provides a long list of formats that can be used; this list can be consulted at <a href="http://en.cppreference.com/w/cpp/io/manip/put_time">http://en.cppreference.com/w/cpp/io/manip/put_time</a>.</li>
<li class="numberedList">To write a standard date and time string according to the settings of a specific locale, first set the locale for the stream by calling <code class="inlineCode">imbue()</code> and then use the <code class="inlineCode">std::put_time()</code> manipulator:
        <pre class="programlisting code"><code class="hljs-code">std::cout.imbue(std::locale("en_GB.utf8"));
std::cout &lt;&lt; std::put_time(ltime, "%c") &lt;&lt; '\n';
// Sun 04 Dec 2016 05:26:47 JST
</code></pre>
</li>
</ol>
<p class="normal">The following<a id="_idIndexMarker897"/> list shows some examples of supported time formats:</p>
<ul>
<li class="bulletList">ISO 8601 date format <code class="inlineCode">"%F"</code> or <code class="inlineCode">"%Y-%m-%d"</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::put_time(ltime, "%F") &lt;&lt; '\n';
// 2016-12-04
</code></pre>
</li>
<li class="bulletList">ISO 8601 time format <code class="inlineCode">"%T"</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::put_time(ltime, "%T") &lt;&lt; '\n';
// 05:26:47
</code></pre>
</li>
<li class="bulletList">ISO 8601 combined date and time in UTC format <code class="inlineCode">"%FT%T%z"</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::put_time(ltime, "%FT%T%z") &lt;&lt; '\n';
// 2016-12-04T05:26:47+0900
</code></pre>
</li>
<li class="bulletList">ISO 8601 week format <code class="inlineCode">"%Y-W%V"</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::put_time(ltime, "%Y-W%V") &lt;&lt; '\n';
// 2016-W48
</code></pre>
</li>
<li class="bulletList">ISO 8601 date with week number format <code class="inlineCode">"</code><code class="inlineCode">%Y-W%V-%u"</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::put_time(ltime, "%Y-W%V-%u") &lt;&lt; '\n';
// 2016-W48-7
</code></pre>
</li>
<li class="bulletList">ISO 8601 ordinal date format <code class="inlineCode">"%Y-%j"</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::put_time(ltime, "%Y-%j") &lt;&lt; '\n';
// 2016-339
</code></pre>
</li>
</ul>
<p class="normal">To read a time value from an input stream, you should perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Declare an object of the <code class="inlineCode">std::tm</code> type to hold the time value read from the stream:
        <pre class="programlisting code"><code class="hljs-code">auto time = std::tm {};
</code></pre>
</li>
<li class="numberedList">Use <code class="inlineCode">std::get_time()</code> to supply a pointer to the <code class="inlineCode">std::tm</code> object, which will hold the time value, and a pointer to a null-terminated character string, which represents the format. The list of possible formats can be consulted at <a href="http://en.cppreference.com/w/cpp/io/manip/get_time">http://en.cppreference.com/w/cpp/io/manip/get_time</a>. The following example parses an ISO 8601 combined date and time value:
        <pre class="programlisting code"><code class="hljs-code">std::istringstream stext("2016-12-04T05:26:47+0900");
stext &gt;&gt; std::get_time(&amp;time, "%Y-%m-%dT%H:%M:%S");
if (!stext.fail()) { /* do something */ }
</code></pre>
</li>
<li class="numberedList">To <a id="_idIndexMarker898"/>read a standard date and time string according to the settings of a specific locale, first set the locale for the stream by calling <code class="inlineCode">imbue()</code> and then use the <code class="inlineCode">std::get_time()</code> manipulator:
        <pre class="programlisting code"><code class="hljs-code">std::istringstream stext("Sun 04 Dec 2016 05:35:30 JST");
stext.imbue(std::locale("en_GB.utf8"));
stext &gt;&gt; std::get_time(&amp;time, "%c");
if (stext.fail()) { /* do something else */ }
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-460">How it works...</h2>
<p class="normal">The two manipulators for time values, <code class="inlineCode">put_time()</code> and <code class="inlineCode">get_time()</code>, are very similar: they are both function templates with two arguments. The first argument is a pointer to a <code class="inlineCode">std::tm</code> object representing the calendar date and time, which holds the value to be written to the stream or the value that is read from the stream. The second argument is a pointer to a null-terminated character string representing the format of the time text. <code class="inlineCode">put_time()</code> uses the <code class="inlineCode">std::time_put()</code> facet to output a date and time value, and <code class="inlineCode">get_time()</code> uses the <code class="inlineCode">std::time_get()</code> facet to parse a date and time value. Both manipulator function templates return an object of an unspecified type. These functions do not throw exceptions:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class CharT&gt;
/*unspecified*/ put_time(const std::tm* tmb, const CharT* fmt);
template&lt;class CharT&gt;
/*unspecified*/ get_time(std::tm* tmb, const CharT* fmt);
</code></pre>
<div><p class="normal">The string that results from using <code class="inlineCode">put_time()</code> to write a date and time value to an output stream is the same as the one that results from a call to <code class="inlineCode">std::strftime()</code> or <code class="inlineCode">std::wcsftime()</code>.</p>
</div>
<p class="normal">The standard <a id="_idIndexMarker899"/>defines a long list of available conversion specifiers that compose the format string. These specifiers are prefixed with a <code class="inlineCode">%</code>, and, in some cases, are followed by an <code class="inlineCode">E</code> or a <code class="inlineCode">0</code>. Some of them are also equivalent; for instance, <code class="inlineCode">%F</code> is equivalent to <code class="inlineCode">%Y-%m-%d</code> (this is the ISO 8601 date format), and <code class="inlineCode">%T</code> is equivalent to <code class="inlineCode">%H:%M:%S</code> (this is the ISO 8601 time format). The examples in this recipe mention only a few of the conversion specifiers, referring to ISO 8601 date and time formats. For the complete list of conversion specifiers, refer to the C++ standard or follow the links that were mentioned earlier.</p>
<div><p class="normal">It is important to note that not all of the conversion specifiers supported by <code class="inlineCode">put_time()</code> are also supported by <code class="inlineCode">get_time()</code>. Examples include the <code class="inlineCode">z</code> (offset from UTC in the ISO 8601 format) and <code class="inlineCode">Z</code> (time zone name or abbreviation) specifiers, which can only be used with <code class="inlineCode">put_time()</code>. This is demonstrated in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">std::istringstream stext("2016-12-04T05:26:47+0900");
auto time = std::tm {};
stext &gt;&gt; std::get_time(&amp;time, "%Y-%m-%dT%H:%M:%S%z"); // fails
stext &gt;&gt; std::get_time(&amp;time, "%Y-%m-%dT%H:%M:%S");   // OK
</code></pre>
</div>
<p class="normal">The text represented by some conversion specifiers is locale-dependent. All specifiers prefixed with <code class="inlineCode">E</code> or <code class="inlineCode">0</code> are locale-dependent. To set a particular locale for the stream, use the <code class="inlineCode">imbue()</code> method, as demonstrated in the examples in the <em class="italic">How to do it...</em> section.</p>
<div><p class="normal">The <code class="inlineCode">std::localtime()</code> function used in an earlier example returns a pointer to a static internal <code class="inlineCode">std::tm</code> object if it succeeds (or <code class="inlineCode">nullptr</code> otherwise). You should not attempt to free this pointer!</p>
</div>
<h2 class="heading-2" id="_idParaDest-461">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using I/O manipulators to control the output of a stream</em>, to learn about the use of helper functions, called manipulators, that control input and output streams using the <code class="inlineCode">&lt;&lt;</code> and <code class="inlineCode">&gt;&gt;</code> stream operators</li>
<li class="bulletList"><em class="italic">Using monetary I/O manipulators</em>, to learn how to use standard manipulators to write and read monetary values</li>
</ul>
<h1 class="heading-1" id="_idParaDest-462">Working with filesystem paths</h1>
<p class="normal">An <a id="_idIndexMarker900"/>important addition to the C++17 standard is the <code class="inlineCode">filesystem</code> library, which enables us to work with paths, files, and directories in hierarchical filesystems (such as Windows or POSIX filesystems). This standard library has been developed based on the <code class="inlineCode">boost.filesystem</code> library. In the next few recipes, we will explore those features of the library that enable us to perform operations with files and directories, such as creating, moving, or deleting them, but also querying properties and searching. It is important, however, to first look at how this library handles paths.</p>
<h2 class="heading-2" id="_idParaDest-463">Getting ready</h2>
<p class="normal">For this recipe, we will consider most of the examples using Windows paths. In the accompanying code, all examples have both Windows and POSIX alternatives.</p>
<p class="normal">The <code class="inlineCode">filesystem</code> library is available in the <code class="inlineCode">std::filesystem</code> namespace, in the <code class="inlineCode">&lt;filesystem&gt;</code> header. To simplify the code, we will use the following namespace alias in all of the examples:</p>
<pre class="programlisting code"><code class="hljs-code">namespace fs = std::filesystem;
</code></pre>
<p class="normal">A path to a filesystem component (file, directory, hard link, or soft link) is represented by the <code class="inlineCode">path</code> class.</p>
<h2 class="heading-2" id="_idParaDest-464">How to do it...</h2>
<p class="normal">The following is a list of the most common operations on paths:</p>
<ul>
<li class="bulletList">Create a path using the constructor, the assignment operator, or the <code class="inlineCode">assign()</code> method:
        <pre class="programlisting code"><code class="hljs-code">// Windows
auto path = fs::path{"C:\\Users\\Marius\\Documents"};
// POSIX
auto path = fs::path{ "/home/marius/docs" };
</code></pre>
</li>
<li class="bulletList">Append<a id="_idIndexMarker901"/> elements to a path by including a directory separator using the member <code class="inlineCode">operator /=</code>, the non-member <code class="inlineCode">operator /</code>, or the <code class="inlineCode">append()</code> method:
        <pre class="programlisting code"><code class="hljs-code">path /= "Book";
path = path / "Modern" / "Cpp";
path.append("Programming");
// Windows: C:\Users\Marius\Documents\Book\Modern\Cpp\Programming
// POSIX:   /home/marius/docs/Book/Modern/Cpp/Programming
</code></pre>
</li>
<li class="bulletList">Concatenate elements to a path without including a directory separator by using the member <code class="inlineCode">operator +=</code>, the non-member <code class="inlineCode">operator +</code>, or the <code class="inlineCode">concat()</code> method:
        <pre class="programlisting code"><code class="hljs-code">auto path = fs::path{ "C:\\Users\\Marius\\Documents" };
path += "\\Book";
path.concat("\\Modern");
// path = C:\Users\Marius\Documents\Book\Modern
</code></pre>
</li>
<li class="bulletList">Decompose the elements of a path into its parts, such as the root, root directory, parent path, filename, extension, and so on, using member functions such as <code class="inlineCode">root_name()</code>, <code class="inlineCode">root_dir()</code>, <code class="inlineCode">filename()</code>, <code class="inlineCode">stem()</code>, <code class="inlineCode">extension()</code>, and so on (all of them are shown in the following example):
        <pre class="programlisting code"><code class="hljs-code">auto path =
  fs::path{"C:\\Users\\Marius\\Documents\\sample.file.txt"};
std::cout
  &lt;&lt; "root: "        &lt;&lt; path.root_name() &lt;&lt; '\n'
  &lt;&lt; "root dir: "    &lt;&lt; path.root_directory() &lt;&lt; '\n'
  &lt;&lt; "root path: "   &lt;&lt; path.root_path() &lt;&lt; '\n'
  &lt;&lt; "rel path: "    &lt;&lt; path.relative_path() &lt;&lt; '\n'
  &lt;&lt; "parent path: " &lt;&lt; path.parent_path() &lt;&lt; '\n'
  &lt;&lt; "filename: "    &lt;&lt; path.filename() &lt;&lt; '\n'
  &lt;&lt; "stem: "        &lt;&lt; path.stem() &lt;&lt; '\n'
  &lt;&lt; "extension: "   &lt;&lt; path.extension() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Query whether parts of a part are available using member functions such as <code class="inlineCode">has_root_name()</code>, <code class="inlineCode">has_root_directory()</code>, <code class="inlineCode">has_filename()</code>, <code class="inlineCode">has_stem()</code>, and <code class="inlineCode">has_extension()</code> (all of these are shown in the following example):
        <pre class="programlisting code"><code class="hljs-code">auto path =
  fs::path{"C:\\Users\\Marius\\Documents\\sample.file.txt"};
std::cout
  &lt;&lt; "has root: "        &lt;&lt; path.has_root_name() &lt;&lt; '\n'
  &lt;&lt; "has root dir: "    &lt;&lt; path.has_root_directory() &lt;&lt; '\n'
  &lt;&lt; "has root path: "   &lt;&lt; path.has_root_path() &lt;&lt; '\n'
  &lt;&lt; "has rel path: "    &lt;&lt; path.has_relative_path() &lt;&lt; '\n'
  &lt;&lt; "has parent path: " &lt;&lt; path.has_parent_path() &lt;&lt; '\n'
  &lt;&lt; "has filename: "    &lt;&lt; path.has_filename() &lt;&lt; '\n'
  &lt;&lt; "has stem: "        &lt;&lt; path.has_stem() &lt;&lt; '\n'
  &lt;&lt; "has extension: "   &lt;&lt; path.has_extension() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Check<a id="_idIndexMarker902"/> whether a path is relative or absolute:
        <pre class="programlisting code"><code class="hljs-code">auto path2 = fs::path{ "marius\\temp" };
std::cout
  &lt;&lt; "absolute: " &lt;&lt; path1.is_absolute() &lt;&lt; '\n'
  &lt;&lt; "absolute: " &lt;&lt; path2.is_absolute() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Modify individual parts of the path, such as the filename with <code class="inlineCode">replace_filename()</code> and <code class="inlineCode">remove_filename()</code>, and the extension with <code class="inlineCode">replace_extension()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto path =
  fs::path{"C:\\Users\\Marius\\Documents\\sample.file.txt"};
path.replace_filename("output");
path.replace_extension(".log");
// path = C:\Users\Marius\Documents\output.log
path.remove_filename();
// path = C:\Users\Marius\Documents
</code></pre>
</li>
<li class="bulletList">Convert the directory separator to the system-preferred separator:
        <pre class="programlisting code"><code class="hljs-code">// Windows
auto path = fs::path{"Users/Marius/Documents"};
path.make_preferred();
// path = Users\Marius\Documents
// POSIX
auto path = fs::path{ "\\home\\marius\\docs" };
path.make_preferred();
// path = /home/marius/docs
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-465">How it works...</h2>
<p class="normal">The <code class="inlineCode">std::filesystem::path</code> class<a id="_idIndexMarker903"/> models paths to filesystem components. However, it only handles the syntax and does not validate the existence of a component (such as a file or a directory) represented by the path.</p>
<p class="normal">The library defines a portable, generic syntax for paths that can accommodate various filesystems, such as POSIX or Windows, including <a id="_idIndexMarker904"/>the Microsoft Windows <strong class="keyWord">Universal Naming Convention</strong> (<strong class="keyWord">UNC</strong>) format. Both of them differ in several key aspects:</p>
<ul>
<li class="bulletList">POSIX systems have a single tree, no root name, a single root directory called <code class="inlineCode">/</code>, and a single current directory. Additionally, they use <code class="inlineCode">/</code> as the directory separator. Paths are represented as null-terminated strings of <code class="inlineCode">char</code> encoded as UTF-8.</li>
<li class="bulletList">Windows systems have multiple trees, each with a root name (such as <code class="inlineCode">C:</code>), a root directory (such as <code class="inlineCode">\</code>), and a current directory (such as <code class="inlineCode">C:\Windows\System32</code>). Paths are represented as null-terminated strings of wide characters encoded as UTF-16.</li>
</ul>
<div><p class="normal">You should not mix path formats across different systems. Although Windows can handle POSIX paths, the other way around is not true. Use the path format specific to each system. Additionally, you can use the <code class="inlineCode">filesystem::path</code> functionality, such as <code class="inlineCode">operator /=</code> and the <code class="inlineCode">append()</code> function, as well as the <code class="inlineCode">preferred_separator</code> static member to build paths in a portable manner.</p>
</div>
<p class="normal">A pathname, as defined in the <code class="inlineCode">filesystem</code> library, has the following syntax:</p>
<ul>
<li class="bulletList">An optional root name (<code class="inlineCode">C:</code> or <code class="inlineCode">//localhost</code>)</li>
<li class="bulletList">An optional root directory</li>
<li class="bulletList">Zero or more filenames (which may refer to a file, a directory, a hard link, or a symbolic link) or directory separators</li>
</ul>
<p class="normal">There are two special filenames that are recognized: the single dot (<code class="inlineCode">.</code>), which represents the current directory, and the double dot (<code class="inlineCode">..</code>), which represents the parent directory. The directory separator can be repeated, in which case it is treated as a single separator (in other words, <code class="inlineCode">/home////docs</code> is the same as <code class="inlineCode">/home/marius/docs</code>). A path that has no redundant current directory name (<code class="inlineCode">.</code>), no redundant parent directory name (<code class="inlineCode">..</code>), and no redundant directory separators is said to be in a normal form.</p>
<p class="normal">The <a id="_idIndexMarker905"/>path operations presented in the previous section are the most common operations with paths. However, their implementation defines additional querying and modifying methods, iterators, non-member comparison operators, and more. </p>
<p class="normal">The following sample iterates through the parts of a path and prints them to the console:</p>
<pre class="programlisting code"><code class="hljs-code">auto path =
  fs::path{ "C:\\Users\\Marius\\Documents\\sample.file.txt" };
for (auto const &amp; part : path)
{
  std::cout &lt;&lt; part &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The following listing represents its result:</p>
<pre class="programlisting con"><code class="hljs-con">C:
Users
Marius
Documents
sample.file.txt
</code></pre>
<p class="normal">In this example, <code class="inlineCode">sample.file.txt</code> is the filename. This is basically the part from the last directory separator to the end of the path. This is what the member function <code class="inlineCode">filename()</code> would be returning for the given path. The extension for this file is <code class="inlineCode">.txt</code>, which is the string returned by the <code class="inlineCode">extension()</code> member function. To retrieve the filename without an extension, another member function called <code class="inlineCode">stem()</code> is available. Here, the string returned by this method is <code class="inlineCode">sample.file</code>. For all of these methods, but also all of the other decomposition methods, there is a corresponding querying method with the same name and the prefix <code class="inlineCode">has_</code>, such as <code class="inlineCode">has_filename()</code>, <code class="inlineCode">has_stem()</code>, and <code class="inlineCode">has_extension()</code>. All of these methods return a <code class="inlineCode">bool</code> value to indicate whether the path has the corresponding part.</p>
<h2 class="heading-2" id="_idParaDest-466">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating, copying, and deleting files and directories</em>, to learn how to perform these basic operations with files and directories independently of the filesystem in use</li>
<li class="bulletList"><em class="italic">Checking the properties of an existing file or directory</em>, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</li>
</ul>
<h1 class="heading-1" id="_idParaDest-467">Creating, copying, and deleting files and directories</h1>
<p class="normal">Operations with files, such as copying, moving, and deleting, or with directories, such as creating, renaming, and <a id="_idIndexMarker906"/>deleting, are all supported by the <code class="inlineCode">filesystem</code> library. Files and directories <a id="_idIndexMarker907"/>are identified using a path (which can be absolute, canonical, or relative), a topic that was covered in the previous recipes. In this recipe, we will look at<a id="_idIndexMarker908"/> what the standard functions for the previously mentioned operations are and how they work.</p>
<h2 class="heading-2" id="_idParaDest-468">Getting ready</h2>
<p class="normal">Before going forward, you should read the <em class="italic">Working with filesystem paths</em> recipe. The introductory notes from that recipe also apply here. However, all of the examples in this recipe are platform-independent.</p>
<p class="normal">For all of the following examples, we will use the following variables and assume the current path is <code class="inlineCode">C:\Users\Marius\Documents</code> on Windows and <code class="inlineCode">/home/marius/docs</code> for a POSIX system:</p>
<pre class="programlisting code"><code class="hljs-code">auto err = std::error_code{};
auto basepath = fs::current_path();
auto path = basepath / "temp";
auto filepath = path / "sample.txt";
</code></pre>
<p class="normal">We will also assume the presence of a file called <code class="inlineCode">sample.txt</code> in the <code class="inlineCode">temp</code> subdirectory of the current path (such as <code class="inlineCode">C:\Users\Marius\Documents\temp\sample.txt</code> or <code class="inlineCode">/home/marius/docs/temp/sample.txt</code>).</p>
<h2 class="heading-2" id="_idParaDest-469">How to do it...</h2>
<p class="normal">Use the <a id="_idIndexMarker909"/>following <a id="_idIndexMarker910"/>library functions to perform operations <a id="_idIndexMarker911"/>with directories:</p>
<ul>
<li class="bulletList">To create a new directory, use <code class="inlineCode">create_directory()</code>. This method does nothing if the directory already exists; however, it does not create directories recursively:
        <pre class="programlisting code"><code class="hljs-code">auto success = fs::create_directory(path, err);
</code></pre>
</li>
<li class="bulletList">To create new directories recursively, use <code class="inlineCode">create_directories()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto temp = path / "tmp1" / "tmp2" / "tmp3";
auto success = fs::create_directories(temp, err);
</code></pre>
</li>
<li class="bulletList">To move an existing directory, use <code class="inlineCode">rename()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto temp = path / "tmp1" / "tmp2" / "tmp3";
auto newtemp = path / "tmp1" / "tmp3";
fs::rename(temp, newtemp, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To rename an existing directory, also use <code class="inlineCode">rename()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto temp = path / "tmp1" / "tmp3";
auto newtemp = path / "tmp1" / "tmp4";
fs::rename(temp, newtemp, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To copy an existing directory, use <code class="inlineCode">copy()</code>. To recursively copy the entire content of a directory, use the <code class="inlineCode">copy_options::recursive</code> flag:
        <pre class="programlisting code"><code class="hljs-code">fs::copy(path, basepath / "temp2",
         fs::copy_options::recursive, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To create a symbolic link to a directory, use <code class="inlineCode">create_directory_symlink()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto linkdir = basepath / "templink";
fs::create_directory_symlink(path, linkdir, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To remove an empty directory, use <code class="inlineCode">remove()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto temp = path / "tmp1" / "tmp4";
auto success = fs::remove(temp, err);
</code></pre>
</li>
<li class="bulletList">To remove the entire content of a directory recursively and the directory itself, use <code class="inlineCode">remove_all()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto success = fs::remove_all(path, err) !=
               static_cast&lt;std::uintmax_t&gt;(-1);
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker912"/>change <a id="_idIndexMarker913"/>permissions on a directory or a file, use <code class="inlineCode">permissions()</code>, specifying permissions options from the <code class="inlineCode">perms</code> enum. Unless <a id="_idIndexMarker914"/>you specify an operation type (replace, add, or remove) from the <code class="inlineCode">perm_options</code> enum, the default action is to replace all existing permissions with the specified ones:
        <pre class="programlisting code"><code class="hljs-code">// replace permissions with specified ones
fs::permissions(temp, fs::perms::owner_all | 
                      fs::perms::group_all, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
// remove specified permissions
fs::permissions(temp, fs::perms::group_exec,
                      fs::perm_options::remove, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<p class="normal">Use the following library functions to perform operations with files:</p>
<ul>
<li class="bulletList">To copy a file, use <code class="inlineCode">copy()</code> or <code class="inlineCode">copy_file()</code>. The next section explains the difference between the two:
        <pre class="programlisting code"><code class="hljs-code">auto success = fs::copy_file(filepath, path / "sample.bak", err);
if (!success) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
fs::copy(filepath, path / "sample.cpy", err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To rename a file, use <code class="inlineCode">rename()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto newpath = path / "sample.log";
fs::rename(filepath, newpath, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To move a file, use <code class="inlineCode">rename()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto newpath = path / "sample.log";
fs::rename(newpath, path / "tmp1" / "sample.log", err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker915"/>create a symbolic link to a file, use <code class="inlineCode">create_symlink()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto linkpath = path / "sample.txt.link";
fs::create_symlink(filepath, linkpath, err);
if (err) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To delete a file, use <code class="inlineCode">remove()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto success = fs::remove(path / "sample.cpy", err);
if (!success) std::cout &lt;&lt; err.message() &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-470">How it works...</h2>
<p class="normal">All of the<a id="_idIndexMarker916"/> functions mentioned in this recipe, and other similar functions<a id="_idIndexMarker917"/> that are not discussed here, have multiple overloads that can be grouped into two categories:</p>
<ul>
<li class="bulletList">Overloads that take, as the last argument, a reference to a <code class="inlineCode">std::error_code</code>: these overloads do not throw an exception (they are defined with the <code class="inlineCode">noexcept</code> specification). Instead, they set the value of the <code class="inlineCode">error_code</code> object to the operating system error code if an operating system error has occurred. If no such error has occurred, then the <code class="inlineCode">clear()</code> method on the <code class="inlineCode">error_code</code> object is called to reset any possible previously set code.</li>
<li class="bulletList">Overloads that do not take the last argument of the <code class="inlineCode">std::error_code</code> type: these overloads throw exceptions if errors occur. If an operating system error occurs, they throw a <code class="inlineCode">std::filesystem::filesystem_error</code> exception. On the other hand, if memory allocation fails, these functions throw a <code class="inlineCode">std::bad_alloc</code> exception.</li>
</ul>
<p class="normal">All the <a id="_idIndexMarker918"/>examples in the previous section used the overload that does not throw exceptions but, instead, sets a code when an error occurs. Some<a id="_idIndexMarker919"/> functions return a <code class="inlineCode">bool</code> to indicate a success or a failure. You can check whether the <code class="inlineCode">error_code</code> object <a id="_idIndexMarker920"/>holds the code of an error by either checking whether the value of the error code, returned by the method <code class="inlineCode">value()</code>, is different from 0, or by using the conversion <code class="inlineCode">operator bool</code>, which returns <code class="inlineCode">true</code> for the same case and <code class="inlineCode">false</code> otherwise. To retrieve the explanatory string for the error code, use the <code class="inlineCode">message()</code> method.</p>
<p class="normal">Some <code class="inlineCode">filesystem</code> library functions are common for both files and directories. This is the case for <code class="inlineCode">rename()</code>, <code class="inlineCode">remove()</code>, and <code class="inlineCode">copy()</code>. The working details of each of these functions can be complex, especially in the case of <code class="inlineCode">copy()</code>, and are beyond the scope of this recipe. You should refer to the reference documentation if you need to perform anything other than the simple operations covered here.</p>
<p class="normal">When it comes to copying files, there are two functions that can be used: <code class="inlineCode">copy()</code> and <code class="inlineCode">copy_file()</code>. These have equivalent overloads with identical signatures and, apparently, work the same way. However, there is an important difference (other than the fact that <code class="inlineCode">copy()</code> also works for directories): <code class="inlineCode">copy_file()</code> follows symbolic links. </p>
<p class="normal">To avoid doing that and, instead, copy the actual symbolic link, you must use either <code class="inlineCode">copy_symlink()</code> or <code class="inlineCode">copy()</code> with the <code class="inlineCode">copy_options::copy_symlinks</code> flag. Both the <code class="inlineCode">copy()</code> and <code class="inlineCode">copy_file()</code> functions have an overload that takes an argument of the <code class="inlineCode">std::filesystem::copy_options</code> type, which defines how the operation should be performed. <code class="inlineCode">copy_options</code> is a scoped <code class="inlineCode">enum</code> with the following definition:</p>
<pre class="programlisting code"><code class="hljs-code">enum class copy_options
{
  none               = 0,
  skip_existing      = 1,
  overwrite_existing = 2,
  update_existing    = 4,
  recursive          = 8,
  copy_symlinks      = 16,
  skip_symlinks      = 32,
  directories_only   = 64,
  create_symlinks    = 128,
  create_hard_links  = 256
};
</code></pre>
<p class="normal">The following table defines how each of these flags affects a copy operation, either with <code class="inlineCode">copy()</code> or <code class="inlineCode">copy_file()</code>. The table is taken<a id="_idIndexMarker921"/> from the 31.12.8.3 paragraph<a id="_idIndexMarker922"/> from<a id="_idIndexMarker923"/> the N4917 version of the C++ standard:</p>
<table class="table-container" id="table003-3">
<tbody>
<tr>
<td class="table-cell" colspan="2">
<p class="normal">Option group controlling <code class="inlineCode">copy_file</code> function effects for existing target files</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">none</code></p>
</td>
<td class="table-cell">
<p class="normal">(Default) Error; file already exists</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">skip_existing</code></p>
</td>
<td class="table-cell">
<p class="normal">Do not overwrite existing file; do not report an error</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">overwrite_existing</code></p>
</td>
<td class="table-cell">
<p class="normal">Overwrite the existing file</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">update_existing</code></p>
</td>
<td class="table-cell">
<p class="normal">Overwrite the existing file if it is older than the replacement file</p>
</td>
</tr>
<tr>
<td class="table-cell" colspan="2">
<p class="normal">Option group controlling <code class="inlineCode">copy</code> function effects for subdirectories</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">none</code></p>
</td>
<td class="table-cell">
<p class="normal">(Default) Do not copy subdirectories</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">recursive</code></p>
</td>
<td class="table-cell">
<p class="normal">Recursively copy subdirectories and their contents</p>
</td>
</tr>
<tr>
<td class="table-cell" colspan="2">
<p class="normal">Option group controlling <code class="inlineCode">copy</code> function effects for symbolic links</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">none</code></p>
</td>
<td class="table-cell">
<p class="normal">(Default) Follow symbolic links</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">copy_symlinks</code></p>
</td>
<td class="table-cell">
<p class="normal">Copy symbolic links as symbolic links rather than copying the files that they point to</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">skip_symlinks</code></p>
</td>
<td class="table-cell">
<p class="normal">Ignore symbolic links</p>
</td>
</tr>
<tr>
<td class="table-cell" colspan="2">
<p class="normal">Option group controlling <code class="inlineCode">copy</code> function effects for choosing the form of copying</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">none</code></p>
</td>
<td class="table-cell">
<p class="normal">(Default) Copy contents</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">directories_only</code></p>
</td>
<td class="table-cell">
<p class="normal">Copy the directory structure only; do not copy non-directory files</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">create_symlinks</code></p>
</td>
<td class="table-cell">
<p class="normal">Make symbolic links instead of copies of files; the source path will be an absolute path unless the destination path is in the current directory</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">create_hard_links</code></p>
</td>
<td class="table-cell">
<p class="normal">Make hard links instead of copies of files</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 7.3: A breakdown of how copy_operation flags affect the copy operation</p>
<p class="normal">Another <a id="_idIndexMarker924"/>aspect that should be mentioned is related to symbolic links: <code class="inlineCode">create_directory_symlink()</code> creates a symbolic link to a directory, whereas <code class="inlineCode">create_symlink()</code> creates symbolic links to either files or directories. On POSIX systems, the two are<a id="_idIndexMarker925"/> identical when it comes to directories. On other systems (such as Windows), symbolic links to directories are created<a id="_idIndexMarker926"/> differently than symbolic links to files. Therefore, it is recommended that you use <code class="inlineCode">create_directory_symlink()</code> for directories in order to write code that works correctly on all systems.</p>
<div><p class="normal">When you perform operations with files and directories, such as the ones described in this recipe, and you use the overloads that may throw exceptions, ensure that you use <code class="inlineCode">try</code>-<code class="inlineCode">catch</code> on the calls. Regardless of the type of overload used, you should check the success of the operation and take appropriate action in the case of a failure.</p>
</div>
<p class="normal">If you need to change permissions for a file or directory, you can use the <code class="inlineCode">permissions()</code> function. It has several overloads that allow you to specify a range of permission options. These are defined in the <code class="inlineCode">std::filesystem::perms</code> enumeration. If you don’t specify a particular change operation, a complete replacement of existing permissions is performed. However, you can specify to add or remove permissions using the options available from the <code class="inlineCode">std::filesystem::perm_options</code> enumeration. Apart from <code class="inlineCode">replace</code>, <code class="inlineCode">add</code>, and <code class="inlineCode">remove</code>, there is a fourth option, <code class="inlineCode">nofollow</code>. This applies to symlinks, so that the permissions are changed on the symlink itself and not to the file it resolves to.</p>
<h2 class="heading-2" id="_idParaDest-471">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Working with filesystem paths</em>, to learn about the C++17 standard support for filesystem paths</li>
<li class="bulletList"><em class="italic">Removing content from a file</em>, to explore the possible ways of removing parts of the content of a file</li>
<li class="bulletList"><em class="italic">Checking the properties of an existing file or directory</em>, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</li>
</ul>
<h1 class="heading-1" id="_idParaDest-472">Removing content from a file</h1>
<p class="normal">Operations <a id="_idIndexMarker927"/>such as copying, renaming, moving, or deleting files are directly provided by the <code class="inlineCode">filesystem</code> library. However, when it comes to removing content from a file, you must perform explicit actions.</p>
<p class="normal">Regardless of whether you need to do this for text or binary files, you could implement the following pattern:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a temporary file.</li>
<li class="numberedList">Copy only the content that you want from the original file to the temporary file.</li>
<li class="numberedList">Delete the original file.</li>
<li class="numberedList">Rename/move the temporary file to the name/location of the original file.</li>
</ol>
<p class="normal">In this recipe, we will learn how to implement this pattern for a text file.</p>
<h2 class="heading-2" id="_idParaDest-473">Getting ready</h2>
<p class="normal">For the purpose of this recipe, we will consider removing empty lines, or lines that start with a semicolon (<code class="inlineCode">;</code>), from a text file. For this example, we will have an initial file, called <code class="inlineCode">sample.dat</code>, that contains the names of Shakespeare’s plays, but also empty lines and lines that start with a semicolon. The following is a partial listing of this file (from the beginning):</p>
<pre class="programlisting code"><code class="hljs-code">;Shakespeare's plays, listed by genre
;TRAGEDIES
Troilus and Cressida
Coriolanus
Titus Andronicus
Romeo and Juliet
Timon of Athens
Julius Caesar
</code></pre>
<p class="normal">The code<a id="_idIndexMarker928"/> samples listed in the next section use the following variables:</p>
<pre class="programlisting code"><code class="hljs-code">auto path = fs::current_path();
auto filepath = path / "sample.dat";
auto temppath = path / "sample.tmp";
auto err = std::error_code{};
</code></pre>
<p class="normal">We will learn how to put this pattern into code in the following section.</p>
<h2 class="heading-2" id="_idParaDest-474">How to do it...</h2>
<p class="normal">Perform the following operations to remove content from a file:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open the file for reading:
        <pre class="programlisting code"><code class="hljs-code">std::ifstream in(filepath);
if (!in.is_open())
{
  std::cout &lt;&lt; "File could not be opened!" &lt;&lt; '\n';
  return;
}
</code></pre>
</li>
<li class="numberedList">Open another temporary file for writing; if the file already exists, truncate its content:
        <pre class="programlisting code"><code class="hljs-code">std::ofstream out(temppath, std::ios::trunc);
if (!out.is_open())
{
  std::cout &lt;&lt; "Temporary file could not be created!" &lt;&lt; '\n';
  return;
}
</code></pre>
</li>
<li class="numberedList">Read, line by line, from the input file and copy the selected content to the output file:
        <pre class="programlisting code"><code class="hljs-code">auto line = std::string{};
while (std::getline(in, line))
{
  if (!line.empty() &amp;&amp; line.at(0) != ';')
  {
    out &lt;&lt; line &lt;&lt; 'n';
  }
}
</code></pre>
</li>
<li class="numberedList">Close <a id="_idIndexMarker929"/>both the input and output files:
        <pre class="programlisting code"><code class="hljs-code">in.close();
out.close();
</code></pre>
</li>
<li class="numberedList">Delete the original file:
        <pre class="programlisting code"><code class="hljs-code">auto success = fs::remove(filepath, err);
if(!success || err)
{
  std::cout &lt;&lt; err.message() &lt;&lt; '\n';
  return;
}
</code></pre>
</li>
<li class="numberedList">Rename/move the temporary file to the name/location of the original file:
        <pre class="programlisting code"><code class="hljs-code">fs::rename(temppath, filepath, err);
if (err)
{
  std::cout &lt;&lt; err.message() &lt;&lt; '\n';
}
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-475">How it works...</h2>
<p class="normal">The pattern described here is the same for binary files too; however, to keep this short, we are only discussing an example with text files. The temporary file in this example is in the same directory as the original file. Alternatively, this can be located in a separate directory, such as a user temporary directory. To get a path to a temporary directory, you can use <code class="inlineCode">std::filesystem::temp_directory_path()</code>. On Windows systems, this function returns the same directory as <code class="inlineCode">GetTempPath()</code>. On POSIX systems, it returns the path specified in one of the environment variables <code class="inlineCode">TMPDIR</code>, <code class="inlineCode">TMP</code>, <code class="inlineCode">TEMP</code>, or <code class="inlineCode">TEMPDIR</code>, or, if none of them are available, it returns the path <code class="inlineCode">/tmp</code>.</p>
<p class="normal">How content from the original file is copied to the temporary file varies from one case to another, depending on what needs to be copied. In the preceding example, we have copied entire lines, unless they are empty or start with a semicolon. </p>
<p class="normal">For this purpose, we read the content<a id="_idIndexMarker930"/> of the original file, line by line, using <code class="inlineCode">std::getline()</code>, until there are no more lines to read. After all the necessary content has been copied, the files should be closed so they can be moved or deleted.</p>
<p class="normal">To complete the operation, there are three options:</p>
<ul>
<li class="bulletList">Delete the original file and rename the temporary file to the same name as the original one if they are in the same directory, or move the temporary file to the original file location if they are in different directories. This is the approach taken in this recipe. For this, we used the <code class="inlineCode">remove()</code> function to delete the original file and <code class="inlineCode">rename()</code> to rename the temporary file to the original filename.</li>
<li class="bulletList">Copy the content of the temporary file to the original file (for this, you can use either the <code class="inlineCode">copy()</code> or <code class="inlineCode">copy_file()</code> functions) and then delete the temporary file (use <code class="inlineCode">remove()</code> for this).</li>
<li class="bulletList">Rename the original file (for instance, changing the extension or the name) and then use the original filename to rename/move the temporary file.</li>
</ul>
<div><p class="normal">If you take the first approach mentioned here, then you must make sure that the temporary file that is later replacing the original file has the same file permissions as the original file; otherwise, depending on the context of your solution, it can lead to problems.</p>
</div>
<h2 class="heading-2" id="_idParaDest-476">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating, copying, and deleting files and directories</em>, to learn how to perform these basic operations with files and directories independently of the filesystem in use</li>
</ul>
<h1 class="heading-1" id="_idParaDest-477">Checking the properties of an existing file or directory</h1>
<p class="normal">The <code class="inlineCode">filesystem</code> library <a id="_idIndexMarker931"/>provides functions and types that enable developers to check for the existence of a filesystem object, such as a file or directory, its properties, such as the type (the file, directory, symbolic link, and more), the last write time, permissions, and more. In this recipe, we will look at what these types and functions are and how they can be used.</p>
<h2 class="heading-2" id="_idParaDest-478">Getting ready</h2>
<p class="normal">For the<a id="_idIndexMarker932"/> following code samples, we will use the namespace alias <code class="inlineCode">fs</code> for the <code class="inlineCode">std::filesystem</code> namespace. The <code class="inlineCode">filesystem</code> library is available in the header with the same name, <code class="inlineCode">&lt;filesystem&gt;</code>. Also, we will use the variables shown here, <code class="inlineCode">path</code> for the path of a file, and <code class="inlineCode">err</code> for receiving potential operating system error codes from the filesystem APIs:</p>
<pre class="programlisting code"><code class="hljs-code">auto path = fs::current_path() / "main.cpp";
auto err = std::error_code{};
</code></pre>
<p class="normal">Also, the function <code class="inlineCode">to_time_t</code> shown here will be referred to in this recipe:</p>
<pre class="programlisting code"><code class="hljs-code"> template &lt;typename TP&gt;
  std::time_t to_time_t(TP tp)
 {
     using namespace std::chrono;
     auto sctp = time_point_cast&lt;system_clock::duration&gt;(
       tp - TP::clock::now() + system_clock::now());
     return system_clock::to_time_t(sctp);
  }
</code></pre>
<p class="normal">Before continuing with this recipe, you should read the <em class="italic">Working with filesystem paths</em> recipe.</p>
<h2 class="heading-2" id="_idParaDest-479">How to do it...</h2>
<p class="normal">Use the following library functions to retrieve information about filesystem objects:</p>
<ul>
<li class="bulletList">To check whether a path refers to an existing filesystem object, use <code class="inlineCode">exists()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto exists = fs::exists(path, err);
std::cout &lt;&lt; "file exists: " &lt;&lt; std::boolalpha
          &lt;&lt; exists &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To check whether two different paths refer to the same filesystem object, use <code class="inlineCode">equivalent()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto same = fs::equivalent(path,
               fs::current_path() / "." / "main.cpp", err);
std::cout &lt;&lt; "equivalent: " &lt;&lt; same &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To retrieve the size of a file in bytes, use <code class="inlineCode">file_size()</code>. This does not require the file to be opened, so it should be preferred over the approach of opening the file and then using the <code class="inlineCode">seekg()</code>/<code class="inlineCode">tellg()</code> functions:
        <pre class="programlisting code"><code class="hljs-code">auto size = fs::file_size(path, err);
std::cout &lt;&lt; "file size: " &lt;&lt; size &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker933"/>retrieve the count of hard links to a filesystem object, use <code class="inlineCode">hard_link_count()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto links = fs::hard_link_count(path, err);
if(links != static_cast&lt;uintmax_t&gt;(-1))
  std::cout &lt;&lt; "hard links: " &lt;&lt; links &lt;&lt; '\n';
else
  std::cout &lt;&lt; "hard links: error" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To retrieve or set the last modification time for a filesystem object, use <code class="inlineCode">last_write_time()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto lwt = fs::last_write_time(path, err);
auto time = to_time_t(lwt);
auto localtime = std::localtime(&amp;time);
std::cout &lt;&lt; "last write time: "
          &lt;&lt; std::put_time(localtime, "%c") &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To retrieve the file attributes, such as the type and permissions (as if returned by the POSIX <code class="inlineCode">stat</code> function), use the <code class="inlineCode">status()</code> function. This function follows symbolic links. To retrieve the file attributes of a symbolic link without following it, use <code class="inlineCode">symlink_status()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto print_perm = [](fs::perms p)
{
  std::cout
    &lt;&lt; ((p &amp; fs::perms::owner_read) != fs::perms::none ?
       "r" : "-")
    &lt;&lt; ((p &amp; fs::perms::owner_write) != fs::perms::none ?
       "w" : "-")
    &lt;&lt; ((p &amp; fs::perms::owner_exec) != fs::perms::none ?
       "x" : "-")
    &lt;&lt; ((p &amp; fs::perms::group_read) != fs::perms::none ?
       "r" : "-")
    &lt;&lt; ((p &amp; fs::perms::group_write) != fs::perms::none ?
       "w" : "-")
    &lt;&lt; ((p &amp; fs::perms::group_exec) != fs::perms::none ?
       "x" : "-")
    &lt;&lt; ((p &amp; fs::perms::others_read) != fs::perms::none ?
       "r" : "-")
    &lt;&lt; ((p &amp; fs::perms::others_write) != fs::perms::none ?
       "w" : "-")
    &lt;&lt; ((p &amp; fs::perms::others_exec) != fs::perms::none ?
       "x" : "-")
    &lt;&lt; '\n';
};
auto status = fs::status(path, err);
std::cout &lt;&lt; "type: " &lt;&lt; static_cast&lt;int&gt;(status.type()) &lt;&lt; '\n';
std::cout &lt;&lt; "permissions: ";
print_perm(status.permissions());
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker934"/>check whether a path refers to a particular type of filesystem object, such as a file, directory, symbolic link, and so on, use the functions <code class="inlineCode">is_regular_file()</code>, <code class="inlineCode">is_directory()</code>, <code class="inlineCode">is_symlink()</code>, and so on:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; "regular file? " &lt;&lt;
          fs::is_regular_file(path, err) &lt;&lt; '\n';
std::cout &lt;&lt; "directory? " &lt;&lt;
          fs::is_directory(path, err) &lt;&lt; '\n';
std::cout &lt;&lt; "char file? " &lt;&lt;
          fs::is_character_file(path, err) &lt;&lt; '\n';
std::cout &lt;&lt; "symlink? " &lt;&lt;
          fs::is_symlink(path, err) &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To check whether a file or directory is empty, use the <code class="inlineCode">is_empty()</code> function:
        <pre class="programlisting code"><code class="hljs-code">bool empty = fs::is_empty(path, err);
if (!err)
{
   std::cout &lt;&lt; std::boolalpha
             &lt;&lt; "is_empty(): " &lt;&lt; empty &lt;&lt; '\n';
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-480">How it works...</h2>
<p class="normal">These<a id="_idIndexMarker935"/> functions (used to retrieve information about the filesystem files and directories) are, in general, simple and straightforward. However, some considerations are necessary:</p>
<ul>
<li class="bulletList">Checking whether a filesystem object exists can be done using <code class="inlineCode">exists()</code>, either by passing the path or a <code class="inlineCode">std::filesystem::file_status</code> object that was previously retrieved using the <code class="inlineCode">status()</code> function.</li>
<li class="bulletList">The <code class="inlineCode">equivalent()</code> function determines whether two filesystem objects have the same status, as retrieved by the function <code class="inlineCode">status()</code>. If neither path exists, or if both exist but neither is a file, directory, or symbolic link, then the function returns an error. Hard links to the same file object are equivalent. A symbolic link and its target are also equivalent.</li>
<li class="bulletList">The <code class="inlineCode">file_size()</code> function can only be used to determine the size of regular files and symbolic links that target a regular file. For any other types of file objects, such as directories, this function fails. This function returns the size of the file in bytes, or <code class="inlineCode">-1</code> if an error has occurred. If you want to determine whether a file is empty, you can use the <code class="inlineCode">is_empty()</code> function. This works for all types of filesystem objects, including directories.</li>
<li class="bulletList">The <code class="inlineCode">last_write_time()</code> function has two sets of overloads: one that is used to retrieve the last modification time of the filesystem object and one that is used to set the last modification time. Time is indicated by a <code class="inlineCode">std::filesystem::file_time_type</code> object, which is basically a type alias for <code class="inlineCode">std::chrono::time_point</code>. The following example changes the last write time for a file to 30 minutes earlier than its previous value:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::chrono_literals;
auto lwt = fs::last_write_time(path, err);
fs::last_write_time(path, lwt - 30min);
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">status()</code> function determines the type and permissions of a filesystem object. If the file is a symbolic link, the information returned is about the target of the symbolic link. To retrieve information about the symbolic link itself, the <code class="inlineCode">symlink_status()</code> function must be used. These functions return a <code class="inlineCode">std::filesystem::file_status</code> object. 
    <p class="bulletList">This class has a <code class="inlineCode">type()</code> member function to retrieve the file type, and a <code class="inlineCode">permissions()</code> member function to retrieve the file permissions. The type of a file is defined with the <code class="inlineCode">std::filesystem::file_type</code> enumeration. Permissions of a file are defined with the <code class="inlineCode">std::filesystem::perms</code> enumeration. Not all the enumerators of this enumeration represent permissions; some of them represent controlling bits, such as <code class="inlineCode">add_perms</code>, to indicate that permissions should <a id="_idIndexMarker936"/>be added, or <code class="inlineCode">remove_perms</code>, to indicate that permissions should be removed. The <code class="inlineCode">permissions()</code> function can be used to modify the permissions of a file or a directory. The following example adds all permissions to the owner and user group of a file:</p>
<pre class="programlisting code"><code class="hljs-code">fs::permissions(
  path,
  fs::perms::add_perms |
  fs::perms::owner_all | fs::perms::group_all,
  err);
</code></pre></li>
</ul>
<ul>
<li class="bulletList">To determine the type of a filesystem object, such as a file, directory, or symbolic link, there are two options available: retrieve the file status and then check the <code class="inlineCode">type</code> property, or use one of the available filesystem functions, such as <code class="inlineCode">is_regular_file()</code>, <code class="inlineCode">is_symlink()</code>, or <code class="inlineCode">is_directory()</code>. The following examples that check whether a path refers to a regular file are equivalent:
        <pre class="programlisting code"><code class="hljs-code">auto s = fs::status(path, err);
auto isfile = s.type() == std::filesystem::file_type::regular;
auto isfile = fs::is_regular_file(path, err);
</code></pre>
</li>
</ul>
<p class="normal">All of the functions discussed in this recipe have an overload that throws exceptions if an error occurs, and an overload that does not throw but returns an error code via a function parameter. All of the examples in this recipe used this approach. More information about these sets of overloads can be found in the <em class="italic">Creating, copying, and deleting files and directories</em> recipe. Although the snippets in this recipe don’t show it (for simplicity), it’s important that you check the <code class="inlineCode">error_code</code> value returned by these functions. The actual meaning of each value it holds depends on the call that returned it and the value category (such as system, I/O streams, or generic) it belongs to. However, the value <code class="inlineCode">0</code> is considered to indicate success in all value categories. Therefore, you can check for success as follows:</p>
<pre class="programlisting code"><code class="hljs-code">auto lwt = fs::last_write_time(path, err);
if (!err) // success
{
   auto time = to_time_t(lwt);
   auto localtime = std::localtime(&amp;time);
   std::cout &lt;&lt; "last write time: "
             &lt;&lt; std::put_time(localtime, "%c") &lt;&lt; '\n';
}
</code></pre>
<p class="normal">If you <a id="_idIndexMarker937"/>use the overloads that don’t return an error code but throw an exception, then you need to catch that possible exception. Here is an example:</p>
<pre class="programlisting code"><code class="hljs-code">try
{
   auto exists = fs::exists(path);
   std::cout &lt;&lt; "file exists: " &lt;&lt; std::boolalpha &lt;&lt; exists &lt;&lt; '\n';
}
catch (std::filesystem::filesystem_error const&amp; ex)
{
   std::cerr &lt;&lt; ex.what() &lt;&lt; '\n';
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-481">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Working with filesystem paths</em>, to learn about the C++17-standard support for filesystem paths</li>
<li class="bulletList"><em class="italic">Creating, copying, and deleting files and directories</em>, to learn how to perform these basic operations with files and directories independently of the filesystem in use</li>
<li class="bulletList"><em class="italic">Enumerating the content of a directory</em>, to learn how to iterate through the files and subdirectories of a directory</li>
</ul>
<h1 class="heading-1" id="_idParaDest-482">Enumerating the content of a directory</h1>
<p class="normal">So far in this chapter, we <a id="_idIndexMarker938"/>have looked at many of the functionalities provided by the <code class="inlineCode">filesystem</code> library, such as working with paths, performing operations with files and directories (creating, moving, renaming, deleting, and so on), and querying or modifying properties. Another useful functionality when working with the filesystem is to iterate through the content of a directory. The <code class="inlineCode">filesystem</code> library provides two directory iterators, one called <code class="inlineCode">directory_iterator</code>, which iterates the content of a directory, and one called <code class="inlineCode">recursive_directory_iterator</code>, which recursively iterates the content of a directory and its subdirectories. In this recipe, we will learn how to use them.</p>
<h2 class="heading-2" id="_idParaDest-483">Getting ready</h2>
<p class="normal">For this recipe, we will consider a directory with the following structure:</p>
<pre class="programlisting code"><code class="hljs-code">test/
├──data/
│ ├──input.dat
│ └──output.dat
├──file_1.txt
├──file_2.txt
└──file_3.log
</code></pre>
<p class="normal">In the following snippets, we will refer to the following function:</p>
<pre class="programlisting code"><code class="hljs-code">void print_line(std::string_view prefix, 
                std::filesystem::path const&amp; path)
{
   std::cout &lt;&lt; prefix &lt;&lt; path &lt;&lt; '\n';
}
</code></pre>
<p class="normal">In this recipe, we will work with filesystem paths and check the properties of a filesystem object. Therefore, it is recommended that you first read the <em class="italic">Working with filesystem paths</em> and <em class="italic">Checking the properties of an existing file or directory</em> recipes.</p>
<h2 class="heading-2" id="_idParaDest-484">How to do it...</h2>
<p class="normal">Use the following patterns to enumerate the content of a directory:</p>
<ul>
<li class="bulletList">To iterate only the content of a directory without recursively visiting its subdirectories, use <code class="inlineCode">directory_iterator</code>:
        <pre class="programlisting code"><code class="hljs-code">void visit_directory(fs::path const &amp; dir)
{
  if (fs::exists(dir) &amp;&amp; fs::is_directory(dir))
  {
    for (auto const &amp; entry : fs::directory_iterator(dir))
    {
      auto filename = entry.path().filename();
      if (fs::is_directory(entry.status()))
        print_line("[+]", filename);
      else if (fs::is_symlink(entry.status()))
        print_line("[&gt;]", filename);
      else if (fs::is_regular_file(entry.status()))
        print_line(" ", filename);
      else
        print_line("[?]", filename);
    }
  }
}
</code></pre>
</li>
<li class="bulletList">To iterate <a id="_idIndexMarker939"/>all the content of a directory, including its subdirectories, use <code class="inlineCode">recursive_directory_iterator</code> when the order of processing the entries does not matter:
        <pre class="programlisting code"><code class="hljs-code">void visit_directory_rec(fs::path const &amp; dir)
{
  if (fs::exists(dir) &amp;&amp; fs::is_directory(dir))
  {
    for (auto const &amp; entry :
         fs::recursive_directory_iterator(dir))
    {
      auto filename = entry.path().filename();
      if (fs::is_directory(entry.status()))
        print_line("[+]", filename);
      else if (fs::is_symlink(entry.status()))
        print_line("[&gt;]",filename);
      else if (fs::is_regular_file(entry.status()))
        print_line(" ",filename);
      else
        print_line("[?]",filename);
    }
  }
}
</code></pre>
</li>
<li class="bulletList">To iterate all the content of a directory, including its subdirectories, in a structured manner, such as traversing a tree, use a function similar to the one in the first example, which uses <code class="inlineCode">directory_iterator</code> to iterate the content <a id="_idIndexMarker940"/>of a directory. However, instead, call it recursively for each subdirectory:
        <pre class="programlisting code"><code class="hljs-code">void visit_directory_rec_ordered(
  fs::path const &amp; dir,
 bool const recursive = false,
 unsigned int const level = 0)
{
  if (fs::exists(dir) &amp;&amp; fs::is_directory(dir))
  {
    auto lead = std::string(level*3, ' ');
    for (auto const &amp; entry : fs::directory_iterator(dir))
    {
      auto filename = entry.path().filename();
      if (fs::is_directory(entry.status()))
      {
        print_line(lead + "[+]", filename);
        if(recursive)
          visit_directory_rec_ordered(entry, recursive, 
 level+1);
      }
      else if (fs::is_symlink(entry.status()))
        print_line(lead + "[&gt;]", filename);
      else if (fs::is_regular_file(entry.status()))
        print_line(lead + " ", filename);
      else
        print_line(lead + "[?]", filename);
    }
  }
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-485">How it works...</h2>
<p class="normal">Both <code class="inlineCode">directory_iterator</code> and <code class="inlineCode">recursive_directory_iterator</code> are input iterators that iterate over the entries of a directory. The difference is that the first one does not visit the subdirectories recursively, while the second one, as its name implies, does. They both share a similar behavior:</p>
<ul>
<li class="bulletList">The order of iteration is unspecified.</li>
<li class="bulletList">Each directory entry is visited only once.</li>
<li class="bulletList">The special paths dot (<code class="inlineCode">.</code>) and dot-dot (<code class="inlineCode">..</code>) are skipped.</li>
<li class="bulletList">A default-constructed iterator is the end iterator, and two end iterators are always equal.</li>
<li class="bulletList">When iterated past the last directory entries, it becomes equal to the end iterator.</li>
<li class="bulletList">The standard does not specify what happens if a directory entry is added to, or deleted from, the iterated directory after the iterator has been created.</li>
<li class="bulletList">The standard defines the non-member functions <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> for both <code class="inlineCode">directory_iterator</code> and <code class="inlineCode">recursive_directory_iterator</code>, which enables us to use these iterators in range-based <code class="inlineCode">for</code> loops, as shown in the examples earlier.</li>
</ul>
<p class="normal">Both<a id="_idIndexMarker941"/> iterators have overloaded constructors. Some overloads of the <code class="inlineCode">recursive_directory_iterator</code> constructor take an argument of the <code class="inlineCode">std::filesystem::directory_options</code> type, which specifies additional options for the iteration:</p>
<ul>
<li class="bulletList"><code class="inlineCode">none</code>: This is the default, which does not specify anything.</li>
<li class="bulletList"><code class="inlineCode">follow_directory_symlink</code>: This specifies that the iteration should follow symbolic links instead of serving the link itself.</li>
<li class="bulletList"><code class="inlineCode">skip_permission_denied</code>: This specifies that you should ignore and skip the directories that could trigger an access denied error.</li>
</ul>
<p class="normal">The elements that both directory iterators point to are of the <code class="inlineCode">directory_entry</code> type. The <code class="inlineCode">path()</code> member function returns the path of the filesystem object represented by this object. The status of the filesystem object can be retrieved with the member functions <code class="inlineCode">status()</code> and <code class="inlineCode">symlink_status()</code> for symbolic links.</p>
<p class="normal">The preceding examples follow a common pattern:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Verify that the path to iterate actually exists.</li>
<li class="numberedList">Use a range-based <code class="inlineCode">for</code> loop to iterate all the entries of a directory.</li>
<li class="numberedList">Use one of the two directory iterators available in the <code class="inlineCode">filesystem</code> library, depending on the way the iteration is supposed to be done.</li>
<li class="numberedList">Process each entry according to the requirements.</li>
</ol>
<p class="normal">In our examples, we simply printed the names of the directory entries to the console. It is important to note, as we specified earlier, that the content of the directory is iterated in an unspecified order. If you want to process the content in a structured manner, such as showing subdirectories and their entries indented (for this particular case) or in a tree (in other types of applications), then using <code class="inlineCode">recursive_directory_iterator</code> is not appropriate. Instead, you should use <code class="inlineCode">directory_iterator</code> in a function that is called recursively from the iteration, for each subdirectory, as shown in the last example from the previous section.</p>
<p class="normal">Considering the <a id="_idIndexMarker942"/>directory structure presented at the beginning of this recipe (relative to the current path), we get the following output when using the recursive iterator, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">visit_directory_rec(fs::current_path() / "test");
</code></pre>
<pre class="programlisting con"><code class="hljs-con">[+]data
   input.dat
   output.dat
   file_1.txt
   file_2.txt
   file_3.log
</code></pre>
<p class="normal">On the other hand, when using the recursive function from the third example, as shown in the following listing, the output is displayed in order of sublevels, as intended:</p>
<pre class="programlisting code"><code class="hljs-code">visit_directory_rec_ordered(fs::current_path() / "test", true);
</code></pre>
<pre class="programlisting con"><code class="hljs-con">[+]data
      input.dat
      output.dat
   file_1.txt
   file_2.txt
   file_3.log
</code></pre>
<p class="normal">Remember that the <code class="inlineCode">visit_directory_rec()</code> function is a non-recursive function that uses <code class="inlineCode">recursive_directory_iterator</code>, while the <code class="inlineCode">visit_directory_rec_ordered()</code> function is a recursive function that uses <code class="inlineCode">directory_iterator</code>. This example should help you to understand the difference between the two iterators.</p>
<h2 class="heading-2" id="_idParaDest-486">There’s more...</h2>
<p class="normal">In the previous recipe, <em class="italic">Checking the properties of an existing file or directory</em>, we discussed, among other things, the <code class="inlineCode">file_size()</code> function, which returns the size of a file in bytes. However, this function fails if the specified path is a directory. To determine the size of a directory, we need to iterate recursively through the content of a directory, retrieve the size of the regular files or symbolic links, and add them together.</p>
<p class="normal">Consider the following function to exemplify this case:</p>
<pre class="programlisting code"><code class="hljs-code">std::uintmax_t dir_size(fs::path const &amp; path)
{
   if (fs::exists(path) &amp;&amp; fs::is_directory(path))
   {
      auto size = static_cast&lt;uintmax_t&gt;(0);
      for (auto const &amp; entry :
           fs::recursive_directory_iterator(path))
      {
         if (fs::is_regular_file(entry.status()) ||
            fs::is_symlink(entry.status()))
         {
            auto err = std::error_code{};
            auto filesize = fs::file_size(entry, err);
            if (!err)
               size += filesize;
         }
      }
      return size;
   }
   return static_cast&lt;uintmax_t&gt;(-1);
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker943"/>preceding <code class="inlineCode">dir_size()</code> function returns the size of all the files in a directory (recursively), or <code class="inlineCode">-1</code>, as a <code class="inlineCode">uintmax_t</code>, in the case of an error (the path does not exist or does not represent a directory).</p>
<h2 class="heading-2" id="_idParaDest-487">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Checking the properties of an existing file or directory</em>, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</li>
<li class="bulletList"><em class="italic">Finding a file</em>, to learn how to search for files based on their name, extension, or other properties</li>
</ul>
<h1 class="heading-1" id="_idParaDest-488">Finding a file</h1>
<p class="normal">In the <a id="_idIndexMarker944"/>previous recipe, we learned how to use <code class="inlineCode">directory_iterator</code> and <code class="inlineCode">recursive_directory_iterator</code> to enumerate the content of a directory. Displaying the content of a directory, as we did in the previous recipe, is only one of the scenarios in which this is needed. The other major scenario is when searching for particular entries in a directory, such as files with a particular name, extension, and so on. In this recipe, we will demonstrate how we can use the directory iterators and the iterating patterns shown earlier to find files that match a given criterion.</p>
<h2 class="heading-2" id="_idParaDest-489">Getting ready</h2>
<p class="normal">You should read the previous recipe, <em class="italic">Enumerating the content of a directory</em>, for details about directory iterators. In this recipe, we will also use the same test directory structure that was presented in the previous recipe.</p>
<h2 class="heading-2" id="_idParaDest-490">How to do it...</h2>
<p class="normal">To find files that match particular criteria, use the following pattern:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Use <code class="inlineCode">recursive_directory_iterator</code> to iterate through all the entries of a directory and recursively through its subdirectories.</li>
<li class="numberedList">Consider regular files (and any other types of files you may need to process).</li>
<li class="numberedList">Use a function object (such as a lambda expression) to filter only the files that match your criteria.</li>
<li class="numberedList">Add the selected entries to a container (such as a vector).</li>
</ol>
<p class="normal">This pattern is exemplified in the <code class="inlineCode">find_files()</code> function shown here:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;fs::path&gt; find_files(
    fs::path const &amp; dir,
    std::function&lt;bool(fs::path const&amp;)&gt; filter)
{
  auto result = std::vector&lt;fs::path&gt;{};
  if (fs::exists(dir))
  {
    for (auto const &amp; entry :
      fs::recursive_directory_iterator(
        dir,
        fs::directory_options::follow_directory_symlink))
    {
      if (fs::is_regular_file(entry) &amp;&amp;
          filter(entry))
      {
        result.push_back(entry);
      }
    }
  }
  return result;
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-491">How it works...</h2>
<p class="normal">When we want to <a id="_idIndexMarker945"/>find files in a directory, the structure of the directory and the order in which its entries, including subdirectories, are visited are probably not important. Therefore, we can use the <code class="inlineCode">recursive_directory_iterator</code> to iterate through the entries.</p>
<p class="normal">The <code class="inlineCode">find_files()</code> function takes two arguments: a path and a function wrapper that is used to select the entries that should be returned. The return type is a vector of <code class="inlineCode">filesystem::path</code>, though. Alternatively, it could also be a vector of <code class="inlineCode">filesystem::directory_entry</code>. The recursive directory iterator used in this example does not follow symbolic links, returning the link itself and not the target. This behavior can be changed by using a constructor overload that has an argument of the type <code class="inlineCode">filesystem::directory_options</code> and passing <code class="inlineCode">follow_directory_symlink</code>.</p>
<p class="normal">In the preceding example, we only consider the regular files and ignore the other types of filesystem objects. The predicate is applied to the directory entry and, if it returns <code class="inlineCode">true</code>, the entry is added to the result.</p>
<p class="normal">The following example uses the <code class="inlineCode">find_files()</code> function to find all of the files in the test directory that start with the prefix <code class="inlineCode">file_</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto results = find_files(
          fs::current_path() / "test",
          [](fs::path const &amp; p) {
  auto filename = p.wstring();
  return filename.find(L"file_") != std::wstring::npos;
});
for (auto const &amp; path : results)
{
  std::cout &lt;&lt; path &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The output of executing this program, with paths relative to the current path, is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">test\file_1.txt
test\file_2.txt
test\file_3.log
</code></pre>
<p class="normal">A second <a id="_idIndexMarker946"/>example shows how to find files that have a particular extension, in this case, the extension <code class="inlineCode">.dat</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto results = find_files(
       fs::current_path() / "test",
       [](fs::path const &amp; p) {
         return p.extension() == L".dat";});
for (auto const &amp; path : results)
{
  std::cout &lt;&lt; path &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The output, again relative to the current path, is shown here:</p>
<pre class="programlisting con"><code class="hljs-con">test\data\input.dat
test\data\output.dat
</code></pre>
<p class="normal">These two examples are very similar. The only thing that is different is the code in the lambda function, which checks the path received as an argument.</p>
<h2 class="heading-2" id="_idParaDest-492">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Checking the properties of an existing file or directory</em>, to learn how to query the properties of files and directories, such as the type, permissions, file times, and more</li>
<li class="bulletList"><em class="italic">Enumerating the content of a directory</em>, to learn how to iterate through the files and subdirectories of a directory</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_07.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>