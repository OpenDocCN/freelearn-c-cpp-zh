<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Procrastinating the Execution Process Using Lazy Evaluation</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discussed recursion for repeating the function invocation in the functional approach. Now, we will discuss lazy evaluation that can make our <span>code become more efficient since it will only run when we need it. We will also apply recursion, the topic w</span>e talked about in the previous chapter, to produce the lazy code.</p>
<p>In this chapter, we discuss <strong>lazy evaluation</strong> to make code run faster. This will make the code become efficient since it will make sure that unnecessary code won't be executed. The following are the topics we will discuss to dive into lazy evaluation:</p>
<ul>
<li>Distinguishing the difference between eager and lazy evaluation</li>
<li>Optimizing code using the caching technique</li>
<li>Refactoring eager evaluation into lazy evaluation</li>
<li>Designing the useful classes that can be reused in others' functional code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating the expression</h1>
                </header>
            
            <article>
                
<p>Every programming language has its own strategy to determine when to evaluate <span>the arguments of a function call and what type of value that has to be passed to the parameter. There are two kinds of strategy evaluation that are mostly used in a programming language--<strong>strict</strong> (eager) evaluation and <strong>non-strict</strong> (lazy) evaluation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the expression immediately with strict evaluation</h1>
                </header>
            
            <article>
                
<p>Strict evaluation is used in the most imperative programming language. It will immediately execute the code we have. Let's suppose we have the following equation:</p>
<pre>
    int i = (x + (y * z));
</pre>
<p>In a strict evaluation, the innermost bracket will be calculated first, then work outwards for the preceding equation. This means we will calculate <kbd>y * z</kbd>, then add the result to <kbd>x</kbd>. To make it clearer, let's see the following <kbd>strict.cpp</kbd> code:</p>
<pre class="mce-root">
    /* strict.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/> <br/>    int OuterFormula(int x, int yz)<br/>    {<br/>      // For logging purpose only<br/>      cout &lt;&lt; "Calculate " &lt;&lt; x &lt;&lt; " + ";<br/>      cout &lt;&lt; "InnerFormula(" &lt;&lt; yz &lt;&lt; ")";<br/>      cout &lt;&lt; endl;<br/><br/>      // Returning the calculation result<br/>      return x * yz;<br/>    }<br/><br/>    int InnerFormula(int y, int z)<br/>    {<br/>      // For logging purpose only<br/>      cout &lt;&lt; "Calculate " &lt;&lt; y &lt;&lt; " * ";<br/>      cout &lt;&lt; z &lt;&lt; endl;<br/>  <br/>      // Returning the calculation result<br/>      return y * z;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[strict.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing three int variables<br/>      // for the calculation<br/>      int x = 4;<br/>      int y = 3;<br/>      int z = 2;<br/> <br/>      // Calculating the expression<br/>      cout &lt;&lt; "Calculate " &lt;&lt; x &lt;&lt;" + ";<br/>      cout &lt;&lt; "(" &lt;&lt; y &lt;&lt; " * " &lt;&lt; z &lt;&lt; ")";<br/>      cout &lt;&lt; endl;<br/>      int result = OuterFormula(x, InnerFormula(y, z));<br/><br/>      // For logging purpose only<br/>      cout &lt;&lt; x &lt;&lt; " + ";<br/>      cout &lt;&lt; "(" &lt;&lt; y &lt;&lt; " * " &lt;&lt; z &lt;&lt; ")";<br/>      cout &lt;&lt; " = " &lt;&lt; result &lt;&lt; endl;<br/>   <br/>      return 0;<br/>    }
</pre>
<p>As we discussed earlier, the execution of the preceding code will be <kbd>y * z</kbd> first, then we will add the result to <kbd>x</kbd>, as we can see in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/5df7ea63-3801-47d1-9fbd-e50d30c1f8ec.png"/></div>
<p>The preceding execution order is what we usually expect. However, in non-strict evaluation, we will reorder this execution process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delaying the expression with non-strict evaluation</h1>
                </header>
            
            <article>
                
<p>In a non-strict evaluation, the <kbd>+</kbd> operator is reduced first, and then we reduce the inner formula, which is <kbd>(y * z)</kbd>. We will see that the evaluation will be started from the outside to the inside. We will refactor our previous <kbd>strict.cpp</kbd> code to make it become a non-strict evaluation. The code should be like the following <kbd>non_strict.cpp</kbd> code:</p>
<pre class="mce-root">
    /* non_strict.cpp */<br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/><strong>    int OuterFormulaNonStrict(</strong><br/><strong>      int x,</strong><br/><strong>      int y,</strong><br/><strong>      int z,</strong><br/><strong>      function&lt;int(int, int)&gt; yzFunc)</strong><br/><strong>      {</strong><br/><strong>         // For logging purpose only</strong><br/><strong>         cout &lt;&lt; "Calculate " &lt;&lt; x &lt;&lt; " + ";</strong><br/><strong>         cout &lt;&lt; "InnerFormula(" &lt;&lt; y &lt;&lt; ", ";</strong><br/><strong>         cout &lt;&lt; z &lt;&lt; ")" &lt;&lt; endl;</strong><br/><br/><strong>         // Returning the calculation result</strong><br/><strong>         return x * yzFunc(y, z);</strong><br/><strong>      }</strong><br/><br/>     int InnerFormula(int y, int z)<br/>     {<br/>       // For logging purpose only<br/>       cout &lt;&lt; "Calculate " &lt;&lt; y &lt;&lt; " * ";<br/>       cout &lt;&lt; z &lt;&lt; endl;<br/><br/>       // Returning the calculation result<br/>       return y * z;<br/>     }<br/><br/>     auto main() -&gt; int<br/>     {<br/>       cout &lt;&lt; "[non_strict.cpp]" &lt;&lt; endl;<br/><br/>       // Initializing three int variables<br/>       // for the calculation<br/>       int x = 4;<br/>       int y = 3;<br/>       int z = 2;<br/><br/>       // Calculating the expression<br/>       cout &lt;&lt; "Calculate " &lt;&lt; x &lt;&lt;" + ";<br/>       cout &lt;&lt; "(" &lt;&lt; y &lt;&lt; " * " &lt;&lt; z &lt;&lt; ")";<br/>       cout &lt;&lt; endl;<br/>       int result = OuterFormulaNonStrict(x, y, z, InnerFormula);<br/><br/>       // For logging purpose only<br/>       cout &lt;&lt; x &lt;&lt; " + ";<br/>       cout &lt;&lt; "(" &lt;&lt; y &lt;&lt; " * " &lt;&lt; z &lt;&lt; ")";<br/>       cout &lt;&lt; " = " &lt;&lt; result &lt;&lt; endl;<br/><br/>       return 0;<br/>    }
</pre>
<p>As we can see, we modify the <kbd>OuterFormula()</kbd> function in the <kbd>strict.cpp</kbd> code into an <kbd>OuterFormulaNonStrict()</kbd> function in the <kbd>non_strict.cpp</kbd> code. In the <kbd>OuterFormulaNonStrict()</kbd> function, we pass a function as the argument in addition to the three variables--<kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd>. As a result, the order of execution of the preceding expression is changed. Here is what we should see on the console screen when we run the <kbd>non_strict.cpp</kbd> code:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/ce639e69-1325-47bc-b524-6894d77af3b5.png"/></div>
<p>From the preceding output, we have proved that our code is performing non-strict evaluation since it now calculates the addition operator (<kbd>+</kbd>) first instead of the multiplication (<kbd>*</kbd>). However, the result is still correct, although the order has been changed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The basic concept of lazy evaluation</h1>
                </header>
            
            <article>
                
<p>Before we create a <span>lazy code, let's discuss the basic concepts of lazy evaluation. We will use the delaying process to make our code lazy, the caching technique to increase the performance of the code by avoiding needless calculations, and the optimizing technique to speed up the code by storing the results of expensive function calls and returning the cached result when the same inputs occur again. After we have looked at these techniques, we will try to develop the real lazy code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delaying the process</h1>
                </header>
            
            <article>
                
<p>The basic concept of laziness is delaying a process. In this section, we will discuss how to delay the execution of a particular process. We will create a new class named <kbd>Delay</kbd>. We will pass a function into it when we construct the class. The function won't be run unless we invoke the <kbd>Fetch()</kbd> method. The implementation of the function is as follows:</p>
<pre>
    template&lt;class T&gt; class Delay<br/>    {<br/>      private:<br/>        function&lt;T()&gt; m_func;<br/><br/>      public:<br/>        Delay(<br/>          function&lt;T()&gt; func)<br/>          : m_func(func)<br/>          {<br/>          }<br/><br/>        T Fetch()<br/>        {<br/>          return m_func();<br/>        }<br/>    };
</pre>
<p>Now, let's consume the <kbd>Delay</kbd> class to procrastinate the execution. We will create a file named <kbd>delaying.cpp</kbd> that will run two functions--<kbd>multiply</kbd> and <kbd>division</kbd>. However, these two functions will only be run after we call the <kbd>Fetch()</kbd> method. The content of the file is as follows:</p>
<pre>
    /* delaying.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;functional&gt;<br/><br/>    using namespace std;<br/><br/>    template&lt;class T&gt; class Delay<br/>    {<br/>      private:<br/>        function&lt;T()&gt; m_func;<br/><br/>      public:<br/>        Delay(function&lt;T()&gt; func) : m_func(func)<br/>        {<br/>        }<br/><br/>        T Fetch()<br/>        {<br/>          return m_func();<br/>        }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[delaying.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several int variables<br/>      int a = 10;<br/>      int b = 5;<br/><br/>      cout &lt;&lt; "Constructing Delay&lt;&gt; named multiply";<br/>      cout &lt;&lt; endl;<br/>      Delay&lt;int&gt; multiply([a, b]()<br/>      {<br/>        cout &lt;&lt; "Delay&lt;&gt; named multiply";<br/>        cout &lt;&lt; " is constructed." &lt;&lt; endl;<br/>        return a * b;<br/>      });<br/><br/>     cout &lt;&lt; "Constructing Delay&lt;&gt; named division";<br/>     cout &lt;&lt; endl;<br/>     Delay&lt;int&gt; division([a, b]()<br/>     {<br/>       cout &lt;&lt; "Delay&lt;&gt; named division ";<br/>       cout &lt;&lt; "is constructed." &lt;&lt; endl;<br/>       return a / b; <br/>     });<br/><br/>     cout &lt;&lt; "Invoking Fetch() method in ";<br/>     cout &lt;&lt; "multiply instance." &lt;&lt; endl;<br/>     int c = multiply.Fetch();<br/><br/>     cout &lt;&lt; "Invoking Fetch() method in ";<br/>     cout &lt;&lt; "division instance." &lt;&lt; endl;<br/>     int d = division.Fetch();<br/><br/>     // Displaying the result<br/>     cout &lt;&lt; "The result of a * b = " &lt;&lt; c &lt;&lt; endl;<br/>     cout &lt;&lt; "The result of a / b = " &lt;&lt; d &lt;&lt; endl;<br/><br/>     return 0;<br/>    }
</pre>
<p>As we discussed in <a href="58c8c3cc-432a-4664-be4d-a78917b16f15.xhtml" target="_blank">Chapter 1</a>, <em>Diving into Modern C++</em>, we can use a Lambda expression to build <span>the <kbd>multiply</kbd></span> <span>and</span> <kbd>division</kbd> <span>functions. We then pass them in each <kbd>Delay</kbd> constructor. In this stage, the function is not run yet. It will be run after the <kbd>Fetch()</kbd> method is invoked--<kbd>multiply.Fetch()</kbd> and <kbd>division.Fetch()</kbd>.</span> <span>The output we will see on the screen should look like the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/5ade918f-d163-4d2b-9d84-d41ddc962d86.png"/></div>
<p>As we can see in the preceding output screenshot, the <kbd>multiply</kbd> and <kbd>division</kbd> instance is constructed when the <kbd>Fetch()</kbd> method is invoked (see the two white arrows), not when the constructor of the <kbd>Delay</kbd> class is invoked. Now, we have successfully delayed the execution, and we can say that the process is only executed when it is needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching the value using the memoization technique</h1>
                </header>
            
            <article>
                
<p>We now have successfully delayed the execution of the function by consuming the <kbd>Delay</kbd> class. However, since the function of the <kbd>Delay</kbd> class instance will be run each time the <kbd>Fetch()</kbd> method is invoked, an unexpected result might occur if the function is not pure or has side effects. Let's refactor our previous <kbd>delaying.cpp</kbd> code by modifying the <kbd>multiply</kbd> function. This function now becomes a non-pure function since it depends on an outside variable. The code should look like this:</p>
<pre>
    /* delaying_non_pure.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;functional&gt;<br/><br/>    using namespace std;<br/><br/>    template&lt;class T&gt; class Delay<br/>    {<br/>      private:<br/>        function&lt;T()&gt; m_func;<br/><br/>      public:<br/>        Delay(function&lt;T()&gt; func) : m_func(func)<br/>        {<br/>        }<br/> <br/>        T Fetch()<br/>        {<br/>          return m_func();<br/>        }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[delaying_non_pure.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several int variables<br/>      int a = 10;<br/>      int b = 5;<br/>      int multiplexer = 0;<br/><br/>      // Constructing Delay&lt;&gt; named multiply_impure<br/>      Delay&lt;int&gt; multiply_impure([&amp;]()<br/>      {<br/>        return multiplexer * a * b;<br/>      });<br/><br/>      // Invoking Fetch() method in multiply_impure instance<br/>      // multiple times<br/>      for (int i = 0; i &lt; 5; ++i)<br/>      {<br/>        ++multiplexer;<br/>        cout &lt;&lt; "Multiplexer = " &lt;&lt; multiplexer &lt;&lt; endl;<br/>        cout &lt;&lt; "a * b = " &lt;&lt; multiply_impure.Fetch();<br/>        cout &lt;&lt; endl;<br/>      }<br/> <br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we now have a new Lambda expression named <kbd>multiply_impure</kbd>, which is the refactored version of the <kbd>multiply</kbd> function we created in the <kbd>delaying.cpp</kbd> <span>code. The <kbd>multiply_impure</kbd> function depends on the <kbd>multiplexer</kbd> variable, whose value will be increased each time before we invoke the <kbd>Fetch()</kbd> method. The following is the screenshot output we should see on the screen:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/f1e15207-1b93-4d22-b534-54ce6b0bba97.png"/></div>
<p>As we can see, the <kbd>Fetch()</kbd> method gives a different result each time it's invoked. We now have to refactor the <kbd>Delay</kbd> class to ensure that it will return the exact same result each time the <kbd>Fetch()</kbd> method runs the function with the same passed arguments. To achieve it, we will use the memoization technique that stores the results of the function calls and returns the cached result when the same inputs occur again.</p>
<p>We will rename the <kbd>Delay</kbd> class to <kbd>Memoization</kbd> class. This will not only delay the function call, it will also record the function with specific passed arguments. So the next time the function with those arguments occurs, the function itself will not be run but it will just return the cached result instead. To ease our discussion, let's take a look at the following <kbd>Memoization</kbd> <span>class implementation:<br/></span></p>
<pre class="mce-root">
    template&lt;class T&gt; class Memoization<br/>    {<br/>      private:<br/>        T const &amp; (*m_subRoutine)(Memoization *);<br/>        mutable T m_recordedFunc;<br/>        function&lt;T()&gt; m_func;<br/><br/>        static T const &amp; ForceSubroutine(Memoization * d)<br/>        {<br/>          return d-&gt;DoRecording();<br/>        }<br/><br/>        static T const &amp; FetchSubroutine(Memoization * d)<br/>        {<br/>          return d-&gt;FetchRecording();<br/>        }<br/><br/>        T const &amp; FetchRecording()<br/>        {<br/>          return m_recordedFunc;<br/>        }<br/><br/>        T const &amp; DoRecording()<br/>        {<br/>          m_recordedFunc = m_func();<br/>          m_subRoutine = &amp;FetchSubroutine;<br/>          return FetchRecording();<br/>        }<br/><br/>     public:<br/>        Memoization(function&lt;T()&gt; func) : m_func(func),<br/>         m_subRoutine(&amp;ForceSubroutine),<br/>         m_recordedFunc(T())<br/>        {<br/>        }<br/><br/>       T Fetch()<br/>       {<br/>         return m_subRoutine(this);<br/>       }<br/>    };
</pre>
<p><span>As we can see in the preceding code snippet, we now have <kbd>FetchRecording()</kbd> and <kbd>DoRecording()</kbd> to get and set the function we have stored. Moreover, when the class is constructed, it will record the passed function and save it to <kbd>m_subRoutine</kbd>. The class will inspect <kbd>m_subRoutine</kbd> when the <kbd>Fetch()</kbd> method is called and find whether it has the value from the function with current passed arguments. If yes, it simply returns the value from <kbd>m_subRoutine</kbd> instead of running the function. Now, let's see the following</span> <kbd>delaying_non_pure_memoization.cpp</kbd> <span>code, that consumes the <kbd>Memoization</kbd> class:<br/></span></p>
<pre class="mce-root">
    /* delaying_non_pure_memoization.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;functional&gt;<br/><br/>    using namespace std;<br/><br/>    template&lt;class T&gt; class Memoization<br/>    {<br/>      private:<br/>        T const &amp; (*m_subRoutine)(Memoization *);<br/>        mutable T m_recordedFunc;<br/>        function&lt;T()&gt; m_func;<br/><br/>        static T const &amp; ForceSubroutine(Memoization * d)<br/>        {<br/>          return d-&gt;DoRecording();<br/>        }<br/>  <br/>       static T const &amp; FetchSubroutine(Memoization * d)<br/>       {<br/>          return d-&gt;FetchRecording();<br/>       }<br/><br/>       T const &amp; FetchRecording()<br/>       {<br/>          return m_recordedFunc;<br/>       }<br/><br/>       T const &amp; DoRecording()<br/>       {<br/>          m_recordedFunc = m_func();<br/>          m_subRoutine = &amp;FetchSubroutine;<br/>          return FetchRecording();<br/>       }<br/><br/>     public:<br/>       Memoization(function&lt;T()&gt; func) : m_func(func),<br/>        m_subRoutine(&amp;ForceSubroutine),<br/>        m_recordedFunc(T())<br/>       {<br/>       }<br/><br/>      T Fetch()<br/>      {<br/>        return m_subRoutine(this);<br/>      }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[delaying_non_pure_memoization.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several int variables<br/>      int a = 10;<br/>      int b = 5;<br/>      int multiplexer = 0;<br/><br/><strong>      // Constructing Memoization&lt;&gt; named multiply_impure</strong><br/><strong>      Memoization&lt;int&gt; multiply_impure([&amp;]()</strong><br/><strong>      {</strong><br/><strong>        return multiplexer * a * b;</strong><br/><strong>      });</strong><br/><br/>      // Invoking Fetch() method in multiply_impure instance<br/>      // multiple times<br/>      for (int i = 0; i &lt; 5; ++i)<br/>      {<br/>        ++multiplexer;<br/>        cout &lt;&lt; "Multiplexer = " &lt;&lt; multiplexer &lt;&lt; endl;<br/>        cout &lt;&lt; "a * b = " &lt;&lt; multiply_impure.Fetch();<br/>        cout &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p><span>From the preceding code snippet, we see we don't have much modification in the <kbd>main()</kbd> function. What we modify is only the class type we use for the <kbd>multiply_impure</kbd> variable, from <kbd>Delay</kbd> to <kbd>Memoization</kbd>. However, the result has now changed since we will get the exact same return value from the five times invocation of the <kbd>multiply_impure()</kbd> function. Let's take a look at the following screenshot to prove it:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/eb597eec-cfe2-4c06-b0eb-a546e3a26fb5.png"/></div>
<p>From the preceding screenshot, we can see that even the value of the <kbd>Multiplexer</kbd> is increased and the return of the calculation is always the same. This is because the return value of the first function invocation is recorded, so there's no need to run the function again for the remaining invocation.</p>
<div class="packt_infobox">As we discussed in <a href="a1baf007-8f40-4616-8718-9887f95120b0.xhtml" target="_blank">Chapter 2</a>, <em>Manipulating Functions in Functional Programming</em>, having an impure function seems wrong in functional programming. Hiding an impure function behind memoization might also cause a bug if the code really needs a different result (non-cached result). Use the preceding technique for caching the impure function wisely.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizing the code using the memoization technique</h1>
                </header>
            
            <article>
                
<p>Memoization is quite useful for applying in a non-pure function or a function that has been the side effect. However, it can also be used to optimize the code. By using memoization, the code we have developed will be run faster. Let's suppose we need to run the exact same functions with the exact same passed arguments multiple times. It will be faster if the code fetches the value from the place we record the value instead of running the function. It would also be better for an expensive function call because by using memoization, we don't need to execute the unnecessary expensive function call over and over again.<br/>
Let's create a code to discuss the further optimization. We will use the <kbd>Delay</kbd> class to demonstrate it's not an optimized code compared to the <kbd>Memoization</kbd> class. We will have the <kbd>not_optimize_code.cpp</kbd> code that will consume the <kbd>Delay</kbd> <span>class. In this unoptimized code, we will call the <kbd>fibonacci()</kbd> function that we created in <a href="7c3fb034-5951-4003-905f-48dd745a1c6f.xhtml" target="_blank">Chapter 4</a>, <em>Repeating Method Invocation Using Recursive Algorithm</em>. We will pass <kbd>40</kbd> as the argument to the <kbd>fibonacci()</kbd> function and call the <kbd>Fetch()</kbd> method from the <kbd>fib40</kbd> class instance five times. We will also calculate the elapsed time in each invocation of the method, using the <kbd>high_resolution_clock</kbd> class resided in the <kbd>chrono</kbd> header, to record the <strong>start</strong> and <strong>end</strong> time to retrieve the elapsed time by subtracting the end value with the start value. In addition to the elapsed time of each <kbd>Fetch()</kbd> method invocation, we also calculate the elapsed time of the entire code.</span> <span>The implementation of the <kbd>not_optimize_code.cpp</kbd> code is as follows:</span></p>
<pre>
    /* not_optimize_code.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;functional&gt;<br/>    #include &lt;chrono&gt;<br/><br/>    using namespace std;<br/><br/>    template&lt;class T&gt; class Delay<br/>    {<br/>      private:<br/>        function&lt;T()&gt; m_func;<br/><br/>      public:<br/>        Delay(function&lt;T()&gt; func): m_func(func)<br/>        {<br/>        }<br/><br/>        T Fetch()<br/>        {<br/>          return m_func();<br/>        }<br/>    };<br/><br/>    // Function for calculating Fibonacci sequence<br/>    int fibonacci(int n)<br/>    {<br/>      if(n &lt;= 1)<br/>         return n;<br/>      return fibonacci(n-1) + fibonacci(n-2);<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[not_optimize_code.cpp]" &lt;&lt; endl;<br/>      <br/>      // Recording start time for the program<br/>      auto start = chrono::high_resolution_clock::now();<br/>      <br/>      // Initializing int variable to store the result<br/>      // from Fibonacci calculation<br/>      int fib40Result = 0;<br/><br/>      // Constructing Delay&lt;&gt; named fib40<br/>      Delay&lt;int&gt; fib40([]()<br/>      {<br/>        return fibonacci(40);<br/>      });<br/><br/>      for (int i = 1; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "Invocation " &lt;&lt; i &lt;&lt; ". ";<br/><br/>        // Recording start time<br/>        auto start = chrono::high_resolution_clock::now();<br/><br/>        // Invoking the Fetch() method<br/>        // in fib40 instance<br/>        fib40Result = fib40.Fetch();<br/><br/>        // Recording end time<br/>        auto finish = chrono::high_resolution_clock::now();<br/><br/>        // Calculating the elapsed time<br/>        chrono::duration&lt;double, milli&gt; elapsed = finish - start;<br/><br/>        // Displaying the result<br/>        cout &lt;&lt; "Result = " &lt;&lt; fib40Result &lt;&lt; ". ";<br/><br/>        // Displaying elapsed time<br/>        // for each fib40.Fetch() invocation<br/>        cout &lt;&lt; "Consuming time = " &lt;&lt; elapsed.count();<br/>        cout &lt;&lt; " milliseconds" &lt;&lt; endl;<br/>      }<br/><br/>       // Recording end time for the program<br/>       auto finish = chrono::high_resolution_clock::now();<br/><br/>       // Calculating the elapsed time for the program<br/>       chrono::duration&lt;double, milli&gt; elapsed = finish - start;<br/><br/>       // Displaying elapsed time for the program<br/>       cout &lt;&lt; "Total consuming time = ";<br/>       cout &lt;&lt; elapsed.count() &lt;&lt; " milliseconds" &lt;&lt; endl;<br/><br/>       return 0;<br/>    }
</pre>
<p>Now, let's run the code to obtain the elapsed time of the preceding code process. The following screenshot is what we will see on the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/d2ef7cc8-601b-47af-ae9f-19797be02341.png"/></div>
<p>From the preceding screenshot, we can see that we need about <kbd>2357.79</kbd> milliseconds to process the code. And each time it invokes the <kbd>fib40.Fetch()</kbd> method, it needs an average of about <kbd>470</kbd> milliseconds, although we pass the exact same argument to the <kbd>fibonacci()</kbd> function, which is <kbd>40</kbd>. Now, let's see what will happen if we use the memoization technique on the preceding code. We won't modify the code much, just refactor the instantiation of <kbd>fib40</kbd>. Instead of instancing from the <kbd>Delay</kbd> class, now it instances from the <kbd>Memoization</kbd> class. <span>The code should be as follows:</span></p>
<pre>
    /* optimizing_memoization.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;functional&gt;<br/>    #include &lt;chrono&gt;<br/><br/>    using namespace std;<br/><br/>    template&lt;class T&gt; class Memoization<br/>    {<br/>      private:<br/>        T const &amp; (*m_subRoutine)(Memoization *);<br/>        mutable T m_recordedFunc;<br/>        function&lt;T()&gt; m_func;<br/><br/>        static T const &amp; ForceSubroutine(Memoization * d)<br/>        {<br/>          return d-&gt;DoRecording();<br/>        }<br/><br/>        static T const &amp; FetchSubroutine(Memoization * d)<br/>        {<br/>          return d-&gt;FetchRecording();<br/>        }<br/><br/>        T const &amp; FetchRecording()<br/>        {<br/>          return m_recordedFunc;<br/>        }<br/><br/>        T const &amp; DoRecording()<br/>        {<br/>          m_recordedFunc = m_func();<br/>          m_subRoutine = &amp;FetchSubroutine;<br/>          return FetchRecording();<br/>        }<br/><br/>      public:<br/>        Memoization(function&lt;T()&gt; func): m_func(func),<br/>          m_subRoutine(&amp;ForceSubroutine),<br/>          m_recordedFunc(T())<br/>          {<br/>          }<br/><br/>        T Fetch()<br/>        {<br/>          return m_subRoutine(this);<br/>        }<br/>     };<br/><br/>       // Function for calculating Fibonacci sequence<br/>       int fibonacci(int n)<br/>       {<br/>         if(n &lt;= 1)<br/>           return n;<br/>           return fibonacci(n-1) + fibonacci(n-2);<br/>       }<br/><br/>       auto main() -&gt; int<br/>       {<br/>         cout &lt;&lt; "[optimizing_memoization.cpp]" &lt;&lt; endl;<br/><br/>         // Recording start time for the program<br/>         auto start = chrono::high_resolution_clock::now();<br/><br/>         // Initializing int variable to store the result<br/>         // from Fibonacci calculation<br/>         int fib40Result = 0;<br/><br/>         // Constructing Memoization&lt;&gt; named fib40<br/><strong>         Memoization&lt;int&gt; fib40([]()</strong><br/><strong>         {</strong><br/><strong>           return fibonacci(40);</strong><br/><strong>         });</strong><br/><br/>         for (int i = 1; i &lt;= 5; ++i)<br/>         {<br/>           cout &lt;&lt; "Invocation " &lt;&lt; i &lt;&lt; ". ";<br/><br/>           // Recording start time<br/>           auto start = chrono::high_resolution_clock::now();<br/><br/>           // Invoking the Fetch() method<br/>           // in fib40 instance<br/>           fib40Result = fib40.Fetch();<br/><br/>           // Recording end time<br/>           auto finish = chrono::high_resolution_clock::now();<br/><br/>           // Calculating the elapsed time<br/>           chrono::duration&lt;double, milli&gt; elapsed = finish - start;<br/><br/>           // Displaying the result<br/>           cout &lt;&lt; "Result = " &lt;&lt; fib40Result &lt;&lt; ". ";<br/><br/>           // Displaying elapsed time<br/>           // for each fib40.Fetch() invocation<br/>           cout &lt;&lt; "Consuming time = " &lt;&lt; elapsed.count();<br/>           cout &lt;&lt; " milliseconds" &lt;&lt; endl;<br/>       }<br/><br/>          // Recording end time for the program<br/>          auto finish = chrono::high_resolution_clock::now();<br/><br/>          // Calculating the elapsed time for the program<br/>          chrono::duration&lt;double, milli&gt; elapsed = finish - start;<br/><br/>          // Displaying elapsed time for the program<br/>          cout &lt;&lt; "Total consuming time = ";<br/>          cout &lt;&lt; elapsed.count() &lt;&lt; " milliseconds" &lt;&lt; endl;<br/><br/>          return 0;<br/>     }
</pre>
<p><span>Here is what we'll get on the console screen when we run the <kbd>optimizing_memoization.cpp</kbd> code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/0c030b41-e024-44bc-b1fc-986e0504eae2.png"/></div>
<p>Surprisingly, we just need <kbd>494.681</kbd> milliseconds to execute the <span><kbd>optimizing_memoization.cpp</kbd></span> code. Compared to the <span><kbd>not_optimize_code.cpp</kbd> code, the speed of the code is about <kbd>4.7</kbd> times faster. This happens because the code successfully cached the result of the <kbd>fibonacci()</kbd> function when it passed the <kbd>40</kbd></span> <span>to its parameter. Each time we call the <kbd>fib40.Fetch()</kbd> method again, it will invoke the <kbd>fibonacci()</kbd> function again, with the exact same input. The code will just return the cached result so it can avoid running the expensive function calls that are unnecessary to run.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lazy evaluation in action</h1>
                </header>
            
            <article>
                
<p><span>Having discussed the basic concept of lazy evaluation, let's dig into lazy evaluation by designing the code in the lazy approach. In this section, we will develop an eager evaluation code first, then refactor that code into the lazy evaluation one. The code we develop will generate a sequence of prime numbers. First, we will use the</span> <kbd>for</kbd> <span>loop to iterate the integer number to obtain the prime number in the eager evaluation.</span> The following <kbd>prime.cpp</kbd> code is what we are talking about:</p>
<pre>
    /* prime.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;cmath&gt;<br/><br/>    using namespace std;<br/><br/>    bool PrimeCheck(int i)<br/>    {<br/>      // All even numbers are not prime number<br/>      // except 2<br/>      if ((i % 2) == 0)<br/>      {<br/>        return i == 2;<br/>      }<br/><br/>      // Calculating the square root of i<br/>      // and store in int data type variable<br/>      // if the argument i is not even number,<br/>      int sqr = sqrt(i);<br/><br/>      // For numbers 9 and below,<br/>      // the prime numbers is simply the odd numbers<br/>      // For number above 9<br/>      // the prime numbers is all of odd numbers<br/>      // except the square number<br/>      for (int t = 3; t &lt;= sqr; t += 2)<br/>      {<br/>        if (i % t == 0)<br/>        {<br/>            return false;<br/>        }<br/>      }<br/><br/>       // The number 1 is not prime number<br/>       // but still passing the preceding test<br/>       return i != 1;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[delaying.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a counting variable<br/>      int n = 0;<br/><br/>      // Displaying the first 100 prime numbers<br/>      cout &lt;&lt; "List of the first 100 prime numbers:" &lt;&lt; endl;<br/>      for (int i = 0; ; ++i)<br/>      {<br/>        if (PrimeCheck(i))<br/>        {<br/>            cout &lt;&lt; i &lt;&lt; "\t";<br/><br/>            if (++n == 100)<br/>                return 0;<br/>        }<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have a simple <kbd>PrimeCheck()</kbd> function to analyze whether the integer number is a prime number or not. Afterward, the code iterates the infinity integer numbers using the <kbd>for</kbd> loop, then checks whether it's a prime number. The loop will be ended if we've got one hundred prime numbers. The following screenshot is the output on the console we should see:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/3263a17d-40a8-4065-82ad-48cfa4601359.png"/></div>
<p>We now have a code generating prime numbers using eager evaluation. As we can see in the preceding screenshot, we have a hundred prime numbers that we generated using the <kbd>for</kbd> loop. Next, we will refactor it into the lazy code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing Chunk and Row classes</h1>
                </header>
            
            <article>
                
<p>In the <kbd>prime.cpp</kbd> code, we generate a row of integer numbers using the <kbd>for</kbd> loop. In this row, there are several numbers that are called <strong>Chunk</strong>. Now, before we refactor the code, we will prepare a class named <kbd>Row</kbd> and <kbd>Chunk</kbd> for our further discussion. From our preceding analogy, the <kbd>Row</kbd> class will hold the sequence of integer number and the <kbd>Chunk</kbd> class will hold a single number. We will start with the smallest part in the data, which is the chunk. And here is the implementation of the <kbd>Chunk</kbd> class:</p>
<pre>
    template&lt;class T&gt; class Chunk<br/>    {<br/>      private:<br/>        T m_value;<br/>        Row&lt;T&gt; m_lastRow;<br/><br/>      public:<br/>        Chunk()<br/>         {<br/>         }<br/><br/>        Chunk(T value, Row&lt;T&gt; lastRow): m_value(value),<br/>         m_lastRow(std::move(lastRow))<br/>        {<br/>        }<br/><br/>        explicit Chunk(T value) : m_value(value)<br/>        {<br/>        }<br/><br/>        T Value() const<br/>        {<br/>          return m_value;<br/>        }<br/><br/>        Row&lt;T&gt; ShiftLastToFirst() const<br/>        {<br/>          return m_lastRow;<br/>        }<br/>    };
</pre>
<p>Since the <kbd>Row</kbd> class is constructed from several <kbd>Chunk</kbd> classes, besides the value of <kbd>Chunk</kbd> itself, the <kbd>Chunk</kbd> class also has the next value of <kbd>Chunk</kbd> in the current <kbd>Row</kbd> notated by the <kbd>m_lastRow</kbd> member variable. We also can get the <kbd>m_lastRow</kbd> <span>value by invoking the <kbd>ShiftLastToFirst()</kbd> method. N</span>ow, let's move to the <span><kbd>Row</kbd> class.</span> The implementation of the class is as follows:</p>
<pre>
    template&lt;class T&gt; class Row<br/>    {<br/>      private:<br/>        std::shared_ptr &lt;Memoization&lt;Chunk&lt;T&gt;&gt;&gt;<br/>        m_lazyChunk;<br/><br/>      public:<br/>         Row()<br/>         {<br/>         }<br/><br/>         explicit Row(T value)<br/>         {<br/>           auto chunk = ChunkPreparation&lt;T&gt;(value);<br/>           m_lazyChunk = std::make_shared&lt;Memoization&lt;Chunk&lt;T&gt;&gt;&gt; <br/>           (chunk);<br/>         }<br/><br/>         Row(T value, Row row)<br/>         {<br/>           auto chunk = ChunkPreparation&lt;T&gt;( value, std::move(row));<br/><br/>           m_lazyChunk = std::make_shared&lt;Memoization&lt;Chunk&lt;T&gt;&gt;&gt;(<br/>           chunk);<br/>         }<br/>  <br/>         Row(std::function&lt;Chunk&lt;T&gt;()&gt; func): m_lazyChunk(<br/>         std::make_shared&lt;Memoization&lt;Chunk&lt;T&gt;&gt;&gt;(func))<br/>         {<br/>         }<br/><br/>         bool IsEmpty() const<br/>         {<br/>           return !m_lazyChunk;<br/>         }<br/>   <br/>         T Fetch() const<br/>         {<br/>           return m_lazyChunk-&gt;Fetch().Value();<br/>         }<br/><br/>         Row&lt;T&gt; ShiftLastToFirst() const<br/>         {<br/>          return m_lazyChunk-&gt;Fetch().ShiftLastToFirst();<br/>         }<br/><br/>         Row Pick(int n) const<br/>         {<br/>           if (n == 0 || IsEmpty())<br/>            return Row();<br/><br/>          auto chunk = m_lazyChunk;<br/>          return Row([chunk, n]()<br/>          {<br/>            auto val = chunk-&gt;Fetch().Value();<br/>            auto row = chunk-&gt;Fetch().ShiftLastToFirst();<br/>            return Chunk&lt;T&gt;(val, row.Pick(n - 1));<br/>          });<br/>         }<br/>    };
</pre>
<p>As we can see in the preceding code snippet, the <kbd>Row</kbd> class has only one private member to store a memoization of the <kbd>Chunk</kbd> data. There are four constructors the <kbd>Row</kbd> class has, and we will use them all in our next code. It also has the <kbd>Fetch()</kbd> method, which we got when we designed the <kbd>Memoization</kbd> class in the previous section, to get the <kbd>m_lazyChunk</kbd> value. The other methods are also useful to our next lazy code. The <kbd>IsEmpty()</kbd> method will check if the <kbd>m_lazyChunk</kbd> <span>value is empty, the <kbd>ShiftLastToFirst()</kbd> method will take the last row of <kbd>m_lazyChunk</kbd>, and the <kbd>Pick(int n)</kbd> method will take out the first <kbd>n</kbd> row's elements that we will use if we need to take out a hundred of the integer prime numbers later.</span></p>
<p>We can also see that one of the <kbd>Row</kbd> constructors is invoking the <kbd>ChunkPreparation</kbd> class constructor. The <kbd>ChunkPreparation</kbd> <span>class will initialize a new <kbd>Chunk</kbd> class constructor using the given value and the last row value. The implementation of the class is as follows:</span></p>
<pre>
    template&lt;class T&gt; class ChunkPreparation<br/>    {<br/>      public:<br/>        T m_value;<br/>        Row&lt;T&gt; m_row;<br/><br/>        ChunkPreparation(T value, Row&lt;T&gt; row) :<br/>          m_value(value),<br/>          m_row(std::move(row))<br/>          {<br/>          }<br/><br/>        explicit ChunkPreparation(T value) :<br/>          m_value(value)<br/>          {<br/>          }<br/><br/>        Chunk&lt;T&gt; operator()()<br/>        {<br/>          return Chunk&lt;T&gt;(<br/>            m_value,<br/>            m_row);<br/>        }<br/>    };
</pre>
<p>As we can see, by invoking <kbd>operator ()</kbd>, the new <kbd>Chunk</kbd> will be generated with the given <kbd>m_value</kbd> and <kbd>m_row</kbd> value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concatenating several rows</h1>
                </header>
            
            <article>
                
<p>When we plan to generate a row of prime numbers, we have to be able to concatenate the current with the new row generated by code. To address this need, the following is the implementation of the <kbd>ConcatenateRows()</kbd> function that will concatenate the two rows:</p>
<pre>
    template&lt;class T&gt; Row&lt;T&gt; ConcatenateRows(<br/>      Row&lt;T&gt; leftRow,<br/>      Row&lt;T&gt; rightRow)<br/>      {<br/>        if (leftRow.IsEmpty())<br/>          return rightRow;<br/><br/>        return Row&lt;T&gt;([=]()<br/>        {<br/>          return Chunk&lt;T&gt;(<br/>            leftRow.Fetch(),<br/>            ConcatenateRows&lt;T&gt;(<br/>             leftRow.ShiftLastToFirst(),<br/>             rightRow));<br/>         });<br/>       }
</pre>
<p>It's quite clear what the <kbd>ConcatenateRows()</kbd> function does when we take a look at the preceding code snippet. If <kbd>leftRow</kbd> is still empty, just return the second row, which is <kbd>rightRow</kbd>. If <kbd>leftRow</kbd> <span>and</span> <span><kbd>rightRow</kbd> is available, we can return the chunks of the given rows that have been formed as a row.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterating each Row class' element</h1>
                </header>
            
            <article>
                
<p>After we construct the row of prime numbers, we need to iterate each row's element to manipulate it, for instance, to print the value to the console. For this purpose, we have to develop the following <kbd>ForEach()</kbd> method:</p>
<pre>
    template&lt;class T, class U&gt; void ForEach( Row&lt;T&gt; row, U func)<br/>     {<br/>        while (!row.IsEmpty())<br/>        {<br/>          func(row.Fetch());<br/>          row = row.ShiftLastToFirst();<br/>         }<br/>     }
</pre>
<p>We will pass the row itself and a function into the <kbd>ForEach()</kbd> <span>method. The function we passed to it will be run to each element of the row.<br/></span></p>
<div class="packt_tip">For our convenience in developing the lazy code in this chapter, I will bundle our previous discussion <kbd>template</kbd> class into a single header file named <kbd>lazyevaluation.h</kbd>; we can also reuse it for other projects. The header will contain the <kbd>Memoization</kbd>, <kbd>Row</kbd>, <kbd>Chunk</kbd>, <kbd>ChunkPreparation</kbd>, <kbd>ConcatenateRows</kbd>, and <kbd>ForEach</kbd> template class. You can create the header file yourself or download it from the code repository on the Packt website (<span><a href="https://github.com/PacktPublishing/LearningCPPFunctionalProgramming">https://github.com/PacktPublishing/LearningCPPFunctionalProgramming</a></span>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating the infinite integer row</h1>
                </header>
            
            <article>
                
<p>Now it's time to generating the infinite integer row as we did using the <kbd>for</kbd> loop in our previous <kbd>prime.cpp</kbd> code. However, we will now create a new function named <kbd><span>GenerateInfiniteIntRow()</span></kbd> to generate an integer row from several integer chunks. The following code snippet is an implementation of the function:</p>
<pre>
    Row&lt;int&gt; GenerateInfiniteIntRow( int initialNumber)<br/>    {<br/>      return Row&lt;int&gt;([initialNumber]()<br/>      {<br/>        return Chunk&lt;int&gt;(<br/>            initialNumber,<br/>            GenerateInfinityIntRow(<br/>             initialNumber + 1));<br/>      });<br/>    }
</pre>
<p>As we can see, first, we create <kbd>Chunk</kbd> from <kbd>initialNumber</kbd> until infinity. The chunks will be transformed to the <kbd>Row</kbd> data type at the end. To stop this recursive function, we can call the <kbd>Pick()</kbd> method inside the <kbd>Row</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating an infinite prime numbers row</h1>
                </header>
            
            <article>
                
<p>After successfully generated infinite numbers, we now have to limit the row to only generate the prime number. We will modify the <kbd>CheckPrime()</kbd> function from the <kbd>prime.cpp</kbd> code. We will change the return value of the function, <kbd>Row&lt;void*&gt;(nullptr)</kbd> if it's not a prime number or <kbd>Row&lt;void*&gt;()</kbd> if the opposite. The implementation of the function should be as follows:</p>
<pre>
    Row&lt;void*&gt; PrimeCheck(int i)<br/>    {<br/>      if ((i % 2) == 0)<br/>      {<br/>        if (i == 2)<br/>            return Row&lt;void*&gt;(nullptr);<br/>        else<br/>            return Row&lt;void*&gt;();<br/>      }<br/><br/>      int sqr = sqrt(i);<br/><br/>      for (int t = 3; t &lt;= sqr; t = t + 2)<br/>      {<br/>        if (i % t == 0)<br/>        {<br/>            return Row&lt;void*&gt;();<br/>        }<br/>      }<br/><br/>      if (i == 1)<br/>        return Row&lt;void*&gt;();<br/>      else<br/>        return Row&lt;void*&gt;(nullptr);<br/>    }
</pre>
<p>Why do we need to change the return value of the function? Because we want to pass the return value to the <kbd>JoiningPrimeNumber()</kbd> function, which will join the generated Chunk with the following implementation:</p>
<pre>
    template&lt;class T, class U&gt; <br/>    auto JoiningPrimeNumber(<br/>      Row&lt;T&gt; row, U func) -&gt; decltype(func())<br/>      {<br/>         return JoiningAllRows(<br/>           MappingRowByValue(row, func));<br/>      }
</pre>
<p>Moreover, the <kbd>MappingRowByValue()</kbd> function will map the given row to the given function. The implementation of the function is as follows:</p>
<pre>
    template&lt;class T, class U&gt; <br/>    auto MappingRowByValue(<br/>      Row&lt;T&gt; row, U func) -&gt; Row&lt;decltype(func())&gt;<br/>    {<br/>      using V = decltype(func());<br/><br/>      if (row.IsEmpty())<br/>        return Row&lt;V&gt;();<br/><br/>      return Row&lt;V&gt;([row, func]()<br/>      {<br/>        return Chunk&lt;V&gt;(<br/>          func(),<br/>          MappingRowByValue(<br/>            row.ShiftLastToFirst(),<br/>            func));<br/>      });<br/>    }
</pre>
<p>After we have successfully joined all prime numbers using the <kbd>JoiningPrimeNumber()</kbd> function, we have to bind it to the existing row using the <kbd>Binding()</kbd> function with the following implementation:</p>
<pre>
    template&lt;class T, class U&gt; Row&lt;T&gt; <br/>    Binding( Row&lt;T&gt; row, U func)<br/>    {<br/>       return JoiningAllRows( MappingRow( row, func));<br/>    }
</pre>
<p>From the preceding code snippet, the <kbd>MappingRow()</kbd> function will map the given row to the given function, then <kbd>JoiningAllRows()</kbd> will join all rows from the <span><kbd>MappingRow()</kbd> return value. The implementation of the <kbd>MappingRow()</kbd> and <kbd>JoiningAllRows()</kbd> functions are as follows:<br/></span></p>
<pre>
    template&lt;class T, class U&gt;<br/>    auto MappingRow(<br/>      Row&lt;T&gt; row, U func) -&gt; Row&lt;decltype(<br/>        func(row.Fetch()))&gt;<br/>      {<br/>        using V = decltype(func(row.Fetch()));<br/><br/>        if (row.IsEmpty())<br/>          return Row&lt;V&gt;();<br/><br/>        return Row&lt;V&gt;([row, func]()<br/>        {<br/>          return Chunk&lt;V&gt;(func(<br/>            row.Fetch()),<br/>            MappingRow(<br/>              row.ShiftLastToFirst(),<br/>              func));<br/>       });<br/>    }<br/><br/>    template&lt;class T&gt; Row&lt;T&gt; <br/>    JoiningAllRows(<br/>      Row&lt;Row&lt;T&gt;&gt; rowOfRows)<br/>    {<br/>      while (!rowOfRows.IsEmpty() &amp;&amp; <br/>        rowOfRows.Fetch().IsEmpty())<br/>      {<br/>        rowOfRows = rowOfRows.ShiftLastToFirst();<br/>      }<br/><br/>     if (rowOfRows.IsEmpty()) <br/>        return Row&lt;T&gt;();<br/><br/>     return Row&lt;T&gt;([rowOfRows]()<br/>     {<br/>        Row&lt;T&gt; row = rowOfRows.Fetch();<br/><br/>        return Chunk&lt;T&gt;(<br/>          row.Fetch(), <br/>          ConcatenateRows(<br/>            row.ShiftLastToFirst(), <br/>            JoiningAllRows(<br/>              rowOfRows.ShiftLastToFirst())));<br/>     });<br/>    }
</pre>
<p>Now we can create a function to limit the infinite integer number rows with the following implementation:</p>
<pre>
    Row&lt;int&gt; GenerateInfinitePrimeRow()<br/>    {<br/>      return Binding(<br/>        GenerateInfiniteIntRow(1),<br/>        [](int i)<br/>        {<br/>          return JoiningPrimeNumber(<br/>            PrimeCheck(i),<br/>            [i]()<br/>            {<br/>              return ConvertChunkToRow(i);<br/>            });<br/>        });<br/>     }
</pre>
<p>Since the second argument of the <kbd>JoiningPrimeNumber()</kbd> function needs a row as a data type, we need to convert the <kbd>Chunk</kbd> to <kbd>Row</kbd> using the <kbd>ConvertChunkToRow()</kbd> function with the following implementations:</p>
<pre>
    template&lt;class T&gt; Row&lt;T&gt; <br/>    ConvertChunkToRow(<br/>      T value)<br/>      {<br/>        return Row&lt;T&gt;([value]()<br/>        {<br/>          return Chunk&lt;T&gt;(value);<br/>        });<br/>      }
</pre>
<p>Now we can consume all preceding classes and functions to refactor our <kbd>prime.cpp</kbd> code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring eager evaluation to lazy evaluation</h1>
                </header>
            
            <article>
                
<p>We have all the functions we need to refactor the <kbd>prime.cpp</kbd> code into a lazy code. We will create a <kbd>prime_lazy.cpp</kbd> code that will generate infinite integer numbers first and pick the first one hundred of its elements. After that, we iterate a hundred elements and give them to the function that will print the value on the console. The code should look like this:</p>
<pre>
    /* prime_lazy.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;cmath&gt;<br/>    #include "../lazyevaluation/lazyevaluation.h"<br/><br/>    using namespace std;<br/><br/>    Row&lt;void*&gt; PrimeCheck(int i)<br/>    {<br/>      // Use preceding implementation<br/>    }<br/><br/>    Row&lt;int&gt; GenerateInfiniteIntRow(<br/>      int initialNumber)<br/>    {<br/>      // Use preceding implementation<br/>    }<br/><br/>    template&lt;class T, class U&gt;<br/>    auto MappingRow(<br/>      Row&lt;T&gt; row, U func) -&gt; Row&lt;decltype(<br/>        func(row.Fetch()))&gt;<br/>      {     <br/>        // Use preceding implementation<br/>      }<br/><br/>    template&lt;class T, class U&gt;<br/>    auto MappingRowByValue(<br/>      Row&lt;T&gt; row, U func) -&gt; Row&lt;decltype(func())&gt;<br/>      {<br/>        // Use preceding implementation<br/>      }<br/><br/>    template&lt;class T&gt; Row&lt;T&gt;<br/>    ConvertChunkToRow(<br/>      T value)<br/>    {<br/>      // Use preceding implementation<br/>    }<br/><br/>    template&lt;class T&gt; Row&lt;T&gt;<br/>    JoiningAllRows(<br/>      Row&lt;Row&lt;T&gt;&gt; rowOfRows)<br/>    {<br/>      // Use preceding implementation<br/>    }<br/><br/>    template&lt;class T, class U&gt; Row&lt;T&gt;<br/>    Binding(<br/>      Row&lt;T&gt; row, U func)<br/>      {<br/>        // Use preceding implementation<br/>      }<br/><br/>    template&lt;class T, class U&gt;<br/>    auto JoiningPrimeNumber(<br/>      Row&lt;T&gt; row, U func) -&gt; decltype(func())<br/>      {<br/>        // Use preceding implementation<br/>      }<br/><br/>    Row&lt;int&gt; GenerateInfinitePrimeRow()<br/>    {<br/>      // Use preceding implementation<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[prime_lazy.cpp]" &lt;&lt; endl;<br/><br/>      // Generating infinite prime numbers list<br/>      Row&lt;int&gt; r = GenerateInfinitePrimeRow();<br/><br/>      // Picking the first 100 elements from preceding list<br/>      Row&lt;int&gt; firstAHundredPrimeNumbers = r.Pick(100);<br/><br/>      // Displaying the first 100 prime numbers<br/>      cout &lt;&lt; "List of the first 100 prime numbers:" &lt;&lt; endl;<br/>      ForEach(<br/>        move(firstAHundredPrimeNumbers),<br/>        [](int const &amp; i)<br/>        {<br/>            cout &lt;&lt; i &lt;&lt; "\t";<br/>        });<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see from the preceding code, we have <kbd>r</kbd> that holds the infinite numbers, then we pick the first one hundred prime numbers and store them to <kbd>firstAHundredPrimeNumbers</kbd>. To print the value of the element to the console, we use the <kbd>ForEach()</kbd> function and pass the Lambda expression to it. If we run the code, the result is exactly the same as the <kbd>prime.cpp</kbd> code, except the title that is used is a differentiator. The following output is what we should see on the console if we run the <kbd>prime_lazy.cpp</kbd> code:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c60d9bc0-433e-4a8a-ad78-6b0691382add.png"/></div>
<p>By using the <kbd>template</kbd> class, we have revealed in this chapter that we can develop other lazy code to gain the benefit of being lazy.</p>
<div class="packt_infobox">In the preceding <kbd>prime_lazy.cpp</kbd> code, I omitted several lines of code that were written in the previous section to avoid the code redundancy. If you find any difficulty following the code because it's not complete, go to <a href="https://github.com/PacktPublishing/LearningCPPFunctionalProgramming">https://github.com/PacktPublishing/LearningCPPFunctionalProgramming</a>.<span><a href="https://github.com/PacktPublishing/LearningCPPFunctionalProgramming"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Lazy evaluation is not only useful for functional programming, but it actually also has benefits for imperative programming. Using the lazy evaluation, we can have an efficient and faster code by implementing caching and optimizing techniques.</p>
<p>In the next chapter, we will talk about metaprogramming that we can use in the functional approach. We will discuss how to use metaprogramming to gain all its benefits, including code optimization.</p>


            </article>

            
        </section>
    </body></html>