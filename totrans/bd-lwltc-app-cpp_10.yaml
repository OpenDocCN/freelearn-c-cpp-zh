- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Building the C++ Market Making and Liquidity Taking Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建C++市场做市和流动性获取算法
- en: In this chapter, we will implement a C++ market making algorithm on top of all
    the components we built in the previous chapters. This market making algorithm
    will connect to and send orders to the trading exchange we built previously. Additionally,
    we will implement a C++ liquidity taking algorithm in the same trading engine
    framework. This liquidity taking algorithm will also connect to and send orders
    to the trading exchange.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在前几章构建的所有组件之上实现一个C++市场做市算法。此市场做市算法将连接到我们之前构建的交易交易所并发送订单。此外，我们将在相同的交易引擎框架中实现一个C++流动性获取算法。此流动性获取算法也将连接到交易交易所并发送订单。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the behavior of our trading algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解我们的交易算法的行为
- en: Managing the passive liquidity provided in the order book
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理订单簿中提供的被动流动性
- en: Opening and closing positions aggressively
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主动开仓和平仓
- en: Building the trade engine framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建交易引擎框架
- en: Building and running the main trading application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行主要交易应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this book can be found in its GitHub repository at [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source for this chapter is in the `Chapter10` directory in the repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在GitHub仓库中找到，仓库地址为[https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP)。本章的源代码位于仓库中的`Chapter10`目录。
- en: It is important that you have read and understood the design of the electronic
    trading ecosystem presented in the *Designing Our Trading Ecosystem* chapter,
    especially the *Designing a framework for low latency C++ trading algorithms*
    section. It is also expected that you are quite familiar with the previous two
    chapters – *Processing Market Data and Sending Orders to the Exchange in C++*
    and *Building the C++ Trading Algorithm Building Blocks*, since we will be using
    every single component that we built in those two chapters in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，您已经阅读并理解了*设计我们的交易生态系统*章节中介绍的电子交易生态系统的设计，特别是*设计低延迟C++交易算法框架*部分。还预期您对前两个章节——*在C++中处理市场数据和向交易所发送订单*和*构建C++交易算法构建块*相当熟悉，因为我们将在此章中使用我们在那两个章节中构建的每一个组件。
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown here. We present the details of this environment since
    all the C++ code presented in this book is not necessarily portable and might
    require some minor changes to work in your environment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码开发环境的规格在此展示。我们提供此环境的详细信息，因为本书中展示的所有C++代码并不一定可移植，可能需要在您的环境中进行一些小的修改才能工作：
- en: 'OS: `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OS: `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64 GNU/Linux`'
- en: 'GCC: `g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GCC: `g++ (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0`'
- en: 'CMake: `cmake` `version 3.23.2`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CMake: `cmake version 3.23.2`'
- en: 'Ninja: `1.10.2`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ninja: `1.10.2`'
- en: Understanding the behavior of our trading algorithms
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解我们的交易算法的行为
- en: In this section, we will discuss some additional details about the behavior
    and motivation behind the two trading strategies we will build in this chapter
    – the market making trading strategy and the liquidity taking trading strategy.
    With the use of a hypothetical example for each strategy, we will also try to
    understand the strategy order flow mechanics and try to further our understanding
    when we implement these trading strategies in our C++ system, towards the end
    of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论我们将在此章中构建的两个交易策略（市场做市交易策略和流动性获取交易策略）的行为和背后的动机的一些额外细节。通过为每个策略提供一个假设示例，我们还将尝试理解策略订单流机制，并在本章末尾将我们的C++系统中的这些交易策略实现时，进一步加深我们的理解。
- en: Understanding the market making trading algorithm
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解市场做市交易算法
- en: The market making trading strategies seek to make profits by seeking to *capture
    the spread*, which just means buying at the best bid price in the market passively
    and quickly selling at the best ask price in the market passively (or selling
    first and buying after). The market making strategies, profitability depends on
    the spread of the trading instrument, how many buy and sell trades the strategy
    can execute over time, and how much market prices move between the buy and sell
    trades. It should be clear that the market making strategies will trade only against
    other strategies that *cross the spread* and send aggressive buy and sell orders,
    which is what we refer to as **liquidity taking trading strategies**. What this
    means is that market making trading strategies rarely expect to trade against
    other market making trading strategies, since all instances of such strategies
    seek to execute their orders passively. To achieve this, market making trading
    strategies send and manage passive limit orders in the order book and try to use
    intelligence to modify the prices on these orders, thereby improving their execution
    and the probability of successfully capturing the spread as often as possible.
    In the next subsection, we will discuss a hypothetical example of how a market
    making trading strategy would manage its orders.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 做市交易策略旨在通过试图*捕捉价差*来获利，这仅仅意味着在市场上以最佳报价价格被动且快速地买入，并以最佳要价价格被动地卖出（或先卖出后买入）。做市策略的盈利能力取决于交易工具的价差、策略在一段时间内可以执行的买卖交易数量，以及买卖交易之间的市场价格变动幅度。应该清楚的是，做市策略只会与其他*跨越价差*并发出积极买卖订单的策略进行交易，这是我们所说的**流动性获取交易策略**。这意味着做市交易策略很少期望与其他做市交易策略进行交易，因为所有此类策略都寻求被动地执行其订单。为了实现这一点，做市交易策略会在订单簿中发送和管理被动限价订单，并试图使用智能来修改这些订单的价格，从而提高其执行效率和尽可能频繁地成功捕捉价差的可能性。在下一个小节中，我们将讨论一个假设的例子，说明做市交易策略将如何管理其订单。
- en: Inspecting market making mechanics with an example
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用示例检查做市机制
- en: In this subsection, we will discuss the mechanics of how our market making trading
    strategy would behave under a hypothetical market condition. This will help strengthen
    your understanding of how the market making algorithm behaves. Before we do that,
    let us try to understand the following table.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将讨论在假设市场条件下我们的做市交易策略将如何表现。这将有助于加强你对做市算法行为方式的理解。在我们这样做之前，让我们先尝试理解以下表格。
- en: The table presents a state of the market book known as the **price level-aggregated
    order book**. What this term means is that all the orders on the same side and
    same price are grouped/aggregated together into a single price level, so if there
    are 12 orders on the bid side, all at the same price (10.21), that add up to a
    total quantity of 2,500, they can be presented as a single entry. This is shown
    as follows, along with similar grouping on the next buy price level of 10.20 and
    ask levels of 10.22 and 10.23 prices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该表格展示了市场订单簿的一种状态，称为**价格水平聚合订单簿**。这个术语的含义是，同一侧和同一价格的所有订单都被分组/聚合到一个单一的价格水平中，因此如果有12个订单在报价侧，价格都相同（10.21），总数量为2,500，它们可以表示为一个单独的条目。这如下所示，以及类似地按下一个买入价格水平10.20和要价水平10.22和10.23的价格进行分组。
- en: '![Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated
    book](img/B19434_10_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 一个订单簿快照，按价格水平聚合](img/B19434_10_01.jpg)'
- en: Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated
    book
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 一个订单簿快照，按价格水平聚合
- en: 'In the preceding diagram, the columns mean the following things (from left
    to right):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，列的含义如下（从左到右）：
- en: '**Our MM strategy bid**: This represents the quantity of the buy order that
    our **Market Making** (**MM**) strategy has at this price level, which in this
    case is none'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的MM策略报价**：这代表我们的**做市**（**MM**）策略在这个价格水平上的买入订单数量，在这种情况下是没有'
- en: '**Market bid order count**: This represents the number of buy orders in the
    market that make up this price level'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场报价订单数量**：这代表组成这个价格水平的市场买入订单数量'
- en: '**Market bid quantity**: The sum of the quantities on all the buy orders at
    this price level'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场报价数量**：在这个价格水平上所有买入订单数量的总和'
- en: '**Market bid price**: This represents the price of this bid price level'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场报价价**：这代表了这个报价价位的报价价格'
- en: '**Market ask price**: This represents the price of this ask price level'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场卖出价格**：这代表这个卖出价格水平的价格'
- en: '**Market ask quantity**: The sum of the quantities of all the sell orders at
    this price level'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场卖出数量**：这个价格水平上所有卖出订单数量的总和'
- en: '**Market ask order count**: This represents the number of sell orders in the
    market that make up this price level'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场卖出订单数量**：这代表构成这个价格水平的卖出订单的数量'
- en: '**Our MM strategy ask**: This represents the quantity of the sell order that
    our MM strategy has at this price level, which in this case is none'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的MM策略的卖出报价**：这代表我们的MM策略在这个价格水平上的卖出订单数量，在这种情况下是没有'
- en: Now, let us suppose our MM strategy starts running at the time that the market
    is in the state we described here. Let us also assume that, for this example,
    our strategy will send a single passive bid order and a single passive ask order,
    and each has a quantity of 100 shares. Let us say that the strategy decides to
    join the best bid price level and the best ask price level at prices 10.21 and
    10.22, respectively. It does this by sending a single buy order and a single sell
    order of a quantity of 100 at those prices. The following diagram represents this
    event, and the blocks highlighted in gold represent the things that changed because
    of this action.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们的MM策略在市场处于我们这里描述的状态时开始运行。我们也假设，对于这个例子，我们的策略将发送一个被动买入订单和一个被动卖出订单，每个订单的数量为100股。让我们说，策略决定以价格10.21和10.22分别加入最佳买入价格水平和最佳卖出价格水平。它是通过发送数量为100的单一买入订单和单一卖出订单来做到这一点的。以下图表表示这一事件，图中用金色突出显示的块表示由于这一行动而发生变化的事物。
- en: '![Figure 10.2 – An event where our MM order has joined the market on both sides](img/B19434_10_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 当我们的MM订单在市场两边加入时的事件](img/B19434_10_02.jpg)'
- en: Figure 10.2 – An event where our MM order has joined the market on both sides
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 当我们的MM订单在市场两边加入时的事件
- en: 'Finally, for one last scenario, let us assume that the orders on the best bid
    at 10.21 are either fully executed due to trade events and removed, or just canceled
    by the market participants that owned them. If the drop in quantity is large enough,
    let us assume that our MM trading strategy also decides to not be present at the
    price level. The state of the price aggregated order book looks like this right
    before our strategy decides to move its best bid order at a price one price level
    away from its current price, i.e., from price 10.21 to 10.20:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一个最后的场景，假设在10.21的最佳出价上的订单要么因为交易事件而完全执行并被移除，要么仅仅被拥有它们的市参与者取消。如果数量下降足够大，让我们假设我们的MM交易策略也决定不在该价格水平上存在。在策略决定将其最佳出价订单从当前价格水平移动到一价格水平之外的价格之前，价格聚合订单簿的状态如下，即从价格10.21到10.20：
- en: '![Figure 10.3 – The state of the price level book when our MM order decides
    to move its bid](img/B19434_10_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 当我们的MM订单决定将其出价移动到一价格水平之外时价格水平簿的状态](img/B19434_10_03.jpg)'
- en: Figure 10.3 – The state of the price level book when our MM order decides to
    move its bid
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 当我们的MM订单决定将其出价移动到一价格水平之外时价格水平簿的状态
- en: This decision can be due to a wide range of factors, depending on the strategy
    and its features. However, for this example, let us offer you a simple intuitive
    thought – a lot of people are less willing to buy at 10.21 (only 600 shares in
    total) compared to how many people are willing to sell at 10.22 (6,500 shares).
    You might conclude that perhaps it is no longer wise to try and buy at 10.21 or
    that the fair market price is perhaps at 10.21, and you want to try and buy at
    a price that is a little lower than that. The next diagram displays the state
    of the price level book when the MM strategy decides to cancel its buy order at
    10.21 and repositions its buy order to 10.20.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定可能是由广泛的因素造成的，这取决于策略及其特性。然而，对于这个例子，让我们提供一个简单的直观想法 – 与愿意以10.22卖出的人数（6,500股）相比，较少的人愿意以10.21购买（总共只有600股）。你可能会得出结论，也许不再明智尝试在10.21购买，或者公平的市场价格可能是在10.21，你希望尝试以略低于这个价格的价格购买。下一个图表显示了MM策略决定取消其在10.21的买入订单并将其买入订单重新定位到10.20时价格水平簿的状态。
- en: '![Figure 10.4 – An event where our MM strategy repositions its bid from a price
    of 10.21 to 10.20](img/B19434_10_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 当我们的MM策略将其出价从10.21的价格重新定位到10.20时的事件](img/B19434_10_04.jpg)'
- en: Figure 10.4 – An event where our MM strategy repositions its bid from a price
    of 10.21 to 10.20
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 当我们的MM策略将其出价从10.21的价格重新定位到10.20时的事件
- en: The discussion in this subsection aimed to improve your understanding of the
    mechanics of a simple MM strategy, and in the next subsection, we will move on
    to the liquidity taking trading algorithm.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节的讨论旨在提高你对简单MM策略机制的认知，在下一小节中，我们将继续探讨流动性获取交易算法。
- en: Understanding the liquidity taking trading algorithm
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解流动性获取交易算法
- en: The liquidity taking trading algorithm in many ways is the opposite of the MM
    algorithm. Instead of sending passive orders to the book and waiting for them
    to be executed passively, it sends aggressive orders to execute trades when it
    needs them. In this sense, it *crosses the spread* (sends aggressive orders to
    execute) instead of trying to *capture the spread*, like the MM strategy. This
    strategy bets on getting the direction of the market correct – that is, it buys
    aggressively when it thinks that prices will increase further and sells aggressively
    when it thinks that prices will decrease further. The convenient fact about this
    trading algorithm is that order management is very easy since it does not always
    maintain live orders in the order book that it needs to manage. Another way to
    understand this is that when the strategy needs to execute a trade, it sends an
    order to the order book and gets executed almost immediately, and then it is done
    from an order management perspective. The inconvenient fact about this trading
    algorithm is that predicting market directions is extremely difficult, but we
    will not dive into that, since that is not the focus of this book. In the next
    subsection, we will understand the trading mechanics for this strategy as we did
    with the MM strategy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，流动性获取交易算法与MM算法相反。它不是向簿中发送被动订单并等待它们被动执行，而是在需要时发送积极订单以执行交易。从这一意义上说，它*跨越了价差*（发送积极订单执行），而不是像MM策略那样试图*捕捉价差*。这种策略押注于正确判断市场方向——也就是说，当它认为价格将进一步上涨时，它会积极买入；当它认为价格将进一步下跌时，它会积极卖出。关于这种交易算法的便利之处在于，由于它不需要始终在订单簿中保持需要管理的活跃订单，因此订单管理非常简单。另一种理解方式是，当策略需要执行交易时，它会向订单簿发送一个订单，几乎立即执行，然后从订单管理角度来看就完成了。关于这种交易算法的不便之处在于，预测市场方向极其困难，但我们将不会深入探讨这一点，因为这不是本书的重点。在下一小节中，我们将像对MM策略那样理解这种策略的交易机制。
- en: Inspecting liquidity taking mechanics with an example
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过示例检查流动性获取机制
- en: Once again, let us look at the price level-aggregated view of the order book,
    as discussed in the section on MM. The columns here mean the same thing, except
    they do not have the columns for the MM strategy orders, since the liquidity taking
    strategy will not rest orders passively in the order book. Let us assume the initial
    state of the price level book is as shown here, which was also the same initial
    state for the MM example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们看看MM部分讨论的价格水平聚合视图的订单簿，假设初始状态如图所示，这也是MM示例的相同初始状态。
- en: '![Figure 10.5 – The state of the price level book at a given time for a hypothetical
    example](img/B19434_10_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 对于一个假设示例，在给定时间点价格水平簿的状态](img/B19434_10_05.jpg)'
- en: Figure 10.5 – The state of the price level book at a given time for a hypothetical
    example
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 对于一个假设示例，在给定时间点价格水平簿的状态
- en: Let us assume that, for this example, our liquidity taking strategy has a feature
    that tries to follow in the same direction as very large trades. What this means
    is that if a very large trade event happens in the market, our liquidity taking
    algorithm decides to take the same direction as this trade event. So, if a very
    large buy trade happens, our liquidity taking algorithm will buy aggressively,
    and if a very sell trade happens, our liquidity taking algorithm will sell aggressively.
    As mentioned before, this is only an example feature; in practice, different liquidity
    taking algorithms will have many such features on which the decision to make a
    trade depends. For our simple liquidity taking algorithm example, we will use
    this feature of large aggressive trade in the market.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设，在这个例子中，我们的流动性获取策略具有一个特征，该特征试图跟随非常大的交易方向。这意味着，如果市场发生一个非常大的交易事件，我们的流动性获取算法将决定与这个交易事件采取相同的方向。因此，如果发生一个非常大的买入交易，我们的流动性获取算法将积极买入，如果发生一个非常大的卖出交易，我们的流动性获取算法将积极卖出。正如之前提到的，这只是一个示例特征；在实践中，不同的流动性获取算法将有许多这样的特征，这些特征将决定是否进行交易。对于我们的简单流动性获取算法示例，我们将使用市场中的大额积极交易这一特征。
- en: To understand what that looks like, let us assume that given the previous state
    of the price level book, a very large sell execution of a quantity of 2,200 hits
    the bid price level of 10.21, which had a total quantity of 2,500 prior to this.
    This event is shown in the following diagram, where the green arrow represents
    the trade aggressor in market data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这看起来是什么样子，让我们假设，在给定的价格水平簿记的先前状态下，一个2,200单位的非常大的卖出执行订单击中了10.21的买入价格水平，在此之前该价格水平的总数量为2,500。这个事件在以下图表中显示，其中绿色箭头代表市场数据中的交易积极方。
- en: '![Figure 10.6 – An event where a large sell aggressor causes a trade event](img/B19434_10_06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 一个大额卖出积极方引起交易事件的事件](img/B19434_10_06.jpg)'
- en: Figure 10.6 – An event where a large sell aggressor causes a trade event
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 一个大额卖出积极方引起交易事件的事件
- en: This trade event will cause the best bid quantity to reduce from 2,500 to 300
    – that is, by the quantity of the trade aggressor. Additionally, let us assume
    that our liquidity taking strategy observes the large trade of a quantity of 2,200
    and decides to send an aggressive sell order at the price of 10.21\. Let us also
    assume that, like the MM strategy, our liquidity taking strategy also sends a
    sell order of a quantity of 100\. This event is shown in the following diagram.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交易事件将导致最佳买入数量从2,500减少到300 – 即，通过交易积极方的数量。此外，让我们假设，我们的流动性获取策略观察到2,200单位的较大交易，并决定在10.21的价格发送一个积极卖出订单。让我们还假设，像MM策略一样，我们的流动性获取策略也发送了一个100单位的卖出订单。这个事件在以下图表中显示。
- en: '![Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive
    sell order of a quantity of 100 at a price of 10.21](img/B19434_10_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 我们的流动性获取算法在价格为10.21时发送的100单位积极卖出订单的事件](img/B19434_10_07.jpg)'
- en: Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive
    sell order of a quantity of 100 at a price of 10.21
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 我们的流动性获取算法在价格为10.21时发送的100单位积极卖出订单的事件
- en: That concludes the theoretical discussion of the two trading strategies we seek
    to build as part of our trading system. We will get to their actual implementation
    inside our framework in a few sections’ time, but first, we need to build some
    additional building blocks for these strategies, which we will do in the next
    section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们作为交易系统的一部分所寻求构建的两个交易策略的理论讨论。我们将在接下来的几节中了解它们在框架中的实际实现，但首先，我们需要为这些策略构建一些额外的构建块，这将在下一节中完成。
- en: Adding an enumeration to define the type of algorithm
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个枚举来定义算法类型
- en: 'We will round up this discussion of our trading strategies by defining an `AlgoType`
    enumeration in the `Chapter10/common/types.h` header file. It has the following
    valid values – `MAKER` to represent MM, `TAKER` to represent liquidity taking,
    and `RANDOM` to represent the random trading strategy we built before. We also
    have `INVALID` and `MAX` values:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Chapter10/common/types.h`头文件中定义一个`AlgoType`枚举，它有以下有效值 – `MAKER`代表MM，`TAKER`代表流动性获取，`RANDOM`代表我们之前构建的随机交易策略。我们还有`INVALID`和`MAX`值：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will add a standard `algoTypeToString()` method used to stringify the `AlgoType`
    type, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个标准的`algoTypeToString()`方法，用于将`AlgoType`类型转换为字符串，如下所示：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `stringToAlgoType()` method, which we will build next, parses a string
    and converts it into an `AlgoType` enumeration value. It does this by iterating
    through all the possible `AlgoType` enumeration values and comparing the string
    argument against the output of `algoTypeToString()`, called on that `AlgoType`
    enumeration value. If the string representations match, then it returns the `algo_type`
    enumeration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个代码块中构建的 `stringToAlgoType()` 方法，它解析一个字符串并将其转换为 `AlgoType` 枚举值。它是通过遍历所有可能的
    `AlgoType` 枚举值，并将字符串参数与对那个 `AlgoType` 枚举值调用 `algoTypeToString()` 的输出进行比较来完成的。如果字符串表示形式匹配，则返回
    `algo_type` 枚举：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we will move on to building the different building blocks we need to support
    our trading strategies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续构建支持我们的交易策略所需的不同构建块。
- en: Managing the passive liquidity provided in the order book
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理订单簿中提供的被动流动性
- en: At this point, we have all the sub-components we need to start building our
    trading strategies. The first strategy we will build will be the MM algorithm,
    which sends orders that are expected to rest passively in the order book. We discussed
    the details of this trading algorithm earlier in this chapter, so in this section,
    we will focus on the C++ implementation. All the source code for this `MarketMaker`
    trading algorithm can be found in the `Chapter10/trading/strategy/market_maker.h`
    and `Chapter10/trading/strategy/market_maker.cpp` source files.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有了开始构建我们的交易策略所需的所有子组件。我们将构建的第一个策略将是 MM 算法，该算法发送的订单预计将被动地停留在订单簿中。我们已经在本章前面讨论了这种交易算法的细节，因此在本节中，我们将专注于
    C++ 实现。此 `MarketMaker` 交易算法的所有源代码都可以在 `Chapter10/trading/strategy/market_maker.h`
    和 `Chapter10/trading/strategy/market_maker.cpp` 源文件中找到。
- en: Defining the data members in the MarketMaker algorithm
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 MarketMaker 算法中定义数据成员
- en: 'First, we need to define the data members that make up the `MarketMaker` class.
    The key members are the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义构成 `MarketMaker` 类的数据成员。关键成员如下：
- en: A pointer to a constant `FeatureEngine` object called `feature_engine_`, which
    we will use to fetch the fair market price, using the `FeatureEngine::getMktPrice()`
    method we saw earlier
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `feature_engine_` 的常量 `FeatureEngine` 对象的指针，我们将使用它来获取公平市场价格，使用我们之前看到的 `FeatureEngine::getMktPrice()`
    方法。
- en: A pointer to an `OrderManager` object called `order_manager_`, which will be
    used to manage the passive orders that this strategy sends
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向名为 `order_manager_` 的 `OrderManager` 对象的指针，该对象将用于管理此策略发送的被动订单
- en: A `ticker_cfg_` variable of a constant `TradeEngineCfgHashMap` type to hold
    the trading parameters for the different trading instruments that this algorithm
    will trade
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ticker_cfg_` 变量，其类型为常量 `TradeEngineCfgHashMap`，用于存储此算法将交易的多种交易工具的交易参数
- en: 'Let us inspect the class definition, starting with the `include` files needed
    in the `market_maker.h` header file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查类定义，从 `market_maker.h` 头文件中需要的 `include` 文件开始：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now, in the next code block, we can define the `MarketMaker` class and
    the aforementioned data members:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下一个代码块中，我们可以定义 `MarketMaker` 类和上述数据成员：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next section will define the constructor to initialize an instance of this
    `MarketMaker` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将定义构造函数以初始化此 `MarketMaker` 类的一个实例。
- en: Initializing the MarketMaker algorithm
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化 MarketMaker 算法
- en: 'The constructor implemented in the `market_maker.cpp` file is shown in the
    next code block. The constructor accepts a few arguments in the constructor:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `market_maker.cpp` 文件中实现的构造函数将在下一个代码块中展示。构造函数在构造函数中接受一些参数：
- en: A `Logger` object, which will be saved in the `logger_` member variable and
    used for logging purposes.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Logger` 对象，它将被保存在 `logger_` 成员变量中，并用于日志记录目的。
- en: A pointer to a `TradeEngine` object, which will be used to bind the `algoOnOrderBookUpdate`,
    `algoOnTradeUpdate`, and `algoOnOrderUpdate` callbacks in the parent `TradeEngine`
    instance to the corresponding methods in the `MarketMaker` object. This is so
    that the `MarketMaker` trading strategy receives and processes the callbacks when
    `TradeEngine` receives them.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向 `TradeEngine` 对象的指针，该对象将用于将父 `TradeEngine` 实例中的 `algoOnOrderBookUpdate`、`algoOnTradeUpdate`
    和 `algoOnOrderUpdate` 回调绑定到 `MarketMaker` 对象中的相应方法。这样，当 `TradeEngine` 接收到回调时，`MarketMaker`
    交易策略可以接收并处理这些回调。
- en: A pointer to a constant `FeatureEngine` object, which will be stored in the
    `feature_engine_` data member and used to extract the feature values this algorithm
    needs, as described before.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向常量 `FeatureEngine` 对象的指针，该对象将被存储在 `feature_engine_` 数据成员中，并用于提取算法所需的特征值，如之前所述。
- en: A pointer to an `OrderManager` object, which will be used to manage the orders
    for this strategy, and the constructor will simply be saved in the `order_manager_`
    data member.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向 `OrderManager` 对象的指针，该对象将用于管理此策略的订单，构造函数将简单地保存在 `order_manager_` 数据成员中。
- en: 'A reference to a constant `TradeEngineCfgHashMap`, which will be saved in the
    `ticker_cfg_` member and used to make trading decisions, since this contains the
    trading parameters:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对一个常量 `TradeEngineCfgHashMap` 的引用，该常量将被保存在 `ticker_cfg_` 成员中，并用于做出交易决策，因为它包含了交易参数：
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As mentioned before and as shown here, we will override the `TradeEngine:``     :algoOnOrderBookUpdate()`, `TradeEngine::algoOnTradeUpdate()`, and `TradeEngine::algoOnOrderUpdate()`
    methods using lambda methods to forward them to the `MarketMaker::onOrderBookUpdate()`,
    `MarketMaker::onTradeUpdate()`, and `MarketMaker::onOrderUpdate()` methods, respectively:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，并如图所示，我们将使用 lambda 方法覆盖 `TradeEngine::algoOnOrderBookUpdate()`、`TradeEngine::algoOnTradeUpdate()`
    和 `TradeEngine::algoOnOrderUpdate()` 方法，分别将它们转发到 `MarketMaker::onOrderBookUpdate()`、`MarketMaker::onTradeUpdate()`
    和 `MarketMaker::onOrderUpdate()` 方法：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The next subsection tackles the most important task in the `MarketMaker` trading
    algorithm – handling order book updates and sending orders in reaction to them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节处理 `MarketMaker` 交易算法中最重要的任务——处理订单簿更新并对其做出反应发送订单。
- en: Handling order book updates and trade events
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理订单簿更新和交易事件
- en: 'The `MarketMaker::onOrderBookUpdate()` method is called by `TradeEngine` through
    the `TradeEngine::algoOnOrderBookUpdate_` `std::function` member variable. This
    is where the `MarketMaker` trading strategy makes trading decisions with regard
    to what prices it wants its bid and ask orders to be at:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketMaker::onOrderBookUpdate()` 方法通过 `TradeEngine::algoOnOrderBookUpdate_`
    `std::function` 成员变量被 `TradeEngine` 调用。这是 `MarketMaker` 交易策略根据其希望其买入和卖出订单的价格做出交易决策的地方：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It fetches `BBO` from `w` using the `getBBO()` method and saves it in the `bbo`
    variable. We also fetch the market quantity-weighted BBO price and save it in
    the `fair_price` variable:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `getBBO()` 方法从 `w` 获取 `BBO` 并将其保存在 `bbo` 变量中。我们还获取市场数量加权的 `BBO` 价格并将其保存在
    `fair_price` 变量中：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We perform a sanity check on the best `bid_price_` and `ask_price_` values
    from `bbo` and `fair_price` to make sure that the prices are not `Price_INVALID`
    and the feature value is not `Feature_INVALID`. Only if this is `true` will we
    take any action; otherwise, we risk acting on invalid features or sending orders
    at invalid prices:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `bbo` 和 `fair_price` 中的最佳 `bid_price_` 和 `ask_price_` 值进行合理性检查，以确保价格不是 `Price_INVALID`
    且特征值不是 `Feature_INVALID`。只有当这是 `true` 时，我们才会采取任何行动；否则，我们可能会在无效的特征上采取行动或以无效的价格发送订单：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We fetch and save the `clip` quantity from the `ticker_cfg_` container, which
    will be the quantity on the passive orders we send to the exchange. We also extract
    and save the `threshold` value, which we will use to decide what prices to send
    the buy and sell orders at:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `ticker_cfg_` 容器中获取并保存 `clip` 数量，这将是发送给交易所的被动订单的数量。我们还提取并保存 `threshold`
    值，我们将使用它来决定发送买入和卖出订单的价格：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We initialize two price variables, `bid_price` and `ask_price`, to represent
    the prices on our buy and sell orders, respectively. We set `bid_price` to be
    the best bid price if the difference between `fair_price` we computed from the
    `FeatureEngine::getMktPrice()` method and the market bid price exceeds the `threshold`
    value. Otherwise, we set `bid_price` to be a price lower than the best market
    bid price. We compute `ask_price` using the same logic – use the best ask price
    if the difference from the fair price exceeds the threshold and a higher price
    otherwise. The motivation behind this is straightforward; when we think the fair
    price is higher than the best bid price, we are willing to buy at the best bid
    price, expecting the prices to go higher. When we think the fair price is lower
    than the best ask price, we are willing to sell at the best ask price, expecting
    the prices to go lower:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化两个价格变量，`bid_price` 和 `ask_price`，分别代表我们的买入和卖出订单的价格。如果从 `FeatureEngine::getMktPrice()`
    方法计算出的 `fair_price` 与市场买入价格之间的差异超过 `threshold` 值，则将 `bid_price` 设置为最佳买入价格。否则，将
    `bid_price` 设置为一个低于最佳市场买入价格的价格。我们使用相同的逻辑计算 `ask_price` – 如果从公平价格到最佳卖出价格的差异超过阈值，则使用最佳卖出价格，否则使用更高的价格。背后的动机很简单；当我们认为公平价格高于最佳买入价格时，我们愿意以最佳买入价格买入，预期价格会上涨。当我们认为公平价格低于最佳卖出价格时，我们愿意以最佳卖出价格卖出，预期价格会下跌：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We use the `bid_price` and `ask_price` variables we computed in the preceding
    code block a and pass them to the `OrderManager::moveOrders()` method to move
    the orders to the desired prices:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在前面的代码块 a 中计算的 `bid_price` 和 `ask_price` 变量，并将它们传递给 `OrderManager::moveOrders()`
    方法，以将订单移动到所需的价格：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `MarketMaker` trading algorithm does not do anything when there are trade
    events and simply logs the trade message it receives, as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当有交易事件时，`MarketMaker` 交易算法不做任何事情，只是记录它接收到的交易消息，如下所示：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have one more task to complete the `MarketMaker` trading strategy – handling
    order updates for its orders, which will be addressed in the next subsection.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个任务来完成 `MarketMaker` 交易策略——处理其订单的更新，这将在下一小节中讨论。
- en: Handling order updates in the MarketMaker algorithm
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 MarketMaker 算法中的订单更新
- en: 'The handling of order updates for the `MarketMaker` trading algorithm’s orders
    is simple; it simply forwards the `MEClientResponse` messages to the `order_manager_`
    member it uses to manage orders. This is achieved by calling the `OrderManager::onOrderUpdate()`
    method, which we implemented previously:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `MarketMaker` 交易算法的订单更新处理很简单；它只是将 `MEClientResponse` 消息转发到它用于管理订单的 `order_manager_`
    成员。这是通过调用我们之前实现的 `OrderManager::onOrderUpdate()` 方法来实现的：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That concludes our implementation of the MM trading algorithm. In the next section,
    we will tackle the other type of trading strategy we will build in this book –
    a liquidity taking algorithm.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 MM 交易算法的实现。在下一节中，我们将处理我们将在这本书中构建的另一种类型的交易策略——一个流动性获取算法。
- en: Opening and closing positions aggressively
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主动开仓和关仓
- en: In this section, we will build a liquidity taking algorithm, whose behavior
    we covered in the first section of this chapter. This trading strategy does not
    send passive orders as the MM algorithm does; instead, it sends aggressive orders
    that trade against liquidity resting in the book. The source code for the `LiquidityTaker`
    algorithm is in the `Chapter10/trading/strategy/liquidity_taker.h` and `Chapter10/trading/strategy/liquidity_taker.cpp`
    source files. First, we will define the data members that make up the `LiquidityTaker`
    class in the next subsection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个流动性获取算法，其行为在本章的第一节中已介绍。这种交易策略不会像 MM 算法那样发送被动订单；相反，它发送与订单簿中休息的流动性进行交易的主动订单。`LiquidityTaker`
    算法的源代码位于 `Chapter10/trading/strategy/liquidity_taker.h` 和 `Chapter10/trading/strategy/liquidity_taker.cpp`
    源文件中。首先，我们将在下一小节中定义构成 `LiquidityTaker` 类的数据成员。
- en: Defining the data members in the LiquidityTaker algorithm
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 LiquidityTaker 算法的数据成员
- en: 'The `LiquidityTaker` trading strategy has the same data members as the `MarketMaker`
    algorithm we built in the previous section. Before we describe the data members
    themselves, we will present the header files we need to include in the `liquidity_taker.h`
    source file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiquidityTaker` 交易策略具有与我们在上一节中构建的 `MarketMaker` 算法相同的数据成员。在我们描述数据成员本身之前，我们将展示需要在
    `liquidity_taker.h` 源文件中包含的头文件：'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can define the data members, which are the same ones that the MM algorithm
    has. The `LiquidityTaker` class has a `feature_engine_` member, which is a constant
    pointer to a `FeatureEngine` object, an `order_manager_` pointer to an `OrderManager`
    object, and a constant `ticker_cfg_` member, which is of type `TradeEngineCfgHashMap`.
    These members serve the same purpose as they did in the `MarketMaker` class; `feature_engine_`
    is used to extract the ratio of aggressive trade to top-of-book quantity. The
    `order_manager_` object is used to send and manage the orders for this trading
    strategy. Finally, the `ticker_cfg_` object holds the trading parameters that
    will be used by this algorithm to make trading decisions and send orders to the
    exchange:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义数据成员，它们与 MM 算法中相同。`LiquidityTaker` 类有一个 `feature_engine_` 成员，它是一个指向
    `FeatureEngine` 对象的常量指针，一个指向 `OrderManager` 对象的 `order_manager_` 指针，以及一个常量 `ticker_cfg_`
    成员，其类型为 `TradeEngineCfgHashMap`。这些成员与在 `MarketMaker` 类中的用途相同；`feature_engine_`
    用于提取主动交易与订单簿顶部数量的比率。`order_manager_` 对象用于发送和管理此交易策略的订单。最后，`ticker_cfg_` 对象持有此算法将用于做出交易决策并向交易所发送订单的交易参数：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next section, we will see how to initialize a `LiquidityTaker` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何初始化一个 `LiquidityTaker` 对象。
- en: Initializing the LiquidityTaker trading algorithm
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化 LiquidityTaker 交易算法
- en: 'The initialization for the `LiquidityTaker` class is identical to the initialization
    for the `MarketMaker` class. The constructor expects the following arguments –
    a `Logger` object, the `TradeEngine` object within which this algorithm runs,
    a `FeatureEngine` object to compute the feature, an `OrderManager` object used
    to manage orders for this trading strategy, and a `TradeEngineCfgHashMap` object
    containing the trading parameters for this strategy:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiquidityTaker`类的初始化与`MarketMaker`类的初始化相同。构造函数期望以下参数——一个`Logger`对象，此算法运行的`TradeEngine`对象，一个用于计算特征的`FeatureEngine`对象，一个用于管理此交易策略订单的`OrderManager`对象，以及包含此策略交易参数的`TradeEngineCfgHashMap`对象：'
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This constructor also overrides the callbacks in the `TradeEngine` object for
    order book updates, trade events, and updates to the algorithm’s orders like the
    `MarketMaker` algorithm. The `std::function` members, `algoOnOrderBookUpdate_`,
    `algoOnTradeUpdate_`, and `algoOnOrderUpdate_`, in `TradeEngine` are bound, respectively,
    to the `onOrderBookUpdate`, `onTradeUpdate`, and `onOrderUpdate` methods within
    `LiquidityTaker` using lambda methods, as shown here (and as we saw before):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数还覆盖了`TradeEngine`对象中的回调，包括订单簿更新、交易事件以及算法订单（如`MarketMaker`算法）的更新。`TradeEngine`中的`std::function`成员`algoOnOrderBookUpdate_`、`algoOnTradeUpdate_`和`algoOnOrderUpdate_`分别通过lambda方法绑定到`LiquidityTaker`内部的`onOrderBookUpdate`、`onTradeUpdate`和`onOrderUpdate`方法，如下所示（以及我们之前看到的）：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we will discuss the code for handling trade events and order book updates
    due to events in the market data in this trading strategy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论处理由于市场数据事件而导致的交易事件和订单簿更新的代码。
- en: Handling trade events and order book updates
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理交易事件和订单簿更新
- en: 'For the `MarketMaker` trading strategy, we saw that it only makes trading decisions
    on order book updates and does nothing on trade updates. The `LiquidityTaker`
    strategy does the opposite – it takes trading decisions in the `onTradeUpdate()`
    method and does nothing in the `onOrderBookUpdate()` method. We will start by
    looking at the implementation of the `LiquidityTaker::onTradeUpdate()` method
    first in the next code block:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MarketMaker`交易策略，我们看到了它只在订单簿更新时做出交易决策，而在交易更新时则不采取任何行动。`LiquidityTaker`策略则相反——它在`onTradeUpdate()`方法中做出交易决策，而在`onOrderBookUpdate()`方法中不采取任何行动。我们将在下一个代码块中首先查看`LiquidityTaker::onTradeUpdate()`方法的实现：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will fetch and save `BBO` using the `getBBO()` method in the `bbo` local
    variable. For this trading strategy, we will fetch the aggressive trade quantity
    ratio feature from the feature engine by calling the `FeatureEngine::getAggTradeQtyRatio()`
    method and saving it in the `agg_qty_ratio` variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`getBBO()`方法在`bbo`局部变量中获取并保存`BBO`。对于这个交易策略，我们将通过调用`FeatureEngine::getAggTradeQtyRatio()`方法从特征引擎中获取侵略性交易数量比特征，并将其保存到`agg_qty_ratio`变量中：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As we saw before, we will check to make sure that `bid_price_`, `ask_price_`,
    and `agg_qty_ratio` are valid values before we decide to take an order action:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在我们决定采取订单操作之前，我们将检查`bid_price_`、`ask_price_`和`agg_qty_ratio`是否为有效值：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the validity check passes, we first need to fetch the `clip_` member from
    the `ticker_cfg_` object for the `TickerId` of this trade message, as shown in
    the following code block, and save it in the `clip` local variable. Similarly,
    we will fetch and save the `threshold_` member from the `ticker_cfg_` configuration
    object for that `TickerId`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有效性检查通过，我们首先需要从`ticker_cfg_`对象中获取`clip_`成员，用于这个交易消息的`TickerId`，如下面的代码块所示，并将其保存到`clip`局部变量中。同样，我们将从`ticker_cfg_`配置对象中获取并保存该`TickerId`的`threshold_`成员：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To decide whether we send or adjust active orders for this algorithm, we will
    check whether the `agg_qty_ratio` exceeds the threshold we previously fetched:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定我们是否为这个算法发送或调整活跃订单，我们将检查`agg_qty_ratio`是否超过了我们之前获取的阈值：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To send orders using the `OrderManager::moveOrders()` method, we will check
    whether the aggressive trade was a buy trade or a sell trade. If it was a buy
    trade, we will send an aggressive buy order to take liquidity at the best `BBO`
    `ask_price_` and no sell order by specifying a sell price of `Price_INVALID`.
    Conversely, if it was a sell trade and we wanted to send an aggressive sell order
    to take liquidity, we would specify a sell price to be `bid_price_` in the `BBO`
    object and no buy order by specifying a `Price_INVALID` buy price. Remember that
    this trading strategy takes a direction in the market by aggressively sending
    a buy or sell order one at a time, but not both like the `MarketMaker` algorithm:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`OrderManager::moveOrders()`方法发送订单，我们将检查激进的交易是买入交易还是卖出交易。如果是买入交易，我们将发送一个激进的买入订单以在最佳`BBO`
    `ask_price_`处获取流动性，并指定一个`Price_INVALID`的卖出价格，不发送任何卖出订单。相反，如果它是卖出交易，并且我们想要发送一个激进的卖出订单以获取流动性，我们将在`BBO`对象中指定一个`bid_price_`的卖出价格，并通过指定一个`Price_INVALID`的买入价格不发送任何买入订单。请记住，这种交易策略通过激进地一次发送一个买入或卖出订单来在市场中确定方向，而不是像`MarketMaker`算法那样同时发送两者：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As mentioned before and as shown in the following code block, this `LiquidityTaker`
    trading strategy does not take any action on order updates in the `onOrderBookUpdate()`
    method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，并在以下代码块中所示，此`LiquidityTaker`交易策略在`onOrderBookUpdate()`方法中不对订单更新采取任何行动：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The next concluding section related to `LiquidityTaker` adds handling to the
    order updates for the strategy’s orders.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与`LiquidityTaker`相关的下一个结论性部分增加了对策略订单的订单更新处理。
- en: Handling order updates in the LiquidityTaker algorithm
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`LiquidityTaker`算法中处理订单更新
- en: 'The `LiquidityTaker::onOrderUpdate()` method, as shown in the following code
    block, has an identical implementation to the `MarketMaker::onOrderUpdate()` method
    and simply forwards the order update to the order manager using the `OrderManager::onOrderUpdate()`
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码块所示，`LiquidityTaker::onOrderUpdate()`方法与`MarketMaker::onOrderUpdate()`方法有相同的实现，只是简单地使用`OrderManager::onOrderUpdate()`方法将订单更新转发给订单管理器。
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That concludes our implementation of the `LiquidityTaker` trading strategy.
    In the next section, we will shift the discussion to building the final form of
    our trading application so that we can build and run these actual trading strategies
    in our electronic trading ecosystem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对`LiquidityTaker`交易策略的实现。在下一节中，我们将讨论构建我们交易应用的最终形式，以便我们可以在我们的电子交易生态系统中构建和运行这些实际的交易策略。
- en: Building the trade engine framework
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建交易引擎框架
- en: In this section, we will build the trade engine framework in the `TradeEngine`
    class. This framework ties all the different components we built together – the
    `OrderGateway`, `MarketDataConsumer`, `MarketOrderBook`, `FeatureEngine`, `PositionKeeper`,
    `OrderManager`, `RiskManager`, `MarketMaker`, and `LiquidityTaker` components.
    As a reminder of the trading engine component, we present a diagram of all the
    sub-components here. We have built all the sub-components; now, we will just build
    the trading engine framework in which these sub-components exist.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建`TradeEngine`类中的交易引擎框架。这个框架将我们构建的所有不同组件连接在一起——包括`OrderGateway`、`MarketDataConsumer`、`MarketOrderBook`、`FeatureEngine`、`PositionKeeper`、`OrderManager`、`RiskManager`、`MarketMaker`和`LiquidityTaker`组件。为了提醒交易引擎组件，我们在此展示所有子组件的图示。我们已经构建了所有子组件；现在，我们将构建这些子组件存在的交易引擎框架。
- en: '![Figure 10.8 – The components of the trading engine in the client’s trading
    system](img/Figure_9.1_B19434.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 客户交易系统中的交易引擎组件](img/Figure_9.1_B19434.jpg)'
- en: Figure 10.8 – The components of the trading engine in the client’s trading system
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 客户交易系统中的交易引擎组件
- en: We will start this section by defining the data members of our class, as usual.
    All the source code for the basic `TradeEngine` framework is in the `Chapter10/trading/strategy/trade_engine.h`
    and `Chapter10/trading/strategy/trade_engine.cpp` source files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像往常一样，从这个节开始定义我们类的数据成员。所有基本`TradeEngine`框架的源代码都在`Chapter10/trading/strategy/trade_engine.h`和`Chapter10/trading/strategy/trade_engine.cpp`源文件中。
- en: Defining the data members in the trade engine
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义交易引擎的数据成员
- en: 'Before we define the data members in the `TradeEngine` class, we present the
    header files that the `trade_engine.h` source file needs to include:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义`TradeEngine`类的数据成员之前，我们展示`trade_engine.h`源文件需要包含的头文件：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `TradeEngine` class needs the following basic data members:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`TradeEngine`类需要以下基本数据成员：'
- en: It has a `client_id_` variable of type `ClientId` to represent the unique trading
    application instance.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个类型为 `ClientId` 的 `client_id_` 变量，用于表示唯一的交易应用程序实例
- en: We create a `ticker_order_book_` instance of type `MarketOrderBookHashMap`,
    which, as a reminder, is `std::array` of `MarketOrderBook` objects to represent
    a hash map from `TickerId` to `MarketOrderBook` for that instrument.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个类型为 `MarketOrderBookHashMap` 的 `ticker_order_book_` 实例，提醒一下，这是一个 `MarketOrderBook`
    对象的 `std::array`，用于表示从 `TickerId` 到 `MarketOrderBook` 的哈希映射，针对该工具。
- en: We have three lock-free queues to receive market data updates, send order requests,
    and receive order responses from the `MarketDataConsumer` and `OrderGateway` components.
    We receive market data updates using the `incoming_md_updates_` variable, which
    is a pointer to type `MEMarketUpdateLFQueue` (`LFQueue` of `MEMarketUpdate` messages).
    We send client order requests using the `outgoing_ogw_requests_` variable, which
    is a pointer to type `ClientRequestLFQueue` (`LFQueue` of `MEClientRequest` messages).
    We receive client order responses using the `incoming_ogw_responses_` variable,
    which is a pointer to type `ClientResponseLFQueue` (`LFQueue` of `MEClientResponse`
    messages).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有三个无锁队列用于接收市场数据更新、发送订单请求和接收来自 `MarketDataConsumer` 和 `OrderGateway` 组件的订单响应。我们使用
    `incoming_md_updates_` 变量接收市场数据更新，它是指向类型 `MEMarketUpdateLFQueue`（`MEMarketUpdate`
    消息的 `LFQueue`）的指针。我们使用 `outgoing_ogw_requests_` 变量发送客户端订单请求，它是指向类型 `ClientRequestLFQueue`（`MEClientRequest`
    消息的 `LFQueue`）的指针。我们使用 `incoming_ogw_responses_` 变量接收客户端订单响应，它是指向类型 `ClientResponseLFQueue`（`MEClientResponse`
    消息的 `LFQueue`）的指针。
- en: We have the usual Boolean `run_` variable, which will control the execution
    of the main `TradeEngine` thread and is marked `volatile`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有通常的布尔变量 `run_`，它将控制主 `TradeEngine` 线程的执行，并标记为 `volatile`。
- en: We have a `last_event_time_` variable of type `Nanos` to keep track of the time
    when the last message from the exchange was received.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个类型为 `Nanos` 的 `last_event_time_` 变量，用于跟踪收到交易所最后一条消息的时间
- en: 'We will also have a `Logger` variable called `logger_` to create a log file
    for `TradeEngine` to use:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将有一个名为 `logger_` 的 `Logger` 变量，为 `TradeEngine` 创建一个日志文件：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also need instances of each of our components from the previous chapter,
    namely the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要上一章中每个组件的实例，具体如下：
- en: A variable of type `FeatureEngine` called `feature_engine_` to compute complex
    feature values
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为 `FeatureEngine` 的变量 `feature_engine_`，用于计算复杂特征值
- en: A `position_keeper_` variable of type `PositionKeeper` to track trading strategy
    positions and Profits and Losses (**PnLs**) money made or lost from our trading
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为 `PositionKeeper` 的 `position_keeper_` 变量，用于跟踪交易策略的头寸和盈亏（**PnLs**），即从我们的交易中赚取或亏损的资金
- en: An instance of type `OrderManager` called `order_manager_`, which will be used
    by the trading strategies to send and manage live orders
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `order_manager_` 的 `OrderManager` 实例，它将被交易策略用于发送和管理实时订单
- en: A `RiskManager` object named `risk_manager_` to manage the trading strategy’s
    risk
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `risk_manager_` 的 `RiskManager` 对象，用于管理交易策略的风险
- en: A pointer to a `MarketMaker` object called `mm_algo_`, which will be initialized
    if we configure `TradeEngine` to run a MM trading algorithm
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向 `MarketMaker` 对象的指针 `mm_algo_`，如果我们将 `TradeEngine` 配置为运行 MM 交易算法，它将被初始化
- en: 'Similarly, a pointer to a `LiquidityTaker` object called `taker_algo_`, which
    will be initialized if we configure `TradeEngine` to run a liquidity taking trading
    strategy:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，一个指向 `LiquidityTaker` 对象的指针 `taker_algo_`，如果我们将 `TradeEngine` 配置为运行流动性获取交易策略，它将被初始化：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will also add three `std::function` member variables, which `TradeEngine`
    will use to forward market data and order updates to the trading strategy that
    it instantiates. These are explained as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加三个 `std::function` 成员变量，`TradeEngine` 将使用这些变量将市场数据和订单更新转发到它实例化的交易策略。具体说明如下：
- en: '`algoOnOrderBookUpdate_` `std::function` has the same signature as the `TradeEngine::onOrderBookUpdate()`
    method and is used to forward order book updates to the trading strategy'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algoOnOrderBookUpdate_` `std::function` 与 `TradeEngine::onOrderBookUpdate()`
    方法的签名相同，并用于将订单簿更新转发到交易策略'
- en: '`algoOnTradeUpdate_` `std::function` has the same signature as the `TradeEngine::onTradeUpdate()`
    method and is used to forward trade events to the trading strategy'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algoOnTradeUpdate_` `std::function` 与 `TradeEngine::onTradeUpdate()` 方法的签名相同，并用于将交易事件转发到交易策略'
- en: '`algoOnOrderUpdate_` `std::function` has the same signature as the `TradeEngine::onOrderUpdate()`
    method and is used to forward order updates/responses to the trading strategy:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algoOnOrderUpdate_` `std::function` 与 `TradeEngine::onOrderUpdate()` 方法的签名相同，并用于将订单更新/响应转发到交易策略：'
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To default-initialize these three `std::function` data members, we will create
    three new methods that simply log the parameters they are passed. They are shown
    here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了默认初始化这三个 `std::function` 数据成员，我们将创建三个新方法，这些方法只是记录它们接收到的参数。它们在此处显示：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we will discuss the code for some methods to initialize the `TradeEngine`
    class and its member variables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论初始化 `TradeEngine` 类及其成员变量的某些方法的代码。
- en: Initializing the trade engine
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化交易引擎
- en: The constructor for the `TradeEngine` class requires a `ClientId` argument to
    identify the trading application used in the client order requests. It also needs
    pointers to the three `LFQueue` of types `ClientRequestLFQueue`, `ClientResponseLFQueue`,
    and `MEMarketUpdateLFQueue` to initialize the `outgoing_ogw_requests_`, `incoming_ogw_responses_`
    and `incoming_md_updates_` data members, respectively. It also needs an `algo_type`
    argument of type `AlgoType` to specify the type of trading strategy and a `ticker_cfg`
    argument of type reference-to `const TradeEngineCfgHashMap`, which contains the
    configuration parameters for the risk manager and the trading strategy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`TradeEngine` 类的构造函数需要一个 `ClientId` 参数来标识客户端订单请求中使用的交易应用程序。它还需要指向三种类型的 `LFQueue`
    的指针 – `ClientRequestLFQueue`、`ClientResponseLFQueue` 和 `MEMarketUpdateLFQueue`，分别用于初始化
    `outgoing_ogw_requests_`、`incoming_ogw_responses_` 和 `incoming_md_updates_` 数据成员。它还需要一个
    `algo_type` 参数，其类型为 `AlgoType`，用于指定交易策略的类型，以及一个 `ticker_cfg` 参数，其类型为对 `const TradeEngineCfgHashMap`
    的引用，其中包含风险管理器和交易策略的配置参数。'
- en: 'The constructor also initializes the `Logger logger_` member variable with
    a log file and creates a `MarketOrderBook` component for each possible `TickerId`
    value, holding them in the `ticker_order_book_` container. It calls the `setTradeEngine()`
    method on each `MarketOrderBook` component so that callbacks from the book can
    be received in `TradeEngine`. We also initialize the data members corresponding
    to the trading sub-components – `feature_engine_`, `position_keeper_`, `order_manager_`,
    and `risk_manager_`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还使用日志文件初始化 `Logger logger_` 成员变量，并为每个可能的 `TickerId` 值创建一个 `MarketOrderBook`
    组件，将它们保存在 `ticker_order_book_` 容器中。它对每个 `MarketOrderBook` 组件调用 `setTradeEngine()`
    方法，以便在 `TradeEngine` 中接收来自簿的回调。我们还初始化了对应于交易子组件的数据成员 – `feature_engine_`、`position_keeper_`、`order_manager_`
    和 `risk_manager_`：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the body of the constructor, in addition to the order books we previously
    created, we will initialize our new `std::function` members – `algoOnOrderBookUpdate_`,
    `algoOnTradeUpdate_`, and `algoOnOrderUpdate_` – with the defaults – the `defaultAlgoOnOrderBookUpdate()`,
    `defaultAlgoOnTradeUpdate()`, and `defaultAlgoOnOrderUpdate()` methods:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的主体中，除了我们之前创建的订单簿之外，我们还将我们的新 `std::function` 成员 – `algoOnOrderBookUpdate_`、`algoOnTradeUpdate_`
    和 `algoOnOrderUpdate_` – 初始化为默认值 – `defaultAlgoOnOrderBookUpdate()`、`defaultAlgoOnTradeUpdate()`
    和 `defaultAlgoOnOrderUpdate()` 方法：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we will initialize a trading strategy instance, either `mm_algo_`
    of type `MarketMaker` or `taker_algo_` of the `LiquidityTaker` type trading strategy.
    This initialization is shown as follows; remember that the `MarketMaker` or `LiquidityTaker`
    object will update/override the members – `algoOnOrderBookUpdate_`, `algoOnTradeUpdate_`,
    and `algoOnOrderUpdate_` – to point to their own method implementations:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将初始化一个交易策略实例，它可以是类型为 `MarketMaker` 的 `mm_algo_` 或类型为 `LiquidityTaker` 的
    `taker_algo_` 交易策略。此初始化过程如下所示；请记住，`MarketMaker` 或 `LiquidityTaker` 对象将更新/覆盖成员变量
    – `algoOnOrderBookUpdate_`、`algoOnTradeUpdate_` 和 `algoOnOrderUpdate_` – 以指向它们自己的方法实现：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have a `start()` method, as we saw for other components. Again, it sets
    the `run_` flag to `true` to allow the `run()` method to execute and creates and
    launches a thread to execute the `run()` method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `start()` 方法，正如我们在其他组件中看到的那样。再次强调，它将 `run_` 标志设置为 `true` 以允许 `run()` 方法执行，并创建并启动一个线程来执行
    `run()` 方法：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The destructor does some simple de-initialization of the variables. First,
    it sets the `run_` flag to `false` and waits a little bit to let the main thread
    exit, then it proceeds to delete each `MarketOrderBook` instance and clear out
    the `ticker_order_book_` container, and finally, it resets the `LFQueue` pointers
    it holds. It also deletes the `mm_algo_` and `taker_algo_` members corresponding
    to the trading strategies:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数对变量进行了一些简单的反初始化。首先，它将 `run_` 标志设置为 `false`，稍作等待以让主线程退出，然后继续删除每个 `MarketOrderBook`
    实例，清空 `ticker_order_book_` 容器，并最终重置它持有的 `LFQueue` 指针。它还删除了对应于交易策略的 `mm_algo_`
    和 `taker_algo_` 成员：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The familiar `stop()` method for this class first waits until all the incoming
    `MEClientResponse` and `MEMarketUpdate` messages are drained from the `incoming_ogw_responses_`
    and `incoming_md_updates_` `LFQueue` objects. Then, it resets the `run_` flag
    to stop the main `run()` thread and returns from the function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类熟悉的 `stop()` 方法首先等待直到所有来自 `incoming_ogw_responses_` 和 `incoming_md_updates_`
    `LFQueue` 对象的 `MEClientResponse` 和 `MEMarketUpdate` 消息都被清空。然后，它将 `run_` 标志重置以停止主
    `run()` 线程并从函数返回：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The next method we will add to this basic framework is meant to be used to send
    `MEClientRequest` messages to the exchange.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到这个基本框架中的下一个方法旨在用于向交易所发送 `MEClientRequest` 消息。
- en: Sending client requests
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送客户端请求
- en: 'The `sendClientRequest()` method in the trading engine framework is extremely
    simple. It receives a `MEClientRequest` object and simply writes it to the `outgoing_ogw_requests_`
    lock-free queue so that the `OrderGateway` component can pick this up and send
    it out to the trading exchange:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 交易引擎框架中的 `sendClientRequest()` 方法非常简单。它接收一个 `MEClientRequest` 对象，并将其简单地写入 `outgoing_ogw_requests_`
    无锁队列，以便 `OrderGateway` 组件可以取走并发送到交易交易所：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The next subsection presents the main `run()` loop and shows how we handle incoming
    data from the exchange.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示主要的 `run()` 循环，并展示我们如何处理来自交易所的传入数据。
- en: Processing market data updates and client responses
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理市场数据更新和客户端响应
- en: The main thread for `TradeEngine` executes the `run()` method, which simply
    checks the incoming data `LFQueue` and reads and processes any available updates.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`TradeEngine` 的主线程执行 `run()` 方法，该方法简单地检查传入的数据 `LFQueue` 并读取和处理任何可用的更新。'
- en: 'First, we check and drain the `incoming_ogw_responses_` queue. For each `MEClientResponse`
    message we read here, we call the `TradeEngine::onOrderUpdate()` method and pass
    the response message from `OrderGateway` to it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查并清空 `incoming_ogw_responses_` 队列。对于我们在其中读取的每个 `MEClientResponse` 消息，我们调用
    `TradeEngine::onOrderUpdate()` 方法，并将来自 `OrderGateway` 的响应消息传递给它：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We perform a similar task with the `incoming_md_updates_` lock-free queue.
    We read any available `MEMarketUpdate` messages and pass them to the correct `MarketOrderBook`
    instance by calling the `MarketOrderBook::onMarketUpdate()` method and passing
    the market update to it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `incoming_md_updates_` 无锁队列执行类似任务。我们读取任何可用的 `MEMarketUpdate` 消息，并通过调用 `MarketOrderBook::onMarketUpdate()`
    方法并将市场更新传递给它，将它们传递给正确的 `MarketOrderBook` 实例：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that in both of the preceding code blocks, when we successfully read and
    dispatch a market data update or an order response, we update the `last_event_time_`
    variable to track the time of the event, as we described earlier in this section.
    We will see some minor miscellaneous placeholder methods in the next subsection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面两个代码块中，当我们成功读取和分发市场数据更新或订单响应时，我们会更新 `last_event_time_` 变量以跟踪事件的时间，正如我们在本节前面所描述的。在下一个子节中，我们将看到一些小的杂项占位符方法。
- en: Handling order book, trade, and order response updates
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理订单簿、交易和订单响应更新
- en: 'The `TradeEngine::onOrderBookUpdate()` method performs a couple of tasks. First,
    it fetches `BBO` from `MarketOrderBook`, which it receives in the method’s arguments
    by calling the `MarketOrderBook::getBBO()` method. It provides the updated `BBO`
    to the `position_keeper_` and `feature_engine_` data members. For the `FeatureEngine`
    member, it calls the `FeatureEngine::onOrderBookUpdate()` method to notify the
    feature engine to update its feature values. The method also needs to call `algoOnOrderBookUpdate_()`
    so that the trading strategy can receive the notification about the order book
    update:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`TradeEngine::onOrderBookUpdate()` 方法执行几个任务。首先，它从 `MarketOrderBook` 获取 `BBO`，它通过调用
    `MarketOrderBook::getBBO()` 方法在方法参数中接收。它将更新的 `BBO` 提供给 `position_keeper_` 和 `feature_engine_`
    数据成员。对于 `FeatureEngine` 成员，它调用 `FeatureEngine::onOrderBookUpdate()` 方法来通知特征引擎更新其特征值。该方法还需要调用
    `algoOnOrderBookUpdate_()` 以便交易策略可以接收关于订单簿更新的通知：'
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `TradeEngine::onTradeUpdate()` method that is called on trade events also
    performs a couple of tasks, which are like the ones in the `onOrderBookUpdate()`
    method we just saw. It passes the trade event to `FeatureEngine` by calling the
    `onTradeUpdate()` method so that the feature engine can update the features it
    computes. It also passes the trade event to the trading strategy by invoking the
    `algoOnTradeUpdate_()` `std::function` member:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易事件上被调用的 `TradeEngine::onTradeUpdate()` 方法也执行几个任务，这些任务类似于我们刚才看到的 `onOrderBookUpdate()`
    方法中的任务。它通过调用 `onTradeUpdate()` 方法将交易事件传递给 `FeatureEngine`，以便特征引擎可以更新其计算的特征值。它还通过调用
    `algoOnTradeUpdate_()` `std::function` 成员将交易事件传递给交易策略：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, `TradeEngine::onOrderUpdate()` does two things. It checks whether
    `MEClientResponse` corresponds to an execution (`ClientResponseType::FILLED`)
    and calls the `PositionKeeper::addFill()` method to update the position and PnLs.
    It also invokes the `algoOnOrderUpdate_()` `std::function` member so that the
    trading strategy can process the `MEClientResponse`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TradeEngine::onOrderUpdate()` 执行两件事。它检查 `MEClientResponse` 是否对应于执行（`ClientResponseType::FILLED`），并调用
    `PositionKeeper::addFill()` 方法来更新头寸和PnLs。它还调用 `algoOnOrderUpdate_()` `std::function`
    成员函数，以便交易策略可以处理 `MEClientResponse`：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, we can conclude the design and implementation of the `TradeEngine` framework
    in the next subsection by defining some miscellaneous methods we require.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过定义我们所需的杂项方法来总结下一小节中 `TradeEngine` 框架的设计和实现。
- en: Adding some miscellaneous methods
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一些杂项方法
- en: 'This section defines some miscellaneous methods for the `TradeEngine` class.
    The first method, `initLastEventTime()`, simply initializes the `last_event_time_`
    variable with the current time, which is obtained by calling the `getCurrentNanos()`
    method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本节定义了 `TradeEngine` 类的一些杂项方法。第一个方法 `initLastEventTime()` 简单地将 `last_event_time_`
    变量初始化为当前时间，该时间通过调用 `getCurrentNanos()` 方法获得：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `silentSeconds()` method returns the time elapsed (in seconds) since the
    last event was received:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`silentSeconds()` 方法返回自上次收到事件以来经过的时间（以秒为单位）：'
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `clientId()` method is a simple getter method that returns `client_id_`
    for this `TradeEngine` instance:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`clientId()` 方法是一个简单的获取器方法，它返回此 `TradeEngine` 实例的 `client_id_`：'
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That concludes the design and implementation of our trading engine framework.
    In the next section, we will build the main trading application binary.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们交易引擎框架的设计和实现。在下一节中，我们将构建主要交易应用程序的二进制文件。
- en: Building and running the main trading application
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行主要交易应用程序
- en: In the last section of this chapter, we will finally build the main trading
    application using all the components we built in this chapter, as well as the
    previous two chapters. First, we will discuss the implementation of the `trading_main`
    binary application, which combines the `MarketDataConsumer`, `OrderGateway`, `MarketOrderBook`,
    and `TradeEngine` components. After that, we will run our complete electronic
    trading ecosystem – the electronic trading exchange (the `exchange_main` application)
    from the *Communicating with Market Participants* chapter and a few instances
    of the market participants (the `trading_main` application), which we will build
    next.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将最终使用本章以及前两章中构建的所有组件来构建主要交易应用程序。首先，我们将讨论 `trading_main` 二进制应用程序的实现，该应用程序结合了
    `MarketDataConsumer`、`OrderGateway`、`MarketOrderBook` 和 `TradeEngine` 组件。之后，我们将运行我们的完整电子交易生态系统——电子交易交易所（*Communicating
    with Market Participants* 章节中的 `exchange_main` 应用程序）以及一些市场参与者实例（我们将构建的 `trading_main`
    应用程序）。
- en: Building the main trading application
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建主要交易应用程序
- en: Now, let us build the executable `trading_main` binary that will initialize
    and run all the components on the market participant’s trading system. The source
    code for this application is in the `Chapter10/trading/trading_main.cpp` source
    file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建可执行的 `trading_main` 二进制文件，该文件将在市场参与者的交易系统中初始化并运行所有组件。此应用程序的源代码位于 `Chapter10/trading/trading_main.cpp`
    源文件中。
- en: 'First, we will include the necessary header files and create some basic variables
    to represent the different components we need. Specifically, we will have a `Logger`
    object pointer to be used for logging purposes, a `TradeEngine` object pointer
    for the basic trading engine framework, a `MarketDataConsumer` object pointer
    to consumer market data, and an `OrderGateway` object pointer to connect to and
    communicate with the exchange’s order server:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将包含必要的头文件并创建一些基本变量来表示我们需要的不同组件。具体来说，我们将有一个 `Logger` 对象指针用于日志记录，一个 `TradeEngine`
    对象指针用于基本交易引擎框架，一个 `MarketDataConsumer` 对象指针用于消费市场数据，以及一个 `OrderGateway` 对象指针用于连接并与交易所的订单服务器通信：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, we start the entry point – the `main()` method. On the command line, we
    will accept arguments of the following form – `trading_main CLIENT_ID ALGO_TYPE
    [CLIP_1 THRESH_1 MAX_ORDER_SIZE_1 MAX_POS_1 MAX_LOSS_1] [CLIP_2 THRESH_2 MAX_ORDER_SIZE_2
    MAX_POS_2` `MAX_LOSS_2] …`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始入口点——`main()` 方法。在命令行中，我们将接受以下形式的参数——`trading_main CLIENT_ID ALGO_TYPE
    [CLIP_1 THRESH_1 MAX_ORDER_SIZE_1 MAX_POS_1 MAX_LOSS_1] [CLIP_2 THRESH_2 MAX_ORDER_SIZE_2
    MAX_POS_2 MAX_LOSS_2] …`
- en: 'The first argument represents `ClientId` for this trading application instance.
    We will also accept `AlgoType` as the second parameter, and configurations for
    each trading algorithm instance for each `TickerId` as the remaining parameters.
    We will source the random number generator by calling the `srand()` method and
    passing it `client_id` for this specific instance:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数代表此交易应用实例的`ClientId`。我们还将接受`AlgoType`作为第二个参数，以及每个`TickerId`对应的每个交易算法实例的配置作为剩余参数。我们将通过调用`srand()`方法并传递`client_id`来为这个特定实例生成随机数：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will extract `AlgoType`, as shown here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提取`AlgoType`，如下所示：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will also initialize an object of type `TradeEngineCfgHashMap` from the
    remaining command-line arguments, as shown in the following code block:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将从剩余的命令行参数中初始化一个类型为`TradeEngineCfgHashMap`的对象，如下面的代码块所示：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will initialize the component variables we declared before – `Logger`, the
    `client_requests` `LFQueue`, the `client_responses` `LFQueue`, and the `market_updates`
    `LFQueue`. We will also define a `sleep_time` variable and set it to 20 microseconds.
    We will use this value to pause between consecutive order requests we send to
    the trading exchange’s `OrderGatewayServer` component, only in the random trading
    strategy:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始化我们之前声明的组件变量——`Logger`、`client_requests` `LFQueue`、`client_responses` `LFQueue`和`market_updates`
    `LFQueue`。我们还将定义一个`sleep_time`变量并将其设置为20微秒。我们将在发送给交易交换的`OrderGatewayServer`组件的连续订单请求之间使用这个值进行暂停，仅在随机交易策略中：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The first component we will initialize and start will be `TradeEngine`. We
    will pass `client_id`, `algo_type`, the strategy configurations in the `ticker_cfg`
    object, and the lock-free queues that `TradeEngine` needs in the constructor.
    We then call the `start()` method to get the main thread to start executing, as
    shown in the following code block:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先初始化并启动`TradeEngine`组件。我们将传递`client_id`、`algo_type`、`ticker_cfg`对象中的策略配置以及`TradeEngine`构造函数所需的锁-free队列。然后我们调用`start()`方法，让主线程开始执行，如下面的代码块所示：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We perform a similar initialization of the `OrderGateway` component next by
    passing it the IP and port information of `exchange_main`’s `OrderGateway` server
    component. We also pass it the `client_requests` and `client_responses` `LFQueue`
    variables to consume `MEClientRequest` messages from and write `MEClientResponse`
    messages to, and then we use `start()` on the main thread:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来通过传递`exchange_main`的`OrderGateway`服务器组件的IP和端口信息来对`OrderGateway`组件执行类似的初始化。我们还传递`client_requests`和`client_responses`
    `LFQueue`变量，以便从其中消费`MEClientRequest`消息并将`MEClientResponse`消息写入，然后我们在主线程上使用`start()`：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we initialize and start the `MarketDataConsumer` component. It needs
    the IP and port information of the snapshot stream and the incremental stream
    on which the exchange’s `MarketDataPublisher` publishes market data. It also needs
    the `market_updates` `LFQueue` variable, which it will write decoded market data
    updates to. Finally, since all the components are ready, we will start `market_data_consumer`
    so that we can process any market data updates available:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们初始化并启动`MarketDataConsumer`组件。它需要快照流和增量流的IP和端口信息，这些流是交易所的`MarketDataPublisher`发布市场数据的地方。它还需要`market_updates`
    `LFQueue`变量，它将写入解码后的市场数据更新。最后，由于所有组件都已准备就绪，我们将启动`market_data_consumer`以便我们可以处理任何可用的市场数据更新：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we are almost ready to start sending orders to the exchange; we just need
    to perform a few more minor tasks first. First, the `main()` application will
    sleep briefly so that the threads we just created and started in each of our components
    can run for a few seconds:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎准备好向交易所发送订单了；我们首先需要完成几个更小的任务。首先，`main()`应用程序将短暂休眠，以便我们刚刚在各个组件中创建并启动的线程可以运行几秒钟：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We will also initialize the first event time in `TradeEngine` by calling the
    `TradeEngine::initLastEventTime()` method. We intentionally delayed this member’s
    initialization until we were ready to start trading:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过调用`TradeEngine::initLastEventTime()`方法初始化`TradeEngine`中的第一个事件时间。我们故意延迟了这个成员的初始化，直到我们准备好开始交易：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If `AlgoType` is `AlgoType::RANDOM`, we will implement the trading logic right
    here, since it is super simple. First, we will check the `algo_type` variable,
    and branch if the `algo_type` argument specifies the random trading strategy:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`AlgoType`是`AlgoType::RANDOM`，我们将在这里实现交易逻辑，因为它非常简单。首先，我们将检查`algo_type`变量，并根据`algo_type`参数指定的随机交易策略进行分支：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For this random trading algorithm, we will create a starting `OrderId` value
    unique to this trading application’s instance, using the `client_id` we received
    from the command-line argument:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个随机交易算法，我们将创建一个独特的起始 `OrderId` 值，该值仅适用于此交易应用程序的实例，使用我们从命令行参数接收的 `client_id`：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since we send orders with a random price, quantity, and side in our current
    test setup, we will initialize a random reference price for each instrument, for
    which we will send orders. We will send orders with prices that are randomly distributed
    around this reference price value shortly. We do this purely so that different
    trading instruments have orders of slightly different and random prices. The random
    reference price for each instrument is held in the `ticker_base_price` variable.
    We will also create `std::vector` of `MEClientRequest` messages to store the order
    requests we send to the exchange. We will also send cancellations for some of
    these orders to exercise that functionality; hence, we will save them for when
    we try to cancel them:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的当前测试设置中，我们使用随机价格、数量和方向发送订单，因此我们将为每个工具初始化一个随机参考价格，我们将在这个参考价格值周围随机发送订单。我们这样做纯粹是为了让不同的交易工具具有略微不同且随机的价格订单。每个工具的随机参考价格存储在
    `ticker_base_price` 变量中。我们还将创建 `std::vector` 的 `MEClientRequest` 消息来存储我们发送给交易所的订单请求。我们还将为其中一些订单发送取消请求以练习该功能；因此，我们将它们保存起来以备取消时使用：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we can start sending some orders to the exchange, but first, we will initialize
    `TradeEngine`’s `last_event_time_` variable before we get started:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始向交易所发送一些订单，但在开始之前，我们将初始化 `TradeEngine` 的 `last_event_time_` 变量：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the following loop, which executes 10,000 times, we will perform a few tasks,
    described as follows.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的循环中，该循环执行10,000次，我们将执行以下任务。
- en: 'We will pick a random `TickerId`, generate a random `Price` close to the `ticker_base_price`
    reference price value for that instrument, generate a random `Qty`, and generate
    a random `Side` for the order we will send:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将随机选择一个 `TickerId`，生成一个接近该工具的 `ticker_base_price` 参考价格值的随机 `Price`，生成一个随机
    `Qty`，并为即将发送的订单生成一个随机 `Side`：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We will create an `MEClientRequest` message of type `ClientRequestType::NEW`
    with these attributes and pass it along to `TradeEngine` using the `sendClientRequest()`
    method call. We will pause for `sleep_time` (20 microseconds) after we send the
    order request, and we will also save the `MEClientRequest` message we just sent
    out in the `client_requests_vec` container:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类型为 `ClientRequestType::NEW` 的 `MEClientRequest` 消息，并带有这些属性，然后通过 `sendClientRequest()`
    方法调用将其传递给 `TradeEngine`。发送订单请求后，我们将暂停 `sleep_time`（20 微秒），并且我们还将把刚刚发送的 `MEClientRequest`
    消息保存在 `client_requests_vec` 容器中：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After the pause, we randomly pick a client request we sent from our container
    of client requests. We change the request type to `ClientRequestType::CANCEL`
    and send it through to `TradeEngine`. Then, we pause again and continue with the
    loop iteration:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停之后，我们从客户请求容器中随机选择一个我们发送的客户请求。我们将请求类型更改为 `ClientRequestType::CANCEL` 并将其发送到
    `TradeEngine`。然后，我们再次暂停并继续循环迭代：
- en: '[PRE74]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'After we have sent out all of the order flow, we wait until we encounter a
    60-second period where no market update and no order response have been received
    by `TradeEngine`. This is a simple method of detecting when there is no market
    activity due to this client or any other trading client being connected to the
    exchange:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送完所有订单流后，我们等待直到我们遇到一个60秒的周期，在此期间 `TradeEngine` 没有收到任何市场更新和订单响应。这是一种简单的方法来检测由于此客户端或任何其他交易客户端连接到交易所而没有市场活动的情况：
- en: '[PRE75]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After a period of inactivity, this application exits. We first stop each of
    our components and pause for a brief period, before de-initializing and exiting
    the application:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段不活跃期后，此应用程序退出。我们首先停止每个组件并暂停一段时间，然后反初始化并退出应用程序：
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This concludes the implementation of the `trading_main` application. We have
    included a build script in `Chapter10/scripts/build.sh`, which uses CMake and
    Ninja to build the libraries and the `trading_main` application, in addition to
    the `exchange_main` application that we built before. You will have to edit this
    script to point to the correct binaries on your system or switch to a different
    build system if you wish. The `scripts/build.sh` script is expected to be run
    from the `Chapter10` `root` directory, and it simply configures the build files,
    which in this case use `Ninja`, and cleans and rebuilds the build for the release
    and debug versions. We want to clarify that the choice of `Ninja` is completely
    arbitrary; we do not depend on anything that is `Ninja`-specific for our system
    to build and run. The build process generates binaries in the `Chapter10/cmake-build-release`
    and `Chapter10/cmake-build-debug` directories. The scripts to run the trading
    binaries use the binaries from the `Chapter10/cmake-build-release` directory.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着 `trading_main` 应用程序的实现完成。我们在 `Chapter10/scripts/build.sh` 中包含了一个构建脚本，该脚本使用
    CMake 和 Ninja 构建库和 `trading_main` 应用程序，以及我们之前构建的 `exchange_main` 应用程序。您将不得不编辑此脚本以指向您系统上的正确二进制文件，或者如果您希望，切换到不同的构建系统。`scripts/build.sh`
    脚本预计将从 `Chapter10` 的 `root` 目录运行，它只是配置构建文件，在这种情况下使用 `Ninja`，并清理和重建发布和调试版本的构建。我们想澄清，选择
    `Ninja` 是完全随机的；我们构建和运行系统不依赖于任何 `Ninja` 特定的东西。构建过程在 `Chapter10/cmake-build-release`
    和 `Chapter10/cmake-build-debug` 目录中生成二进制文件。运行交易二进制的脚本使用 `Chapter10/cmake-build-release`
    目录中的二进制文件。
- en: Running the final trading ecosystem
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行最终的交易生态系统
- en: We are finally at the point where we can run our entire electronic trading ecosystem,
    admittedly with a random trading strategy for now. We will present two scripts
    – one is `Chapter10/scripts/run_clients.sh`, which is configured to launch five
    instances of the `trading_main` application with client IDs of 1 to 5\. The second
    script is `Chapter10/scripts/run_exchange_and_clients.sh`, which first builds
    the libraries and the binaries using the `build.sh` script. Then, it launches
    the `exchange_main` application and proceeds to launch the trading client instances
    using the `run_clients.sh` script. Finally, it waits for all the trading client
    instances to finish execution, then terminates the exchange instance, and exits.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了可以运行整个电子交易生态系统的地步，虽然现在承认的是使用随机交易策略。我们将展示两个脚本——一个是 `Chapter10/scripts/run_clients.sh`，该脚本配置为启动具有客户端
    ID 1 到 5 的五个 `trading_main` 应用程序实例。第二个脚本是 `Chapter10/scripts/run_exchange_and_clients.sh`，它首先使用
    `build.sh` 脚本构建库和二进制文件。然后，它启动 `exchange_main` 应用程序，并继续使用 `run_clients.sh` 脚本启动交易客户端实例。最后，它等待所有交易客户端实例完成执行，然后终止交易所实例，并退出。
- en: 'We will not look at the full `run_clients.sh` script, but an example of the
    first trading client that creates a `MarketMaker` algorithm is shown here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会查看完整的 `run_clients.sh` 脚本，但这里展示了一个创建 `MarketMaker` 算法的第一个交易客户端的示例：
- en: '[PRE77]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this script, the 1 and 2 client IDs are MM trading algorithms, the 3 and
    4 client IDs are liquidity taking trading algorithms, and the last client ID,
    5, is a random trading algorithm. The random trading algorithm instance exists
    to simulate all trades made by the rest of the market participants for any reason.
    We do this because, in our ecosystem, we only run five trading clients (due to
    limited resources on our workstation). However, we encourage those interested
    among you with access to a lot more CPU resources to run as many trading clients
    as the system can handle. Remember that, in practice, the market is composed of
    orders and trades from thousands of market participants (if not more).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，客户端 ID 1 和 2 是 MM 交易算法，客户端 ID 3 和 4 是流动性获取交易算法，最后一个客户端 ID，5，是一个随机交易算法。随机交易算法实例的存在是为了模拟由于任何原因而由市场其他参与者进行的所有交易。我们这样做是因为，在我们的生态系统中，我们只运行五个交易客户端（由于工作站上的资源有限）。然而，我们鼓励那些拥有更多
    CPU 资源的人尽可能多地运行系统可以处理的交易客户端。请记住，在实践中，市场是由来自数千（如果不是更多）市场参与者的订单和交易组成的。
- en: 'First, we have the output of the build process, which is generated by running
    the `scripts/run_exchange_and_clients.sh` script that internally calls the `scripts/build.sh`
    script to first build everything. Note that you need to be in the `Chapter10`
    root directory, as shown here, for this script to work correctly:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有构建过程的输出，这是通过运行 `scripts/run_exchange_and_clients.sh` 脚本生成的，该脚本内部调用 `scripts/build.sh`
    脚本来首先构建所有内容。请注意，您需要处于如这里所示的 `Chapter10` 根目录中，以便此脚本能够正确运行：
- en: '[PRE78]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, we have the output of the `exchange_main` application starting up:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`exchange_main`应用程序启动的输出：
- en: '[PRE79]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, the output of the `trading_main` instances launching is produced:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生成`trading_main`实例启动的输出：
- en: '[PRE80]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we have the output from the trading clients that shut down, and then
    the exchange exits:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有关闭的交易客户端的输出，然后交易所退出：
- en: '[PRE81]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note that this is just the output displayed on screen. The interesting details
    are in the log files, which we will inspect and discuss in the next subsection.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只是在屏幕上显示的输出。有趣细节在日志文件中，我们将在下一小节中检查和讨论。
- en: One other important note is that the `exchange_main` application has 10 threads,
    and each `trading_main` application has 8 threads. The `Logger` threads, which
    are many of these threads (five for `exchange_main` and four for `trading_main`),
    as well as the thread for the `main()` method (one each for `exchange_main` and
    `trading_main`), are not CPU-intensive and sleep for most of their runtime. The
    optimal setup would need a lot of cores for the entire ecosystem, which is common
    for production trading servers used for electronic trading. On these production-grade
    trading servers, we would be able to assign a CPU core to each of the remaining
    critical threads (four for `exchange_main` and three for `trading_main`). Since
    we are not sure which server we run on, we intentionally avoid setting affinity
    on those threads. If CPU and/or memory resources are limited on your system, our
    advice would be to reduce the number of trading clients launched in the `run_clients.sh`
    script.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的注意事项是，`exchange_main`应用程序有10个线程，每个`trading_main`应用程序有8个线程。这些线程中的许多是`Logger`线程（`exchange_main`有五个，`trading_main`有四个），以及`main()`方法的线程（`exchange_main`和`trading_main`各有一个），它们不是CPU密集型，大部分运行时间都在休眠。最佳的设置需要整个生态系统很多核心，这在用于电子交易的生产级交易服务器上是常见的。在这些生产级交易服务器上，我们可以为剩余的每个关键线程分配一个CPU核心（`exchange_main`有四个，`trading_main`有三个）。由于我们不确定运行在哪个服务器上，所以我们故意避免为这些线程设置亲和性。如果您的系统CPU和/或内存资源有限，我们的建议是在`run_clients.sh`脚本中减少启动的交易客户端数量。
- en: Inspecting the output of a run
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查运行输出
- en: 'In this concluding section, we will look at the log files generated by running
    the `run_exchange_and_clients.sh` script. We know that the trading strategy we
    ran in this chapter is not interesting since it sends random orders to the exchange,
    but there are some important observations in these log files. Running the `run_exchange_and_clients.sh`
    script should generate log files similar to the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结论中，我们将查看运行`run_exchange_and_clients.sh`脚本生成的日志文件。我们知道在本章中运行的交易策略并不有趣，因为它向交易所发送随机订单，但日志文件中有一些重要的观察结果。运行`run_exchange_and_clients.sh`脚本应该生成类似于以下日志文件：
- en: '[PRE82]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: To understand and follow the events, our advice would be to correlate the log
    lines we generate from our calls to `Logger::log()` from various components and
    sub-components and then find them in the log files.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解和跟踪事件，我们的建议是关联我们从各个组件和子组件的`Logger::log()`调用生成的日志行，然后在日志文件中找到它们。
- en: 'As an example, let us follow the path of a client sending an order to the exchange
    receiving the request, and generating a client response and a market update for
    that order request. Let us say, for this example, that we want to find the path
    followed by **OrderId=1445** and **MarketOrderId=53**; the path which this order
    follows is laid out as follows from the log files. Note that this is just an example
    that was generated from this specific run and might not be reproducible; the goal
    here is to understand how to track the events in our ecosystem:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们跟随一个客户端向交易所发送订单、接收请求、生成客户端响应和该订单请求的市场更新的路径。假设，在这个例子中，我们想找到**OrderId=1445**和**MarketOrderId=53**的路径；该订单遵循的路径如下所示，从日志文件中可以看出。请注意，这只是一个从这次特定运行生成的示例，可能无法重现；这里的目的是了解如何跟踪我们生态系统中的事件：
- en: '`MEClientRequest` for the new order gets sent by the `TradeEngine` component
    for the `trading_main` instance with `ClientId=1`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MEClientRequest`新订单由`trading_main`实例的`TradeEngine`组件发送，该实例的`ClientId`为1：'
- en: '[PRE83]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `OrderGateway` component picks up that request from the lock-free queue
    and sends it out on the TCP connection to the exchange, as shown here:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrderGateway`组件从无锁队列中获取该请求，并通过TCP连接将其发送到交易所，如下所示：'
- en: '[PRE84]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `OrderServer` component inside the `exchange_main` application receives
    it from the `TCPServer` socket, as shown here:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exchange_main`应用程序内部的`OrderServer`组件从`TCPServer`套接字接收它，如下所示：'
- en: '[PRE85]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `FifoSequencer` sub-component inside `OrderServer` sequences the client
    order request (`MEClientRequest`) based on the software receive time, and publishes
    it to the `MatchingEngine` lock-free queue:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrderServer` 组件内部的 `FifoSequencer` 子组件根据软件接收时间对客户端订单请求 (`MEClientRequest`)
    进行排序，并将其发布到 `MatchingEngine` 的无锁队列中：'
- en: '[PRE86]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `MatchingEngine` component finally receives this request from `LFQueue`
    and processes it, as displayed in the following log file:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MatchingEngine` 组件最终从 `LFQueue` 接收此请求并处理它，如下面的日志文件所示：'
- en: '[PRE87]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In response to the order request it received, the `MatchingEngine` component
    generates a `MEClientResponse` message meant for the client to be published by
    the `OrderServer` component:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为对收到的订单请求的响应，`MatchingEngine` 组件生成一个 `MEClientResponse` 消息，该消息由 `OrderServer`
    组件发布给客户端：
- en: '[PRE88]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Corresponding to the new order that is added to the limit order book, `MatchingEngine`
    also generates an `MEMarketUpdate` message, as shown here. This is meant for the
    `MarketDataPublisher` component to publish and update the snapshot it maintains:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与添加到限价订单簿中的新订单相对应，`MatchingEngine` 也生成一个 `MEMarketUpdate` 消息，如下所示。这是为了让 `MarketDataPublisher`
    组件发布并更新它维护的快照：
- en: '[PRE89]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `OrderServer` component picks up the `MEClientResponse` message from `LFQueue`,
    sending out an `OMClientResponse` message to the client on the correct TCP connection
    with the trading client:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrderServer` 组件从 `LFQueue` 中获取 `MEClientResponse` 消息，并向正确的 TCP 连接上的客户端发送 `OMClientResponse`
    消息：'
- en: '[PRE90]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `MarketDataPublisher` component picks up the `MEMarketUpdate` message sent
    by `MatchingEngine`, sending out an `MDPMarketUpdate` message on the incremental
    market data multicast stream:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MarketDataPublisher` 组件接收由 `MatchingEngine` 发送的 `MEMarketUpdate` 消息，并在增量市场数据多播流上发送
    `MDPMarketUpdate` 消息：'
- en: '[PRE91]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `SnapshotSynthesizer` sub-component inside the `MarketDataPublisher` component
    also receives this incremental `MEMarketUpdate` message, adding it to the snapshot
    it maintains:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MarketDataPublisher` 组件内部的 `SnapshotSynthesizer` 子组件也接收这个增量 `MEMarketUpdate`
    消息，并将其添加到它维护的快照中：'
- en: '[PRE92]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'At some point, `SnapshotSynthesizer` publishes a snapshot of the `MDPMarketUpdate`
    messages on the snapshot multicast market data stream, including this market update:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个时刻，`SnapshotSynthesizer` 在快照多播市场数据流上发布 `MDPMarketUpdate` 消息的快照，包括这个市场更新：
- en: '[PRE93]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `OrderGateway` component inside the `trading_main` application receives
    the `OMClientResponse` response for the order request, from the TCPSocket that
    is connected to the exchange:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`trading_main` 应用程序内部的 `OrderGateway` 组件接收来自连接到交易所的 TCPSocket 的订单请求的 `OMClientResponse`
    响应：'
- en: '[PRE94]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `MarketDataConsumer` component inside the `trading_main` application receives
    the `MDPMarketUpdate` message on the incremental market data stream:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`trading_main` 应用程序内部的 `MarketDataConsumer` 组件接收增量市场数据流上的 `MDPMarketUpdate`
    消息：'
- en: '[PRE95]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `TradeEngine` component finally receives the `MEClientResponse` message
    from the `OrderGateway` component over the lock-free queue. It also forwards the
    `MEClientResponse` message via the `onOrderUpdate()` callback:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TradeEngine` 组件最终从 `OrderGateway` 组件通过无锁队列接收 `MEClientResponse` 消息。它还通过 `onOrderUpdate()`
    回调转发 `MEClientResponse` 消息：'
- en: '[PRE97]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`TradeEngine` also receives the `MEMarketUpdate` message, updates `MarketOrderBook`,
    and, in turn, receives `onOrderBookUpdate()` from the order book back in `TradeEngine`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TradeEngine` 也接收 `MEMarketUpdate` 消息，更新 `MarketOrderBook`，并反过来从 `TradeEngine`
    中的订单簿接收 `onOrderBookUpdate()`：'
- en: '[PRE99]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Hopefully, this example provided you with good insight into what the different
    components in our trading ecosystem do. This should also serve as an example of
    how to investigate different events in the various applications, components, and
    sub-components of our electronic trading universe.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个例子能让你对我们交易生态系统中不同组件的功能有更深入的了解。这也应该作为如何调查我们电子交易宇宙中各种应用、组件和子组件中不同事件的例子。
- en: 'Now, let us focus on the entries generated by our other components – `FeatureEngine`,
    `RiskManager`, `PositionKeeper`, and `OrderManager` – and the strategies – the
    `MarketMaker` and `LiquidityTaker` algorithms:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注由我们的其他组件生成的条目——`FeatureEngine`、`RiskManager`、`PositionKeeper` 和 `OrderManager`——以及策略——`MarketMaker`
    和 `LiquidityTaker` 算法：
- en: 'The following log lines display the feature values that are updated by `FeatureEngine`
    as the order book updates or new trade events occur in market data:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下日志行显示了 `FeatureEngine` 在订单簿更新或市场数据中出现新的交易事件时更新的特征值：
- en: '[PRE101]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The following log lines correspond to `PositionKeeper` being updated as `BBO`
    changes or additional executions are processed:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下日志行对应于 `PositionKeeper` 在 `BBO` 变化或处理额外执行时更新：
- en: '[PRE107]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Failures in `RiskManager`, due to several reasons we discussed in the *Building
    the C++ trading algorithm building blocks* chapter in the *Computing and managing
    risk* section, show up in the log files as something like the following:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在“构建 C++ 交易算法构建块”章节中讨论的几个原因，`RiskManager` 的失败在日志文件中显示如下：
- en: '[PRE111]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Events in `OrderManager` appear as follows in the log files, as attempts are
    made to send order requests and responses are processed:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在日志文件中，`OrderManager` 的事件如下所示，因为尝试发送订单请求并处理响应：
- en: '[PRE114]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Events in the `LiquidityTaker` trading strategy appear as shown here. These
    correspond to order book updates, trade events, and updates to strategy orders:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LiquidityTaker` 交易策略中的事件如下所示。这些对应于订单簿更新、交易事件和策略订单的更新：'
- en: '[PRE120]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Similarly, events in the `MarketMaker` trading algorithm appear in the log
    files, as shown here:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`MarketMaker` 交易算法中的事件在日志文件中显示，如下所示：
- en: '[PRE127]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We encourage you to inspect the various log files in more detail to understand
    the processing that occurs in the different components and how our entire electronic
    trading ecosystem functions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您更详细地检查各种日志文件，以了解不同组件中发生的处理过程以及我们整个电子交易生态系统的运作方式。
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on using all the components we have built over the last
    two chapters and leveraging them to build our intelligent trading strategies –
    the MM trading strategy and the liquidity taking trading algorithm. We spent some
    time understanding the theory, motivation, and behavior of these two trading algorithms
    with some examples.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了使用我们在前两章中构建的所有组件，并利用它们构建我们的智能交易策略——MM 交易策略和流动性获取交易算法。我们花了一些时间理解这两个交易算法的理论、动机和行为，并辅以一些示例。
- en: In the next two sections, we implemented the C++ MM trading algorithm, which
    manages passive orders, and the liquidity taking algorithm, which sends aggressive
    orders to the market.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，我们实现了 C++ MM 交易算法，该算法管理被动订单，以及流动性获取算法，该算法向市场发送积极订单。
- en: Then, we built the trading engine framework that ties together the market data
    consumer, the order gateway, the feature engine, the position keeper, the order
    manager, and the risk manager together with the two trading algorithms. This framework
    is what we use to join all these components together and facilitate the flow of
    incoming and outgoing data streams and trading intelligence.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了交易引擎框架，该框架将市场数据消费者、订单网关、功能引擎、仓位保持者、订单管理器和风险管理器以及两个交易算法结合在一起。这个框架是我们用来将这些组件连接起来并促进流入和流出数据流以及交易智能的框架。
- en: Finally, we built the main trading application, `trading_main`, which is the
    complement of the `exchange_main` application on the market participant’s side.
    We then ran a few different instances of the trading application to run instances
    of the random trading algorithm, the MM algorithm, and the liquidity taking algorithm
    in our ecosystem. We inspected the log files generated by running our electronic
    trading ecosystem as the different trading client systems and strategies interacted
    with each other through the electronic exchange.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建了主要的交易应用程序，`trading_main`，这是市场参与者侧 `exchange_main` 应用程序的补充。然后我们运行了几个不同的交易应用程序实例，以在我们的生态系统中运行随机交易算法、MM
    算法和流动性获取算法。我们检查了在电子交易生态系统运行时生成的日志文件，因为不同的交易客户端系统和策略通过电子交易所相互交互。
- en: In the next chapter, we will add an instrumentation system to measure the performance
    of our entire electronic trading ecosystem. We mentioned throughout this book
    that the first step to optimizing something is measuring the performance of a
    system and its components individually, and we will start by doing that in the
    next chapter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加一个仪表系统来衡量我们整个电子交易生态系统的性能。我们在这本书中提到，优化某物的第一步是衡量系统和其组件的性能，我们将在下一章开始这样做。
- en: Part 4:Analyzing and Improving Performance
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：分析和改进性能
- en: In this part, we will measure the performance of all the different C++ components
    in our trading ecosystem. We will analyze the latency profile of the different
    components individually, as well as measuring the performance of the end-to-end
    round-trip path. From there, we will discuss further optimization techniques and
    see the impact of our C++ optimization efforts. We will also discuss some future
    enhancements that can be made to our electronic trading ecosystem.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将测量我们交易生态系统中所有不同C++组件的性能。我们将分别分析不同组件的延迟配置文件，以及测量端到端往返路径的性能。从那里，我们将讨论进一步的优化技术，并观察我们C++优化努力的成效。我们还将讨论可以对我们的电子交易生态系统进行的某些未来改进。
- en: 'This part contains the following chapters:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '*Chapter 11, Adding Instrumentation and Measuring Performance*'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章，添加仪表和测量性能*'
- en: '*Chapter 12, Analyzing and Optimizing the Performance of Our C++ System*'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第12章，分析和优化我们的C++系统性能*'
