- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the C++ Market Making and Liquidity Taking Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement a C++ market making algorithm on top of all
    the components we built in the previous chapters. This market making algorithm
    will connect to and send orders to the trading exchange we built previously. Additionally,
    we will implement a C++ liquidity taking algorithm in the same trading engine
    framework. This liquidity taking algorithm will also connect to and send orders
    to the trading exchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the behavior of our trading algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the passive liquidity provided in the order book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening and closing positions aggressively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the trade engine framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running the main trading application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this book can be found in its GitHub repository at [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source for this chapter is in the `Chapter10` directory in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that you have read and understood the design of the electronic
    trading ecosystem presented in the *Designing Our Trading Ecosystem* chapter,
    especially the *Designing a framework for low latency C++ trading algorithms*
    section. It is also expected that you are quite familiar with the previous two
    chapters – *Processing Market Data and Sending Orders to the Exchange in C++*
    and *Building the C++ Trading Algorithm Building Blocks*, since we will be using
    every single component that we built in those two chapters in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown here. We present the details of this environment since
    all the C++ code presented in this book is not necessarily portable and might
    require some minor changes to work in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GCC: `g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake: `cmake` `version 3.23.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ninja: `1.10.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the behavior of our trading algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some additional details about the behavior
    and motivation behind the two trading strategies we will build in this chapter
    – the market making trading strategy and the liquidity taking trading strategy.
    With the use of a hypothetical example for each strategy, we will also try to
    understand the strategy order flow mechanics and try to further our understanding
    when we implement these trading strategies in our C++ system, towards the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the market making trading algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The market making trading strategies seek to make profits by seeking to *capture
    the spread*, which just means buying at the best bid price in the market passively
    and quickly selling at the best ask price in the market passively (or selling
    first and buying after). The market making strategies, profitability depends on
    the spread of the trading instrument, how many buy and sell trades the strategy
    can execute over time, and how much market prices move between the buy and sell
    trades. It should be clear that the market making strategies will trade only against
    other strategies that *cross the spread* and send aggressive buy and sell orders,
    which is what we refer to as **liquidity taking trading strategies**. What this
    means is that market making trading strategies rarely expect to trade against
    other market making trading strategies, since all instances of such strategies
    seek to execute their orders passively. To achieve this, market making trading
    strategies send and manage passive limit orders in the order book and try to use
    intelligence to modify the prices on these orders, thereby improving their execution
    and the probability of successfully capturing the spread as often as possible.
    In the next subsection, we will discuss a hypothetical example of how a market
    making trading strategy would manage its orders.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting market making mechanics with an example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will discuss the mechanics of how our market making trading
    strategy would behave under a hypothetical market condition. This will help strengthen
    your understanding of how the market making algorithm behaves. Before we do that,
    let us try to understand the following table.
  prefs: []
  type: TYPE_NORMAL
- en: The table presents a state of the market book known as the **price level-aggregated
    order book**. What this term means is that all the orders on the same side and
    same price are grouped/aggregated together into a single price level, so if there
    are 12 orders on the bid side, all at the same price (10.21), that add up to a
    total quantity of 2,500, they can be presented as a single entry. This is shown
    as follows, along with similar grouping on the next buy price level of 10.20 and
    ask levels of 10.22 and 10.23 prices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated
    book](img/B19434_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated
    book
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, the columns mean the following things (from left
    to right):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Our MM strategy bid**: This represents the quantity of the buy order that
    our **Market Making** (**MM**) strategy has at this price level, which in this
    case is none'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market bid order count**: This represents the number of buy orders in the
    market that make up this price level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market bid quantity**: The sum of the quantities on all the buy orders at
    this price level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market bid price**: This represents the price of this bid price level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market ask price**: This represents the price of this ask price level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market ask quantity**: The sum of the quantities of all the sell orders at
    this price level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market ask order count**: This represents the number of sell orders in the
    market that make up this price level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Our MM strategy ask**: This represents the quantity of the sell order that
    our MM strategy has at this price level, which in this case is none'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let us suppose our MM strategy starts running at the time that the market
    is in the state we described here. Let us also assume that, for this example,
    our strategy will send a single passive bid order and a single passive ask order,
    and each has a quantity of 100 shares. Let us say that the strategy decides to
    join the best bid price level and the best ask price level at prices 10.21 and
    10.22, respectively. It does this by sending a single buy order and a single sell
    order of a quantity of 100 at those prices. The following diagram represents this
    event, and the blocks highlighted in gold represent the things that changed because
    of this action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – An event where our MM order has joined the market on both sides](img/B19434_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – An event where our MM order has joined the market on both sides
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for one last scenario, let us assume that the orders on the best bid
    at 10.21 are either fully executed due to trade events and removed, or just canceled
    by the market participants that owned them. If the drop in quantity is large enough,
    let us assume that our MM trading strategy also decides to not be present at the
    price level. The state of the price aggregated order book looks like this right
    before our strategy decides to move its best bid order at a price one price level
    away from its current price, i.e., from price 10.21 to 10.20:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The state of the price level book when our MM order decides
    to move its bid](img/B19434_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The state of the price level book when our MM order decides to
    move its bid
  prefs: []
  type: TYPE_NORMAL
- en: This decision can be due to a wide range of factors, depending on the strategy
    and its features. However, for this example, let us offer you a simple intuitive
    thought – a lot of people are less willing to buy at 10.21 (only 600 shares in
    total) compared to how many people are willing to sell at 10.22 (6,500 shares).
    You might conclude that perhaps it is no longer wise to try and buy at 10.21 or
    that the fair market price is perhaps at 10.21, and you want to try and buy at
    a price that is a little lower than that. The next diagram displays the state
    of the price level book when the MM strategy decides to cancel its buy order at
    10.21 and repositions its buy order to 10.20.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – An event where our MM strategy repositions its bid from a price
    of 10.21 to 10.20](img/B19434_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – An event where our MM strategy repositions its bid from a price
    of 10.21 to 10.20
  prefs: []
  type: TYPE_NORMAL
- en: The discussion in this subsection aimed to improve your understanding of the
    mechanics of a simple MM strategy, and in the next subsection, we will move on
    to the liquidity taking trading algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the liquidity taking trading algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The liquidity taking trading algorithm in many ways is the opposite of the MM
    algorithm. Instead of sending passive orders to the book and waiting for them
    to be executed passively, it sends aggressive orders to execute trades when it
    needs them. In this sense, it *crosses the spread* (sends aggressive orders to
    execute) instead of trying to *capture the spread*, like the MM strategy. This
    strategy bets on getting the direction of the market correct – that is, it buys
    aggressively when it thinks that prices will increase further and sells aggressively
    when it thinks that prices will decrease further. The convenient fact about this
    trading algorithm is that order management is very easy since it does not always
    maintain live orders in the order book that it needs to manage. Another way to
    understand this is that when the strategy needs to execute a trade, it sends an
    order to the order book and gets executed almost immediately, and then it is done
    from an order management perspective. The inconvenient fact about this trading
    algorithm is that predicting market directions is extremely difficult, but we
    will not dive into that, since that is not the focus of this book. In the next
    subsection, we will understand the trading mechanics for this strategy as we did
    with the MM strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting liquidity taking mechanics with an example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, let us look at the price level-aggregated view of the order book,
    as discussed in the section on MM. The columns here mean the same thing, except
    they do not have the columns for the MM strategy orders, since the liquidity taking
    strategy will not rest orders passively in the order book. Let us assume the initial
    state of the price level book is as shown here, which was also the same initial
    state for the MM example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The state of the price level book at a given time for a hypothetical
    example](img/B19434_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The state of the price level book at a given time for a hypothetical
    example
  prefs: []
  type: TYPE_NORMAL
- en: Let us assume that, for this example, our liquidity taking strategy has a feature
    that tries to follow in the same direction as very large trades. What this means
    is that if a very large trade event happens in the market, our liquidity taking
    algorithm decides to take the same direction as this trade event. So, if a very
    large buy trade happens, our liquidity taking algorithm will buy aggressively,
    and if a very sell trade happens, our liquidity taking algorithm will sell aggressively.
    As mentioned before, this is only an example feature; in practice, different liquidity
    taking algorithms will have many such features on which the decision to make a
    trade depends. For our simple liquidity taking algorithm example, we will use
    this feature of large aggressive trade in the market.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what that looks like, let us assume that given the previous state
    of the price level book, a very large sell execution of a quantity of 2,200 hits
    the bid price level of 10.21, which had a total quantity of 2,500 prior to this.
    This event is shown in the following diagram, where the green arrow represents
    the trade aggressor in market data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – An event where a large sell aggressor causes a trade event](img/B19434_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – An event where a large sell aggressor causes a trade event
  prefs: []
  type: TYPE_NORMAL
- en: This trade event will cause the best bid quantity to reduce from 2,500 to 300
    – that is, by the quantity of the trade aggressor. Additionally, let us assume
    that our liquidity taking strategy observes the large trade of a quantity of 2,200
    and decides to send an aggressive sell order at the price of 10.21\. Let us also
    assume that, like the MM strategy, our liquidity taking strategy also sends a
    sell order of a quantity of 100\. This event is shown in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive
    sell order of a quantity of 100 at a price of 10.21](img/B19434_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive
    sell order of a quantity of 100 at a price of 10.21
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the theoretical discussion of the two trading strategies we seek
    to build as part of our trading system. We will get to their actual implementation
    inside our framework in a few sections’ time, but first, we need to build some
    additional building blocks for these strategies, which we will do in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an enumeration to define the type of algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will round up this discussion of our trading strategies by defining an `AlgoType`
    enumeration in the `Chapter10/common/types.h` header file. It has the following
    valid values – `MAKER` to represent MM, `TAKER` to represent liquidity taking,
    and `RANDOM` to represent the random trading strategy we built before. We also
    have `INVALID` and `MAX` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add a standard `algoTypeToString()` method used to stringify the `AlgoType`
    type, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `stringToAlgoType()` method, which we will build next, parses a string
    and converts it into an `AlgoType` enumeration value. It does this by iterating
    through all the possible `AlgoType` enumeration values and comparing the string
    argument against the output of `algoTypeToString()`, called on that `AlgoType`
    enumeration value. If the string representations match, then it returns the `algo_type`
    enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will move on to building the different building blocks we need to support
    our trading strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the passive liquidity provided in the order book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have all the sub-components we need to start building our
    trading strategies. The first strategy we will build will be the MM algorithm,
    which sends orders that are expected to rest passively in the order book. We discussed
    the details of this trading algorithm earlier in this chapter, so in this section,
    we will focus on the C++ implementation. All the source code for this `MarketMaker`
    trading algorithm can be found in the `Chapter10/trading/strategy/market_maker.h`
    and `Chapter10/trading/strategy/market_maker.cpp` source files.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data members in the MarketMaker algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to define the data members that make up the `MarketMaker` class.
    The key members are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to a constant `FeatureEngine` object called `feature_engine_`, which
    we will use to fetch the fair market price, using the `FeatureEngine::getMktPrice()`
    method we saw earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to an `OrderManager` object called `order_manager_`, which will be
    used to manage the passive orders that this strategy sends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ticker_cfg_` variable of a constant `TradeEngineCfgHashMap` type to hold
    the trading parameters for the different trading instruments that this algorithm
    will trade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us inspect the class definition, starting with the `include` files needed
    in the `market_maker.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, in the next code block, we can define the `MarketMaker` class and
    the aforementioned data members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next section will define the constructor to initialize an instance of this
    `MarketMaker` class.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the MarketMaker algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constructor implemented in the `market_maker.cpp` file is shown in the
    next code block. The constructor accepts a few arguments in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Logger` object, which will be saved in the `logger_` member variable and
    used for logging purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to a `TradeEngine` object, which will be used to bind the `algoOnOrderBookUpdate`,
    `algoOnTradeUpdate`, and `algoOnOrderUpdate` callbacks in the parent `TradeEngine`
    instance to the corresponding methods in the `MarketMaker` object. This is so
    that the `MarketMaker` trading strategy receives and processes the callbacks when
    `TradeEngine` receives them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to a constant `FeatureEngine` object, which will be stored in the
    `feature_engine_` data member and used to extract the feature values this algorithm
    needs, as described before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to an `OrderManager` object, which will be used to manage the orders
    for this strategy, and the constructor will simply be saved in the `order_manager_`
    data member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A reference to a constant `TradeEngineCfgHashMap`, which will be saved in the
    `ticker_cfg_` member and used to make trading decisions, since this contains the
    trading parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As mentioned before and as shown here, we will override the `TradeEngine:``     :algoOnOrderBookUpdate()`, `TradeEngine::algoOnTradeUpdate()`, and `TradeEngine::algoOnOrderUpdate()`
    methods using lambda methods to forward them to the `MarketMaker::onOrderBookUpdate()`,
    `MarketMaker::onTradeUpdate()`, and `MarketMaker::onOrderUpdate()` methods, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection tackles the most important task in the `MarketMaker` trading
    algorithm – handling order book updates and sending orders in reaction to them.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order book updates and trade events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MarketMaker::onOrderBookUpdate()` method is called by `TradeEngine` through
    the `TradeEngine::algoOnOrderBookUpdate_` `std::function` member variable. This
    is where the `MarketMaker` trading strategy makes trading decisions with regard
    to what prices it wants its bid and ask orders to be at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It fetches `BBO` from `w` using the `getBBO()` method and saves it in the `bbo`
    variable. We also fetch the market quantity-weighted BBO price and save it in
    the `fair_price` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We perform a sanity check on the best `bid_price_` and `ask_price_` values
    from `bbo` and `fair_price` to make sure that the prices are not `Price_INVALID`
    and the feature value is not `Feature_INVALID`. Only if this is `true` will we
    take any action; otherwise, we risk acting on invalid features or sending orders
    at invalid prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We fetch and save the `clip` quantity from the `ticker_cfg_` container, which
    will be the quantity on the passive orders we send to the exchange. We also extract
    and save the `threshold` value, which we will use to decide what prices to send
    the buy and sell orders at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize two price variables, `bid_price` and `ask_price`, to represent
    the prices on our buy and sell orders, respectively. We set `bid_price` to be
    the best bid price if the difference between `fair_price` we computed from the
    `FeatureEngine::getMktPrice()` method and the market bid price exceeds the `threshold`
    value. Otherwise, we set `bid_price` to be a price lower than the best market
    bid price. We compute `ask_price` using the same logic – use the best ask price
    if the difference from the fair price exceeds the threshold and a higher price
    otherwise. The motivation behind this is straightforward; when we think the fair
    price is higher than the best bid price, we are willing to buy at the best bid
    price, expecting the prices to go higher. When we think the fair price is lower
    than the best ask price, we are willing to sell at the best ask price, expecting
    the prices to go lower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `bid_price` and `ask_price` variables we computed in the preceding
    code block a and pass them to the `OrderManager::moveOrders()` method to move
    the orders to the desired prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MarketMaker` trading algorithm does not do anything when there are trade
    events and simply logs the trade message it receives, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have one more task to complete the `MarketMaker` trading strategy – handling
    order updates for its orders, which will be addressed in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order updates in the MarketMaker algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The handling of order updates for the `MarketMaker` trading algorithm’s orders
    is simple; it simply forwards the `MEClientResponse` messages to the `order_manager_`
    member it uses to manage orders. This is achieved by calling the `OrderManager::onOrderUpdate()`
    method, which we implemented previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our implementation of the MM trading algorithm. In the next section,
    we will tackle the other type of trading strategy we will build in this book –
    a liquidity taking algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Opening and closing positions aggressively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a liquidity taking algorithm, whose behavior
    we covered in the first section of this chapter. This trading strategy does not
    send passive orders as the MM algorithm does; instead, it sends aggressive orders
    that trade against liquidity resting in the book. The source code for the `LiquidityTaker`
    algorithm is in the `Chapter10/trading/strategy/liquidity_taker.h` and `Chapter10/trading/strategy/liquidity_taker.cpp`
    source files. First, we will define the data members that make up the `LiquidityTaker`
    class in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data members in the LiquidityTaker algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LiquidityTaker` trading strategy has the same data members as the `MarketMaker`
    algorithm we built in the previous section. Before we describe the data members
    themselves, we will present the header files we need to include in the `liquidity_taker.h`
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the data members, which are the same ones that the MM algorithm
    has. The `LiquidityTaker` class has a `feature_engine_` member, which is a constant
    pointer to a `FeatureEngine` object, an `order_manager_` pointer to an `OrderManager`
    object, and a constant `ticker_cfg_` member, which is of type `TradeEngineCfgHashMap`.
    These members serve the same purpose as they did in the `MarketMaker` class; `feature_engine_`
    is used to extract the ratio of aggressive trade to top-of-book quantity. The
    `order_manager_` object is used to send and manage the orders for this trading
    strategy. Finally, the `ticker_cfg_` object holds the trading parameters that
    will be used by this algorithm to make trading decisions and send orders to the
    exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will see how to initialize a `LiquidityTaker` object.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the LiquidityTaker trading algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initialization for the `LiquidityTaker` class is identical to the initialization
    for the `MarketMaker` class. The constructor expects the following arguments –
    a `Logger` object, the `TradeEngine` object within which this algorithm runs,
    a `FeatureEngine` object to compute the feature, an `OrderManager` object used
    to manage orders for this trading strategy, and a `TradeEngineCfgHashMap` object
    containing the trading parameters for this strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor also overrides the callbacks in the `TradeEngine` object for
    order book updates, trade events, and updates to the algorithm’s orders like the
    `MarketMaker` algorithm. The `std::function` members, `algoOnOrderBookUpdate_`,
    `algoOnTradeUpdate_`, and `algoOnOrderUpdate_`, in `TradeEngine` are bound, respectively,
    to the `onOrderBookUpdate`, `onTradeUpdate`, and `onOrderUpdate` methods within
    `LiquidityTaker` using lambda methods, as shown here (and as we saw before):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss the code for handling trade events and order book updates
    due to events in the market data in this trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Handling trade events and order book updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the `MarketMaker` trading strategy, we saw that it only makes trading decisions
    on order book updates and does nothing on trade updates. The `LiquidityTaker`
    strategy does the opposite – it takes trading decisions in the `onTradeUpdate()`
    method and does nothing in the `onOrderBookUpdate()` method. We will start by
    looking at the implementation of the `LiquidityTaker::onTradeUpdate()` method
    first in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will fetch and save `BBO` using the `getBBO()` method in the `bbo` local
    variable. For this trading strategy, we will fetch the aggressive trade quantity
    ratio feature from the feature engine by calling the `FeatureEngine::getAggTradeQtyRatio()`
    method and saving it in the `agg_qty_ratio` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw before, we will check to make sure that `bid_price_`, `ask_price_`,
    and `agg_qty_ratio` are valid values before we decide to take an order action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the validity check passes, we first need to fetch the `clip_` member from
    the `ticker_cfg_` object for the `TickerId` of this trade message, as shown in
    the following code block, and save it in the `clip` local variable. Similarly,
    we will fetch and save the `threshold_` member from the `ticker_cfg_` configuration
    object for that `TickerId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To decide whether we send or adjust active orders for this algorithm, we will
    check whether the `agg_qty_ratio` exceeds the threshold we previously fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To send orders using the `OrderManager::moveOrders()` method, we will check
    whether the aggressive trade was a buy trade or a sell trade. If it was a buy
    trade, we will send an aggressive buy order to take liquidity at the best `BBO`
    `ask_price_` and no sell order by specifying a sell price of `Price_INVALID`.
    Conversely, if it was a sell trade and we wanted to send an aggressive sell order
    to take liquidity, we would specify a sell price to be `bid_price_` in the `BBO`
    object and no buy order by specifying a `Price_INVALID` buy price. Remember that
    this trading strategy takes a direction in the market by aggressively sending
    a buy or sell order one at a time, but not both like the `MarketMaker` algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before and as shown in the following code block, this `LiquidityTaker`
    trading strategy does not take any action on order updates in the `onOrderBookUpdate()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The next concluding section related to `LiquidityTaker` adds handling to the
    order updates for the strategy’s orders.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order updates in the LiquidityTaker algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LiquidityTaker::onOrderUpdate()` method, as shown in the following code
    block, has an identical implementation to the `MarketMaker::onOrderUpdate()` method
    and simply forwards the order update to the order manager using the `OrderManager::onOrderUpdate()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our implementation of the `LiquidityTaker` trading strategy.
    In the next section, we will shift the discussion to building the final form of
    our trading application so that we can build and run these actual trading strategies
    in our electronic trading ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Building the trade engine framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build the trade engine framework in the `TradeEngine`
    class. This framework ties all the different components we built together – the
    `OrderGateway`, `MarketDataConsumer`, `MarketOrderBook`, `FeatureEngine`, `PositionKeeper`,
    `OrderManager`, `RiskManager`, `MarketMaker`, and `LiquidityTaker` components.
    As a reminder of the trading engine component, we present a diagram of all the
    sub-components here. We have built all the sub-components; now, we will just build
    the trading engine framework in which these sub-components exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – The components of the trading engine in the client’s trading
    system](img/Figure_9.1_B19434.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – The components of the trading engine in the client’s trading system
  prefs: []
  type: TYPE_NORMAL
- en: We will start this section by defining the data members of our class, as usual.
    All the source code for the basic `TradeEngine` framework is in the `Chapter10/trading/strategy/trade_engine.h`
    and `Chapter10/trading/strategy/trade_engine.cpp` source files.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data members in the trade engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we define the data members in the `TradeEngine` class, we present the
    header files that the `trade_engine.h` source file needs to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TradeEngine` class needs the following basic data members:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a `client_id_` variable of type `ClientId` to represent the unique trading
    application instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a `ticker_order_book_` instance of type `MarketOrderBookHashMap`,
    which, as a reminder, is `std::array` of `MarketOrderBook` objects to represent
    a hash map from `TickerId` to `MarketOrderBook` for that instrument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have three lock-free queues to receive market data updates, send order requests,
    and receive order responses from the `MarketDataConsumer` and `OrderGateway` components.
    We receive market data updates using the `incoming_md_updates_` variable, which
    is a pointer to type `MEMarketUpdateLFQueue` (`LFQueue` of `MEMarketUpdate` messages).
    We send client order requests using the `outgoing_ogw_requests_` variable, which
    is a pointer to type `ClientRequestLFQueue` (`LFQueue` of `MEClientRequest` messages).
    We receive client order responses using the `incoming_ogw_responses_` variable,
    which is a pointer to type `ClientResponseLFQueue` (`LFQueue` of `MEClientResponse`
    messages).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the usual Boolean `run_` variable, which will control the execution
    of the main `TradeEngine` thread and is marked `volatile`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a `last_event_time_` variable of type `Nanos` to keep track of the time
    when the last message from the exchange was received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also have a `Logger` variable called `logger_` to create a log file
    for `TradeEngine` to use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need instances of each of our components from the previous chapter,
    namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable of type `FeatureEngine` called `feature_engine_` to compute complex
    feature values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `position_keeper_` variable of type `PositionKeeper` to track trading strategy
    positions and Profits and Losses (**PnLs**) money made or lost from our trading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of type `OrderManager` called `order_manager_`, which will be used
    by the trading strategies to send and manage live orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `RiskManager` object named `risk_manager_` to manage the trading strategy’s
    risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to a `MarketMaker` object called `mm_algo_`, which will be initialized
    if we configure `TradeEngine` to run a MM trading algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, a pointer to a `LiquidityTaker` object called `taker_algo_`, which
    will be initialized if we configure `TradeEngine` to run a liquidity taking trading
    strategy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add three `std::function` member variables, which `TradeEngine`
    will use to forward market data and order updates to the trading strategy that
    it instantiates. These are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`algoOnOrderBookUpdate_` `std::function` has the same signature as the `TradeEngine::onOrderBookUpdate()`
    method and is used to forward order book updates to the trading strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`algoOnTradeUpdate_` `std::function` has the same signature as the `TradeEngine::onTradeUpdate()`
    method and is used to forward trade events to the trading strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`algoOnOrderUpdate_` `std::function` has the same signature as the `TradeEngine::onOrderUpdate()`
    method and is used to forward order updates/responses to the trading strategy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To default-initialize these three `std::function` data members, we will create
    three new methods that simply log the parameters they are passed. They are shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss the code for some methods to initialize the `TradeEngine`
    class and its member variables.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the trade engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The constructor for the `TradeEngine` class requires a `ClientId` argument to
    identify the trading application used in the client order requests. It also needs
    pointers to the three `LFQueue` of types `ClientRequestLFQueue`, `ClientResponseLFQueue`,
    and `MEMarketUpdateLFQueue` to initialize the `outgoing_ogw_requests_`, `incoming_ogw_responses_`
    and `incoming_md_updates_` data members, respectively. It also needs an `algo_type`
    argument of type `AlgoType` to specify the type of trading strategy and a `ticker_cfg`
    argument of type reference-to `const TradeEngineCfgHashMap`, which contains the
    configuration parameters for the risk manager and the trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor also initializes the `Logger logger_` member variable with
    a log file and creates a `MarketOrderBook` component for each possible `TickerId`
    value, holding them in the `ticker_order_book_` container. It calls the `setTradeEngine()`
    method on each `MarketOrderBook` component so that callbacks from the book can
    be received in `TradeEngine`. We also initialize the data members corresponding
    to the trading sub-components – `feature_engine_`, `position_keeper_`, `order_manager_`,
    and `risk_manager_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the body of the constructor, in addition to the order books we previously
    created, we will initialize our new `std::function` members – `algoOnOrderBookUpdate_`,
    `algoOnTradeUpdate_`, and `algoOnOrderUpdate_` – with the defaults – the `defaultAlgoOnOrderBookUpdate()`,
    `defaultAlgoOnTradeUpdate()`, and `defaultAlgoOnOrderUpdate()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will initialize a trading strategy instance, either `mm_algo_`
    of type `MarketMaker` or `taker_algo_` of the `LiquidityTaker` type trading strategy.
    This initialization is shown as follows; remember that the `MarketMaker` or `LiquidityTaker`
    object will update/override the members – `algoOnOrderBookUpdate_`, `algoOnTradeUpdate_`,
    and `algoOnOrderUpdate_` – to point to their own method implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a `start()` method, as we saw for other components. Again, it sets
    the `run_` flag to `true` to allow the `run()` method to execute and creates and
    launches a thread to execute the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor does some simple de-initialization of the variables. First,
    it sets the `run_` flag to `false` and waits a little bit to let the main thread
    exit, then it proceeds to delete each `MarketOrderBook` instance and clear out
    the `ticker_order_book_` container, and finally, it resets the `LFQueue` pointers
    it holds. It also deletes the `mm_algo_` and `taker_algo_` members corresponding
    to the trading strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The familiar `stop()` method for this class first waits until all the incoming
    `MEClientResponse` and `MEMarketUpdate` messages are drained from the `incoming_ogw_responses_`
    and `incoming_md_updates_` `LFQueue` objects. Then, it resets the `run_` flag
    to stop the main `run()` thread and returns from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The next method we will add to this basic framework is meant to be used to send
    `MEClientRequest` messages to the exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Sending client requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sendClientRequest()` method in the trading engine framework is extremely
    simple. It receives a `MEClientRequest` object and simply writes it to the `outgoing_ogw_requests_`
    lock-free queue so that the `OrderGateway` component can pick this up and send
    it out to the trading exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection presents the main `run()` loop and shows how we handle incoming
    data from the exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Processing market data updates and client responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main thread for `TradeEngine` executes the `run()` method, which simply
    checks the incoming data `LFQueue` and reads and processes any available updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check and drain the `incoming_ogw_responses_` queue. For each `MEClientResponse`
    message we read here, we call the `TradeEngine::onOrderUpdate()` method and pass
    the response message from `OrderGateway` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We perform a similar task with the `incoming_md_updates_` lock-free queue.
    We read any available `MEMarketUpdate` messages and pass them to the correct `MarketOrderBook`
    instance by calling the `MarketOrderBook::onMarketUpdate()` method and passing
    the market update to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that in both of the preceding code blocks, when we successfully read and
    dispatch a market data update or an order response, we update the `last_event_time_`
    variable to track the time of the event, as we described earlier in this section.
    We will see some minor miscellaneous placeholder methods in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order book, trade, and order response updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TradeEngine::onOrderBookUpdate()` method performs a couple of tasks. First,
    it fetches `BBO` from `MarketOrderBook`, which it receives in the method’s arguments
    by calling the `MarketOrderBook::getBBO()` method. It provides the updated `BBO`
    to the `position_keeper_` and `feature_engine_` data members. For the `FeatureEngine`
    member, it calls the `FeatureEngine::onOrderBookUpdate()` method to notify the
    feature engine to update its feature values. The method also needs to call `algoOnOrderBookUpdate_()`
    so that the trading strategy can receive the notification about the order book
    update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TradeEngine::onTradeUpdate()` method that is called on trade events also
    performs a couple of tasks, which are like the ones in the `onOrderBookUpdate()`
    method we just saw. It passes the trade event to `FeatureEngine` by calling the
    `onTradeUpdate()` method so that the feature engine can update the features it
    computes. It also passes the trade event to the trading strategy by invoking the
    `algoOnTradeUpdate_()` `std::function` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `TradeEngine::onOrderUpdate()` does two things. It checks whether
    `MEClientResponse` corresponds to an execution (`ClientResponseType::FILLED`)
    and calls the `PositionKeeper::addFill()` method to update the position and PnLs.
    It also invokes the `algoOnOrderUpdate_()` `std::function` member so that the
    trading strategy can process the `MEClientResponse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can conclude the design and implementation of the `TradeEngine` framework
    in the next subsection by defining some miscellaneous methods we require.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some miscellaneous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section defines some miscellaneous methods for the `TradeEngine` class.
    The first method, `initLastEventTime()`, simply initializes the `last_event_time_`
    variable with the current time, which is obtained by calling the `getCurrentNanos()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `silentSeconds()` method returns the time elapsed (in seconds) since the
    last event was received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clientId()` method is a simple getter method that returns `client_id_`
    for this `TradeEngine` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the design and implementation of our trading engine framework.
    In the next section, we will build the main trading application binary.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the main trading application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will finally build the main trading
    application using all the components we built in this chapter, as well as the
    previous two chapters. First, we will discuss the implementation of the `trading_main`
    binary application, which combines the `MarketDataConsumer`, `OrderGateway`, `MarketOrderBook`,
    and `TradeEngine` components. After that, we will run our complete electronic
    trading ecosystem – the electronic trading exchange (the `exchange_main` application)
    from the *Communicating with Market Participants* chapter and a few instances
    of the market participants (the `trading_main` application), which we will build
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Building the main trading application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let us build the executable `trading_main` binary that will initialize
    and run all the components on the market participant’s trading system. The source
    code for this application is in the `Chapter10/trading/trading_main.cpp` source
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will include the necessary header files and create some basic variables
    to represent the different components we need. Specifically, we will have a `Logger`
    object pointer to be used for logging purposes, a `TradeEngine` object pointer
    for the basic trading engine framework, a `MarketDataConsumer` object pointer
    to consumer market data, and an `OrderGateway` object pointer to connect to and
    communicate with the exchange’s order server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, we start the entry point – the `main()` method. On the command line, we
    will accept arguments of the following form – `trading_main CLIENT_ID ALGO_TYPE
    [CLIP_1 THRESH_1 MAX_ORDER_SIZE_1 MAX_POS_1 MAX_LOSS_1] [CLIP_2 THRESH_2 MAX_ORDER_SIZE_2
    MAX_POS_2` `MAX_LOSS_2] …`
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument represents `ClientId` for this trading application instance.
    We will also accept `AlgoType` as the second parameter, and configurations for
    each trading algorithm instance for each `TickerId` as the remaining parameters.
    We will source the random number generator by calling the `srand()` method and
    passing it `client_id` for this specific instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will extract `AlgoType`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also initialize an object of type `TradeEngineCfgHashMap` from the
    remaining command-line arguments, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We will initialize the component variables we declared before – `Logger`, the
    `client_requests` `LFQueue`, the `client_responses` `LFQueue`, and the `market_updates`
    `LFQueue`. We will also define a `sleep_time` variable and set it to 20 microseconds.
    We will use this value to pause between consecutive order requests we send to
    the trading exchange’s `OrderGatewayServer` component, only in the random trading
    strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The first component we will initialize and start will be `TradeEngine`. We
    will pass `client_id`, `algo_type`, the strategy configurations in the `ticker_cfg`
    object, and the lock-free queues that `TradeEngine` needs in the constructor.
    We then call the `start()` method to get the main thread to start executing, as
    shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We perform a similar initialization of the `OrderGateway` component next by
    passing it the IP and port information of `exchange_main`’s `OrderGateway` server
    component. We also pass it the `client_requests` and `client_responses` `LFQueue`
    variables to consume `MEClientRequest` messages from and write `MEClientResponse`
    messages to, and then we use `start()` on the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we initialize and start the `MarketDataConsumer` component. It needs
    the IP and port information of the snapshot stream and the incremental stream
    on which the exchange’s `MarketDataPublisher` publishes market data. It also needs
    the `market_updates` `LFQueue` variable, which it will write decoded market data
    updates to. Finally, since all the components are ready, we will start `market_data_consumer`
    so that we can process any market data updates available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are almost ready to start sending orders to the exchange; we just need
    to perform a few more minor tasks first. First, the `main()` application will
    sleep briefly so that the threads we just created and started in each of our components
    can run for a few seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also initialize the first event time in `TradeEngine` by calling the
    `TradeEngine::initLastEventTime()` method. We intentionally delayed this member’s
    initialization until we were ready to start trading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If `AlgoType` is `AlgoType::RANDOM`, we will implement the trading logic right
    here, since it is super simple. First, we will check the `algo_type` variable,
    and branch if the `algo_type` argument specifies the random trading strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For this random trading algorithm, we will create a starting `OrderId` value
    unique to this trading application’s instance, using the `client_id` we received
    from the command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we send orders with a random price, quantity, and side in our current
    test setup, we will initialize a random reference price for each instrument, for
    which we will send orders. We will send orders with prices that are randomly distributed
    around this reference price value shortly. We do this purely so that different
    trading instruments have orders of slightly different and random prices. The random
    reference price for each instrument is held in the `ticker_base_price` variable.
    We will also create `std::vector` of `MEClientRequest` messages to store the order
    requests we send to the exchange. We will also send cancellations for some of
    these orders to exercise that functionality; hence, we will save them for when
    we try to cancel them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start sending some orders to the exchange, but first, we will initialize
    `TradeEngine`’s `last_event_time_` variable before we get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In the following loop, which executes 10,000 times, we will perform a few tasks,
    described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will pick a random `TickerId`, generate a random `Price` close to the `ticker_base_price`
    reference price value for that instrument, generate a random `Qty`, and generate
    a random `Side` for the order we will send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create an `MEClientRequest` message of type `ClientRequestType::NEW`
    with these attributes and pass it along to `TradeEngine` using the `sendClientRequest()`
    method call. We will pause for `sleep_time` (20 microseconds) after we send the
    order request, and we will also save the `MEClientRequest` message we just sent
    out in the `client_requests_vec` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'After the pause, we randomly pick a client request we sent from our container
    of client requests. We change the request type to `ClientRequestType::CANCEL`
    and send it through to `TradeEngine`. Then, we pause again and continue with the
    loop iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have sent out all of the order flow, we wait until we encounter a
    60-second period where no market update and no order response have been received
    by `TradeEngine`. This is a simple method of detecting when there is no market
    activity due to this client or any other trading client being connected to the
    exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'After a period of inactivity, this application exits. We first stop each of
    our components and pause for a brief period, before de-initializing and exiting
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the implementation of the `trading_main` application. We have
    included a build script in `Chapter10/scripts/build.sh`, which uses CMake and
    Ninja to build the libraries and the `trading_main` application, in addition to
    the `exchange_main` application that we built before. You will have to edit this
    script to point to the correct binaries on your system or switch to a different
    build system if you wish. The `scripts/build.sh` script is expected to be run
    from the `Chapter10` `root` directory, and it simply configures the build files,
    which in this case use `Ninja`, and cleans and rebuilds the build for the release
    and debug versions. We want to clarify that the choice of `Ninja` is completely
    arbitrary; we do not depend on anything that is `Ninja`-specific for our system
    to build and run. The build process generates binaries in the `Chapter10/cmake-build-release`
    and `Chapter10/cmake-build-debug` directories. The scripts to run the trading
    binaries use the binaries from the `Chapter10/cmake-build-release` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Running the final trading ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are finally at the point where we can run our entire electronic trading ecosystem,
    admittedly with a random trading strategy for now. We will present two scripts
    – one is `Chapter10/scripts/run_clients.sh`, which is configured to launch five
    instances of the `trading_main` application with client IDs of 1 to 5\. The second
    script is `Chapter10/scripts/run_exchange_and_clients.sh`, which first builds
    the libraries and the binaries using the `build.sh` script. Then, it launches
    the `exchange_main` application and proceeds to launch the trading client instances
    using the `run_clients.sh` script. Finally, it waits for all the trading client
    instances to finish execution, then terminates the exchange instance, and exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not look at the full `run_clients.sh` script, but an example of the
    first trading client that creates a `MarketMaker` algorithm is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this script, the 1 and 2 client IDs are MM trading algorithms, the 3 and
    4 client IDs are liquidity taking trading algorithms, and the last client ID,
    5, is a random trading algorithm. The random trading algorithm instance exists
    to simulate all trades made by the rest of the market participants for any reason.
    We do this because, in our ecosystem, we only run five trading clients (due to
    limited resources on our workstation). However, we encourage those interested
    among you with access to a lot more CPU resources to run as many trading clients
    as the system can handle. Remember that, in practice, the market is composed of
    orders and trades from thousands of market participants (if not more).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the output of the build process, which is generated by running
    the `scripts/run_exchange_and_clients.sh` script that internally calls the `scripts/build.sh`
    script to first build everything. Note that you need to be in the `Chapter10`
    root directory, as shown here, for this script to work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the output of the `exchange_main` application starting up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the output of the `trading_main` instances launching is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the output from the trading clients that shut down, and then
    the exchange exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is just the output displayed on screen. The interesting details
    are in the log files, which we will inspect and discuss in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: One other important note is that the `exchange_main` application has 10 threads,
    and each `trading_main` application has 8 threads. The `Logger` threads, which
    are many of these threads (five for `exchange_main` and four for `trading_main`),
    as well as the thread for the `main()` method (one each for `exchange_main` and
    `trading_main`), are not CPU-intensive and sleep for most of their runtime. The
    optimal setup would need a lot of cores for the entire ecosystem, which is common
    for production trading servers used for electronic trading. On these production-grade
    trading servers, we would be able to assign a CPU core to each of the remaining
    critical threads (four for `exchange_main` and three for `trading_main`). Since
    we are not sure which server we run on, we intentionally avoid setting affinity
    on those threads. If CPU and/or memory resources are limited on your system, our
    advice would be to reduce the number of trading clients launched in the `run_clients.sh`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the output of a run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this concluding section, we will look at the log files generated by running
    the `run_exchange_and_clients.sh` script. We know that the trading strategy we
    ran in this chapter is not interesting since it sends random orders to the exchange,
    but there are some important observations in these log files. Running the `run_exchange_and_clients.sh`
    script should generate log files similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: To understand and follow the events, our advice would be to correlate the log
    lines we generate from our calls to `Logger::log()` from various components and
    sub-components and then find them in the log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let us follow the path of a client sending an order to the exchange
    receiving the request, and generating a client response and a market update for
    that order request. Let us say, for this example, that we want to find the path
    followed by **OrderId=1445** and **MarketOrderId=53**; the path which this order
    follows is laid out as follows from the log files. Note that this is just an example
    that was generated from this specific run and might not be reproducible; the goal
    here is to understand how to track the events in our ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MEClientRequest` for the new order gets sent by the `TradeEngine` component
    for the `trading_main` instance with `ClientId=1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `OrderGateway` component picks up that request from the lock-free queue
    and sends it out on the TCP connection to the exchange, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `OrderServer` component inside the `exchange_main` application receives
    it from the `TCPServer` socket, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FifoSequencer` sub-component inside `OrderServer` sequences the client
    order request (`MEClientRequest`) based on the software receive time, and publishes
    it to the `MatchingEngine` lock-free queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `MatchingEngine` component finally receives this request from `LFQueue`
    and processes it, as displayed in the following log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In response to the order request it received, the `MatchingEngine` component
    generates a `MEClientResponse` message meant for the client to be published by
    the `OrderServer` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Corresponding to the new order that is added to the limit order book, `MatchingEngine`
    also generates an `MEMarketUpdate` message, as shown here. This is meant for the
    `MarketDataPublisher` component to publish and update the snapshot it maintains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `OrderServer` component picks up the `MEClientResponse` message from `LFQueue`,
    sending out an `OMClientResponse` message to the client on the correct TCP connection
    with the trading client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `MarketDataPublisher` component picks up the `MEMarketUpdate` message sent
    by `MatchingEngine`, sending out an `MDPMarketUpdate` message on the incremental
    market data multicast stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `SnapshotSynthesizer` sub-component inside the `MarketDataPublisher` component
    also receives this incremental `MEMarketUpdate` message, adding it to the snapshot
    it maintains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At some point, `SnapshotSynthesizer` publishes a snapshot of the `MDPMarketUpdate`
    messages on the snapshot multicast market data stream, including this market update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `OrderGateway` component inside the `trading_main` application receives
    the `OMClientResponse` response for the order request, from the TCPSocket that
    is connected to the exchange:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `MarketDataConsumer` component inside the `trading_main` application receives
    the `MDPMarketUpdate` message on the incremental market data stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `TradeEngine` component finally receives the `MEClientResponse` message
    from the `OrderGateway` component over the lock-free queue. It also forwards the
    `MEClientResponse` message via the `onOrderUpdate()` callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TradeEngine` also receives the `MEMarketUpdate` message, updates `MarketOrderBook`,
    and, in turn, receives `onOrderBookUpdate()` from the order book back in `TradeEngine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hopefully, this example provided you with good insight into what the different
    components in our trading ecosystem do. This should also serve as an example of
    how to investigate different events in the various applications, components, and
    sub-components of our electronic trading universe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us focus on the entries generated by our other components – `FeatureEngine`,
    `RiskManager`, `PositionKeeper`, and `OrderManager` – and the strategies – the
    `MarketMaker` and `LiquidityTaker` algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following log lines display the feature values that are updated by `FeatureEngine`
    as the order book updates or new trade events occur in market data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following log lines correspond to `PositionKeeper` being updated as `BBO`
    changes or additional executions are processed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Failures in `RiskManager`, due to several reasons we discussed in the *Building
    the C++ trading algorithm building blocks* chapter in the *Computing and managing
    risk* section, show up in the log files as something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Events in `OrderManager` appear as follows in the log files, as attempts are
    made to send order requests and responses are processed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Events in the `LiquidityTaker` trading strategy appear as shown here. These
    correspond to order book updates, trade events, and updates to strategy orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, events in the `MarketMaker` trading algorithm appear in the log
    files, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We encourage you to inspect the various log files in more detail to understand
    the processing that occurs in the different components and how our entire electronic
    trading ecosystem functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on using all the components we have built over the last
    two chapters and leveraging them to build our intelligent trading strategies –
    the MM trading strategy and the liquidity taking trading algorithm. We spent some
    time understanding the theory, motivation, and behavior of these two trading algorithms
    with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, we implemented the C++ MM trading algorithm, which
    manages passive orders, and the liquidity taking algorithm, which sends aggressive
    orders to the market.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we built the trading engine framework that ties together the market data
    consumer, the order gateway, the feature engine, the position keeper, the order
    manager, and the risk manager together with the two trading algorithms. This framework
    is what we use to join all these components together and facilitate the flow of
    incoming and outgoing data streams and trading intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we built the main trading application, `trading_main`, which is the
    complement of the `exchange_main` application on the market participant’s side.
    We then ran a few different instances of the trading application to run instances
    of the random trading algorithm, the MM algorithm, and the liquidity taking algorithm
    in our ecosystem. We inspected the log files generated by running our electronic
    trading ecosystem as the different trading client systems and strategies interacted
    with each other through the electronic exchange.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add an instrumentation system to measure the performance
    of our entire electronic trading ecosystem. We mentioned throughout this book
    that the first step to optimizing something is measuring the performance of a
    system and its components individually, and we will start by doing that in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Part 4:Analyzing and Improving Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will measure the performance of all the different C++ components
    in our trading ecosystem. We will analyze the latency profile of the different
    components individually, as well as measuring the performance of the end-to-end
    round-trip path. From there, we will discuss further optimization techniques and
    see the impact of our C++ optimization efforts. We will also discuss some future
    enhancements that can be made to our electronic trading ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 11, Adding Instrumentation and Measuring Performance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 12, Analyzing and Optimizing the Performance of Our C++ System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
