<html><head></head><body>
		<div><h1 id="_idParaDest-264"><a id="_idTextAnchor272"/><em class="italic">Chapter 12</em>: Layering Views and Implementing the HUD</h1>
			<p>In this chapter, we will get to see the real value of SFML Views. We will add a large array of SFML <code>Text</code> objects and manipulate them, like we did before in the Timber!!! project and the Pong project. What's new is that we will draw the HUD using a second View instance. This way, the HUD will stay neatly positioned over the top of the main game action, regardless of what the background, player, zombies, and other game objects are doing.</p>
			<p>Here is what we will do in this chapter:</p>
			<ul>
				<li>Add text and a background to the home/game over screen</li>
				<li>Add text to the level-up screen</li>
				<li>Create the second View</li>
				<li>Add a HUD</li>
			</ul>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor273"/>Adding all the Text and HUD objects</h1>
			<p>We will be manipulating a few strings in this chapter. We are doing this so we can format the HUD and the level-up screen with the necessary text.</p>
			<p>Add the extra <code>include</code> directive highlighted in the following code so that we can make some <code>sstream</code> objects to achieve this:</p>
			<pre><strong class="bold">#include &lt;sstream&gt;</strong>
#include &lt;SFML/Graphics.hpp&gt;
#include "ZombieArena.h"
#include "Player.h"
#include "TextureHolder.h"
#include "Bullet.h"
#include "Pickup.h"
using namespace sf;</pre>
			<p>Next, add this rather lengthy, but easily explainable, piece of code. To help identify where you should add the code, the new code is highlighted, and the existing code is not:</p>
			<pre>int score = 0;
int hiScore = 0;
<strong class="bold">// For the home/game over screen</strong>
<strong class="bold">Sprite spriteGameOver;</strong>
<strong class="bold">Texture textureGameOver = TextureHolder::GetTexture("graphics/background.png");</strong>
<strong class="bold">spriteGameOver.setTexture(textureGameOver);</strong>
<strong class="bold">spriteGameOver.setPosition(0, 0);</strong>
<strong class="bold">// Create a view for the HUD</strong>
<strong class="bold">View hudView(sf::FloatRect(0, 0, resolution.x, resolution.y));</strong>
<strong class="bold">// Create a sprite for the ammo icon</strong>
<strong class="bold">Sprite spriteAmmoIcon;</strong>
<strong class="bold">Texture textureAmmoIcon = TextureHolder::GetTexture(</strong>
<strong class="bold">           "graphics/ammo_icon.png");</strong>
<strong class="bold">spriteAmmoIcon.setTexture(textureAmmoIcon);</strong>
<strong class="bold">spriteAmmoIcon.setPosition(20, 980);</strong>
<strong class="bold">// Load the font</strong>
<strong class="bold">Font font;</strong>
<strong class="bold">font.loadFromFile("fonts/zombiecontrol.ttf");</strong>
<strong class="bold">// Paused</strong>
<strong class="bold">Text pausedText;</strong>
<strong class="bold">pausedText.setFont(font);</strong>
<strong class="bold">pausedText.setCharacterSize(155);</strong>
<strong class="bold">pausedText.setFillColor(Color::White);</strong>
<strong class="bold">pausedText.setPosition(400, 400);</strong>
<strong class="bold">pausedText.setString("Press Enter \nto continue");</strong>
<strong class="bold">// Game Over</strong>
<strong class="bold">Text gameOverText;</strong>
<strong class="bold">gameOverText.setFont(font);</strong>
<strong class="bold">gameOverText.setCharacterSize(125);</strong>
<strong class="bold">gameOverText.setFillColor(Color::White);</strong>
<strong class="bold">gameOverText.setPosition(250, 850);</strong>
<strong class="bold">gameOverText.setString("Press Enter to play");</strong>
<strong class="bold">// LEVELING up</strong>
<strong class="bold">Text levelUpText;</strong>
<strong class="bold">levelUpText.setFont(font);</strong>
<strong class="bold">levelUpText.setCharacterSize(80);</strong>
<strong class="bold">levelUpText.setFillColor(Color::White);</strong>
<strong class="bold">levelUpText.setPosition(150, 250);</strong>
<strong class="bold">std::stringstream levelUpStream;</strong>
<strong class="bold">levelUpStream &lt;&lt;</strong>
<strong class="bold">    "1- Increased rate of fire" &lt;&lt;</strong>
<strong class="bold">    "\n2- Increased clip size(next reload)" &lt;&lt;</strong>
<strong class="bold">    "\n3- Increased max health" &lt;&lt;</strong>
<strong class="bold">    "\n4- Increased run speed" &lt;&lt;</strong>
<strong class="bold">    "\n5- More and better health pickups" &lt;&lt;</strong>
<strong class="bold">    "\n6- More and better ammo pickups";</strong>
<strong class="bold">levelUpText.setString(levelUpStream.str());</strong>
<strong class="bold">// Ammo</strong>
<strong class="bold">Text ammoText;</strong>
<strong class="bold">ammoText.setFont(font);</strong>
<strong class="bold">ammoText.setCharacterSize(55);</strong>
<strong class="bold">ammoText.setFillColor(Color::White);</strong>
<strong class="bold">ammoText.setPosition(200, 980);</strong>
<strong class="bold">// Score</strong>
<strong class="bold">Text scoreText;</strong>
<strong class="bold">scoreText.setFont(font);</strong>
<strong class="bold">scoreText.setCharacterSize(55);</strong>
<strong class="bold">scoreText.setFillColor(Color::White);</strong>
<strong class="bold">scoreText.setPosition(20, 0);</strong>
<strong class="bold">// Hi Score</strong>
<strong class="bold">Text hiScoreText;</strong>
<strong class="bold">hiScoreText.setFont(font);</strong>
<strong class="bold">hiScoreText.setCharacterSize(55);</strong>
<strong class="bold">hiScoreText.setFillColor(Color::White);</strong>
<strong class="bold">hiScoreText.setPosition(1400, 0);</strong>
<strong class="bold">std::stringstream s;</strong>
<strong class="bold">s &lt;&lt; "Hi Score:" &lt;&lt; hiScore;</strong>
<strong class="bold">hiScoreText.setString(s.str());</strong>
<strong class="bold">// Zombies remaining</strong>
<strong class="bold">Text zombiesRemainingText;</strong>
<strong class="bold">zombiesRemainingText.setFont(font);</strong>
<strong class="bold">zombiesRemainingText.setCharacterSize(55);</strong>
<strong class="bold">zombiesRemainingText.setFillColor(Color::White);</strong>
<strong class="bold">zombiesRemainingText.setPosition(1500, 980);</strong>
<strong class="bold">zombiesRemainingText.setString("Zombies: 100");</strong>
<strong class="bold">// Wave number</strong>
<strong class="bold">int wave = 0;</strong>
<strong class="bold">Text waveNumberText;</strong>
<strong class="bold">waveNumberText.setFont(font);</strong>
<strong class="bold">waveNumberText.setCharacterSize(55);</strong>
<strong class="bold">waveNumberText.setFillColor(Color::White);</strong>
<strong class="bold">waveNumberText.setPosition(1250, 980);</strong>
<strong class="bold">waveNumberText.setString("Wave: 0");</strong>
<strong class="bold">// Health bar</strong>
<strong class="bold">RectangleShape healthBar;</strong>
<strong class="bold">healthBar.setFillColor(Color::Red);</strong>
<strong class="bold">healthBar.setPosition(450, 980);</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>The previous code is very simple and nothing new. It basically creates a whole bunch of SFML <code>Text</code> objects. It assigns their colors and sizes and then formats their positions using functions we have seen before.</p>
			<p>The most important thing to note is that we create another <code>View</code> object called <code>hudView</code> and initialize it to fit the resolution of the screen. </p>
			<p>As we have seen, the main <code>View</code> object scrolls around as it follows the player. In contrast, we will never move <code>hudView</code>. The result of this is that if we switch to this view before we draw the elements of the HUD, we will create the effect of allowing the game world to scroll by underneath while the player's HUD remains stationary. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As an analogy, you can think of laying a transparent sheet of plastic with some writing on it over a TV screen. The TV will carry on as normal with moving pictures, and the text on the plastic sheet will stay in the same place, regardless of what goes on underneath it. We will take this concept a step further in the next project when we split the screen and separate moving views of the game world.</p>
			<p>The next thing to notice, however, is that the hi-score is not set in any meaningful way. We will need to wait until the next chapter, when we investigate file I/O, to save and retrieve the high score.</p>
			<p>Another point worth noting is that we declare and initialize a <code>RectangleShape</code> called <code>healthBar</code>, which will be a visual representation of the player's remaining health. This will work in almost the same way that the time-bar worked in the Timber!!! project, except it will represent health instead of time.</p>
			<p>In the previous code, there is a new <code>Sprite</code> instance called <code>ammoIcon</code> that gives context to the bullet and clip statistics that we will draw next to it, at the bottom-left of the screen.</p>
			<p>Although there is nothing new or technical about the large amount of code that we just added, be sure to familiarize yourself with the details – especially the variable names – to make the rest of this chapter easier to follow.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor274"/>Updating the HUD</h1>
			<p>As you might expect, we will update the HUD variables in the update section of our code. We will not, however, do so every frame. The reason for this is that it is unnecessary, and it also slows our game loop down. </p>
			<p>As an example, consider the scenario when the player kills a zombie and gets some more points. It doesn't matter whether the <code>Text</code> object that holds the score is updated in one-thousandth, one-hundredth, or even one-tenth of a second. The player will discern no difference. This means there is no point rebuilding strings that we set for the <code>Text</code> objects every frame. </p>
			<p>Therefore, we can time when and how often we update the HUD. Add the following highlighted variables:</p>
			<pre>// Debug HUD
Text debugText;
debugText.setFont(font);
debugText.setCharacterSize(25);
debugText.setFillColor(Color::White);
debugText.setPosition(20, 220);
std::ostringstream ss;
<strong class="bold">// When did we last update the HUD?</strong>
<strong class="bold">int framesSinceLastHUDUpdate = 0;</strong>
<strong class="bold">// How often (in frames) should we update the HUD</strong>
<strong class="bold">int fpsMeasurementFrameInterval = 1000;</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>In the previous code, we have variables to track how many frames it has been since the last time the HUD was updated, and the interval, measured in frames, we would like to wait between HUD updates.</p>
			<p>Now, we can use these new variables and update the HUD each frame. We won't see all the HUD elements change, however, until we begin to manipulate the final variables, such as  <code>wave</code>, in the next chapter. </p>
			<p>Add the following highlighted code in the update section of the game loop, as follows:</p>
			<pre>    // Has the player touched ammo pickup
    if (player.getPosition().intersects
        (ammoPickup.getPosition()) &amp;&amp; ammoPickup.isSpawned())
    {
        bulletsSpare += ammoPickup.gotIt();
        
    }
<strong class="bold">    // size up the health bar</strong>
<strong class="bold">    healthBar.setSize(Vector2f(player.getHealth() * 3, 50));</strong>
<strong class="bold">    // Increment the number of frames since the previous update</strong>
<strong class="bold">    framesSinceLastHUDUpdate++;</strong>
<strong class="bold">    // re-calculate every fpsMeasurementFrameInterval frames</strong>
<strong class="bold">    if (framesSinceLastHUDUpdate &gt; fpsMeasurementFrameInterval)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Update game HUD text</strong>
<strong class="bold">        std::stringstream ssAmmo;</strong>
<strong class="bold">        std::stringstream ssScore;</strong>
<strong class="bold">        std::stringstream ssHiScore;</strong>
<strong class="bold">        std::stringstream ssWave;</strong>
<strong class="bold">        std::stringstream ssZombiesAlive;</strong>
<strong class="bold">        // Update the ammo text</strong>
<strong class="bold">        ssAmmo &lt;&lt; bulletsInClip &lt;&lt; "/" &lt;&lt; bulletsSpare;</strong>
<strong class="bold">        ammoText.setString(ssAmmo.str());</strong>
<strong class="bold">        // Update the score text</strong>
<strong class="bold">        ssScore &lt;&lt; "Score:" &lt;&lt; score;</strong>
<strong class="bold">        scoreText.setString(ssScore.str());</strong>
<strong class="bold">        // Update the high score text</strong>
<strong class="bold">        ssHiScore &lt;&lt; "Hi Score:" &lt;&lt; hiScore;</strong>
<strong class="bold">        hiScoreText.setString(ssHiScore.str());</strong>
<strong class="bold">        // Update the wave</strong>
<strong class="bold">        ssWave &lt;&lt; "Wave:" &lt;&lt; wave;</strong>
<strong class="bold">        waveNumberText.setString(ssWave.str());</strong>
<strong class="bold">        // Update the high score text</strong>
<strong class="bold">        ssZombiesAlive &lt;&lt; "Zombies:" &lt;&lt; numZombiesAlive;</strong>
<strong class="bold">        zombiesRemainingText.setString(ssZombiesAlive.str());</strong>
<strong class="bold">        framesSinceLastHUDUpdate = 0;</strong>
<strong class="bold">    }// End HUD update</strong>
}// End updating the scene</pre>
			<p>In the new code, we update the size of the <code>healthBar</code> sprite then increment the <code>framesSinceLastHUDUpdate</code> variable.</p>
			<p>Next, we start an <code>if</code> block that tests whether <code>framesSinceLastHUDUpdate</code> is greater than our preferred interval, which is stored in <code>fpsMeasurementFrameInterval</code>.</p>
			<p>Inside this <code>if</code> block is where all the action takes place. First, we declare a <code>stringstream</code> object for each string that we need to set to a <code>Text</code> object.</p>
			<p>Then, we use each of those <code>stringstream</code> objects in turn and use the <code>setString</code> function to set the result to the appropriate <code>Text</code> object.</p>
			<p>Finally, before the <code>if</code> block is exited, <code>framesSinceLastHUDUpdate</code> is set back to zero so that the count can begin again.</p>
			<p>Now, when we redraw the scene, the new values will appear in the player's HUD.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor275"/>Drawing the HUD, home, and level-up screens</h1>
			<p>All the code in the following three code blocks goes in the drawing phase of our game loop. All we need to do is draw the appropriate <code>Text</code> objects during the appropriate states, in the draw section of the main game loop.</p>
			<p>In the <code>PLAYING</code> state, add the following highlighted code:</p>
			<pre>    //Draw the crosshair
    window.draw(spriteCrosshair);
<strong class="bold">    // Switch to the HUD view</strong>
<strong class="bold">    window.setView(hudView);</strong>
<strong class="bold">    // Draw all the HUD elements</strong>
<strong class="bold">    window.draw(spriteAmmoIcon);</strong>
<strong class="bold">    window.draw(ammoText);</strong>
<strong class="bold">    window.draw(scoreText);</strong>
<strong class="bold">    window.draw(hiScoreText);</strong>
<strong class="bold">    window.draw(healthBar);</strong>
<strong class="bold">    window.draw(waveNumberText);</strong>
<strong class="bold">    window.draw(zombiesRemainingText);</strong>
}
if (state == State::LEVELING_UP)
{
}</pre>
			<p>The vital thing to notice in the preceding block of code is that we switch views to the HUD view. This causes everything to be drawn at the precise screen positions we gave each of the elements of the HUD. They will never move.</p>
			<p>In the <code>LEVELING_UP</code> state, add the following highlighted code:</p>
			<pre>if (state == State::LEVELING_UP)
{
<strong class="bold">    window.draw(spriteGameOver);</strong>
<strong class="bold">    window.draw(levelUpText);</strong>
}</pre>
			<p>In the <code>PAUSED</code> state, add the following highlighted code:</p>
			<pre>if (state == State::PAUSED)
{
<strong class="bold">    window.draw(pausedText);</strong>
}</pre>
			<p>In the <code>GAME_OVER</code> state, add the following highlighted code:</p>
			<pre>if (state == State::GAME_OVER)
{
<strong class="bold">    window.draw(spriteGameOver);</strong>
<strong class="bold">    window.draw(gameOverText);</strong>
<strong class="bold">    window.draw(scoreText);</strong>
<strong class="bold">    window.draw(hiScoreText);</strong>
}</pre>
			<p>Now, we can run the game and see our HUD update during gameplay:</p>
			<div><div><img src="img/B14278_12_01.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot shows the high score and score on the home/game over screen:</p>
			<div><div><img src="img/B14278_12_02.jpg" alt=""/>
				</div>
			</div>
			<p>Next, we see text that tells the player what their level-up options are, although these options don't do anything yet:</p>
			<div><div><img src="img/B14278_12_03.jpg" alt=""/>
				</div>
			</div>
			<p>Here, we can see a helpful message on the pause screen:</p>
			<div><div><img src="img/B14278_12_04.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Tip</p>
			<p class="callout">SFML Views are more powerful than this simple HUD can demonstrate. For an insight into the potential of the SFML <code>View</code> class and how easy they are to use, look at the SFML website's tutorial on <code>View</code> at <a href="https://www.sfml-dev.org/tutorials/2.5/graphics-view.php">https://www.sfml-dev.org/tutorials/2.5/graphics-view.php</a>.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor276"/>Summary</h1>
			<p>This was a quick and simple chapter. We looked at how to display the values that are held by variables of different types using <code>sstream</code> and then learned how to draw them over the top of the main game action using a second SFML <code>View</code> object.</p>
			<p>We are nearly done with Zombie Arena now. All the screenshots in this chapter show a small arena that doesn't take advantage of the full monitor. </p>
			<p>In the next chapter, the final one for this project, we will put in some finishing touches, such as leveling up, sound effects, and saving the high score. The arena can then grow to the same size as the monitor and far beyond.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor277"/>FAQ</h1>
			<p>Here is a question that might be on your mind:</p>
			<p>Q) Where can I see more of the power of the <code>View</code> class in action?</p>
			<p>A) Take a look at the enhanced edition of the Zombie Arena game, in the download bundle. You can use the cursor keyboard keys to spin and zoom the game. Warning! Spinning the scene makes the controls awkward, but you get to see some of the things that can be done with the View class:</p>
			<div><div><img src="img/B14278_12_05.jpg" alt=""/>
				</div>
			</div>
			<p>The <a id="_idTextAnchor278"/>zoom and rotate functionality were achieved with just a few lines of code in the input handling section of the main game loop. You can see the code in the <code>Zombie Arena Enhanced Version</code> folder of the download bundle or run the enhanced version from the <code>Runnable Games/Zombie Arena</code> folder.</p>
		</div>
	</body></html>