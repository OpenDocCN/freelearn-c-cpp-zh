<html><head></head><body>
		<div id="_idContainer080">
			<h1 id="_idParaDest-264"><a id="_idTextAnchor272"/><em class="italic">Chapter 12</em>: Layering Views and Implementing the HUD</h1>
			<p>In this chapter, we will get to see the real value of SFML Views. We will add a large array of SFML <strong class="source-inline">Text</strong> objects and manipulate them, like we did before in the Timber!!! project and the Pong project. What's new is that we will draw the HUD using a second View instance. This way, the HUD will stay neatly positioned over the top of the main game action, regardless of what the background, player, zombies, and other game objects are doing.</p>
			<p>Here is what we will do in this chapter:</p>
			<ul>
				<li>Add text and a background to the home/game over screen</li>
				<li>Add text to the level-up screen</li>
				<li>Create the second View</li>
				<li>Add a HUD</li>
			</ul>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor273"/>Adding all the Text and HUD objects</h1>
			<p>We will be manipulating a few strings in this chapter. We are doing this so we can format the HUD and the level-up screen with the necessary text.</p>
			<p>Add the extra <strong class="source-inline">include</strong> directive highlighted in the following code so that we can make some <strong class="source-inline">sstream</strong> objects to achieve this:</p>
			<p class="source-code"><strong class="bold">#include &lt;sstream&gt;</strong></p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "ZombieArena.h"</p>
			<p class="source-code">#include "Player.h"</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include "Bullet.h"</p>
			<p class="source-code">#include "Pickup.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p>Next, add this rather lengthy, but easily explainable, piece of code. To help identify where you should add the code, the new code is highlighted, and the existing code is not:</p>
			<p class="source-code">int score = 0;</p>
			<p class="source-code">int hiScore = 0;</p>
			<p class="source-code"><strong class="bold">// For the home/game over screen</strong></p>
			<p class="source-code"><strong class="bold">Sprite spriteGameOver;</strong></p>
			<p class="source-code"><strong class="bold">Texture textureGameOver = TextureHolder::GetTexture("graphics/background.png");</strong></p>
			<p class="source-code"><strong class="bold">spriteGameOver.setTexture(textureGameOver);</strong></p>
			<p class="source-code"><strong class="bold">spriteGameOver.setPosition(0, 0);</strong></p>
			<p class="source-code"><strong class="bold">// Create a view for the HUD</strong></p>
			<p class="source-code"><strong class="bold">View hudView(sf::FloatRect(0, 0, resolution.x, resolution.y));</strong></p>
			<p class="source-code"><strong class="bold">// Create a sprite for the ammo icon</strong></p>
			<p class="source-code"><strong class="bold">Sprite spriteAmmoIcon;</strong></p>
			<p class="source-code"><strong class="bold">Texture textureAmmoIcon = TextureHolder::GetTexture(</strong></p>
			<p class="source-code"><strong class="bold">           "graphics/ammo_icon.png");</strong></p>
			<p class="source-code"><strong class="bold">spriteAmmoIcon.setTexture(textureAmmoIcon);</strong></p>
			<p class="source-code"><strong class="bold">spriteAmmoIcon.setPosition(20, 980);</strong></p>
			<p class="source-code"><strong class="bold">// Load the font</strong></p>
			<p class="source-code"><strong class="bold">Font font;</strong></p>
			<p class="source-code"><strong class="bold">font.loadFromFile("fonts/zombiecontrol.ttf");</strong></p>
			<p class="source-code"><strong class="bold">// Paused</strong></p>
			<p class="source-code"><strong class="bold">Text pausedText;</strong></p>
			<p class="source-code"><strong class="bold">pausedText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">pausedText.setCharacterSize(155);</strong></p>
			<p class="source-code"><strong class="bold">pausedText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">pausedText.setPosition(400, 400);</strong></p>
			<p class="source-code"><strong class="bold">pausedText.setString("Press Enter \nto continue");</strong></p>
			<p class="source-code"><strong class="bold">// Game Over</strong></p>
			<p class="source-code"><strong class="bold">Text gameOverText;</strong></p>
			<p class="source-code"><strong class="bold">gameOverText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">gameOverText.setCharacterSize(125);</strong></p>
			<p class="source-code"><strong class="bold">gameOverText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">gameOverText.setPosition(250, 850);</strong></p>
			<p class="source-code"><strong class="bold">gameOverText.setString("Press Enter to play");</strong></p>
			<p class="source-code"><strong class="bold">// LEVELING up</strong></p>
			<p class="source-code"><strong class="bold">Text levelUpText;</strong></p>
			<p class="source-code"><strong class="bold">levelUpText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">levelUpText.setCharacterSize(80);</strong></p>
			<p class="source-code"><strong class="bold">levelUpText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">levelUpText.setPosition(150, 250);</strong></p>
			<p class="source-code"><strong class="bold">std::stringstream levelUpStream;</strong></p>
			<p class="source-code"><strong class="bold">levelUpStream &lt;&lt;</strong></p>
			<p class="source-code"><strong class="bold">    "1- Increased rate of fire" &lt;&lt;</strong></p>
			<p class="source-code"><strong class="bold">    "\n2- Increased clip size(next reload)" &lt;&lt;</strong></p>
			<p class="source-code"><strong class="bold">    "\n3- Increased max health" &lt;&lt;</strong></p>
			<p class="source-code"><strong class="bold">    "\n4- Increased run speed" &lt;&lt;</strong></p>
			<p class="source-code"><strong class="bold">    "\n5- More and better health pickups" &lt;&lt;</strong></p>
			<p class="source-code"><strong class="bold">    "\n6- More and better ammo pickups";</strong></p>
			<p class="source-code"><strong class="bold">levelUpText.setString(levelUpStream.str());</strong></p>
			<p class="source-code"><strong class="bold">// Ammo</strong></p>
			<p class="source-code"><strong class="bold">Text ammoText;</strong></p>
			<p class="source-code"><strong class="bold">ammoText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">ammoText.setCharacterSize(55);</strong></p>
			<p class="source-code"><strong class="bold">ammoText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">ammoText.setPosition(200, 980);</strong></p>
			<p class="source-code"><strong class="bold">// Score</strong></p>
			<p class="source-code"><strong class="bold">Text scoreText;</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setCharacterSize(55);</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setPosition(20, 0);</strong></p>
			<p class="source-code"><strong class="bold">// Hi Score</strong></p>
			<p class="source-code"><strong class="bold">Text hiScoreText;</strong></p>
			<p class="source-code"><strong class="bold">hiScoreText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">hiScoreText.setCharacterSize(55);</strong></p>
			<p class="source-code"><strong class="bold">hiScoreText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">hiScoreText.setPosition(1400, 0);</strong></p>
			<p class="source-code"><strong class="bold">std::stringstream s;</strong></p>
			<p class="source-code"><strong class="bold">s &lt;&lt; "Hi Score:" &lt;&lt; hiScore;</strong></p>
			<p class="source-code"><strong class="bold">hiScoreText.setString(s.str());</strong></p>
			<p class="source-code"><strong class="bold">// Zombies remaining</strong></p>
			<p class="source-code"><strong class="bold">Text zombiesRemainingText;</strong></p>
			<p class="source-code"><strong class="bold">zombiesRemainingText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">zombiesRemainingText.setCharacterSize(55);</strong></p>
			<p class="source-code"><strong class="bold">zombiesRemainingText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">zombiesRemainingText.setPosition(1500, 980);</strong></p>
			<p class="source-code"><strong class="bold">zombiesRemainingText.setString("Zombies: 100");</strong></p>
			<p class="source-code"><strong class="bold">// Wave number</strong></p>
			<p class="source-code"><strong class="bold">int wave = 0;</strong></p>
			<p class="source-code"><strong class="bold">Text waveNumberText;</strong></p>
			<p class="source-code"><strong class="bold">waveNumberText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">waveNumberText.setCharacterSize(55);</strong></p>
			<p class="source-code"><strong class="bold">waveNumberText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">waveNumberText.setPosition(1250, 980);</strong></p>
			<p class="source-code"><strong class="bold">waveNumberText.setString("Wave: 0");</strong></p>
			<p class="source-code"><strong class="bold">// Health bar</strong></p>
			<p class="source-code"><strong class="bold">RectangleShape healthBar;</strong></p>
			<p class="source-code"><strong class="bold">healthBar.setFillColor(Color::Red);</strong></p>
			<p class="source-code"><strong class="bold">healthBar.setPosition(450, 980);</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>The previous code is very simple and nothing new. It basically creates a whole bunch of SFML <strong class="source-inline">Text</strong> objects. It assigns their colors and sizes and then formats their positions using functions we have seen before.</p>
			<p>The most important thing to note is that we create another <strong class="source-inline">View</strong> object called <strong class="source-inline">hudView</strong> and initialize it to fit the resolution of the screen. </p>
			<p>As we have seen, the main <strong class="source-inline">View</strong> object scrolls around as it follows the player. In contrast, we will never move <strong class="source-inline">hudView</strong>. The result of this is that if we switch to this view before we draw the elements of the HUD, we will create the effect of allowing the game world to scroll by underneath while the player's HUD remains stationary. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As an analogy, you can think of laying a transparent sheet of plastic with some writing on it over a TV screen. The TV will carry on as normal with moving pictures, and the text on the plastic sheet will stay in the same place, regardless of what goes on underneath it. We will take this concept a step further in the next project when we split the screen and separate moving views of the game world.</p>
			<p>The next thing to notice, however, is that the hi-score is not set in any meaningful way. We will need to wait until the next chapter, when we investigate file I/O, to save and retrieve the high score.</p>
			<p>Another point worth noting is that we declare and initialize a <strong class="source-inline">RectangleShape</strong> called <strong class="source-inline">healthBar</strong>, which will be a visual representation of the player's remaining health. This will work in almost the same way that the time-bar worked in the Timber!!! project, except it will represent health instead of time.</p>
			<p>In the previous code, there is a new <strong class="source-inline">Sprite</strong> instance called <strong class="source-inline">ammoIcon</strong> that gives context to the bullet and clip statistics that we will draw next to it, at the bottom-left of the screen.</p>
			<p>Although there is nothing new or technical about the large amount of code that we just added, be sure to familiarize yourself with the details – especially the variable names – to make the rest of this chapter easier to follow.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor274"/>Updating the HUD</h1>
			<p>As you might expect, we will update the HUD variables in the update section of our code. We will not, however, do so every frame. The reason for this is that it is unnecessary, and it also slows our game loop down. </p>
			<p>As an example, consider the scenario when the player kills a zombie and gets some more points. It doesn't matter whether the <strong class="source-inline">Text</strong> object that holds the score is updated in one-thousandth, one-hundredth, or even one-tenth of a second. The player will discern no difference. This means there is no point rebuilding strings that we set for the <strong class="source-inline">Text</strong> objects every frame. </p>
			<p>Therefore, we can time when and how often we update the HUD. Add the following highlighted variables:</p>
			<p class="source-code">// Debug HUD</p>
			<p class="source-code">Text debugText;</p>
			<p class="source-code">debugText.setFont(font);</p>
			<p class="source-code">debugText.setCharacterSize(25);</p>
			<p class="source-code">debugText.setFillColor(Color::White);</p>
			<p class="source-code">debugText.setPosition(20, 220);</p>
			<p class="source-code">std::ostringstream ss;</p>
			<p class="source-code"><strong class="bold">// When did we last update the HUD?</strong></p>
			<p class="source-code"><strong class="bold">int framesSinceLastHUDUpdate = 0;</strong></p>
			<p class="source-code"><strong class="bold">// How often (in frames) should we update the HUD</strong></p>
			<p class="source-code"><strong class="bold">int fpsMeasurementFrameInterval = 1000;</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>In the previous code, we have variables to track how many frames it has been since the last time the HUD was updated, and the interval, measured in frames, we would like to wait between HUD updates.</p>
			<p>Now, we can use these new variables and update the HUD each frame. We won't see all the HUD elements change, however, until we begin to manipulate the final variables, such as  <strong class="source-inline">wave</strong>, in the next chapter. </p>
			<p>Add the following highlighted code in the update section of the game loop, as follows:</p>
			<p class="source-code">    // Has the player touched ammo pickup</p>
			<p class="source-code">    if (player.getPosition().intersects</p>
			<p class="source-code">        (ammoPickup.getPosition()) &amp;&amp; ammoPickup.isSpawned())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        bulletsSpare += ammoPickup.gotIt();</p>
			<p class="source-code">        </p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // size up the health bar</strong></p>
			<p class="source-code"><strong class="bold">    healthBar.setSize(Vector2f(player.getHealth() * 3, 50));</strong></p>
			<p class="source-code"><strong class="bold">    // Increment the number of frames since the previous update</strong></p>
			<p class="source-code"><strong class="bold">    framesSinceLastHUDUpdate++;</strong></p>
			<p class="source-code"><strong class="bold">    // re-calculate every fpsMeasurementFrameInterval frames</strong></p>
			<p class="source-code"><strong class="bold">    if (framesSinceLastHUDUpdate &gt; fpsMeasurementFrameInterval)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Update game HUD text</strong></p>
			<p class="source-code"><strong class="bold">        std::stringstream ssAmmo;</strong></p>
			<p class="source-code"><strong class="bold">        std::stringstream ssScore;</strong></p>
			<p class="source-code"><strong class="bold">        std::stringstream ssHiScore;</strong></p>
			<p class="source-code"><strong class="bold">        std::stringstream ssWave;</strong></p>
			<p class="source-code"><strong class="bold">        std::stringstream ssZombiesAlive;</strong></p>
			<p class="source-code"><strong class="bold">        // Update the ammo text</strong></p>
			<p class="source-code"><strong class="bold">        ssAmmo &lt;&lt; bulletsInClip &lt;&lt; "/" &lt;&lt; bulletsSpare;</strong></p>
			<p class="source-code"><strong class="bold">        ammoText.setString(ssAmmo.str());</strong></p>
			<p class="source-code"><strong class="bold">        // Update the score text</strong></p>
			<p class="source-code"><strong class="bold">        ssScore &lt;&lt; "Score:" &lt;&lt; score;</strong></p>
			<p class="source-code"><strong class="bold">        scoreText.setString(ssScore.str());</strong></p>
			<p class="source-code"><strong class="bold">        // Update the high score text</strong></p>
			<p class="source-code"><strong class="bold">        ssHiScore &lt;&lt; "Hi Score:" &lt;&lt; hiScore;</strong></p>
			<p class="source-code"><strong class="bold">        hiScoreText.setString(ssHiScore.str());</strong></p>
			<p class="source-code"><strong class="bold">        // Update the wave</strong></p>
			<p class="source-code"><strong class="bold">        ssWave &lt;&lt; "Wave:" &lt;&lt; wave;</strong></p>
			<p class="source-code"><strong class="bold">        waveNumberText.setString(ssWave.str());</strong></p>
			<p class="source-code"><strong class="bold">        // Update the high score text</strong></p>
			<p class="source-code"><strong class="bold">        ssZombiesAlive &lt;&lt; "Zombies:" &lt;&lt; numZombiesAlive;</strong></p>
			<p class="source-code"><strong class="bold">        zombiesRemainingText.setString(ssZombiesAlive.str());</strong></p>
			<p class="source-code"><strong class="bold">        framesSinceLastHUDUpdate = 0;</strong></p>
			<p class="source-code"><strong class="bold">    }// End HUD update</strong></p>
			<p class="source-code">}// End updating the scene</p>
			<p>In the new code, we update the size of the <strong class="source-inline">healthBar</strong> sprite then increment the <strong class="source-inline">framesSinceLastHUDUpdate</strong> variable.</p>
			<p>Next, we start an <strong class="source-inline">if</strong> block that tests whether <strong class="source-inline">framesSinceLastHUDUpdate</strong> is greater than our preferred interval, which is stored in <strong class="source-inline">fpsMeasurementFrameInterval</strong>.</p>
			<p>Inside this <strong class="source-inline">if</strong> block is where all the action takes place. First, we declare a <strong class="source-inline">stringstream</strong> object for each string that we need to set to a <strong class="source-inline">Text</strong> object.</p>
			<p>Then, we use each of those <strong class="source-inline">stringstream</strong> objects in turn and use the <strong class="source-inline">setString</strong> function to set the result to the appropriate <strong class="source-inline">Text</strong> object.</p>
			<p>Finally, before the <strong class="source-inline">if</strong> block is exited, <strong class="source-inline">framesSinceLastHUDUpdate</strong> is set back to zero so that the count can begin again.</p>
			<p>Now, when we redraw the scene, the new values will appear in the player's HUD.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor275"/>Drawing the HUD, home, and level-up screens</h1>
			<p>All the code in the following three code blocks goes in the drawing phase of our game loop. All we need to do is draw the appropriate <strong class="source-inline">Text</strong> objects during the appropriate states, in the draw section of the main game loop.</p>
			<p>In the <strong class="source-inline">PLAYING</strong> state, add the following highlighted code:</p>
			<p class="source-code">    //Draw the crosshair</p>
			<p class="source-code">    window.draw(spriteCrosshair);</p>
			<p class="source-code"><strong class="bold">    // Switch to the HUD view</strong></p>
			<p class="source-code"><strong class="bold">    window.setView(hudView);</strong></p>
			<p class="source-code"><strong class="bold">    // Draw all the HUD elements</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(spriteAmmoIcon);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(ammoText);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(scoreText);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(hiScoreText);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(healthBar);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(waveNumberText);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(zombiesRemainingText);</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">if (state == State::LEVELING_UP)</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>The vital thing to notice in the preceding block of code is that we switch views to the HUD view. This causes everything to be drawn at the precise screen positions we gave each of the elements of the HUD. They will never move.</p>
			<p>In the <strong class="source-inline">LEVELING_UP</strong> state, add the following highlighted code:</p>
			<p class="source-code">if (state == State::LEVELING_UP)</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    window.draw(spriteGameOver);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(levelUpText);</strong></p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">PAUSED</strong> state, add the following highlighted code:</p>
			<p class="source-code">if (state == State::PAUSED)</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    window.draw(pausedText);</strong></p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">GAME_OVER</strong> state, add the following highlighted code:</p>
			<p class="source-code">if (state == State::GAME_OVER)</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    window.draw(spriteGameOver);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(gameOverText);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(scoreText);</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(hiScoreText);</strong></p>
			<p class="source-code">}</p>
			<p>Now, we can run the game and see our HUD update during gameplay:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B14278_12_01.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot shows the high score and score on the home/game over screen:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B14278_12_02.jpg" alt=""/>
				</div>
			</div>
			<p>Next, we see text that tells the player what their level-up options are, although these options don't do anything yet:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B14278_12_03.jpg" alt=""/>
				</div>
			</div>
			<p>Here, we can see a helpful message on the pause screen:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B14278_12_04.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Tip</p>
			<p class="callout">SFML Views are more powerful than this simple HUD can demonstrate. For an insight into the potential of the SFML <strong class="source-inline">View</strong> class and how easy they are to use, look at the SFML website's tutorial on <strong class="source-inline">View</strong> at <a href="https://www.sfml-dev.org/tutorials/2.5/graphics-view.php">https://www.sfml-dev.org/tutorials/2.5/graphics-view.php</a>.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor276"/>Summary</h1>
			<p>This was a quick and simple chapter. We looked at how to display the values that are held by variables of different types using <strong class="source-inline">sstream</strong> and then learned how to draw them over the top of the main game action using a second SFML <strong class="source-inline">View</strong> object.</p>
			<p>We are nearly done with Zombie Arena now. All the screenshots in this chapter show a small arena that doesn't take advantage of the full monitor. </p>
			<p>In the next chapter, the final one for this project, we will put in some finishing touches, such as leveling up, sound effects, and saving the high score. The arena can then grow to the same size as the monitor and far beyond.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor277"/>FAQ</h1>
			<p>Here is a question that might be on your mind:</p>
			<p>Q) Where can I see more of the power of the <strong class="source-inline">View</strong> class in action?</p>
			<p>A) Take a look at the enhanced edition of the Zombie Arena game, in the download bundle. You can use the cursor keyboard keys to spin and zoom the game. Warning! Spinning the scene makes the controls awkward, but you get to see some of the things that can be done with the View class:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B14278_12_05.jpg" alt=""/>
				</div>
			</div>
			<p>The <a id="_idTextAnchor278"/>zoom and rotate functionality were achieved with just a few lines of code in the input handling section of the main game loop. You can see the code in the <strong class="source-inline">Zombie Arena Enhanced Version</strong> folder of the download bundle or run the enhanced version from the <strong class="source-inline">Runnable Games/Zombie Arena</strong> folder.</p>
		</div>
	</body></html>