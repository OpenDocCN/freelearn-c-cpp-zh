["```cpp\n#pragma once\n#include <stdlib.h>\n#include <math.h>\n#include \"LoadObj.h\"\n#include \"glut.h\"\n```", "```cpp\nclass Model\n{\n\n  public:\n\n  struct Color\n  {\n    Color()\n    {\n      r = 0.0f;\n      g = 0.0f;\n      b = 0.0f;\n    }\n    Color(const float p_r, const float p_g, const float p_b)\n    {\n      r = p_r;\n      g = p_g;\n      b = p_b;\n    }\n    float r;\n    float g;\n    float b;\n  };\n};\n```", "```cpp\n Model(const char* p_filepath, const Color p_color);\n ~Model();\n void Update(const float p_deltaTime);\n void Render();\n void SetPosition(const float p_x, const float p_y, const float p_z);\n void SetPosition(const Vec3 p_position);\n const Vec3 GetPosition() const;\n void SetHeading(const float p_x, const float p_y, const float p_z);\n void SetHeading(const Vec3 p_heading);\n const Vec3 GetHeading() const;\n void SetColor(const float p_red, const float p_green, const float p_blue);\n void SetColor(const Color p_color);\n void SetBaseRotation(const float p_x, const float p_y, const float p_z);\n void SetBaseRotation(const Vec3 p_rotation);\n const Vec3 GetBaseRotation() const;\n void SetHeadingRotation(const float p_x, const float p_y, const float p_z);\n void SetHeadingRotation(const Vec3 p_rotation);\n const Vec3 GetHeadingRotation() const;\n void SetVelocity(const float p_velocity);\n const float GetVelocity() const;\n const bool IsShip();\n void IsShip(const bool p_IsShip);\n const bool IsVisible() const { return m_isVisible; };\n void IsVisible(const bool p_isVisible) { m_isVisible = p_isVisible; };\n};\n```", "```cpp\nm_vertices;\n std::vectorm_normals;\n Vec3 m_position;\n Vec3 m_heading;\n Vec3 m_baseRotation;\n Vec3 m_headingRotation;\n Color m_color;\n Primitive m_primitive;\n float m_velocity;\n\n bool m_isVisible;\n bool m_loaded;\n bool m_IsShip;\n\n float m_radius;\n bool m_collideable;\n```", "```cpp\n#include \"Model.h\"\n\nModel::Model(const char* p_filepath, const Color p_color)\n{\n m_filepath = p_filepath;\n m_loaded = LoadObj(m_filepath, m_vertices, m_normals, m_primitive);\n SetPosition(0.0f, 0.0f, 0.0f);\n SetHeading(0.0f, 0.0f, 0.0f);\n SetHeadingRotation(0.0f, 0.0f, 0.0f);\n SetBaseRotation(0.0f, 0.0f, 0.0f);\n IsShip(false);\n SetVelocity(0.0f);\n SetColor(p_color.r, p_color.g, p_color.b);\n SetRadius(1.0f);\n IsCollideable(true);\n IsVisible(true);\n}\nModel::~Model()\n{\n m_vertices.clear();\n m_normals.clear();\n}\n```", "```cpp\nfloat Deg2Rad(const float p_degrees)\n{\n  return p_degrees * (M_PI / 180.0f);\n\n}\n```", "```cpp\nvoid Model::Update(const float p_deltaTime)\n{\n Vec3 targetRotation = GetHeadingRotation();\n Vec3 currentPosition = GetPosition();\n Vec3 targetPosition = GetPosition();\n\n float distance = m_velocity * p_deltaTime;\n Vec3 deltaPosition;\n\n deltaPosition.y = cos(Deg2Rad(targetRotation.z)) * distance;\n deltaPosition.x = -sin(Deg2Rad(targetRotation.z)) * distance;\n deltaPosition.z = sin(Deg2Rad(targetRotation.x)) * distance;\n\n targetPosition.x += deltaPosition.x;\n targetPosition.y += deltaPosition.y;\n targetPosition.z += deltaPosition.z;\n SetPosition(targetPosition);\n}\n```", "```cpp\nvoid Model::Render()\n{\n if (IsVisible())\n {\n  glRotatef(-m_baseRotation.x, 1.0f, 0.0f, 0.0f);\n  glRotatef(-m_baseRotation.y, 0.0f, 1.0f, 0.0f);\n  glRotatef(-m_baseRotation.z, 0.0f, 0.0f, 1.0f);\n\n  Vec3 targetRotation = GetHeadingRotation();\n  Vec3 currentPosition = GetPosition();\n\n  if (m_IsShip)\n  {\n   glPushMatrix();\n   glLoadIdentity();\n   glRotatef(targetRotation.x, 1.0f, 0.0f, 0.0f);\n   glRotatef(targetRotation.y, 0.0f, 1.0f, 0.0f);\n   glRotatef(targetRotation.z, 0.0f, 0.0f, 1.0f);\n   GLfloat matrix[16];\n   glGetFloatv(GL_MODELVIEW_MATRIX, matrix);\n   glPopMatrix();\n   glTranslatef(currentPosition.x, currentPosition.y, currentPosition.z);\n   glMultMatrixf(matrix);\n  }\n\n  switch (m_primitive)\n  {\n  case Primitive::Quads:\n   glBegin(GL_QUADS);\n   break;\n  case Primitive::Triangles:\n   glBegin(GL_TRIANGLES);\n   break;\n  }\n  glColor3f(m_color.r, m_color.g, m_color.b);\n  for (unsigned int i = 0; i < m_vertices.size(); i++)\n  {\n   if (m_IsShip)\n   {\n    glVertex3f(m_vertices[i].x, m_vertices[i].y, m_vertices[i].z);\n   }\n   else\n   {\n    glVertex3f(m_vertices[i].x + m_position.x, m_vertices[i].y + m_position.y, m_vertices[i].z + m_position.z);\n   }\n  }\n  glEnd();\n }\n}\n```", "```cpp\nvoid Model::SetPosition(const float p_x, const float p_y, const float p_z)\n{\n  m_position.x = p_x;\n  m_position.y = p_y;\n  m_position.z = p_z;\n}\n\nvoid Model::SetPosition(const Vec3 p_position)\n{\n  m_position.x = p_position.x;\n  m_position.y = p_position.y;\n  m_position.z = p_position.z;\n}\n\nconst Vec3 Model::GetPosition() const\n{\n  return m_position;\n}\n```", "```cpp\nvoid Model::SetHeading(const float p_x, const float p_y, const float p_z)\n{\n  m_heading.x = p_x;\n  m_heading.y = p_y;\n  m_heading.z = p_z;\n}\n\nvoid Model::SetHeading(const Vec3 p_heading)\n{\n  m_heading.x = p_heading.x;\n  m_heading.y = p_heading.y;\n  m_heading.z = p_heading.z;\n}\nconst Vec3 Model::GetHeading() const\n{\n  return m_heading;\n}\n```", "```cpp\nvoid Model::SetColor(const float p_red, const float p_green, const float p_blue)\n{\n  m_color.r = p_red;\n  m_color.g = p_green;\n  m_color.b = p_blue;\n}\n\nvoid Model::SetColor(const Color p_color)\n{\n  m_color.r = p_color.r;\n  m_color.g = p_color.g;\n  m_color.b = p_color.b;\n}\n```", "```cpp\nvoid Model::SetVelocity(const float p_velocity)\n{\n  m_velocity = p_velocity;\n}\n\nconst float Model::GetVelocity() const\n{\n  return m_velocity;\n}\n```", "```cpp\nvoid Model::SetBaseRotation(const float p_x, const float p_y, const float p_z)\n{\n  m_baseRotation.x = p_x;\n  m_baseRotation.y = p_y;\n  m_baseRotation.z = p_z;\n}\n\nvoid Model::SetBaseRotation(const Vec3 p_rotation)\n{\n  m_baseRotation.x = p_rotation.x;\n  m_baseRotation.y = p_rotation.y;\n  m_baseRotation.z = p_rotation.z;\n}\n\nconst Vec3 Model::GetBaseRotation() const\n{\n  return m_baseRotation;\n}\n```", "```cpp\nvoid Model::SetHeadingRotation(const float p_x, const float p_y, const float p_z)\n{\n  m_headingRotation.x = p_x;\n  m_headingRotation.y = p_y;\n  m_headingRotation.z = p_z;\n}\n\nvoid Model::SetHeadingRotation(const Vec3 p_rotation)\n{\n  m_headingRotation.x = p_rotation.x;\n  m_headingRotation.y = p_rotation.y;\n  m_headingRotation.z = p_rotation.z;\n}\n\nconst Vec3 Model::GetHeadingRotation() const\n{\n  return m_headingRotation;\n}\n```", "```cpp\n#include <windows.h>\n#include \"Model.h\"\n#include \"Sprite.h\"\n#include \"Input.h\"\n#include \"glut.h\"\n```", "```cpp\nModel* ship;\nstd::vector<Model*> asteroids;\n```", "```cpp\nvoid StartGame()\n{\n //Ship\n Model::Color c(0.0f, 0.0f, 1.0f);\n ship = new Model(\"ship.obj\", c);\n Vec3 rotation(90.0f, 0.0f, 0.0f);\n ship->SetBaseRotation(rotation);\n ship->IsShip(true);\n ship->SetVelocity(1.0f);\n\n //Asteroid 1\n c.r = 1.0f;\n c.g = 0.0f;\n c.b = 0.0f;\n Model* asteroid = new Model(\"asteroid.obj\", c);\n Vec3 position(0.0f, 0.0f, -10.0f);\n asteroid->SetPosition(position);\n asteroids.push_back(asteroid);\n\n //Asteroid 2\n c.r = 0.0f;\n c.g = 1.0f;\n c.b = 0.0f;\n asteroid = new Model(\"asteroid.obj\", c);\n position.x = 5.0f;\n position.y = 0.0f;\n position.z = -15.0f;\n asteroid->SetPosition(position);\n asteroids.push_back(asteroid);\n\n //Asteroid 3\n c.r = 0.0f;\n c.g = 1.0f;\n c.b = 1.0f;\n asteroid = new Model(\"asteroid.obj\", c);\n position.x = 5.0f;\n position.y = 5.0f;\n position.z = -20.0f;\n asteroid->SetPosition(position);\n asteroids.push_back(asteroid);\n}\n```", "```cpp\nvoid Update(const float p_deltaTime)\n{\n\n  ship->Update(p_deltaTime);\n\n  for (unsigned int i = 0; i < asteroids.size(); i++)\n  {\n    asteroids[i]->Update(p_deltaTime);\n  }\n}\n```", "```cpp\nvoid Render()\n{\n glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n glMatrixMode(GL_MODELVIEW);\n glLoadIdentity();\n\n for (unsigned int i = 0; i < asteroids.size(); i++)\n {\n  asteroids[i]->Render();\n }\n ship->Render();\n SwapBuffers(hDC);\n}\n```", "```cpp\n#include \"Input.h\"\n```", "```cpp\nInput* m_input;\n```", "```cpp\nm_input = new Input(hWnd);\n```", "```cpp\nvoid ProcessInput(const float p_deltaTime)\n{\n Vec3 rotation;\n m_input->Update(p_deltaTime);\n Input::Command command = m_input->GetCommand();\n switch (command)\n {\n case Input::CM_STOP:\n {\n  if (ship->GetVelocity() > 0.0f)\n  {\n   ship->SetVelocity(0.0f);\n  }\n  else\n  {\n   ship->SetVelocity(1.0f);\n  }\n }\n break;\n case Input::CM_DOWN:\n {\n  rotation = ship->GetHeadingRotation();\n  rotation.x += -1.0f;\n  if (rotation.x < 0.0f)\n  {\n   rotation.x = 359.0f;\n  }\n  if (rotation.x < 359.0f && rotation.x > 180.0f)\n  {\n   if (rotation.x < 315.0f)\n   {\n    rotation.x = 315.0f;\n   }\n  }\n  ship->SetHeadingRotation(rotation);\n }\n break;\n case Input::CM_UP:\n {\n  rotation = ship->GetHeadingRotation();\n  rotation.x += 1.0f;\n  if (rotation.x > 359.0f)\n  {\n   rotation.x = 0.0f;\n  }\n  if (rotation.x > 0.0f && rotation.x < 180.0f)\n  {\n   if (rotation.x > 45.0f)\n   {\n    rotation.x = 45.0f;\n   }\n  }\n  ship->SetHeadingRotation(rotation);\n }\n break;\n case Input::CM_LEFT:\n {\n  rotation = ship->GetHeadingRotation();\n  rotation.z += 1.0f;\n  if (rotation.z > 359.0f)\n  {\n   rotation.z = 0.0f;\n  }\n  if (rotation.z > 0.0f && rotation.z < 180.0f)\n  {\n   if (rotation.z > 45.0f)\n   {\n    rotation.z = 45.0f;\n   }\n  }\n  ship->SetHeadingRotation(rotation);\n }\n break;\n case Input::CM_RIGHT:\n {\n  rotation = ship->GetHeadingRotation();\n  rotation.z += -1.0f;\n  if (rotation.z < 0.0f)\n  {\n   rotation.z = 359.0f;\n  }\n  if (rotation.z < 359.0f && rotation.z > 180.0f)\n  {\n   if (rotation.z < 315.0f)\n   {\n    rotation.z = 315.0f;\n   }\n  }\n  ship->SetHeadingRotation(rotation);\n }\n break;\n }\n}\n```", "```cpp\nProcessInput(p_deltaTime);\n```", "```cpp\nconst bool IsCollideable();\nvoid IsCollideable(const bool collideable);\nconst bool CollidedWith(Model* target);\nconst Vec3 GetCenter() const;\nvoid SetRadius(const float p_radius);\nconst float GetRadius() const;\n```", "```cpp\n float m_radius;\n bool m_collideable;\n```", "```cpp\n SetRadius(1.0f);\n IsCollideable(true);\n```", "```cpp\nconst bool Model::IsCollideable()\n{\n  return m_collideable;\n}\n\nvoid Model::IsCollideable(const bool p_collideable)\n{\n  m_collideable = p_collideable;\n}\n\nconst bool Model::CollidedWith(Model* p_target)\n{\n  if (p_target->IsCollideable() && this->IsCollideable())\n  {\n    const Vec3 p1 = this->GetCenter();\n    const Vec3 p2 = p_sprite->GetCenter();\n\n    float y = p2.y - p1.y;\n    float x = p2.x - p1.x;\n    float z = p2.z - p1.z;\n    float d = x*x + y*y + z*z;\n\n    float r1 = this->GetRadius() * this->GetRadius();\n    float r2 = p_sprite->GetRadius() * p_sprite->GetRadius();\n\n    if (d <= r1 + r2)\n    {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst Vec3 Model::GetCenter() const\n{\n Vec3 center;\n center = GetPosition();\n if (m_IsShip)\n {\n  center.z = -m_position.y;\n  center.x = m_position.x;\n  center.y = m_position.z;\n }\n return center;\n}\n\nvoid Model::SetRadius(const float p_radius)\n{\n  m_radius = p_radius;\n}\n\nconst float Model::GetRadius() const\n{\n  return m_radius;\n}\n```", "```cpp\nvoid CheckCollisions()\n{\n bool collision = false;\n for (int i = 0; i < asteroids.size(); i++)\n {\n  Model* item = asteroids[i];\n  collision = ship->CollidedWith(item);\n  if (collision)\n  {\n   item->IsCollideable(false);\n   item->IsVisible(false);\n   score++;\n   asteroidsHit++;\n  }\n }\n}\n```", "```cpp\nHandleCollisions();\n```"]