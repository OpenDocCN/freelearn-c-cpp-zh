- en: Implementing Windows and Dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to animate our application by using
    signals and slots to trigger and respond to actions that occur within our application.
    So far, we have been concentrating on examples that are contained in only one
    file and do not expressly describe a full working application. To do so, we will
    need to change the style in which our applications are written, and also adopt
    a number of new conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall work with Windows in Qt, so that by the end of the
    chapter, you should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how to subclass and create a custom window application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a menu bar to a window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a toolbar to a window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the various dialog (boxes) to communicate information to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a window(ed) application, we usually call the `show()` method on an
    instance of `QWidget` and that makes that widget, to be contained in a window
    of its own, along with its child widgets displayed in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A recap of such a simple application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`mainWindow` here is an instance of `QMainWindow`, which is derived from `QWidget`.
    As such, by calling the `show()` method, a window will appear. If you were to
    replace `QMainWindow` with `QLabel`, this will still work.'
  prefs: []
  type: TYPE_NORMAL
- en: But this style of writing applications is not the best. Instead, from this point
    onward, we shall define our own custom widget, in which we shall define child
    widgets and make connections between signals and sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's rewrite the preceding application by sub-classing `QMainWindow`.
    We have chosen to subclass `QMainWindow` because we need to illustrate the menu
    and toolbars.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by creating a new folder and defining a header file. The name
    of our header file here is `mainwindow.h`, but feel free to name it how you want
    and remember to add the `.h` suffix. This file should basically contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the Qt classes `QMainWindow`, and `QLabel` in our header file. Then,
    we subclass `QMainWindow` and call it `MainWindow`. The constructor of this new
    class is declared with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire class definition is wrapped within an `#ifndef ... #endif` directive,
    which tells the preprocessor to ignore its content if it is accidentally included
    multiple times in a file.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use the non-standard, but widely used, preprocessor directive, `#pragma
    once`.
  prefs: []
  type: TYPE_NORMAL
- en: Take notice of the `Q_OBJECT` macro. This is what makes the signals and slots
    mechanism possible. Remember that the C++ language does not know about the keywords
    used to set up signals and slots. By including this macro, it becomes part of
    the C++ syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have defined so far is just the header file. The body of the main program
    has to live in some other `.cpp` file. For easy identification, we call it `mainwindow.cpp`.
    Create this file within the same folder and add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We include the header file that we defined earlier with the first line of code.
    The default constructor of our sub-classed widget, `MainWindow`, is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we call the method that sets the title of the window. `setWindowTitle()`
    is invoked and can be accessed from within the constructor since it is an inherited
    method from `QWindow`. There is no need to use the `this` keyword. The size of
    the window is specified by calling the `resize()` method and passing two integer
    values to be used as the dimensions of the window.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of a `QLabel` is created, `mainLabel`. The text within the label
    is aligned to the center by calling `mainLabel->setAlignment(Qt::AlignCenter)`.
  prefs: []
  type: TYPE_NORMAL
- en: A call to `setCentralWidget()` is important as it situates any class that inherits
    from `QWidget` to occupy the interior of the window. Here, `mainLabel` is being
    passed to `setCentralWidget`, and that will make it the only widget to be displayed
    within the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the structure of `QMainWindow` in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60b5e682-55d6-4878-afe7-5aaded0dbb90.png)'
  prefs: []
  type: TYPE_IMG
- en: At the very top of every window is the **Menu Bar**. Elements such as the file,
    edit, and help menus go there. Below that, are the **Toolbars**. Contained within
    the **Toolbars** are the **Dock Widgets**, which are collapsible panels. Now,
    the main controls within the window must be put in the **Central Widget** location.
    Since a UI is made up of several widgets, it will be good to compose a widget
    that will contain child widgets. This parent widget is what you will stick into
    the **Central Widget** area. To do this, we call `setCentralWidget()` and pass
    in the parent widget. At the bottom of the window, is the **Status Bar**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the application, we need to create an instance of our custom window
    class. Create a file called `main.cpp` within the same folder where the header
    and `.cpp` files are located. Add the following lines of code to `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We include the header file `mainwindow.h`, which contains the declaration of
    our custom class, `MainWindow`. Without this, the compiler wouldn't know where
    to find the definition of the `MainWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `MainWindow` is created and the `show()` method is called on
    it. We still have to call the `show()` method on `mainwindow`. `MainWindow`, which
    is a subclass of `QMainWindow`, and behaves just like any widget out there. Furthermore,
    as we already know, to cause a widget to appear, you have to call the `show()`
    method on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the program, move into the folder via the command line and issue the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `QT += widgets` to the `.pro` file that is generated. Now continue with
    the next set of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the `.pro` file for a second. At the very bottom of the file, we have
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The headers are automatically collected and added to `HEADERS`. Similarly, the
    `.cpp` files are collected and added to `SOURCES`. Always remember to check this
    file when there are compilation errors to ensure that all required files have
    been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the program, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For those who work on the macOS, the correct command you will need to issue
    in order to run the executable is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The running application should appear, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/938e02c9-499f-4930-b00b-da7e73f3b26f.png)'
  prefs: []
  type: TYPE_IMG
- en: Menu bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications hold a set of clickable(s) that reveal a list of another set
    of actions that expose more functionality to the user. The most popular among
    these are the File, Edit, and Help menus.
  prefs: []
  type: TYPE_NORMAL
- en: In Qt, menu bars occupy the very top of the window. We shall create a short
    program to make use of the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three files must be created in a newly created folder. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mainwindow.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mainwindow.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `main.cpp` file will remain as before in terms of content. Therefore, copy
    the `main.cpp` file from the previous section. Let''s examine the `mainwindow.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once more, the header file is enclosed in an `ifndef` directive to prevent errors
    that may occur as a result of multiple inclusions of this file.
  prefs: []
  type: TYPE_NORMAL
- en: To create a menu within the window, you need instances of `QMenu`. Each menu,
    such as the File menu, will have sub-menus or items that make up the menu. The
    File menu usually has the Open, New, and Close sub-menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical image of a Menu bar is as follows, with the File, Edit, and Help
    menus. The File menu items under the File menu are New..., Open..., Save, Save
    As..., and Quit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30d1b054-175c-40e9-af76-2448906c0f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Our application will have only two menus, namely, `fileMenu` and `helpMenu`.
    The other instances of `QAction` are the individual menu items: `quitAction`,
    `saveAction`, `cancelAction`, and `newAction`.
  prefs: []
  type: TYPE_NORMAL
- en: Both the menu and sub-menu items are defined as members of the class in the
    header file. Furthermore, this kind of declaration will allow users to modify
    their behavior and also to easily access them when connecting them to sockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s switch to the `mainwindow.cpp`. Copy the following code into `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The header file, `mainwindow.h`, is included at the beginning of the file to
    make available the class declaration and Qt classes that will be used in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the default constructor of our custom class, `MainWindow`, we start by setting
    the name of our window by calling `setWindowTitle()` and giving it an appropriate
    name. The size of our window is then established by calling `setFixedSize()`.
    This is demonstrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Menu items can be displayed with images beside them. To associate an image or
    icon with a menu item, `QAction`, you need to first capture that image within
    an instance of `QPixmap`. Three such images are captured in the `newIcon`, `openIcon`,
    and `closeIcon` variables. These will be used further down the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up the `fileMenu` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To add a menu to the window, a call to `menuBar()` is made. This returns an
    instance of `QMenu`, and we call `addMenu` on that object specifying the name
    of the menu we want to add. Here, we call our first menu, File. The `"&"` sign
    in front of the F in File will make it possible to press *Alt* + *F* on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '`quitAction` is passed an instance of `QAction()`. `closeIcon` is the image
    we want to associate with this sub-menu. `"Quit"` is the display name and the
    `this` keyword makes the `quitAction` a child widget of `MainWindow`.'
  prefs: []
  type: TYPE_NORMAL
- en: A shortcut to a sub-menu is associated with `quitAction` by calling `setShortcuts()`.
    By using `QKeySequence::Quit`, we mask the need to cater for platform-specific
    key sequences that are used.
  prefs: []
  type: TYPE_NORMAL
- en: '`newAction` and `openAction` follow the same logic in their creation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our menu in `fileMenu` and the menu items in `quitAction`,
    `newAction`, and `openActions`, we need to link them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To add a sub-menu item, we call the `addAction()` method on the `QMenu` instance,
    `fileMenu`, and pass the required `QAction` instance. The `addSeparator()` is
    used to insert a visual marker in our list of menu items. It also returns an instance
    of `QAction`, but we are not interested in that object at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second menu is added to the application along with its only sub-menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`QAction` encapsulates a general idea of an action that can be inserted into
    widgets. Here, we used `QAction` to insert actions into our menus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These `QAction` instances emit the `triggered` signal, which can be connected
    to a socket to cause the application to change, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When connecting a signal to a slot within a class definition, simply call the
    `connect()` method and pass in the parameters as you would do normally. The first
    parameter is the object that is going to emit the signal we are interested in.
    `&QAction::triggered` is one way of specifying the triggered signal. This is the
    same as writing `SIGNAL(triggered())`. The `this` keyword refers to the `MainWindow`
    object that will be created in the future. The quit slot is specified by `&QApplication::quit`.
  prefs: []
  type: TYPE_NORMAL
- en: The signal and slot connected will create a situation where, when the File menu
    is opened and the Close button is clicked, the application will close.
  prefs: []
  type: TYPE_NORMAL
- en: The last file needed to run this example is the `main.cpp` file. The previous
    `main.cpp` file created should be copied over to this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project. A typical output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50cfe2b4-db39-4bac-a735-a8e38c568181.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On a Mac, press the key combination *Command* + *Q* and that will close the
    application. On Linux and Windows, *Alt* + *F4* should do the same. This is made
    possible by the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This line of code blurs out the difference by relying on Qt's `QKeySequence::Quit`,
    depending on the OS in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the File menu and select New:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8001058b-a450-40fb-bfd5-c53630e89a43.png)'
  prefs: []
  type: TYPE_IMG
- en: Nothing happens. That is because we did not define what should happen when the
    user clicks on that action. The last menu item, Quit, on the other hand, closes
    the application as defined by the socket and slot we declared.
  prefs: []
  type: TYPE_NORMAL
- en: Also, take note of how each menu item has an appropriate icon or image in front
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Visit the Packt website to obtain the images for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beneath the menu bar is a panel that is usually referred to as toolbar. It contains
    a set of controls that could be widgets or instances of `QAction`, just as we
    saw in their use in creating the menu bar. This also means that you may choose
    to replace the `QAction` with a widget, such as a regular `QPushButton` or `QComboBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbars may be fixed to the top of the window (beneath the menu bar) and can
    be pinned there or made to float around the dock widget.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we will need to create a new project or modify the one from the
    previous section of this chapter. The files that we will be creating are `main.cpp`,
    `mainwindow.h`, and `mainwindow.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.cpp` file remains the same, as follows. We only instantiate our custom
    class and call `show()` on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mainwindow.h` file will essentially contain the `QAction` members that
    will hold the actions in our toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This header file appears the same as before. The only difference is the `QToolbar`
    instance, `*toolbar`, and the `QAction` objects that will be shown within the
    toolbar. These are `newToolBarAction`, `openToolBarAction`, and `closeToolBarAction`.
    The `QAction` instances that are used in a menu are the same as the ones used
    for toolbars.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are no slots being declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mainwindow.cpp` file will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The same set of icons used for the menu bar will be used for the toolbars too.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain an instance of the Windows toolbar for further manipulation, call
    the `addTooBar()` method, which will return an instance of a `QToolBar`. The method
    accepts any text that is used as the title of the window. It also adds the toolbar
    to the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolbar at this point can be moved around within the window. To fix it
    to the top of the window, call the `toolbar->setMovable(false);` function on the
    instance of the `QToolBar`, `toolbar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Two `QAction` objects are created and passed to the `newToolBarAction` and `openToolBarAction`
    objects. We pass the `QIcon` object that becomes the image on the `QAction` and
    a name or text to be displayed as a tooltip. A separator is added to the toolbar
    by calling the `addSeparator()` method. The last control, `closeToolBarAction`,
    contains an image to be displayed on the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To link the trigger signal of `closeToolBarAction` to the quit slot of the
    window, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile this project as a recap, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `QT += widgets` to the `.pro` file that is generated and make sure all
    three files are listed in the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceed to issue the following commands in order to build the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went well, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e49d334c-3989-4115-99c9-479ade2fadc8.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the toolbar beneath the File and Help menus.
    Three icons show three `QAction` objects that represent the New, Open, and Close
    actions. Only the last button (to close the application) action works. That is
    because we only defined a single signal-slot connection for the `closeToolBarAction` and `QAction`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'By hovering the mouse over the toolbar menu items, some text appears. This
    message is called a tooltip. As can be seen in the preceding diagram, the Open
    File message is derived from the last parameter of the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted earlier, a toolbar can be moved around within a window as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8872f67b-6a3c-4f2b-95cc-430acafc0f19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, by clicking on the three vertical dots on the left-hand side
    of the toolbar and moving it, you can detach the toolbar from the top to either
    the left, right, or bottom. To display this kind of functionality, issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will fix the toolbar to the top so that it can't be moved around.
  prefs: []
  type: TYPE_NORMAL
- en: Adding other widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only added a menu bar and a toolbar to our window. To add other
    widgets that might make our application useful, we have to add more members to
    our header file. In this section, we shall create a simple application that appends
    personal details to a displayable list.
  prefs: []
  type: TYPE_NORMAL
- en: There will be a form where the details of a number of contacts will be received.
    This detail will then be added to a list on the window. As more contacts are added,
    the list will grow. We shall base these on the previous section's code and continue
    to build on it.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you create a new folder with the three files, namely, `main.cpp`,
    `mainwindow.cpp`, and `mainwindow.h`. The `main.cpp` file will remain as before
    from the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mainwindow.h` file should contain the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The file imports the classes that will be used in declaring the members within
    our custom class. The whole file is wrapped with the `#ifndef` directive so that
    the header file can be included multiple times without yielding errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code to the same header file, `mainwindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We then declare our default constructor for our class.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one slot in our application that will be used to move the content
    of a number of widgets into a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue the code listing by adding the following lines of code that will add
    the members of the class and define the prototype of some `helper` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The members include layout and other widget classes, classes for our menu, toolbars,
    and their associated `QAction` objects.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the code is borrowed from the previous section with the exception
    of the widgets being added.
  prefs: []
  type: TYPE_NORMAL
- en: The private methods, `createIcons()`, `createMenuBar()`, `createToolBar()`,
    `setupSignalsAndSlot()`, and `setupCoreWidgets()`, will be used to refactor the
    code that should live in our default constructor. The `clearFields()` method will
    be used to clear the data from a number of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mainwindow.cpp` file, we shall define our class with the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor has been refactored a great deal here. The building
    blocks of code have been moved away into functions to help make the code readable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we only set the window title and size of the application window. Next,
    we call the method that will create the icons that will be used by the various
    widgets. Another function call is made to set up the core widgets by calling the
    `setupCoreWidgets()` method. The menu and toolbars are created by calling the
    `createMenuBar()` and `createToolBar()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The layout object, `centralWidgetLayout`, is the main layout of our application.
    We add the `formLayout` object first, followed by the `appTable` object. As you
    can see, it is possible to insert a layout into another layout. Lastly, we insert
    the `buttonsLayout` object, which contains our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The `mainWidget` object's layout is set to `centralWidgetLayout`. This `mainWidget`
    object is then set as the main widget that should occupy the center of the window,
    as was demonstrated in the first diagram of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All signals and slots will be set up in the `setupSignalsAndSlot()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code to the `mainwindow.cpp` file that defines the
    `createIcons()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `createIcons()` method will pass instances of `QPixmap` to the members that
    were declared in `mainwindow.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of `setupCoreWidgets()` is as follows, in `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are just instantiating objects to be used within the application. There
    is nothing out of the ordinary here. `nameLineEdit` and `phoneNumberLineEdit`
    will be used to collect the name and phone number of contacts about to be saved.
    `dateOfBirthEdit` is a special kind of textbox that allows you to specify a date.
    `savePushButton` and `newPushButton` are buttons that will be used to trigger
    the saving of the contact and the clearing of the list.
  prefs: []
  type: TYPE_NORMAL
- en: The labels and line edit controls will be used in the `formLayout` object, which
    is a `QGridLayout` instance. `QGridLayout` allows widgets to be specified using
    columns and rows.
  prefs: []
  type: TYPE_NORMAL
- en: To save a contact, this means we will save it to a widget that can display a
    list of items. Qt has a number of such widgets. These include `QListView`, `QTableView`,
    and `QTreeView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `QListView` is used in displaying information, it will typically appear
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/888d6e5f-7929-48f2-b591-542d7dc51a2e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`QTableView` will use columns and rows to display data or information in cells
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6785168c-b18c-4ac9-aa72-83a5ffedf13f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To show hierarchical information, `QTreeView` is also used, as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6707e92-a5ed-463e-aaf9-3f73dc596906.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An instance of `QTableView` is passed to `appTable`. We need a model for our
    `QTableView` instance. The model will hold the data that will be displayed in
    our table. When data is added or removed from the model, its corresponding view
    will be updated to show the change that has occurred, automatically. The model
    here is an instance of `QStandardItemModel`. The line `QStandardItemModel(1, 3,
    this)` will create an instance with one row and three columns. The `this` keyword
    is used to make the model a child of the `MainWindow` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is used to help us define a custom action that should happen when
    we raise a context menu on the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line is important and enables the headers of our table to stretch
    out fully. This is the result when we omit that line (as shown in an area bounded
    by the red box):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66e16468-6820-4379-b2d2-69249b06729d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ideally, we want our table to have the following header, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/502811d8-85bb-465b-9568-e8c9bccae68f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To set the header for the table, we can do so with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The table for displaying the contacts needs headers. The `setHorizontalHeaderItem()`
    method on the model object uses the first parameter to indicate the position where
    the new `QStandardItem(QString())` should be inserted. Because our table uses
    three columns, the line is repeated three times for the headers, Name, Date of
    Birth, and Phone Number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We make `model` the model of our `QTableView` by calling `setModel()` on `appTable`
    and passing `model` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To populate our model, which updates its view, `QTableView`, we shall create
    instances of `QStandardItem`. Each cell in our table has to be encapsulated in
    this class. `dateOfBirth` is of the `QDate` type, so we call `toString()` on it
    and pass it to `new QStandardItem()`. `firstItem` is inserted into our model by
    specifying the row and column as in the line `model->setItem(0, 0, firstItem);`.
  prefs: []
  type: TYPE_NORMAL
- en: This is done for the second and third `QStandardItem` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s populate our `formLayout` object. This is of the `QGridLayout` type.
    To insert widgets into our layout, use the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We add widgets to the layout by calling `addWidget()`, supplying the widget,
    and the row and column it is supposed to fill. `0, 0` will fill the first cell, `0,
    1` will fill the second cell on the first row, and `1, 0` will fill the first
    cell on the second row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code adds buttons to the `QHBoxLayout` instance of `buttonsLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To push `savePushButton` and `newPushButton` to the right, we first add a stretch
    that will expand and fill the empty space by calling `addStretch()` before a call
    to add the widgets is made by `addWidget()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we come to the menus in the application, add the following code. To
    include menus and a toolbar to our application, add the definition of `createMenuBar()`
    and `createToolBar()` to the `mainwindow.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is familiar code that adds a toolbar and menus to our window.
    The final lines of code define the `setupSignalsAndSlots()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we connect the triggered signal of `quitAction` to the
    quit slot of `QApplication`. The triggered signal of `closeToolBarAction` is connected
    to the same, to achieve the effect of closing the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `clicked()` signal of `savePushButton` is connected to the slot, `saveButtonClicked()`.
    Because it is defined within our class, the `this` keyword is used in the third
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The exact operation that ensures that the information input into the form is
    saved, is defined by the `saveButtonClicked()` function that serves a slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define our slot, add the following code to `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When `saveButtonClicked()` is invoked, we shall extract the values within the
    controls, `nameLinedEdit`, `dateOfBirthEdit`, and `phoneNumberLineEdit`. We append
    them to the model by calling `appendRow()` on the model object. We can access
    the model object because it is a member point variable in our class definition.
  prefs: []
  type: TYPE_NORMAL
- en: After appending the new contact information into the list, all the fields are
    cleared and reset with a call to `clearFields()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clear the fields, we call `clearFields()`, which is defined in `mainwindow.cpp`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nameLineEdit` object is reset to an empty string by calling the `clear()`
    method. This method also doubles as a slot. Another way to set a `QLineEdit` object
    to an empty string is by setting the text to `""` by calling the `setText("")`:'
  prefs: []
  type: TYPE_NORMAL
- en: Because `QDateEdit` accepts dates, we have to create an instance of `date` and
    pass it to `setDate()` of `dateOfBirthEdit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d7a1cf3-4101-4cb6-a5dc-1c13ec5f94d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a new contact, complete the form and click on the Save button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef6535e7-49b9-44d5-a228-e984c353d355.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the Save button, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b28d12a8-35dd-48b8-8837-1a2f8a987d87.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding dialog boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when an application needs to inform the user of an action or
    to receive input for further processing. Usually, another window, typically small
    in size, will appear with such information or instructions. In Qt, the `QMessageBox`
    provides us with the functionality to raise alerts and receive input using `QInputDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different messages, as explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6262d2fe-0591-4cc7-b1c7-c4626529abe6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To raise an instance of `QMessage` to communicate a recently accomplished task
    to the user, the following code listing can serve as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code listing will yield an output such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70d4daf-c9c9-4298-9519-ec4aab559d4a.png)'
  prefs: []
  type: TYPE_IMG
- en: This `QMessageBox` instance is being used to communicate to the user that an
    operation was successful.
  prefs: []
  type: TYPE_NORMAL
- en: The icon and number of buttons on a `QMessageBox` instance is configurable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's complete the contact application being written to show how `QMessageBox`
    and `QInputDialog` are used.
  prefs: []
  type: TYPE_NORMAL
- en: Choose to build upon the example in the previous section or create a new folder
    with the three main files we have been working with so far, that is, `main.cpp`,
    `mainwindow.cpp`, and `mainwindow.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mainwindow.h` file should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The only notable change is the increase in the number of slots. The `saveButtonClicked()`
    slot will be reimplemented to pop up a message telling the user of a successful
    save action. The `aboutDialog()` slot will be used to show an about message. This
    is usually a window that conveys information about the program and usually contains
    copyright, help, and contact information.
  prefs: []
  type: TYPE_NORMAL
- en: The `clearAllRecords()` slot will invoke a question message box that will prompt
    the user of the destructive action about to be taken. `deleteSavedRecord()` will
    use `QInputDialog` to accept input from the user as to which row to remove from
    our list of saved contacts.
  prefs: []
  type: TYPE_NORMAL
- en: '`QAction *aboutQtAction` will be used to invoke the slot to display the about
    page or message. We shall also add a toolbar action, `QAction *deleteOneEntryToolBarAction`,
    that will be used to invoke a dialog box that will receive input from the user.
    Observe these three inputs, `QPixmap deleteIcon`, `QPixmap clearIcon`, and `QPixmap
    deleteIcon`, as we add more actions to the window and, likewise, the `QPushButton*clearPushButton`,
    which is replacing `newPushButton` in the previous example.'
  prefs: []
  type: TYPE_NORMAL
- en: Everything else about the header file remains the same. The two extra classes
    imported are the `QMessageBox` and `QInputDialog` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mainwindow.cpp` file, we define the default constructor of the `MainWindow`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This time, we want to give the whole application an icon that will show up in
    a taskbar or dock when it is running. To do this, we call the `setWindowIcon()`
    method and pass in an instance of `QIcon("window_logo.png")`.
  prefs: []
  type: TYPE_NORMAL
- en: The `window_logo.png` file is included in the project, along with the other
    image files being used as an attachment on the Packt site for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Everything remains the same as before in the previous example. The methods that
    are setting up the various parts of the application have been modified slightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setupSignalsAndSlots()` method is implemented with the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `triggered()` signal of `aboutAction` is connected to the `aboutDialog()`.
    slot. This method raises a dialog box that is used to display a window with some
    information about the application and a logo of the app (which we have defined
    by calling `setWindowIcon()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The static method, `QMessageBox::about()`, is called with `this` as its first
    argument. The title of the window is the second argument, and a string that describes
    the application is given as the third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, click on the Help menu and then click on About. You should see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4a86188-c4c5-434a-9052-e43a41ea2e2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The third signal-slot connection that is established in the `setupSignalsAndSlots()`
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `clearAllRecords()` slot, we will first ask the user with the aid of
    a prompt if they are sure they want all the items in a model to be removed. This
    can be achieved by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`QMessageBox::question` is used to raise a dialog to ask the user a question.
    It has two main buttons, Yes and No. `QMessageBox::No|QMessageBox::Default` sets
    the No option as the default selection. `QMessageBox::No|QMessageBox::Escape`
    makes the escape key have the same effect as clicking on the No option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever option the user chooses will be stored as `int` in the status variable.
    It will then be compared to the `QMessageBox::Yes` constant. This way of asking
    the user a Yes or No question is not informative enough, especially when a destructive
    operation will ensue when the user clicks Yes. We shall use the alternative form
    as defined in `clearAllRecords()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the parent object is pointed to by `this`. The second parameter is
    the title of the dialog box and the string of the question follows. We shall make
    the first option verbose by passing Yes, Delete all records. The user, upon reading,
    will know what effect the clicking of the button will have. The No ! parameter will
    be displayed on the button that represents the other answer to the question. `QString()`
    is being passed so that we don't display the third button. When the first button
    is clicked, `0` will be returned to `status`. When the second button or option
    is clicked, `1` will be returned. By specifying `1`, we make the `"No !"` button
    the default button of the dialog box. We select `1` again, as the last parameter
    specifies that `"No !"` should be the button selected when the escape button is
    pressed.
  prefs: []
  type: TYPE_NORMAL
- en: If the user clicks on the Yes, Delete all records button, then status will store
    `0`. In the body of the `if` statement, we obtain the number of rows in our model
    object. A call to `removeRows` is made and we specify that all the entries from
    the first, represented by `0`, to the `rowCount`, should be removed. However,
    if the user clicks on the No ! button, the application will do nothing, as we
    don't specify that in the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialog window should appear as follows when the Clear All button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaf6dc67-d05e-484b-ba4c-4211f55bc803.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `saveButtonClicked()` slot has also been modified to show a simple message
    to the user that the operation has been successful, as demonstrated in the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The two last parameters are constants that prevent buttons from showing in the
    message box.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the application to remove certain rows from the table, the `deleteSaveRecords()` method
    is used to raise an input-based dialog box that receives the `rowId` of the row
    we want to remove through the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword refers to the parent object. The second parameter to the
    call of the static method `QInputDialog::getInt()` is used as the title of the
    dialog window. The request is captured in the second parameter. The third parameter
    here is used to specify the default number of the input field. `1`, and `model->rowCount()`,
    are the minimum and maximum values that should be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: The last but one parameter, `1`, is the incremental step between the minimum
    and maximum value. `True` or `False` will be stored in `&ok`. When the user clicks
    OK, `True` will be stored in `&ok` and, based on that, the `if` statement will
    call the `removeRow` on the model object. Whatever value that the user inputs
    will be passed to `rowId`. We pass `rowId-1` to get the actual index of the row
    in the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection to this slot is made by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`deleteOneEntryToolBarAction` is the last but one action on the toolbar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is what will appear when the user clicks on this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f66acf9a-878e-4a38-9202-a1832c602367.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The method that sets up the toolbar is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: All the other methods are borrowed from the previous section and can be obtained
    from the source code attached to this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, this is what you should see after compiling and running the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a4b9f91-2d37-4eb4-91d4-818f48da3985.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that the reason we already have an entry in the model object is because
    we created such an entry within the `setupCoreWidgets()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the name, date of birth, and phone number fields and click on Save.
    This will add an extra line to the table in the window. A dialog message will
    tell you if the operation was successful.
  prefs: []
  type: TYPE_NORMAL
- en: To delete a row within the table, select the desired row and click on the recycle
    bin icon, and confirm whether you really want to delete the entry.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to create menus, toolbars, and how to use
    dialog boxes to receive further input and display information to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](48ced144-5e85-4e89-9ddf-80e876e83b0f.xhtml), *Managing Events,
    Custom Signals, and Slots*, we will explore the use of events and more on signals
    and slots.
  prefs: []
  type: TYPE_NORMAL
