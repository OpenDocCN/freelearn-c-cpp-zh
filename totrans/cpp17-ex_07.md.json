["```cpp\n#ifndef GAMEWIDGET_H \n#define GAMEWIDGET_H \n\n#include <QPainter> \n#include <QMouseEvent> \n#include <QMessageBox> \n\n#include \"..\\MainWindow\\MainWindow.h\" \n\nclass GameWidget : public QWidget { \n  Q_OBJECT \n```", "```cpp\n    public: \n      GameWidget(int rows, int columns, QWidget* parentWidget); \n```", "```cpp\n      void clearGrid(); \n```", "```cpp\n    void resizeEvent(QResizeEvent *eventPtr); \n```", "```cpp\n      void mousePressEvent(QMouseEvent *eventPtr); \n      void paintEvent(QPaintEvent *eventPtr); \n      void closeEvent(QCloseEvent *eventPtr); \n```", "```cpp\n    virtual void mouseMark(int row, int column) = 0; \n    virtual void drawMark(QPainter& painter, \n                          const QRect& markRect, int mark) = 0; \n```", "```cpp\n  private: \n    bool isQuitOk(); \n```", "```cpp\n  public slots: \n    DEFINE_LISTENER(GameWidget, isQuitEnabled); \n```", "```cpp\n    void onQuit(); \n    void onExit(); \n```", "```cpp\n  protected: \n    bool isGameInProgress() const {return m_gameInProgress;} \n    void setGameInProgress(bool active) \n                          {m_gameInProgress = active;} \n```", "```cpp\n    protected: \n      int get(int row, int column) const; \n      void set(int row, int column, int value); \n```", "```cpp\n     private: \n       bool m_gameInProgress = false; \n       int m_rows, m_columns; \n       int m_rowHeight, m_columnWidth; \n       int* m_gameGrid; \n     }; \n\n     #endif // GAMEWIDGET_H \n```", "```cpp\n#include \"GameWidget.h\" \n#include <QApplication> \n#include <CAssert> \n```", "```cpp\nGameWidget::GameWidget(int rows, int columns, \n                       QWidget* parentWidget) \n :QWidget(parentWidget), \n  m_rows(rows), \n  m_columns(columns), \n  m_gameGrid(new int[rows * columns]) { \n  assert(rows > 0); \n  assert(columns > 0); \n  clearGrid(); \n} \n```", "```cpp\nint GameWidget::get(int row, int column) const { \n  return m_gameGrid[(row * m_columns) + column]; \n} \n\nvoid GameWidget::set(int row, int column, int value) { \n  m_gameGrid[(row * m_columns) + column] = value; \n} \n```", "```cpp\nvoid GameWidget::clearGrid() { \n  for (int row = 0; row < m_rows; ++row) { \n    for (int column = 0; column < m_columns; ++column) { \n      set(row, column, 0); \n    } \n  } \n} \n```", "```cpp\nbool GameWidget::isQuitEnabled() { \n  return m_gameInProgress; \n} \n```", "```cpp\nbool GameWidget::isQuitOk() { \n  if (m_gameInProgress) { \n    QMessageBox messageBox(QMessageBox::Warning, \n                           tr(\"Quit\"), QString()); \n    messageBox.setText(tr(\"Quit the Game.\")); \n    messageBox.setInformativeText \n                  (tr(\"Do you really want to quit the game?\")); \n    messageBox.setStandardButtons(QMessageBox::Yes | \n                                  QMessageBox::No); \n    messageBox.setDefaultButton(QMessageBox::No); \n```", "```cpp\n    return (messageBox.exec() == QMessageBox::Yes); \n  } \n\n  return true; \n}\n\n```", "```cpp\nvoid GameWidget::onQuit() { \n  if (isQuitOk()) { \n    m_gameInProgress = false; \n    update(); \n  } \n} \n```", "```cpp\nvoid GameWidget::onExit() { \n  if (isQuitOk()) { \n    qApp->exit(0); \n  } \n} \n```", "```cpp\nvoid GameWidget::resizeEvent(QResizeEvent* eventPtr) { \n  m_rowHeight = height() / (m_rows + 2); \n  m_columnWidth = width() / (m_columns + 2); \n  QWidget::resizeEvent(eventPtr); \n  update(); \n} \n```", "```cpp\n    void GameWidget::mousePressEvent(QMouseEvent* eventPtr) { \n       if (m_gameInProgress &&\n             (eventPtr->button() == Qt::LeftButton)) { \n       QPoint mousePoint = eventPtr->pos(); \n```", "```cpp\n    mousePoint.setX(mousePoint.x() - m_columnWidth); \n    mousePoint.setY(mousePoint.y() - m_rowHeight); \n```", "```cpp\n      int row = mousePoint.y() / m_rowHeight, \n         column = mousePoint.x() / m_columnWidth; \n```", "```cpp\n    if ((row < m_rows) && (column < m_columns) && \n        (get(row, column) == 0)) { \n      mouseMark(row, column); \n      update(); \n    } \n  } \n} \n```", "```cpp\nvoid GameWidget::paintEvent(QPaintEvent* /*eventPtr*/) { \n  if (m_gameInProgress) { \n    QPainter painter(this); \n    painter.setRenderHint(QPainter::Antialiasing); \n    painter.setRenderHint(QPainter::TextAntialiasing); \n```", "```cpp\n    for (int row = 0; row < m_rows; ++row) { \n      QString text; \n      text.sprintf(\"%c\", (char) (((int) 'A') + row)); \n      QRect charRect(0, (row + 1) * m_rowHeight, \n                     m_columnWidth, m_rowHeight); \n      painter.drawText(charRect, Qt::AlignCenter | \n                       Qt::AlignHCenter, text); \n    } \n```", "```cpp\n    for (int column = 0; column < m_columns; ++column) { \n      QString text; \n      text.sprintf(\"%i\", column); \n      QRect charRect((column + 1) * m_columnWidth, 0, \n                     m_columnWidth, m_rowHeight); \n      painter.drawText(charRect, Qt::AlignCenter | \n                       Qt::AlignHCenter, text); \n    } \n\n    painter.save(); \n    painter.translate(m_columnWidth, m_rowHeight); \n```", "```cpp\n    for (int row = 0; row < m_rows; ++row) { \n      for (int column = 0; column < m_columns; ++column) { \n        QRect markRect(column * m_columnWidth, row * m_rowHeight, \n                       m_columnWidth, m_rowHeight); \n        painter.setPen(Qt::black); \n        painter.drawRect(markRect); \n        painter.fillRect(markRect, Qt::lightGray); \n        drawMark(painter, markRect, get(row, column)); \n      } \n    } \n\n    painter.restore(); \n     } \n    } \n```", "```cpp\nvoid GameWidget::closeEvent(QCloseEvent* eventPtr) { \n  if (isQuitOk()) { \n    eventPtr->accept(); \n    qApp->exit(0); \n  } \n  else { \n    eventPtr->ignore(); \n  } \n} \n```", "```cpp\n  #ifndef OTHELLOWINDOW_H \n  #define OTHELLOWINDOW_H \n\n  #include \"..\\MainWindow\\MainWindow.h\" \n  #include \"OthelloWidget.h\" \n\n  class OthelloWindow : public MainWindow { \n    Q_OBJECT \n\n    public: \n      OthelloWindow(QWidget *parentWidget = nullptr); \n      ~OthelloWindow(); \n\n      void closeEvent(QCloseEvent *eventPtr) \n        {m_othelloWidgetPtr->closeEvent(eventPtr);} \n```", "```cpp\n  private: \n    OthelloWidget* m_othelloWidgetPtr; \n}; \n\n#endif // OTHELLOWINDOW_H \n```", "```cpp\n#include \"OthelloWidget.h\" \n#include \"OthelloWindow.h\" \n#include <QtWidgets> \n```", "```cpp\nOthelloWindow::OthelloWindow(QWidget *parentWidget /*= nullptr*/)\n :MainWindow(parentWidget) {\n  setWindowTitle(tr(\"Othello\"));\n  resize(1000, 500);\n```", "```cpp\n    m_othelloWidgetPtr = new OthelloWidget(this); \n    setCentralWidget(m_othelloWidgetPtr); \n```", "```cpp\n  { QMenu* gameMenuPtr = menuBar()->addMenu(tr(\"&Game\")); \n    connect(gameMenuPtr, SIGNAL(aboutToShow()), \n            this, SLOT(onMenuShow())); \n```", "```cpp\n    addAction(gameMenuPtr, tr(\"&Black Starts\"), \n              SLOT(onBlackStarts()), 0, \n              tr(\"Black Starts\"), nullptr,tr(\"Black Starts\"), \n              LISTENER(isBlackStartsEnabled)); \n\n    addAction(gameMenuPtr, tr(\"&White Starts\"), \n              SLOT(onWhiteStarts()), 0, \n              tr(\"White Starts\"), nullptr, tr(\"White Starts\"), \n              LISTENER(isWhiteStartsEnabled)); \n\n    gameMenuPtr->addSeparator(); \n```", "```cpp\n    addAction(gameMenuPtr, tr(\"&Quit the Game\"), \n              SLOT(onQuit()), \n              QKeySequence(Qt::CTRL + Qt::Key_Q), \n              tr(\"Quit Game\"), nullptr, tr(\"Quit the Game\"), \n              LISTENER(isQuitEnabled)); \n```", "```cpp\n    addAction(gameMenuPtr, tr(\"E&xit\"), \n              SLOT(onExit()), QKeySequence::Quit); \n  } \n} \n```", "```cpp\nOthelloWindow::~OthelloWindow() { \n  delete m_othelloWidgetPtr; \n} \n```", "```cpp\n#ifndef OTHELLOWIDGET_H \n#define OTHELLOWIDGET_H \n\n#include \"..\\MainWindow\\GameWidget.h\" \n\n#define ROWS    8 \n#define COLUMNS 8 \n```", "```cpp\nenum Mark {Empty = 0, Black, White}; \n\nclass OthelloWidget : public GameWidget { \n  Q_OBJECT \n\n  public: \n    OthelloWidget(QWidget* parentWidget); \n\n    void mouseMark(int row, int column); \n    void drawMark(QPainter& painter, \n                  const QRect& markRect, int mark); \n```", "```cpp\n    public slots: \n     DEFINE_LISTENER(OthelloWidget, isBlackStartsEnabled); \n     DEFINE_LISTENER(OthelloWidget, isWhiteStartsEnabled); \n```", "```cpp\n    void onBlackStarts(); \n    void onWhiteStarts(); \n```", "```cpp\n   private: \n     void checkWinner(); \n```", "```cpp\n     void turn(int row, int column, Mark mark); \n```", "```cpp\n    void calculateMark(int row, int column, Mark mark, \n                       QSet<QPair<int,int>>& resultSet); \n```", "```cpp\n    Mark m_nextMark; \n}; \n\n#endif // OTHELLOWIDGET_H \n```", "```cpp\n#include \"OthelloWidget.h\" \n#include \"OthelloWindow.h\" \n\n#include <QTime> \n#include <CTime> \n#include <CAssert> \nusing namespace std; \n\nOthelloWidget::OthelloWidget(QWidget* parentWidget) \n :GameWidget(ROWS, COLUMNS, parentWidget) { \n  // Empty. \n} \n```", "```cpp\nbool OthelloWidget::isBlackStartsEnabled() { \n  return !isGameInProgress(); \n} \n\nbool OthelloWidget::isWhiteStartsEnabled() { \n  return !isGameInProgress(); \n} \n```", "```cpp\nvoid OthelloWidget::onBlackStarts() { \n  setGameInProgress(true); \n  m_nextMark = Black; \n  update(); \n} \n\nvoid OthelloWidget::onWhiteStarts() { \n  setGameInProgress(true); \n  m_nextMark = White; \n  update(); \n} \n```", "```cpp\nvoid OthelloWidget::mouseMark(int row, int column) { \n  set(row, column, m_nextMark); \n  turn(row, column, m_nextMark); \n  update(); \n```", "```cpp\n  checkWinner(); \n  m_nextMark = (m_nextMark == Black) ? White : Black; \n} \n```", "```cpp\nvoid OthelloWidget::drawMark(QPainter& painter, \n     const QRect& markRect, int mark) { \n  painter.setPen(Qt::black); \n  painter.drawRect(markRect); \n  painter.fillRect(markRect, Qt::lightGray); \n\n  switch (mark) { \n    case Black: \n      painter.setPen(Qt::black); \n      painter.setBrush(Qt::black); \n      painter.drawEllipse(markRect); \n      break; \n\n    case White: \n      painter.setPen(Qt::white); \n      painter.setBrush(Qt::white); \n      painter.drawEllipse(markRect); \n      break; \n\n    case Empty: \n      break;\n```", "```cpp\n  } \n} \n```", "```cpp\nvoid OthelloWidget::checkWinner() { \n  int blacks = 0, whites = 0, empties = 0; \n\n  for (int row = 0; row < ROWS; ++row) { \n    for (int column = 0; column < COLUMNS; ++column) { \n      switch (get(row, column)) { \n        case Black: \n          ++blacks; \n          break; \n\n        case White: \n          ++whites; \n          break; \n\n        case Empty: \n          ++empties; \n          break; \n      } \n    } \n  } \n```", "```cpp\n  if (empties == 0) { \n    QMessageBox messageBox(QMessageBox::Information, \n        tr(\"Victory\"), QString()); \n    QString text; \n\n    if (blacks == whites) { \n      text.sprintf(\"A Draw.\"); \n    } \n    else if (blacks > whites) { \n      text.sprintf(\"The Winner: Black\"); \n    } \n    else { \n      text.sprintf(\"The Winner: White\"); \n    } \n\n    messageBox.setText(text); \n    messageBox.setStandardButtons(QMessageBox::Ok); \n    messageBox.exec(); \n    setGameInProgress(false); \n\n    clearGrid(); \n    update(); \n  } \n} \n```", "```cpp\nvoid OthelloWidget::turn(int row, int column, Mark mark) { \n  QSet<QPair<int,int>> totalSet; \n  calculateMark(row, column, mark, totalSet); \n\n  for (QPair<int,int> pair : totalSet) { \n    int row = pair.first, column = pair.second; \n    set(row, column, mark); \n  } \n} \n```", "```cpp\nvoid OthelloWidget::calculateMark(int row, int column, \n    Mark playerMark, QSet<QPair<int,int>>& totalSet){ \n```", "```cpp\n  QPair<int,int> directionArray[] = \n    {QPair<int,int>(-1, 0),   // North \n     QPair<int,int>(-1, 1),   // Northeast \n     QPair<int,int>(0, 1),    // East \n     QPair<int,int>(1, 1),    // Southeast \n     QPair<int,int>(1, 0),    // South \n     QPair<int,int>(1, -1),   // Southwest \n     QPair<int,int>(0, -1),   // West \n     QPair<int,int>(-1, -1)}; // Northwest \n```", "```cpp\n  int arraySize = \n    (sizeof directionArray) / (sizeof directionArray[0]); \n```", "```cpp\n  for (int index = 0; index < arraySize; ++index) { \n    QPair<int,int> pair = directionArray[index]; \n```", "```cpp\n    int rowStep = pair.first, columnStep = pair.second, \n        currRow = row, currColumn = column; \n```", "```cpp\n    QSet<QPair<int,int>> directionSet; \n\n    while (true) { \n      currRow += rowStep; \n      currColumn += columnStep; \n```", "```cpp\nif ((currRow < 0) || (currRow == ROWS) || \n          (currColumn < 0) || (currColumn == COLUMNS) || \n          (get(currRow, currColumn) == Empty)) { \nbreak; \n} \n```", "```cpp\nelse if (get(currRow, currColumn) == playerMark) { \n  totalSet += directionSet; \n  break; \n} \n```", "```cpp\n      else { \n        directionSet.insert(QPair<int,int>(row, column)); \n      } \n    } \n  } \n} \n```", "```cpp\n#include \"OthelloWidget.h\" \n#include \"OthelloWindow.h\" \n#include <QApplication> \n\nint main(int argc, char *argv[]) { \n  QApplication application(argc, argv); \n  OthelloWindow othelloWindow; \n  othelloWindow.show(); \n  return application.exec(); \n} \n```", "```cpp\n#ifndef NACWINDOW_H \n#define NACWINDOW_H \n\n#include \"..\\MainWindow\\MainWindow.h\" \n#include \"NaCWidget.h\" \n\nclass NaCWindow : public MainWindow { \n  Q_OBJECT \n\n  public: \n    NaCWindow(QWidget *parentWidget = nullptr); \n    ~NaCWindow(); \n\n  public: \n    void closeEvent(QCloseEvent *eventPtr) override \n                   {m_nacWidgetPtr->closeEvent(eventPtr);} \n\n  private: \n    NaCWidget* m_nacWidgetPtr; \n}; \n\n#endif // NACWINDOW_H \n```", "```cpp\n#include \"NaCWindow.h\" \n#include <QtWidgets> \n\nNaCWindow::NaCWindow(QWidget *parentWidget /*= nullptr*/) \n :MainWindow(parentWidget) { \n  setWindowTitle(tr(\"Noughts and Crosses\")); \n  resize(1000, 500); \n\n  m_nacWidgetPtr = new NaCWidget(this); \n  setCentralWidget(m_nacWidgetPtr); \n\n  { QMenu* gameMenuPtr = menuBar()->addMenu(tr(\"&Game\")); \n    connect(gameMenuPtr, SIGNAL(aboutToShow()), \n            this, SLOT(onMenuShow())); \n\n    addAction(gameMenuPtr, tr(\"&Nought Starts\"), \n              SLOT(onNoughtStarts()), 0, \n              tr(\"Nought Starts\"), nullptr, tr(\"Nought Starts\"), \n              LISTENER(isNoughtStartsEnabled)); \n\n    addAction(gameMenuPtr, tr(\"&Cross Starts\"), \n              SLOT(onCrossStarts()), 0, \n              tr(\"Cross Starts\"), nullptr, tr(\"Cross Starts\"), \n              LISTENER(isCrossStartsEnabled)); \n\n    gameMenuPtr->addSeparator(); \n\n    addAction(gameMenuPtr, tr(\"&Quit the Game\"), \n              SLOT(onQuit()), \n              QKeySequence(Qt::CTRL + Qt::Key_Q), tr(\"Quit Game\"), \n              nullptr, tr(\"Quit the Game\"), \n              LISTENER(isQuitEnabled)); \n\n    addAction(gameMenuPtr, tr(\"E&xit\"), \n              SLOT(onExit()), QKeySequence::Quit); \n  } \n} \n\nNaCWindow::~NaCWindow() { \n  delete m_nacWidgetPtr; \n} \n```", "```cpp\n#ifndef NACWIDGET_H \n#define NACWIDGET_H \n\n#include \"..\\MainWindow\\GameWidget.h\" \n\n#define ROWS    26 \n#define COLUMNS 26 \n```", "```cpp\nenum Mark {Empty = 0, Nought, Cross}; \n\nclass NaCWidget : public GameWidget { \n  Q_OBJECT \n\n  public: \n    NaCWidget(QWidget* parentWidget); \n\n    void mouseMark(int row, int column); \n    void drawMark(QPainter& painter, \n                  const QRect& markRect, int mark); \n\n  public slots: \n    DEFINE_LISTENER(NaCWidget, isNoughtStartsEnabled); \n    void onNoughtStarts(); \n\n    DEFINE_LISTENER(NaCWidget, isCrossStartsEnabled); \n    void onCrossStarts(); \n\n  private: \n    void checkWinner(int row, int column, Mark mark); \n    int countMarks(int row, int column, int rowStep, \n                   int columnStep, Mark mark); \n\n    Mark m_nextMark; \n}; \n\n#endif // NACWIDGET_H \n```", "```cpp\n#include \"NaCWidget.h\" \n#include <CTime> \n\nNaCWidget::NaCWidget(QWidget* parentWidget) \n :GameWidget(ROWS, COLUMNS, parentWidget) { \n  // Empty. \n} \n```", "```cpp\nbool NaCWidget::isCrossStartsEnabled() { \n  return !isGameInProgress(); \n} \n\nbool NaCWidget::isNoughtStartsEnabled() { \n  return !isGameInProgress(); \n} \n```", "```cpp\nvoid NaCWidget::onNoughtStarts() { \n  setGameInProgress(true); \n  m_nextMark = Nought; \n  update(); \n} \n\nvoid NaCWidget::onCrossStarts() { \n  setGameInProgress(true); \n  m_nextMark = Cross; \n  update(); \n} \n```", "```cpp\nvoid NaCWidget::mouseMark(int row, int column) { \n  set(row, column, m_nextMark); \n  checkWinner(row, column, m_nextMark); \n  m_nextMark = (m_nextMark == Nought) ? Cross : Nought; \n  update(); \n} \n```", "```cpp\nvoid NaCWidget::drawMark(QPainter& painter, \n    const QRect& markRect, int mark) { \n```", "```cpp\n  painter.setPen(Qt::black); \n  switch (mark) { \n    case Nought: \n      painter.drawEllipse(markRect); \n      break; \n```", "```cpp\n    case Cross: \n      painter.drawLine(markRect.topLeft(), \n                       markRect.bottomRight()); \n      painter.drawLine(markRect.topRight(), \n                       markRect.bottomLeft()); \n      break; \n```", "```cpp\n    case Empty: \n      break; \n  } \n} \n```", "```cpp\n    void NaCWidget::checkWinner(int row, int column, Mark mark) { \n```", "```cpp\n  if ((countMarks(row, column, -1, 0, mark) >= 5) || \n```", "```cpp\n      (countMarks(row, column, 0, -1, mark) >= 5) || \n```", "```cpp\n      (countMarks(row, column, -1, 1, mark) >=5)|| \n```", "```cpp\n      (countMarks(row, column, 1, 1, mark) >= 5)) { \n```", "```cpp\n    QMessageBox messageBox(QMessageBox::Information, \n                           tr(\"Victory\"), QString()); \n    QString text; \n    text.sprintf(\"The Winner: %s.\", \n                 (mark == Nought) ? \"Nought\" : \"Cross\"); \n\n    messageBox.setText(text); \n    messageBox.setStandardButtons(QMessageBox::Ok); \n    messageBox.exec(); \n    setGameInProgress(false); \n```", "```cpp\n    clearGrid(); \n    update(); \n  } \n} \n```", "```cpp\nint NaCWidget::countMarks(int row, int column, int rowStep, \n                          int columnStep, Mark mark) { \n  int countMarks = 0; \n```", "```cpp\n    { int currentRow = row, currentColumn = column; \n      while ((currentRow >= 0) && (currentRow < ROWS) && \n             (currentColumn >= 0) && (currentColumn < COLUMNS) && \n             (get(currentRow, currentColumn) == mark)) { \n          ++countMarks; \n          currentRow += rowStep; \n          currentColumn += columnStep; \n         } \n    } \n```", "```cpp\n  { int currentRow = row + rowStep, \n        currentColumn = column + columnStep; \n      while ((currentRow >= 0) && (currentRow < ROWS) && \n           (currentColumn >= 0) && (currentColumn < COLUMNS) && \n           (get(currentRow, currentColumn) == mark)) { \n        ++countMarks; \n        currentRow -= rowStep; \n        currentColumn -= columnStep; \n      } \n     } \n\n    return countMarks; \n  } \n```", "```cpp\n#include \"NaCWidget.h\" \n#include \"NaCWindow.h\" \n#include <QApplication> \n\nint main(int argc, char *argv[]) { \n  QApplication application(argc, argv); \n  NaCWindow mainWindow; \n  mainWindow.show(); \n  return application.exec(); \n} \n```"]