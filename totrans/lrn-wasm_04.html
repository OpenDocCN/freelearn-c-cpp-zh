<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Installing the Required Dependencies</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that you have your development environment set up and you're ready to start writing C, C++, and JavaScript, it's time to add the final piece of the puzzle. In order to generate <kbd>.wasm</kbd> files from our C/C++ code, we need to install and configure the <strong>Emscripten SDK</strong> (<strong>EMSDK</strong>).</p>
<p class="mce-root">In this chapter, we'll discuss the development workflow and talk about how the EMSDK fits into the development process. Detailed instructions will be provided on how to install and configure the EMSDK on each platform, as well as any prerequisites. Once the installation and configuration process is complete, you'll test it out by writing and compiling some C code.</p>
<p class="mce-root">Our goal for this chapter is to understand the following:</p>
<ul>
<li class="mce-root">The overall development workflow when working with WebAssembly</li>
<li class="mce-root">How the EMSDK relates to Emscripten and WebAssembly and why it's needed</li>
<li class="mce-root">How to install the prerequisites for the EMSDK</li>
<li class="mce-root">How to install and configure the EMSDK</li>
<li class="mce-root">How to test the EMSDK to ensure it's working correctly</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The development workflow</h1>
                </header>
            
            <article>
                
<p>The development workflow for WebAssembly is comparable to most other languages that require compilation and a build process. Before getting into the tooling setup, we will cover the development cycle. In this section, we will establish some context for the tooling we will install and configure in the rest of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Steps in the workflow</h1>
                </header>
            
            <article>
                
<p class="mce-root">For this book, we will write C and C++ code and compile it down to a Wasm module, but the workflow will be applicable to any programming language that compiles down to a <kbd>.wasm</kbd> file. The following diagram gives an overview of the process:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b43e1500-5c09-4f8d-a81c-665fad256758.png" style="width:31.00em;height:43.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Steps in the development workflow</div>
<p class="mce-root">This process will be used throughout the book for our examples, so you'll get an idea of how the project structure corresponds to the workflow. We'll use some of the tooling available to expedite and simplify the process, but the steps will still be the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating Tooling into the workflow</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are many editors and tools available to simplify the development process. Fortunately, C/C++ and JavaScript have been around for quite some time, so you can take advantage of the options that suit you best. The list of tools for WebAssembly is considerably shorter, given the shorter duration of which the technology has existed, but they are out there.</p>
<p class="mce-root">The primary tool we'll use, VS Code, offers some excellent and useful features for simplifying the build and development process. In addition to using it for writing our code, we'll utilize VS Code's built-in Tasks feature to build the <kbd>.wasm</kbd> file from C/C++. By creating a <kbd>.vscode/tasks.json</kbd> file in the project root folder, we're able to specify all of the parameters associated with the build step and run it quickly using a keyboard shortcut. In addition to performing a build, we can start and stop a running Node.js process (that is, the local server in the workflow diagram). We'll cover how to add and configure these features in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Emscripten and the EMSDK</h1>
                </header>
            
            <article>
                
<p class="mce-root">We'll use Emscripten to compile our C/C++ code down to <kbd>.wasm</kbd> files. Up to this point, Emscripten has only briefly been mentioned in a general context. Since we'll use this tool and the corresponding Emscripten SDK (EMSDK) in the build process, it's important to understand what each technology is and the part it plays in the development workflow. In this section, we'll describe Emscripten's purpose and discuss its relationship to the EMSDK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Emscripten overview</h1>
                </header>
            
            <article>
                
<p class="mce-root">So what is Emscripten? Wikipedia provides the following definition:</p>
<div class="mce-root packt_quote">"Emscripten is a source-to-source compiler that runs as a back end to the LLVM compiler and produces a subset of JavaScript known as asm.js. It can also produce WebAssembly."</div>
<p class="mce-root">We discussed source-to-source compilers (or transpilers) in the first chapter and used TypeScript as an example. Transpilers convert source code in one programming language to equivalent source code in another programming language. To elaborate on Emscripten running as a backend to the LLVM compiler, we need to provide some additional details about LLVM.</p>
<p class="mce-root">The official website for LLVM (<a href="https://llvm.org">https://llvm.org</a>) defines the LLVM as <em>a collection of modular and reusable compiler and toolchain technologies</em>. There are several sub-projects that make up LLVM, but we'll be focusing on the two that Emscripten utilizes: Clang and the LLVM Core libraries. To understand how these pieces fit together, let's review the design of a three-stage compiler:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fd686aef-f7e8-4aa4-a782-25c68ec02e2a.png" style="width:40.17em;height:35.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Design of a general three-stage compiler</div>
<p class="mce-root">The process is relatively straightforward: three separate stages or <em>ends</em> handle the compilation process. This design allows for different frontends and backends for various programming languages and target architectures and completely decouples the machine code from the source code by using an intermediate representation. Now let's associate each compilation stage with a component of the toolchain we'll use to generate WebAssembly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3a332b22-6a36-4623-b326-dde857731fd7.png" style="width:36.33em;height:39.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Three-stage compilation using the LLVM, Clang, and Emscripten</div>
<p class="mce-root"/>
<p class="mce-root">Clang is used to compile C/C++ down to LLVM's <strong>Intermediate Representation</strong> (<strong>IR</strong>), which Emscripten compiles to a Wasm module (binary format). The two diagrams also demonstrate the relationship between Wasm and machine code. You can think of WebAssembly as a CPU in the browser, with Wasm being the machine code on which it runs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Where does the EMSDK fit in?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Emscripten refers to the toolchain used to compile C and C++ down to <kbd>asm.js</kbd> or WebAssembly. The EMSDK is used to manage the tools in the toolchain and the corresponding configuration. This eliminates the need for complex environment setup and prevents issues with incompatible versions of tooling. By installing the EMSDK, we have all of the tooling we need (with the exception of the prerequisites) to use the Emscripten compiler. The following diagram is a visual representation of the Emscripten toolchain (with the EMSDK shown in dark gray):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c88f7e5e-eefe-454f-a218-816b9caebac5.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Emscripten Toolchain (modified slightly from emscripten.org)</div>
<p class="mce-root">Now that you have a better understanding of Emscripten and the EMSDK, let's move on to the installation process for the prerequisites.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the prerequisites</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before installing and configuring the EMSDK, we'll need to install some prerequisites. You installed two of the prerequisites in <a href="706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml">Chapter 3</a>, <em>Setting Up a Development Environment</em>: Node.js and Git. Each platform has slightly different installation processes and tooling requirements. In this section, we cover the installation process for the prerequisite tooling for each platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common prerequisites</h1>
                </header>
            
            <article>
                
<p class="mce-root">It's possible that you already have all of the prerequisites installed. Here are the three that you'll need regardless of the platform:</p>
<ul>
<li class="mce-root">Git</li>
<li class="mce-root">Node.js</li>
<li class="mce-root">Python 2.7</li>
</ul>
<p class="mce-root">Note the Python version; this is important because installing the wrong version could cause the installation process to fail. If you followed along in <a href="0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml">Chapter 2</a>, <em>Elements of WebAssembly - Wat, Wasm, and the JavaScript API</em>, and installed Node.js and Git, all that's left is to install Python 2.7 and any additional prerequisites specified for your platform. The Python installation process for each platform will be specified in the following subsections.</p>
<div class="mce-root packt_infobox">Python is a high-level programming language used for general-purpose programming. If you'd like to learn more, check out the official website at <a href="https://www.python.org/">https://www.python.org/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the prerequisites on macOS</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are three additional tools you'll need to install prior to installing the EMSDK:</p>
<ul>
<li class="mce-root">Xcode</li>
<li class="mce-root">Xcode Command Line Tools</li>
<li class="mce-root">CMake</li>
</ul>
<p class="mce-root"/>
<p class="mce-root">You can install Xcode from the macOS App Store. If you already had Xcode installed, you can check if the Command Line Tools are installed by going to <span class="packt_screen">Xcode | Preferences | Locations</span> and checking if the <span class="packt_screen">Command Line Tools</span> option has a value. The <span class="packt_screen">Command Line Tools</span> should have already been installed if you installed the Homebrew package manager:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1fec0953-9278-4312-b286-c5ed34ec45e3.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Checking the current version of the Xcode Command Line Tools</div>
<p class="mce-root">If you don't see that, open up Terminal and run this command:</p>
<pre class="mce-root"><strong>xcode-select --install</strong></pre>
<p class="mce-root">Once complete, you can install CMake by running this command:</p>
<pre class="mce-root"><strong>brew install cmake</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Prior to installing Python, run this command:</p>
<pre class="mce-root"><strong>python --version</strong></pre>
<p class="mce-root">If you see <kbd>Python 2.7.xx</kbd> (where <kbd>xx</kbd> is the patch version and can be any number), you're ready to install the EMSDK. If you get an error saying the Python command wasn't found or you see <kbd>Python 3.x.xx</kbd>, I recommend you install <kbd>pyenv</kbd>, a Python Version manager. To install <kbd>pyenv</kbd>, run this command:</p>
<pre class="mce-root"><strong>brew install pyenv</strong></pre>
<p class="mce-root">You'll need to take some additional configuration steps to finalize the installation. Follow the installation instructions for Homebrew at <a href="https://github.com/pyenv/pyenv#homebrew-on-mac-os-x">https://github.com/pyenv/pyenv#homebrew-on-mac-os-x</a>. After installing and configuring <kbd>pyenv</kbd>, run this command to install Python 2.7:</p>
<pre class="mce-root"><strong>pyenv install 2.7.15</strong></pre>
<p class="mce-root">After the installation is complete, run this command:</p>
<pre class="mce-root"><strong>pyenv global 2.7.15</strong></pre>
<p class="mce-root">To ensure you're using the correct version of Python, run this command:</p>
<pre class="mce-root"><strong>python --version</strong></pre>
<p class="mce-root">You should see Python <kbd>2.7.xx</kbd>, where <kbd>xx</kbd> is the patch version (I was seeing <kbd>2.7.10</kbd>, which will work fine).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the prerequisites on Ubuntu</h1>
                </header>
            
            <article>
                
<p class="mce-root">Ubuntu should already have Python 2.7 installed. You can confirm this by running this command:</p>
<pre class="mce-root"><strong>python --version</strong></pre>
<p>If you see Python <kbd>2.7.xx</kbd> (where <kbd>xx</kbd> is the patch version and can be any number), you're ready to install the EMSDK. If you get an error saying the python command wasn't found or you see <kbd>Python 3.x.xx</kbd>, I recommend you install <kbd>pyenv</kbd>, a Python version manager. Before installing <kbd>pyenv</kbd>, check if you have <kbd>curl</kbd> installed. You can do this by running the following command:</p>
<pre><strong>curl --version</strong></pre>
<p class="mce-root"/>
<p>If you see a version number and other information, <kbd>curl</kbd> is installed. If not, you can install <kbd>curl</kbd> by running the following command:</p>
<pre class="mce-root"><strong>sudo apt-get install curl</strong></pre>
<p class="mce-root">Once the <kbd>curl</kbd> installation is complete, run this command to install <kbd>pyenv</kbd>:</p>
<pre class="mce-root"><strong>curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</strong></pre>
<p class="mce-root">After installing and configuring pyenv, run this command to install Python 2.7:</p>
<pre class="mce-root"><strong>pyenv install 2.7.15</strong></pre>
<p>If you encounter build issues, navigate to the <em>Common build problems</em> page at <a href="https://github.com/pyenv/pyenv/wiki/common-build-problems">https://github.com/pyenv/pyenv/wiki/common-build-problems</a>. After the installation is complete, run this command:</p>
<pre class="mce-root"><strong>pyenv global 2.7.15</strong></pre>
<p class="mce-root">To ensure you're using the correct version of Python, run this command:</p>
<pre class="mce-root"><strong>python --version</strong></pre>
<p>You should see <kbd>Python 2.7.xx</kbd>, where <kbd>xx</kbd> is the patch version (I was seeing <kbd>2.7.10</kbd>, which will work fine).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the prerequisites on Windows</h1>
                </header>
            
            <article>
                
<p class="mce-root">The only additional prerequisite for Windows is Python 2.7. Before attempting the installation, run this command:</p>
<pre class="mce-root"><strong>python --version</strong></pre>
<p class="mce-root">If you see <kbd>Python 2.7.xx</kbd> (where <kbd>xx</kbd> is the patch version and can be any number), you're ready to install the EMSDK. If you get an error saying the Python command wasn't found, or you see <kbd>Python 3.x.xx</kbd> and Python 2.7 isn't installed on your system, run this command to install Python 2.7:</p>
<pre class="mce-root"><strong>choco install python2 -y</strong></pre>
<p class="mce-root">If you saw <kbd>Python 3.x.xx</kbd> prior to installing Python 2.7, you should be able to change the current Python version by updating your path. Before attempting the EMSDK installation, run this command to set Python to 2.7:</p>
<pre class="mce-root"><strong>SET PATH=C:\Python27\python.exe</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and configuring the EMSDK</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you have all of the prerequisites installed, you're ready to install the EMSDK. The process for getting the EMSDK up and running is relatively straightforward. In this section, we cover the installation process for the EMSDK and demonstrate how to update your VS Code C/C++ configuration to accommodate for Emscripten.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation process across all platforms</h1>
                </header>
            
            <article>
                
<p class="mce-root">First, select a folder to install the EMSDK. I created a folder at <kbd>~/Tooling</kbd> (or <kbd>C:\Users\Mike\Tooling</kbd> on Windows). In a terminal, <kbd>cd</kbd> into the folder you just created and run this command:</p>
<pre class="mce-root"><strong>git clone https://github.com/juj/emsdk.git</strong></pre>
<p class="mce-root">Once the clone process is complete, follow the instructions to complete the installation from the section below that corresponds to your platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation on macOS and Ubuntu</h1>
                </header>
            
            <article>
                
<p class="mce-root">Once the clone process is complete, run each of the commands from the following code snippet. If you see a message recommending that you run <kbd>git pull</kbd> instead of <kbd>./emsdk update</kbd>, use the <kbd>git pull</kbd> command prior to running the <kbd>./emsdk install latest</kbd> command:</p>
<pre class="mce-root"># Change directory into the EMSDK installation folder<br/><strong>cd emsdk</strong><br/><br/># Fetch the latest registry of available tools<br/><strong>./emsdk update</strong><br/><br/># Download and install the latest SDK tools<br/><strong>./emsdk install latest</strong><br/><br/># Make the latest SDK active for the current user (writes ~/.emscripten file)<br/><strong>./emsdk activate latest</strong><br/><br/># Activate PATH and other environment variables in the current Terminal<br/><strong>source ./emsdk_env.sh</strong></pre>
<p class="mce-root">The <kbd>source ./emsdk_env.sh</kbd> command will activate the environment variables in the current Terminal, which means every time you create a new Terminal instance, you'd have to re-run it. To prevent having to take this step, you can add the following line to your Bash or Zsh configuration file (that is, <kbd>~/.bash_profile</kbd> or <kbd>~/.zshrc</kbd>):</p>
<pre class="mce-root"><strong>source ~/Tooling/emsdk/emsdk_env.sh &gt; /dev/null</strong></pre>
<p class="mce-root">If you installed the EMSDK in a different location, make sure that you update the path to reflect this. Adding this line to your configuration file will run that environment update command automatically so you can start using the EMSDK immediately. To ensure you can use the Emscripten compiler, run this command:</p>
<pre class="mce-root"><strong>emcc --version</strong></pre>
<p class="mce-root">If you see a message with version information, the setup was successful. If you see an error message stating that the command was not found, double-check your configuration. You may have specified an invalid path for the <kbd>emsdk_env.sh</kbd> in your Bash or Zsh configuration file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation and configuration on Windows</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before completing the installation, I recommend you use <strong>PowerShell</strong> going forward. The examples in this book will be using PowerShell inside <kbd>cmder</kbd>. Once the clone process is complete, run each of the commands given in the following code snippet. If you see a message recommending that you run <kbd>git pull</kbd> instead of <kbd>./emsdk update</kbd>, use the <kbd>git pull</kbd> command prior to running the <kbd>./emsdk install latest</kbd> command:</p>
<pre class="mce-root"># Change directory into the EMSDK installation folder<br/><strong>cd emsdk</strong><br/><br/># Fetch the latest registry of available tools<br/><strong>.\emsdk update</strong><br/><br/># Download and install the latest SDK tools<br/><strong>.\emsdk install latest</strong><br/><br/># Make the latest SDK active for the current user (writes ~/.emscripten file)<br/><strong>.\emsdk activate --global latest</strong></pre>
<p>The <kbd>--global</kbd> flag in the <kbd>.\emsdk activate</kbd> command allows you to run <kbd>emcc</kbd> without having to run a script to set the environment variables each session. To ensure you can use the Emscripten compiler, restart your CLI and run this command:</p>
<pre><strong>emcc --version</strong></pre>
<p>If you see a message with version information, the setup was successful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration in VS Code</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you haven't already done so, create a folder that will contain the code samples we'll be working through (the examples use the name <kbd>book-examples</kbd>). Open this folder in VS Code, press the <em>F1</em> key, and select <span class="packt_screen">C/Cpp: Edit Configurations…</span> to create a <kbd>.vscode/c_cpp_properties.json</kbd> file in the root of your project. It should open the file automatically. Add the following line to the <kbd>browse.path</kbd> array: <kbd>"${env:EMSCRIPTEN}/system/include"</kbd>. This will prevent errors being thrown if you include the <kbd>emscripten.h</kbd> header. You may need to manually create the <kbd>browse</kbd> object with a <kbd>path</kbd> entry if it didn't generate one automatically. The following snippet represents the updated configuration file on Ubuntu:</p>
<pre class="mce-root">{<br/>  "name": "Linux",<br/>  "includePath": [<br/>    "/usr/include",<br/>    "/usr/local/include",<br/>    "${workspaceFolder}",<br/>    "${env:EMSCRIPTEN}/system/include"<br/>  ],<br/>  "defines": [],<br/>  "intelliSenseMode": "clang-x64",<br/>  "browse": {<br/>    "path": [<br/>      "/usr/include",<br/>      "/usr/local/include",<br/>      "${workspaceFolder}"<br/>      ],<br/>    "limitSymbolsToIncludedHeaders": true,<br/>    "databaseFilename": ""<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the compiler</h1>
                </header>
            
            <article>
                
<p class="mce-root">After installing and configuring the EMSDK, you'll need to test it to ensure you're able to generate Wasm modules from C/C++ code. The easiest way to test it is to compile some code using the <kbd>emcc</kbd> command and try running it in a browser. In this section, we'll validate the EMSDK installation by writing and compiling some simple C code and evaluating the Wat associated with the <kbd>.wasm</kbd> output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The C code</h1>
                </header>
            
            <article>
                
<p class="mce-root">We'll use some very simple C code to test our compiler installation. We won't need to import any headers or external libraries. We won't use C++ for this test because we need to perform an extra step with C++ to prevent name mangling, which we'll describe in greater detail in <a href="cdf64596-59dd-4805-8509-7315b7760b1e.xhtml">Chapter 6</a>, <em>Interacting with JavaScript and Debugging</em>. The code for this section is located in the <kbd>/chapter-04-installing-deps</kbd> folder of the <kbd>learn-webassembly</kbd> repository. Follow the instructions listed here to test out the EMSDK.</p>
<p class="mce-root">Create a subfolder named <kbd>/chapter-04-installing-deps</kbd> in your <kbd>/book-examples</kbd> folder. Next, create a new file in this folder named <kbd>main.c</kbd> and populate it with the following contents:</p>
<pre class="mce-root">int addTwoNumbers(int leftValue, int rightValue) {<br/>    return leftValue + rightValue;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling the C code</h1>
                </header>
            
            <article>
                
<p class="mce-root">In order to compile a C/C++ file with Emscripten, we'll use the <kbd>emcc</kbd> command. We need to pass some arguments to the compiler to ensure we get a valid output that we can utilize in the browser. To generate a Wasm file from a C/C++ file, the command follows this format:</p>
<pre class="mce-root"><strong>emcc &lt;file.c&gt; -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o &lt;file.wasm&gt;</strong></pre>
<p class="mce-root"/>
<p class="mce-root">Here's a breakdown of each of the arguments for the <kbd>emcc</kbd> command:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 35.6137%"><strong>Argument</strong></td>
<td style="width: 63.3863%"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 35.6137%"><kbd>&lt;file.c&gt;</kbd></td>
<td style="width: 63.3863%"><span>Path of the C or C++ input file that will be compiled down to a Wasm module; we'll replace this with the actual file path when we run the command.</span></td>
</tr>
<tr>
<td style="width: 35.6137%"><kbd><span>-Os</span></kbd></td>
<td style="width: 63.3863%"><span>Compiler optimization level. This optimization flag allows for module instantiation without requiring Emscripten's glue code.</span></td>
</tr>
<tr>
<td style="width: 35.6137%"><kbd>-s WASM=1</kbd></td>
<td style="width: 63.3863%">Tells the compiler to compile code to WebAssembly.</td>
</tr>
<tr>
<td style="width: 35.6137%"><kbd>-s SIDE_MODULE=1</kbd></td>
<td style="width: 63.3863%">Ensures only a <kbd>WebAssembly</kbd> module is output (no glue code).</td>
</tr>
<tr>
<td style="width: 35.6137%"><kbd>-s BINARYEN_ASYNC_COMPILATION=0</kbd></td>
<td style="width: 63.3863%">
<p class="mce-root">From official docs:</p>
<div class="mce-root packt_quote">Whether to compile the wasm asynchronously, which is more efficient and does not block the main thread. This is currently required for all but the smallest modules to run in V8<em>.</em></div>
</td>
</tr>
<tr>
<td style="width: 35.6137%"><kbd>-o &lt;file.wasm&gt;</kbd></td>
<td style="width: 63.3863%">Path of output file <kbd>.wasm</kbd> file. We'll replace this with the desired output path when we run the command.</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">To test if Emscripten is working correctly, open the integrated terminal in VS Code and run the following commands:</p>
<pre class="mce-root"># Ensure you're in the /chapter-04-installing-deps folder:<br/><strong>cd chapter-04-installing-deps</strong><br/><br/># Compile the main.c file to main.wasm:<br/><strong>emcc main.c -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o main.wasm</strong></pre>
<p class="mce-root">It may take a minute to compile the file the first time, but subsequent builds will be much faster. If the compilation was successful, you should see a <kbd>main.wasm</kbd> file in the <kbd>/chapter-04-installing-deps</kbd> folder. If you encounter an error, Emscripten's error message should be descriptive enough to help you correct the issue.</p>
<p class="mce-root">If everything completed successfully, you can view the Wat associated with the <kbd>main.wasm</kbd> file by right-clicking <kbd>main.wasm</kbd> in VS Code's file explorer and selecting <span class="packt_screen">Show WebAssembly</span> from the context menu. The output should look like this:</p>
<pre>(module<br/>  (type $t0 (func (param i32)))<br/>  (type $t1 (func (param i32 i32) (result i32)))<br/>  (type $t2 (func))<br/>  (type $t3 (func (result f64)))<br/>  (import "env" "table" (table $env.table 2 anyfunc))<br/>  (import "env" "memoryBase" (global $env.memoryBase i32))<br/>  (import "env" "tableBase" (global $env.tableBase i32))<br/>  (import "env" "abort" (func $env.abort (type $t0)))<br/>  (func $_addTwoNumbers (type $t1) (param $p0 i32) (param $p1 i32) (result i32)<br/>    get_local $p1<br/>    get_local $p0<br/>    i32.add)<br/>  (func $runPostSets (type $t2)<br/>    nop)<br/>  (func $__post_instantiate (type $t2)<br/>     get_global $env.memoryBase<br/>    set_global $g2<br/>    get_global $g2<br/>    i32.const 5242880<br/>    i32.add<br/>    set_global $g3)<br/>  (func $f4 (type $t3) (result f64)<br/>    i32.const 0<br/>    call $env.abort<br/>    f64.const 0x0p+0 (;=0;))<br/>  (global $g2 (mut i32) (i32.const 0))<br/>  (global $g3 (mut i32) (i32.const 0))<br/>  (global $fp$_addTwoNumbers i32 (i32.const 1))<br/>  (export "__post_instantiate" (func $__post_instantiate))<br/>  (export "_addTwoNumbers" (func $_addTwoNumbers))<br/>  (export "runPostSets" (func $runPostSets))<br/>  (export "fp$_addTwoNumbers" (global 4))<br/>  (elem (get_global $env.tableBase) $f4 $_addTwoNumbers))</pre>
<p class="mce-root">If the compiler ran successfully, you're ready to move on to the next step and write JavaScript code to interact with the module, which we'll cover in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we covered the overall development workflow when working with WebAssembly. In order to generate our <kbd>.wasm</kbd> files, we're using Emscripten, which requires the installation of the EMSDK. Prior to reviewing any installation details, we discussed the technologies under the hood and described how they relate to each other and to WebAssembly. We covered each of the steps required to get EMDSK working locally on your computer. The installation process for the EMSDK on each platform was presented, as well as the installation and configuration instructions for the EMSDK. After installing the EMSDK<span> </span><span>, we tested the compiler (no to). That was the <kbd>emcc</kbd> command we ran in the previous section. U</span><span>sing the</span> <kbd>emcc</kbd> <span>command on a simple C code file to ensure Emscripten was working correctly. In the next chapter, we'll walk through the process of creating and loading your first module!</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">What are the five steps in the development workflow?</li>
<li class="mce-root">Which stage or end does Emscripten represent in the compilation process?</li>
<li class="mce-root">What does IR stand for (LLVM's output)?</li>
<li class="mce-root">What role does the EMSDK play with regard to Emscripten?</li>
<li class="mce-root">Which EMSDK prerequisites are required on all three platforms (macOS, Windows, and Linux)?</li>
<li class="mce-root">Why do you need to run the <kbd>emsdk_env</kbd> script before you can use the Emscripten compiler?</li>
<li class="mce-root">Why do you need to add the <kbd>"${env:EMSCRIPTEN}/system/include"</kbd> path to the C/Cpp configuration file?</li>
<li class="mce-root">What is the command used to compile C/C++ down to Wasm modules?</li>
<li class="mce-root">What does the <kbd>-Os</kbd> compiler flag represent?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li class="mce-root">Emscripten: <a href="http://emscripten.org">http://emscripten.org</a></li>
<li class="mce-root">The LLVM Compiler Infrastructure Project: <a href="https://llvm.org">https://llvm.org</a></li>
<li class="mce-root">C++ programming with Visual Studio Code: <a href="https://code.visualstudio.com/docs/languages/cpp">https://code.visualstudio.com/docs/languages/cpp</a></li>
</ul>


            </article>

            
        </section>
    </body></html>