- en: Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: In this chapter, you will be taught how to communicate with internet servers
    and with sockets in general. First, we will take a look at `QNetworkAccessManager`,
    which makes sending network requests and receiving replies really easy. Building
    on this basic knowledge, we will then use Google's Distance API to get information
    about the distance between two locations and how long it would take to get from
    one to the other. This technique, and the respective knowledge, can also be used
    to include Facebook or Twitter in your application via their respective APIs.
    Then, we will take a look at Qt's Bearer API, which provides information about
    a device's connectivity state. In the last section, you will learn how to use
    sockets to create your own server and clients using TCP or UDP as the network
    protocol.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何与互联网服务器以及一般套接字进行通信。首先，我们将查看 `QNetworkAccessManager`，它使得发送网络请求和接收回复变得非常简单。基于这些基本知识，我们将使用
    Google 的距离 API 来获取两个位置之间的距离以及从一个位置到另一个位置需要多长时间的信息。这种技术和相应的知识也可以用来通过它们的相应 API 将
    Facebook 或 Twitter 包含到您的应用程序中。然后，我们将查看 Qt 的 Bearer API，它提供有关设备连接状态的信息。在最后一节中，您将学习如何使用套接字创建自己的服务器和客户端，使用
    TCP 或 UDP 作为网络协议。
- en: 'The main topics covered in this chapter are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Downloading files using `QNetworkAccessManager`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `QNetworkAccessManager` 下载文件
- en: Using Google's Distance Matrix API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google 的距离矩阵 API
- en: Implementing a TCP chat server and client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 TCP 聊天服务器和客户端
- en: Using UDP sockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UDP 套接字
- en: QNetworkAccessManager
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkAccessManager
- en: All network-related functionality in Qt is implemented in the Qt Network module.
    The easiest way to access files on the internet is to use the `QNetworkAccessManager`
    class, which handles the complete communication between your game and the internet.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 中所有与网络相关的功能都在 Qt 网络模块中实现。访问互联网上的文件最简单的方法是使用 `QNetworkAccessManager` 类，该类处理您游戏与互联网之间的完整通信。
- en: Setting up a local HTTP server
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地 HTTP 服务器
- en: In our next example, we will be downloading a file over HTTP. If you don't have
    a local HTTP server, you can just use any publicly available HTTP or HTTPS resource
    to test your code. However, when you develop and test a network-enabled application,
    it is recommended that you use a private, local network if feasible. This way,
    it is possible to debug both ends of the connection, and errors will not expose
    sensitive data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将通过 HTTP 下载文件。如果您没有本地 HTTP 服务器，您可以使用任何公开可用的 HTTP 或 HTTPS 资源来测试您的代码。然而，当您开发和测试一个网络启用应用程序时，如果可能的话，建议您使用私有、本地网络。这样，您可以调试连接的两端，并且错误不会暴露敏感数据。
- en: If you are not familiar with setting up a web server locally on your machine,
    there are, luckily, a number of all-in-one installers that are freely available.
    These will automatically configure Apache2, MySQL (or MariaDB), PHP, and many
    other servers on your system. On Windows, for example, you can use XAMPP ([https://www.apachefriends.org](https://www.apachefriends.org)),
    or the Uniform Server ([http://www.uniformserver.com](http://www.uniformserver.com));
    on Apple computers, there is MAMP ([https://www.mamp.info](https://www.mamp.info));
    and on Linux, you can open your preferred package manager, search for a package
    called `Apache2` or a similar one, and install it. Alternatively, take a look
    at your distribution's documentation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉在您的机器上本地设置 Web 服务器，幸运的是，有许多免费的全能安装程序可供使用。这些程序将自动配置 Apache2、MySQL（或 MariaDB）、PHP
    以及许多其他服务器。例如，在 Windows 上，您可以使用 XAMPP ([https://www.apachefriends.org](https://www.apachefriends.org))
    或 Uniform Server ([http://www.uniformserver.com](http://www.uniformserver.com))；在苹果电脑上，有
    MAMP ([https://www.mamp.info](https://www.mamp.info))；在 Linux 上，您可以打开您首选的包管理器，搜索名为
    `Apache2` 或类似名称的包，并安装它。或者，查看您发行版的文档。
- en: Before you install Apache on your machine, think about using a virtual machine,
    such as VirtualBox ([http://www.virtualbox.org](http://www.virtualbox.org)) for
    this task. This way, you keep your machine clean, and you can easily try different
    settings for your test server. With multiple virtual machines, you can even test
    the interaction between different instances of your game. If you are on Unix,
    Docker ([http://www.docker.com](http://www.docker.com)) might be worth taking
    a look at.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在机器上安装 Apache 之前，考虑使用虚拟机，例如 VirtualBox ([http://www.virtualbox.org](http://www.virtualbox.org))
    来完成这项任务。这样，您可以保持机器的整洁，并且可以轻松尝试为您的测试服务器设置不同的配置。使用多个虚拟机，您甚至可以测试您游戏的不同实例之间的交互。如果您使用
    Unix 系统，Docker ([http://www.docker.com](http://www.docker.com)) 可能值得一看。
- en: Preparing a URL for testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备测试的URL
- en: 'If you''ve set up a local HTTP server, create a file called `version.txt` in
    the root directory of the installed server. This file should contain a small piece
    of text such as "I am a file on localhost" or something similar. As you might
    have guessed, a real-life scenario could be to check whether there is an updated
    version of your game or application on the server. To test whether the server
    and the file are correctly set up, start a web browser and open `http://localhost/version.txt`.
    You should then see the file''s content:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了一个本地HTTP服务器，请在已安装服务器的根目录下创建一个名为`version.txt`的文件。此文件应包含一小段文本，例如“我是一个本地的文件”或类似的内容。正如你可能已经猜到的，现实生活中的场景可能是检查服务器上是否有你游戏或应用的更新版本。为了测试服务器和文件是否正确设置，启动一个网页浏览器并打开`http://localhost/version.txt`。你应该会看到文件的内容：
- en: '![](img/74b59c2a-3cf3-433b-81ae-7f97a6eb9b2a.png).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/74b59c2a-3cf3-433b-81ae-7f97a6eb9b2a.png).'
- en: If this fails, it may be the case that your server does not allow you to display
    text files. Instead of getting lost in the server's configuration, just rename
    the file to `version.html`. This should do the trick!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这失败了，可能是因为你的服务器不允许你显示文本文件。不要在服务器的配置中迷失方向，只需将文件重命名为`version.html`。这应该会解决问题！
- en: If you don't have an HTTP server, you can use the URL of your favorite website,
    but be prepared to receive HTML code instead of plain text, as the majority of
    websites use HTML. You can also use the `https://www.google.com/robots.txt` URL,
    as it responds with plain text.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有HTTP服务器，你可以使用你最喜欢的网站的URL，但要做好准备接收HTML代码而不是纯文本，因为大多数网站都使用HTML。你也可以使用`https://www.google.com/robots.txt`
    URL，因为它会以纯文本响应。
- en: Time for action – Downloading a file
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 下载文件
- en: Create a Qt Widgets project and add a widget class named `FileDownload`. Add
    a button that will start the download and a plain text edit that will display
    the result. As always, you can look at the code files provided with the book if
    you need any help.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Qt Widgets项目，并添加一个名为`FileDownload`的小部件类。添加一个按钮来启动下载，并添加一个纯文本编辑来显示结果。如往常一样，如果你需要任何帮助，可以查看书中提供的代码文件。
- en: 'Next, enable the Qt Network module by adding `QT += network` to the project
    file. Then, create an instance of `QNetworkAccessManager` in the constructor and
    put it in a private field:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在项目文件中添加`QT += network`来启用Qt网络模块。然后，在构造函数中创建`QNetworkAccessManager`的一个实例并将其放入私有字段中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since `QNetworkAccessManager` inherits `QObject`, it takes a pointer to `QObject`,
    which is used as a parent. Thus, you do not have delete the manager later on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QNetworkAccessManager`继承自`QObject`，它需要一个指向`QObject`的指针，这被用作父对象。因此，你不需要在之后删除管理器。
- en: 'Secondly, we connect the manager''s `finished()` signal to a slot of our choice;
    for example, in our class, we have a slot called `downloadFinished()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将管理器的`finished()`信号连接到我们选择的槽；例如，在我们的类中，我们有一个名为`downloadFinished()`的槽：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to do this because the API of `QNetworkAccessManager` is *asynchronous*.
    This means that none of the network requests, or the read or write operations,
    will block the current thread. Instead, when the data is available or another
    network event occurs, Qt will send a corresponding signal so that you can handle
    the data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须这样做，因为`QNetworkAccessManager`的API是**异步**的。这意味着网络请求、读取或写入操作都不会阻塞当前线程。相反，当数据可用或发生其他网络事件时，Qt会发送一个相应的信号，以便你可以处理数据。
- en: 'Thirdly, we actually request the `version.txt` file from localhost when the
    button is clicked:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，当按钮被点击时，我们实际上从本地主机请求`version.txt`文件：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With `get()`, we send a request to get the contents of the file specified by
    the URL. The function expects a `QNetworkRequest` object, which defines all the
    information needed to send a request over the network. The main information for
    such a request is, naturally the URL of the file. This is the reason `QNetworkRequest`
    takes `QUrl` as an argument in its constructor. You can also set the URL with
    `setUrl()` to a request. If you wish to define a request header (for example,
    a custom user agent), you can use `setHeader()`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get()`，我们向指定的URL发送请求以获取文件内容。该函数期望一个`QNetworkRequest`对象，它定义了通过网络发送请求所需的所有信息。此类请求的主要信息自然是文件URL。这就是为什么`QNetworkRequest`在构造函数中将`QUrl`作为参数。你也可以使用`setUrl()`将URL设置到请求中。如果你希望定义一个请求头（例如，自定义用户代理），可以使用`setHeader()`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `setHeader()` function takes two arguments: the first is a value of the
    `QNetworkRequest::KnownHeaders` enumeration, which holds the most common (self-explanatory)
    headers, such as `LastModifiedHeader` or `ContentTypeHeader`, and the second is
    the actual value. You can also write the header using `setRawHeader()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`setHeader()`函数接受两个参数：第一个是`QNetworkRequest::KnownHeaders`枚举的值，它包含最常见的（自解释）头部，例如`LastModifiedHeader`或`ContentTypeHeader`，第二个是实际值。你也可以使用`setRawHeader()`来编写头部：'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you use `setRawHeader()`, you have to write the header field names yourself.
    Besides this, it behaves like `setHeader()`. A list of all the available headers
    for the HTTP protocol Version 1.1 can be found in section 14 of RFC 2616 ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`setRawHeader()`时，你必须自己编写头部字段名称。除此之外，它表现得像`setHeader()`。所有HTTP协议版本1.1中可用的头部列表可以在RFC
    2616的第14节中找到（[https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14)）。
- en: 'Getting back to our example, with the `get()` function, we requested the `version.txt`
    file from the localhost. All we have to do from now on is wait for the server
    to reply. As soon as the server''s reply is finished, the `downloadFinished()`
    slot will be called that was defined by the preceding connection statement. A
    pointer to a `QNetworkReply` object will be passed as the argument to the slot,
    and we can read the reply''s data and show it in `m_edit`, an instance of `QPlainTextEdit`,
    with the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，使用`get()`函数，我们从本地主机请求了`version.txt`文件。从现在开始，我们只需要等待服务器回复。一旦服务器的回复完成，之前连接语句中定义的`downloadFinished()`槽函数将被调用。一个指向`QNetworkReply`对象的指针将被作为参数传递给槽函数，我们可以使用以下方式读取回复的数据并在`m_edit`中显示，`m_edit`是`QPlainTextEdit`的一个实例：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since `QNetworkReply` inherits `QIODevice`, there are also other possibilities
    to read the content of the reply. For example, you can use `QDataStream` or `QTextStream`
    to read and interpret binary or textual data, respectively. Here, as the fourth
    command, `QIODevice::readAll()` is used to get the full content of the requested
    file in a `QByteArray` object. This is very similar to reading from files, which
    was shown in the previous chapter. The responsibility for the transferred pointer
    to the corresponding `QNetworkReply` lies with us, so we need to delete it at
    the end of the slot. However, be careful and do not call `delete` on the reply
    directly. Always use `deleteLater()`, as the documentation suggests!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QNetworkReply`继承了`QIODevice`，因此还有其他方法可以读取回复的内容。例如，你可以使用`QDataStream`或`QTextStream`分别读取和解释二进制或文本数据。在这里，作为第四个命令，使用`QIODevice::readAll()`在`QByteArray`对象中获取请求文件的完整内容。这与上一章中展示的从文件中读取非常相似。转移给相应`QNetworkReply`的指针的责任在我们这里，因此我们需要在槽函数的末尾删除它。然而，要小心，不要直接调用`delete`。始终使用`deleteLater()`，如文档中建议的那样！
- en: In the previous chapter, we warned you that you shouldn't use `readAll()` to
    read large files, as they can't fit in a single `QByteArray`. The same holds for
    `QNetworkReply`. If the server decides to send you a large response (for example,
    if you try to download a large file), the first portion of the response will be
    saved to a buffer inside the `QNetworkReply` object, and then the download will
    throttle down until you read some data from the buffer. However, you can't do
    that if you only use the `finished()` signal. Instead, you need to use the `QNetworkReply::readyRead()`
    signal and read each portion of the data in order to free the buffer and allow
    more data to be received. We will show how to do this later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们警告你不要使用`readAll()`来读取大文件，因为它们无法适应单个`QByteArray`。对于`QNetworkReply`也是如此。如果服务器决定发送一个大的响应（例如，如果你尝试下载一个大文件），响应的第一部分将被保存到`QNetworkReply`对象内部的缓冲区中，然后下载将减慢速度，直到你从缓冲区中读取一些数据。然而，如果你只使用`finished()`信号，你无法做到这一点。相反，你需要使用`QNetworkReply::readyRead()`信号并按顺序读取数据的每一部分，以便释放缓冲区并允许接收更多数据。我们将在本章后面展示如何做到这一点。
- en: 'The full source code can be found in the FileDownload example bundled with
    this book. If you start the small demo application and click on the Load File
    button, you should see the content of the loaded file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在本书附带的书签下载示例中找到。如果你启动这个小型的演示应用程序并点击加载文件按钮，你应该能看到加载文件的正文内容：
- en: '![](img/6ac7b5b1-1dd1-4022-8c8c-988dbd13bc9c.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ac7b5b1-1dd1-4022-8c8c-988dbd13bc9c.png)'
- en: Have a go hero – Extending the basic file downloader
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄——扩展基本文件下载器
- en: Of course, having to alter the source code in order to download another file
    is far from an ideal approach, so try to extend the dialog by adding a line edit
    in which you can specify the URL you want to download. Also, you can offer a file
    dialog to choose the location where the downloaded file will be saved. The simplest
    way of doing that is to use the `QFileDialog::getSaveFileName()` static function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了下载另一个文件而不得不修改源代码，这远非理想的方法，因此尝试通过添加一行编辑框来扩展对话框，以便您可以指定要下载的URL。此外，您还可以提供一个文件对话框来选择下载文件将保存的位置。实现这一点的最简单方法是使用
    `QFileDialog::getSaveFileName()` 静态函数。
- en: Single network manager per application
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个应用程序一个网络管理器
- en: One single instance of `QNetworkAccessManager` is enough for an entire application.
    For example, you can create an instance of `QNetworkAccessManager` in your main
    window class and pass a pointer to it to all the other places where it's needed.
    For ease of use, you can also create a **singleton** and access the manager through
    that.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整个应用程序来说，只需要一个 `QNetworkAccessManager` 的单例实例。例如，您可以在主窗口类中创建一个 `QNetworkAccessManager`
    实例，并将其指针传递到所有需要它的其他地方。为了方便使用，您还可以创建一个 **单例** 并通过它来访问管理器。
- en: A singleton pattern ensures that a class is instantiated only once. The pattern
    is useful for accessing application-wide configurations or—as in our case—an instance
    of `QNetworkAccessManager`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式确保一个类只被实例化一次。该模式对于访问应用程序范围内的配置或——在我们的案例中——`QNetworkAccessManager` 的实例很有用。
- en: 'A simple template-based approach to create a singleton will look like this
    (as a header file):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基于模板的简单单例创建方法如下（作为一个头文件）：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the source code, you will include that header file and acquire a singleton
    of a class called `MyClass` with this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，您将包含该头文件，并使用以下方式获取名为 `MyClass` 的类的单例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This singleton implementation is not *thread-safe*, meaning that attempting
    to access the instance from multiple threads simultaneously will result in undefined
    behavior. An example of thread-safe implementation of the singleton pattern can
    be found at [https://wiki.qt.io/Qt_thread-safe_singleton](https://wiki.qt.io/Qt_thread-safe_singleton).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单例实现不是 **线程安全** 的，这意味着尝试从多个线程同时访问实例将导致未定义的行为。线程安全单例模式的实现示例可以在 [https://wiki.qt.io/Qt_thread-safe_singleton](https://wiki.qt.io/Qt_thread-safe_singleton)
    找到。
- en: 'If you are using Qt Quick—it will be explained in [Chapter 11](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml),
    *Introduction to Qt Quick*—with `QQmlApplicationEngine`, you can directly use
    the engine''s instance of `QNetworkAccessManager`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Qt Quick——它将在第11章中解释，*Qt Quick 简介*——与 `QQmlApplicationEngine` 一起，您可以直接使用引擎的
    `QNetworkAccessManager` 实例：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Time for action – Displaying a proper error message
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 显示适当的错误消息
- en: If you do not see the content of the file, something went wrong. Just as in
    real life, this can often happen. So, we need to ensure that there is a good error
    handling mechanism in such cases to inform the user about what is going on. Fortunately, `QNetworkReply` offers
    several possibilities to do this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到文件的内容，说明出了问题。就像现实生活中一样，这种情况经常发生。因此，我们需要确保在这种情况下有一个良好的错误处理机制来通知用户发生了什么。幸运的是，`QNetworkReply`
    提供了几个这样做的方法。
- en: 'In the slot called `downloadFinished()`, we first want to check whether an
    error occurred:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `downloadFinished()` 的槽函数中，我们首先想要检查是否发生了错误：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `QNetworkReply::error()` function returns the error that occurred while
    handling the request. The error is encoded as a value of the `QNetworkReply::NetworkError`
    type. The most common errors are probably these:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkReply::error()` 函数返回处理请求时发生的错误。错误被编码为 `QNetworkReply::NetworkError`
    类型的值。最常见的问题可能是这些：'
- en: '| **Error code** | **Meaning** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **错误代码** | **含义** |'
- en: '| `QNetworkReply::ConnectionRefusedError` | The program was not able to connect
    to the server at all (for example, if no server was running) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `QNetworkReply::ConnectionRefusedError` | 程序根本无法连接到服务器（例如，如果没有服务器运行）|'
- en: '| `QNetworkReply::ContentNotFoundError` | The server responded with HTTP error
    code 404, indicating that a page with the requested URL could not be found |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `QNetworkReply::ContentNotFoundError` | 服务器响应了HTTP错误代码404，表示无法找到请求的URL对应的页面|'
- en: '| `QNetworkReply::ContentAccessDenied` | The server responded with HTTP error
    code 403, indicating that you do not have the permission to access the requested
    file |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `QNetworkReply::ContentAccessDenied` | 服务器响应了HTTP错误代码403，表示您没有权限访问请求的文件|'
- en: 'There are more than 30 possible error types, and you can look them up in the
    documentation of the `QNetworkReply::NetworkError` enumeration. However, normally,
    you do not need to know exactly what went wrong. You only need to know whether
    everything worked out—`QNetworkReply::NoError` would be the return value in this
    case—or whether something went wrong. To provide the user with a meaningful error
    description, you can use `QIODevice::errorString()`. The text is already set up
    with the corresponding error message, and we only have to display it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有超过30种可能的错误类型，你可以在`QNetworkReply::NetworkError`枚举的文档中查找它们。然而，通常你不需要确切知道出了什么问题。你只需要知道是否一切顺利——在这种情况下，`QNetworkReply::NoError`将是返回值——或者是否出了问题。为了向用户提供有意义的错误描述，你可以使用`QIODevice::errorString()`。文本已经设置了相应的错误消息，我们只需要显示它：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our example, assuming that we made an error in the URL and wrote `versions.txt`
    by mistake, the application will look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，假设我们在URL中犯了一个错误，错误地写成了`versions.txt`，应用程序将看起来像这样：
- en: '![](img/2689f64f-fc6d-455a-8ae9-2e555f4b55d7.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2689f64f-fc6d-455a-8ae9-2e555f4b55d7.png)'
- en: 'If the request was an HTTP request and the status code is of interest, it can
    be retrieved by `QNetworkReply::attribute()`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求是HTTP请求并且状态码是有兴趣的，可以通过`QNetworkReply::attribute()`检索：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since it returns `QVariant`, you need to use `QVariant::toInt()` to get the
    code as an integer. Besides the HTTP status code, you can query a lot of other
    information through `attribute()`. Take a look at the description of the `QNetworkRequest::Attribute`
    enumeration in the documentation. There, you will also find `QNetworkRequest::HttpReasonPhraseAttribute`,
    which holds a human-readable reason phrase for the HTTP status code, for example,
    "Not Found" if an HTTP error 404 has occurred. The value of this attribute is
    used to set the error text for `QIODevice::errorString()`. So, you can either
    use the default error description provided by `errorString()` or compose your
    own by interpreting the reply's attributes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它返回`QVariant`，你需要使用`QVariant::toInt()`来将代码作为整数获取。除了HTTP状态码之外，你还可以通过`attribute()`查询很多其他信息。查看文档中`QNetworkRequest::Attribute`枚举的描述。在那里，你也会找到`QNetworkRequest::HttpReasonPhraseAttribute`，它包含HTTP状态码的可读原因短语，例如，如果发生HTTP错误404，则为“未找到”。此属性的值用于设置`QIODevice::errorString()`的错误文本。因此，你可以使用`errorString()`提供的默认错误描述，或者通过解释回复的属性来创建自己的描述。
- en: If a download failed and you want to resume it, or if you only want to download
    a specific part of a file, you can use the `Range` header. However, the server
    must support this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下载失败并且你想恢复它，或者如果你只想下载文件的一部分，你可以使用`Range`头。但是，服务器必须支持这一点。
- en: 'In the following example, only the bytes from `300` to `500` will be downloaded:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，只有从`300`到`500`的字节将被下载：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to simulate sending a form on a website, you will usually need to
    send a POST request instead of GET. This is done by using the `QNetworkAccessManager::post()`
    function instead of the `get()` function we used. You will also need to specify
    the payload, for example, using the `QHttpMultiPart` class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要模拟在网站上发送表单，你通常需要发送POST请求而不是GET请求。这是通过使用`QNetworkAccessManager::post()`函数而不是我们使用的`get()`函数来完成的。你还需要指定有效载荷，例如，使用`QHttpMultiPart`类。
- en: Downloading files over FTP
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过FTP下载文件
- en: 'Downloading a file over FTP is as simple as downloading files over HTTP. If
    it is an anonymous FTP server for which you do not need an authentication, just
    use the URL as we did before. Assuming that there is again a file called `version.txt`
    on the FTP server on the localhost, type this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过FTP下载文件与通过HTTP下载文件一样简单。如果是一个不需要认证的匿名FTP服务器，只需像我们之前做的那样使用URL。假设在本地主机的FTP服务器上再次有一个名为`version.txt`的文件，输入以下内容：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s all; everything else stays the same. If the FTP server requires an
    authentication, you''ll get an error; consider this example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部；其他所有内容保持不变。如果FTP服务器需要认证，你会收到一个错误；考虑以下示例：
- en: '![](img/04027ec7-2bca-4612-b610-c09c2ace6802.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04027ec7-2bca-4612-b610-c09c2ace6802.png)'
- en: Likewise, setting the username and password to access an FTP server is easy—either
    write it in the URL, or use the `setUserName()` and `setPassword()` functions
    of `QUrl`. If the server does not use a standard port, you can set the port explicitly
    with `QUrl::setPort()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，设置用户名和密码以访问FTP服务器也很简单——要么将其写入URL，要么使用`QUrl`的`setUserName()`和`setPassword()`函数。如果服务器不使用标准端口，你可以使用`QUrl::setPort()`显式设置端口。
- en: To upload a file to an FTP server, use `QNetworkAccessManager::put()`, which
    takes `QNetworkRequest` as its first argument, calling a URL that defines the
    name of the new file on the server, and the actual data as its second argument,
    which should be uploaded. For small uploads, you can pass the content as `QByteArray`.
    For larger content, it's better to use a pointer to `QIODevice`. Ensure that the
    device is open and stays available until the upload is complete.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件上传到FTP服务器，使用`QNetworkAccessManager::put()`，它将`QNetworkRequest`作为其第一个参数，调用一个URL来定义服务器上新文件的名字，并将实际数据作为其第二个参数，该数据应该被上传。对于小文件上传，你可以传递内容作为`QByteArray`。对于更大的内容，最好使用指向`QIODevice`的指针。确保设备在上传完成前保持打开和可用状态。
- en: Downloading files in parallel
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行下载文件
- en: A very important note concerning `QNetworkAccessManager` is the fact that it
    works asynchronously. This means that you can post a network request without blocking
    the main event loop, and this is what keeps the GUI responsive. If you post more
    than one request, they are put in the manager's queue. Depending on the protocol
    used, they may be processed in parallel. If you are sending HTTP requests, normally
    up to six requests will be handled at a time. If more requests are queued, they
    will be automatically processed later. This will not block the application, as `QNetworkAccessManager`
    uses threads internally.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`QNetworkAccessManager`的一个非常重要的注意事项是它以异步方式工作。这意味着你可以发送网络请求而不阻塞主事件循环，这正是保持GUI响应的原因。如果你发送多个请求，它们将被放入管理器的队列中。根据使用的协议，它们可能会并行处理。如果你发送HTTP请求，通常一次最多处理六个请求。如果有更多请求排队，它们将自动稍后处理。这不会阻塞应用程序，因为`QNetworkAccessManager`内部使用线程。
- en: There is really no need to encapsulate `QNetworkAccessManager` in a thread;
    however, unfortunately, this unnecessary approach is frequently recommended all
    over the internet. Really, don't move `QNetworkAccessManager` to a thread unless
    you know exactly what you are doing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上没有必要在线程中封装`QNetworkAccessManager`；然而，遗憾的是，这种不必要的做法在互联网上被频繁推荐。实际上，除非你确切知道你在做什么，否则不要将`QNetworkAccessManager`移动到线程中。
- en: If you send multiple requests, the slot connected to the manager's `finished()`
    signal is called in an arbitrary order, depending on how quickly a request gets
    a reply from the server. This is why you need to know to which request a reply
    belongs. This is one reason why every `QNetworkReply` carries its related `QNetworkRequest`.
    It can be accessed through `QNetworkReply::request()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发送多个请求，连接到管理器`finished()`信号的槽位将以任意顺序被调用，这取决于请求从服务器获得回复的速度。这就是为什么你需要知道回复属于哪个请求。这也是为什么每个`QNetworkReply`都携带其相关的`QNetworkRequest`的原因。它可以通过`QNetworkReply::request()`访问。
- en: Even if the determination of the replies and their purpose may work for a small
    application in a single slot, it will quickly get large and confusing if you send
    a lot of requests with different purposes. It would be better to connect requests
    to multiple slots that are specialized for a given task. Fortunately, this can
    be achieved very easily.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使确定回复及其目的可能适用于小型应用程序的单个槽位，如果你发送大量具有不同目的的请求，它将很快变得庞大且混乱。将请求连接到针对特定任务专门化的多个槽位会更好。幸运的是，这可以非常容易地实现。
- en: 'Any method that adds a request to `QNetworkAccessManager` (such as `get()`)
    returns a pointer to `QNetworkReply`. Using this pointer, you can then connect
    the reply''s signals to your specific slots. For example, if you have several
    URLs, and you want to save all linked images from these sites to your hard drive,
    you request all web pages via `QNetworkAccessManager::get()` and connect their
    replies to a slot specialized for parsing the received HTML. If links to the images
    are found, this slot will request them again with `get()`. This time, however,
    the replies to these requests will be connected to a second slot, which is designed
    for saving the images to the disk. Thus, you can separate the two tasks: parsing
    HTML and saving data to a local drive.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任何向`QNetworkAccessManager`添加请求的方法（如`get()`）都返回一个指向`QNetworkReply`的指针。使用这个指针，你可以将回复的信号连接到你的特定槽位。例如，如果你有多个URL，并且你想将这些网站的所有链接图片保存到你的硬盘上，你可以通过`QNetworkAccessManager::get()`请求所有网页，并将它们的回复连接到一个专门用于解析接收到的HTML的槽位。如果找到图片链接，这个槽位将再次使用`get()`请求它们。然而，这次，这些请求的回复将连接到第二个槽位，该槽位是为将图片保存到磁盘而设计的。因此，你可以分离这两个任务：解析HTML和将数据保存到本地驱动器。
- en: The most important signals of `QNetworkReply` are discussed next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个将讨论`QNetworkReply`最重要的信号。
- en: The finished signal
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成后的信号
- en: The `finished()` signal is an equivalent of the `QNetworkAccessManager::finished()`
    signal that we used earlier. It is triggered as soon as a reply is returned—successfully
    or not. After this signal is emitted, neither the reply's data nor its metadata
    will be altered any more. With this signal, you are now able to connect a reply
    to a specific slot. This way, you can realize the scenario on saving images that
    was outlined in the previous section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one problem remains: if you post simultaneous requests, you do not'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: know which one has finished and thus called the connected slot. Unlike `QNetworkAccessManager::finished()`,
    `QNetworkReply::finished()` does not pass a pointer to `QNetworkReply`; this would
    actually be a pointer to itself in this case. We've already had a similar problem
    in [Chapter 3](ebffc011-752f-4dbe-a383-0917a002841d.xhtml), *Qt GUI Programming*,
    so let's remember how we can deal with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick solution to solve this problem is to use `sender()`. It returns a pointer
    to the `QObject` instance that has called the slot. Since we know that it was
    `QNetworkReply`, we can write the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, we needed to cast the `QObject` pointer returned by `sender()`
    to a pointer of the `QNetworkReply` type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you're casting classes that inherit `QObject`, use `qobject_cast`.
    Unlike `dynamic_cast`, it does not use RTTI and works across the dynamic library
    boundaries.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Although we can be pretty confident that the cast will work, do not forget to
    check whether the pointer is valid. If it is a null pointer, exit the slot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Writing the OOP conform code using QSignalMapper
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more elegant way that does not rely on `sender()` would be to use `QSignalMapper`
    to receive the reply object in the argument of the slot. First, you need to add
    the `QSignalMapper *m_imageFinishedMapper` private field to your class. When you
    call `QNetworkAccessManager::get()` to request each image, set up the mapper as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In a prominent place, most likely the constructor of the class, connect the
    mapper''s `map()` signal to a custom slot. Take this example into consideration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now your slot receives the reply object as the argument:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What just happened?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we posted the request and fetched the pointer to the `QNetworkReply`
    object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Then, we connected the reply's finished signal to the mapper's slot `map()`.
    Next, we called the `setMapping()` method of the mapper to indicate that the sender
    itself should be
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: sent as the slot's argument. The effect is very similar to the direct use of
    the `QNetworkAccessManager::finished(QNetworkReply *reply)` signal, but this way,
    we can use multiple slots dedicated to different purposes (with a separate mapper
    corresponding to each slot), all served by a single `QNetworkAccessManager` instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`QSignalMapper` also allows you to map with `int` or `QString` as an identifier
    instead of `QObject *`, as used in the preceding code. So, you can rewrite the
    example and use the URL to identify the corresponding request.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSignalMapper`还允许您使用`int`或`QString`作为标识符，而不是像前面代码中使用`QObject *`。因此，您可以重写示例并使用URL来识别相应的请求。'
- en: The error signal
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误信号
- en: Instead of dealing with errors in the slot connected to the `finished()` signal,
    you can use the reply's `error()` signal, which passes the error of the `QNetworkReply::NetworkError`
    type to the slot. After the `error()` signal has been emitted, the `finished()`
    signal will, most likely, also be emitted shortly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在连接到`finished()`信号的槽中处理错误，也可以使用回复的`error()`信号，它将`QNetworkReply::NetworkError`类型的错误传递到槽中。在发出`error()`信号后，`finished()`信号很可能会很快发出。
- en: The readyRead signal
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: readyRead信号
- en: 'Until now, we have used the slot connected to the `finished()` signal to get
    the reply''s content. This works perfectly if you are deal with small files. However,
    this approach is unsuitable when dealing with large files, as they will unnecessarily
    bind too many resources. For larger files, it is better to read and save the transferred
    data as soon as it is available. We are informed by `QIODevice::readyRead()` whenever
    new data is available to be read. So, for large files, you should use the following
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用连接到`finished()`信号的槽来获取回复的内容。如果您处理的是小文件，这种方法工作得很好。然而，当处理大文件时，这种方法不适用，因为它们会不必要地绑定太多资源。对于大文件，最好在数据可用时立即读取并保存传输的数据。每当有新数据可供读取时，我们都会通过`QIODevice::readyRead()`得到通知。因此，对于大文件，您应该使用以下代码：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will help you connect the reply''s `readyRead()` signal to a slot, set
    up `QFile`, and open it. In the connected slot, type in the following snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您连接回复的`readyRead()`信号到槽，设置`QFile`并打开它。在连接的槽中，输入以下代码片段：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, you can fetch the content, which has been transferred so far, and save
    it to the (already open) file. This way, the resources needed are minimized. Don't
    forget to close the file after the `finished()` signal is emitted.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以获取到目前为止已传输的内容，并将其保存到（已打开的）文件中。这样，所需资源最小化。别忘了在发出`finished()`信号后关闭文件。
- en: 'In this context, it would be helpful if you knew upfront the size of the file
    you want to download. With this information, we can check upfront whether there
    is enough space left on the disk. We can use `QNetworkAccessManager::head()` for
    this purpose. It behaves like the `get()` function, but it does not request the
    content of the file. Only the headers are transferred, and if we are lucky, the
    server sends the `Content-Length` header, which holds the file size in bytes.
    To get that information, we type this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果您事先知道要下载的文件大小，将会很有帮助。有了这些信息，我们可以提前检查磁盘上是否有足够的空间。我们可以使用`QNetworkAccessManager::head()`来完成这个目的。它就像`get()`函数一样，但它不会请求文件的内容。只传输头部信息，如果幸运的话，服务器会发送`Content-Length`头部信息，其中包含文件大小（以字节为单位）。为了获取这些信息，我们输入以下内容：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Time for action – Showing the download progress
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 - 显示下载进度
- en: Especially when a big file is downloaded, the user usually wants to know how
    much data has already been downloaded and approximately how long it will take
    for the download to finish.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在下载大文件时，用户通常想知道已经下载了多少数据，以及下载完成大约需要多长时间。
- en: 'In order to achieve this, we can use the reply''s `downloadProgress()` signal.
    As the first argument, it passes the information on how many bytes have already
    been received and as the second argument, how many bytes there are in total. This
    gives us the possibility to indicate the progress of the download with `QProgressBar`.
    As the passed arguments are of the `qint64` type, we can''t use them directly
    with `QProgressBar`, as it only accepts `int`. So, in the connected slot, we can
    do the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用回复的`downloadProgress()`信号。作为第一个参数，它传递已接收的字节数信息，作为第二个参数，传递总字节数。这使我们能够使用`QProgressBar`来指示下载进度。由于传递的参数是`qint64`类型，我们不能直接使用它们与`QProgressBar`一起，因为它只接受`int`。因此，在连接的槽中，我们可以执行以下操作：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What just happened?
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'First, we calculate the percentage of the download progress. The calculated
    `progress` value will range from 0 (0%) to 1 (100%). Then, we set the new value
    for the progress bar where `progressBar` is the pointer to this bar. However,
    what value will `progressBar->maximum()` have and where do we set the range for
    the progress bar? What is nice is that you do not have to set it for every new
    download. It is only done once, for example, in the constructor of the class containing
    the bar. As range values, we would recommend this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算下载进度的百分比。计算出的`progress`值将在0（0%）到1（100%）之间。然后，我们为进度条设置新的值，其中`progressBar`是指向此进度条的指针。然而，`progressBar->maximum()`将有什么值，我们在哪里设置进度条的取值范围？令人高兴的是，你不必为每次新的下载设置它。它只需要设置一次，例如，在包含进度条的类的构造函数中。作为取值范围，我们建议使用以下值：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The reason is that if you take, for example, a range of 0 to 100 and the progress
    bar is 500 pixels wide, the bar would jump 5 pixels forward for every value change.
    This will look ugly. To get a smooth progression where the bar expands by 1 pixel
    at a time, a range of 0 to 99.999.999 would surely work, but it would be highly
    inefficient. This is because the current value of the bar would change a lot without
    any graphical depiction. So, the best value for the range would be 0 to the actual
    bar's width in pixels. Unfortunately, the width of the bar can change depending
    on the actual widget width, and frequently querying the actual size of the bar
    every time the value changes is also not a good solution. Why 2048, then? It's
    just a nice round number that is bigger than any screen resolution we're likely
    to get. This ensures that the progress bar runs smoothly, even if it is fully
    expanded. If you are targeting smaller devices, choose a smaller, more appropriate
    number.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，如果你以0到100的范围为例，并且进度条宽度为500像素，每次值的变化都会使进度条前进5像素。这看起来会很丑。为了得到平滑的进度，每次进度条只增加1像素，范围应该是0到99.999.999，这肯定可以工作，但效率会非常高。这是因为进度条当前值的变化会很大，而没有任何图形表示。因此，最佳的范围值应该是0到实际进度条宽度的像素数。不幸的是，进度条的宽度可能会根据实际小部件的宽度而变化，并且每次值变化时频繁查询实际大小也不是一个好的解决方案。那么，为什么是2048呢？它只是一个比我们可能得到的任何屏幕分辨率都要大的漂亮的整数。这确保了进度条即使在完全展开的情况下也能平滑运行。如果你针对的是较小的设备，请选择一个更小、更合适的数字。
- en: 'To be able to calculate the time remaining for the download to finish, you
    have to start a timer. In this case, use `QElapsedTimer`. After posting the request
    with `QNetworkAccessManager::get()`, start the timer by calling `QElapsedTimer::start()`.
    Assuming that the timer is called `m_timer`, the calculation will be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够计算下载完成剩余时间，你必须开始一个计时器。在这种情况下，使用`QElapsedTimer`。在通过`QNetworkAccessManager::get()`发布请求后，通过调用`QElapsedTimer::start()`来启动计时器。假设计时器被命名为`m_timer`，计算方法如下：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`QElapsedTimer::elapsed()` returns the milliseconds that are counted from the
    moment the timer is started. Assuming that the download progress is linear, the
    ratio of the remaining time to the elapsed time equals `(1.0 - progress) / progress`.
    For example, if `progress` is 0.25 (25%), the expected remaining time will be
    three times bigger than the elapsed time: `(1.0 - 0.25) / 0.25) = 3`. If you divide
    the result by 1,000 and round it to the nearest integer, you''ll get the remaining
    time in seconds.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`QElapsedTimer::elapsed()`返回从计时器开始时计数的毫秒数。假设下载进度是线性的，剩余时间与经过时间的比率等于`(1.0 -
    progress) / progress`。例如，如果`progress`是0.25（25%），预期的剩余时间将是经过时间的三倍：`(1.0 - 0.25)
    / 0.25) = 3`。如果你将结果除以1,000并四舍五入到最接近的整数，你将得到剩余时间（以秒为单位）。'
- en: '`QElapsedTimer` is not to be confused with `QTimer`. `QTimer` is used to call
    a slot after a certain amount of time has passed. `QElapsedTimer` is merely a
    convenience class that is able to remember the start time and calculate the elapsed
    time by subtracting the start time from the current time.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`QElapsedTimer`不要与`QTimer`混淆。`QTimer`用于在经过一定时间后调用槽。`QElapsedTimer`仅仅是一个方便的类，能够记住开始时间并通过从当前时间减去开始时间来计算经过的时间。'
- en: Using a proxy
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理
- en: If you want to use a proxy, you first have to set up `QNetworkProxy`. You can
    define the type of proxy with `setType()`. As arguments, you will most likely
    want to pass `QNetworkProxy::Socks5Proxy` or `QNetworkProxy::HttpProxy`. Then,
    set up the hostname with `setHostName()`, the username with `setUserName()`, and
    the password with `setPassword()`. The last two properties are, of course, only
    needed if the proxy requires authentication. Once the proxy is set up, you can
    set it to the access manager via `QNetworkAccessManager::setProxy()`. Now, all
    new requests will use this proxy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用代理，首先你需要设置`QNetworkProxy`。你可以使用`setType()`方法来定义代理的类型。作为参数，你很可能会传递`QNetworkProxy::Socks5Proxy`或`QNetworkProxy::HttpProxy`。然后，使用`setHostName()`设置主机名，使用`setUserName()`设置用户名，使用`setPassword()`设置密码。当然，后两个属性只有在代理需要认证时才需要。一旦设置了代理，你可以通过`QNetworkAccessManager::setProxy()`将其设置到访问管理器中。现在，所有新的请求都将使用这个代理。
- en: Connecting to Google, Facebook, Twitter, and co.
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到Google、Facebook、Twitter等。
- en: Since we discussed `QNetworkAccessManager`, you now have the knowledge you need
    to integrate Facebook, Twitter, or similar sites into your application. They all
    use the HTTPS protocol and simple requests in order to retrieve data from them.
    For Facebook, you have to use the so-called Graph API. It describes which interfaces
    are available and what options they offer. If you want to search for users who
    are called **Helena**, you have to request `https://graph.facebook.com/search?q=helena&type=user`.
    Of course, you can do this with `QNetworkManager`. You will find more information
    about the possible requests to Facebook at [https://developers.facebook.com/docs/graph-api](https://developers.facebook.com/docs/graph-api).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们讨论了`QNetworkAccessManager`，你现在有了将Facebook、Twitter或类似网站集成到你的应用程序所需的知识。它们都使用HTTPS协议和简单的请求来从它们那里检索数据。对于Facebook，你必须使用所谓的Graph
    API。它描述了哪些接口可用以及它们提供了哪些选项。如果你想搜索名为**Helena**的用户，你必须请求`https://graph.facebook.com/search?q=helena&type=user`。当然，你可以使用`QNetworkManager`来做这件事。你可以在[https://developers.facebook.com/docs/graph-api](https://developers.facebook.com/docs/graph-api)找到有关Facebook可能请求的更多信息。
- en: If you wish to display tweets in your game, you have to use Twitter's REST or
    Search API. Assuming that you know the ID of a tweet you would like to display,
    you can get it through `https://api.twitter.com/1.1/statuses/show.json?id=12345`,
    where `12345` is the actual ID for the tweet. If you would like to find tweets
    mentioning `#Helena`, you would write `https://api.twitter.com/1.1/search/tweets.json?q=%23Helena`.
    You can find more information about the parameters and the other possibilities
    of Twitter's API at [https://developer.twitter.com/en/docs](https://developer.twitter.com/en/docs).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在游戏中显示推文，你必须使用Twitter的REST或搜索API。假设你知道你想显示的推文的ID，你可以通过`https://api.twitter.com/1.1/statuses/show.json?id=12345`来获取它，其中`12345`是推文的实际ID。如果你想找到提到`#Helena`的推文，你可以写`https://api.twitter.com/1.1/search/tweets.json?q=%23Helena`。你可以在[https://developer.twitter.com/en/docs](https://developer.twitter.com/en/docs)找到有关参数和其他Twitter
    API可能性的更多信息。
- en: Since both Facebook and Twitter need an authentication to use their APIs, we
    will take a look at Google instead. Let's use Google's Distance Matrix API in
    order to get information about how long it would take for us to get from one city
    to another. The technical documentation for the API we will use can be found at
    [https://developers.google.com/maps/documentation/distancematrix](https://developers.google.com/maps/documentation/distancematrix).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Facebook和Twitter都需要认证才能使用它们的API，我们将看看Google。让我们使用Google的距离矩阵API来获取从一个城市到另一个城市所需时间的信息。我们将使用的API的技术文档可以在[https://developers.google.com/maps/documentation/distancematrix](https://developers.google.com/maps/documentation/distancematrix)找到。
- en: Time for action – Using Google's Distance Matrix API
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用Google的距离矩阵API
- en: The GUI for this example is kept simple—the source code is attached with the
    book. It consists of two line edits (`ui->from` and `ui->to`) that allow you to
    enter the origin and destination of the journey. It also provides you with a combobox
    (`ui->vehicle`) that allows you to choose a mode of transportation—whether you
    want to drive a car, ride a bicycle, or walk—a push button (`ui->search`) to start
    the request, and a text edit, or (`ui->result`) to show the results.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的GUI保持简单——源代码附在书中。它由两个行编辑器（`ui->from`和`ui->to`）组成，允许你输入旅程的起点和终点。它还提供了一个组合框（`ui->vehicle`），允许你选择一种交通方式——无论是开车、骑自行车还是步行——一个按钮（`ui->search`）来启动请求，以及一个文本编辑器（或`ui->result`）来显示结果。
- en: 'It looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '![](img/89fd5b76-fce6-4445-80d3-2f59cbdd13e0.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89fd5b76-fce6-4445-80d3-2f59cbdd13e0.png)'
- en: '`MainWindow`—a subclass of `QMainWindow`—is the application''s main class that
    holds two private members: `m_network_manager`, which is a pointer to `QNetworkAccessManager`,
    and `m_reply`, which is a pointer to `QNetworkReply`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow` 是 `QMainWindow` 的一个子类，是应用程序的主要类，包含两个私有成员：`m_network_manager`，它是一个指向
    `QNetworkAccessManager` 的指针，以及 `m_reply`，它是一个指向 `QNetworkReply` 的指针。'
- en: Time for action – Constructing the query
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 构建查询
- en: 'Whenever the button is pressed, the `sendRequest()` slot is called:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每当按钮被按下时，就会调用 `sendRequest()` 槽：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this slot, we first check whether there is an old request, which was stored
    in `m_reply`, and whether it is still running. If that is `true`, we abort the
    old request, as we are about to schedule a new one. Then, we also wipe out the
    result of the last request by calling `QPlainTextEdit::clear()` on the text edit.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个槽中，我们首先检查是否有旧请求，该请求存储在 `m_reply` 中，并且它是否仍在运行。如果是 `true`，我们将终止旧请求，因为我们即将安排一个新的请求。然后，我们通过在文本编辑上调用
    `QPlainTextEdit::clear()` 来清除上一次请求的结果。
- en: 'Next, we will construct the URL for the request. We can do this by composing
    the string by hand where we add the query parameters to the base URL similar to
    the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建请求的 URL。我们可以通过手动组合字符串来完成此操作，将查询参数添加到基本 URL 中，如下所示：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Besides the problem that this quickly becomes hard to read when we include
    multiple parameters, it is also rather error-prone. The values of the line edits
    have to be encoded to fit the criteria for a valid URL. For every user value,
    we, therefore, have to call `QUrl::toPercentEncoding()` explicitly. A much better
    approach, which is easier to read and less error-prone, is to use `QUrlQuery`.
    It circumvents the problem that may result when you forget to encode the data.
    So, we do this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当我们包含多个参数时这很快变得难以阅读的问题之外，它还相当容易出错。行编辑的值必须编码以符合有效 URL 的标准。因此，对于每个用户值，我们都必须显式调用
    `QUrl::toPercentEncoding()`。一个更好的方法，它更容易阅读且错误更少，是使用 `QUrlQuery`。它避免了忘记编码数据时可能产生的问题。因此，我们这样做：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The usage is pretty clear: we create an instance and then add the query parameters
    with `addQueryItem()`. The first argument is taken as the key and the second as
    the value resulting in a string such as "key=value". The value will be automatically
    encoded when we use `QUrlQuery` in conjunction with `QUrl`. Other benefits of
    using `QUrlQuery` are that we can check whether we have already set a key with
    `hasQueryItem()`, taking the key as an argument, or removed a previously set key
    by calling `removeQueryItem()`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法相当清晰：我们创建一个实例，然后使用 `addQueryItem()` 添加查询参数。第一个参数被视为键，第二个参数被视为值，结果是一个如 "key=value"
    的字符串。当我们将 `QUrlQuery` 与 `QUrl` 一起使用时，值将自动编码。使用 `QUrlQuery` 的其他好处是，我们可以使用 `hasQueryItem()`
    检查是否已经设置了键，将键作为参数传递，或者通过调用 `removeQueryItem()` 删除之前设置的键。
- en: 'Let''s review which parameters we have set. The `sensor` key is set to `false`
    as we are not using a GPS device to locate our position. The `language` key is
    set to `English`, and for units, we favor metric over imperial. Then, the search-related
    parameters are set. The `origins` key holds the places we want to start from.
    As its value, the text of the `ui->from` line edit is chosen. If you want to query
    multiple starting positions, you just have to combine them using `|`. Equivalent
    to the origins, we set up the value for destinations. Last, we pass the value
    of the combo box to mode, which defines whether we want to go by a car, bicycle,
    or whether we want to walk. Next, we execute the request:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们设置了哪些参数。`sensor` 键设置为 `false`，因为我们没有使用 GPS 设备来确定我们的位置。`language` 键设置为
    `English`，对于单位，我们更倾向于公制而不是英制。然后，我们设置了与搜索相关的参数。`origins` 键包含我们想要开始的地点。其值是 `ui->from`
    行编辑的文本。如果你想要查询多个起始位置，你只需使用 `|` 将它们组合起来。与起点等效，我们为目的地设置了值。最后，我们将组合框的值传递给模式，这定义了我们是想开车、骑自行车还是步行。接下来，我们执行请求：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create `QUrl` that contains the address to which the query should be posted.
    By including `json` at the end, we define that the server should transfer its
    reply using the JSON format. Google also provides the option for us to get the
    result as XML. To achieve this, simply replace `json` with `xml`. However, since
    the APIs of Facebook and Twitter return JSON, we will use this format.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个包含查询应发送到的地址的 `QUrl`。通过在末尾包含 `json`，我们定义服务器应使用 JSON 格式传输其响应。Google 还为我们提供了将结果作为
    XML 获取的选项。要实现这一点，只需将 `json` 替换为 `xml`。然而，由于 Facebook 和 Twitter 的 API 返回 JSON，我们将使用此格式。
- en: Then, we set the previously constructed `query` to the URL by calling `QUrl::setQuery()`.
    This automatically encodes the values, so we do not have to worry about that.
    Last, we post the request by calling the `get()` function and store the returned
    `QNetworkReply` in `m_reply`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `QUrl::setQuery()` 将之前构建的 `query` 设置到 URL 中。这会自动编码值，所以我们不需要担心这一点。最后，我们通过调用
    `get()` 函数发布请求，并将返回的 `QNetworkReply` 存储在 `m_reply` 中。
- en: Time for action – Parsing the server's reply
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 解析服务器的响应
- en: 'In the constructor, we have connected the manager''s `finished()` signal to
    the `finished()` slot of the `MainWindow` class. It will thus be called after
    the request has been posted:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将管理器的 `finished()` 信号连接到了 `MainWindow` 类的 `finished()` 插槽。因此，它将在请求发布后被调用：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we check whether the reply that was passed is the one that we have requested
    through `m_network_manager`. If this is not the case, we delete the `reply` and
    exit the function. This can happen if a reply was aborted by the `sendRequest()`
    slot. Since we are now sure that it is our request, we set `m_reply` to `nullptr`,
    because we have handled it and do not need this information any more:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查传入的响应是否是通过 `m_network_manager` 请求的。如果不是这种情况，我们删除 `reply` 并退出函数。这可能发生在
    `sendRequest()` 插槽取消响应的情况下。由于我们现在确定这是我们请求的，我们将 `m_reply` 设置为 `nullptr`，因为我们已经处理了它，不再需要这个信息：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we check whether an error occurred, and if it did, we put the reply''s
    error string in the text edit, delete the reply, and exit the function. After
    this, we can finally start decoding the server''s response:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否发生了错误，如果发生了，我们将响应的错误字符串放入文本编辑中，删除响应，并退出函数。之后，我们最终可以开始解码服务器的响应：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With `readAll()`, we get the content of the server''s reply. Since the transferred
    data is not large, we do not need to use partial reading with `readyRead()`. The
    content is then converted to `QJsonDocument` using the `QJsonDocument::fromJson()`
    static function, which takes `QByteArray` as an argument and parses its data.
    If the document is not an object, the server''s reply wasn''t valid, as the API
    call should respond with a single object. In this case, we show an error message
    on the text edit, delete the reply, and exit the function. Let''s look at the
    next part of the code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readAll()`，我们可以获取服务器的响应内容。由于传输的数据量不大，我们不需要使用 `readyRead()` 进行部分读取。然后，我们使用
    `QJsonDocument::fromJson()` 静态函数将内容转换为 `QJsonDocument`，该函数接受 `QByteArray` 作为参数并解析其数据。如果文档不是一个对象，那么服务器的响应是不有效的，因为
    API 调用应该响应一个单一的对象。在这种情况下，我们在文本编辑中显示错误消息，删除响应，并退出函数。让我们看看代码的下一部分：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we have now ensured that there is an object, we store it in `obj`. Furthermore,
    due to the API, we also know that the object holds the `origin_addresses` and
    `destination_addresses` keys. Both values are arrays that hold the requested origins
    and destinations. From this point on, we will skip any tests if the values exist
    and are valid since we trust the API. The object also holds a key called `status`,
    whose value can be used to check whether the query may have failed and if yes,
    why. The last two lines of the source code store the origins and destinations
    in two variables. With `obj.value("origin_addresses")`, we get `QJsonValue` that
    holds the value of the pair specified by the `origin_addresses` key, and `QJsonValue::toArray()`
    converts this value to `QJsonArray`. The returned JSON file for a search requesting
    the distance from Warsaw or Erlangen to Birmingham will look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经确保存在一个对象，我们将其存储在 `obj` 中。此外，由于 API，我们还知道该对象包含 `origin_addresses` 和 `destination_addresses`
    键。这两个值都是包含请求的来源和目的地的数组。从这一点开始，如果值存在且有效，我们将跳过任何测试，因为我们信任 API。该对象还包含一个名为 `status`
    的键，其值可以用来检查查询是否可能失败，如果是，原因是什么。源代码的最后两行将来源和目的地存储在两个变量中。使用 `obj.value("origin_addresses")`，我们得到一个
    `QJsonValue`，它包含由 `origin_addresses` 键指定的值的对，而 `QJsonValue::toArray()` 将此值转换为
    `QJsonArray`。对于请求从华沙或埃尔兰根到伯明翰的距离的搜索，返回的 JSON 文件将看起来像这样：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `rows` key holds the actual results as an array. The first object in this
    array belongs to the first origin, the second object to the second origin, and
    so on. Each object holds a key named `elements`, whose value is also an array
    of objects that belong to the corresponding destinations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`rows` 键持有实际结果作为数组。这个数组中的第一个对象属于第一个来源，第二个对象属于第二个来源，依此类推。每个对象都包含一个名为 `elements`
    的键，其值也是一个对象数组，这些对象属于相应的目的地：'
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Each JSON object (`{...}` in the preceding example) for an origin-destination
    pair consists of two pairs with the distance and duration keys. Both values of
    these keys are arrays that hold the `text` and `value` keys, where `text` is a
    human-readable phrase for `value`. The object for the Warsaw-Birmingham search
    looks as shown in the following snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个源-目的地对，前一个示例中的每个 JSON 对象 (`{...}`) 包含两个键值对，分别对应距离和持续时间。这两个键的值都是数组，包含 `text`
    和 `value` 键，其中 `text` 是 `value` 的人类可读短语。Warsaw-Birmingham 搜索的对象如下所示：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the value of `value` for distance is the distance expressed
    in meters—since we have used `units=metric` in the request—and the value of `text`
    is value transformed into kilometers with the "km" postfix. The same applies to
    duration. Here, value is expressed in seconds, and text is value converted into
    hours and minutes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，距离的 `value` 是以米为单位表示的距离——因为我们已经在请求中使用了 `units=metric`——而 `text` 的值是将值转换为带有
    "km" 后缀的公里。同样适用于持续时间。在这里，值以秒为单位表示，而 `text` 是将值转换为小时和分钟的转换。
- en: 'Now that we know how the returned JSON is structured, we display the value
    of each origin-destination pair in the text edit. Therefore, we loop through each
    possible pairing using the two `QJsonArray`. We need the indices as well as values,
    so we use the classic `for` loop instead of the range-based one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了返回的 JSON 的结构，我们在文本编辑器中显示每个源-目的地对的值。因此，我们使用两个 `QJsonArray` 遍历每个可能的配对。我们需要索引以及值，所以我们使用经典的
    `for` 循环而不是基于范围的循环：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we create an `output` string variable to cache the constructed text.
    Before starting the second loop, we calculate two variables that will be the same
    for all destinations. The `origin` variable holds the text representation of the
    current origin, and the `row` variable contains the corresponding row of the table.
    Whenever we try to get an item out of a `QJsonArray` or a `QJsonObject`, the returned
    value will have the `QJsonValue` type, so each time we do that, we need to convert
    it to an array, an object, or a string, depending on what we expect to get according
    to the API. When we calculate the `row` variable, starting at the reply's root
    object, we fetch the value of the `rows` key and convert it to an array (`obj.value("rows").toArray()`).
    Then, we fetch the value of the current row (`.at(i)`), convert it to an object,
    and fetch its `elements` key (`.toObject().value("elements")`). Since this value
    is also an array—the columns of the row—we convert it to an array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `output` 字符串变量来缓存构建的文本。在开始第二个循环之前，我们计算两个变量，这两个变量对于所有目的地都是相同的。`origin`
    变量包含当前源的文字表示，而 `row` 变量包含表格的相应行。每次我们尝试从一个 `QJsonArray` 或 `QJsonObject` 中获取项时，返回的值将具有
    `QJsonValue` 类型，因此每次我们这样做时，我们需要根据 API 的预期结果将其转换为数组、对象或字符串。当我们计算 `row` 变量时，从回复的根对象开始，我们获取
    `rows` 键的值并将其转换为数组 (`obj.value("rows").toArray()`)。然后，我们获取当前行的值 (`.at(i)`)，将其转换为对象，并获取其
    `elements` 键 (`.toObject().value("elements")`)。由于此值也是一个数组——行的列，我们将其转换为数组。
- en: 'The scope inside the two loops will be reached for each combination. Think
    of the transferred result as a table where the origins are rows and the destinations
    are columns:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 两个循环内的作用域将遍历每个组合。想象一下传递的结果就像一个表格，其中源是行，目的地是列：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, we add the `"From:"` string and the current origin to output. The same
    is done for the destination, which results in the following as the value for output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在输出中添加 `"From:"` 字符串和当前源地址。对于目的地也执行相同的操作，这导致输出值为以下内容：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we will read the duration and distance from the corresponding `QJsonObject`
    from where we call `data`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从调用 `data` 的相应 `QJsonObject` 中读取持续时间和距离：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this code, we fetch the current column from the row (`at(j)`) and convert
    it to an object. This is the object that contains the distance and duration for
    an origin-destination pair in the `(i; j)` cell. Besides `distance` and `duration`,
    the object also holds a key called `status`. Its value indicates whether the search
    was successful (`OK`), whether the origin or destination could not be found (`NOT_FOUND`),
    or whether the search could not find a route between the origin and destination
    (`ZERO_RESULTS`). We store the value of `status` in a local variable that is also
    named `status`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们从行中获取当前列 (`at(j)`) 并将其转换为对象。这是包含 `(i; j)` 单元中起点-终点对的距离和持续时间的对象。除了 `distance`
    和 `duration`，该对象还包含一个名为 `status` 的键。其值表示搜索是否成功（`OK`），起点或目的地是否无法找到（`NOT_FOUND`），或者搜索是否无法在起点和目的地之间找到路线（`ZERO_RESULTS`）。我们将
    `status` 的值存储在一个同名的局部变量中。
- en: 'Next, we check the status and append the distance and the duration to the output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查状态并将距离和持续时间追加到输出中：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For distance, we want to show the phrased result. Therefore, we first get the
    JSON value of the distance key (`data.value("distance")`), convert it to an object,
    and request the value for the text key (`toObject().value("text")`). Lastly, we
    convert `QJsonValue` to `QString` using `toString()`. The same applies for duration.
    Finally, we need to handle the errors the API might return:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于距离，我们希望显示短语结果。因此，我们首先获取距离键的 JSON 值 (`data.value("distance")`)，将其转换为对象，并请求文本键的值
    (`toObject().value("text")`)。最后，我们使用 `toString()` 将 `QJsonValue` 转换为 `QString`。对于持续时间也是如此。最后，我们需要处理
    API 可能返回的错误：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At the end of the output for each cell, we add a line consisting of `35` equals
    signs (`QStringLiteral("=").repeated(35)`) to separate the result from the other
    cells. Finally, after all loops finish, we put the text into the text edit and
    delete the reply object:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个单元的输出末尾，我们添加由 `35` 个等号组成的行 (`QStringLiteral("=").repeated(35)`) 以将结果与其他单元分开。最后，在所有循环完成后，我们将文本放入文本编辑器中并删除回复对象：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The actual result then looks as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际结果如下所示：
- en: '![](img/95c1ee67-1c73-47c8-a974-57cb9bfe7576.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95c1ee67-1c73-47c8-a974-57cb9bfe7576.png)'
- en: Have a go hero – Choosing XML as the reply's format
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 选择 XML 作为回复的格式
- en: To hone your XML skills, you can use [https://maps.googleapis.com/maps/api/distancematrix/xml](https://maps.googleapis.com/maps/api/distancematrix/xml)
    as the URL to which you send the requests. Then, you can parse the XML file, as
    we did with JSON, and display the retrieved data likewise.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要磨练您的 XML 技能，您可以使用 [https://maps.googleapis.com/maps/api/distancematrix/xml](https://maps.googleapis.com/maps/api/distancematrix/xml)
    作为发送请求的 URL。然后，您可以像处理 JSON 一样解析 XML 文件，并同样显示检索到的数据。
- en: Controlling the connectivity state
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制连接状态
- en: Before trying to access a network resource, it's useful to check whether you
    have an active connection to the internet. Qt allows you to check whether the
    computer, mobile device, or tablet is online. You can even start a new connection
    if the operating system supports it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试访问网络资源之前，检查您是否已建立到互联网的活跃连接是有用的。Qt 允许您检查计算机、移动设备或平板电脑是否在线。如果操作系统支持，您甚至可以启动新的连接。
- en: The relevant API mainly consists of four classes. `QNetworkConfigurationManager`
    is the base and starting point. It holds all network configurations available
    on the system. Furthermore, it provides information about the network capabilities,
    for example, whether you can start and stop interfaces. The network configurations
    found by it are stored as `QNetworkConfiguration` classes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 相关 API 主要由四个类组成。`QNetworkConfigurationManager` 是基础和起点。它包含系统上可用的所有网络配置。此外，它提供有关网络功能的信息，例如，您是否可以启动和停止接口。它找到的网络配置存储为
    `QNetworkConfiguration` 类。
- en: '`QNetworkConfiguration` holds all information about an access point but not
    about a network interface, as an interface can provide multiple access points.
    This class also provides only the information about network configurations. You
    can''t configure an access point or a network interface through `QNetworkConfiguration`.
    The network configuration is up to the operating system and therefore `QNetworkConfiguration`
    is a read-only class. With `QNetworkConfiguration`, however, you can determine
    whether the type of connection is an Ethernet, WLAN, or 4G connection. This may
    influence what kind of data and, more importantly, what size of data you will
    download.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration` 包含有关接入点的所有信息，但不包含网络接口的信息，因为一个接口可以提供多个接入点。此类还仅提供有关网络配置的信息。您无法通过
    `QNetworkConfiguration` 配置接入点或网络接口。网络配置由操作系统负责，因此 `QNetworkConfiguration` 是一个只读类。然而，使用
    `QNetworkConfiguration`，您可以确定连接类型是以太网、WLAN 还是 4G 连接。这可能会影响您将下载的数据类型，更重要的是，影响您将下载的数据大小。'
- en: With `QNetworkSession`, you can then start or stop system network interfaces,
    which are defined by the configurations. This way, you gain control over an access
    point. `QNetworkSession` also provides session management that is useful when
    a system's access point is used by more than one application. The session ensures
    that the underlying interface only gets terminated after the last session has
    been closed. Lastly, `QNetworkInterface` provides classic information, such as
    the hardware address or interface name.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QNetworkSession`，您可以启动或停止由配置定义的系统网络接口。这样，您就可以控制接入点。`QNetworkSession` 还提供了当系统接入点被多个应用程序使用时的会话管理功能。会话确保在最后一个会话关闭后，底层接口才会终止。最后，`QNetworkInterface`
    提供了经典信息，例如硬件地址或接口名称。
- en: QNetworkConfigurationManager
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkConfigurationManager
- en: '`QNetworkConfigurationManager` manages all network configurations that are
    available on a system. You can access these configurations by calling `allConfigurations()`.
    Of course, you have to create an instance of the manager first:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkConfigurationManager` 管理系统上所有可用的网络配置。您可以通过调用 `allConfigurations()`
    来访问这些配置。当然，您必须首先创建管理器的实例：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The configurations are returned as a list. The default behavior of `allConfigurations()`
    is to return all possible configurations. However, you can also retrieve a filtered
    list. If you pass `QNetworkConfiguration::Active` as an argument, the list only
    contains configurations that have at least one active session. If you create a
    new session based on such a configuration, it will be active and connected. By
    passing `QNetworkConfiguration::Discovered` as an argument, you will get a list
    with configurations that can be used to immediately start a session. Note, however,
    that at this point, you cannot be sure whether the underlying interface can be
    started. The last important argument is `QNetworkConfiguration::Defined`. With
    this argument, `allConfigurations()` returns a list of configurations that are
    known to the system but are not usable right now. This may be a previously used
    WLAN hotspot, which is currently out of range.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 配置以列表的形式返回。`allConfigurations()` 的默认行为是返回所有可能的配置。但是，您也可以获取一个过滤后的列表。如果您将 `QNetworkConfiguration::Active`
    作为参数传递，列表中只包含至少有一个活动会话的配置。如果您基于此类配置创建一个新会话，它将是活动的并已连接。通过传递 `QNetworkConfiguration::Discovered`
    作为参数，您将获得一个可以立即启动会话的配置列表。请注意，然而，在此阶段，您不能确定底层接口是否可以启动。最后一个重要的参数是 `QNetworkConfiguration::Defined`。使用此参数，`allConfigurations()`
    返回一个列表，其中包含系统已知但当前不可用的配置。这可能是一个之前使用的、目前超出范围的 WLAN 热点。
- en: You will be notified whenever the configurations change. If a new configuration
    becomes available, the manager emits the `configurationAdded()` signal. This may
    happen, for example, if mobile data transmission becomes available or if the user
    turns his/her device's WLAN adapter on. If a configuration is removed, for example,
    if the WLAN adapter is turned off, `configurationRemoved()` is emitted. Lastly,
    when a configuration is changed, you will be notified by the `configurationChanged()`
    signal. All three signals pass a constant reference to the configuration about
    what was added, removed, or changed. The configuration passed by the `configurationRemoved()`
    signal is, of course, invalid. It still contains the name and identifier of the
    removed configuration.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置更改时，您将收到通知。如果出现新的配置，则管理器会发出`configurationAdded()`信号。例如，如果移动数据传输变得可用或用户打开其设备的WLAN适配器，这可能会发生。如果移除配置，例如，如果关闭WLAN适配器，则发出`configurationRemoved()`。最后，当配置更改时，您将通过`configurationChanged()`信号得到通知。所有三个信号都传递一个关于添加、移除或更改的配置的常量引用。通过`configurationRemoved()`信号传递的配置当然无效。它仍然包含已移除配置的名称和标识符。
- en: To find out whether any network interface of the system is active, call `isOnline()`.
    If you want to be notified about a mode change, track the `onlineStateChanged()`
    signal.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定系统中的任何网络接口是否处于活动状态，请调用`isOnline()`。如果您想收到模式更改的通知，请跟踪`onlineStateChanged()`信号。
- en: Since a WLAN scan takes a certain amount of time, `allConfigurations()` may
    not return all the available configurations. To ensure that configurations are
    completely populated, call `updateConfigurations()` first. Due to the long time
    it may take to gather all the information about the system's network configurations,
    this call is asynchronous. Wait for the `updateCompleted()` signal and only then,
    call `allConfigurations()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WLAN扫描需要一定的时间，`allConfigurations()`可能不会返回所有可用的配置。为确保配置完全填充，请先调用`updateConfigurations()`。由于收集系统网络配置的所有信息可能需要很长时间，此调用是异步的。等待`updateCompleted()`信号，然后才能调用`allConfigurations()`。
- en: '`QNetworkConfigurationManager` also informs you about the Bearer API''s capabilities.
    The `capabilities()` function returns a flag of the `QNetworkConfigurationManager::Capabilities`
    type and describes the available possibilities that are platform-specific. The
    values you may be most interested in are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkConfigurationManager`还会通知您Bearer API的功能。`capabilities()`函数返回一个`QNetworkConfigurationManager::Capabilities`类型的标志，并描述了特定平台的可用可能性。您可能最感兴趣的值如下：'
- en: '| **Value** | **Meaning** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **含义** |'
- en: '| `CanStartAndStopInterfaces` | This means that you can start and stop access
    points. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `CanStartAndStopInterfaces` | 这意味着您可以启动和停止接入点。 |'
- en: '| `ApplicationLevelRoaming` | This indicates that the system will inform you
    if a more suitable access point is available, and that you can actively change
    the access point if you think there is a better one available. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `ApplicationLevelRoaming` | 这表示系统会通知您是否有更合适的接入点可用，并且如果您认为有更好的接入点，您可以主动更改接入点。
    |'
- en: '| `DataStatistics` | With this capability, `QNetworkSession` contains information
    about the transmitted and received data. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `DataStatistics` | 使用此功能，`QNetworkSession`包含有关传输和接收的数据信息。 |'
- en: QNetworkConfiguration
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkConfiguration
- en: '`QNetworkConfiguration` holds, as mentioned earlier, information about an access
    point. With `name()`, you get the user-visible name for a configuration, and with
    `identifier()`, you get a unique, system-specific identifier. If you develop games
    for mobile devices, it may be of advantage to you to know which type of connection
    is being used. This might influence the data that you request; for example, the
    quality and thus, the size of a video. With `bearerType()`, the type of bearer
    used by a configuration is returned. The returned enumeration values are rather
    self-explanatory: `BearerEthernet`, `BearerWLAN`, `Bearer2G`, `BearerCDMA2000`,
    `BearerWCDMA`, `BearerHSPA`, `BearerBluetooth`, `BearerWiMAX`, and so on. You
    can look up the full-value list in the documentation for `QNetworkConfiguration::BearerType`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`QNetworkConfiguration`包含有关接入点的信息。使用`name()`，您可以得到配置的用户可见名称，而使用`identifier()`，您可以得到一个唯一、系统特定的标识符。如果您为移动设备开发游戏，了解正在使用的连接类型可能对您有利。这可能影响您请求的数据；例如，视频的质量以及因此其大小。使用`bearerType()`，返回配置使用的承载类型。返回的枚举值相当直观：`BearerEthernet`、`BearerWLAN`、`Bearer2G`、`BearerCDMA2000`、`BearerWCDMA`、`BearerHSPA`、`BearerBluetooth`、`BearerWiMAX`等。您可以在`QNetworkConfiguration::BearerType`的文档中查找完整的值列表。
- en: With `purpose()`, you get the purpose of the configuration, for example, whether
    it is suitable to access a private network (`QNetworkConfiguration::PrivatePurpose`)
    or to access a public network (`QNetworkConfiguration::PublicPurpose`). The state
    of the configuration, if it is defined, discovered or active, as previously described,
    can be accessed through `state()`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `purpose()`，你可以获取配置的目的，例如，它是否适合访问私有网络（`QNetworkConfiguration::PrivatePurpose`）或访问公共网络（`QNetworkConfiguration::PublicPurpose`）。如果已定义、发现或激活，配置的状态可以通过
    `state()` 访问，如前所述。
- en: QNetworkSession
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkSession
- en: 'To start a network interface or to tell the system to keep an interface connected
    for as long as you need it, you have to start a session:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动网络接口或告诉系统保持接口连接直到你需要它，你必须启动一个会话：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A session is based on a configuration. When there is more than one session and
    you are not sure which one to use, use `QNetworkConfigurationManager::defaultConfiguration()`.
    It returns the system's default configuration. Based on this, you can create an
    instance of `QNetworkSession`. The first argument, the configuration, is required.
    The second is optional but is recommended since it sets a parent, and we do not
    have to take care of the deletion. You may want to check whether the configuration
    is valid (`QNetworkConfiguration::isValid()`) first.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 会话基于配置。当存在多个会话且你不确定使用哪一个时，请使用 `QNetworkConfigurationManager::defaultConfiguration()`。它返回系统的默认配置。基于此，你可以创建
    `QNetworkSession` 的实例。第一个参数，配置，是必需的。第二个参数是可选的，但建议使用，因为它设置了一个父对象，我们不需要处理删除。你可能首先想检查配置是否有效（`QNetworkConfiguration::isValid()`）。
- en: Calling `open()` will start the session and connect the interface if needed
    and supported. Since `open()` can take some time, the call is asynchronous. So,
    either listen to the `opened()` signal, which is emitted as soon as the session
    is open, or to the `error()` signal if an error happened. The error information
    is represented using the `QNetworkSession::SessionError` type. Alternatively,
    instead of checking the `opened()` signal, you can also watch the `stateChanged()`
    signal. The possible states for a session can be `Invalid`, `NotAvailable`, `Connecting`,
    `Connected`, `Closing`, `Disconnected`, and `Roaming`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `open()` 将启动会话并在需要且支持的情况下连接接口。由于 `open()` 可能需要一些时间，因此该调用是异步的。所以，你可以监听 `opened()`
    信号，该信号在会话打开后立即发出，或者监听 `error()` 信号，如果发生错误。错误信息使用 `QNetworkSession::SessionError`
    类型表示。或者，你也可以不检查 `opened()` 信号，而是监听 `stateChanged()` 信号。会话的可能状态有 `Invalid`（无效）、`NotAvailable`（不可用）、`Connecting`（连接中）、`Connected`（已连接）、`Closing`（关闭中）、`Disconnected`（已断开）和
    `Roaming`（漫游）。
- en: If you want to open the session in a synchronous way, call `waitForOpened()`
    right after calling `open()`. It will block the `event` loop until the session
    is open. This function will return `true` if successful and `false` otherwise.
    To limit the waiting time, you can define a time-out. Just pass the milliseconds
    that you are willing to wait as an argument to `waitForOpened()`. To check whether
    a session is open, use `isOpen()`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以同步方式打开会话，请在调用 `open()` 后立即调用 `waitForOpened()`。这将阻塞事件循环直到会话打开。如果成功，此函数将返回
    `true`，否则返回 `false`。为了限制等待时间，你可以定义一个超时。只需将你愿意等待的毫秒数作为参数传递给 `waitForOpened()`。要检查会话是否打开，请使用
    `isOpen()`。
- en: To close the session, call `close()`. If no session is left on the interface,
    it will be shot down. To force an interface to disconnect, call `stop()`. This
    call will invalidate all the sessions that are based on that interface.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭会话，请调用 `close()`。如果接口上没有剩余的会话，它将被关闭。要强制断开接口，请调用 `stop()`。此调用将使基于该接口的所有会话无效。
- en: You may receive the `preferredConfigurationChanged()` signal, which indicates
    that the preferred configuration, that is, for example, the preferred access point,
    has changed. This may be the case if a WLAN network is now in range and you do
    not have to use 2G anymore. The new configuration is passed as the first argument,
    and the second one indicates whether changing the new access point will also alter
    the IP address. Besides checking for the signal, you can also inquire whether
    roaming is available for a configuration by calling `QNetworkConfiguration::isRoamingAvailable()`.
    If roaming is available, you have to decide to either reject the offer by calling
    `ignore()` or to accept it by calling `migrate()`. If you accept roaming, it will
    emit `newConfigurationActivated()` when the session is roamed. After you have
    checked the new connection, you can either accept the new access point or reject
    it. The latter means that you will return to the previous access point. If you
    accept the new access point, the previous one will be terminated.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会收到 `preferredConfigurationChanged()` 信号，这表示首选配置，例如首选接入点已更改。这可能是在一个 WLAN
    网络现在在范围内，你不再需要使用 2G 的情况下。新的配置作为第一个参数传递，第二个参数指示更改新的接入点是否会同时更改 IP 地址。除了检查信号外，你还可以通过调用
    `QNetworkConfiguration::isRoamingAvailable()` 来查询配置是否支持漫游。如果漫游可用，你必须决定是调用 `ignore()`
    拒绝提议，还是调用 `migrate()` 接受它。如果你接受漫游，当会话漫游时，它将发出 `newConfigurationActivated()` 信号。在你检查了新的连接之后，你可以接受新的接入点或拒绝它。后者意味着你将返回到以前的接入点。如果你接受新的接入点，以前的接入点将被终止。
- en: QNetworkInterface
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkInterface
- en: 'To get the interface that is used by a session, call `QNetworkSession::interface()`.
    It will return the `QNetworkInterface` object, which describes the interface.
    With `hardwareAddress()`, you get the low-level hardware address of the interface
    that is normally the MAC address. The name of the interface can be obtained by
    `name()`, which is a string such as "eth0" or "wlan0". A list of IP addresses
    as well as their netmasks and broadcast addresses registered with the interface
    is returned by `addressEntries()`. Furthermore, information about whether the
    interface is a loopback or whether it supports multicasting can be queried with
    `flags()`. The returned bitmask is a combination of these values: `IsUp`, `IsRunning`,
    `CanBroadcast`, `IsLoopBack`, `IsPointToPoint`, and `CanMulticast`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取会话使用的接口，请调用 `QNetworkSession::interface()`。它将返回 `QNetworkInterface` 对象，该对象描述了接口。通过
    `hardwareAddress()`，你可以获取接口的低级硬件地址，通常是 MAC 地址。接口的名称可以通过 `name()` 获取，它是一个如 "eth0"
    或 "wlan0" 的字符串。`addressEntries()` 返回与接口注册的 IP 地址列表以及它们的子网掩码和广播地址。此外，可以通过 `flags()`
    查询接口是否为回环接口或是否支持多播。返回的位掩码是这些值的组合：`IsUp`、`IsRunning`、`CanBroadcast`、`IsLoopBack`、`IsPointToPoint`
    和 `CanMulticast`。
- en: Communicating between games
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏间的通信
- en: After having discussed Qt's high-level network classes such as `QNetworkAccessManager`
    and `QNetworkConfigurationManager`, we will now take a look at lower-level network
    classes and see how Qt supports you when it comes to implementing TCP or UDP servers
    and clients. This becomes relevant when you plan to extend your game by including
    a multiplayer mode. For such a task, Qt offers `QTcpSocket`, `QUdpSocket`, and
    `QTcpServer`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了 Qt 的高级网络类，如 `QNetworkAccessManager` 和 `QNetworkConfigurationManager` 之后，我们现在将查看较低级别的网络类，并了解
    Qt 在实现 TCP 或 UDP 服务器和客户端时如何支持你。当你计划通过包括多人模式来扩展你的游戏时，这变得相关。为此任务，Qt 提供 `QTcpSocket`、`QUdpSocket`
    和 `QTcpServer`。
- en: Time for action – Realizing a simple chat program
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 实现一个简单的聊天程序
- en: 'To get familiar with `QTcpServer` and `QTcpSocket`, let''s develop a simple
    chat program. This example will teach you the basic knowledge of network handling
    in Qt so that you can use this skill later to connect two or more copies of a
    game. At the end of this exercise, we want to see something like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉 `QTcpServer` 和 `QTcpSocket`，让我们开发一个简单的聊天程序。这个例子将教会你 Qt 中网络处理的基本知识，以便你可以使用这项技能在以后连接两个或更多游戏副本。在这个练习结束时，我们希望看到如下内容：
- en: '![](img/dd2ae024-636d-49c3-aa01-5b343d9039ff.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd2ae024-636d-49c3-aa01-5b343d9039ff.png)'
- en: On both the left-hand side and the right-hand side of the preceding screenshot,
    you can see a client, whereas the server is in the middle. We'll start by taking
    a closer look at the server.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图的左侧和右侧，你可以看到一个客户端，而服务器位于中间。我们将首先仔细看看服务器。
- en: The server – QTcpServer
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器 – QTcpServer
- en: 'As a protocol for communication, we will use **Transmission Control Protocol**
    (**TCP**). You may know this network protocol from the two most popular internet
    protocols: HTTP and FTP. Both use TCP for their communication and so do the globally
    used protocols for email traffic: SMTP, POP3, and IMAP. The main advantage of
    TCP is its reliability and connection-based architecture. Data transferred by
    TCP is guaranteed to be complete, ordered, and without any duplicates. The protocol
    is furthermore stream oriented, which allows us to use `QDataStream` or `QTextStream`.
    A downside to TCP is its speed. This is because the missing data has to be retransmitted
    until the receiver fully receives it. By default, this causes a retransmission
    of all the data that was transmitted after the missing part. So, you should only
    choose TCP as a protocol if speed is not your top priority, but rather the completeness
    and correctness of the transmitted data. This applies if you send unique and nonrepetitive
    data.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为通信协议，我们将使用**传输控制协议**（**TCP**）。您可能从最流行的两个互联网协议HTTP和FTP中了解到这个网络协议。它们都使用TCP进行通信，全球通用的电子邮件流量协议也是如此：SMTP、POP3和IMAP。TCP的主要优势是其可靠性和基于连接的架构。通过TCP传输的数据保证是完整、有序且无重复的。此外，该协议是面向流的，这使得我们可以使用`QDataStream`或`QTextStream`。TCP的一个缺点是它的速度较慢。这是因为丢失的数据必须重新传输，直到接收方完全接收为止。默认情况下，这会导致丢失部分之后传输的所有数据重新传输。因此，只有当速度不是您最优先考虑的因素，而是数据的完整性和正确性时，您才应该选择TCP作为协议。如果您发送的是独特且非重复的数据，这也适用。
- en: Time for action – Setting up the server
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 设置服务器
- en: 'A look at the server''s GUI shows us that it principally consists of `QPlainTextEdit`
    (`ui->log`) that is used to display system messages and a button (`ui->disconnectClients`),
    which allows us to disconnect all the currently connected clients. On the top,
    next to the button, the server''s address and port are displayed (`ui->address`
    and `ui->port`). After setting up the user interface in the constructor of the
    server''s class `TcpServer`, we initiate the internally used `QTcpServer`, which
    is stored in the `m_server` private member variable:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 查看服务器的GUI显示，我们可以看到它主要由`QPlainTextEdit`（`ui->log`）组成，用于显示系统消息，还有一个按钮（`ui->disconnectClients`），允许我们断开所有当前连接的客户端。在按钮旁边，显示服务器的地址和端口（`ui->address`和`ui->port`）。在服务器类的构造函数中设置用户界面后，我们初始化内部使用的`QTcpServer`，它存储在`m_server`私有成员变量中：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What just happened?
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'With `QTcpServer::listen()`, we defined that the server should listen to the
    localhost and the port `52693` for new incoming connections. The value used here,
    `QHostAddress::LocalHost` of the `QHostAddress::SpecialAddress` enumeration, will
    resolve to `127.0.0.1`. Instead, if you pass `QHostAddress::Any`, the server will
    listen to all IPv4 interfaces as well as to IPv6 interfaces. If you only want
    to listen to a specific address, just pass this address as `QHostAddress`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QTcpServer::listen()`，我们定义了服务器应该监听本地的端口`52693`以接收新的连接。这里使用的值，`QHostAddress::LocalHost`属于`QHostAddress::SpecialAddress`枚举，将解析为`127.0.0.1`。相反，如果您传递`QHostAddress::Any`，服务器将监听所有IPv4接口以及IPv6接口。如果您只想监听特定的地址，只需将此地址作为`QHostAddress`传递：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will behave like the one in the preceding code, only in that the server
    will now listen to a port that will be chosen automatically. On success, `listen()`
    will return `true`. So, if something goes wrong in the example, it will show an
    error message on the text edit and exit the function. To compose the error message,
    we are using `QTcpServer::errorString()`, which holds a human-readable error phrase.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表现得像前面的代码一样，只是服务器现在将监听一个自动选择的端口。如果成功，`listen()`将返回`true`。因此，如果示例中出现问题，它将在文本编辑器上显示错误消息并退出函数。为了组成错误消息，我们使用`QTcpServer::errorString()`，它包含一个可读的错误短语。
- en: 'To handle the error in your game''s code, the error string is not suitable.
    In any case where you need to know the exact error, use `QTcpServer::serverError()`,
    which returns the enumeration value of `QAbstractSocket::SocketError`. Based on
    this, you know exactly what went wrong, for example, `QAbstractSocket::HostNotFoundError`.
    If `listen()` was successful, we connect the server''s `newConnection()` signal
    to the class''s `newConnection()` slot. The signal will be emitted every time
    a new connection is available. Lastly, we show the server''s address and port
    number that can be accessed through `serverAddress()` and `serverPort()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理你游戏代码中的错误，错误字符串是不合适的。在任何需要知道确切错误的情况下，使用`QTcpServer::serverError()`，它返回`QAbstractSocket::SocketError`的枚举值。基于此，你可以确切地知道出了什么问题，例如`QAbstractSocket::HostNotFoundError`。如果`listen()`调用成功，我们将服务器的`newConnection()`信号连接到类的`newConnection()`槽。每当有新的连接可用时，都会发出此信号。最后，我们显示可以通过`serverAddress()`和`serverPort()`访问的服务器的地址和端口号：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This information is required by the clients so that they are able to connect
    to the server.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端需要这些信息以便能够连接到服务器。
- en: Time for action – Reacting on a new pending connection
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 对新的挂起连接做出反应
- en: 'As soon as a client tries to connect to the server, the `newConnection()` slot
    will be called:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端尝试连接到服务器时，`newConnection()`槽会被调用：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What just happened?
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Since more than one connection may be pending, we use `hasPendingConnections()`
    to determine whether there is at least one more pending connection. Each one is
    then handled in the iteration of the `while` loop. To get a pending connection
    of the `QTcpSocket` type, we call `nextPendingConnection()` and add this connection
    to a private vector called `m_clients`, which holds all active connections. In
    the next line, as there is now at least one connection, we enable the button that
    allows all connections to be closed. The slot connected to the button's `click()`
    signal will call `QTcpSocket::close()` on each single connection. When a connection
    is closed, its socket emits a `disconnected()` signal. We connect this signal
    to our `removeConnection()` slot. With the last connection, we react to the socket's
    `readyRead()` signal, which indicates that new data is available. In such a situation,
    our `readyRead()` slot is called. Lastly, we print a system message that a new
    connection has been established. The address and port of the connecting client
    and peer can be retrieved by the socket's `peerAddress()` and `peerPort()` functions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能存在多个挂起的连接，我们使用`hasPendingConnections()`来确定是否至少还有一个挂起的连接。然后，在`while`循环的迭代中处理每一个连接。为了获取`QTcpSocket`类型的挂起连接，我们调用`nextPendingConnection()`并将此连接添加到一个名为`m_clients`的私有向量中，该向量包含所有活动连接。在下一行，由于现在至少有一个连接，我们启用了允许关闭所有连接的按钮。连接到按钮`click()`信号的槽将调用每个单独连接的`QTcpSocket::close()`。当一个连接关闭时，其套接字会发出`disconnected()`信号。我们将此信号连接到我们的`removeConnection()`槽。在最后一个连接时，我们响应套接字的`readyRead()`信号，这表示有新数据可用。在这种情况下，我们的`readyRead()`槽会被调用。最后，我们打印一条系统消息，表明已建立新的连接。连接客户端和对方的地址和端口号可以通过套接字的`peerAddress()`和`peerPort()`函数获取。
- en: If a new connection can't be accepted, the `acceptError()` signal is emitted
    instead of `newConnection()`. It passes the reason for the failure of the `QAbstractSocket::SocketError`
    type as an argument. If you want to temporarily decline new connections, call
    `pauseAccepting()` on `QTcpServer`. To resume accepting new connections, call
    `resumeAccepting()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法接受新的连接，将发出`acceptError()`信号而不是`newConnection()`。它将`QAbstractSocket::SocketError`类型失败原因作为参数传递。如果你想要暂时拒绝新的连接，请在`QTcpServer`上调用`pauseAccepting()`。要恢复接受新的连接，请调用`resumeAccepting()`。
- en: Time for action – Forwarding a new message
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 前向转发新消息
- en: When a connected client sends a new chat message, the underlying socket—since
    it inherits `QIODevice`—emits `readyRead()`, and thus, our `readyRead()` slot
    will be called.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接的客户端发送新的聊天消息时，由于它继承了`QIODevice`，底层的套接字会发出`readyRead()`，因此我们的`readyRead()`槽会被调用。
- en: Before we take a look at this slot, there is something important that you need
    to keep in mind. Even though TCP is ordered and without any duplicates, this does
    not mean that all the data is delivered in one big chunk. So, before processing
    the received data, we need to ensure that we get the entire message. Unfortunately,
    there is neither an easy way to detect whether all data was transmitted nor a
    globally usable method for such a task. Therefore, it is up to you to solve this
    problem, as it depends on the use case. Two common solutions, however, are to
    either send magic tokens to indicate the start and end of a message, for example,
    single characters or XML tags, or you can send the size of the message upfront.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这个槽之前，有一些重要的事情需要你记住。尽管TCP是有序且无重复的，但这并不意味着所有数据都作为一个大块传输。因此，在处理接收到的数据之前，我们需要确保我们得到了整个消息。不幸的是，没有简单的方法来检测是否所有数据都已传输，也没有一个全局通用的方法来完成这项任务。因此，这个问题取决于你，因为它取决于用例。然而，两种常见的解决方案是发送魔法令牌来指示消息的开始和结束，例如单个字符或XML标签，或者你可以提前发送消息的大小。
- en: The second solution is shown in the Qt documentation where the length is put
    in a `quint16` in front of the message. We, on the other hand, will look at an
    approach that uses a simple magic token to handle the messages correctly. As a
    delimiter, we use the "End of Transmission Block" character—ASCII code 23—to indicate
    the end of a message. We also choose UTF-8 as the encoding of transmitted messages
    to ensure that clients with different locales can communicate with each other.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案在Qt文档中有所展示，其中消息长度被放在消息前的`quint16`中。另一方面，我们将探讨一种使用简单魔法令牌正确处理消息的方法。作为分隔符，我们使用“传输结束块”字符——ASCII码23——来指示消息的结束。我们还选择UTF-8作为传输消息的编码，以确保具有不同地域的客户之间可以相互通信。
- en: 'Since the processing of received data is quite complex, we will go through
    the code step by step this time:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收数据的处理相当复杂，这次我们将逐步分析代码：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To determine which socket called the slot, we use `sender()`. If the cast to
    `QTcpSocket` is unsuccessful, we exit the slot.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定哪个套接字调用了槽，我们使用`sender()`。如果将`QTcpSocket`进行类型转换失败，我们将退出槽。
- en: Note that `sender()` is used for simplicity. If you write real-life code, it
    is better to use `QSignalMapper`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sender()`的使用是为了简单起见。如果你编写实际的代码，最好使用`QSignalMapper`。
- en: 'Next, we read the transferred—potentially fragmentary—message with `readAll()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`readAll()`读取传输的——可能是片段化的——消息：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, `QHash<QTcpSocket*, QByteArray> m_receivedData` is a private class member
    where we store the previously received data for each connection. When the first
    chunk of data is received from a client, `m_receivedData[socket]` will automatically
    insert an empty `QByteArray` into the hash and return a reference to it. On subsequent
    calls, it will return a reference to the same array. We use `append()` to append
    the newly received data to the end of the array. Finally, we need to identify
    the messages that were completely received by now, if there are any such messages:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`QHash<QTcpSocket*, QByteArray> m_receivedData`是一个私有类成员，其中我们存储每个连接之前接收到的数据。当从客户端接收到第一块数据时，`m_receivedData[socket]`将自动将一个空的`QByteArray`插入到哈希中，并返回对其的引用。在后续调用中，它将返回对同一数组的引用。我们使用`append()`将新接收到的数据追加到数组的末尾。最后，我们需要确定现在是否已经完全接收了消息，如果有这样的消息：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: On each iteration of the loop, we try to find the first separator character.
    If we didn't find one (`endIndex < 0`), we exit the loop, and leave the remaining
    partial message in `m_receivedData`. If we found a separator, we take the first
    message's data using the `left(endIndex)` function that returns the leftmost `endIndex`
    bytes from the array. To remove the first message from `buffer`, we use the `remove()`
    function that will remove the specified number of bytes, shifting the remaining
    bytes to the left. We want to remove `endIndex + 1` bytes (the message itself
    and the separator after it). Following our transmission protocol, we interpret
    the data as UTF-8 and call our `newMessage()` function that will handle the received
    message.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，我们尝试找到第一个分隔符字符。如果我们没有找到（`endIndex < 0`），我们将退出循环，并将剩余的局部消息留在`m_receivedData`中。如果我们找到了分隔符，我们使用`left(endIndex)`函数获取第一个消息的数据，该函数返回从数组中左侧的`endIndex`个字节。为了从`buffer`中移除第一个消息，我们使用`remove()`函数，该函数将移除指定数量的字节，并将剩余的字节向左移动。我们希望移除`endIndex
    + 1`个字节（消息本身及其后的分隔符）。根据我们的传输协议，我们将数据解释为UTF-8，并调用我们的`newMessage()`函数来处理接收到的消息。
- en: 'In the `newMessage()` function, we append the new message to the server log
    and send it to all clients:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `newMessage()` 函数中，我们将新消息追加到服务器日志并发送给所有客户端：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this function, we encode the message according to our transmission protocol.
    First, we use `toUtf8()` to convert `QString` to `QByteArray` in UTF-8 encoding.
    Next, we append the separator character. Finally, we iterate over the list of
    clients, check whether they are still connected, and send the encoded message
    to them. Since the socket inherits `QIODevice`, you can use most of the functions
    that you know from `QFile`. The current behavior of our server is very simple,
    so we have no use for the `sender` argument, so we add the `Q_UNUSED` macro to
    suppress the unused argument warning.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们根据我们的传输协议对消息进行编码。首先，我们使用 `toUtf8()` 将 `QString` 转换为 UTF-8 编码的 `QByteArray`。然后，我们添加分隔符字符。最后，我们遍历客户端列表，检查它们是否仍然连接，并将编码后的消息发送给它们。由于套接字继承了
    `QIODevice`，你可以使用你从 `QFile` 知道的几乎所有函数。我们的服务器当前行为非常简单，所以我们没有使用 `sender` 参数的必要，因此我们添加了
    `Q_UNUSED` 宏来抑制未使用参数的警告。
- en: Have a go hero – Using QSignalMapper
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来试试英雄吧——使用 QSignalMapper
- en: As discussed earlier, using `sender()` is a convenient, but not an object-oriented,
    approach. Thus, try to use `QSignalMapper` instead to determine which socket called
    the slot. To achieve this, you have to connect the socket's `readyRead()` signal
    to a mapper and the slot directly. All the signal-mapper-related code will go
    into the `newConnection()` slot.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 `sender()` 是一种方便的方法，但不是面向对象的方法。因此，尝试使用 `QSignalMapper` 来确定哪个套接字调用了槽。为了实现这一点，你必须将套接字的
    `readyRead()` 信号连接到一个映射器，并将槽直接连接。所有与信号-映射器相关的代码都将放入 `newConnection()` 槽中。
- en: The same applies to the connection to the `removeConnection()` slot. Let's take
    a look at it next.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于连接到 `removeConnection()` 槽。让我们接下来看看它。
- en: Time for action – Detecting a disconnect
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——检测断开连接
- en: 'When a client terminates the connection, we have to delete the socket from
    the local `m_clients` list. The socket''s `disconnected()` signal is already connected to the `removeConnection()` slot,
    so we just need to implement it as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端终止连接时，我们必须从本地的 `m_clients` 列表中删除套接字。套接字的 `disconnected()` 信号已经连接到 `removeConnection()`
    插槽，所以我们只需按以下方式实现它：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What just happened?
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: After getting the socket that emitted the call through `sender()`, we post the
    information that a socket is being removed. Then, we remove the socket from `m_clients`,
    remove the associated buffer from `m_receivedData` and call `deleteLater()` on
    it. Do not use `delete`. Lastly, if no client is left, the disconnect button is
    disabled.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 `sender()` 获取发出调用的套接字后，我们发布一个套接字正在被移除的信息。然后，我们从 `m_clients` 中删除套接字，从 `m_receivedData`
    中删除相关的缓冲区，并对其调用 `deleteLater()`。不要使用 `delete`。最后，如果没有剩余的客户端，断开连接按钮将被禁用。
- en: The server is ready. Now let's take a look at the client.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已准备就绪。现在让我们看看客户端。
- en: The client
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: The GUI of the client (`TcpClient`) is pretty simple. It has three input fields
    to define the server's address (`ui->address`), the server's port (`ui->port`),
    and a username (`ui->user`). Of course, there is also a button to connect to (`ui->connect`)
    and disconnect from (`ui->disconnect`) the server. Finally, the GUI has a text
    edit that holds the received messages (`ui->chat`) and a line edit (`ui->text`)
    to send messages.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的 GUI (`TcpClient`) 非常简单。它有三个输入字段来定义服务器的地址 (`ui->address`)、服务器的端口 (`ui->port`)
    和用户名 (`ui->user`)。当然，还有一个按钮用于连接到 (`ui->connect`) 和断开与 (`ui->disconnect`) 服务器的连接。最后，GUI
    有一个文本编辑器，用于保存接收到的消息 (`ui->chat`)，以及一个行编辑器 (`ui->text`) 用于发送消息。
- en: Time for action – Setting up the client
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——设置客户端
- en: 'After providing the server''s address and port and choosing a username, the
    user can connect to the server:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供服务器地址和端口并选择用户名后，用户可以连接到服务器：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What just happened?
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `m_socket` private member variable holds an instance of `QTcpSocket`. If
    this socket is already connected, nothing happens. Otherwise, the socket is connected
    to the given address and port by calling `connectToHost()`. Besides the obligatory
    server address and port number, you can pass a third argument to define the mode
    in which the socket will be opened. For possible values, you can use `OpenMode`
    just like we did for `QIODevice`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_socket` 私有成员变量持有 `QTcpSocket` 的实例。如果这个套接字已经连接，则不会发生任何事情。否则，通过调用 `connectToHost()`
    将套接字连接到指定的地址和端口。除了必需的服务器地址和端口号之外，你还可以传递第三个参数来定义套接字将打开的模式。对于可能的值，你可以使用 `OpenMode`，就像我们为
    `QIODevice` 所做的那样。'
- en: Since this call is asynchronous, we print a notification to the chat so that
    the user is informed that the application is currently trying to connect to the
    server. When the connection is established, the socket sends the `connected()`
    signal that prints "Connected to server" on the chat to indicate that we have
    connected to a slot. Besides the messages in the chat, we also updated the GUI
    by, for example, disabling the connect button, but this is all basic stuff. You
    won't have any trouble understanding this if you have had a look at the sources.
    So, these details are left out here.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个调用是异步的，我们在聊天中打印一个通知，让用户知道应用程序目前正在尝试连接到服务器。当连接建立时，套接字发送 `connected()` 信号，在聊天中打印
    "Connected to server"，以指示我们已经连接到一个槽。除了聊天中的消息外，我们还通过例如禁用连接按钮等方式更新了GUI，但这都是基本操作。如果你看过源代码，你不会遇到任何麻烦。所以，这些细节在这里被省略了。
- en: Of course, something could go wrong when trying to connect to a server, but
    luckily, we are informed about a failure as well through the `error()` signal,
    passing a description of error in the form of `QAbstractSocket::SocketError`.
    The most frequent errors will probably be `QAbstractSocket::ConnectionRefusedError`
    if the peer refused the connection or `QAbstractSocket::HostNotFoundError` if
    the host address could not be found. If the connection, however, was successfully
    established, it should be closed later on. You can either call `abort()` to immediately
    close the socket, whereas `disconnectFromHost()` will wait until all pending data
    has been written.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在尝试连接到服务器时可能会出错，但幸运的是，我们也可以通过 `error()` 信号得知失败，该信号传递一个错误描述，形式为 `QAbstractSocket::SocketError`。最频繁的错误可能是
    `QAbstractSocket::ConnectionRefusedError`，如果对等方拒绝连接，或者 `QAbstractSocket::HostNotFoundError`，如果找不到主机地址。然而，如果连接成功建立，它应该在稍后关闭。你可以调用
    `abort()` 立即关闭套接字，而 `disconnectFromHost()` 将等待所有挂起的数据被写入。
- en: Time for action – Receiving text messages
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——接收文本消息
- en: 'In the constructor, we have connected the socket''s `readyRead()` signal to
    a local slot. So, whenever the server sends a message through `QTcpSocket::write()`,
    we read the data and decode it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将套接字的 `readyRead()` 信号连接到了一个本地槽。因此，每当服务器通过 `QTcpSocket::write()` 发送消息时，我们读取数据并解码它：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This code is very similar to the `readyRead()` slot of the server. It''s even
    simpler because we only have one socket and one data buffer, so `m_receivedData`
    is a single `QByteArray`. The `newMessage()` implementation in the client is also
    much simpler than in the server:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与服务器中的 `readyRead()` 槽位非常相似。它甚至更简单，因为我们只有一个套接字和一个数据缓冲区，所以 `m_receivedData`
    是一个单一的 `QByteArray`。客户端中 `newMessage()` 的实现也比服务器简单得多：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we just need to display the received message to the user.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要将接收到的消息显示给用户。
- en: Time for action – Sending text messages
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——发送文本消息
- en: 'What is left now is to describe how to send a chat message. On hitting return
    button inside the line edit, a local slot will be called that checks whether there
    is actual text to send and whether `m_socket` is still connected. If everything
    is ready, we construct a message that contains the self-given username, a colon,
    and the text of the line edit:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是描述如何发送聊天消息。在行编辑器中按回车键时，会调用一个本地槽，该槽检查是否有实际要发送的文本以及 `m_socket` 是否仍然连接。如果一切准备就绪，我们构建一个包含自给用户名、冒号和行编辑器文本的消息：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we encode and send the message, just like we did on the server side:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编码并发送消息，就像我们在服务器端做的那样：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That's all. It's like writing and reading from a file. For the complete example,
    take a look at the sources bundled with this book and run the server and several
    clients.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么多了。就像从文件中写入和读取一样。对于完整的示例，请查看本书附带源代码，并运行服务器和几个客户端。
- en: You can see that the server and client share a significant amount of code. In
    a real project, you definitely want to avoid such duplication. You can move all
    repeating code to a common library used by both server or client. Alternatively,
    you can implement server and client in a single project and enable the needed
    functionality using command-line arguments or conditional compilation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到服务器和客户端共享大量的代码。在实际项目中，你肯定希望避免这种重复。你可以将所有重复的代码移动到一个由服务器和客户端共同使用的公共库中。或者，你可以在一个项目中实现服务器和客户端，并使用命令行参数或条件编译启用所需的功能。
- en: Have a go hero – Extending the chat server and client
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来试试吧——扩展聊天服务器和客户端
- en: This example has shown us how to send a simple text. If you now go on and define
    a schema for how the communication should work, you can use it as a base for more
    complex communication. For instance, if you want to enable the client to receive
    a list of all other clients (and their usernames), you need to define that the
    server will return such a list if it gets a special message from a client. You
    can use special text commands such as `/allClients`, or you can implement a more
    complex message structure using `QDataStream` or JSON serialization. Therefore,
    you have to parse all messages received by the server before forwarding them to
    all the connected clients. Go ahead and try to implement such a requirement yourself.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了如何发送简单的文本。如果你现在继续定义一个通信应该如何工作的模式，你可以将其作为更复杂通信的基础。例如，如果你想使客户端能够接收所有其他客户端（及其用户名）的列表，你需要定义服务器在接收到客户端的特殊消息时将返回这样一个列表。你可以使用特殊的文本命令，如`/allClients`，或者你可以使用`QDataStream`或JSON序列化实现更复杂的信息结构。因此，在将消息转发给所有已连接的客户端之前，你必须解析服务器接收到的所有消息。现在就尝试自己实现这样的要求吧。
- en: By now, it is possible that multiple users have chosen the same username. With
    the new functionality of getting a user list, you can prevent this from happening.
    Therefore, you have to send the username to the server that keeps track of them.
    In the current implementation, nothing stops the client from sending messages
    under a different username each time. You can make the server handle usernames
    instead of trusting the client's each message.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可能有多位用户选择了相同的用户名。通过获取用户列表的新功能，你可以防止这种情况发生。因此，你必须将用户名发送到跟踪它们的服务器。在当前实现中，没有阻止客户端每次使用不同的用户名发送消息。你可以让服务器处理用户名，而不是信任客户端的每条消息。
- en: Synchronous network operations
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步网络操作
- en: The example we explained uses a nonblocking, asynchronous approach. For example,
    after asynchronous calls such as `connectToHost()`, we do not block the thread
    until we get a result, but instead, we connect to the socket's signals to proceed.
    On the Internet as well as Qt's documentation, on the other hand, you will find
    dozens of examples explaining the blocking and the synchronous approaches. You
    will easily spot them by their use of `waitFor...()` functions. These functions
    block the current thread until a function such as `connectToHost()` has a result—the
    time `connected()` or `error()` will be emitted. The corresponding blocking function
    to `connectToHost()` is `waitForConnected()`. The other blocking functions that
    can be used are `waitForReadyRead()`, which waits until new data is available
    on a socket for reading; `waitForBytesWritten()`, which waits until the data has
    been written to the socket; and `waitForDisconnected()`, which waits until the
    connection has been closed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释的例子使用的是非阻塞、异步的方法。例如，在异步调用如`connectToHost()`之后，我们不会阻塞线程直到我们得到结果，而是连接到套接字的信号以继续。另一方面，在互联网以及Qt的文档中，你会找到许多解释阻塞和同步方法的例子。你将很容易通过它们使用`waitFor...()`函数来识别。这些函数会阻塞当前线程，直到`connectToHost()`等函数有结果——即`connected()`或`error()`信号被发射。`connectToHost()`的对应阻塞函数是`waitForConnected()`。其他可以使用的阻塞函数包括`waitForReadyRead()`，它等待直到套接字上有可读的新数据；`waitForBytesWritten()`，它等待直到数据已写入套接字；以及`waitForDisconnected()`，它等待直到连接被关闭。
- en: Look out! Even if Qt offers these `waitFor...()` functions, do not use them!
    The synchronous approach is not the smartest one, since it will freeze your game's
    GUI. A frozen GUI is the worst thing that can happen in your game, and it will
    annoy every user. So, when working inside the GUI thread, you are better to react
    to the `QIODevice::readyRead()`, `QIODevice::bytesWritten()`, `QAbstractSocket::connected()`,
    and `QAbstractSocket::disconnected()` signals.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！即使Qt提供了这些`waitFor...()`函数，也不要使用它们！同步方法并不是最聪明的选择，因为它会冻结你的游戏GUI。冻结的GUI是游戏中可能发生的最糟糕的事情，并且会令每个用户感到烦恼。所以，当在GUI线程中工作时，你最好是对`QIODevice::readyRead()`、`QIODevice::bytesWritten()`、`QAbstractSocket::connected()`和`QAbstractSocket::disconnected()`信号做出反应。
- en: '`QAbstractSocket` is the base class of `QTcpSocket` as well as of `QUdpSocket`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAbstractSocket`是`QTcpSocket`和`QUdpSocket`的基类。'
- en: Following the asynchronous approach shown, the application will only become
    unresponsive while your own slots are being executed. If your slots contain more
    heavy computations, you will need to move them to an extra thread. Then, the GUI
    thread will only get signals, passing the new messages, and to send, it will simply
    pass the required data to the worker thread. This way, you will get a super fluent
    velvet GUI.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按照展示的异步方法，应用程序只有在你的槽函数正在执行时才会变得无响应。如果你的槽函数包含更重的计算，你需要将它们移动到额外的线程。然后，GUI 线程将只接收信号，传递新消息，发送时，它只需将所需数据传递给工作线程。这样，你将得到一个超级流畅的绒毛
    GUI。
- en: Using UDP
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UDP
- en: In contrast to TCP, UDP is unreliable and connectionless. Neither the order
    of packets nor their delivery is guaranteed. These limitations, however, allow
    UDP to be very fast. So, if you have frequent data, which does not necessarily
    need to be received by the peer, use UDP. This data could, for example, be real-time
    positions of a player that get updated frequently or live video/audio streaming.
    Since `QUdpSocket` is mostly the same as `QTcpSocket`—both inherit `QAbstractSocket`—there
    is not much to explain. The main difference between them is that TCP is stream-oriented,
    whereas UDP is datagram-oriented. This means that the data is sent in small packages,
    containing among the actual content, the sender's as well as the receiver's IP
    address and port number.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TCP 相比，UDP 是不可靠的且无连接的。既不能保证数据包的顺序，也不能保证它们的交付。然而，这些限制使得 UDP 非常快。所以，如果你有频繁的数据，这些数据不一定需要被对等方接收，可以使用
    UDP。这些数据可以是玩家实时位置，频繁更新，或者实时视频/音频流。由于 `QUdpSocket` 主要与 `QTcpSocket` 相同——两者都继承自
    `QAbstractSocket`——因此没有太多可解释的。它们之间的主要区别是，TCP 是面向流的，而 UDP 是面向数据报的。这意味着数据以小包的形式发送，其中包含实际内容，以及发送者和接收者的
    IP 地址和端口号。
- en: Unlike `QTcpSocket` and `QTcpServer`, UDP does not need a separate server class
    because it is connectionless. A single `QUdpSocket` can be used as a server. In
    this case, you have to use `QAbstractSocket::bind()` instead of `QTcpServer::listen()`.
    Like `listen()`, `bind()` takes the addresses and ports that are allowed to send
    datagrams as arguments. Note that TCP ports and UDP ports are completely unrelated
    to each other.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `QTcpSocket` 和 `QTcpServer` 不同，UDP 不需要一个单独的服务器类，因为它是无连接的。单个 `QUdpSocket` 可以用作服务器。在这种情况下，你必须使用
    `QAbstractSocket::bind()` 而不是 `QTcpServer::listen()`。与 `listen()` 类似，`bind()`
    接受允许发送数据报的地址和端口作为参数。请注意，TCP 端口和 UDP 端口之间完全无关。
- en: Whenever a new package arrives, the `QIODevice::readyRead()` signal is emitted.
    To read the data, use the `receiveDatagram()` or `readDatagram()` function. The
    `receiveDatagram()` function accepts an optional `maxSize` argument that allows
    you to limit the size of the received data. This function returns a `QNetworkDatagram`
    object that contains the datagram and has a number of methods to get the data.
    The most useful of them are `data()`, which returns the payload as a `QByteArray` as
    well as `senderAddress()` and `senderPort()` that allow you to identify the sender.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个新的数据包到达时，`QIODevice::readyRead()` 信号会被触发。要读取数据，请使用 `receiveDatagram()` 或
    `readDatagram()` 函数。`receiveDatagram()` 函数接受一个可选的 `maxSize` 参数，允许你限制接收数据的尺寸。这个函数返回一个包含数据报的
    `QNetworkDatagram` 对象，并具有许多获取数据的方法。其中最有用的是 `data()`，它返回作为 `QByteArray` 的有效载荷，以及
    `senderAddress()` 和 `senderPort()`，允许你识别发送者。
- en: The `readDatagram()` function is a more low-level function that takes four parameters.
    The first one of the `char*` type is used to write the data in, the second specifies
    the amount of bytes to be written, and the last two parameters of the `QHostAddress*`
    and `quint16*` types are used to store the sender's IP address and port number.
    This function is less convenient, but you can use it more efficiently than `receiveDatagram()`,
    because it's possible to use the same data buffer for all datagrams instead of
    allocating a new one for each datagram.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`readDatagram()` 函数是一个更底层的函数，它接受四个参数。第一个参数是 `char*` 类型，用于写入数据，第二个参数指定要写入的字节数，最后两个参数是
    `QHostAddress*` 和 `quint16*` 类型，用于存储发送者的 IP 地址和端口号。这个函数不太方便，但你可以比 `receiveDatagram()`
    更高效地使用它，因为你可以为所有数据报使用相同的数据缓冲区，而不是为每个数据报分配一个新的缓冲区。'
- en: '`QUdpSocket` also provides the overloaded `writeDatagram()` function for sending
    the data. One of the overloads simply accepts a `QNetworkDatagram` object. You
    can also supply the data in the form of `QByteArray` or a `char*` buffer with
    a size, but in these cases, you also need to specify the recipient''s address
    and port number as separate arguments.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUdpSocket` 还提供了重载的 `writeDatagram()` 函数用于发送数据。其中一个重载简单地接受一个 `QNetworkDatagram`
    对象。你也可以以 `QByteArray` 或 `char*` 缓冲区形式提供数据，但在这两种情况下，你还需要指定接收者的地址和端口号作为单独的参数。'
- en: Time for action – Sending a text via UDP
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候通过 UDP 发送文本了
- en: 'As an example, let''s assume that we have two sockets of the `QUdpSocket` type.
    We will call the first one `socketA` and the other `socketB`. Both are bound to
    the localhost, `socketA` to the `52000` port and `socketB` to the `52001` port.
    So, if we want to send the string `Hello!` from `socketA` to `socketB`, we have
    to write in the application that is holding `socketA`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们有两个 `QUdpSocket` 类型的套接字。我们将第一个称为 `socketA`，另一个称为 `socketB`。它们都绑定到本机，`socketA`
    绑定到 `52000` 端口，`socketB` 绑定到 `52001` 端口。因此，如果我们想从 `socketA` 向 `socketB` 发送字符串
    `Hello!`，我们必须在持有 `socketA` 的应用程序中编写：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The class that holds `socketB` must have the socket''s `readyRead()` signal
    connected to a slot. This slot will then be called because of our `writeDatagram()`
    call, assuming that the datagram is not lost! In the slot, we read the datagram
    and the sender''s address and port number with:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `socketB` 的类必须将套接字的 `readyRead()` 信号连接到一个槽。然后，由于我们的 `writeDatagram()` 调用，该槽将被调用，假设数据报没有丢失！在槽中，我们读取数据报和发送者的地址和端口号，使用：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As long as there are pending datagrams—this is checked by `hasPendingDatagrams()`—we
    read them using the high-level `QNetworkDatagram` API. After the datagram was
    received, we use the getter functions to read the data and identify the sender.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 只要存在挂起的数据报——这是通过 `hasPendingDatagrams()` 检查的——我们就使用高级 `QNetworkDatagram` API
    读取它们。在接收到数据报后，我们使用获取函数来读取数据和识别发送者。
- en: Have a go hero – Connecting players of the Benjamin game
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 勇敢的尝试者——连接本杰明游戏玩家
- en: With this introductory knowledge, you can go ahead and try some stuff by yourself.
    For example, you can take the game Benjamin the elephant and send Benjamin's current
    position from one client to another. This way, you can either clone the screen
    from one client to the other, or both clients can play the game and, additionally,
    can see where the elephant of the other player currently is. For such a task,
    you would use UDP, as it is important that the position is updated very fast while
    it isn't a disaster when one position gets lost.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些基础知识后，你可以尝试自己做一些事情。例如，你可以玩本杰明大象游戏，并将本杰明的当前位置从一个客户端发送到另一个客户端。这样，你可以从客户端克隆屏幕到另一个客户端，或者两个客户端都可以玩游戏，并且还可以看到其他玩家的大象当前的位置。对于这样的任务，你会使用
    UDP，因为位置更新非常快很重要，而丢失一个位置并不是灾难。
- en: Keep in mind that we only scratched the surface of networking due to its complexity.
    Covering it fully would have exceeded this beginner's guide. For a real game,
    which uses a network, you should learn more about Qt's possibilities for establishing
    a secure connection via SSL or some other mechanism.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于网络的复杂性，我们只是触及了网络的一角。全面覆盖将超出这本入门指南的范围。对于使用网络的真正游戏，你应该了解 Qt 通过 SSL 或其他机制建立安全连接的可能性。
- en: Pop quiz
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which class can you use to read the data received over the network?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 你可以使用哪个类来读取通过网络接收到的数据？
- en: '`QNetworkReply`'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QNetworkReply`'
- en: '`QNetworkRequest`'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QNetworkRequest`'
- en: '`QNetworkAccessManager`'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QNetworkAccessManager`'
- en: Q2\. What should you usually do with the `QNetworkReply *reply` object in the `finished()` signal
    handler?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 在 `finished()` 信号处理程序中，你通常应该对 `QNetworkReply *reply` 对象做什么？
- en: Delete it using `delete reply`
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `delete reply` 删除它
- en: Delete it using `reply->deleteLater()`
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `reply->deleteLater()` 删除它
- en: Don't delete it
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要删除它
- en: Q3\. How to ensure that your application won't freeze because of processing
    an HTTP request?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 如何确保你的应用程序不会因为处理 HTTP 请求而冻结？
- en: Use `waitForConnected()` or `waitForReadyRead()` functions
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `waitForConnected()` 或 `waitForReadyRead()` 函数
- en: Use `readyRead()` or `finished()` signals
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `readyRead()` 或 `finished()` 信号
- en: Move `QNetworkAccessManager` to a separate thread
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `QNetworkAccessManager` 移动到单独的线程
- en: Q4\. Which class can you use to create a UDP server?
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 你可以使用哪个类来创建 UDP 服务器？
- en: '`QTcpServer`'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QTcpServer`'
- en: '`QUdpServer`'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QUdpServer`'
- en: '`QUdpSocket`'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QUdpSocket`'
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the first part of this chapter, you familiarized yourself with `QNetworkAccessManager`.
    This class is at the heart of your code whenever you want to download or upload
    files to the internet. After having gone through the different signals that you
    can use to fetch errors, to get notified about new data or to show the progress,
    you should now know everything you need on that topic.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，你熟悉了`QNetworkAccessManager`。每当你要在互联网上下载或上传文件时，这个类就是你的代码核心。在了解了你可以用来获取错误、接收新数据通知或显示进度的不同信号之后，你现在应该对该主题所需的一切都了如指掌。
- en: The example about the Distance Matrix API depended on your knowledge of `QNetworkAccessManager`,
    and it shows you a real-life application case for it. Dealing with JSON as the
    server's reply format was a summary of [Chapter 4](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml),
    *Qt Core Essentials*, but it was highly needed since Facebook and Twitter only
    use JSON to format their network replies.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 关于距离矩阵API的示例依赖于你对`QNetworkAccessManager`的了解，并且展示了它的实际应用案例。处理作为服务器响应格式的JSON是[第4章](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml)，“Qt核心基础”的总结，但这是非常必要的，因为Facebook和Twitter只使用JSON来格式化它们的网络响应。
- en: In the last section, you learned how to set up your own TCP server and clients.
    This enables you to connect different instances of a game to provide the multiplayer
    functionality. Alternatively, you were taught how to use UDP.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节，你学习了如何设置自己的TCP服务器和客户端。这使得你能够连接游戏的不同实例以提供多人游戏功能。或者，你被教导如何使用UDP。
- en: You are now familiar with Qt widgets, the Graphics View framework, the core
    Qt classes, and the networking API. This knowledge will already allow you to implement
    games with rich and advanced functionality. The only large and significant part
    of Qt we will explore is Qt Quick. However, before we get to that, let's consolidate
    our knowledge of what we already know and investigate some advanced topics.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在熟悉了Qt小部件、图形视图框架、核心Qt类和网络API。这些知识已经允许你实现具有丰富和高级功能的游戏。我们将探索Qt的最后一个大型和重要部分是Qt
    Quick。然而，在我们到达那里之前，让我们巩固我们已经知道的知识，并研究一些高级主题。
- en: Now we are returning to the world of widgets. In [Chapter 3](ebffc011-752f-4dbe-a383-0917a002841d.xhtml),
    *Qt GUI Programming*, we only used the widget classes provided by Qt. In the next
    chapter, you will learn to create your own widgets and integrate them into your
    forms.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到了小部件的世界。在[第3章](ebffc011-752f-4dbe-a383-0917a002841d.xhtml)，“Qt GUI编程”中，我们只使用了Qt提供的小部件类。在下一章，你将学习如何创建自己的小部件并将它们集成到你的表单中。
