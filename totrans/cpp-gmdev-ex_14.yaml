- en: Preparing the Clear Screen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备清除屏幕
- en: In the last chapter, we enabled the Vulkan validation layers and extensions,
    created the Vulkan application and instance, chose the device, and created the
    logical device. In this chapter, we will continue the journey toward creating
    a clear screen picture and presenting it to the viewport.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们启用了 Vulkan 验证层和扩展，创建了 Vulkan 应用程序和实例，选择了设备，并创建了逻辑设备。在这一章中，我们将继续探索创建清晰的屏幕图像并将其呈现到视口的过程。
- en: Before drawing pictures, we first clear and erase the previous picture with
    a color value. If we don't do this, the new picture will be written on top of
    the previous picture, which will create a psychedelic effect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制图像之前，我们首先使用一个颜色值清除和擦除之前的图像。如果我们不这样做，新的图像将覆盖在之前的图像上，这将产生一种迷幻的效果。
- en: Each picture is cleared and rendered and then presented on the screen. While
    the current one is being shown, the next picture is in the process of being drawn
    in the background. Once that is rendered, the current picture will be swapped
    with the new picture. This swapping of pictures is taken care of by the **SwapChain**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每幅图像被清除和渲染后，然后呈现在屏幕上。当当前图像正在显示时，下一幅图像已经在后台被绘制。一旦渲染完成，当前图像将与新图像交换。这种图像交换由 **SwapChain**
    负责处理。
- en: In our case, each picture in the SwapChain we are drawing simply stores the
    color information. This target picture is rendered and, hence, it is called the
    render target. We can also have other target pictures. For example, we can have
    a depth target/picture, which will store the depth information of each pixel per
    frame. Consequently, we create these render targets as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们正在绘制的 SwapChain 中的每一幅图像仅仅存储颜色信息。这个目标图像被渲染，因此被称为渲染目标。我们也可以有其他的目标图像。例如，我们可以有一个深度目标/图像，它将存储每帧每个像素的深度信息。因此，我们也创建了这些渲染目标。
- en: Each of these target pictures per frame is set as an attachment and used to
    create the framebuffer. Since we have double buffering (meaning we have two sets
    of pictures to swap between), we create a framebuffer for each frame. Consequently,
    we will create two framebuffers—one for each frame—and we will add the picture as
    an attachment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧的每个目标图像被设置为附件并用于创建帧缓冲区。由于我们采用双缓冲（意味着我们有两套图像进行交换），我们为每一帧创建一个帧缓冲区。因此，我们将为每一帧创建两个帧缓冲区——一个用于每一帧——并将图像作为附件添加。
- en: The commands that we give to the GPU—for example, the draw command—are sent
    to the GPU with each frame using a command buffer. The command buffer stores all
    the commands to be submitted to the GPU using the graphics queue of the device.
    So, for each frame, we create a command buffer to carry all our commands as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 GPU 的命令——例如，绘制命令——通过每个帧使用命令缓冲区发送到 GPU。命令缓冲区存储所有要使用设备图形队列提交给 GPU 的命令。因此，对于每一帧，我们创建一个命令缓冲区来携带我们所有的命令。
- en: Once the commands are submitted and the scene is rendered, instead of presenting
    the drawn picture to the screen, we can save it and add any post-processing effects
    to it, such as motion blur. In the renderpass, we can specify how the render target
    is to be used. Although in our case, we are not going to add any post-processing
    effects, we still need to create a renderpass. Consequently, we create a renderpass,
    which will specify to the device how many swap chain pictures and buffers we will
    be using, what kind of buffers they are, and how they are to be used.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令提交并且场景被渲染，我们不仅可以将绘制的图像呈现在屏幕上，我们还可以将其保存并添加任何后处理效果，例如运动模糊。在渲染过程中，我们可以指定渲染目标的使用方式。尽管在我们的案例中，我们不会添加任何后处理效果，但我们仍然需要创建一个渲染过程。因此，我们创建了一个渲染过程，它将指定我们将使用多少
    SwapChain 图像和缓冲区，它们是什么类型的缓冲区，以及它们应该如何使用。
- en: 'The different stages the picture will go through are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图像将经历的各个阶段如下：
- en: '![](img/42991319-7f62-4966-8aee-afd84dc7cc22.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42991319-7f62-4966-8aee-afd84dc7cc22.png)'
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Creating `SwapChain`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `SwapChain`
- en: Creating `Renderpass`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Renderpass`
- en: Using render views and `Framebuffers`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用渲染视图和 `Framebuffers`
- en: Creating `CommandBuffer`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `CommandBuffer`
- en: Beginning and ending `Renderpass`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束 `Renderpass`
- en: Creating the clear screen
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建清除屏幕
- en: Creating SwapChain
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SwapChain
- en: While the scene is rendered, the buffers are swapped and presented to the window
    surface. The surface is platform-dependent and, depending upon the operating system,
    we have to choose the surface format accordingly. For the scene to be presented
    properly, we create the `SwapChain`, depending upon the surface format, presentation
    mode, and the extent, meaning the width and height, of the picture that the window
    can support.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景渲染时，缓冲区会交换并显示到窗口表面。表面是平台相关的，并且根据操作系统，我们必须相应地选择表面格式。为了正确显示场景，我们根据表面格式、显示模式和图片的范围（即窗口可以支持的宽度和高度）创建
    `SwapChain`。
- en: In [Chapter 10](dc30df72-df2e-4bb9-a598-a481ecb595f3.xhtml), *Drawing Vulkan
    Objects*, when we chose the GPU device to use, we retrieved the properties of
    the device, such as the surface format and the presentation modes it supports.
    While we create the `SwapChain`, we match and check the surface format and the
    presentation that is available from the device, and that is also supported by
    the window to create the `SwapChain` object itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](dc30df72-df2e-4bb9-a598-a481ecb595f3.xhtml) 的 *绘制 Vulkan 对象* 中，当我们选择要使用的
    GPU 设备时，我们检索了设备的属性，例如表面格式和它支持的显示模式。当我们创建 `SwapChain` 时，我们将匹配并检查设备提供的表面格式和显示，以及窗口支持的表面格式，以创建
    `SwapChain` 对象本身。
- en: 'We create a new class called `SwapChain` and add the following includes to `SwapChain.h`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的类，名为 `SwapChain`，并将以下包含添加到 `SwapChain.h`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then create the class, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建类，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the public section of the class, we create the constructor and the destructor.
    Then, we create the variables of the `VkSwapchainKHR`, `VkFormat`, and `VkExtent2D` types
    to store the `swapchain` itself. When we create the surface, we store the format
    of the picture itself, which is supported, as well as the extent of the picture,
    which is the width and height of the viewport. This is because, when the viewport
    is stretched or changed, the size of the swapchain picture will also be changed
    accordingly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的公共部分，我们创建构造函数和析构函数。然后，我们创建 `VkSwapchainKHR`、`VkFormat` 和 `VkExtent2D` 类型的变量来存储
    `swapchain` 本身。当我们创建表面时，我们存储支持的图片格式以及图片的范围，即视口的宽度和高度。这是因为，当视口拉伸或改变时，swapchain
    图片的大小也会相应地改变。
- en: We create a vector of the `VkImage` type, called `swapChainImages`, to store
    the SwapChain pictures. Three helper functions, `chooseSwapChainSurfaceFormat`, 
    `chooseSwapPresentMode`, and `chooseSwapExtent`, are created to get the most suitable
    surface format, present mode, and SwapChain extent. Finally, the `create` function
    takes the surface in which we will create the swapchain itself. We also add a
    function to destroy and release the resources back to the system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `VkImage` 类型的向量，称为 `swapChainImages`，用于存储 SwapChain 图片。创建了三个辅助函数，`chooseSwapChainSurfaceFormat`、`chooseSwapPresentMode`
    和 `chooseSwapExtent`，以获取最合适的表面格式、显示模式和 SwapChain 范围。最后，`create` 函数接收我们将在其中创建 swapchain
    本身的表面。我们还添加了一个用于销毁和释放资源回系统的函数。
- en: That is it for the `SwapChain.h` file. We will now move on to `SwapChain.cpp`
    to incorporate the implementation of the functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwapChain.h` 文件的内容就是这些。我们现在将转到 `SwapChain.cpp` 以包含函数的实现。'
- en: 'In the `SwapChain.cpp` file, add the following includes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SwapChain.cpp` 文件中，添加以下包含：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will need to include `VulkanContext.h`  to get the device's `SwapChainSupportDetails`
    struct, which we populated in the last chapter when we selected the physical device
    and created the logical device. Before we create the swapchain, let's first look
    at the three helper functions and see how each is created.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含 `VulkanContext.h` 来获取设备的 `SwapChainSupportDetails` 结构体，这是我们在上一个章节中在选择了物理设备并创建了逻辑设备时填充的。在我们创建
    swapchain 之前，让我们先看看三个辅助函数以及每个是如何创建的。
- en: 'The first of the three functions is `chooseSwapChainSurfaceFormat`. This function
    takes in a vector of `VkSurfaceFormatKHR`, which is the available format supported
    by the device. Using this function, we will choose the surface format that is
    most suitable. The function is created as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 三个函数中的第一个是 `chooseSwapChainSurfaceFormat`。这个函数接收一个 `VkSurfaceFormatKHR` 类型的向量，这是设备支持的可用格式。使用这个函数，我们将选择最合适的表面格式。函数的创建方式如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we check whether the available format is just `1` and whether it is undefined
    by the device. This means that there is no preferred format, so we choose the
    one that is most convenient for us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查可用的格式是否仅为 `1`，并且是否由设备未定义。这意味着没有首选格式，因此我们选择对我们最方便的一个。
- en: The values returned are the color format and color space. The color format specifies
    the format of the color itself, `VK_FORMAT_B8G8R8A8_UNORM`, which tells us that
    we store 32 bits of information in each pixel. The colors are stored in the Blue,
    Green, Red, and Alpha channels, and in that order. Each channel is stored in 8
    bits, so that means 2^8, which is 256 color values. `UNORM` suggests that each
    color value is normalized, so the color values, instead of being from 0-255, are
    normalized between 0 and 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值是颜色格式和颜色空间。颜色格式指定了颜色本身的格式，`VK_FORMAT_B8G8R8A8_UNORM`，这告诉我们我们在每个像素中存储32位信息。颜色存储在蓝色、绿色、红色和Alpha通道中，并且按照这个顺序。每个通道存储8位，这意味着2^8，即256种颜色值。"UNORM"表明每个颜色值是归一化的，所以颜色值不是从0-255，而是归一化在0和1之间。
- en: We choose the SRGB color space as the second parameter, as we want more of a
    range of colors to be represented. If there is no preferred format, we go through
    the formats available and then check and return the ones that we need. We choose
    this color space, as most surfaces support this format because it is widely available.
    Otherwise, we just return the first available format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择SRGB色彩空间作为第二个参数，因为我们希望有更多的颜色范围被表示。如果没有首选格式，我们将遍历可用的格式，然后检查并返回我们需要的格式。我们选择这个色彩空间，因为大多数表面支持这种格式，因为它广泛可用。否则，我们只返回第一个可用的格式。
- en: 'The next function is `chooseSwapPresentMode`, which takes in a vector of `VkPresentModeKHR`
    called `availablePresentModes`. Presentation modes specify how the final rendered
    picture is presented to the viewport. Here are the available modes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`chooseSwapPresentMode`，它接受一个名为`availablePresentModes`的`VkPresentModeKHR`向量。展示模式指定了最终渲染的图片如何呈现到视口。以下是可用的模式：
- en: '`VK_PRESENT_MODE_IMMEDIATE_KHR`: In this case, the picture will be displayed
    as soon as a picture is available to present. Pictures are not queued to be displayed.
    This causes picture tearing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PRESENT_MODE_IMMEDIATE_KHR`：在这种情况下，图片将在有可呈现的图片时立即显示。图片不会被排队等待显示。这会导致图片撕裂。'
- en: '`VK_PRESENT_MODE_FIFO_KHR`: The acquired pictures to be presented are put in
    a queue. The size of the queue is one minus the swap chain size. At vsync, the
    first picture to be displayed gets displayed in the **First In First Out (FIFO)**
    manner. There is no tearing as pictures are displayed in the same order in which
    they were added to the queue and vsync is enabled. This mode needs to always be
    supported.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PRESENT_MODE_FIFO_KHR`：要呈现的获取的图片被放入一个队列中。队列的大小是交换链大小减一。在垂直同步（vsync）时，第一个要显示的图片以**先进先出（FIFO）**的方式显示。由于图片是按照它们被添加到队列中的顺序显示的，并且启用了垂直同步，所以没有撕裂。这种模式需要始终支持。'
- en: '`VK_PRESENT_MODE_FIFO_RELAXED_KHR`: This is a variation of the `FIFO` mode.
    In this mode, if the rendering is faster than the refresh rate of the monitor,
    it is fine, but if the drawing is slower than the monitor, there will be screen
    tearing as the next available picture is presented immediately.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PRESENT_MODE_FIFO_RELAXED_KHR`：这是`FIFO`模式的一种变体。在这种模式下，如果渲染速度超过显示器的刷新率，那是可以的，但如果绘图速度慢于显示器，当下一个可用的图片立即呈现时，将会出现屏幕撕裂。'
- en: '`VK_PRESENTATION_MODE_MAILBOX_KHR`: The presentation of the pictures is put
    in a queue, but it has just one element in it, unlike `FIFO`, which has more than
    one element in the queue. The next picture to be displayed will wait for the queue
    to be displayed and then the presentation engine will display the picture. This
    doesn''t cause tearing.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PRESENTATION_MODE_MAILBOX_KHR`：图片的展示被放入一个队列中，但它只有一个元素，与`FIFO`不同，`FIFO`队列中有多个元素。下一个要显示的图片将等待队列被显示，然后展示引擎将显示图片。这不会导致撕裂。'
- en: 'With this information, let''s create the `chooseSwapPresentMode` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，让我们创建`chooseSwapPresentMode`函数：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the `FIFO` mode is our most preferred mode, we set it in the function
    so that we can compare it with the available modes of the device. If it is not
    available, we go for the next best mode, which is the `MAILBOX` mode, so that
    the presentation queue will have at least one more picture to avoid screen tearing.
    If neither mode is available, we go for the `IMMEDIATE` mode, which is least desirable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FIFO`模式是我们最偏好的模式，我们在函数中将它设置好，以便我们可以将其与设备的可用模式进行比较。如果不可用，我们将选择下一个最佳模式，即`MAILBOX`模式，这样展示队列至少会多一个图片以避免屏幕撕裂。如果两种模式都不可用，我们将选择`IMMEDIATE`模式，这是最不希望的模式。
- en: 'The third function is the `chooseSwapExtent` function. In this function, we
    get the resolution of the window that we drew to set the resolution of the swapchain
    pictures. It is added as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数是`chooseSwapExtent`函数。在这个函数中，我们获取我们绘制窗口的分辨率来设置swapchain图片的分辨率。它被添加如下：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The resolution of this window should match the swapchain pictures. Some window
    managers allow the resolution to be different between the pictures and the window.
    This is indicated by setting the value to the maximum of `uint32_t`. If not, then
    in that case, we return the current extent that we retrieved by the capabilities
    of the hardware, or pick the resolution that best matches the resolution between
    the maximum and minimum values available, as compared to the actual resolution
    we set, which is 1,280 x 720.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口的分辨率应该与swapchain图片匹配。一些窗口管理器允许图片和窗口之间的分辨率不同。这可以通过将值设置为`uint32_t`的最大值来表示。如果不这样做，那么在这种情况下，我们将返回通过硬件能力检索到的当前范围，或者选择与最大和最小值之间的分辨率最匹配的分辨率，与实际设置的分辨率1,280
    x 720相比。
- en: 'Let''s now look at the `create` function, in which we actually create the `SwapChain`
    itself. To create this function, we will add the functionality to create the `SwapChain`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下`create`函数，在这个函数中我们实际上创建`SwapChain`本身。为了创建这个函数，我们将添加创建`SwapChain`的功能：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first thing we do is get the device support details, which we retrieved
    for our device when we created the `Device` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是获取设备支持详情，这是我们创建`Device`类时为我们的设备检索到的：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, using the `helper` function we created, we get the surface format, present
    mode, and the extent:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们创建的`helper`函数，我们获取表面格式、展示模式和范围：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then set the minimum number of pictures required to make the swapchain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置swapchain所需的图片的最小数量：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should also make sure that we don''t exceed the maximum available picture
    count, so if the `imageCount` is more than the maximum amount, we set `imageCount`
    to the maximum count:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该确保我们不超过可用的最大图片数量，所以如果`imageCount`超过了最大数量，我们将`imageCount`设置为最大计数：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create the swapchain, we have to populate the `VkSwapchainCreateInfoKHR`
    struct first, so let''s create it. Create a variable called `createInfo` and specify
    the type of the structure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建swapchain，我们首先必须填充`VkSwapchainCreateInfoKHR`结构，所以让我们创建它。创建一个名为`createInfo`的变量并指定结构体的类型：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this, we have to specify the surface to use, the minimum picture count,
    the picture format, the space, and the extent. We also need to specify the picture array
    layers. Since we are not going to create a stereoscopic application like a virtual
    reality game, in which there would be two surfaces, one for the left eye and one
    for the right eye, instead, we just set the value for it as `1`. We also need
    to specify what the picture will be used for. Here, it will be used to show the
    color information using the color attachment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须指定要使用的表面、最小图片计数、图片格式、空间和范围。我们还需要指定图片数组层。由于我们不会创建一个像虚拟现实游戏这样的立体应用，其中会有两个表面，一个用于左眼，一个用于右眼，因此我们只需将其值设置为`1`。我们还需要指定图片将用于什么。在这里，它将用于使用颜色附件显示颜色信息：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now specify the graphics, presentation indices, and the count. We also specify
    the sharing mode. It is possible for the presentation and graphics family to be
    either the same or different.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在指定图形、展示索引和计数。我们还指定了共享模式。展示和图形家族可以是相同的，也可以是不同的。
- en: 'If the presentation and graphics family is different, the sharing mode is said
    to be of the `VK_SHARING_MODE_CONCURRENT` type. This means that the picture can
    be used across multiple queue families. However, if the picture is in the same
    queue family, the sharing mode is said to be of the `VK_SHARING_MODE_EXCLUSIVE` type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果展示和图形家族不同，共享模式被认为是`VK_SHARING_MODE_CONCURRENT`类型。这意味着图片可以在多个队列家族之间使用。然而，如果图片在同一个队列家族中，共享模式被认为是`VK_SHARING_MODE_EXCLUSIVE`类型：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we want, we can apply a pre-transform to the picture to either flip it or
    mirror it. In this case, we just keep the current transform. We can also alpha-blend
    the picture with other window systems, but we just keep it opaque and ignore the
    alpha channel, set the present mode, and set whether the pixel should be clipped
    if there is a window in front. We can also specify an old `SwapChain` if the current
    one becomes invalid when we resize the window. Since we don't resize the window,
    we don't have to specify an older swapchain.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想，我们可以对图片应用预变换，以翻转或镜像它。在这种情况下，我们只保留当前变换。我们还可以将图片与其它窗口系统进行alpha混合，但我们只是保持不透明，忽略alpha通道，设置显示模式，并设置如果前面有窗口，像素是否应该被裁剪。我们还可以指定一个旧的`SwapChain`，如果当前`SwapChain`在调整窗口大小时变得无效。由于我们不调整窗口大小，所以我们不需要指定旧的swapchain。
- en: 'After setting the info struct, we can create the swapchain itself:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置信息结构后，我们可以创建swapchain本身：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We create the swapchain using the `vkCreateSwapchainKHR` function, which takes
    the logical device, the `createInfo` struct, an allocator callback, and the swapchain
    itself. If it doesn't create the `SwapChain` because of an error, we will send
    out an error. Now that the swapchain is created, we will obtain the swapchain
    pictures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`vkCreateSwapchainKHR`函数创建swapchain，该函数接受逻辑设备、`createInfo`结构、分配器回调和swapchain本身。如果由于错误而没有创建`SwapChain`，我们将发送错误。现在swapchain已创建，我们将获取swapchain图片。
- en: 'Depending upon the picture count, we call the `vkGetSwapchainImagesKHR` function,
    which we use to first get the picture count and then call the function again to
    populate the `vkImage` vector with the pictures:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图片数量，我们调用`vkGetSwapchainImagesKHR`函数，该函数用于首先获取图片数量，然后再次调用该函数以将图片填充到`vkImage`向量中：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The creation of pictures is a bit more involved, but Vulkan automatically creates
    color pictures. We can set the picture format and extent as well:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的创建稍微复杂一些，但Vulkan会自动创建彩色图片。我们可以设置图片格式和范围：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we add the `destroy` function, which destroys the `SwapChain` by calling
    the `vkDestroySwapchainKHR` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`destroy`函数，通过调用`vkDestroySwapchainKHR`函数来销毁`SwapChain`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `VulkanApplication.h` file, include the `SwapChain` header and create
    a new `SwapChain` instance in the `VulkanApplication` class. In `VulkanApplication.cpp`,
    in the `initVulkan` function, after creating the logical device, create the `SwapChain`
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanApplication.h`文件中，包含`SwapChain`头文件并在`VulkanApplication`类中创建一个新的`SwapChain`实例。在`VulkanApplication.cpp`文件中，在`initVulkan`函数中，在创建逻辑设备之后，创建`SwapChain`如下：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Build and run the application to make sure the `SwapChain` is created without
    any errors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序以确保`SwapChain`创建没有错误。
- en: Creating Renderpass
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Renderpass
- en: After creating the `SwapChain`, we move on to the Renderpass. Here, we specify
    how many color attachments and depth attachments are present and how many samples
    to use for each of them for each framebuffer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`SwapChain`之后，我们继续到`Renderpass`。在这里，我们指定有多少个颜色附件和深度附件，以及每个附件在帧缓冲区中使用的样本数量。
- en: As mentioned at the start of this chapter, a framebuffer is a collection of
    target attachments. Attachments can be of type color, depth, and so on. The color
    attachment stores the color information that is presented to the viewport. There
    are other attachments that the end user doesn't see, but that are used internally.
    This includes depth, for example, which has all the depth information per pixel.
    In the render pass, apart from the type of attachments, we also specify how the
    attachments are used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，帧缓冲区是一组目标附件。附件可以是颜色、深度等类型。颜色附件存储要呈现给视口的颜色信息。还有其他用户看不到但内部使用的附件。这包括深度，例如，它包含每个像素的所有深度信息。在渲染遍历中，除了附件类型外，我们还指定了如何使用附件。
- en: For this book, we will be presenting what is rendered in a scene to the viewport,
    so we will just use a single pass. If we add a post-processing effect, we will
    take the rendered picture and apply this effect to it, for which we will need
    to use multiple passes. We will create a new class called `Renderpass`, in which
    we will create the render pass.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将展示场景中渲染到视口的内容，因此我们只需使用单个遍历。如果我们添加后处理效果，我们将对渲染的图片应用此效果，为此我们需要使用多个遍历。我们将创建一个新的类`Renderpass`，在其中我们将创建渲染遍历。
- en: 'In the `Renderpass.h` file, add the following includes and class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderpass.h`文件中，添加以下包含和类：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the class, add the constructor, destructor, and the `VkRenderPass` and `renderPass`
    variables. Add a new function called `createRenderPass` to create the `Renderpass`
    itself, which takes in the picture format. Also, add a function to destroy the
    `Renderpass` object after use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中添加构造函数、析构函数以及`VkRenderPass`和`renderPass`变量。添加一个名为`createRenderPass`的新函数，用于创建`Renderpass`本身，它接受图片格式。还要添加一个函数，用于在用完后销毁`Renderpass`对象。
- en: 'In the `Renderpass.cpp` file, add the following includes, as well as the constructor
    and destructor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderpass.cpp`文件中，添加以下包含项，以及构造函数和析构函数：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now add the `createRenderPass` function, in which we will add the functionality
    to create the Renderpass for the current scene to be rendered:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加`createRenderPass`函数，在其中我们将添加创建当前要渲染场景的`Renderpass`的功能：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we create the render pass, we have to specify the number and the type of
    attachments that we are using. So, for our project, we want only color attachments
    as we will only be drawing color information. We could also have a depth attachment,
    which stores depth information. We need to provide subpasses, and if so, then
    how many, as we could be using subpasses for adding post-processing effects to
    the current frame.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建渲染管线时，我们必须指定我们使用的附加项的数量和类型。因此，对于我们的项目，我们只想有颜色附加项，因为我们只会绘制颜色信息。我们也可以有一个深度附加项，它存储深度信息。我们需要提供子管线，如果有的话，那么有多少，因为我们可能使用子管线为当前帧添加后处理效果。
- en: For the attachments and subpasses, we have to populate structs to pass to them
    at the time of creating the render pass.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于附加项和子管线，我们必须在创建渲染管线时填充结构并传递给它们。
- en: 'So, let''s populate the structs. First, we create the attachments:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们填充结构。首先，我们创建附加项：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create the struct and specify the format to be used, which is the same as
    the `swapChainImage` format. We have to provide the sample count as 1 as we are
    not going to be using multi-sampling. In `loadOp` and `storeOp`, we specify what
    to do with the data before and after rendering. We specify that at the time of
    loading the attachment, we will clear the data to a constant at the start. After
    the render process, we store the data so we can read from it later. We then decide
    what to do with the data before and after the stencil operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建结构并指定要使用的格式，该格式与`swapChainImage`格式相同。我们必须提供样本数量为1，因为我们不会使用多采样。在`loadOp`和`storeOp`中，我们指定在渲染前后对数据进行什么操作。我们指定在加载附加项时，我们将数据清除到常量值。在渲染过程之后，我们存储数据，以便我们稍后可以从中读取。然后我们决定在模板操作前后对数据进行什么操作。
- en: Since we are not using the stencil buffer, we specify DON'T CARE during loading
    and storing. We also have to specify the data layout before and after processing
    the picture. The previous layout of the picture doesn't matter, but after rendering,
    the picture needs to be changed to the layout in order for it to be ready for
    presenting.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用模板缓冲区，我们在加载和存储时指定“不关心”。我们还需要在处理图片前后指定数据布局。图片的先前布局不重要，但渲染后，图片需要改变到布局，以便它准备好进行展示。
- en: 'Now we''ll go through the subpass. Each subpass references the attachments
    that need to be specified as a separate structure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将遍历`subpass`。每个`subpass`都引用需要指定为单独结构的附加项：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `subpass` reference, we specify the attachment index, which is the 0^(th)
    index and specify the layout, which is a color attachment with optimal performance.
    Next, we create the `subpass` structure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`subpass`引用中，我们指定了附加索引，即0^(th)索引，并指定了布局，这是一个具有最佳性能的颜色附加。接下来，我们创建`subpass`结构：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the pipeline bind point, we specify that this is a graphics subpass, as
    it could have been a compute subpass. Specify the attachment count as `1` and
    provide the color attachment. Now, we can create the renderpass info struct:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在管线绑定点中，我们指定这是一个图形子管线，因为它可能是一个计算子管线。指定附加数量为`1`并提供颜色附加。现在，我们可以创建渲染管线信息结构：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We create an array of one element of the `VkAttachmentDescription` type, and
    then we create the info struct and pass in the type. The attachment count and
    the attachments are passed in, and then the subpass count and the subpass is passed
    in as well. Create the renderpass itself by calling `vkCreateRenderPass` and passing
    in the logical device, the create info, and the allocator callback to get the
    renderpass:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`VkAttachmentDescription`类型的单元素数组，然后创建信息结构并传入类型。附加项数量和附加项被传入，然后子管线数量和子管线也被传入。通过调用`vkCreateRenderPass`并传入逻辑设备、创建信息和分配器回调来创建渲染管线：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, in the `destroy` function, we call `vkDestroyRenderPass` to destroy
    it after we are done:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `destroy` 函数中，我们在完成之后调用 `vkDestroyRenderPass` 来销毁它：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `VulkanApplication.h`, include `RenderPass.h` and create a render pass object.
    In `VulkanApplication.cpp`, after creating the swapchain, create the renderpass:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `VulkanApplication.h` 中，包含 `RenderPass.h` 并创建一个渲染通道对象。在 `VulkanApplication.cpp`
    中，在创建交换链之后，创建渲染通道：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, build and run the project to make sure there are no errors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建并运行项目以确保没有错误。
- en: Using render targets and framebuffers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用渲染目标和帧缓冲区
- en: To use a picture, we have to create an `ImageView`. The picture doesn't have
    any information, such as mipmap levels, and you can't access a portion of the
    picture. However, by now using picture views, we specify the type of the texture
    and whether it has mipmaps. In addition, in renderpass, we specified the attachments
    per frame buffer. We will create framebuffers here and pass in the picture views
    as attachments.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用图片，我们必须创建一个 `ImageView`。图片没有任何信息，例如 mipmap 级别，并且您无法访问图片的一部分。然而，通过使用图片视图，我们现在指定了纹理的类型以及它是否有
    mipmap。此外，在渲染通道中，我们指定了每个帧缓冲区的附件。我们将在这里创建帧缓冲区并将图片视图作为附件传递。
- en: 'Create a new class called `RenderTexture`. In the `RenderTexture.h` file, add
    the following headers and then create the class itself:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `RenderTexture` 的新类。在 `RenderTexture.h` 文件中，添加以下头文件然后创建该类：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the class, we add the constructor and destructor as usual. We will store
    `swapChainImages` and the extent to use it locally. We create two vectors to store
    the created ImageViews and framebuffers. To create the views and framebuffers,
    we will call the `createViewsAndFramebuffers` function, which takes the pictures,
    picture format, extent, and the renderpass as the input. This function intern
    will call `createImageViews` and `CreateFramebuffer` to create the views and buffers.
    We will add the `destroy` function, which destroys and releases the resources
    back to the system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，我们像往常一样添加构造函数和析构函数。我们将存储 `swapChainImages` 和要本地使用的范围。我们创建两个向量来存储创建的 ImageViews
    和帧缓冲区。为了创建视图和帧缓冲区，我们将调用 `createViewsAndFramebuffers` 函数，该函数接受图片、图片格式、范围和渲染通道作为输入。该函数将内部调用
    `createImageViews` 和 `CreateFramebuffer` 来创建视图和缓冲区。我们将添加 `destroy` 函数，该函数销毁并释放资源回系统。
- en: 'In the `RenderTexture.cpp` file, we will add the following includes as well
    as the constructor and destructor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RenderTexture.cpp` 文件中，我们还将添加以下包含以及构造函数和析构函数：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, add the `createViewAndFramebuffer` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加 `createViewAndFramebuffer` 函数：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We first assign the images and `imageExtent` to the local variables. Then,
    we call the `imageViews` function, followed by `createFramebuffer`, in order to
    create both of them. To create the image views, use the `createImageViews` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将图像和 `imageExtent` 分配给局部变量。然后，我们调用 `imageViews` 函数，接着调用 `createFramebuffer`，以便创建它们。要创建图像视图，使用
    `createImageViews` 函数：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We specify the vector size depending upon the swapchain image count first.
    For each of the image counts, we create image views using the `createImageView`
    function in the `vkTool` namespace. The `createImageView` function takes in the
    image itself, the image format, and `ImageAspectFlag`. This will be `VK_IMAGE_ASPECT_COLOR_BIT`
    or `VK_IMAGE_ASPECT_DEPTH_BIT` depending on the kind of view that you want to
    create for the image. The `createImageView` function is created in the `Tools.h`
    file under the `vkTools` namespace. The `Tools.h` file is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先根据交换链图像的数量指定向量的大小。对于每个图像数量，我们使用 `vkTool` 命名空间中的 `createImageView` 函数创建图像视图。`createImageView`
    函数接受图像本身、图像格式和 `ImageAspectFlag`。这将根据您想要为图像创建的视图类型是 `VK_IMAGE_ASPECT_COLOR_BIT`
    或 `VK_IMAGE_ASPECT_DEPTH_BIT`。`createImageView` 函数在 `Tools.h` 文件下的 `vkTools` 命名空间中创建。`Tools.h`
    文件如下：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The implementation of the function is created in the `Tools.cpp` file as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的实现创建在 `Tools.cpp` 文件中，如下所示：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To create the `imageView`, we have to populate the `VkImageViewCreateInfo` struct
    and then use the `vkCreateImageView` function to create the view itself. To populate
    the view info, we specify the structure type, the picture itself, the view type,
    which is `VK_IMAGE_VIEW_TYPE_2D`, and a 2D texture, and then specify the format.
    We pass in the aspectFlags for the aspect mask. We create the image view without
    any mipmap level or layers, so we set them to `0`. We would only need multiple
    layers if we were making something like a VR game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `imageView`，我们必须填充 `VkImageViewCreateInfo` 结构体，然后使用 `vkCreateImageView`
    函数创建视图本身。为了填充视图信息，我们指定结构体类型、图片本身、视图类型，即 `VK_IMAGE_VIEW_TYPE_2D`、一个 2D 纹理，然后指定格式。我们传递
    aspectFlags 用于方面掩码。我们创建的图像视图没有任何 mipmap 级别或层，因此我们将它们设置为 `0`。如果我们正在制作类似 VR 游戏的东西，我们才需要多个层。
- en: We then create an `imageView` of the `VkImage` type and create it using the
    `vkCreateImageView` function, which takes in the logical device, the view info
    struct, and then the picture view is created and returned. That's all for the
    Tools file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `VkImage` 类型的 `imageView` 并使用 `vkCreateImageView` 函数创建它，该函数接受逻辑设备、视图信息结构体，然后创建并返回图片视图。这就是
    Tools 文件的所有内容。
- en: We will use the Tools file and add more functions to it when we want functions
    that can be reused. Now, let's go back to the `RenderTexture.cpp` file and add
    in the function to create the framebuffer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要可重用的函数时，我们将使用 Tools 文件并为其添加更多函数。现在，让我们回到 `RenderTexture.cpp` 文件并添加创建帧缓冲区的函数。
- en: 'We will create framebuffers for each frame in the swapchain. `createFramebuffer`
    requires the picture extent and the renderpass itself:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为交换链中的每一帧创建帧缓冲区。`createFramebuffer` 函数需要图片范围和渲染通道本身：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For each frame that we create, the Framebuffer first populates the `framebufferInfo`
    struct and then calls `vkCreateFramebuffer` to create the Framebuffer itself.
    For each frame, we create a new info struct and specify the type of struct. We
    then pass the renderpass, the attachment count, and the attachment views, specify
    the width and height of the Framebuffer, and set the layers to `1`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们创建的每一帧，帧缓冲区首先填充 `framebufferInfo` 结构体，然后调用 `vkCreateFramebuffer` 创建帧缓冲区本身。对于每一帧，我们创建一个新的信息结构体并指定结构体类型。然后我们传递渲染通道、附件数量和附件视图，指定帧缓冲区的宽度和高度，并将层设置为
    `1`。
- en: 'Finally, we create the framebuffer by calling the `vkCreateFramebuffer` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用 `vkCreateFramebuffer` 函数创建帧缓冲区：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `destroy` function, we destroy each of the picture views and framebuffers
    we created by calling `vkDestroyImageView` and `vkDestroyFramebuffer`. And that
    is all for the `RenderTexture` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `destroy` 函数中，我们通过调用 `vkDestroyImageView` 和 `vkDestroyFramebuffer` 销毁我们创建的每个图像视图和帧缓冲区。这就是
    `RenderTexture` 类的所有内容。
- en: 'In `VulkanApplication.h`, include `RenderTexture.h` and create an instance
    of it called `renderTexture` in the `VulkanApplication` class. In the `VulkanApplication.cpp`
    file, include the `initVulkan` function and create a new `RenderTexture`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `VulkanApplication.h` 中，包含 `RenderTexture.h` 并在 `VulkanApplication` 类中创建一个名为
    `renderTexture` 的其实例。在 `VulkanApplication.cpp` 文件中，包含 `initVulkan` 函数并创建一个新的 `RenderTexture`：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating CommandBuffer
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令缓冲区
- en: In Vulkan, the drawing and other operations done on the GPU are performed using
    command buffers. The command buffers contain the draw commands, which are recorded
    and then executed. Draw commands are to be recorded and executed in every frame.
    To create a command buffer, we have to first create a command pool and then allocate
    command buffers from the command pool, and then the commands are recorded per
    frame.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，GPU 上执行的所有绘图和其他操作都使用命令缓冲区完成。命令缓冲区包含绘图命令，这些命令被记录并执行。绘图命令需要在每一帧中记录和执行。要创建命令缓冲区，我们必须首先创建命令池，然后从命令池中分配命令缓冲区，然后按帧记录命令。
- en: 'Let''s create a new class for creating the command buffer pool and then allocate
    the command buffers. We also create a function to start and stop recording and
    to destroy the command buffers. Create a new class, called `DrawCommandBuffer`,
    and `DrawCommandBuffer.h` as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的类来创建命令缓冲池，并分配命令缓冲区。我们还要创建一个用于开始和停止录制以及销毁命令缓冲区的函数。创建一个新的类，命名为 `DrawCommandBuffer`，以及
    `DrawCommandBuffer.h` 如下所示：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the class, we create the constructor and destructor. We create variables
    to store the command pool and a vector to store `VkCommandBuffer`. We create one
    function initially to create the command pool and allocate the command buffers.
    The next two functions, `beginCommandBuffer` and `endCommandBuffer`, will be called
    when we want to start and stop recording the command buffer. The `createCommandPool`
    and `allocateCommandBuffers` functions will be called by `createCommandPoolAndBuffer`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，我们创建构造函数和析构函数。我们创建变量来存储命令池和一个向量来存储`VkCommandBuffer`。我们最初创建一个函数来创建命令池和分配命令缓冲区。接下来的两个函数`beginCommandBuffer`和`endCommandBuffer`将在我们想要开始和停止记录命令缓冲区时被调用。`createCommandPool`和`allocateCommandBuffers`函数将由`createCommandPoolAndBuffer`调用。
- en: 'We will create the `destroy` function to destroy the command buffers when we
    want the resources to be released to the system. In `CommandBuffer.cpp`, add the
    necessary includes and the constructor and destructor:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将资源释放给系统时，我们将创建`destroy`函数来销毁命令缓冲区。在`CommandBuffer.cpp`中，添加必要的包含文件和构造函数及析构函数：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we add `createCommandPoolAndBuffer`, which takes in the picture count:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加`createCommandPoolAndBuffer`，它接受图片数量：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `createCommandPoolAndBuffer` function will call the `createCommandPool`
    and `allocateCommandBuffers` functions. First, we create the `createCommandPool`
    function. Commands have to be sent to a certain queue. We have to specify the
    queue when we create the command pool:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`createCommandPoolAndBuffer`函数将调用`createCommandPool`和`allocateCommandBuffers`函数。首先，我们创建`createCommandPool`函数。命令必须发送到特定的队列。当我们创建命令池时，我们必须指定队列：'
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To start, we get the queue family indices for the current device. To create
    the command pool, we have to populate the `VkCommandPoolCreateInfo` struct. As
    usual, we specify the type. Then, we set the queue family index in which the pool
    has to be created. After that, we set the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    flags, which will reset the values of the command buffer every time. We then use
    the `vkCreateCommandPool` function by passing in the logical device and the info
    struct to get the command pool. Next, we create the `allocateCommandBuffers` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取当前设备的队列家族索引。为了创建命令池，我们必须填充`VkCommandPoolCreateInfo`结构体。像往常一样，我们指定类型。然后，我们设置池必须创建的队列家族索引。之后，我们设置`VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`标志，这将每次重置命令缓冲区的值。然后，我们通过传递逻辑设备和信息结构体来使用`vkCreateCommandPool`函数获取命令池。接下来，我们创建`allocateCommandBuffers`函数：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We resize the `commandBuffers` vector. Then, to allocate the command buffers,
    we have to populate `VkCommandBufferAllocateInfo`. We first set the type of the
    struct and the command pool. Then, we have to specify the level of the command
    buffers. You can have a chain of command buffers, with the primary command buffer
    containing the secondary command buffer. For our use, we will set the command
    buffers as primary. We then set `commandBufferCount`, which is equal to the swapchain
    pictures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整`commandBuffers`向量的大小。然后，为了分配命令缓冲区，我们必须填充`VkCommandBufferAllocateInfo`。我们首先设置结构体的类型和命令池。然后，我们必须指定命令缓冲区的级别。你可以有一个命令缓冲区的链，其中主命令缓冲区包含次级命令缓冲区。对于我们的用途，我们将命令缓冲区设置为主要的。然后，我们设置`commandBufferCount`，它等于交换链的图片数量。
- en: Then, we allocate the command buffers using the `vkAllocateCommandBuffers` function.
    We pass in the logical device, the info struct, and the command buffers to allocate
    memory for the command buffers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`vkAllocateCommandBuffers`函数分配命令缓冲区。我们传递逻辑设备、信息结构体和要分配内存的命令缓冲区。
- en: 'Then, we add `beginCommandBuffer`. This takes in the current command buffer
    to start recording commands in it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加`beginCommandBuffer`。这个函数接受当前命令缓冲区以开始在其中记录命令：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To record command buffers, we also have to populate `VkCommandBufferBeginInfoStruct`.
    Once again, we specify the struct type and the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`
    flag. This enables us to schedule the command buffer for the next frame while
    the last frame is still in use. `vkBeginCommandBuffer` is called to start recording
    the commands by passing in the current command buffer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录命令缓冲区，我们还需要填充`VkCommandBufferBeginInfoStruct`。再次指定结构体类型和`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`标志。这使我们能够在上一帧仍在使用时调度下一帧的命令缓冲区。通过传递当前命令缓冲区来调用`vkBeginCommandBuffer`以开始记录命令。
- en: 'Next, we add in the `endCommandBuffer` function. This function just calls `vkEndCommandBuffer`
    to stop recording to the command buffer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`endCommandBuffer`函数。这个函数只是调用`vkEndCommandBuffer`来停止向命令缓冲区记录：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can then destroy the command buffers and the pool using the `Destroy` function.
    Here, we just destroy the pool, which will destroy the command buffers as well:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Destroy`函数销毁命令缓冲区和池。在这里，我们只销毁池，这将销毁命令缓冲区：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `VulkanApplication.h` file, include `DrawCommandBuffer.h` and create
    an object of this class. In `VulkanApplication.cpp`, in the `VulkanInit` function,
    after creating `renderViewsAndFrameBuffers`, create `DrawCommandBuffer`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanApplication.h`文件中，包含`DrawCommandBuffer.h`并创建此类的对象。在`VulkanApplication.cpp`文件中，在`VulkanInit`函数中，在创建`renderViewsAndFrameBuffers`之后，创建`DrawCommandBuffer`：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Beginning and ending Renderpass
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和结束`Renderpass`
- en: 'Along with the commands being recorded in each frame, the renderpass is also
    processed for each frame where the color and the depth information is reset. So,
    since we only have color attachments in each frame, we have to clear the color
    information for each frame as well. Go back to the `Renderpass.h` file and add
    two new functions, called `beginRenderPass` and `endRenderPass`, in the class,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在每一帧中记录的命令外，每一帧的renderpass也会被处理，其中颜色和深度信息被重置。因此，由于我们每一帧中只有颜色附加层，我们必须为每一帧清除颜色信息。回到`Renderpass.h`文件，并在类中添加两个新函数，分别称为`beginRenderPass`和`endRenderPass`，如下所示：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `RenderPass.cpp`, add the implementation of the `beginRenderPass` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderPass.cpp`中，添加`beginRenderPass`函数的实现：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We then populate the `VkRenderPassBeginInfo` struct. In this, we specify the
    struct type, pass in the renderpass and the current framebuffer, set the render
    area as the whole viewport, and pass in the clear value and the count. The clear
    value is the color value we want to clear the screen with, and the count would
    be `1`, as we would like to clear only the color attachment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来填充`VkRenderPassBeginInfo`结构体。在这里，我们指定结构体类型，传入renderpass和当前framebuffer，设置渲染区域为整个viewport，并传入清除值和计数。清除值是我们想要清除屏幕的颜色值，计数将是`1`，因为我们只想清除颜色附加层。
- en: To begin the renderpass, we pass in the current command buffer, the info struct,
    and specify the third parameter as `VK_SUBPASS_CONTENTS_INLINE`, specifying that
    the renderpass commands are bound to the primary command buffer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始`Renderpass`，我们传入当前命令缓冲区、信息结构体，并将第三个参数指定为`VK_SUBPASS_CONTENTS_INLINE`，指定renderpass命令绑定到主命令缓冲区。
- en: 'In the `endCommandBuffer` function, we finish the `Renderpass` for the current
    frame:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`endCommandBuffer`函数中，我们完成当前帧的`Renderpass`：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To end the `Renderpass`, the `vkCmdEndRenderPass` function is called and the
    current command buffer is passed in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束`Renderpass`，调用`vkCmdEndRenderPass`函数并传入当前命令缓冲区。
- en: We have the required classes to get the clear screen going. Now, let's go to
    the Vulkan Application class and add some lines of code to get it working.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所需的类来开始清除屏幕。现在，让我们转到Vulkan应用程序类，并添加一些代码行以使其工作。
- en: Creating the clear screen
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建清除屏幕
- en: In the `VulkanApplication.h` file, we will add three new functions, called `drawBegin`,
    `drawEnd`, and `cleanup`. `drawBegin` will be called before we pass in any draw
    commands, and `drawEnd` will be called once the drawing is done and the frame
    is ready to be presented to the viewport. In the `cleanup` function, we will destroy
    all the resources.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanApplication.h`文件中，我们将添加三个新函数，分别称为`drawBegin`、`drawEnd`和`cleanup`。`drawBegin`将在传递任何绘图命令之前被调用，`drawEnd`将在绘图完成后、帧准备好呈现到viewport时被调用。在`cleanup`函数中，我们将销毁所有资源。
- en: 'We will also create two variables. The first is `uint32_t`, to get the current
    picture from the swapchain, and the second is `currentCommandBuffer` of the `VkCommandBuffer`
    type to get the current command buffer:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建两个变量。第一个是`uint32_t`，用于从swapchain获取当前图片，第二个是`currentCommandBuffer`，类型为`VkCommandBuffer`，用于获取当前命令缓冲区：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `VulkanApplication.cpp` file, we add the implementation of the `drawBegin`
    and `drawEnd` functions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanApplication.cpp`文件中，我们添加`drawBegin`和`drawEnd`函数的实现：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we acquire the next picture from the swap chain. This is done using the
    Vulkan `vkAcquireNextImageKHR` API call. To do this, we pass in the logical device,
    the swapchain instance. Next, we need to pass in the timeout, for which we pass
    in the maximum numerical value as we don't care about the time limit. The next
    two variables are kept as null. These require a semaphore and a fence, which we
    will discuss in a later chapter. Finally, we pass in the `imageIndex` itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从交换链中获取下一张图片。这是通过使用Vulkan的`vkAcquireNextImageKHR` API调用来完成的。为此，我们传递逻辑设备和交换链实例。接下来，我们需要传递超时时间，因为我们不关心时间限制，所以我们传递最大数值。接下来的两个变量保持为null。这些需要信号量和栅栏，我们将在后面的章节中讨论。最后，我们传递`imageIndex`本身。
- en: Then, we get the current command buffer from the command buffers vector. We
    begin recording the command buffer by calling `beginCommandBuffer` and the commands
    will be stored in the `currentCommandBuffer` object. We now start the renderpass.
    In this, we pass the clear color value, which is the color purple, because *why
    not?* ! Pass in the current `commandbuffer`, the frame buffer, and the picture extent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从命令缓冲区向量中获取当前命令缓冲区。我们通过调用`beginCommandBuffer`开始记录命令缓冲区，命令将被存储在`currentCommandBuffer`对象中。我们现在开始渲染过程。在这个过程中，我们传递清除颜色值，这是紫色，因为*为什么不呢？*！传递当前`commandbuffer`、帧缓冲区和图片范围。
- en: 'We can now implement the `drawEnd` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实现`drawEnd`函数：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We end the renderpass and stop recording to the command buffer. Then, we have
    to submit the command buffer and present the frame. To submit the command buffer,
    we create a `VkSubmitInfo` struct and populate it with the struct type, the buffer
    count, which is 1 per frame, and the command buffer itself. The command is submitted
    to the graphics queue by calling `vkQueueSubmit` and passing in the graphics queue,
    the submission count, and the submit info.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们结束渲染过程并停止向命令缓冲区记录。然后，我们必须提交命令缓冲区和呈现帧。要提交命令缓冲区，我们创建一个`VkSubmitInfo`结构体，并用结构体类型、每帧的缓冲区计数（每帧1个）和命令缓冲区本身填充它。通过调用`vkQueueSubmit`并将图形队列、提交计数和提交信息传递进去，命令被提交到图形队列。
- en: Once the frame is rendered, it is presented to the viewport using the present
    queue.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染了帧，它就会通过呈现队列呈现到视口。
- en: To present the scene once it is drawn, we have to create and populate the `VkPresentInfoKHR`
    struct. For presentation, the picture is sent back to the swapchain. When we create
    the info and set the type of the struct, we also have to set the swapchain, the
    image index, and the swapchain count, which is 1.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在绘制完成后呈现场景，我们必须创建并填充`VkPresentInfoKHR`结构体。对于呈现，图片被发送回交换链。当我们创建信息和设置结构体的类型时，我们还需要设置交换链、图像索引和交换链计数，该计数为1。
- en: 'We then present the picture using `vkQueuePresentKHR` by passing in the present
    queue and the present info to the function. At the end, we wait for the host to
    finish the presentation operation of a given queue using the `vkQueueWaitIdle` function,
    which takes in the present queue. Also, it is better to clean up the resources
    when you are done with them, so add the `cleanup` function as well:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`vkQueuePresentKHR`通过传递呈现队列和呈现信息到函数中来呈现图片。最后，我们使用`vkQueueWaitIdle`函数等待主机完成给定队列的呈现操作，该函数接受呈现队列。此外，当你完成使用资源时，最好清理资源，因此添加`cleanup`函数：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When we are destroying the objects, we have to call `vkDeviceWaitIdle` to stop
    using the device. Then, we destroy the objects in reverse order. So, we destroy
    the command buffer first, then the render texture resources, then renderpass,
    and then the swapchain. We then destroy the device, validation layer, surface,
    and finally, the Vulkan instance. Finally, we also delete the class instances
    we created for `DrawCommandBuffer`, `RenderTarget`, `Renderpass`, `Swapchain`,
    `Device`, `ValidationLayersAndExtensions`, and `VulkanInstance`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们销毁对象时，我们必须调用`vkDeviceWaitIdle`来停止使用设备。然后，我们以相反的顺序销毁对象。因此，我们首先销毁命令缓冲区，然后是渲染纹理资源，然后是渲染过程，然后是交换链。然后我们销毁设备、验证层、表面，最后是Vulkan实例。最后，我们删除为`DrawCommandBuffer`、`RenderTarget`、`Renderpass`、`Swapchain`、`Device`、`ValidationLayersAndExtensions`和`VulkanInstance`创建的类实例。
- en: And finally, we also delete the instance of `VulkanContext` as well and set
    it to `nullptr` after deleting it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们删除`VulkanContext`的实例，并在删除后将其设置为`nullptr`。
- en: 'In the `source.cpp` file, in the `while` loop, call the `drawBegin` and `drawEnd`
    functions. Then call the `cleanup` function after the loop:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`source.cpp`文件中的`while`循环中，调用`drawBegin`和`drawEnd`函数。然后在循环后调用`cleanup`函数：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You will see a purple viewport, as follows, when you build and run the command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建并运行命令时，你会看到一个紫色的视口，如下所示：
- en: '![](img/e6152ccd-b527-4376-b15f-b536ea987712.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6152ccd-b527-4376-b15f-b536ea987712.png)'
- en: 'The screen looks OK, but if you look at the console, you will see the following
    error, which says that when we call `vkAcquireNextImageKHR`, the semaphore and
    fence cannot both be `NULL`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕看起来没问题，但如果你查看控制台，你会看到以下错误，它说当我们调用`vkAcquireNextImageKHR`时，信号量和栅栏都不能为`NULL`：
- en: '![](img/e720f47c-eff8-4fde-9e32-8689885d1073.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e720f47c-eff8-4fde-9e32-8689885d1073.png)'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the creation of the swapchain, renderpass, render
    views, framebuffers, and the command buffers. We also looked at what each does
    and why they are important for rendering a clear screen.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了交换链、渲染通道、渲染视图、帧缓冲区和命令缓冲区的创建。我们还探讨了每个的作用以及为什么它们对于渲染清晰的屏幕很重要。
- en: In the next chapter, we will create the resources that will enable us to render
    geometry to the viewport. Once we have the object resources ready, we will render
    the objects. We will then explore semaphores and fences and why they are needed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建资源，使我们能够将几何图形渲染到视口中。一旦我们准备好了对象资源，我们将渲染这些对象。然后我们将探讨信号量和栅栏以及为什么它们是必需的。
