- en: Preparing the Clear Screen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备清除屏幕
- en: In the last chapter, we enabled the Vulkan validation layers and extensions,
    created the Vulkan application and instance, chose the device, and created the
    logical device. In this chapter, we will continue the journey toward creating
    a clear screen picture and presenting it to the viewport.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们启用了 Vulkan 验证层和扩展，创建了 Vulkan 应用程序和实例，选择了设备，并创建了逻辑设备。在这一章中，我们将继续探索创建清晰的屏幕图像并将其呈现到视口的过程。
- en: Before drawing pictures, we first clear and erase the previous picture with
    a color value. If we don't do this, the new picture will be written on top of
    the previous picture, which will create a psychedelic effect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制图像之前，我们首先使用一个颜色值清除和擦除之前的图像。如果我们不这样做，新的图像将覆盖在之前的图像上，这将产生一种迷幻的效果。
- en: Each picture is cleared and rendered and then presented on the screen. While
    the current one is being shown, the next picture is in the process of being drawn
    in the background. Once that is rendered, the current picture will be swapped
    with the new picture. This swapping of pictures is taken care of by the **SwapChain**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每幅图像被清除和渲染后，然后呈现在屏幕上。当当前图像正在显示时，下一幅图像已经在后台被绘制。一旦渲染完成，当前图像将与新图像交换。这种图像交换由 **SwapChain**
    负责处理。
- en: In our case, each picture in the SwapChain we are drawing simply stores the
    color information. This target picture is rendered and, hence, it is called the
    render target. We can also have other target pictures. For example, we can have
    a depth target/picture, which will store the depth information of each pixel per
    frame. Consequently, we create these render targets as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们正在绘制的 SwapChain 中的每一幅图像仅仅存储颜色信息。这个目标图像被渲染，因此被称为渲染目标。我们也可以有其他的目标图像。例如，我们可以有一个深度目标/图像，它将存储每帧每个像素的深度信息。因此，我们也创建了这些渲染目标。
- en: Each of these target pictures per frame is set as an attachment and used to
    create the framebuffer. Since we have double buffering (meaning we have two sets
    of pictures to swap between), we create a framebuffer for each frame. Consequently,
    we will create two framebuffers—one for each frame—and we will add the picture as
    an attachment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧的每个目标图像被设置为附件并用于创建帧缓冲区。由于我们采用双缓冲（意味着我们有两套图像进行交换），我们为每一帧创建一个帧缓冲区。因此，我们将为每一帧创建两个帧缓冲区——一个用于每一帧——并将图像作为附件添加。
- en: The commands that we give to the GPU—for example, the draw command—are sent
    to the GPU with each frame using a command buffer. The command buffer stores all
    the commands to be submitted to the GPU using the graphics queue of the device.
    So, for each frame, we create a command buffer to carry all our commands as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 GPU 的命令——例如，绘制命令——通过每个帧使用命令缓冲区发送到 GPU。命令缓冲区存储所有要使用设备图形队列提交给 GPU 的命令。因此，对于每一帧，我们创建一个命令缓冲区来携带我们所有的命令。
- en: Once the commands are submitted and the scene is rendered, instead of presenting
    the drawn picture to the screen, we can save it and add any post-processing effects
    to it, such as motion blur. In the renderpass, we can specify how the render target
    is to be used. Although in our case, we are not going to add any post-processing
    effects, we still need to create a renderpass. Consequently, we create a renderpass,
    which will specify to the device how many swap chain pictures and buffers we will
    be using, what kind of buffers they are, and how they are to be used.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令提交并且场景被渲染，我们不仅可以将绘制的图像呈现在屏幕上，我们还可以将其保存并添加任何后处理效果，例如运动模糊。在渲染过程中，我们可以指定渲染目标的使用方式。尽管在我们的案例中，我们不会添加任何后处理效果，但我们仍然需要创建一个渲染过程。因此，我们创建了一个渲染过程，它将指定我们将使用多少
    SwapChain 图像和缓冲区，它们是什么类型的缓冲区，以及它们应该如何使用。
- en: 'The different stages the picture will go through are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图像将经历的各个阶段如下：
- en: '![](img/42991319-7f62-4966-8aee-afd84dc7cc22.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42991319-7f62-4966-8aee-afd84dc7cc22.png)'
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Creating `SwapChain`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `SwapChain`
- en: Creating `Renderpass`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Renderpass`
- en: Using render views and `Framebuffers`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用渲染视图和 `Framebuffers`
- en: Creating `CommandBuffer`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `CommandBuffer`
- en: Beginning and ending `Renderpass`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束 `Renderpass`
- en: Creating the clear screen
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建清除屏幕
- en: Creating SwapChain
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SwapChain
- en: While the scene is rendered, the buffers are swapped and presented to the window
    surface. The surface is platform-dependent and, depending upon the operating system,
    we have to choose the surface format accordingly. For the scene to be presented
    properly, we create the `SwapChain`, depending upon the surface format, presentation
    mode, and the extent, meaning the width and height, of the picture that the window
    can support.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](dc30df72-df2e-4bb9-a598-a481ecb595f3.xhtml), *Drawing Vulkan
    Objects*, when we chose the GPU device to use, we retrieved the properties of
    the device, such as the surface format and the presentation modes it supports.
    While we create the `SwapChain`, we match and check the surface format and the
    presentation that is available from the device, and that is also supported by
    the window to create the `SwapChain` object itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new class called `SwapChain` and add the following includes to `SwapChain.h`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then create the class, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the public section of the class, we create the constructor and the destructor.
    Then, we create the variables of the `VkSwapchainKHR`, `VkFormat`, and `VkExtent2D` types
    to store the `swapchain` itself. When we create the surface, we store the format
    of the picture itself, which is supported, as well as the extent of the picture,
    which is the width and height of the viewport. This is because, when the viewport
    is stretched or changed, the size of the swapchain picture will also be changed
    accordingly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We create a vector of the `VkImage` type, called `swapChainImages`, to store
    the SwapChain pictures. Three helper functions, `chooseSwapChainSurfaceFormat`, 
    `chooseSwapPresentMode`, and `chooseSwapExtent`, are created to get the most suitable
    surface format, present mode, and SwapChain extent. Finally, the `create` function
    takes the surface in which we will create the swapchain itself. We also add a
    function to destroy and release the resources back to the system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: That is it for the `SwapChain.h` file. We will now move on to `SwapChain.cpp`
    to incorporate the implementation of the functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SwapChain.cpp` file, add the following includes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will need to include `VulkanContext.h`  to get the device's `SwapChainSupportDetails`
    struct, which we populated in the last chapter when we selected the physical device
    and created the logical device. Before we create the swapchain, let's first look
    at the three helper functions and see how each is created.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of the three functions is `chooseSwapChainSurfaceFormat`. This function
    takes in a vector of `VkSurfaceFormatKHR`, which is the available format supported
    by the device. Using this function, we will choose the surface format that is
    most suitable. The function is created as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we check whether the available format is just `1` and whether it is undefined
    by the device. This means that there is no preferred format, so we choose the
    one that is most convenient for us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The values returned are the color format and color space. The color format specifies
    the format of the color itself, `VK_FORMAT_B8G8R8A8_UNORM`, which tells us that
    we store 32 bits of information in each pixel. The colors are stored in the Blue,
    Green, Red, and Alpha channels, and in that order. Each channel is stored in 8
    bits, so that means 2^8, which is 256 color values. `UNORM` suggests that each
    color value is normalized, so the color values, instead of being from 0-255, are
    normalized between 0 and 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: We choose the SRGB color space as the second parameter, as we want more of a
    range of colors to be represented. If there is no preferred format, we go through
    the formats available and then check and return the ones that we need. We choose
    this color space, as most surfaces support this format because it is widely available.
    Otherwise, we just return the first available format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function is `chooseSwapPresentMode`, which takes in a vector of `VkPresentModeKHR`
    called `availablePresentModes`. Presentation modes specify how the final rendered
    picture is presented to the viewport. Here are the available modes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_PRESENT_MODE_IMMEDIATE_KHR`: In this case, the picture will be displayed
    as soon as a picture is available to present. Pictures are not queued to be displayed.
    This causes picture tearing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PRESENT_MODE_FIFO_KHR`: The acquired pictures to be presented are put in
    a queue. The size of the queue is one minus the swap chain size. At vsync, the
    first picture to be displayed gets displayed in the **First In First Out (FIFO)**
    manner. There is no tearing as pictures are displayed in the same order in which
    they were added to the queue and vsync is enabled. This mode needs to always be
    supported.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PRESENT_MODE_FIFO_RELAXED_KHR`: This is a variation of the `FIFO` mode.
    In this mode, if the rendering is faster than the refresh rate of the monitor,
    it is fine, but if the drawing is slower than the monitor, there will be screen
    tearing as the next available picture is presented immediately.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PRESENTATION_MODE_MAILBOX_KHR`: The presentation of the pictures is put
    in a queue, but it has just one element in it, unlike `FIFO`, which has more than
    one element in the queue. The next picture to be displayed will wait for the queue
    to be displayed and then the presentation engine will display the picture. This
    doesn''t cause tearing.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this information, let''s create the `chooseSwapPresentMode` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the `FIFO` mode is our most preferred mode, we set it in the function
    so that we can compare it with the available modes of the device. If it is not
    available, we go for the next best mode, which is the `MAILBOX` mode, so that
    the presentation queue will have at least one more picture to avoid screen tearing.
    If neither mode is available, we go for the `IMMEDIATE` mode, which is least desirable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The third function is the `chooseSwapExtent` function. In this function, we
    get the resolution of the window that we drew to set the resolution of the swapchain
    pictures. It is added as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The resolution of this window should match the swapchain pictures. Some window
    managers allow the resolution to be different between the pictures and the window.
    This is indicated by setting the value to the maximum of `uint32_t`. If not, then
    in that case, we return the current extent that we retrieved by the capabilities
    of the hardware, or pick the resolution that best matches the resolution between
    the maximum and minimum values available, as compared to the actual resolution
    we set, which is 1,280 x 720.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the `create` function, in which we actually create the `SwapChain`
    itself. To create this function, we will add the functionality to create the `SwapChain`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first thing we do is get the device support details, which we retrieved
    for our device when we created the `Device` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, using the `helper` function we created, we get the surface format, present
    mode, and the extent:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then set the minimum number of pictures required to make the swapchain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should also make sure that we don''t exceed the maximum available picture
    count, so if the `imageCount` is more than the maximum amount, we set `imageCount`
    to the maximum count:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create the swapchain, we have to populate the `VkSwapchainCreateInfoKHR`
    struct first, so let''s create it. Create a variable called `createInfo` and specify
    the type of the structure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this, we have to specify the surface to use, the minimum picture count,
    the picture format, the space, and the extent. We also need to specify the picture array
    layers. Since we are not going to create a stereoscopic application like a virtual
    reality game, in which there would be two surfaces, one for the left eye and one
    for the right eye, instead, we just set the value for it as `1`. We also need
    to specify what the picture will be used for. Here, it will be used to show the
    color information using the color attachment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now specify the graphics, presentation indices, and the count. We also specify
    the sharing mode. It is possible for the presentation and graphics family to be
    either the same or different.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'If the presentation and graphics family is different, the sharing mode is said
    to be of the `VK_SHARING_MODE_CONCURRENT` type. This means that the picture can
    be used across multiple queue families. However, if the picture is in the same
    queue family, the sharing mode is said to be of the `VK_SHARING_MODE_EXCLUSIVE` type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we want, we can apply a pre-transform to the picture to either flip it or
    mirror it. In this case, we just keep the current transform. We can also alpha-blend
    the picture with other window systems, but we just keep it opaque and ignore the
    alpha channel, set the present mode, and set whether the pixel should be clipped
    if there is a window in front. We can also specify an old `SwapChain` if the current
    one becomes invalid when we resize the window. Since we don't resize the window,
    we don't have to specify an older swapchain.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the info struct, we can create the swapchain itself:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We create the swapchain using the `vkCreateSwapchainKHR` function, which takes
    the logical device, the `createInfo` struct, an allocator callback, and the swapchain
    itself. If it doesn't create the `SwapChain` because of an error, we will send
    out an error. Now that the swapchain is created, we will obtain the swapchain
    pictures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending upon the picture count, we call the `vkGetSwapchainImagesKHR` function,
    which we use to first get the picture count and then call the function again to
    populate the `vkImage` vector with the pictures:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The creation of pictures is a bit more involved, but Vulkan automatically creates
    color pictures. We can set the picture format and extent as well:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we add the `destroy` function, which destroys the `SwapChain` by calling
    the `vkDestroySwapchainKHR` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `VulkanApplication.h` file, include the `SwapChain` header and create
    a new `SwapChain` instance in the `VulkanApplication` class. In `VulkanApplication.cpp`,
    in the `initVulkan` function, after creating the logical device, create the `SwapChain`
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Build and run the application to make sure the `SwapChain` is created without
    any errors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Creating Renderpass
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the `SwapChain`, we move on to the Renderpass. Here, we specify
    how many color attachments and depth attachments are present and how many samples
    to use for each of them for each framebuffer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the start of this chapter, a framebuffer is a collection of
    target attachments. Attachments can be of type color, depth, and so on. The color
    attachment stores the color information that is presented to the viewport. There
    are other attachments that the end user doesn't see, but that are used internally.
    This includes depth, for example, which has all the depth information per pixel.
    In the render pass, apart from the type of attachments, we also specify how the
    attachments are used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will be presenting what is rendered in a scene to the viewport,
    so we will just use a single pass. If we add a post-processing effect, we will
    take the rendered picture and apply this effect to it, for which we will need
    to use multiple passes. We will create a new class called `Renderpass`, in which
    we will create the render pass.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Renderpass.h` file, add the following includes and class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the class, add the constructor, destructor, and the `VkRenderPass` and `renderPass`
    variables. Add a new function called `createRenderPass` to create the `Renderpass`
    itself, which takes in the picture format. Also, add a function to destroy the
    `Renderpass` object after use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Renderpass.cpp` file, add the following includes, as well as the constructor
    and destructor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now add the `createRenderPass` function, in which we will add the functionality
    to create the Renderpass for the current scene to be rendered:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we create the render pass, we have to specify the number and the type of
    attachments that we are using. So, for our project, we want only color attachments
    as we will only be drawing color information. We could also have a depth attachment,
    which stores depth information. We need to provide subpasses, and if so, then
    how many, as we could be using subpasses for adding post-processing effects to
    the current frame.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: For the attachments and subpasses, we have to populate structs to pass to them
    at the time of creating the render pass.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s populate the structs. First, we create the attachments:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create the struct and specify the format to be used, which is the same as
    the `swapChainImage` format. We have to provide the sample count as 1 as we are
    not going to be using multi-sampling. In `loadOp` and `storeOp`, we specify what
    to do with the data before and after rendering. We specify that at the time of
    loading the attachment, we will clear the data to a constant at the start. After
    the render process, we store the data so we can read from it later. We then decide
    what to do with the data before and after the stencil operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not using the stencil buffer, we specify DON'T CARE during loading
    and storing. We also have to specify the data layout before and after processing
    the picture. The previous layout of the picture doesn't matter, but after rendering,
    the picture needs to be changed to the layout in order for it to be ready for
    presenting.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll go through the subpass. Each subpass references the attachments
    that need to be specified as a separate structure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `subpass` reference, we specify the attachment index, which is the 0^(th)
    index and specify the layout, which is a color attachment with optimal performance.
    Next, we create the `subpass` structure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the pipeline bind point, we specify that this is a graphics subpass, as
    it could have been a compute subpass. Specify the attachment count as `1` and
    provide the color attachment. Now, we can create the renderpass info struct:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We create an array of one element of the `VkAttachmentDescription` type, and
    then we create the info struct and pass in the type. The attachment count and
    the attachments are passed in, and then the subpass count and the subpass is passed
    in as well. Create the renderpass itself by calling `vkCreateRenderPass` and passing
    in the logical device, the create info, and the allocator callback to get the
    renderpass:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, in the `destroy` function, we call `vkDestroyRenderPass` to destroy
    it after we are done:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `VulkanApplication.h`, include `RenderPass.h` and create a render pass object.
    In `VulkanApplication.cpp`, after creating the swapchain, create the renderpass:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, build and run the project to make sure there are no errors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Using render targets and framebuffers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use a picture, we have to create an `ImageView`. The picture doesn't have
    any information, such as mipmap levels, and you can't access a portion of the
    picture. However, by now using picture views, we specify the type of the texture
    and whether it has mipmaps. In addition, in renderpass, we specified the attachments
    per frame buffer. We will create framebuffers here and pass in the picture views
    as attachments.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `RenderTexture`. In the `RenderTexture.h` file, add
    the following headers and then create the class itself:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the class, we add the constructor and destructor as usual. We will store
    `swapChainImages` and the extent to use it locally. We create two vectors to store
    the created ImageViews and framebuffers. To create the views and framebuffers,
    we will call the `createViewsAndFramebuffers` function, which takes the pictures,
    picture format, extent, and the renderpass as the input. This function intern
    will call `createImageViews` and `CreateFramebuffer` to create the views and buffers.
    We will add the `destroy` function, which destroys and releases the resources
    back to the system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `RenderTexture.cpp` file, we will add the following includes as well
    as the constructor and destructor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, add the `createViewAndFramebuffer` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We first assign the images and `imageExtent` to the local variables. Then,
    we call the `imageViews` function, followed by `createFramebuffer`, in order to
    create both of them. To create the image views, use the `createImageViews` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We specify the vector size depending upon the swapchain image count first.
    For each of the image counts, we create image views using the `createImageView`
    function in the `vkTool` namespace. The `createImageView` function takes in the
    image itself, the image format, and `ImageAspectFlag`. This will be `VK_IMAGE_ASPECT_COLOR_BIT`
    or `VK_IMAGE_ASPECT_DEPTH_BIT` depending on the kind of view that you want to
    create for the image. The `createImageView` function is created in the `Tools.h`
    file under the `vkTools` namespace. The `Tools.h` file is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The implementation of the function is created in the `Tools.cpp` file as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To create the `imageView`, we have to populate the `VkImageViewCreateInfo` struct
    and then use the `vkCreateImageView` function to create the view itself. To populate
    the view info, we specify the structure type, the picture itself, the view type,
    which is `VK_IMAGE_VIEW_TYPE_2D`, and a 2D texture, and then specify the format.
    We pass in the aspectFlags for the aspect mask. We create the image view without
    any mipmap level or layers, so we set them to `0`. We would only need multiple
    layers if we were making something like a VR game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `imageView`，我们必须填充 `VkImageViewCreateInfo` 结构体，然后使用 `vkCreateImageView`
    函数创建视图本身。为了填充视图信息，我们指定结构体类型、图片本身、视图类型，即 `VK_IMAGE_VIEW_TYPE_2D`、一个 2D 纹理，然后指定格式。我们传递
    aspectFlags 用于方面掩码。我们创建的图像视图没有任何 mipmap 级别或层，因此我们将它们设置为 `0`。如果我们正在制作类似 VR 游戏的东西，我们才需要多个层。
- en: We then create an `imageView` of the `VkImage` type and create it using the
    `vkCreateImageView` function, which takes in the logical device, the view info
    struct, and then the picture view is created and returned. That's all for the
    Tools file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `VkImage` 类型的 `imageView` 并使用 `vkCreateImageView` 函数创建它，该函数接受逻辑设备、视图信息结构体，然后创建并返回图片视图。这就是
    Tools 文件的所有内容。
- en: We will use the Tools file and add more functions to it when we want functions
    that can be reused. Now, let's go back to the `RenderTexture.cpp` file and add
    in the function to create the framebuffer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要可重用的函数时，我们将使用 Tools 文件并为其添加更多函数。现在，让我们回到 `RenderTexture.cpp` 文件并添加创建帧缓冲区的函数。
- en: 'We will create framebuffers for each frame in the swapchain. `createFramebuffer`
    requires the picture extent and the renderpass itself:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为交换链中的每一帧创建帧缓冲区。`createFramebuffer` 函数需要图片范围和渲染通道本身：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For each frame that we create, the Framebuffer first populates the `framebufferInfo`
    struct and then calls `vkCreateFramebuffer` to create the Framebuffer itself.
    For each frame, we create a new info struct and specify the type of struct. We
    then pass the renderpass, the attachment count, and the attachment views, specify
    the width and height of the Framebuffer, and set the layers to `1`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们创建的每一帧，帧缓冲区首先填充 `framebufferInfo` 结构体，然后调用 `vkCreateFramebuffer` 创建帧缓冲区本身。对于每一帧，我们创建一个新的信息结构体并指定结构体类型。然后我们传递渲染通道、附件数量和附件视图，指定帧缓冲区的宽度和高度，并将层设置为
    `1`。
- en: 'Finally, we create the framebuffer by calling the `vkCreateFramebuffer` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用 `vkCreateFramebuffer` 函数创建帧缓冲区：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `destroy` function, we destroy each of the picture views and framebuffers
    we created by calling `vkDestroyImageView` and `vkDestroyFramebuffer`. And that
    is all for the `RenderTexture` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `destroy` 函数中，我们通过调用 `vkDestroyImageView` 和 `vkDestroyFramebuffer` 销毁我们创建的每个图像视图和帧缓冲区。这就是
    `RenderTexture` 类的所有内容。
- en: 'In `VulkanApplication.h`, include `RenderTexture.h` and create an instance
    of it called `renderTexture` in the `VulkanApplication` class. In the `VulkanApplication.cpp`
    file, include the `initVulkan` function and create a new `RenderTexture`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `VulkanApplication.h` 中，包含 `RenderTexture.h` 并在 `VulkanApplication` 类中创建一个名为
    `renderTexture` 的其实例。在 `VulkanApplication.cpp` 文件中，包含 `initVulkan` 函数并创建一个新的 `RenderTexture`：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating CommandBuffer
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令缓冲区
- en: In Vulkan, the drawing and other operations done on the GPU are performed using
    command buffers. The command buffers contain the draw commands, which are recorded
    and then executed. Draw commands are to be recorded and executed in every frame.
    To create a command buffer, we have to first create a command pool and then allocate
    command buffers from the command pool, and then the commands are recorded per
    frame.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，GPU 上执行的所有绘图和其他操作都使用命令缓冲区完成。命令缓冲区包含绘图命令，这些命令被记录并执行。绘图命令需要在每一帧中记录和执行。要创建命令缓冲区，我们必须首先创建命令池，然后从命令池中分配命令缓冲区，然后按帧记录命令。
- en: 'Let''s create a new class for creating the command buffer pool and then allocate
    the command buffers. We also create a function to start and stop recording and
    to destroy the command buffers. Create a new class, called `DrawCommandBuffer`,
    and `DrawCommandBuffer.h` as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的类来创建命令缓冲池，并分配命令缓冲区。我们还要创建一个用于开始和停止录制以及销毁命令缓冲区的函数。创建一个新的类，命名为 `DrawCommandBuffer`，以及
    `DrawCommandBuffer.h` 如下所示：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the class, we create the constructor and destructor. We create variables
    to store the command pool and a vector to store `VkCommandBuffer`. We create one
    function initially to create the command pool and allocate the command buffers.
    The next two functions, `beginCommandBuffer` and `endCommandBuffer`, will be called
    when we want to start and stop recording the command buffer. The `createCommandPool`
    and `allocateCommandBuffers` functions will be called by `createCommandPoolAndBuffer`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the `destroy` function to destroy the command buffers when we
    want the resources to be released to the system. In `CommandBuffer.cpp`, add the
    necessary includes and the constructor and destructor:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we add `createCommandPoolAndBuffer`, which takes in the picture count:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `createCommandPoolAndBuffer` function will call the `createCommandPool`
    and `allocateCommandBuffers` functions. First, we create the `createCommandPool`
    function. Commands have to be sent to a certain queue. We have to specify the
    queue when we create the command pool:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To start, we get the queue family indices for the current device. To create
    the command pool, we have to populate the `VkCommandPoolCreateInfo` struct. As
    usual, we specify the type. Then, we set the queue family index in which the pool
    has to be created. After that, we set the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    flags, which will reset the values of the command buffer every time. We then use
    the `vkCreateCommandPool` function by passing in the logical device and the info
    struct to get the command pool. Next, we create the `allocateCommandBuffers` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We resize the `commandBuffers` vector. Then, to allocate the command buffers,
    we have to populate `VkCommandBufferAllocateInfo`. We first set the type of the
    struct and the command pool. Then, we have to specify the level of the command
    buffers. You can have a chain of command buffers, with the primary command buffer
    containing the secondary command buffer. For our use, we will set the command
    buffers as primary. We then set `commandBufferCount`, which is equal to the swapchain
    pictures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Then, we allocate the command buffers using the `vkAllocateCommandBuffers` function.
    We pass in the logical device, the info struct, and the command buffers to allocate
    memory for the command buffers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add `beginCommandBuffer`. This takes in the current command buffer
    to start recording commands in it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To record command buffers, we also have to populate `VkCommandBufferBeginInfoStruct`.
    Once again, we specify the struct type and the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`
    flag. This enables us to schedule the command buffer for the next frame while
    the last frame is still in use. `vkBeginCommandBuffer` is called to start recording
    the commands by passing in the current command buffer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add in the `endCommandBuffer` function. This function just calls `vkEndCommandBuffer`
    to stop recording to the command buffer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can then destroy the command buffers and the pool using the `Destroy` function.
    Here, we just destroy the pool, which will destroy the command buffers as well:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Destroy`函数销毁命令缓冲区和池。在这里，我们只销毁池，这将销毁命令缓冲区：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `VulkanApplication.h` file, include `DrawCommandBuffer.h` and create
    an object of this class. In `VulkanApplication.cpp`, in the `VulkanInit` function,
    after creating `renderViewsAndFrameBuffers`, create `DrawCommandBuffer`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanApplication.h`文件中，包含`DrawCommandBuffer.h`并创建此类的对象。在`VulkanApplication.cpp`文件中，在`VulkanInit`函数中，在创建`renderViewsAndFrameBuffers`之后，创建`DrawCommandBuffer`：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Beginning and ending Renderpass
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和结束`Renderpass`
- en: 'Along with the commands being recorded in each frame, the renderpass is also
    processed for each frame where the color and the depth information is reset. So,
    since we only have color attachments in each frame, we have to clear the color
    information for each frame as well. Go back to the `Renderpass.h` file and add
    two new functions, called `beginRenderPass` and `endRenderPass`, in the class,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在每一帧中记录的命令外，每一帧的renderpass也会被处理，其中颜色和深度信息被重置。因此，由于我们每一帧中只有颜色附加层，我们必须为每一帧清除颜色信息。回到`Renderpass.h`文件，并在类中添加两个新函数，分别称为`beginRenderPass`和`endRenderPass`，如下所示：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `RenderPass.cpp`, add the implementation of the `beginRenderPass` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderPass.cpp`中，添加`beginRenderPass`函数的实现：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We then populate the `VkRenderPassBeginInfo` struct. In this, we specify the
    struct type, pass in the renderpass and the current framebuffer, set the render
    area as the whole viewport, and pass in the clear value and the count. The clear
    value is the color value we want to clear the screen with, and the count would
    be `1`, as we would like to clear only the color attachment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来填充`VkRenderPassBeginInfo`结构体。在这里，我们指定结构体类型，传入renderpass和当前framebuffer，设置渲染区域为整个viewport，并传入清除值和计数。清除值是我们想要清除屏幕的颜色值，计数将是`1`，因为我们只想清除颜色附加层。
- en: To begin the renderpass, we pass in the current command buffer, the info struct,
    and specify the third parameter as `VK_SUBPASS_CONTENTS_INLINE`, specifying that
    the renderpass commands are bound to the primary command buffer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始`Renderpass`，我们传入当前命令缓冲区、信息结构体，并将第三个参数指定为`VK_SUBPASS_CONTENTS_INLINE`，指定renderpass命令绑定到主命令缓冲区。
- en: 'In the `endCommandBuffer` function, we finish the `Renderpass` for the current
    frame:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`endCommandBuffer`函数中，我们完成当前帧的`Renderpass`：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To end the `Renderpass`, the `vkCmdEndRenderPass` function is called and the
    current command buffer is passed in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束`Renderpass`，调用`vkCmdEndRenderPass`函数并传入当前命令缓冲区。
- en: We have the required classes to get the clear screen going. Now, let's go to
    the Vulkan Application class and add some lines of code to get it working.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所需的类来开始清除屏幕。现在，让我们转到Vulkan应用程序类，并添加一些代码行以使其工作。
- en: Creating the clear screen
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建清除屏幕
- en: In the `VulkanApplication.h` file, we will add three new functions, called `drawBegin`,
    `drawEnd`, and `cleanup`. `drawBegin` will be called before we pass in any draw
    commands, and `drawEnd` will be called once the drawing is done and the frame
    is ready to be presented to the viewport. In the `cleanup` function, we will destroy
    all the resources.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanApplication.h`文件中，我们将添加三个新函数，分别称为`drawBegin`、`drawEnd`和`cleanup`。`drawBegin`将在传递任何绘图命令之前被调用，`drawEnd`将在绘图完成后、帧准备好呈现到viewport时被调用。在`cleanup`函数中，我们将销毁所有资源。
- en: 'We will also create two variables. The first is `uint32_t`, to get the current
    picture from the swapchain, and the second is `currentCommandBuffer` of the `VkCommandBuffer`
    type to get the current command buffer:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建两个变量。第一个是`uint32_t`，用于从swapchain获取当前图片，第二个是`currentCommandBuffer`，类型为`VkCommandBuffer`，用于获取当前命令缓冲区：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `VulkanApplication.cpp` file, we add the implementation of the `drawBegin`
    and `drawEnd` functions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanApplication.cpp`文件中，我们添加`drawBegin`和`drawEnd`函数的实现：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we acquire the next picture from the swap chain. This is done using the
    Vulkan `vkAcquireNextImageKHR` API call. To do this, we pass in the logical device,
    the swapchain instance. Next, we need to pass in the timeout, for which we pass
    in the maximum numerical value as we don't care about the time limit. The next
    two variables are kept as null. These require a semaphore and a fence, which we
    will discuss in a later chapter. Finally, we pass in the `imageIndex` itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get the current command buffer from the command buffers vector. We
    begin recording the command buffer by calling `beginCommandBuffer` and the commands
    will be stored in the `currentCommandBuffer` object. We now start the renderpass.
    In this, we pass the clear color value, which is the color purple, because *why
    not?* ! Pass in the current `commandbuffer`, the frame buffer, and the picture extent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now implement the `drawEnd` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We end the renderpass and stop recording to the command buffer. Then, we have
    to submit the command buffer and present the frame. To submit the command buffer,
    we create a `VkSubmitInfo` struct and populate it with the struct type, the buffer
    count, which is 1 per frame, and the command buffer itself. The command is submitted
    to the graphics queue by calling `vkQueueSubmit` and passing in the graphics queue,
    the submission count, and the submit info.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Once the frame is rendered, it is presented to the viewport using the present
    queue.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: To present the scene once it is drawn, we have to create and populate the `VkPresentInfoKHR`
    struct. For presentation, the picture is sent back to the swapchain. When we create
    the info and set the type of the struct, we also have to set the swapchain, the
    image index, and the swapchain count, which is 1.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We then present the picture using `vkQueuePresentKHR` by passing in the present
    queue and the present info to the function. At the end, we wait for the host to
    finish the presentation operation of a given queue using the `vkQueueWaitIdle` function,
    which takes in the present queue. Also, it is better to clean up the resources
    when you are done with them, so add the `cleanup` function as well:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When we are destroying the objects, we have to call `vkDeviceWaitIdle` to stop
    using the device. Then, we destroy the objects in reverse order. So, we destroy
    the command buffer first, then the render texture resources, then renderpass,
    and then the swapchain. We then destroy the device, validation layer, surface,
    and finally, the Vulkan instance. Finally, we also delete the class instances
    we created for `DrawCommandBuffer`, `RenderTarget`, `Renderpass`, `Swapchain`,
    `Device`, `ValidationLayersAndExtensions`, and `VulkanInstance`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we also delete the instance of `VulkanContext` as well and set
    it to `nullptr` after deleting it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `source.cpp` file, in the `while` loop, call the `drawBegin` and `drawEnd`
    functions. Then call the `cleanup` function after the loop:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You will see a purple viewport, as follows, when you build and run the command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建并运行命令时，你会看到一个紫色的视口，如下所示：
- en: '![](img/e6152ccd-b527-4376-b15f-b536ea987712.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6152ccd-b527-4376-b15f-b536ea987712.png)'
- en: 'The screen looks OK, but if you look at the console, you will see the following
    error, which says that when we call `vkAcquireNextImageKHR`, the semaphore and
    fence cannot both be `NULL`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕看起来没问题，但如果你查看控制台，你会看到以下错误，它说当我们调用`vkAcquireNextImageKHR`时，信号量和栅栏都不能为`NULL`：
- en: '![](img/e720f47c-eff8-4fde-9e32-8689885d1073.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e720f47c-eff8-4fde-9e32-8689885d1073.png)'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the creation of the swapchain, renderpass, render
    views, framebuffers, and the command buffers. We also looked at what each does
    and why they are important for rendering a clear screen.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了交换链、渲染通道、渲染视图、帧缓冲区和命令缓冲区的创建。我们还探讨了每个的作用以及为什么它们对于渲染清晰的屏幕很重要。
- en: In the next chapter, we will create the resources that will enable us to render
    geometry to the viewport. Once we have the object resources ready, we will render
    the objects. We will then explore semaphores and fences and why they are needed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建资源，使我们能够将几何图形渲染到视口中。一旦我们准备好了对象资源，我们将渲染这些对象。然后我们将探讨信号量和栅栏以及为什么它们是必需的。
