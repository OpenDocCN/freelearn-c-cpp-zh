- en: Preparing the Clear Screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we enabled the Vulkan validation layers and extensions,
    created the Vulkan application and instance, chose the device, and created the
    logical device. In this chapter, we will continue the journey toward creating
    a clear screen picture and presenting it to the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Before drawing pictures, we first clear and erase the previous picture with
    a color value. If we don't do this, the new picture will be written on top of
    the previous picture, which will create a psychedelic effect.
  prefs: []
  type: TYPE_NORMAL
- en: Each picture is cleared and rendered and then presented on the screen. While
    the current one is being shown, the next picture is in the process of being drawn
    in the background. Once that is rendered, the current picture will be swapped
    with the new picture. This swapping of pictures is taken care of by the **SwapChain**.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, each picture in the SwapChain we are drawing simply stores the
    color information. This target picture is rendered and, hence, it is called the
    render target. We can also have other target pictures. For example, we can have
    a depth target/picture, which will store the depth information of each pixel per
    frame. Consequently, we create these render targets as well.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these target pictures per frame is set as an attachment and used to
    create the framebuffer. Since we have double buffering (meaning we have two sets
    of pictures to swap between), we create a framebuffer for each frame. Consequently,
    we will create two framebuffers—one for each frame—and we will add the picture as
    an attachment.
  prefs: []
  type: TYPE_NORMAL
- en: The commands that we give to the GPU—for example, the draw command—are sent
    to the GPU with each frame using a command buffer. The command buffer stores all
    the commands to be submitted to the GPU using the graphics queue of the device.
    So, for each frame, we create a command buffer to carry all our commands as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once the commands are submitted and the scene is rendered, instead of presenting
    the drawn picture to the screen, we can save it and add any post-processing effects
    to it, such as motion blur. In the renderpass, we can specify how the render target
    is to be used. Although in our case, we are not going to add any post-processing
    effects, we still need to create a renderpass. Consequently, we create a renderpass,
    which will specify to the device how many swap chain pictures and buffers we will
    be using, what kind of buffers they are, and how they are to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different stages the picture will go through are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42991319-7f62-4966-8aee-afd84dc7cc22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating `SwapChain`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `Renderpass`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using render views and `Framebuffers`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `CommandBuffer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning and ending `Renderpass`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the clear screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating SwapChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the scene is rendered, the buffers are swapped and presented to the window
    surface. The surface is platform-dependent and, depending upon the operating system,
    we have to choose the surface format accordingly. For the scene to be presented
    properly, we create the `SwapChain`, depending upon the surface format, presentation
    mode, and the extent, meaning the width and height, of the picture that the window
    can support.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](dc30df72-df2e-4bb9-a598-a481ecb595f3.xhtml), *Drawing Vulkan
    Objects*, when we chose the GPU device to use, we retrieved the properties of
    the device, such as the surface format and the presentation modes it supports.
    While we create the `SwapChain`, we match and check the surface format and the
    presentation that is available from the device, and that is also supported by
    the window to create the `SwapChain` object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new class called `SwapChain` and add the following includes to `SwapChain.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the public section of the class, we create the constructor and the destructor.
    Then, we create the variables of the `VkSwapchainKHR`, `VkFormat`, and `VkExtent2D` types
    to store the `swapchain` itself. When we create the surface, we store the format
    of the picture itself, which is supported, as well as the extent of the picture,
    which is the width and height of the viewport. This is because, when the viewport
    is stretched or changed, the size of the swapchain picture will also be changed
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We create a vector of the `VkImage` type, called `swapChainImages`, to store
    the SwapChain pictures. Three helper functions, `chooseSwapChainSurfaceFormat`, 
    `chooseSwapPresentMode`, and `chooseSwapExtent`, are created to get the most suitable
    surface format, present mode, and SwapChain extent. Finally, the `create` function
    takes the surface in which we will create the swapchain itself. We also add a
    function to destroy and release the resources back to the system.
  prefs: []
  type: TYPE_NORMAL
- en: That is it for the `SwapChain.h` file. We will now move on to `SwapChain.cpp`
    to incorporate the implementation of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SwapChain.cpp` file, add the following includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will need to include `VulkanContext.h`  to get the device's `SwapChainSupportDetails`
    struct, which we populated in the last chapter when we selected the physical device
    and created the logical device. Before we create the swapchain, let's first look
    at the three helper functions and see how each is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of the three functions is `chooseSwapChainSurfaceFormat`. This function
    takes in a vector of `VkSurfaceFormatKHR`, which is the available format supported
    by the device. Using this function, we will choose the surface format that is
    most suitable. The function is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether the available format is just `1` and whether it is undefined
    by the device. This means that there is no preferred format, so we choose the
    one that is most convenient for us.
  prefs: []
  type: TYPE_NORMAL
- en: The values returned are the color format and color space. The color format specifies
    the format of the color itself, `VK_FORMAT_B8G8R8A8_UNORM`, which tells us that
    we store 32 bits of information in each pixel. The colors are stored in the Blue,
    Green, Red, and Alpha channels, and in that order. Each channel is stored in 8
    bits, so that means 2^8, which is 256 color values. `UNORM` suggests that each
    color value is normalized, so the color values, instead of being from 0-255, are
    normalized between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: We choose the SRGB color space as the second parameter, as we want more of a
    range of colors to be represented. If there is no preferred format, we go through
    the formats available and then check and return the ones that we need. We choose
    this color space, as most surfaces support this format because it is widely available.
    Otherwise, we just return the first available format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function is `chooseSwapPresentMode`, which takes in a vector of `VkPresentModeKHR`
    called `availablePresentModes`. Presentation modes specify how the final rendered
    picture is presented to the viewport. Here are the available modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_PRESENT_MODE_IMMEDIATE_KHR`: In this case, the picture will be displayed
    as soon as a picture is available to present. Pictures are not queued to be displayed.
    This causes picture tearing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PRESENT_MODE_FIFO_KHR`: The acquired pictures to be presented are put in
    a queue. The size of the queue is one minus the swap chain size. At vsync, the
    first picture to be displayed gets displayed in the **First In First Out (FIFO)**
    manner. There is no tearing as pictures are displayed in the same order in which
    they were added to the queue and vsync is enabled. This mode needs to always be
    supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PRESENT_MODE_FIFO_RELAXED_KHR`: This is a variation of the `FIFO` mode.
    In this mode, if the rendering is faster than the refresh rate of the monitor,
    it is fine, but if the drawing is slower than the monitor, there will be screen
    tearing as the next available picture is presented immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PRESENTATION_MODE_MAILBOX_KHR`: The presentation of the pictures is put
    in a queue, but it has just one element in it, unlike `FIFO`, which has more than
    one element in the queue. The next picture to be displayed will wait for the queue
    to be displayed and then the presentation engine will display the picture. This
    doesn''t cause tearing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this information, let''s create the `chooseSwapPresentMode` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since the `FIFO` mode is our most preferred mode, we set it in the function
    so that we can compare it with the available modes of the device. If it is not
    available, we go for the next best mode, which is the `MAILBOX` mode, so that
    the presentation queue will have at least one more picture to avoid screen tearing.
    If neither mode is available, we go for the `IMMEDIATE` mode, which is least desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third function is the `chooseSwapExtent` function. In this function, we
    get the resolution of the window that we drew to set the resolution of the swapchain
    pictures. It is added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The resolution of this window should match the swapchain pictures. Some window
    managers allow the resolution to be different between the pictures and the window.
    This is indicated by setting the value to the maximum of `uint32_t`. If not, then
    in that case, we return the current extent that we retrieved by the capabilities
    of the hardware, or pick the resolution that best matches the resolution between
    the maximum and minimum values available, as compared to the actual resolution
    we set, which is 1,280 x 720.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the `create` function, in which we actually create the `SwapChain`
    itself. To create this function, we will add the functionality to create the `SwapChain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do is get the device support details, which we retrieved
    for our device when we created the `Device` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, using the `helper` function we created, we get the surface format, present
    mode, and the extent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set the minimum number of pictures required to make the swapchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also make sure that we don''t exceed the maximum available picture
    count, so if the `imageCount` is more than the maximum amount, we set `imageCount`
    to the maximum count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the swapchain, we have to populate the `VkSwapchainCreateInfoKHR`
    struct first, so let''s create it. Create a variable called `createInfo` and specify
    the type of the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this, we have to specify the surface to use, the minimum picture count,
    the picture format, the space, and the extent. We also need to specify the picture array
    layers. Since we are not going to create a stereoscopic application like a virtual
    reality game, in which there would be two surfaces, one for the left eye and one
    for the right eye, instead, we just set the value for it as `1`. We also need
    to specify what the picture will be used for. Here, it will be used to show the
    color information using the color attachment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We now specify the graphics, presentation indices, and the count. We also specify
    the sharing mode. It is possible for the presentation and graphics family to be
    either the same or different.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the presentation and graphics family is different, the sharing mode is said
    to be of the `VK_SHARING_MODE_CONCURRENT` type. This means that the picture can
    be used across multiple queue families. However, if the picture is in the same
    queue family, the sharing mode is said to be of the `VK_SHARING_MODE_EXCLUSIVE` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we want, we can apply a pre-transform to the picture to either flip it or
    mirror it. In this case, we just keep the current transform. We can also alpha-blend
    the picture with other window systems, but we just keep it opaque and ignore the
    alpha channel, set the present mode, and set whether the pixel should be clipped
    if there is a window in front. We can also specify an old `SwapChain` if the current
    one becomes invalid when we resize the window. Since we don't resize the window,
    we don't have to specify an older swapchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the info struct, we can create the swapchain itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We create the swapchain using the `vkCreateSwapchainKHR` function, which takes
    the logical device, the `createInfo` struct, an allocator callback, and the swapchain
    itself. If it doesn't create the `SwapChain` because of an error, we will send
    out an error. Now that the swapchain is created, we will obtain the swapchain
    pictures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending upon the picture count, we call the `vkGetSwapchainImagesKHR` function,
    which we use to first get the picture count and then call the function again to
    populate the `vkImage` vector with the pictures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of pictures is a bit more involved, but Vulkan automatically creates
    color pictures. We can set the picture format and extent as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the `destroy` function, which destroys the `SwapChain` by calling
    the `vkDestroySwapchainKHR` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `VulkanApplication.h` file, include the `SwapChain` header and create
    a new `SwapChain` instance in the `VulkanApplication` class. In `VulkanApplication.cpp`,
    in the `initVulkan` function, after creating the logical device, create the `SwapChain`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application to make sure the `SwapChain` is created without
    any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Renderpass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the `SwapChain`, we move on to the Renderpass. Here, we specify
    how many color attachments and depth attachments are present and how many samples
    to use for each of them for each framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the start of this chapter, a framebuffer is a collection of
    target attachments. Attachments can be of type color, depth, and so on. The color
    attachment stores the color information that is presented to the viewport. There
    are other attachments that the end user doesn't see, but that are used internally.
    This includes depth, for example, which has all the depth information per pixel.
    In the render pass, apart from the type of attachments, we also specify how the
    attachments are used.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will be presenting what is rendered in a scene to the viewport,
    so we will just use a single pass. If we add a post-processing effect, we will
    take the rendered picture and apply this effect to it, for which we will need
    to use multiple passes. We will create a new class called `Renderpass`, in which
    we will create the render pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Renderpass.h` file, add the following includes and class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the class, add the constructor, destructor, and the `VkRenderPass` and `renderPass`
    variables. Add a new function called `createRenderPass` to create the `Renderpass`
    itself, which takes in the picture format. Also, add a function to destroy the
    `Renderpass` object after use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Renderpass.cpp` file, add the following includes, as well as the constructor
    and destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We now add the `createRenderPass` function, in which we will add the functionality
    to create the Renderpass for the current scene to be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we create the render pass, we have to specify the number and the type of
    attachments that we are using. So, for our project, we want only color attachments
    as we will only be drawing color information. We could also have a depth attachment,
    which stores depth information. We need to provide subpasses, and if so, then
    how many, as we could be using subpasses for adding post-processing effects to
    the current frame.
  prefs: []
  type: TYPE_NORMAL
- en: For the attachments and subpasses, we have to populate structs to pass to them
    at the time of creating the render pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s populate the structs. First, we create the attachments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We create the struct and specify the format to be used, which is the same as
    the `swapChainImage` format. We have to provide the sample count as 1 as we are
    not going to be using multi-sampling. In `loadOp` and `storeOp`, we specify what
    to do with the data before and after rendering. We specify that at the time of
    loading the attachment, we will clear the data to a constant at the start. After
    the render process, we store the data so we can read from it later. We then decide
    what to do with the data before and after the stencil operation.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not using the stencil buffer, we specify DON'T CARE during loading
    and storing. We also have to specify the data layout before and after processing
    the picture. The previous layout of the picture doesn't matter, but after rendering,
    the picture needs to be changed to the layout in order for it to be ready for
    presenting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll go through the subpass. Each subpass references the attachments
    that need to be specified as a separate structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `subpass` reference, we specify the attachment index, which is the 0^(th)
    index and specify the layout, which is a color attachment with optimal performance.
    Next, we create the `subpass` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the pipeline bind point, we specify that this is a graphics subpass, as
    it could have been a compute subpass. Specify the attachment count as `1` and
    provide the color attachment. Now, we can create the renderpass info struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an array of one element of the `VkAttachmentDescription` type, and
    then we create the info struct and pass in the type. The attachment count and
    the attachments are passed in, and then the subpass count and the subpass is passed
    in as well. Create the renderpass itself by calling `vkCreateRenderPass` and passing
    in the logical device, the create info, and the allocator callback to get the
    renderpass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `destroy` function, we call `vkDestroyRenderPass` to destroy
    it after we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In `VulkanApplication.h`, include `RenderPass.h` and create a render pass object.
    In `VulkanApplication.cpp`, after creating the swapchain, create the renderpass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, build and run the project to make sure there are no errors.
  prefs: []
  type: TYPE_NORMAL
- en: Using render targets and framebuffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use a picture, we have to create an `ImageView`. The picture doesn't have
    any information, such as mipmap levels, and you can't access a portion of the
    picture. However, by now using picture views, we specify the type of the texture
    and whether it has mipmaps. In addition, in renderpass, we specified the attachments
    per frame buffer. We will create framebuffers here and pass in the picture views
    as attachments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `RenderTexture`. In the `RenderTexture.h` file, add
    the following headers and then create the class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the class, we add the constructor and destructor as usual. We will store
    `swapChainImages` and the extent to use it locally. We create two vectors to store
    the created ImageViews and framebuffers. To create the views and framebuffers,
    we will call the `createViewsAndFramebuffers` function, which takes the pictures,
    picture format, extent, and the renderpass as the input. This function intern
    will call `createImageViews` and `CreateFramebuffer` to create the views and buffers.
    We will add the `destroy` function, which destroys and releases the resources
    back to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `RenderTexture.cpp` file, we will add the following includes as well
    as the constructor and destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `createViewAndFramebuffer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We first assign the images and `imageExtent` to the local variables. Then,
    we call the `imageViews` function, followed by `createFramebuffer`, in order to
    create both of them. To create the image views, use the `createImageViews` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify the vector size depending upon the swapchain image count first.
    For each of the image counts, we create image views using the `createImageView`
    function in the `vkTool` namespace. The `createImageView` function takes in the
    image itself, the image format, and `ImageAspectFlag`. This will be `VK_IMAGE_ASPECT_COLOR_BIT`
    or `VK_IMAGE_ASPECT_DEPTH_BIT` depending on the kind of view that you want to
    create for the image. The `createImageView` function is created in the `Tools.h`
    file under the `vkTools` namespace. The `Tools.h` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the function is created in the `Tools.cpp` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To create the `imageView`, we have to populate the `VkImageViewCreateInfo` struct
    and then use the `vkCreateImageView` function to create the view itself. To populate
    the view info, we specify the structure type, the picture itself, the view type,
    which is `VK_IMAGE_VIEW_TYPE_2D`, and a 2D texture, and then specify the format.
    We pass in the aspectFlags for the aspect mask. We create the image view without
    any mipmap level or layers, so we set them to `0`. We would only need multiple
    layers if we were making something like a VR game.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an `imageView` of the `VkImage` type and create it using the
    `vkCreateImageView` function, which takes in the logical device, the view info
    struct, and then the picture view is created and returned. That's all for the
    Tools file.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Tools file and add more functions to it when we want functions
    that can be reused. Now, let's go back to the `RenderTexture.cpp` file and add
    in the function to create the framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create framebuffers for each frame in the swapchain. `createFramebuffer`
    requires the picture extent and the renderpass itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For each frame that we create, the Framebuffer first populates the `framebufferInfo`
    struct and then calls `vkCreateFramebuffer` to create the Framebuffer itself.
    For each frame, we create a new info struct and specify the type of struct. We
    then pass the renderpass, the attachment count, and the attachment views, specify
    the width and height of the Framebuffer, and set the layers to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create the framebuffer by calling the `vkCreateFramebuffer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the `destroy` function, we destroy each of the picture views and framebuffers
    we created by calling `vkDestroyImageView` and `vkDestroyFramebuffer`. And that
    is all for the `RenderTexture` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `VulkanApplication.h`, include `RenderTexture.h` and create an instance
    of it called `renderTexture` in the `VulkanApplication` class. In the `VulkanApplication.cpp`
    file, include the `initVulkan` function and create a new `RenderTexture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Creating CommandBuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, the drawing and other operations done on the GPU are performed using
    command buffers. The command buffers contain the draw commands, which are recorded
    and then executed. Draw commands are to be recorded and executed in every frame.
    To create a command buffer, we have to first create a command pool and then allocate
    command buffers from the command pool, and then the commands are recorded per
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new class for creating the command buffer pool and then allocate
    the command buffers. We also create a function to start and stop recording and
    to destroy the command buffers. Create a new class, called `DrawCommandBuffer`,
    and `DrawCommandBuffer.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the class, we create the constructor and destructor. We create variables
    to store the command pool and a vector to store `VkCommandBuffer`. We create one
    function initially to create the command pool and allocate the command buffers.
    The next two functions, `beginCommandBuffer` and `endCommandBuffer`, will be called
    when we want to start and stop recording the command buffer. The `createCommandPool`
    and `allocateCommandBuffers` functions will be called by `createCommandPoolAndBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the `destroy` function to destroy the command buffers when we
    want the resources to be released to the system. In `CommandBuffer.cpp`, add the
    necessary includes and the constructor and destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add `createCommandPoolAndBuffer`, which takes in the picture count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createCommandPoolAndBuffer` function will call the `createCommandPool`
    and `allocateCommandBuffers` functions. First, we create the `createCommandPool`
    function. Commands have to be sent to a certain queue. We have to specify the
    queue when we create the command pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To start, we get the queue family indices for the current device. To create
    the command pool, we have to populate the `VkCommandPoolCreateInfo` struct. As
    usual, we specify the type. Then, we set the queue family index in which the pool
    has to be created. After that, we set the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    flags, which will reset the values of the command buffer every time. We then use
    the `vkCreateCommandPool` function by passing in the logical device and the info
    struct to get the command pool. Next, we create the `allocateCommandBuffers` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We resize the `commandBuffers` vector. Then, to allocate the command buffers,
    we have to populate `VkCommandBufferAllocateInfo`. We first set the type of the
    struct and the command pool. Then, we have to specify the level of the command
    buffers. You can have a chain of command buffers, with the primary command buffer
    containing the secondary command buffer. For our use, we will set the command
    buffers as primary. We then set `commandBufferCount`, which is equal to the swapchain
    pictures.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we allocate the command buffers using the `vkAllocateCommandBuffers` function.
    We pass in the logical device, the info struct, and the command buffers to allocate
    memory for the command buffers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add `beginCommandBuffer`. This takes in the current command buffer
    to start recording commands in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To record command buffers, we also have to populate `VkCommandBufferBeginInfoStruct`.
    Once again, we specify the struct type and the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`
    flag. This enables us to schedule the command buffer for the next frame while
    the last frame is still in use. `vkBeginCommandBuffer` is called to start recording
    the commands by passing in the current command buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add in the `endCommandBuffer` function. This function just calls `vkEndCommandBuffer`
    to stop recording to the command buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then destroy the command buffers and the pool using the `Destroy` function.
    Here, we just destroy the pool, which will destroy the command buffers as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `VulkanApplication.h` file, include `DrawCommandBuffer.h` and create
    an object of this class. In `VulkanApplication.cpp`, in the `VulkanInit` function,
    after creating `renderViewsAndFrameBuffers`, create `DrawCommandBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Beginning and ending Renderpass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along with the commands being recorded in each frame, the renderpass is also
    processed for each frame where the color and the depth information is reset. So,
    since we only have color attachments in each frame, we have to clear the color
    information for each frame as well. Go back to the `Renderpass.h` file and add
    two new functions, called `beginRenderPass` and `endRenderPass`, in the class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In `RenderPass.cpp`, add the implementation of the `beginRenderPass` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We then populate the `VkRenderPassBeginInfo` struct. In this, we specify the
    struct type, pass in the renderpass and the current framebuffer, set the render
    area as the whole viewport, and pass in the clear value and the count. The clear
    value is the color value we want to clear the screen with, and the count would
    be `1`, as we would like to clear only the color attachment.
  prefs: []
  type: TYPE_NORMAL
- en: To begin the renderpass, we pass in the current command buffer, the info struct,
    and specify the third parameter as `VK_SUBPASS_CONTENTS_INLINE`, specifying that
    the renderpass commands are bound to the primary command buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `endCommandBuffer` function, we finish the `Renderpass` for the current
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To end the `Renderpass`, the `vkCmdEndRenderPass` function is called and the
    current command buffer is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: We have the required classes to get the clear screen going. Now, let's go to
    the Vulkan Application class and add some lines of code to get it working.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the clear screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `VulkanApplication.h` file, we will add three new functions, called `drawBegin`,
    `drawEnd`, and `cleanup`. `drawBegin` will be called before we pass in any draw
    commands, and `drawEnd` will be called once the drawing is done and the frame
    is ready to be presented to the viewport. In the `cleanup` function, we will destroy
    all the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also create two variables. The first is `uint32_t`, to get the current
    picture from the swapchain, and the second is `currentCommandBuffer` of the `VkCommandBuffer`
    type to get the current command buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `VulkanApplication.cpp` file, we add the implementation of the `drawBegin`
    and `drawEnd` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First, we acquire the next picture from the swap chain. This is done using the
    Vulkan `vkAcquireNextImageKHR` API call. To do this, we pass in the logical device,
    the swapchain instance. Next, we need to pass in the timeout, for which we pass
    in the maximum numerical value as we don't care about the time limit. The next
    two variables are kept as null. These require a semaphore and a fence, which we
    will discuss in a later chapter. Finally, we pass in the `imageIndex` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get the current command buffer from the command buffers vector. We
    begin recording the command buffer by calling `beginCommandBuffer` and the commands
    will be stored in the `currentCommandBuffer` object. We now start the renderpass.
    In this, we pass the clear color value, which is the color purple, because *why
    not?* ! Pass in the current `commandbuffer`, the frame buffer, and the picture extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now implement the `drawEnd` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We end the renderpass and stop recording to the command buffer. Then, we have
    to submit the command buffer and present the frame. To submit the command buffer,
    we create a `VkSubmitInfo` struct and populate it with the struct type, the buffer
    count, which is 1 per frame, and the command buffer itself. The command is submitted
    to the graphics queue by calling `vkQueueSubmit` and passing in the graphics queue,
    the submission count, and the submit info.
  prefs: []
  type: TYPE_NORMAL
- en: Once the frame is rendered, it is presented to the viewport using the present
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: To present the scene once it is drawn, we have to create and populate the `VkPresentInfoKHR`
    struct. For presentation, the picture is sent back to the swapchain. When we create
    the info and set the type of the struct, we also have to set the swapchain, the
    image index, and the swapchain count, which is 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then present the picture using `vkQueuePresentKHR` by passing in the present
    queue and the present info to the function. At the end, we wait for the host to
    finish the presentation operation of a given queue using the `vkQueueWaitIdle` function,
    which takes in the present queue. Also, it is better to clean up the resources
    when you are done with them, so add the `cleanup` function as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When we are destroying the objects, we have to call `vkDeviceWaitIdle` to stop
    using the device. Then, we destroy the objects in reverse order. So, we destroy
    the command buffer first, then the render texture resources, then renderpass,
    and then the swapchain. We then destroy the device, validation layer, surface,
    and finally, the Vulkan instance. Finally, we also delete the class instances
    we created for `DrawCommandBuffer`, `RenderTarget`, `Renderpass`, `Swapchain`,
    `Device`, `ValidationLayersAndExtensions`, and `VulkanInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we also delete the instance of `VulkanContext` as well and set
    it to `nullptr` after deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `source.cpp` file, in the `while` loop, call the `drawBegin` and `drawEnd`
    functions. Then call the `cleanup` function after the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a purple viewport, as follows, when you build and run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6152ccd-b527-4376-b15f-b536ea987712.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screen looks OK, but if you look at the console, you will see the following
    error, which says that when we call `vkAcquireNextImageKHR`, the semaphore and
    fence cannot both be `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e720f47c-eff8-4fde-9e32-8689885d1073.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the creation of the swapchain, renderpass, render
    views, framebuffers, and the command buffers. We also looked at what each does
    and why they are important for rendering a clear screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create the resources that will enable us to render
    geometry to the viewport. Once we have the object resources ready, we will render
    the objects. We will then explore semaphores and fences and why they are needed.
  prefs: []
  type: TYPE_NORMAL
