<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-158"><a id="_idTextAnchor163"/>11</h1>
<h1 id="_idParaDest-159"><a id="_idTextAnchor164"/>Deferred Reclamation</h1>
<p>In <a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a>, we showed some examples of unusual memory allocation mechanisms and how they can be used, including how to react to errors to give our programs a form of “second chance” to continue, as well as how to use atypical or exotic memory through the mediation of the C++ language facilities. Then, in <a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>, we examined arena-based allocation and some variants thereof with an eye on issues of speed, determinism, and control over resource consumption.</p>
<p>What we will do in the current chapter is something that is not often done in C++ but that is common practice in programs written in many other languages, particularly those with integrated garbage collectors: we will write mechanisms that delay the destruction of dynamically allocated objects at selected moments in the execution of a program.</p>
<p>We will <em class="italic">not</em> write a proper garbage collector, as that would involve deeper involvement in the inner workings of the compiler and impact the programming model that makes C++ such a wonderful tool. However, we will put together mechanisms for <strong class="bold">deferred reclamation</strong>, in<a id="_idIndexMarker597"/> the sense that selected objects will deliberately be destroyed and see their underlying storage freed together at chosen moments, but without necessarily guaranteeing a destruction order. We will, of course, not provide an exhaustive overview of techniques to achieve this objective, but we will hopefully give you, dear reader, enough “food for thought” to build your own deferred reclamation mechanisms should you need to.</p>
<p>The techniques in this chapter can be coupled with those seen in <a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a> to make programs faster and reduce memory fragmentation, but we will cover deferred reclamation as a standalone topic to make our discourse clearer. After reading this chapter, you will be able to do the following:</p>
<ul>
<li>Understand the trade-offs associated with deferred reclamation, as there are gains to be made but there are also costs involved (this is not a panacea!)</li>
<li>Implement an almost transparent external wrapper to track the memory that needs to be collected</li>
<li>Implement an almost transparent external wrapper to help finalize the objects that are subjected to deferred reclamation</li>
<li>Implement a counting pointer akin to the reference counter of a <code>std::shared_ptr</code> object in order to identify objects that can be reclaimed at the end of a chosen scope</li>
</ul>
<p>The first step we need to take is to try to understand some problem domains where deferred reclamation can be helpful, including its relation to the (different but not entirely dissimilar) problem of garbage collection.</p>
<p class="callout-heading">Finalization? Reclamation?</p>
<p class="callout">You will notice that, in this chapter, we will often use the word <em class="italic">finalization</em> instead of the word <em class="italic">destruction</em>, as we seek to emphasize the fact that the code executed at the end of an object’s lifetime (its destructor) is distinct from the code that frees its underlying storage. As a bonus, <strong class="bold">finalization</strong> is<a id="_idIndexMarker598"/> also more common in garbage-collected languages, and garbage collection is a cousin of the techniques discussed in the sections that follow. Consider finalization (without reclamation) as the equivalent of calling the destructor of an object (without deallocating the underlying storage).</p>
<p class="callout">As stated earlier in this chapter, we will <a id="_idIndexMarker599"/>name <strong class="bold">reclamation</strong> the act of freeing the memory for one or many objects at selected moments, for example, at the end of a scope or when reaching the end of a program’s execution. Again, this term is more common in garbage-collected languages than it is in C++, but the topic of this chapter is in some ways closer to what these languages do so, hopefully, using similar terms will help develop a common understanding of the ideas and techniques involved.</p>
<h1 id="_idParaDest-160">Technical requiremen<a id="_idTextAnchor165"/>ts</h1>
<p>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter11">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter11</a>.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor166"/>What do we mean by deferred reclamation?</h1>
<p>Why would one want to resort to <a id="_idIndexMarker600"/>deferred reclamation? That’s a valid question indeed, so thanks for asking!</p>
<p>The short answer is that it solves a real problem. Indeed, there are programs where it makes sense not to collect objects right after they stop being referred to by client code, or where it’s unclear whether they can be collected at all until we know for sure the code that could use them concludes. These programs are somewhat rare in C++ because of the way we reason about code in our language, but they are not rare when looking at the programming world in general.</p>
<p>For example, consider a function in which there are circular references between some of the locally allocated objects, or one where there is a tree that one can navigate from the root node to its leaf nodes, but in which the leaves of the tree also have a reference to its root node. Sometimes, we can determine how to destroy the set of objects: for example, in the case of a tree, we could decide to start at the root and go down the branches. In other situations, if we know that a group of objects will not escape a given function, we can also use the knowledge that, at the end of that function, they all can be reclaimed as a group.</p>
<p>If you are familiar with garbage-collected languages, you probably know that in most of them, the collector “reclaims the bytes,” freeing the underlying storage of the reclaimed objects (and sometimes compacting the memory as it proceeds), but does not finalize the objects. One reason for this is that it is difficult (in some cases, impossible) for an object in such a language to know which other objects still exist in the program since there is no order-of-finalization guarantee… and how could there be one if the garbage collector needs to deal with cycles of objects referring to each other? Not knowing which other objects still exist when an object reaches the end of its lifetime severely limits what finalization code can do.</p>
<p>The fact that reclamation does not mean finalization in many languages simplifies the task of collecting the objects: one can conceptually call <code>std::free()</code> or some equivalent function and free memory without worrying about the objects therein. In languages that do guarantee finalization before reclamation, one often finds a class hierarchy rooted in a single, common base class (often called <code>object</code> or <code>Object</code>), which makes it possible to call the equivalent of a <code>virtual</code> destructor on each object and polymorphically finalize it. Of course, what one can do when finalizing an object under such circumstances is limited since the order in which objects are finalized is usually unknown.</p>
<p>What is more common in contemporary garbage-collected languages is to make finalization the responsibility of client code and leave the collection to the language itself. Such languages often use a special interface (<code>IDisposable</code> in C# and <code>Closeable</code> in Java come to mind) that is implemented by classes for which finalization is important (typically, classes that manage external resources), and client code will explicitly put in place the required mechanisms for the ordered finalization of objects. This moves part of the responsibility over resource management from the object itself (as is customary in C++ with the RAII idiom described in <a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>) to the code that uses it, which is a reminder that garbage collectors tend to simplify memory management but, at the same time, tend to complicate the management of other resources.</p>
<p>Examples of such client code-driven resource management include a <code>try</code> block accompanied by a <code>finally</code> block, which serves as the locus of cleanup code applied regardless of whether the <code>try</code> block concluded normally or some <code>catch</code> block was entered. There are also simplified syntaxes that perform the same thing in a less burdensome manner for client code. For example, Java uses try-with blocks and implicitly calls <code>close()</code> on selected <code>Closeable</code> objects at <em class="italic">end of scope</em>, and C# uses <code>using</code> blocks likewise in order to implicitly call <code>Dispose()</code> on selected <code>IDisposable</code> objects.</p>
<p>C++ does not have <code>finally</code> blocks, nor does it use intrusive techniques such as special interfaces known to the language that receive special treatment or a common base class to all types. In C++, objects are usually made responsible for the management of their resources through the <a id="_idIndexMarker601"/>RAII idiom; this leads to a different mindset and different programming techniques when compared to other popular languages.</p>
<p>In this chapter, we will face a similar yet different situation to the one faced in garbage-collected languages: if we want to use deferred reclamation of objects, we cannot guarantee that during destruction, one of the reclaimed objects will be able to access other objects reclaimed in the same group, so one should not try to do this. On the other hand, the fact that we will choose to apply deferred reclamation to <em class="italic">selected</em> objects (instead of doing so for all objects) means that objects not part of this group and known to survive that group’s reclamation can still be accessed during the finalization of reclaimed objects. It’s a benefit of not having a one-size-fits-all solution, really: C++ is nothing if not versatile, as you probably knew even before starting to read this book.</p>
<p>Not having a common base class to all types means that we will have to either forego finalization (and this can work if we limit ourselves to allocating objects of trivially destructible types, something we could validate at compile time) or that we will have to find some other way to remember the types of the objects we allocated and call the appropriate destructor when the time comes. In this chapter, we will show how one can implement both approaches.</p>
<p>Contrary to popular belief, some garbage collectors have been implemented for C++. One of the best-known ones (the Boehm-Demers-Weiser collector made by Hans Boehm, Alan Demers, and Mark Weiser) does not finalize objects in general but allows the registration of chosen finalizers from user code. This is done through a facility named <code>GC_register_finalizer</code>, but the authors warn users of this facility that what such a finalizer can do is limited, as is the case in garbage-collected languages (and discussed earlier in this section).</p>
<p class="callout-heading">Further reading</p>
<p class="callout">To explore further, please check <a href="https://www.hboehm.info/gc/">https://www.hboehm.info/gc/</a>.</p>
<p>We will use other<a id="_idIndexMarker602"/> techniques in this chapter. As is always the case in this book, the intent is to present ideas from which you can experiment and build the kind of solution your code needs. We will show three different examples:</p>
<ul>
<li>Code that reclaims selected objects at the end of program execution but does not finalize them, limiting deferred reclamation to trivially destructible objects</li>
<li>Code that reclaims and finalizes selected objects at the end of program execution</li>
<li>Code that reclaims and finalizes selected objects at the end of selected scopes</li>
</ul>
<p>We will proceed differently in each case, to give you a broader perspective on what can be done. In all three cases, we will store the pointers in a globally accessible object. Yes, a singleton, but that’s the correct tool here as we are discussing a feature that impacts the whole program. Ready? Here we go!</p>
<p class="callout-heading">Things we sometimes do to make examples readable…</p>
<p class="callout">The code in the following sections can seem strange to some readers. In an effort to focus on the deferred reclamation aspects of the code and keep the overall presentation readable, I chose not to<a id="_idIndexMarker603"/> go into aspects of thread safety, although this is essential in contemporary code. In the GitHub repository for this chapter, however, you will find both the code presented in this book and the thread-safe equivalent for each example.</p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor167"/>Reclamation (without finalization) at the end of the program</h1>
<p>Our first implementation <a id="_idIndexMarker604"/>will provide reclamation but not finalization at the end of program execution. For this reason, it will not accept managing objects of some type <code>T</code> if <code>T</code> is not trivially destructible since objects of that type have a destructor that might have to be executed to avoid leaks or other problems along the way.</p>
<p>With this example, as with the others in this chapter, we will start with our test code, and then go on to see how the reclamation mechanics are implemented. Our test code will go as follows:</p>
<ul>
<li>We will declare two types, <code>NamedThing</code> and <code>Identifier</code>. The former will not be trivially destructible as its destructor will contain user code that prints out debugging information, but the latter will be, as it will only contain trivially destructible non-static data members and offer no user-provided destructor.</li>
<li>We will provide two <code>g()</code> functions. The first one will be commented out as it tries to allocate <code>NamedThing</code> objects through our reclamation system, something that would not compile as type <code>NamedThing</code> does not meet our requirement of trivial destructibility. The second one will be used as the objects it allocates are of a type that meets those requirements.</li>
<li>The <code>f()</code>, <code>g()</code>, and <code>main()</code> functions will construct objects at various levels in the call stack of our program. However, the reclaimable objects will only be at the end of program execution.</li>
</ul>
<p>The client<a id="_idIndexMarker605"/> code in this case would be as follows:</p>
<pre class="source-code">
// ...
<strong class="bold">// note: not trivially destructible</strong>
struct NamedThing {
   const char *name;
   NamedThing(const char *name) : name{ name } {
      std::print("{} ctor\n", name);
   }
   ~NamedThing() {
      std::print("{} dtor\n", name);
   }
};
struct Identifier {
   int value;
};
<strong class="bold">// would not compile</strong>
<strong class="bold">/*</strong>
<strong class="bold">void g() {</strong>
<strong class="bold">   [[maybe_unused]] auto p = gcnew&lt;NamedThing&gt;("hi");</strong>
<strong class="bold">   [[maybe_unused]] auto q = gcnew&lt;NamedThing&gt;("there");</strong>
<strong class="bold">}</strong>
<strong class="bold">*/</strong>
void g() {
<strong class="bold">   [[maybe_unused]] auto p = gcnew&lt;Identifier&gt;(2);</strong>
<strong class="bold">   [[maybe_unused]] auto q = gcnew&lt;Identifier&gt;(3);</strong>
}
auto h() {
<strong class="bold">   struct X {</strong>
<strong class="bold">      int m() const { return 123; }</strong>
<strong class="bold">   };</strong>
<strong class="bold">   return gcnew&lt;X&gt;();</strong>
}
<strong class="bold">auto f() {</strong>
<strong class="bold">   g();</strong>
<strong class="bold">   return h();</strong>
<strong class="bold">}</strong>
int main() {
   std::print("Pre\n");
   std::print("{}\n", <strong class="bold">f()-&gt;m()</strong>);
   std::print("Post\n");
}</pre> <p>With this code and the (so far missing) deferred reclamation code, this program will print the following:</p>
<pre class="console">
Pre
123
Post
~GC with 3 objects to deallocate</pre> <p>Note that <code>f()</code> allocates<a id="_idIndexMarker606"/> and returns an object from which <code>main()</code> calls the <code>m()</code> member function without explicitly resorting to a smart pointer, yet this program does not leak memory. Objects allocated through the <code>gcnew&lt;T&gt;()</code> function are registered in the <code>GC</code> object, and the destructor of the <code>GC</code> object will ensure the registered memory blocks will be deallocated.</p>
<p>How does <code>gcnew&lt;T&gt;()</code> work, then, and why write such a function instead of simply overloading <code>operator new()</code>? Well, remember that <code>operator new()</code> intervenes in the overall allocation process as an allocation function – one that trades in raw memory, not one that knows what the type of object to create will be. In this example, we want (a) memory to be allocated for the new object, (b) the object to be constructed (hence the need for the type and the arguments that will be passed to the constructor), and (c) to reject types that are not trivially destructible. We need to know the type of object to construct, something <code>operator new()</code> is not aware of.</p>
<p>To be able to reclaim the memory for these objects at the end of program execution, we will need a form of globally available storage where we will put the pointers that have been allocated. We will call such pointers <code>roots</code> and store them in a singleton of the <code>GC</code> type (inspired by the nickname typically associated with garbage collectors, even though this is not exactly what we are implementing – that name will convey the intent well, and it’s short enough not to get in the way).</p>
<p>The <code>GC::add_root&lt;T&gt;(args...)</code> member function will ensure that <code>T</code> is a trivially destructible type, allocate a chunk of <code>sizeof(T)</code> bytes, construct <code>T(args...)</code> at that location, store an abstract pointer (a <code>void*</code>) to that object in <code>roots</code>, and return a <code>T*</code> object to the newly created object. The <code>gcnew&lt;T&gt;()</code> function will allow user code to interface with <code>GC::add_root&lt;T&gt;()</code> in a simplified manner; since we want user code to use <code>gcnew&lt;T&gt;()</code>, we will qualify <code>GC::add_root&lt;T&gt;()</code> as <code>private</code> and make <code>gcnew&lt;T&gt;()</code> a <code>friend</code> of the <code>GC</code> class.</p>
<p>Note that the <code>GC</code> class itself is not a generic class (it’s not a template). It exposes template member functions, but structurally only stores raw addresses (<code>void*</code> objects), which makes <a id="_idIndexMarker607"/>this class mostly type-agnostic. This all leads to the following code:</p>
<pre class="source-code">
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;print&gt;
#include &lt;type_traits&gt;
class GC {
<strong class="bold">   std::vector&lt;void*&gt; roots;</strong>
   GC() = default;
   static auto &amp;get() {
      static GC gc;
      return gc;
   }
<strong class="bold">   template &lt;class T, class ... Args&gt;</strong>
<strong class="bold">      T *add_root(Args &amp;&amp;... args) {</strong>
<strong class="bold">         // there will be no finalization</strong>
<strong class="bold">         static_assert(</strong>
<strong class="bold">            std::is_trivially_destructible_v&lt;T&gt;</strong>
<strong class="bold">         );</strong>
<strong class="bold">         return static_cast&lt;T*&gt;(</strong>
<strong class="bold">            roots.emplace_back(</strong>
<strong class="bold">               new T(std::forward&lt;Args&gt;(args)...)</strong>
<strong class="bold">            )</strong>
<strong class="bold">         );</strong>
<strong class="bold">      }</strong>
<strong class="bold">   // provide access privileges to gcnew&lt;T&gt;()</strong>
<strong class="bold">   template &lt;class T, class ... Args&gt;</strong>
<strong class="bold">      friend T* gcnew(Args&amp;&amp;...);</strong>
public:
<strong class="bold">   ~GC() {</strong>
<strong class="bold">      std::print("~GC with {} objects to deallocate",</strong>
<strong class="bold">                 std::size(roots));</strong>
<strong class="bold">      for(auto p : roots) std::free(p);</strong>
<strong class="bold">   }</strong>
   GC(const GC &amp;) = delete;
   GC&amp; operator=(const GC &amp;) = delete;
};
<strong class="bold">template &lt;class T, class ... Args&gt;</strong>
<strong class="bold">   T *gcnew(Args &amp;&amp;...args) {</strong>
<strong class="bold">      return GC::get().add_root&lt;T&gt;(</strong>
<strong class="bold">         std::forward&lt;Args&gt;(args)...</strong>
<strong class="bold">      );</strong>
<code>GC::~GC()</code> calls <code>std::free()</code> but invokes no destructor, as this implementation reclaims memory but does not finalize objects.</p>
<p>This example shows a way to group memory reclamation as a single block to be executed at the end of a program. In code where there is more available memory than what the program requires, this can lead to a more streamlined program execution, albeit at the cost of a slight slowdown at program termination (of course, if you want to try this, please measure to see whether there are actual benefits for your code base!). It can also help us write analysis tools that examine how memory has been allocated throughout program execution and can be enhanced to collate additional information such as memory block size and alignment: we simply would need to keep pairs – or tuples, depending on the needs – instead of single <code>void*</code> objects in the <code>roots</code> container to aggregate the desired data.</p>
<p>Of course, not<a id="_idIndexMarker608"/> being able to finalize objects allocated through this mechanism can be a severe limitation, as no non-trivially destructible type can benefit from our efforts. Let’s see how we could add finalization support to our design.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor168"/>Reclamation and finalization at the end of the program</h1>
<p>Our second implementation<a id="_idIndexMarker609"/> will not only free the underlying storage for the objects allocated through our deferred reclamation system but will also finalize them by calling their destructors. To do so, we will need to remember the type of each object that goes through our system. There are, of course, many ways to achieve this, and we will see one of them.</p>
<p>By ensuring the finalization of reclaimed objects, we can get rid of the trivially destructible requirement of our previous implementation. We still will not guarantee the order in which objects are finalized, so it’s important that reclaimed objects do not refer to each other during finalization if we are to have sound programs, but that’s a constraint many other popular programming languages also share. This implementation will, however, keep the singleton approach and finalize and then deallocate objects and their underlying storage at the end of program execution.</p>
<p>As in the previous section, we will first look at client code. In this case, we will be using (and benefitting from) non-trivially destructible objects and use them to print out information during finalization: this will simplify the task of tracing program execution. Of course, we will also use trivially destructible types (such as <code>struct X</code>, local to the <code>h()</code> function) as there is no reason not to support these too. Note that, often (but not always), non-trivially destructible types will be RAII types (see <a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>) whose objects need to free resources before their life ends, but we just want a simple example here so doing anything non-trivial such as printing out some value (which is what we are doing with <code>NamedThing</code>) will suffice in demonstrating that we handle non-trivially-destructible types correctly.</p>
<p>We will use nested function calls to highlight the local aspect of construction and allocation, as well <a id="_idIndexMarker610"/>as the non-local aspect of object destruction and deallocation since these will happen at program termination time. Our example code will be as follows:</p>
<pre class="source-code">
// ...
<strong class="bold">// note: not trivially destructible</strong>
struct NamedThing {
   const char *name;
   NamedThing(const char *name) : name{ name } {
      std::print("{} ctor\n", name);
   }
   ~NamedThing() {
      std::print("{} dtor\n", name);
   }
};
void g() {
<strong class="bold">   [[maybe_unused]] auto p = gcnew&lt;NamedThing&gt;("hi");</strong>
<strong class="bold">   [[maybe_unused]] auto q = gcnew&lt;NamedThing&gt;("there");</strong>
}
auto h() {
<strong class="bold">   struct X {</strong>
<strong class="bold">      int m() const { return 123; }</strong>
<strong class="bold">   };</strong>
<strong class="bold">   return gcnew&lt;X&gt;();</strong>
}
<strong class="bold">auto f() {</strong>
<strong class="bold">   g();</strong>
<strong class="bold">   return h();</strong>
<strong class="bold">}</strong>
int main() {
   std::print("Pre\n");
   std::print("{}\n", <strong class="bold">f()-&gt;m()</strong>);
   std::print("Post\n");
}</pre> <p>When executed, you <a id="_idIndexMarker611"/>should expect the following information to be printed on the screen:</p>
<pre class="console">
Pre
hi ctor
there ctor
123
Post
hi dtor
there dtor</pre> <p>As can be seen, the constructors happen when invoked in the source code, but the destructors are called at program termination (after the end of <code>main()</code>) as we had announced we would do.</p>
<p class="callout-heading">On the importance of interfaces</p>
<p class="callout">You might <a id="_idIndexMarker612"/>notice that user code essentially did not change between the non-object-finalizing implementation and this one. The beauty here is that our upgrade, or so to say, is completely achieved in the implementation, leaving the interface stable and, as such, the differences transparent to client code. Being able to change the implementation without impacting interfaces is a sign of low coupling and is a noble objective for one to seek to attain.</p>
<p>How did we get from a non-finalizing implementation to a finalizing one? Well, this implementation<a id="_idIndexMarker613"/> will also use a singleton named <code>GC</code> where “object roots” will be stored. In this case, however, we will store semantically enhanced objects, not just raw addresses (<code>void*</code> objects) as we did in the previous implementation.</p>
<p>We will achieve this objective through a set of old yet useful tricks:</p>
<ul>
<li>Our <code>GC</code> class will not be a generic class, as it would force us to write <code>GC&lt;T&gt;</code> instead of just <code>GC</code> in our code, and find a way to have a distinct <code>GC&lt;T&gt;</code> object for each <code>T</code> type. What we want is for a single <code>GC</code> object to store the required information for all objects that require deferred reclamation, regardless of type.</li>
<li>In <code>GC</code>, instead of storing objects of the <code>void*</code> type, we will store objects of the <code>GC::GcRoot*</code> type. These objects will not be generic either but will be polymorphic, exposing a <code>destroy()</code> service to destroy (call the destructor, then free the underlying storage) objects.</li>
<li>There will be classes that derive from <code>GC::GcRoot</code>. We will call such classes <code>GC::GcNode&lt;T&gt;</code> and there will be one for each type <code>T</code> in a program that is involved in our deferred reclamation mechanism. These are where the type-specific code will be “hidden.”</li>
<li>By keeping <code>GC::GcRoot*</code> objects as roots but storing <code>GC::GcNode&lt;T&gt;*</code> in practice, we will be able to deallocate and finalize the <code>T</code> object appropriately.</li>
</ul>
<p>The code for this implementation follows:</p>
<pre class="source-code">
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;print&gt;
class GC {
<strong class="bold">   class GcRoot {</strong>
<strong class="bold">      void *p;</strong>
<strong class="bold">   public:</strong>
<strong class="bold">      auto get() const noexcept { return p; }</strong>
<strong class="bold">      GcRoot(void *p) : p{ p } {</strong>
<strong class="bold">      }</strong>
<strong class="bold">      GcRoot(const GcRoot &amp;) = delete;</strong>
<strong class="bold">      GcRoot&amp; operator=(const GcRoot &amp;) = delete;</strong>
<strong class="bold">      virtual void destroy(void *) const noexcept = 0;</strong>
<strong class="bold">      virtual ~GcRoot() = default;</strong>
<strong class="bold">   };</strong>
   // ...</pre> <p>As can be<a id="_idIndexMarker614"/> seen, <code>GC::GcRoot</code> is an abstraction that trades in raw pointers (objects of the <code>void*</code> type) and contains no type-specific information, per se.</p>
<p>The type-specific information is held in derived classes of the <code>GcNode&lt;T&gt;</code> type:</p>
<pre class="source-code">
   // ...
<strong class="bold">   template &lt;class T&gt; class GcNode : public GcRoot {</strong>
<strong class="bold">      void destroy(void* q) const noexcept override {</strong>
<strong class="bold">         delete static_cast&lt;T*&gt;(q);</strong>
<strong class="bold">      }</strong>
<strong class="bold">   public:</strong>
<strong class="bold">      template &lt;class ... Args&gt;</strong>
<strong class="bold">         GcNode(Args &amp;&amp;... args) :</strong>
<strong class="bold">            GcRoot(new T(std::forward&lt;Args&gt;(args)...)) {</strong>
<strong class="bold">         }</strong>
<strong class="bold">      ~GcNode() {</strong>
<strong class="bold">         destroy(get());</strong>
<strong class="bold">      }</strong>
<strong class="bold">   };</strong>
   // ...</pre> <p>As we can see, a <code>GcNode&lt;T&gt;</code> object can be constructed with any sequence of arguments suitable for type <code>T</code>, perfectly forwarding them to the constructor of a <code>T</code> object. The actual (raw) pointers are stored in the base class part of the object (the <code>GcRoot</code> but the destructor of a <code>GcNode&lt;T&gt;</code> invokes <code>destroy()</code> on that raw pointer, which casts <a id="_idIndexMarker615"/>the <code>void*</code> to the appropriate <code>T*</code> type before invoking <code>operator delete()</code>.</p>
<p>Through the <code>GcRoot</code> abstraction, a <code>GC</code> object is kept apart from type-specific details of the objects it needs to reclaim at a later point. This implementation can be seen as a form of <strong class="bold">external polymorphism</strong>, where<a id="_idIndexMarker616"/> we use a polymorphic hierarchy “underneath the covers” to implement functionality in such a way as to keep client code unaware.</p>
<p>Given what we have written so far, our work is almost done:</p>
<ul>
<li>Lifetime management can be delegated to smart pointers, as the finalization code is found in the destructor of <code>GcNode&lt;T&gt;</code> objects. Here, we will be using <code>std::unique_ptr&lt;GcRoot&gt;</code> objects (simple and efficient).</li>
<li>The <code>add_root()</code> function will create <code>GcNode&lt;T&gt;</code> objects, store them in the <code>roots</code> container as pointers to their base class, <code>GcRoot</code>, and return the <code>T*</code> pointing to the newly constructed object. Thus, it installs lifetime management mechanisms while exposing pointers in ways that look natural to users of <code>operator new()</code>.</li>
</ul>
<p>That part of<a id="_idIndexMarker617"/> the code follows:</p>
<pre class="source-code">
   // ...
<strong class="bold">   std::vector&lt;std::unique_ptr&lt;GcRoot&gt;&gt; roots;</strong>
   GC() = default;
   static auto &amp;get() {
      static GC gc;
      return gc;
   }
<strong class="bold">   template &lt;class T, class ... Args&gt;</strong>
<strong class="bold">      T *add_root(Args &amp;&amp;... args) {</strong>
<strong class="bold">         return static_cast&lt;T*&gt;(roots.emplace_back(</strong>
<strong class="bold">            std::make_unique&lt;GcNode&lt;T&gt;&gt;(</strong>
<strong class="bold">               std::forward&lt;Args&gt;(args)...)</strong>
<strong class="bold">         )-&gt;get());</strong>
<strong class="bold">      }</strong>
   template &lt;class T, class ... Args&gt;
      friend T* gcnew(Args&amp;&amp;...);
public:
   GC(const GC &amp;) = delete;
   GC&amp; operator=(const GC &amp;) = delete;
};
template &lt;class T, class ... Args&gt;
   T *gcnew(Args &amp;&amp;...args) {
      return GC::get().add_root&lt;T&gt;(
         std::forward&lt;Args&gt;(args)...
      );
   }
// ...</pre> <p>So, there we have it: a way to create objects at selected points, and destroy and reclaim them all at program termination, with the corresponding upsides and downsides, of course. These tools are useful, but they are also niche tools that you should use (and customize to your needs) if there is indeed a need to do so.</p>
<p>So far, we have <a id="_idIndexMarker618"/>seen deferred reclamation facilities that terminate (and finalize, depending on the tool) at program termination. We still need a mechanism for reclamation at the end of selected scopes.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor169"/>Reclamation and finalization at the end of the scope</h1>
<p>Our third and last <a id="_idIndexMarker619"/>implementation for this chapter will ensure reclamation and finalization at the end of the scope, but only on demand. By this, we mean that if a user wants to reclaim unused objects that are subject to deferred reclamation at the end of a scope, it will be possible to do so. Objects subject to deferred reclamation that are still considered in use will not be reclaimed, and objects that are not in use will not be reclaimed if the user code does not ask for it. Of course, at program termination, all remaining objects that are subject to deferred reclamation will be claimed, as we want to avoid leaks.</p>
<p>This implementation will be more subtle than the previous ones, as we will need to consider (a) whether an object is still being referred to at a given point in program execution and (b) whether there is a need to collect objects that are not being referred to at that time.</p>
<p>To get to that point, we will inspire ourselves from <code>std::shared_ptr</code>, a type we provided an academic and simplified version of in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, and will write a <code>counting_ptr&lt;T&gt;</code> type that, instead of destroying the pointee when its last client disconnects, will mark it as ready to be reclaimed.</p>
<p>The client code for this example follows. Pay attention to the presence of objects of the <code>scoped_collect</code> type in some scopes. These represent requests made by client code to reclaim objects <a id="_idIndexMarker620"/>not in use anymore at the end of that scope:</p>
<pre class="source-code">
// ...
<strong class="bold">// note: not trivially destructible</strong>
struct NamedThing {
   const char *name;
   NamedThing(const char *name) : name{ name } {
      std::cout &lt;&lt; name &lt;&lt; " ctor" &lt;&lt; std::endl;
   }
   ~NamedThing() {
      std::cout &lt;&lt; name &lt;&lt; " dtor" &lt;&lt; std::endl;
   }
};
auto g() {
<strong class="bold">   auto _ = scoped_collect{};</strong>
   [[maybe_unused]] auto p = gcnew&lt;NamedThing&gt;("hi");
   auto q = gcnew&lt;NamedThing&gt;("there");
   return q;
} <strong class="bold">// a reclamation will occur here</strong>
auto h() {
   struct X {
      int m() const { return 123; }
   };
   return gcnew&lt;X&gt;();
}
auto f() {
<strong class="bold">   auto _ = scoped_collect{};</strong>
   auto p = g();
   std::cout &lt;&lt; '\"' &lt;&lt; p-&gt;name &lt;&lt; '\"' &lt;&lt; std::endl;
} <strong class="bold">// a reclamation will occur here</strong>
int main() {
   using namespace std;
   cout &lt;&lt; "Pre" &lt;&lt; endl;
   f();
   cout &lt;&lt; h()-&gt;m() &lt;&lt; endl;
   cout &lt;&lt; "Post" &lt;&lt; endl;
} <code>scoped_collect</code> object lives will lead to the reclamation of all objects allocated through <code>gcnew&lt;T&gt;()</code> that are not referenced anymore at that point; this holds regardless of whether they were allocated in that scope or somewhere else in the program. The<a id="_idIndexMarker621"/> intent here is that the end of such as scope is a point where we are willing to “pay” the time and effort required to collect a group of objects. Do not use a <code>scoped_collect</code> object in a scope where either speed or deterministic behavior is of the essence!</p>
<p>Executing this code, we end up with the following:</p>
<pre class="console">
Pre
hi ctor
there ctor
hi dtor
"there"
there dtor
123
Post</pre> <p>As we can see, objects that are still being referred to remain available, and objects that are not being referred to are collected either when the destructor of a <code>scoped_collect</code> object is called, or at program termination if there are still some reclaimable objects in the program at that point.</p>
<p>The <code>scoped_collect</code> type itself is very simple, its main role being to interact with the <code>GC</code> global object. It is simply a non-copiable, non-movable RAII object that invokes a reclamation at <a id="_idIndexMarker622"/>the end of its lifetime:</p>
<pre class="source-code">
// ...
struct scoped_collect {
   scoped_collect() = default;
   scoped_collect(const scoped_collect &amp;) = delete;
   scoped_collect(scoped_collect &amp;&amp;) = delete;
   scoped_collect&amp;
      operator=(const scoped_collect &amp;) = delete;
   scoped_collect &amp;operator=(scoped_collect &amp;&amp;) = delete;
<strong class="bold">   ~scoped_collect() {</strong>
<strong class="bold">      GC::get().collect();</strong>
<strong class="bold">   }</strong>
};
// ...</pre> <p>How does this whole infrastructure work? Let’s take it step by step. We will inspire ourselves from the previous sections of this chapter, where we initially collect all objects at the end of program execution, and then add finalization for these objects. The novelty in this section is that we will add the possibility of collecting objects at various times in program execution and implement the required code to track references to objects.</p>
<p>To track references to objects, we will use objects of the <code>counting_ptr&lt;T&gt;</code> type:</p>
<pre class="source-code">
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;functional&gt;
#include &lt;utility&gt;</pre> <p>As can be seen, we can (and do!) implement this type solely through standard tools. Note that the <code>count</code> data member<a id="_idIndexMarker623"/> is a pointer as it might be shared between instances of <code>counting_ptr&lt;T&gt;</code>:</p>
<pre class="source-code">
template &lt;class T&gt;
   class counting_ptr {
<strong class="bold">      using count_type = std::atomic&lt;int&gt;;</strong>
<strong class="bold">      T *p;</strong>
<strong class="bold">      count_type *count;</strong>
<strong class="bold">      std::function&lt;void()&gt; mark;</strong>
   public:
      template &lt;<strong class="bold">class M</strong>&gt;
         constexpr counting_ptr(T *p<strong class="bold">, M mark</strong>) try :
            p{ p }<strong class="bold">, mark{ mark }</strong> {
               count = new count_type{ 1 };
         } catch(...) {
            delete p;
            throw;
         }
      T&amp; operator*() noexcept {
         return *p;
      }
      const T&amp; operator*() const noexcept {
         return *p;
      }
      T* operator-&gt;() noexcept {
         return p;
      }
      const T* operator-&gt;() const noexcept {
         return p;
      }
      constexpr bool
         operator==(const counting_ptr &amp;other) const {
         return p == other.p;
      }
<strong class="bold">      // operator!= can be omitted since C++20</strong>
      constexpr bool
         operator!=(const counting_ptr &amp;other) const {
         return !(*this == other);
      }
<strong class="bold">      // we allow comparing counting_ptr&lt;T&gt; objects</strong>
<strong class="bold">      // to objects of type U* or counting_ptr&lt;U&gt; to</strong>
<strong class="bold">      // simplify the handling of types in a class</strong>
<strong class="bold">      // hierarchy</strong>
      template &lt;class U&gt;
         constexpr bool
           operator==(const counting_ptr&lt;U&gt; &amp;other) const {
            return p == &amp;*other;
         }
      template &lt;class U&gt;
         constexpr bool
           operator!=(const counting_ptr&lt;U&gt; &amp;other) const {
            return !(*this == other);
         }
      template &lt;class U&gt;
         constexpr bool operator==(const U *q) const {
            return p == q;
         }
      template &lt;class U&gt;
         constexpr bool operator!=(const U *q) const {
            return !(*this == q);
         }
       // ...</pre> <p>Now that the <a id="_idIndexMarker624"/>relational operators are in place, we can implement copy and move semantics for our type:</p>
<pre class="source-code">
      // ...
      void swap(counting_ptr &amp;other) {
         using std::swap;
         swap(p, other.p);
         swap(count, other.count);
         <strong class="bold">swap(mark, other.mark);</strong>
      }
      constexpr operator bool() const noexcept {
         return p != nullptr;
      }
      counting_ptr(counting_ptr &amp;&amp;other) noexcept
         : p{ std::exchange(other.p, nullptr) },
           count{ std::exchange(other.count, nullptr) },
           <strong class="bold">mark{ other.mark }</strong> {
      }
      counting_ptr &amp;
         operator=(counting_ptr &amp;&amp;other) noexcept {
         counting_ptr{ std::move(other) }.swap(*this);
         return *this;
      }
      counting_ptr(const counting_ptr &amp;other)
         : p{ other.p }, count{ other.count },
           mark{ other.mark } {
         if (count) ++(*count);
      }
      counting_ptr &amp;operator=(const counting_ptr &amp;other) {
         counting_ptr{ other }.swap(*this);
         return *this;
      }
      ~counting_ptr() {
         if (count) {
            if ((*count)-- == 1) {
<strong class="bold">               mark();</strong>
               delete count;
            }
         }
      }
   };
namespace std {
   template &lt;class T, class M&gt;
      void swap(counting_ptr&lt;T&gt; &amp;a, counting_ptr&lt;T&gt; &amp;b) {
         a.swap(b);
      }
}
// ...</pre> <p>Instead of destroying the counter and the pointee like a <code>shared_ptr&lt;T&gt;</code> would, <code>counting_ptr&lt;T&gt;</code> will delete the counter but “mark” the pointee, making it a candidate for ulterior reclamation.</p>
<p>The general <code>GC</code>, <code>GC::GcRoot</code>, and <code>GC::GcNode&lt;T&gt;</code> approach from the previous section remains, but is enhanced as follows:</p>
<ul>
<li>The <code>roots</code> container couples a <code>unique_ptr&lt;GcRoot&gt;</code> with a “mark” data member of type <code>bool</code></li>
<li>The <code>make_collectable(p)</code> member function marks the root associated with the <code>p</code> pointer as collectable</li>
<li>The <code>collect()</code> member functions reclaim all the roots that are marked as collectable</li>
</ul>
<p>What this <a id="_idIndexMarker625"/>implementation does is (a) associate a Boolean mark (collect or do not collect) with each reclaimable pointer, (b) use <code>counting_ptr&lt;T&gt;</code> object with each <code>T*</code> to keep track of how each pointee is being used, and (c) collect reclaimable pointees as a group whenever a collection request arrives. The easiest way to request such a collection is to reach the destructor of a <code>scoped_collect</code> object.</p>
<p>The code for this<a id="_idIndexMarker626"/> somewhat more sophisticated version is as follows:</p>
<pre class="source-code">
// ...
class GC {
   class GcRoot {
      void *p;
   public:
      auto get() const noexcept { return p; }
      GcRoot(void *p) : p{ p } {
      }
      GcRoot(const GcRoot&amp;) = delete;
      GcRoot&amp; operator=(const GcRoot&amp;) = delete;
      virtual void destroy(void*) const noexcept = 0;
      virtual ~GcRoot() = default;
   };
   template &lt;class T&gt; class GcNode : public GcRoot {
      void destroy(void *q) const noexcept override {
         delete static_cast&lt;T*&gt;(q);
      }
   public:
      template &lt;class ... Args&gt;
         GcNode(Args &amp;&amp;... args)
            : GcRoot(new T(std::forward&lt;Args&gt;(args)...)) {
         }
      ~GcNode() {
         destroy(get());
      }
   };
<strong class="bold">   std::vector&lt;</strong>
<strong class="bold">      std::pair&lt;std::unique_ptr&lt;GcRoot&gt;, bool&gt;</strong>
<strong class="bold">   &gt; roots;</strong>
   GC() = default;
   static auto &amp;get() {
      static GC gc;
      return gc;
   }</pre> <p>The collection<a id="_idIndexMarker627"/> functions in this case would be as follows:</p>
<pre class="source-code">
<strong class="bold">   void make_collectable(void *p) {</strong>
<strong class="bold">      for (auto &amp;[q, coll] : roots)</strong>
<strong class="bold">         if (static_cast&lt;GcRoot*&gt;(p) == q.get())</strong>
<strong class="bold">            coll = true;</strong>
<strong class="bold">   }</strong>
<strong class="bold">   void collect() {</strong>
<strong class="bold">      for (auto p = std::begin(roots);</strong>
<strong class="bold">           p != std::end(roots); ) {</strong>
<strong class="bold">         if (auto &amp;[ptr, collectible] = *p; collectible) {</strong>
<strong class="bold">            ptr = nullptr;</strong>
<strong class="bold">            p = roots.erase(p);</strong>
<strong class="bold">         } else {</strong>
<strong class="bold">            ++p;</strong>
<strong class="bold">         }</strong>
<strong class="bold">      }</strong>
<strong class="bold">   }</strong>
   template &lt;class T, class ... Args&gt;
      auto add_root(Args &amp;&amp;... args) {
         auto q = static_cast&lt;T*&gt;(roots.emplace_back(
            std::make_unique&lt;GcNode&lt;T&gt;&gt;(
               std::forward&lt;Args&gt;(args)...
            )<strong class="bold">, false</strong>
         ).first-&gt;get());
<strong class="bold">         // the marking function is implemented as</strong>
<strong class="bold">         // a lambda expression that iterates through</strong>
<strong class="bold">         // the roots, then finds and marks for</strong>
<strong class="bold">         // reclamation pointer q. It is overly</strong>
<strong class="bold">         // simplified (linear search) and you are</strong>
<strong class="bold">         // welcome to do something better!</strong>
<strong class="bold">         return counting_ptr{</strong>
<strong class="bold">            q, [&amp;,q]() {</strong>
<strong class="bold">               for (auto &amp;[p, coll] : roots)</strong>
<strong class="bold">                  if (static_cast&lt;void*&gt;(q) ==</strong>
<strong class="bold">                      p.get()-&gt;get()) {</strong>
<strong class="bold">                     coll = true;</strong>
<strong class="bold">                     return;</strong>
<strong class="bold">                  }</strong>
<strong class="bold">            }</strong>
<strong class="bold">         };</strong>
      }
<strong class="bold">   template &lt;class T, class ... Args&gt;</strong>
<strong class="bold">      friend counting_ptr&lt;T&gt; gcnew(Args&amp;&amp;...);</strong>
<strong class="bold">   friend struct scoped_collect;</strong>
public:
   GC(const GC &amp;) = delete;
   GC&amp; operator=(const GC &amp;) = delete;
};
// ...
template &lt;class T, class ... Args&gt;
   counting_ptr&lt;T&gt; gcnew(Args &amp;&amp;... args) {
      return GC::get().add_root&lt;T&gt;(
         std::forward&lt;Args&gt;(args)...
      );
   }
// ...</pre> <p>As you can see, dear reader, this last example would benefit from several optimizations, but it works and is meant to be simple enough to understand and improve.</p>
<p>We now<a id="_idIndexMarker628"/> know it is possible to reclaim objects in groups in C++, as it is in other popular languages. It might not be idiomatic C++ code, but deferred reclamation can be achieved with reasonable effort, on an opt-in basis. Not bad!</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor170"/>Summary</h1>
<p>This chapter took us in the territory of deferred reclamation, a territory that’s unfamiliar to many C++ programmers. We saw ways in which we can reclaim objects in groups at specific points in a program, discussed restrictions on what could be done when reclaiming such objects, and examined various techniques to finalize objects before freeing their associated memory storage.</p>
<p>We are now ready to look at how memory management interacts with C++ containers, an important topic that will occupy us in the next three chapters.</p>
<p>Indeed, we could write containers that handle memory explicitly, but in general, that would be counterproductive (for example, if we tied <code>std::vector&lt;T&gt;</code> to <code>new</code> and <code>delete</code>, how could <code>std::vector&lt;T&gt;</code> handle some type <code>T</code> for which allocation and deallocation have to be done through other means?).</p>
<p>There are, of course, quite a few ways to get there. Want to know some of them? Let’s take a deep breath and dive in…</p>
</div>


<div><h1 id="_idParaDest-166" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor171"/>Part 4: Writing Generic Containers (and a Bit More)</h1>
<p>In this part, we will focus on writing efficient generic containers, doing so through explicit memory management, then through implicit memory management, and finally, through allocators, under the various guises these types have held over the years. Leveraging our deeper understanding of memory management techniques and facilities, we will express two types of containers (one that uses contiguous memory and another that uses linked nodes) in ways that can sometimes be much more efficient than a simpler, more naïve implementation would be. We end this part with a look to the near future in memory management with C++.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>, <em class="italic">Writing Generic Containers with Explicit Memory Management</em></li>
<li><a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a>, <em class="italic">Writing Generic Containers with Implicit Memory Management</em></li>
<li><a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a>, <em class="italic">Writing Generic Containers with Allocator Support</em></li>
<li><a href="B21071_15.xhtml#_idTextAnchor213"><em class="italic">Chapter 15</em></a>, <em class="italic">Contemporary Issues</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>