- en: Developing for Embedded Linux and Similar Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为嵌入式Linux和类似系统开发
- en: Small, SoC-based systems are everywhere these days, from smartphones, video
    game consoles, and smart television sets, to infotainment systems in cars and
    airplanes. Consumer devices relying on such systems are extremely common.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于SoC的小型系统无处不在，从智能手机、视频游戏机、智能电视，到汽车和飞机中的信息娱乐系统。依赖于此类系统的消费设备极为常见。
- en: In addition to consumer devices, they're also found as part of industrial and
    building-level controller systems, where they monitor equipment, respond to input,
    and execute scheduled tasks for whole networks of sensors and actuators. Compared
    to MCUs, SoCs are not as resource-limited, usually running a full **operating
    system** (**OS**) such as a Linux-derived OS, VxWorks, or QNX.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了消费设备外，它们还作为工业和建筑级控制器系统的一部分存在，在这些系统中，它们监控设备，响应输入，并执行整个传感器和执行器网络的预定任务。与MCU相比，SoC的资源限制较少，通常运行完整的**操作系统**（**OS**），如基于Linux的操作系统、VxWorks或QNX。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to develop drivers for OS-based embedded systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为基于操作系统的嵌入式系统开发驱动程序
- en: Ways to integrate peripherals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成外围设备的方法
- en: How to handle and implement real-time performance requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理和实现实时性能要求
- en: Recognizing and dealing with resource limitations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和处理资源限制
- en: Embedded operating systems
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式操作系统
- en: An OS is typically used with an embedded system when you're writing your application
    directly for the system's hardware, which is an unrealistic proposal. What an
    OS provides to the application is a number of APIs that abstract away the hardware
    and functionality implemented using this hardware, such as network communications
    or video output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通常与嵌入式系统一起使用，当你直接为系统的硬件编写应用程序时，这是一个不切实际的建议。操作系统提供给应用程序的是一系列API，这些API抽象化了使用该硬件实现的硬件和功能，例如网络通信或视频输出。
- en: The trade-off here is between convenience and both code size and complexity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的权衡是在便利性与代码大小和复杂性之间。
- en: Whereas a bare metal implementation ideally implements only those features it
    needs, an operating system comes with a task scheduler, along with functionality
    that the application being run may not ever need. For this reason, it's important
    to know when to use an OS instead of developing directly for the hardware, understanding
    the complications that come with either.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与裸机实现理想情况下仅实现所需功能不同，操作系统附带任务调度器，以及运行的应用程序可能永远不会需要的功能。因此，了解何时使用操作系统而不是直接为硬件开发，以及理解随之而来的复杂性是很重要的。
- en: Good reasons to use an OS are if you have to be able to run different tasks
    simultaneously (multitasking, or multithreading). Implementing your own scheduler
    from scratch is generally not worth the effort. Having the need to run a non-fixed
    number of applications, and being able to remove and add them at will, is also
    made significantly easier by using an OS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用操作系统的良好理由是，如果你需要能够同时运行不同的任务（多任务处理或多线程）。从头开始实现自己的调度器通常不值得付出努力。需要运行非固定数量的应用程序，并且能够随意添加和删除它们，使用操作系统也会使这一过程变得容易得多。
- en: Finally, features such as advanced graphics output, graphics acceleration (such
    as OpenGL), touch screens, and advanced network functionality (for example, SSH
    and encryption) can be made much easier to implement when you have access to an
    OS and readily accessible drivers, and the APIs related to them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您能够访问操作系统和易于获取的驱动程序以及相关的API时，高级图形输出、图形加速（如OpenGL）、触摸屏和高级网络功能（例如SSH和加密）的实现会变得更加容易。
- en: 'Commonly used embedded operating systems include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的嵌入式操作系统包括以下：
- en: '| **Name** | **Vendor** | **License** | **Platforms** | **Details** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **供应商** | **许可** | **平台** | **详细信息** |'
- en: '| Raspbian | Community-based | Mainly GPL, similar | ARM (Raspberry Pi) | Debian
    Linux-based OS |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Raspbian | 基于社区的 | 主要为GPL，类似 | ARM（树莓派） | 基于Debian Linux的操作系统 |'
- en: '| Armbian | Community-based | GPLv2 | ARM (various boards) | Debian Linux-based
    OS |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Armbian | 基于社区的 | GPLv2 | ARM（各种板） | 基于Debian Linux的操作系统 |'
- en: '| Android | Google | GPLv2, Apache | ARM, x86, x86_64 | Linux-based |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Android | Google | GPLv2, Apache | ARM, x86, x86_64 | 基于Linux |'
- en: '| VxWorks | Wind River (Intel) | Proprietary | ARM, x86, MIPS, PowerPC, SH-4
    | RTOS, monolithic kernel |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| VxWorks | Wind River (Intel) | 商业版权 | ARM, x86, MIPS, PowerPC, SH-4 | 实时操作系统，单核内核
    |'
- en: '| QNX | BlackBerry | Proprietary | ARMv7, ARMv8, x86 | RTOS, microkernel |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| QNX | BlackBerry | 商业版权 | ARMv7, ARMv8, x86 | 实时操作系统，微内核 |'
- en: '| Windows IoT | Microsoft | Proprietary | ARM, x86 | Formerly known as Windows
    Embedded |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Windows IoT | 微软 | 商业版权 | ARM, x86 | 以前称为 Windows Embedded |'
- en: '| NetBSD | NetBSD Foundation | 2-clause BSD | ARM, 68k, MIPS, PowerPC, SPARC,
    RISC-V, x86, and so on | Most portable BSD-based OS |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| NetBSD | NetBSD 基金会 | 2-clause BSD | ARM, 68k, MIPS, PowerPC, SPARC, RISC-V,
    x86 及其他 | 最便携的基于 BSD 的操作系统 |'
- en: What all of these OSes have in common is that they handle basic functionality
    such as memory and task management, while offering access to hardware and OS functionality
    using programming interfaces (APIs).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作系统共同的特点是它们处理基本功能，如内存和任务管理，同时通过编程接口（API）提供对硬件和操作系统功能的访问。
- en: In this chapter, we will specifically focus on SoC and SBC-based systems, which
    reflects in the preceding list of operating systems. Each of these OSes is meant
    to be used on a system with at least a few megabytes of RAM and in the order of
    megabytes to gigabytes of storage.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将特别关注基于 SoC 和 SBC 的系统，这在前面的操作系统列表中有所体现。这些操作系统都旨在用于至少拥有几兆字节 RAM 的系统，以及从兆字节到千兆字节的存储空间。
- en: If the target SoC or SBC is not yet targeted by an existing Linux distribution,
    or one wishes to heavily customize the system, one can use the tools from the
    Yocto Project ([http://www.yoctoproject.org/](http://www.yoctoproject.org/)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标 SoC 或 SBC 还未被现有的 Linux 发行版所针对，或者希望对系统进行大量自定义，可以使用 Yocto 项目（[http://www.yoctoproject.org/](http://www.yoctoproject.org/)）的工具。
- en: Linux-based embedded OSes are quite prevalent, with Android being a well-known
    example. It is mostly used on smartphones, tablets, and similar devices, which
    heavily rely on graphical user interaction, while relying on the Android application
    infrastructure and related APIs. Due to this level of specialization, it is not
    well-suited to other use cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Linux 的嵌入式操作系统相当普遍，Android 是一个众所周知的例子。它主要用于智能手机、平板电脑和类似设备，这些设备高度依赖图形用户交互，同时依赖于
    Android 应用程序基础设施和相关 API。由于这种高度专业化，它并不适合其他使用场景。
- en: Raspbian is based on the very common Debian Linux distribution, aimed at basically
    just the Raspberry Pi series of SBCs. Armbian is similar, but covers a far wider
    range of SBCs. Both of these are community efforts. This is similar to the Debian
    project, which can also be used directly for embedded systems. The main advantage
    of the Raspbian, Armbian, and other similar projects is that they provide ready-made
    images to be used with the target SBC.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Raspbian 基于非常常见的 Debian Linux 发行版，主要针对 Raspberry Pi 系列的 SBC。Armbian 类似，但覆盖了更广泛的
    SBC。这两个都是社区努力的结果。这与 Debian 项目类似，也可以直接用于嵌入式系统。Raspbian、Armbian 和其他类似项目的优势在于它们提供了用于目标
    SBC 的现成镜像。
- en: Like Linux-based OSes, NetBSD has the advantage of being open source, meaning
    that you have full access to the source code and can heavily customize any aspect
    of the operating system, including support for custom hardware. One big advantage
    NetBSD and similar BSD-based OSes have is that the OS is built from a single codebase,
    and managed by a single group of developers. This often simplifies the development
    and maintenance of an embedded project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于 Linux 的操作系统一样，NetBSD 具有开源的优势，这意味着您可以完全访问源代码，并且可以大幅度自定义操作系统的任何方面，包括对自定义硬件的支持。NetBSD
    和类似基于 BSD 的操作系统的一个重大优势是，操作系统是从单个代码库构建的，并由一组开发人员管理。这通常简化了嵌入式项目的开发和维护。
- en: The BSD license (three- or two-clause) offers a major benefit for commercial
    projects, as this license only requires one to provide attribution instead of
    requiring the manufacturer to provide the full source code of the OS on request.
    This can be very relevant if one makes certain modifications to the source code,
    adding code modules that one wants to keep closed source.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 许可证（三或两条款）为商业项目提供了主要好处，因为此许可证仅要求提供归属，而不是要求制造商在请求时提供操作系统的完整源代码。如果对源代码进行了某些修改，添加了希望保持为闭源代码的代码模块，这可能非常相关。
- en: Recent PlayStation gaming consoles, for example, use a modified version of FreeBSD,
    allowing Sony to heavily optimize the OS for the hardware and its use as a gaming
    console without having to release this code together with the rest of the OS's
    source code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，最近的 PlayStation 游戏机使用了一个修改版的 FreeBSD，这使得索尼能够针对硬件及其作为游戏机的使用进行大量优化，而无需将此代码与操作系统其余部分的源代码一起发布。
- en: Proprietary options also exist, such as the offerings from BlackBerry (QNX)
    and Microsoft (Windows IoT, formerly Windows Embedded, formerly Windows CE). These
    tend to require a license fee per device and require the assistance of the manufacturer
    for any customization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一些专有选项，例如BlackBerry（QNX）和Microsoft（Windows IoT，以前称为Windows Embedded，以前称为Windows
    CE）提供的解决方案。这些通常需要按设备支付许可费，并且需要制造商的帮助来进行任何定制。
- en: Real-time OSes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时操作系统
- en: The basic requirement for a real-time OS (RTOS) is that it can guarantee that
    tasks will be executed and finished within a certain time span. This allows one
    to use them for real-time applications where variability (jitter) between the
    execution times of a batch of the same task is not acceptable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实时操作系统（RTOS）的基本要求是它能够保证任务将在一定时间内执行并完成。这允许在执行时间批次中同一任务的执行时间变化（抖动）不可接受的情况下使用它们进行实时应用。
- en: 'From this, we can draw the basic distinction between hard and soft real-time
    OSes: with low jitter, the OS is hard real-time, as it can guarantee that a given
    task will always be executed with practically the same delay. With higher jitter,
    the OS can usually but not always execute a task with the same delay.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，我们可以区分硬实时操作系统和软实时操作系统的基本区别：具有低抖动的操作系统是硬实时操作系统，因为它可以保证给定任务始终以几乎相同的延迟执行。具有较高抖动的操作系统通常但并不总是以相同的延迟执行任务。
- en: Within these two categories, we can again distinguish between event-driven and
    time-sharing schedulers. The former switches tasks based on priority (priority
    scheduling), whereas the latter uses a timer to regularly switch tasks. Which
    design is better depends on what one uses the system for.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个类别中，我们还可以区分事件驱动和时间共享调度程序。前者根据优先级切换任务（优先级调度），而后者使用定时器定期切换任务。哪种设计更好取决于系统用途。
- en: The main thing that time sharing has over event-driven schedulers is that since
    it gives far more CPU time to lower-priority tasks as well, it can make a multitasking
    system seem to run much smoother.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件驱动的调度程序相比，时间共享的主要优势在于它还为低优先级任务提供了更多的CPU时间，这使得多任务系统看起来运行得更加平滑。
- en: Generally, one would only use an RTOS if your project requirements are such
    that one must be able to guarantee that inputs can be handled within a strictly
    defined time window. For applications such as robotics and industrial applications,
    it can be crucial that an action is performed in exactly the same time span every
    time, with failure to do so resulting in the disruption of a production line or
    an inferior product.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，只有当项目需求要求能够保证在严格定义的时间窗口内处理输入时，才会使用RTOS。对于如机器人技术和工业应用等应用，每次执行动作必须在完全相同的时间范围内，否则会导致生产线中断或产品质量下降。
- en: With the example project that we will be looking at later in this chapter, we
    do not use an RTOS, but a regular Linux-based OS, as no hard timing requirements
    exist. Using an RTOS would impose an unneeded burden and likely increase complexity
    and costs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面我们将要讨论的示例项目中，我们不使用RTOS，而是使用基于Linux的常规操作系统，因为没有硬时间要求。使用RTOS将带来不必要的负担，并可能增加复杂性和成本。
- en: One way to regard an RTOS is to get as close to the real-time nature of programming
    directly for the hardware (bare metal) without having to give up all of the conveniences
    of using a full-blown OS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将实时操作系统（RTOS）视为一种方式，即在直接为硬件编程（裸金属）时尽可能接近实时性，同时不必放弃使用完整操作系统带来的所有便利。
- en: Custom peripherals and drivers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制外设和驱动程序
- en: A peripheral is defined as an ancillary device that adds I/O or other functionality
    to a computer system. This can be anything from an I2C, SPI, or SD card controller
    to an audio or graphics device. Most of those are part of the physical SoC, with
    others added via interfaces that the SoC exposes to the outside world. Examples
    of external peripherals would be RAM (via the RAM controller) and a **real-time
    clock** (**RTC**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 外设被定义为一种辅助设备，它可以为计算机系统添加I/O或其他功能。这可以是任何从I2C、SPI或SD卡控制器到音频或图形设备的设备。大多数这些设备是物理SoC的一部分，而其他设备则是通过SoC对外界暴露的接口添加的。外部外设的例子包括RAM（通过RAM控制器）和**实时时钟**（**RTC**）。
- en: One issue that one will likely encounter when using cheaper SBCs such as the
    Raspberry Pi, Orange Pi, and countless similar systems is that they usually lack
    an RTC, meaning that when they are powered off, they no longer keep track of the
    time. The thought behind this is usually that those boards will be connected to
    the internet anyway, so the OS can use an online time service (**Network Time
    Protocol**, or **NTP**) to synchronize the system time, thus saving board space.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像Raspberry Pi、Orange Pi和无数类似系统这样的较便宜的SBC时，人们可能会遇到的一个问题是它们通常缺少RTC，这意味着当它们断电时，它们就不再跟踪时间。背后的想法通常是这些板将无论如何都会连接到互联网，因此操作系统可以使用在线时间服务（**网络时间协议**，或**NTP**）来同步系统时间，从而节省板空间。
- en: One might end up using an SBC in a situation where no internet connection is
    available, or where the delay before online time synchronization is unacceptable,
    or any of a myriad of other reasons. In this case, one may want to add an RTC
    peripheral to the board and configure the OS to make use of it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有互联网连接的情况下，或者在线时间同步前的延迟无法接受，或者任何其他无数原因的情况下，人们可能会使用SBC。在这种情况下，人们可能希望将RTC外围设备添加到板上，并配置操作系统以使用它。
- en: Adding an RTC
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加RTC
- en: 'One can cheaply get RTCs as a ready-to-use module, often based around the DS1307
    chip. This is a 5V module, which connects to the SBC (or MCU) via the I2C bus:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: RTC可以作为一个现成的模块以低价购买，通常基于DS1307芯片。这是一个5V模块，通过I2C总线连接到SBC（或MCU）：
- en: '![](img/5881b3bf-15ed-4189-ab38-619ca08aa8c8.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5881b3bf-15ed-4189-ab38-619ca08aa8c8.png)'
- en: This image is of a small DS1307-based RTC module. As one can see, it has the
    RTC chip, a crystal, and an MCU. The last of these is used to communicate with
    the host system, regardless of whether it is an SoC or MCU-based board. All that
    one requires is the ability to provide the desired voltage (and current) the RTC
    module operates on, along with an I2C bus.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片展示了一个基于DS1307的小型RTC模块。如图所示，它包含RTC芯片、晶体和MCU。最后一个用于与主机系统通信，无论它是基于SoC还是MCU的板。所需的一切只是提供RTC模块运行的所需电压（和电流），以及I2C总线。
- en: After connecting the RTC module to the SBC board, the next goal is to have the
    OS also use it. For this, we must make sure that the I2C kernel module is loaded
    so that we can use I2C devices.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在将RTC模块连接到SBC板后，下一个目标就是让操作系统也使用它。为此，我们必须确保I2C内核模块已加载，这样我们才能使用I2C设备。
- en: Linux distributions for SBCs, such as Raspbian and Armbian, usually come with
    drivers for a number of RTC modules. This allows us to relatively quickly set
    up the RTC module and integrate it with the OS. With the module we looked at earlier,
    we require the I2C and DS1307 kernel modules. For a Raspbian OS on a first-generation
    Raspberry Pi SBC, these modules would be called `i2c-dev`, `2cbcm2708`, and `rtc-ds1307`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SBC的Linux发行版，如Raspbian和Armbian，通常包含许多RTC模块的驱动程序。这使得我们能够相对快速地设置RTC模块并将其集成到操作系统。对于之前查看的模块，我们需要I2C和DS1307内核模块。对于第一代Raspberry
    Pi SBC上的Raspbian操作系统，这些模块将被称为`i2c-dev`、`2cbcm2708`和`rtc-ds1307`。
- en: First, you have to enable these modules so that they are loaded when the system
    starts. For Raspbian Linux, one can edit the `/etc/modules` file to do so, as
    well as other configuration tools made available for this platform. After a reboot,
    we should be able to detect the RTC device on the I2C bus using an I2C scanner
    tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须启用这些模块，以便它们在系统启动时加载。对于Raspbian Linux，可以通过编辑`/etc/modules`文件来实现，也可以使用为该平台提供的其他配置工具。重启后，我们应该能够使用I2C扫描工具检测到I2C总线上的RTC设备。
- en: With the RTC device working, we can remove the fake-hwclock package on Raspbian.
    This is a simple module that fakes an RTC, but merely stores the current time
    in a file before the system is shut down so that on the next boot the filesystem
    dates and similar will be consistent due to resuming from that stored date and
    time, without any new files one creates suddenly being *older* than the existing
    files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当RTC设备工作正常时，我们可以在Raspbian上移除fake-hwclock包。这是一个简单的模块，它模拟RTC，但在系统关闭前仅将当前时间存储在文件中，以便在下次启动时，由于从存储的日期和时间恢复，文件系统日期和类似内容将保持一致，而不会出现新创建的文件突然比现有文件*更旧*。
- en: 'Instead, we''ll be using the hwclock utility, which will use any real RTC to
    synchronize the system time with. This requires one to modify the way the OS starts,
    with the location of the RTC module passed as boot parameters in the following
    form:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用hwclock实用程序，它将使用任何真实的RTC来同步系统时间。这需要修改操作系统启动的方式，将RTC模块的位置作为以下形式的引导参数传递：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will initialize an RTC (`/dev/rtc0`) device on the I2C bus, with address
    0x68.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 I2C 总线上初始化一个 RTC (`/dev/rtc0`) 设备，地址为 0x68。
- en: Custom drivers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义驱动程序
- en: The exact format and integration of drivers (kernel modules) with the OS kernel
    differs for each OS and thus would be impossible to fully cover here. We will,
    however, look at how the driver for the RTC module we used earlier is implemented
    for Linux.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序（内核模块）与操作系统内核的精确格式和集成方式因操作系统而异，因此在这里完全覆盖是不可能的。然而，我们将探讨我们之前使用的 RTC 模块的驱动程序是如何在
    Linux 中实现的。
- en: In addition, we will look at how to use an I2C peripheral from user space later
    in this chapter, in the club room monitoring example. Using a user space-based
    driver (library) is often a good alternative to implementing it as a kernel module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在本章后面，在俱乐部房间监控示例中，探讨如何从用户空间使用 I2C 外设。使用基于用户空间的驱动程序（库）通常是将其实现为内核模块的良好替代方案。
- en: The RTC functionality is integrated into the Linux kernel, with the code for
    it found in the `/drivers/rtc` folder (on GitHub, at [https://github.com/torvalds/linux/tree/master/drivers/rtc](https://github.com/torvalds/linux/tree/master/drivers/rtc)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: RTC 功能集成到 Linux 内核中，其代码位于 `/drivers/rtc` 文件夹中（在 GitHub 上，见 [https://github.com/torvalds/linux/tree/master/drivers/rtc](https://github.com/torvalds/linux/tree/master/drivers/rtc)）。
- en: 'The `rtc-ds1307.c` file contains two functions we need to read and set the
    RTC, respectively: `ds1307_get_time()` and `ds1307_set_time()`. The basic functionality
    of these functions is very similar to what we''ll be using in the club room monitoring
    example later in this chapter, where we simply integrate I2C device support into
    our application.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`rtc-ds1307.c` 文件包含两个我们需要分别读取和设置 RTC 的函数：`ds1307_get_time()` 和 `ds1307_set_time()`。这些函数的基本功能与我们将在本章后面讨论的俱乐部房间监控示例中将要使用的基本功能非常相似，在那里我们只是将
    I2C 设备支持集成到我们的应用程序中。'
- en: A major advantage of communicating with I2C, SPI, and other such peripherals
    from user space is that we are not limited by the compile environment supported
    by the OS kernel. Taking the Linux kernel as an example, it is written mostly
    in C with some assembly. Its APIs are C-style APIs and thus we would have to use
    a distinctly C-style coding approach to writing our kernel modules.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间与 I2C、SPI 和其他此类外设通信的主要优势是我们不受操作系统内核支持的编译环境限制。以 Linux 内核为例，它主要用 C 语言编写，其中包含一些汇编代码。它的
    API 是 C 风格的 API，因此我们必须使用明显是 C 风格的编码方法来编写我们的内核模块。
- en: Obviously, this would negate most of the advantages, not to mention the point,
    of attempting to write these modules in C++ to begin with. When moving our module
    code to user space and using it either as part of an application or as a shared
    library, we have no such limitations and can freely use any and all C++ concepts
    and functionality.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这会抵消尝试最初用 C++ 编写这些模块的大部分优势，更不用说这个观点了。当我们把模块代码移动到用户空间并使用它作为应用程序的一部分或作为共享库时，我们就不再有这种限制，可以自由使用任何
    C++ 概念和功能。
- en: 'For completeness'' sake, the basic template for a Linux kernel module looks
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，Linux 内核模块的基本模板如下：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the requisite Hello World example, written in C++-style.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个必要的 Hello World 示例，用 C++ 风格编写。
- en: One final consideration when considering kernel- and user space-based driver
    modules is that of context switches. From an efficiency point of view, kernel
    modules are faster and have lower latency because the CPU does not have to switch
    from a user to kernel space context and back repeatedly to communicate with a
    device and pass messages from it back to the code communicating with it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑基于内核空间和用户空间的驱动模块时，还有一个需要考虑的最终因素，那就是上下文切换。从效率的角度来看，内核模块更快，延迟更低，因为 CPU 不需要反复在用户空间和内核空间之间切换以与设备通信并将消息从设备传递回与之通信的代码。
- en: For high bandwidth devices (such as storage and capturing), this could make
    the difference between a smoothly functioning system and one that severely lags
    and struggles to perform its tasks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高带宽设备（如存储和捕获），这可能会在系统平稳运行和严重滞后、难以完成任务之间造成差异。
- en: However, when considering the club room monitoring example in this chapter and
    its occasional use of an I2C device, it should be obvious that a kernel module
    would be severe overkill without any tangible benefits.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当考虑本章中的俱乐部房间监控示例及其偶尔使用的 I2C 设备时，很明显，没有实际好处的情况下，使用内核模块将是过度设计。
- en: Resource limitations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源限制
- en: Even though SBCs and SoCs tend to be fairly powerful, they are still no direct
    comparison to a modern desktop system or server. They have distinct limits in
    terms of RAM, storage size, and lack of expansion options.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SBC和SoC在近年来对于常见型号的CPU性能有了显著提升，但通常仍然建议使用交叉编译器在快速的桌面系统或服务器上为SBC生成代码。
- en: With wildly varying amounts of (permanently installed) RAM, you have to consider
    the memory needs of the applications one wishes to run on the system before even
    considering the relatively sluggish CPU performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于（永久性安装的）RAM的容量差异很大，你必须在考虑相对较慢的CPU性能之前，先考虑希望在该系统上运行的应用程序的内存需求。
- en: As SBCs tend to not have any, or significant amounts of, storage with a high
    endurance rate (meaning it can be written to often without limited write cycles
    to take into account), they generally do not have swap space and keep everything
    in the available RAM. Without the fallback of swap, any memory leaks and excessive
    memory usage will rapidly lead to a non-functioning or constantly restarting system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SBC通常没有，或者只有少量具有高耐用率的存储（这意味着它可以经常写入，而不需要考虑有限的写入周期），它们通常没有交换空间，并将所有内容都保存在可用的RAM中。没有交换空间的备用方案，任何内存泄漏和过度使用内存都会迅速导致系统无法正常工作或不断重启。
- en: Even though CPU performance on SBCs has increased significantly over the years
    for commonly available models, it is generally still advisable to use a cross-compiler
    to produce code for the SBC on a fast desktop system or server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SBC上的CPU性能在近年来对于常见型号有了显著提升，但通常仍然建议在快速的桌面系统或服务器上使用交叉编译器为SBC生成代码。
- en: More on development issues and solutions will be covered in [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml),
    *Testing OS-Based Applications*, and [Appendix](ddead19d-4726-49ec-b780-34689efdd0b7.xhtml),
    *Best Practices*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于开发问题和解决方案的内容将在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)，*基于OS的应用程序测试*，和[附录](ddead19d-4726-49ec-b780-34689efdd0b7.xhtml)，*最佳实践*中介绍。
- en: Example – club room monitoring
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 俱乐部房间监控
- en: 'In this section, we will be looking at a practical implementation of an SBC-based
    solution that performs the following functionality for a club room:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个基于SBC的解决方案的实际实现，该解决方案为俱乐部房间执行以下功能：
- en: Monitors the status of the club door's lock
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控俱乐部门锁的状态
- en: Monitors the club status switch
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控俱乐部状态开关
- en: Sends status change notifications over MQTT
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过MQTT发送状态变更通知
- en: Provides a REST API for the current club status
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为当前俱乐部状态提供REST API
- en: Controls status lights
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制状态灯
- en: Controls the power in the club room
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制俱乐部房间的电源
- en: The basic use case here is that we have a club room for which we want to be
    able to monitor the status of its lock, and have a switch inside the club to regulate
    whether the non-permanent power outlets in the club are powered on or not. Turning
    the club status switch to *on* would provide power to those outlets. We also want
    to send out a notification over MQTT so that other devices in the club room or
    elsewhere can update their status.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的基本用例是我们有一个俱乐部房间，我们希望能够监控其锁的状态，并在俱乐部内部有一个开关来调节俱乐部中非永久性电源插座是否通电。将俱乐部状态开关调至*开启*状态将为这些插座供电。我们还想通过MQTT发送通知，以便俱乐部房间或其他地方的设备可以更新其状态。
- en: 'MQTT is a simple, binary publish/subscribe protocol on top of TCP/IP. It offers
    a lightweight communication protocol, suitable for resource-restricted applications
    such as sensor networks. Each MQTT client communicates with a central server:
    the MQTT broker.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是在TCP/IP之上简单二进制发布/订阅协议。它提供了一个轻量级的通信协议，适用于资源受限的应用程序，如传感器网络。每个MQTT客户端都与一个中央服务器通信：MQTT代理。
- en: Hardware
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: 'The block diagram of the `clubstatus` system looks as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`clubstatus`系统的框图如下所示：'
- en: '![](img/bfb888d8-bf9f-4dab-9366-d473d1c7dd7f.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfb888d8-bf9f-4dab-9366-d473d1c7dd7f.png)'
- en: 'For the SBC platform, we use a Raspberry Pi, either the Raspberry Pi B+ model
    or a newer member of the B-series, such as the Raspberry Pi 3 Model B:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SBC平台，我们使用Raspberry Pi，无论是Raspberry Pi B+型号还是B系列的新成员，如Raspberry Pi 3 Model
    B：
- en: '![](img/97073e5a-4311-4381-bf99-025dc76193c3.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97073e5a-4311-4381-bf99-025dc76193c3.png)'
- en: The main features we are looking for in the SBC system are an Ethernet connection
    and, of course, the Raspberry Pi-compatible **general-purpose input/output** (**GPIO**)
    header.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在SBC系统中寻找的主要功能是一个以太网连接，当然，还有与Raspberry Pi兼容的**通用输入/输出**（**GPIO**）引脚。
- en: With this board, we'll use a standard Raspbian OS installation on the μSD card.
    No special configuration is needed beyond this. The primary reason for choosing
    the B+ model or similar is that these have a standard mounting hole pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此板，我们将在μSD卡上使用标准的Raspbian OS安装。除了这个之外不需要特殊配置。选择B+型号或类似型号的主要原因是因为这些具有标准的安装孔图案。
- en: Relays
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继电器
- en: 'To control the status lights and the non-permanent power outlets in the room,
    we use a number of relays, in this case four relays:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制房间内的状态灯和非永久电源插座，我们使用多个继电器，在这种情况下是四个继电器：
- en: '| **Relay** | **Function** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **继电器** | **功能** |'
- en: '| 0 | Power status of non-permanent outlets |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 非永久插座电源状态 |'
- en: '| 1 | Green status light |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 绿色状态灯 |'
- en: '| 2 | Yellow status light |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 黄色状态灯 |'
- en: '| 3 | Red status light |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 红色状态灯 |'
- en: The idea here is that the power status relay is connected to a switch that controls
    the mains power to outlets that are not powered when the club status is off. The
    status lights indicate the current club status. The next section provides the
    details on the implementation of this concept.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，电源状态继电器连接到一个开关，该开关控制当俱乐部状态关闭时未供电的插座的主电源。状态灯指示当前的俱乐部状态。下一节提供了实现这一概念的具体细节。
- en: 'To simplify the design, we will use a ready-made relay board containing four
    relays, which are driven by an NXP PCAL9535A I/O port chip (GPIO expander) connected
    to the I2C bus of the Raspberry Pi SBC:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化设计，我们将使用一个包含四个继电器的现成继电器板，这些继电器由连接到树莓派单板计算机I2C总线的NXP PCAL9535A I/O端口芯片（GPIO扩展器）驱动：
- en: '![](img/5853c932-146d-46f6-abc9-8537243bc361.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5853c932-146d-46f6-abc9-8537243bc361.png)'
- en: 'This particular board is the Seeed Studio Raspberry Pi Relay Board v1.0: [http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/](http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/).
    It offers the four relays we require, allowing us to switch lights and switches
    up to 30 VDC (direct current) or 250 VAC (alternating current). This allows one
    to connect practically any type of lighting and further relays and kin.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的板是Seeed Studio树莓派继电器板v1.0：[http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/](http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/).
    它提供了我们所需的四个继电器，允许我们切换高达30 VDC（直流）或250 VAC（交流）的灯光和开关。这使得可以连接几乎任何类型的照明和进一步的继电器等。
- en: The connection with the SBC is made by stacking the relay board on top of the
    SBC using its GPIO header, which allows us to add further boards on top of the
    relay board. This allows us to add the debounce functionality to the system, as
    indicated in the wiring plan diagram.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用SBC的GPIO引脚堆叠继电器板，我们与SBC连接，这允许我们在继电器板上添加更多板。这使得我们可以将防抖功能添加到系统中，如接线图所示。
- en: Debounce
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防抖
- en: 'The debounce board has the debouncing of switch signals as a requirement, as
    well as providing the Raspberry Pi board with power. The theory and reason behind
    the debouncing of mechanical switches is that the signal provided by those switches
    is not clean, meaning that they don''t immediately switch from open to closed.
    They will briefly close (make contact) before the springiness of the metal contacts
    causes them to open again and rapidly move between these two states, before finally
    settling into its final position, as we can see in the following diagram from
    an oscilloscope connected to a simple switch:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 防抖板需要防抖开关信号，同时为树莓派板提供电源。机械开关防抖的理论和原因在于，这些开关提供的信号不干净，意味着它们不会立即从开到关切换。它们会在金属触点的弹性导致它们再次打开之前短暂闭合（接触），然后在这两种状态之间快速移动，最终稳定在其最终位置，正如我们可以在以下来自连接到简单开关的示波器的图中看到：
- en: '![](img/279f998d-afcf-427d-aeae-3b6f2fcc04e6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/279f998d-afcf-427d-aeae-3b6f2fcc04e6.png)'
- en: The result of this property is that the signal that arrives at the SBC's GPIO
    pins will rapidly change for a number of milliseconds (or worse). Performing any
    kind of action based upon these switch input changes would therefore lead to immense
    problems, as one cannot easily distinguish between a desired switch change and
    the rapid bouncing of the switch contacts during this change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性的后果是，到达SBC GPIO引脚的信号将在几个毫秒内（或更糟）快速变化。因此，基于这些开关输入变化执行任何类型的操作都会导致巨大的问题，因为无法轻易区分所需的开关变化和在此变化期间开关触点快速弹跳。
- en: It is possible to debounce a switch either in hardware or software. The latter
    solution involves the starting of a timer when the state of the switch first changes.
    The assumption behind this is that after a certain time (in milliseconds) has
    expired, the switch is in a stable state and can be safely read out. This approach
    has disadvantages in that it puts an extra burden on the system by taking up one
    or more timers, or pausing the program's execution. Also, using interrupts on
    the input for the switch requires one to disable interrupts while the timer is
    running, adding further complexity to the code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过硬件或软件去抖动一个开关。后者解决方案涉及在开关状态首次改变时启动计时器。背后的假设是在一定时间（以毫秒为单位）过后，开关处于稳定状态，可以安全地读取。这种方法的不利之处在于它通过占用一个或多个计时器或暂停程序的执行，给系统增加了额外的负担。此外，在开关输入上使用中断需要在一个计时器运行时禁用中断，这进一步增加了代码的复杂性。
- en: 'Debouncing in hardware can be done using discrete components, or using an SR
    latch (consisting of two NAND gates). For this application, we will use the following
    circuit, which works well with the most commonly used SPST (single-pole, single-throw)
    type of switch:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件去抖动可以使用离散元件，或者使用 SR 锁存器（由两个与非门组成）。对于这个应用，我们将使用以下电路，它与最常用的 SPST（单刀单掷）开关类型配合得很好：
- en: '![](img/78c9ed38-dcb3-4eb3-85a1-733bf19c5bd6.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78c9ed38-dcb3-4eb3-85a1-733bf19c5bd6.png)'
- en: The concept behind this circuit is that when the switch is open, the capacitor
    is charged via R1 (and D1), causing the input on the inverting Schmitt trigger
    circuit (U1) to go high, resulting in the GPIO pin of the SBC connected to the
    output of U1 to read low. When the switch closes, the capacitor is discharged
    to the ground over R2.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电路背后的概念是，当开关闭合时，电容器通过 R1（和 D1）充电，导致反相施密特触发器电路（U1）的输入变高，从而使连接到 U1 输出的 SBC 的
    GPIO 引脚读取为低。当开关闭合时，电容器通过 R2 放电到地。
- en: 'Both the charging and discharging will take a certain amount of time, which
    adds latency before a change is registered on the input of U1\. The charging and
    discharging rates are determined by the values of R1 and R2, the formulas for
    which are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 充电和放电都会花费一定的时间，这会在 U1 输入上注册变化之前增加延迟。充电和放电速率由 R1 和 R2 的值决定，其公式如下：
- en: Charging: ![](img/0ec96986-b5cd-4e73-9ad3-38681f477c37.png)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充电： ![](img/0ec96986-b5cd-4e73-9ad3-38681f477c37.png)
- en: Discharging: ![](img/6472a5a6-f642-45ee-89c1-8826d4387364.png)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放电： ![](img/6472a5a6-f642-45ee-89c1-8826d4387364.png)
- en: Here, *V(t)* is the voltage at time *t* (in seconds). *V[S]* is the source voltage
    and *t* is the time in seconds after the source voltage has been applied. R is
    the circuit resistance in Ohm and C the capacitance in farads. Finally, *e* is
    a mathematical constant with the value of 2.71828 (approximately), also known
    as Euler's number.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*V(t)* 是时间 *t*（以秒为单位）时的电压。*V[S]* 是源电压，*t* 是源电压施加后的时间（以秒为单位）。R 是电路电阻（以欧姆为单位），C
    是电容（以法拉为单位）。最后，*e* 是一个数学常数，其值为 2.71828（约数），也称为欧拉数。
- en: 'For the charging and discharging of capacitors, the RC time constant, tau (τ),
    is used, which is defined as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电容器的充电和放电，使用 RC 时间常数 tau (τ)，其定义如下：
- en: '![](img/4c70f6d7-152d-44d3-a793-6c3786e82007.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c70f6d7-152d-44d3-a793-6c3786e82007.png)'
- en: This defines the time it takes for the capacitor to be charged up to 63.2% (1τ),
    then 86% (2τ). The discharging of a capacitor for 1τ from fully charged will reduce
    its charge to 37%, and 13.5% after 2τ. One of the things one notices here is that
    a capacitor is never fully charged or discharged; the process of charging or discharging
    just slows down to the point where it becomes almost imperceptible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了电容器充电到 63.2%（1τ），然后到 86%（2τ）所需的时间。从完全充电状态放电 1τ 将其电荷减少到 37%，2τ 后减少到 13.5%。在这里注意到的一件事是，电容器永远不会完全充电或放电；充电或放电的过程只是减慢到几乎不可察觉的程度。
- en: 'With the values that we used for our debounce circuit, we get the following
    charge time constant for charging:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们为我们的去抖动电路所使用的值，我们得到以下充电时间常数：
- en: '![](img/32b180c1-b53b-4bb7-82ed-e324fb5f3094.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32b180c1-b53b-4bb7-82ed-e324fb5f3094.png)'
- en: 'The discharge time is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 放电时间如下：
- en: '![](img/5f7819ea-e9e2-461d-a593-c4fdd7ba7a39.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f7819ea-e9e2-461d-a593-c4fdd7ba7a39.png)'
- en: This corresponds to 51 and 22 microseconds, respectively.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于 51 和 22 微秒，分别。
- en: 'Like any Schmitt trigger, it has so-called hysteresis, meaning that it has
    dual thresholds. This effectively adds a dead zone in the output response above
    and below, which the output will not change:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何施密特触发器都有所谓的滞后，这意味着它有两个阈值。这实际上在输出响应的上下方增加了一个死区，输出将不会改变：
- en: '![](img/bc437d21-ffee-4425-9d2f-3184fc28df6d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc437d21-ffee-4425-9d2f-3184fc28df6d.png)'
- en: The hysteresis from a Schmitt trigger is usually used to remove noise from an
    incoming signal by setting explicit trigger levels. Even though the RC circuit
    we are already using should filter out practically all noises, adding a Schmitt
    trigger adds that little bit more insurance without any negative repercussions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 施密特触发器的滞后通常用于通过设置明确的触发电平来从输入信号中去除噪声。即使我们正在使用的RC电路应该过滤掉几乎所有噪声，添加施密特触发器也增加了额外的保险，而没有任何负面影响。
- en: When available, it is also possible to use the hysteresis functionality of an
    SBC's GPIO pins. For this project and the chosen debounce circuit, we also want
    the inverting property of the chip so that we get the expected high/low response
    for the connected switch instead of having to invert the meaning in software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当可用时，也可以使用SBC的GPIO引脚的滞后功能。对于这个项目和所选的消抖电路，我们还想让芯片具有反相特性，以便我们得到预期的开关高/低响应，而不是需要在软件中反转其含义。
- en: Debounce HAT
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消抖HAT
- en: 'Using the information and debounce circuit from the previous section, a prototype
    board is assembled:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节中的信息和消抖电路，组装了一个原型板：
- en: '![](img/3c655ae5-9b38-479e-8178-6676cf9e0cd9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c655ae5-9b38-479e-8178-6676cf9e0cd9.png)'
- en: This prototype implements two debounce channels for the two switches that are
    required by the project. It also adds a screw terminal to connect the SBC power
    connection to. This allows one to power the SBC via the 5V header pins instead
    of having to use the micro-USB connector of the Raspberry Pi. For integration
    purposes, it's usually easier to just run the wires directly from the power supply
    into a screw terminal or similar than to bodge on a micro-USB plug.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原型实现了两个消抖通道，用于项目所需的两个开关。它还增加了一个螺钉端子，可以将SBC电源连接连接起来。这允许用户通过5V引脚头而不是使用Raspberry
    Pi的micro-USB连接器为SBC供电。为了集成目的，通常直接从电源将电线连接到螺钉端子或类似设备比在micro-USB插头上进行修补要容易。
- en: 'This prototype is, of course, not a proper HAT, as defined by the Raspberry
    Pi Foundation''s rules. These require the following features:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个原型板不符合Raspberry Pi基金会规定的HAT定义。这些要求以下功能：
- en: It has a valid EEPROM containing vendor information, GPIO map, and device information
    connected to the `ID_SC` and `ID_SD` I2C bus pins on the Raspberry Pi SBC
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它连接到Raspberry Pi SBC上的`ID_SC`和`ID_SD` I2C总线引脚的EEPROM包含有效的供应商信息、GPIO映射和设备信息
- en: It has the modern 40-pin (female) GPIO connector, also spacing the HAT from
    the SBC by at least 8 millimeters
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有现代的40针（雌性）GPIO连接器，并且将HAT与SBC之间的间距至少设置为8毫米
- en: It follows the mechanical specification
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循机械规范
- en: If providing power to the SBC via the 5V pins, the HAT has to be able to provide
    at least 1.3 amperes continuously
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过5V引脚为SBC供电，HAT必须能够连续提供至少1.3安培的电流
- en: 'With the required I2C EEPROM (CAT24C32) and other features added, we can see
    what a full version using the six channels offered by the inverting hex Schmitt
    trigger IC (40106) looks like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加所需的I2C EEPROM（CAT24C32）和其他功能后，我们可以看到使用反相六通道施密特触发器IC（40106）提供的六个通道的全版本看起来是什么样子：
- en: '![](img/f94f1673-7d99-4eb5-b684-35e094620374.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f94f1673-7d99-4eb5-b684-35e094620374.png)'
- en: The files for this KiCad project can be found at the author's GitHub account
    at [https://github.com/MayaPosch/DebounceHat](https://github.com/MayaPosch/DebounceHat).
    With the extended number of channels, it would be relatively easy to integrate
    further switches, relays, and other elements into the system, possibly monitoring
    things like windows and such with various sensors that output a high/low signal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该KiCad项目的文件可以在作者的GitHub账户[https://github.com/MayaPosch/DebounceHat](https://github.com/MayaPosch/DebounceHat)中找到。随着通道数量的增加，将更多的开关、继电器和其他元素集成到系统中相对容易，可能使用各种输出高/低信号的传感器来监控窗户等事物。
- en: Power
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电源
- en: For our project, the required voltages we need are 5V for the Raspberry Pi board
    and a second voltage for the lights that we switch on and off via the relays.
    The power supply we pick has to be able to provide sufficient power to the SBC
    and the lights. For the former, 1-2 A should suffice, with the latter depending
    on the lights being used and their power requirements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们需要的电压是 Raspberry Pi 板的 5V 和通过继电器开关的灯的第二电压。我们选择的电源必须能够为 SBC 和灯提供足够的电力。对于前者，1-2
    A 应该足够，后者则取决于使用的灯及其功率需求。
- en: Implementation
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The monitoring service will be implemented as a basic `systemd` service, meaning
    that it will be started by the operating system when the system starts, and the
    service can be monitored and restarted using all the regular systemd tools.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 监控服务将被实现为一个基本的 `systemd` 服务，这意味着操作系统启动时将启动该服务，并且可以使用所有常规的 systemd 工具来监控和重启该服务。
- en: 'We will have the following dependencies:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有以下依赖项：
- en: POCO
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POCO
- en: WiringPi
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WiringPi
- en: libmosquittopp (and libmosquitto)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libmosquittopp（和 libmosquitto）
- en: The libmosquitto dependency ([https://mosquitto.org/man/libmosquitto-3.html](https://mosquitto.org/man/libmosquitto-3.html))
    is used to add MQTT support. The libmosquittopp dependency is a wrapper around
    the C-based API to provide a class-based interface, which makes integration into
    C++ projects easier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: libmosquitto 依赖项（[https://mosquitto.org/man/libmosquitto-3.html](https://mosquitto.org/man/libmosquitto-3.html)）用于添加
    MQTT 支持。libmosquittopp 依赖项是对基于 C 的 API 的封装，以提供基于类的接口，这使得将其集成到 C++ 项目中更加容易。
- en: The POCO framework ([https://pocoproject.org/](https://pocoproject.org/)) is
    a highly portable set of C++ APIs, which provides everything from network-related
    functions (including HTTP) to all common low-level functions. In this project,
    its HTTP server will be used, along with its support for handling configuration
    files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: POCO 框架（[https://pocoproject.org/](https://pocoproject.org/)）是一组高度可移植的 C++ API，它提供了从网络相关函数（包括
    HTTP）到所有常见低级函数的一切。在本项目中，将使用其 HTTP 服务器，以及其处理配置文件的支持。
- en: Finally, WiringPi ([http://wiringpi.com/](http://wiringpi.com/)) is the de facto
    standard header for accessing and using the GPIO header features on the Raspberry
    Pi and compatible systems. It implements APIs to communicate with I2C devices
    and UARTs, and uses PWM and digital pins. In this project, it allows us to communicate
    with the relay board and the debounce board.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，WiringPi ([http://wiringpi.com/](http://wiringpi.com/)) 是访问和使用 Raspberry
    Pi 和兼容系统上的 GPIO 头功能的既定标准头文件。它实现了与 I2C 设备和 UART 通信的 API，并使用 PWM 和数字引脚。在本项目中，它允许我们与继电器板和消抖板通信。
- en: 'The current version of this code can also be found at the author''s GitHub
    account: [https://github.com/MayaPosch/ClubStatusService](https://github.com/MayaPosch/ClubStatusService).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的此代码可以在作者的 GitHub 账户中找到：[https://github.com/MayaPosch/ClubStatusService](https://github.com/MayaPosch/ClubStatusService)。
- en: 'We will start with the main file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从主文件开始：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we include some basic STL functionality, along with the HTTP server and
    `ini` file support from POCO. The listener header is for our MQTT class, with
    the `httprequestfactory` and club headers being for the HTTP server and the main
    monitoring logic, respectively:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了一些基本的 STL 功能，以及来自 POCO 的 HTTP 服务器和 `ini` 文件支持。监听器头文件用于我们的 MQTT 类，而
    `httprequestfactory` 和 club 头文件分别用于 HTTP 服务器和主要的监控逻辑：
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this section, we initialize the MQTT library (libmosquittopp) and try to
    open the configuration file, using the default path and name if nothing is specified
    in the command-line parameters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们初始化 MQTT 库（libmosquittopp），并尝试打开配置文件，如果命令行参数中没有指定，则使用默认路径和名称。
- en: POCO's `IniFileConfiguration` class is used to open and read in the configuration
    file, throwing an exception if it cannot be found or opened. POCO's `AutoPtr`
    is equivalent to C++11's `unique_ptr`, allowing us to create a new heap-based
    instance without having to worry about disposing of it later.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: POCO 的 `IniFileConfiguration` 类用于打开和读取配置文件，如果找不到或无法打开，则会抛出异常。POCO 的 `AutoPtr`
    与 C++11 的 `unique_ptr` 相当，允许我们创建一个新的基于堆的实例，而无需担心以后如何处理它。
- en: 'Next, we read out the values that we are interested in for the MQTT and relay
    board functionality, specifying defaults where it makes sense to do so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将读取我们对 MQTT 和继电器板功能感兴趣的价值，并在合理的地方指定默认值：
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we start the MQTT class, providing it with the parameters it
    needs to connect to the MQTT broker. Next, the HTTP server's configuration details
    are read out and a new `HTTPServer` instance is created.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们启动MQTT类，向其提供连接到MQTT代理所需的参数。接下来，读取HTTP服务器的配置细节并创建一个新的`HTTPServer`实例。
- en: The server instance is configured with the provided port and some limits for
    the maximum number of threads the HTTP server is allowed to use, as well as for
    the maximum queued connections it can keep. These parameters are useful to optimize
    system performance and fit code like this into systems with fewer resources to
    spare.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实例配置了提供的端口和一些限制，即HTTP服务器允许使用的最大线程数以及它可以保持的最大队列连接数。这些参数对于优化系统性能并将代码放入资源较少的系统中有用。
- en: 'New client connections are handled by the custom `RequestHandlerFactory` class,
    which we will look at later:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 新的客户端连接由自定义的`RequestHandlerFactory`类处理，我们稍后会看到：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we assign a reference to the Listener instance we created to the static
    `Club` class's `mqtt` member. This will allow the `Listener` object to be used
    more easily later on, as we will see.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们创建的Listener实例的引用分配给静态`Club`类的`mqtt`成员。这将使得`Listener`对象在以后更容易使用，正如我们将看到的。
- en: With calling `start()` on `Club`, the monitoring and configuring of the connected
    hardware will be handled and we are done with that aspect in the main function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Club`上调用`start()`，将处理连接硬件的监控和配置，我们在主函数中完成这一方面。
- en: Finally, we enter a loop for the MQTT class, ensuring that it remains connected
    to the MQTT broker. Upon leaving the loop, we will clean up resources and stop
    the HTTP server and others. However, since we are in an infinite loop here, this
    code will not be reached with this implementation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入MQTT类的循环，确保它保持连接到MQTT代理。在离开循环时，我们将清理资源并停止HTTP服务器和其他服务。然而，由于我们在这里处于无限循环中，这段代码将不会在这个实现中被达到。
- en: Since this implementation would be run as a service that runs 24/7, a way to
    terminate the service cleanly is not an absolute requirement. A relatively easy
    way to do this would be to add a signal handler that would interrupt the loop
    once triggered. For simplicity's sake, this has been left out of this project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个实现将以24/7运行的服务形式运行，因此提供一个干净地终止服务的方法不是绝对必要的。一个相对简单的方法是添加一个信号处理器，一旦触发就会中断循环。为了简单起见，这个项目已经省略了这一点。
- en: Listener
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Listener
- en: 'The class declaration for the `Listener` class looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listener`类的类声明如下：'
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This class provides a simple API to connect to an MQTT broker and send messages
    to said broker. We inherit from the `mosquittopp` class, re-implementing a number
    of callback methods to handle the events of connecting newly received messages
    and completed subscriptions to MQTT topics.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一个简单的API来连接到MQTT代理并向该代理发送消息。我们继承自`mosquittopp`类，重新实现了多个回调方法来处理连接新接收的消息和完成对MQTT主题的订阅的事件。
- en: 'Next, let''s have a look at the implementation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看实现：
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the constructor, we assign the unique MQTT client identification string using
    the mosquittopp class's constructor. We use a default value for the keep alive
    setting of 60 seconds, meaning the time for which we will keep a connection open
    to the MQTT broker without any side sending a control or other message.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用mosquittopp类的构造函数分配唯一的MQTT客户端标识字符串。我们为保持连接设置使用默认值60秒，这意味着我们将保持与MQTT代理的连接打开，在此期间没有任何端点发送控制或其他消息。
- en: 'After setting a username and password, we connect to the MQTT broker:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置用户名和密码后，我们连接到MQTT代理：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This callback function is called whenever a connection attempt has been made
    with the MQTT broker. We check the value of `rc` and if the value is zero—indicating
    success—we start subscribing to any desired topics. Here, we subscribe to just
    one topic: /club/status. If any other MQTT clients send a message to this topic,
    we will receive it in the following callback function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调函数在尝试连接到MQTT代理时被调用。我们检查`rc`的值，如果值为零——表示成功——我们开始订阅任何所需的主题。在这里，我们只订阅一个主题：/club/status。如果任何其他MQTT客户端向此主题发送消息，我们将在以下回调函数中接收到它：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this callback function, we receive a struct with the MQTT topic and payload.
    We then compare the topic to the topic strings we subscribed to, which in this
    case is just the /club/status topic. Upon receiving a message for this topic,
    we publish a new MQTT message with a topic and payload. The last parameter is
    the **quality of service** (**QoS**) value, with in this case setting is the *deliver
    at least once* flag. This guarantees that at least one other MQTT client will
    receive our message.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调函数中，我们接收一个包含 MQTT 主题和负载的结构体。然后我们将主题与我们所订阅的主题字符串进行比较，在这个例子中就是 /club/status
    主题。在接收到这个主题的消息后，我们发布一个新的 MQTT 消息，包含主题和负载。最后一个参数是服务质量（**QoS**）值，在这个例子中设置为 *至少发送一次*
    标志。这保证了至少有一个其他的 MQTT 客户端会接收到我们的消息。
- en: The MQTT payload is always a binary, that is, `1` in this example. To make it
    reflect the status of the club room (opened or closed), we would have to integrate
    the response from the static `Club` class, which we will be looking at in the
    next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT 负载始终是二进制的，即在这个例子中是 `1`。为了使其反映俱乐部房间的状态（开启或关闭），我们必须集成来自静态 `Club` 类的响应，我们将在下一节中查看。
- en: 'First, we look at the remaining functions for the `Listener` class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看 `Listener` 类的剩余函数：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The callback function for a new subscription is left empty here, but could be
    used to add logging or such functionality. Furthermore, we have an overloaded
    `sendMessage()` function, which allows other parts of the application to also
    publish MQTT messages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里留空的新的订阅回调函数，但可以用来添加日志记录或其他功能。此外，我们还有一个重载的 `sendMessage()` 函数，它允许应用程序的其他部分也可以发布
    MQTT 消息。
- en: The main reason to have these two different functions is that sometimes it's
    easier to use a `char*` array to send, for example, an array of 8-bit integers
    as part of a binary protocol, whereas other times an STL string is more convenient.
    This way, we get the best of both worlds, without having to convert one or the
    other whenever we wish to send an MQTT message anywhere in our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有这两个不同函数的主要原因是，有时使用 `char*` 数组发送数据更容易，例如，作为二进制协议的一部分发送一个 8 位整数的数组，而有时 STL 字符串更方便。这样，我们就能同时获得两者的优点，而无需在需要将
    MQTT 消息发送到代码中的任何位置时进行转换。
- en: The first parameter to `publish()` is the message ID, which is a custom integer
    we can assign ourselves. Here, we leave it at zero. We also make use of the *retain* flag
    (last parameter), setting it to true. This implies that whenever a new MQTT client
    subscribes to the topic we published a retained message on, this client will always
    receive the last message that was published on that particular topic.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish()` 函数的第一个参数是消息 ID，这是一个我们可以自行分配的自定义整数。在这里，我们将其保留为零。我们还使用了 *保留* 标志（最后一个参数），将其设置为
    true。这意味着每当一个新的 MQTT 客户端订阅了我们发布保留消息的主题时，该客户端总是会接收到该特定主题上最后发布的消息。'
- en: Since we will be publishing the status of the club rooms on an MQTT topic, it
    is desirable that the last status message is retained by the MQTT broker so that
    any client that uses this information will immediately receive the current status
    the moment it connects to the broker, instead of having to wait for the next status
    update.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将通过 MQTT 主题发布俱乐部房间的状态，因此希望 MQTT 代理保留最后的状态消息，这样任何使用这些信息的客户端在连接到代理时都能立即接收到当前状态，而无需等待下一次状态更新。
- en: Club
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 俱乐部
- en: 'The club header declares the classes that form the core of the project, and
    is responsible for dealing with the inputs from the switches, controlling the
    relays, and updating the status of the club room:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 俱乐部头文件声明了构成项目核心的类，并负责处理开关的输入、控制继电器以及更新俱乐部房间的状态：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing of note in this header file are the includes. They add the
    basic WiringPi GPIO functionality to our code, as well as those for I2C usage.
    Further WiringPi one could include for other projects requiring such functionality
    would be SPI, UART (serial), software PWM, Raspberry Pi (Broadcom SoC) specific
    functionality, and others:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个头文件中，首先值得注意的是包含部分。它们为我们添加了基本的 WiringPi GPIO 功能，以及用于 I2C 使用的功能。对于其他需要此类功能的项目，还可以包括
    SPI、UART（串行）、软件 PWM、Raspberry Pi（Broadcom SoC）特定功能以及其他功能：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We define the different log levels we will be using as an `enum`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们将要使用的不同日志级别，作为一个 `enum`：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We forward declare the `Listener` class, as we will be using it in the implementation
    for these classes, but don''t want to include the entire header for it yet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提前声明了 `Listener` 类，因为我们将在这些类的实现中使用它，但还不希望包含它的整个头文件：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ClubUpdater` class is responsible for configuring the I2C-based GPIO expander,
    which controls the relays, as well as handling any updates to the club status.
    A `Timer` instance from the POCO framework is used to add a delay to the power
    status relay, as we will see when we look at the implementation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClubUpdater`类负责配置基于I2C的GPIO扩展器，该扩展器控制继电器，以及处理任何关于俱乐部状态的更新。使用POCO框架中的`Timer`实例来为电源状态继电器添加延迟，正如我们在查看实现时将看到的那样。'
- en: This class inherits from the POCO `Runnable` class, which is the base class
    that's expected by the POCO `Thread` class, which is a wrapper around native threads.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承自POCO的`Runnable`类，这是POCO `Thread`类期望的基类，而`Thread`类是原生线程的包装器。
- en: 'The two `uint8_t` member variables mirror two registers on the I2C GPIO expander
    device, allowing us to set the direction and value of the output pins on the device,
    which effectively controls the attached relays:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`uint8_t`成员变量反映了I2C GPIO扩展器设备上的两个寄存器，允许我们设置设备上输出引脚的方向和值，这实际上控制了连接的继电器：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Club` class can be regarded as the input side of the system, setting up
    and handling the ISRs (interrupt handlers), as well as acting as the central (static)
    class with all of the variables pertaining to the club status, such as the status
    of the lock switch, status switch, and status of the power system (club open or
    closed).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Club`类可以被视为系统的输入端，设置和处理ISRs（中断处理程序），同时作为包含所有与俱乐部状态相关的变量（如锁开关状态、状态开关状态和电源系统状态（俱乐部开启或关闭））的中心（静态）类。'
- en: This class is made fully static so that it can be used freely by different parts
    of the program to inquire about the room status.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被完全设置为静态，以便程序的不同部分可以自由地使用它来查询房间状态。
- en: 'Moving on, here is the implementation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是实现部分：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we include the `Listener` header so that we can use it. We also include
    the POCO `NumberFormatter` class to allow us to format integer values for logging
    purposes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了`Listener`头文件，以便我们可以使用它。我们还包含了POCO的`NumberFormatter`类，以便我们可以格式化整数值以供日志记录：
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we define all of the registers of the target GPIO expander device, the
    NXP PCAL9535A. Even though we only use two of these registers, it''s generally
    a good practice to add the full list to simplify later expansion of the code.
    A separate header can be used as well to allow one to easily use different GPIO
    expanders without significant changes to your code, or any at all:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了目标GPIO扩展器设备NXP PCAL9535A的所有寄存器。尽管我们只使用了这些寄存器中的两个，但通常将完整的列表添加进来是一个很好的实践，这样可以简化后续代码的扩展。也可以使用单独的头文件，以便于在不进行重大更改或完全不更改代码的情况下轻松使用不同的GPIO扩展器：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we define which functionality is connected to which relay, corresponding
    to a specific output pin of the GPIO expander chip. Since we have four relays,
    four pins are used. These are connected to the first bank (of two in total) of
    eight pins on the chip.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了哪些功能连接到哪个继电器，对应于GPIO扩展器芯片的特定输出引脚。由于我们有四个继电器，因此使用了四个引脚。这些引脚连接到芯片上的第一个银行（总共两个银行）的八个引脚。
- en: 'Naturally, it is important that these definitions match up with what is physically
    hooked up to those relays. Depending on the use case, one could make this configurable
    as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这些定义与物理连接到继电器的部分相匹配是很重要的。根据使用情况，也可以将其设置为可配置的：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As `Club` is a fully static class, we initialize all of its member variables
    before we move into the `ClubUpdater` class''s implementation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Club`是一个完全静态的类，我们在进入`ClubUpdater`类的实现之前初始化了其所有成员变量：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we start an instance of this class, its `run()` function gets called. Here,
    we set a number of defaults. The direction and output register variables are initially
    set to zero. The club room power status is set to false, and the power timer-related
    Booleans are set to false, as the power timer is not active yet. This timer is
    used to set a delay before the power is turned on or off, as we will see in more
    detail in a moment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动这个类的实例时，它的`run()`函数会被调用。在这里，我们设置了一些默认值。方向和输出寄存器变量最初被设置为零。俱乐部房间的电源状态被设置为false，与电源计时器相关的布尔值也被设置为false，因为电源计时器尚未激活。这个计时器用于在打开或关闭电源之前设置一个延迟，正如我们稍后将更详细地看到的那样。
- en: 'By default, the delay on this timer is ten seconds. This can, of course, also
    be made configurable:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个计时器的延迟是十秒。当然，这也可以设置为可配置的：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we set up the I2C GPIO expander. This requires the I2C device address,
    which we passed to the `Club` class earlier on. What this setup function does
    is ensure that there is an active I2C device at this address on the I2C bus. After
    this, it should be ready to communicate with. It is also possible to skip this
    step via setting the relayActive variable to false. This is done by setting the
    appropriate value in the configuration file, which is useful when running integration
    tests on a system without an I2C bus or connected device.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置I2C GPIO扩展器。这需要I2C设备地址，我们之前将其传递给了`Club`类。此设置函数的作用是确保在I2C总线上存在一个活动I2C设备在该地址。在此之后，它应该准备好进行通信。也可以通过将`relayActive`变量设置为false来跳过此步骤。这是通过在配置文件中设置适当的值来完成的，这在在没有I2C总线或连接设备的情况下运行集成测试时很有用。
- en: 'With the setup complete, we write the initial values of the direction and output
    registers for the first bank. Both are written with null bytes so that all eight
    pins they control are set to both output mode and to a binary zero (low) state.
    This way, all relays connected to the first four pins are initially off:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 完成设置后，我们为第一个存储器的方向寄存器和输出寄存器写入初始值。这两个寄存器都使用空字节写入，以确保它们控制的八个引脚都设置为输出模式，并且处于二进制零（低）状态。这样，连接到前四个引脚的所有继电器最初都是关闭的：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After completing these configuration steps, we run the first update of the club
    room status, using the same function that will also be called later on when the
    inputs change. This results in all of the inputs being checked and the outputs
    being set to a corresponding status.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些配置步骤后，我们使用稍后当输入改变时也将调用的相同函数运行第一个俱乐部房间状态的更新。这导致检查所有输入，并将输出设置为相应的状态。
- en: Finally, we enter a waiting loop. This loop is controlled by the `Club::running`
    Boolean variable, allowing us to break out of it via a signal handler or similar.
    The actual waiting is performed using a condition variable, which we wait for
    here until either a time-out occurs on the one-minute wait (after which, we return
    to waiting after a quick check), or we get signaled by one of the interrupts that
    we will set later on for the inputs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入一个等待循环。此循环由`Club::running`布尔变量控制，允许我们通过信号处理程序或类似方式从中退出。实际的等待是通过一个条件变量来执行的，我们在这里等待，直到一分钟等待超时（之后，我们在快速检查后返回等待），或者我们被稍后将为输入设置的其中一个中断之一所信号。
- en: 'Moving on, we look at the function that''s used to update the status of the
    outputs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看用于更新输出状态的函数：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do when we enter this update function is to ensure that the
    `Club::clubChanged` Boolean is set to false so that it can be set again by one
    of the interrupt handlers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入此更新函数时，我们首先确保`Club::clubChanged`布尔值设置为false，以便它可以由其中一个中断处理程序再次设置。
- en: After this, we check what has changed exactly on the inputs. If the lock switch
    got triggered, its Boolean variable will have been set to true, or the variable
    for the status switch will likely have been triggered. If this is the case, we
    reset the variable and compare the newly read value with the last known value
    for that input.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查输入中确切发生了什么变化。如果锁开关被触发，其布尔变量将被设置为true，或者状态开关的变量可能已经被触发。如果是这种情况，我们将重置变量，并将新读取的值与该输入的已知最后值进行比较。
- en: As a sanity check, we ignore the triggering if the value hasn't changed. This
    could happen if the interrupt got triggered due to noise, such as when the signal
    wire for a switch runs near power lines. Any fluctuation in the latter would induce
    a surge in the former, which can trigger the GPIO pin's interrupt. This is one
    obvious example of both the reality of dealing with a non-ideal physical world
    and a showcase for the importance of both the hardware and software in how they
    affect the reliability of a system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种合理性检查，如果值没有变化，我们将忽略触发。这可能发生在由于噪声而触发中断的情况下，例如当开关的信号线靠近电源线时。后者的任何波动都会在前者中引起浪涌，从而触发GPIO引脚的中断。这是处理非理想物理世界现实的一个明显例子，也是硬件和软件如何影响系统可靠性的重要性的展示。
- en: In addition to this check, we log the event using our central logger, and update
    the buffered input value for use in the next run.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个检查之外，我们还使用我们的中央记录器记录事件，并更新缓冲的输入值，以便在下次运行中使用。
- en: 'The last two cases in the if/else statement deal with the initial run, as well
    as a default handler. When we initially run this function the way we saw earlier,
    no interrupt will have been triggered, so obviously we have to add a third situation
    to the first two for the status and lock switches:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: if/else 语句中的最后两个情况处理初始运行以及默认处理程序。当我们最初以我们之前看到的方式运行此函数时，没有触发中断，因此显然我们必须为状态和锁定开关添加第三种情况：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we check whether we have to change the status of the club room from closed
    to open, or the other way around. This is determined by checking whether the club
    status (`Club::clubOff`) Boolean has changed relative to the `Club::clubIsClosed`
    Boolean, which stores the last known status.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否需要将俱乐部房间的状态从关闭更改为开启，或者相反。这是通过检查俱乐部状态（`Club::clubOff`）布尔值相对于存储最后已知状态的
    `Club::clubIsClosed` 布尔值是否发生变化来确定的。
- en: Essentially, if the status switch is changed from on to off or the other way
    around, this will be detected and a change to the new status will be started.
    This means that a power timer will be started, which will turn the non-permanent
    power in the club room on or off after the preset delay.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果状态开关从开启更改为关闭或相反，这将被检测到，并开始新的状态更改。这意味着将启动一个电源定时器，该定时器将在预设延迟后打开或关闭俱乐部房间中的非永久电源。
- en: The POCO `Timer` class requires that we first stop the timer before starting
    it if it has been started previously. This requires us to add one additional check.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: POCO `Timer` 类要求我们在启动定时器之前先停止定时器，如果它之前已经被启动。这需要我们添加一个额外的检查。
- en: In addition, we also use our reference to the MQTT client class to send a message
    to the MQTT broker with the updated club room status, here as either an ASCII
    1 or 0\. This message can be used to trigger other systems, which could update
    an online status for the club room, or be put to even more creative uses.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还使用我们参考的 MQTT 客户端类将更新后的俱乐部房间状态的消息发送到 MQTT 代理，这里为 ASCII 1 或 0。这条消息可以用来触发其他系统，这些系统可以更新俱乐部房间的在线状态，或者用于更富有创意的应用。
- en: Naturally, the exact payload of the message could be made configurable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，消息的确切负载可以设置为可配置的。
- en: 'In the next section, we will update the colors on the status light, taking
    into account the state of power in the room. For this, we use the following table:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更新状态灯的颜色，考虑到房间中的电源状态。为此，我们使用以下表格：
- en: '| **Color** | **Status switch** | **Lock switch** | **Power status** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | **状态切换** | **锁定切换** | **电源状态** |'
- en: '| Green | On | Unlocked | On |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 绿色 | 开启 | 未锁定 | 开启 |'
- en: '| Yellow | Off | Unlocked | Off |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 黄色 | 关闭 | 未锁定 | 关闭 |'
- en: '| Red | Off | Locked | Off |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | 关闭 | 锁定 | 关闭 |'
- en: '| Yellow and red | On | Locked | On |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 黄色和红色 | 开启 | 锁定 | 开启 |'
- en: 'Here is the implementation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现的示例：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We first check the state of the club room power, which tells us what value to
    use for the first bit of the output register. If the power timer is active, we
    have to invert the power state, as we want to write the current power state, not
    the future state that is stored in the power state Boolean.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查俱乐部房间电源的状态，这告诉我们应该使用输出寄存器的第一个位值。如果电源定时器处于活动状态，我们必须反转电源状态，因为我们想写入当前的电源状态，而不是存储在电源状态布尔值中的未来状态。
- en: If the club room's status switch is in the off position, then the state of the
    lock switch determines the final color. With the club room locked, we trigger
    the red relay, otherwise we trigger the yellow one. The latter would indicate
    the intermediate state, where the club room is off but not yet locked.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果俱乐部房间的状态开关处于关闭位置，那么锁定开关的状态将决定最终的颜色。当俱乐部房间被锁定时，我们触发红色继电器，否则触发黄色继电器。后者表示中间状态，即俱乐部房间关闭但尚未锁定。
- en: 'The use of a mutex here is to ensure that the writing of the I2C device''s
    output register—as well as updating the local register variable—is done in a synchronized
    manner:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用互斥锁是为了确保以同步方式写入 I2C 设备的输出寄存器以及更新本地寄存器变量：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the club room's status switch is set to on, we get two other color options,
    with green being the usual one, which sees both the club room unlocked and the
    status switch enabled. If, however, the latter is on but the room is locked, we
    would get yellow and red.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果俱乐部房间的状态开关设置为开启，我们将得到另外两种颜色选择，绿色通常是其中之一，它表示俱乐部房间未锁定且状态开关已启用。然而，如果后者开启但房间被锁定，我们将得到黄色和红色。
- en: 'After finishing the new contents of the output register, we always use the
    `writeRelayOutputs()` function to write our local version to the remote device,
    thus triggering the new relay state:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成输出寄存器的新内容后，我们始终使用 `writeRelayOutputs()` 函数将我们的本地版本写入远程设备，从而触发新的继电器状态：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function is very simple, and uses WiringPi''s I2C API to write a single
    8-bit value to the connected device''s output register. We also log the written
    value here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数非常简单，并使用 WiringPi 的 I2C API 将单个 8 位值写入连接设备的输出寄存器。我们还在这里记录写入的值：
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this function, we set the club room power state to whatever value its Boolean
    variable contains. We use the same mutex as we used when updating the club room
    status colors. However, we do not create the contents of the output register from
    scratch here, instead opting to toggle the first bit in its variable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们将俱乐部房间的电源状态设置为布尔变量包含的任何值。我们使用与更新俱乐部房间状态颜色时相同的互斥锁。然而，我们在这里不是从头开始创建输出寄存器的内容，而是选择切换其变量的第一个位。
- en: After toggling this bit, we write to the remote device as usual, which will
    cause the power in the club room to toggle state.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换此位后，我们像往常一样写入远程设备，这将导致俱乐部房间的电源状态切换。
- en: 'Next, we look at the static `Club` class, starting with the first function
    we call to initialize it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看静态 `Club` 类，从我们调用的第一个初始化函数开始：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this function, we start the entire club monitoring system, as we saw earlier
    in the application entry point. It accepts a few parameters, allowing us to turn
    the relay functionality on or off, the relay's I2C address (if using a relay),
    and the MQTT topic on which to publish changes to the club room status.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，我们启动整个俱乐部监控系统，正如我们在应用程序入口点之前所看到的。它接受一些参数，允许我们打开或关闭继电器功能，继电器的 I2C 地址（如果使用继电器），以及用于发布俱乐部房间状态变化的
    MQTT 主题。
- en: After setting the values for member variables using those parameters, we initialize
    the WiringPi framework. There are a number of different initialization functions
    offered by WiringPi, which basically differ in how one can access the GPIO pins.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些参数设置成员变量的值后，我们初始化 WiringPi 框架。WiringPi 提供了多种不同的初始化函数，这些函数基本上在如何访问 GPIO 引脚方面有所不同。
- en: The `wiringPiSetup()` function we use here is generally the most convenient
    one to use, as it will use virtual pin numbers that map to the underlying Broadcom
    SoC pins. The main advantage of the WiringPi numbering is that it remains constant
    between different revisions of the Raspberry Pi SBCs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的 `wiringPiSetup()` 函数通常是使用起来最方便的，因为它将使用虚拟引脚号，这些引脚号映射到底层的 Broadcom SoC
    引脚。WiringPi 编号的主要优势是它在不同版本的 Raspberry Pi SBC 之间保持不变。
- en: With the use of either Broadcom (BCM) numbers or the physical position of the
    pins in the header on the SBC's circuit board, we risk that this changes between
    board revisions, but the WiringPi numbering scheme can compensate for this.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Broadcom (BCM) 号码或 SBC 电路板上的引脚在引脚上的物理位置，我们面临的风险是这可能在板修订之间发生变化，但 WiringPi
    编号方案可以对此进行补偿。
- en: 'For our purposes, we use the following pins on the SBC:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们在 SBC 上使用以下引脚：
- en: '|  | **Lock switch** | **Status switch** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|  | **锁开关** | **状态开关** |'
- en: '| BCM | 17 | 4 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| BCM | 17 | 4 |'
- en: '| Physical position | 11 | 7 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 物理位置 | 11 | 7 |'
- en: '| WiringPi | 0 | 7 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| WiringPi | 0 | 7 |'
- en: After initializing the WiringPi library, we set the desired pin mode, making
    both of our pins into inputs. We then enable a pull-down on each of these pins.
    This enables a built-in pull-down resistor in the SoC, which will always try to
    pull the input signal low (referenced to ground). Whether or not one needs a pull-down
    or pull-up resistor enabled for an input (or output) pin depends on the circumstances,
    especially the connected circuit.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 WiringPi 库之后，我们设置所需的引脚模式，将我们的两个引脚都设置为输入。然后我们为每个引脚启用下拉。这将在 SoC 中启用一个内置的下拉电阻，它将始终尝试将输入信号拉低（相对于地）。是否需要为输入（或输出）引脚启用下拉或上拉电阻取决于情况，特别是连接的电路。
- en: It's important to look at the behavior of the connected circuit; if the connected
    circuit has a tendency to "float" the value on the line, this would cause undesirable
    behavior on the input pin, with the value randomly changing. By pulling the line
    either low or high, we can be certain that what we read on the pin is not just
    noise.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要查看连接电路的行为；如果连接电路有使线上值“浮动”的倾向，这将在输入引脚上引起不良行为，值随机变化。通过将线路拉低或拉高，我们可以确信我们在引脚上读取的不是噪声。
- en: With the mode set on each of our pins, we read out the values on them for the
    first time, which allows us to run the update function from the `ClubUpdater`
    class with the current values in a moment. Before we do that, however, we first
    register our interrupt methods for both pins.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向 `ClubUpdate` 的 `run` 循环等待的条件变量上发出信号之前，我们先为两个引脚注册我们的中断方法。
- en: An interrupt handler is little more than a callback that gets called whenever
    the specified event occurs on the specified pin. The WiringPi ISR function accepts
    the pin number, the type of event, and a reference to the handler function we
    wish to use. For the event type we picked here, we will have our interrupt handler
    triggered every time the value on the input pin goes from high to low, or the
    other way around. This means that it will be triggered when the connected switch
    goes from on to off, or off to on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序不过是一个回调，当指定的引脚上发生指定的事件时会被调用。WiringPi ISR 函数接受引脚号、事件类型以及我们希望使用的处理程序函数的引用。对于这里选择的事件类型，我们的中断处理程序将在输入引脚的值从高变低或从低变高时被触发。这意味着当连接的开关从开启变为关闭，或从关闭变为开启时，它会被触发。
- en: 'Finally, we started the update thread by using the `ClubUpdater` class instance
    and pushing it into its own thread:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用 `ClubUpdater` 类实例并将其推入其自己的线程来启动更新线程：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling this function will allow the loop in the `run()` function of `ClubUpdater`
    to end, which will terminate the thread it runs in, allowing the rest of the application
    to safely shut down as well:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数将允许 `ClubUpdater` 的 `run()` 函数中的循环结束，这将终止它运行的线程，允许应用程序的其余部分安全关闭：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Both of our interrupt handlers are pretty simple. When the OS receives the interrupt,
    it triggers the respective handler, which results in them reading the current
    value of the input pin, inverting the value as needed. The `statusChanged` or
    `lockChanged` variable is set to true to indicate to the update function which
    of the interrupts got triggered.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个中断处理程序都非常简单。当操作系统接收到中断时，它会触发相应的中断处理程序，这会导致它们读取输入引脚的当前值，并根据需要反转该值。将 `statusChanged`
    或 `lockChanged` 变量设置为 true 以指示更新函数哪个中断被触发。
- en: We do the same for the `clubChanged` Boolean variable before signaling the condition
    variable on which the `run` loop of `ClubUpdate` is waiting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出信号之前，我们同样对 `clubChanged` 布尔变量做同样的处理。
- en: 'The last part of this class is the logging function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的最后一部分是日志函数：
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use another mutex here to synchronize the log outputs in the system log (or
    console) and to prevent concurrent access to the MQTT class when different parts
    of the application call this function simultaneously. As we will see in a moment,
    this logging function is used in other classes as well.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用另一个互斥锁来同步系统日志（或控制台）中的日志输出，并防止当应用程序的不同部分同时调用此函数时并发访问 MQTT 类。正如我们稍后将看到的，这个日志函数也被其他类使用。
- en: With this logging function, we can log both locally (system log) and remotely
    using MQTT.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个日志函数，我们可以在本地（系统日志）和远程使用 MQTT 进行日志记录。
- en: HTTP request handler
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 请求处理程序
- en: 'Whenever POCO''s HTTP server receives a new client connection, it uses a new
    instance of our `RequestHandlerFactory` class to get a handler for the specific
    request. Because it''s such a simple class, it''s fully implemented in the header:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 POCO 的 HTTP 服务器接收到一个新的客户端连接时，它都会使用我们 `RequestHandlerFactory` 类的一个新实例来获取特定请求的处理程序。因为这个类非常简单，所以它完全在头文件中实现：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our class doesn't do a whole lot more than compare the URL that the HTTP server
    was provided to determine which type of handler to instantiate and return. Here,
    we can see that if the URL string starts with `/clubstatus`, we return the status
    handler, which implements the REST API.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个类所做的不仅仅是比较 HTTP 服务器提供的 URL，以确定要实例化哪种类型的处理程序并返回。在这里，我们可以看到如果 URL 字符串以 `/clubstatus`
    开头，我们返回状态处理程序，该处理程序实现了 REST API。
- en: The default handler is a simple file server, which attempts to interpret the
    request as a filename, as we will see in a moment.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 默认处理程序是一个简单的文件服务器，它试图将请求解释为文件名，正如我们稍后将看到的。
- en: Status handler
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态处理程序
- en: This handler implements a simple REST API, returning a JSON structure containing
    the current club status. This can be used by an external application to show real-time
    information on the system, which is useful for a dashboard or website.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序实现了一个简单的 REST API，返回包含当前俱乐部状态的 JSON 结构。这可以被外部应用程序用来显示系统上的实时信息，这对于仪表板或网站来说很有用。
- en: 'Due to its simplicity, this class is also fully implemented in its header:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，这个类也完全在它的头文件中实现：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the central logger function from the `Club` class here to register details
    on incoming requests. Here, we just log the IP address of the client, but one
    could use the POCO `HTTPServerRequest` class's API to request even more detailed
    information.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `Club` 类的中央日志记录功能来记录传入请求的详细信息。在这里，我们只是记录客户端的 IP 地址，但可以使用 POCO `HTTPServerRequest`
    类的 API 请求更详细的信息。
- en: Next, the URI is obtained from the request and we split the path section of
    the URL into a vector instance. After setting the content type and a transfer
    encoding setting on the response object, we check that we did indeed get the expected
    REST API call, at which point we compose the JSON string, obtain the club room
    status information from the `Club` class, and return this.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从请求中获取 URI，并将 URL 的路径部分拆分为一个向量实例。在设置响应对象的内容类型和传输编码设置后，我们检查我们确实得到了预期的 REST
    API 调用，此时我们组成 JSON 字符串，从 `Club` 类获取俱乐部房间状态信息，并返回这个信息。
- en: In the JSON object, we include information about the club room's status in general,
    inverting its Boolean variable, as well as the status of the lock and the power
    status, with a 1, indicating that the lock is closed or the power is on, respectively.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 对象中，我们包括有关俱乐部房间状态的一般信息，反转其布尔变量，以及锁的状态和电源状态，分别用 1 表示锁是关闭的或电源是开启的。
- en: If the URL path had further segments, it would be an unrecognized API call,
    which would lead us to return an HTTP 400 (Bad Request) error instead.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 URL 路径有更多段，则它是一个未识别的 API 调用，这将导致我们返回 HTTP 400（错误请求）错误。
- en: Data handler
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据处理器
- en: 'The data handler is called whenever no REST API call is recognized by the request
    handler factory. It tries to find the specified file, read it from disk, and return
    it, along with the proper HTTP headers. This class is also implemented in its
    header:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理器在请求处理器工厂未识别任何 REST API 调用时被调用。它尝试找到指定的文件，从磁盘读取它，并返回它，同时附带适当的 HTTP 标头。这个类也完全在它的头文件中实现：
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We make the assumption here that any files to be served can be found in a subfolder
    of the folder in which this service is running. The filename (and path) is obtained
    from the request URL. If the path was empty, we assign it a default index file
    to be served instead:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里假设要服务的任何文件都可以在这个服务运行的文件夹的子文件夹中找到。文件名（和路径）是从请求 URL 获取的。如果路径为空，我们分配一个默认的索引文件来提供服务：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We first check that the resulting file path is valid and that it is a regular
    file, not a directory. If this check fails, we return an HTTP 404 File Not Found
    error.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查生成的文件路径是否有效，并且它是一个常规文件，而不是一个目录。如果这个检查失败，我们返回 HTTP 404 文件未找到错误。
- en: 'After passing this check, we try to obtain the file extension from the file
    path to try and determine a specific MIME type for the file. If this fails, we
    use a default MIME type for plain text:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个检查后，我们尝试从文件路径中获取文件扩展名，以尝试确定文件的特定 MIME 类型。如果失败，我们使用默认的 MIME 类型用于纯文本：
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As the final step, we use the response object's `sendFile()` method to send
    the file to the client, along with the MIME type we determined earlier.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们使用响应对象的 `sendFile()` 方法将文件发送到客户端，以及我们之前确定的 MIME 类型。
- en: We also handle the two exceptions this method can throw. The first one occurs
    when the file cannot be found for some reason. This results in us returning another
    HTTP 404 error.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还处理这个方法可能抛出的两个异常。第一个异常发生在由于某种原因找不到文件时。这导致我们返回另一个 HTTP 404 错误。
- en: If the file cannot be opened for some reason, we return an HTTP 500 Internal
    Server Error instead, along with the text from the exception.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因无法打开文件，我们返回 HTTP 500 内部服务器错误，并附带异常文本。
- en: Service configuration
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务配置
- en: 'With the Raspbian Linux distribution for Raspberry Pi SBCs, system services
    are usually managed with `systemd`. This uses a simple configuration file, with
    our club monitoring service using something like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Raspberry Pi SBC 的 Raspbian Linux 发行版，系统服务通常使用 `systemd` 管理。这使用一个简单的配置文件，我们的俱乐部监控服务使用类似以下的内容：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This service configuration specifies the name of the service, with the service
    being started from the "`user`" user account's folder, and the configuration file
    for the service being found in the same folder. We set the working directory for
    the service, also enabling the automatic restarting of the service after five
    seconds if it were to fail for whatever reason.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务配置指定了服务的名称，服务从"`user`"用户账户的文件夹启动，服务的配置文件位于同一文件夹中。我们设置了服务的当前工作目录，并启用服务在五秒后自动重启，以防因任何原因失败。
- en: Finally, the service will be started after the system has started to the point
    where a user can log in to the system. This way, we are sure that networking and
    other functionality has been started already. If one starts a system service too
    soon, it could fail due to missing functionality on account of things not having
    been initialized yet.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在系统启动到用户可以登录系统的程度后，服务将被启动。这样，我们就可以确保网络和其他功能已经启动。如果过早地启动系统服务，可能会因为尚未初始化而导致的功能缺失而失败。
- en: 'Next, here is the INI file configuration file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是INI文件配置文件：
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The configuration file is divided into three sections, MQTT, HTTP, and Relay,
    with each section containing the relevant variables.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件分为三个部分，MQTT、HTTP和继电器，每个部分包含相关的变量。
- en: For MQTT, we have the expected options for connecting to the MQTT broker, including
    password-based authentication. We also specify the topic regarding which club
    status updates will be published here.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MQTT，我们提供了连接到MQTT代理的预期选项，包括基于密码的认证。我们还指定了将在此发布俱乐部状态更新的主题。
- en: The HTTP section just contains the port we will be listening on, with the server
    listening on all interfaces by default. If necessary, one could make the network
    interface a used configurable as well by making this property configurable before
    starting the HTTP server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP部分仅包含我们将要监听的端口，默认情况下服务器监听所有接口。如果需要，可以在启动HTTP服务器之前将此属性设置为可配置的，从而使网络接口也成为可配置的。
- en: Finally, the Relay section allows us to turn the relay board feature on or off,
    as well as configure the I2C device address if we are making use of this feature.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继电器部分允许我们打开或关闭继电器板功能，如果使用此功能，还可以配置I2C设备地址。
- en: Permissions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限
- en: 'Since both the GPIO and I2C are treated as common Linux devices, they come
    with their own set of permissions. Assuming one wishes to avoid running the service
    as root, we need to add an account that runs the service to both the `gpio` and
    `i2c` user groups:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GPIO和I2C都被视为常见的Linux设备，它们都有自己的权限集。假设某人希望避免以root用户运行服务，我们需要在`gpio`和`i2c`用户组中添加一个运行服务的账户：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After this, we need to restart the system (or log out and in again) for the
    changes to take effect. We should now be able to run the service without any issues.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要重新启动系统（或注销并重新登录）以使更改生效。现在我们应该能够无任何问题地运行服务。
- en: Final results
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终结果
- en: With the application and `systemd` service configured and installed on the target
    SBC, it will automatically start and configure itself. To complete the system,
    you could install it along with a suitable power supply into an enclosure, into
    which you would run the signal wires from the switches, the network cable, and
    so on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标SBC上配置和安装了应用程序和`systemd`服务后，它将自动启动并配置自身。为了完成系统，你可以将它与合适的电源一起安装到机箱中，并将开关、网络电缆等信号线连接到机箱中。
- en: 'One implementation of this system was installed at the Entropia hackerspace
    in Karlsruhe, Germany. This setup uses a real traffic light (legally obtained)
    outside the club door with 12 volt LED lights for status indication. The SBC,
    relay board, debounce board, and power supply (5V and 12V MeanWell industrial
    PSU) are all integrated into a single, laser-cut wooden enclosure:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的这一实现已安装在德国卡尔斯鲁厄的Entropia黑客空间。此配置使用了一个真正的交通灯（合法获得）在俱乐部门外，带有12伏LED灯用于状态指示。SBC、继电器板、消抖板和电源（5V和12V
    MeanWell工业电源）都集成在一个单独的激光切割木制机箱中：
- en: '![](img/fdcc5ed3-6f1c-4c43-a51e-d14a36225368.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdcc5ed3-6f1c-4c43-a51e-d14a36225368.png)'
- en: However, you are free to integrate the components any way you wish. The main
    thing to consider here is that the electronics are all safely protected from harm
    and accidental contact as the relay board could be switching mains voltage, along
    with possibly the mains voltage line for the power supply.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以自由地以任何你希望的方式集成组件。这里要考虑的主要是电子设备必须得到安全保护，避免受到损害和意外接触，因为继电器板可能会切换主电压，以及可能为电源提供的主电压线路。
- en: Example – basic media player
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 基本媒体播放器
- en: Another basic example of an SBC-based embedded system is a media player. This
    can involve both audio and audio-visual (AV) media formats. The difference between
    an SBC-based system being used to play back media with regular keyboard and mouse
    input, and an embedded SBC-based media player, is that in the latter's case the
    system can only ever be used for that purpose, with the software and user interface
    (physical- and software-wise) both optimized for media player use.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基于SBC的嵌入式系统的基本示例是媒体播放器。这可能涉及音频和音频-视频（AV）媒体格式。使用常规键盘和鼠标输入播放媒体时基于SBC的系统与嵌入式SBC媒体播放器之间的区别在于，在后者的情况下，系统只能用于该目的，软件和用户界面（物理和软件方面）都针对媒体播放器使用进行了优化。
- en: To this end, a software-based frontend has to be developed, along with a physical
    interface peripheral, using which the media player can be controlled. This could
    be something as simple as a series of switches connected to the GPIO pins, with
    a regular HDMI display for output. Alternatively, one could use a touch screen,
    although this would require a more complex driver setup.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，必须开发一个基于软件的前端界面，以及一个物理接口外围设备，通过它媒体播放器可以被控制。这可能只是一系列连接到GPIO引脚的开关，以及一个常规的HDMI显示器用于输出。或者，也可以使用触摸屏，尽管这需要更复杂的驱动程序设置。
- en: Since our media player system stores media files locally, we want to use an
    SBC that supports external storage beyond the SD card. Some SBCs come with a SATA
    connection, allowing us to connect a hard disk drive (HDD) of capacities far exceeding
    those of SD cards. Even if we stick to compact 2.5" HDDs, which are roughly the
    same size as many popular SBCs, we can easily and fairly cheaply get multiple
    terabytes worth of storage.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的媒体播放器系统存储媒体文件是本地的，我们希望使用支持SD卡之外的外部存储的SBC。一些SBC带有SATA连接，允许我们连接容量远超过SD卡的硬盘驱动器（HDD）。即使我们坚持使用与许多流行的SBC大小相似的紧凑型2.5"
    HDD，我们也可以轻松且相对便宜地获得数TB的存储空间。
- en: Beyond the storage requirement, we also need to have a digital video output,
    and we want to either use the GPIO or the USB side for the user interface buttons.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储需求之外，我们还需要一个数字视频输出，我们希望使用GPIO或USB侧的用户界面按钮。
- en: 'A very suitable board for this purpose is the LeMaker Banana Pro, which comes
    with the H3 ARM SoC, hardware SATA, and Gigabit Ethernet support, as well as a
    full-sized HDMI output with 4k video decoding support:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个目的，一个非常适合的板是LeMaker Banana Pro，它配备了H3 ARM SoC、硬件SATA、千兆以太网支持，以及带有4k视频解码支持的完整尺寸HDMI输出：
- en: '![](img/74a1aea9-04a3-4e25-9ac3-f4bc3020306d.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74a1aea9-04a3-4e25-9ac3-f4bc3020306d.png)'
- en: After going through the basics of installing Armbian or similar OSes on the
    SBC, we can set up a media player application on the system, having it start together
    with the OS and configuring it to both load a playlist and to listen to events
    on a number of GPIO pins. These GPIO pins would be connected to a number of control
    switches, allowing us to scroll through the playlist and start, pause, and stop
    playlist items.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了在SBC上安装Armbian或类似操作系统的基础知识之后，我们可以在系统上设置媒体播放器应用程序，使其与操作系统一起启动，并配置它加载播放列表并监听多个GPIO引脚上的事件。这些GPIO引脚将连接到多个控制开关，使我们能够浏览播放列表并开始、暂停和停止播放列表项目。
- en: Other interaction methods are possible, such as an infrared or radio-based remote
    control, each of which come with their own advantages and disadvantages.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 其他交互方法也是可能的，例如红外或基于无线电的遥控器，每种方法都有其自身的优缺点。
- en: 'We will be working through the creation of this media player system and turning
    it into an infotainment system in the following chapters:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过创建这个媒体播放器系统并将其转变为信息娱乐系统：
- en: '[Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)，*基于OS的应用程序测试*'
- en: '[Chapter 8](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Linux-Based
    Infotainment System*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)，*示例 - 基于Linux的信息娱乐系统*'
- en: '[Chapter 11](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml), *Developing Embedded
    Systems with Qt*'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml)，*使用Qt开发嵌入式系统*'
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at OS-based embedded systems, exploring the many
    operating systems available to us, with the most significant differences, especially
    those of real-time operating systems. We also saw how one would integrate an RTC
    peripheral into an SBC-based Linux system and explored user space- and kernel
    space-based driver modules, along with their advantages and disadvantages.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了基于操作系统的嵌入式系统，研究了我们可用的许多操作系统，特别是实时操作系统的显著差异。我们还看到了如何将RTC外围设备集成到基于SBC的Linux系统中，并探讨了基于用户空间和内核空间的驱动模块，以及它们的优缺点。
- en: Along with the example project in this chapter, the reader should now have a
    good idea of how to translate a set of requirements into a functioning OS-based
    embedded system. The reader will know how to add external peripherals and use
    them from the OS.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 结合本章中的示例项目，读者现在应该对如何将一组需求转化为基于操作系统的嵌入式系统有了很好的了解。读者将知道如何添加外部外围设备并从操作系统中使用它们。
- en: In the next chapter, we will be looking at developing for resource-restricted
    embedded systems, including 8-bit MCUs and their larger brethren.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨为资源受限的嵌入式系统进行开发，包括8位微控制器及其更大的同族成员。
