["```cpp\ntemplate <typename T>\n```", "```cpp\nT add(T const a, T const b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\nadd(42, 1);       // [1]\n```", "```cpp\nadd(42.0, 1.0);   // [2]\n```", "```cpp\nadd(\"42\"s, \"1\"s); // [3]\n```", "```cpp\nadd(\"42\", \"1\");   // [4] error: cannot add two pointers\n```", "```cpp\ntemplate <typename T,\n```", "```cpp\n   typename = typename std::enable_if_t\n```", "```cpp\n      <std::is_arithmetic_v<T>>>\n```", "```cpp\nT add(T const a, T const b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\n    error C2672: 'add': no matching overloaded function found\n    error C2783: 'T add(const T,const T)': could not deduce template argument for '<unnamed-symbol>'\n    ```", "```cpp\n    prog.cc: In function 'int main()':\n    prog.cc:15:8: error: no matching function for call to 'add(std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>)'\n    15 |     add(\"42\"s, \"1\"s);\n          |     ~~~^~~~~~~~~~~~~\n    prog.cc:6:6: note: candidate: 'template<class T, class> T add(T, T)'\n        6 |    T add(T const a, T const b)\n          |      ^~~\n    prog.cc:6:6: note:   template argument deduction/substitution failed:\n    In file included from /opt/wandbox/gcc-head/include/c++/12.0.0/bits/move.h:57,\n                     from /opt/wandbox/gcc-head/include/c++/12.0.0/bits/nested_exception.h:40,\n    from /opt/wandbox/gcc-head/include/c++/12.0.0/exception:154,\n                     from /opt/wandbox/gcc-head/include/c++/12.0.0/ios:39,\n                     from /opt/wandbox/gcc-head/include/c++/12.0.0/ostream:38,\n                     from /opt/wandbox/gcc-head/include/c++/12.0.0/iostream:39,\n                     from prog.cc:1:\n    /opt/wandbox/gcc-head/include/c++/12.0.0/type_traits: In substitution of 'template<bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = void]':\n    prog.cc:5:14:   required from here\n    /opt/wandbox/gcc-head/include/c++/12.0.0/type_traits:2603:11: error: no type named 'type' in 'struct std::enable_if<false, void>'\n     2603 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;\n          |           ^~~~~~~~~~~\n    ```", "```cpp\n    prog.cc:15:5: error: no matching function for call to 'add'\n        add(\"42\"s, \"1\"s);\n        ^~~\n    prog.cc:6:6: note: candidate template ignored: requirement 'std::is_arithmetic_v<std::string>' was not satisfied [with T = std::string]\n       T add(T const a, T const b)\n         ^\n    ```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT add(T const a, T const b)\n```", "```cpp\n{\n```", "```cpp\n   static_assert(std::is_arithmetic_v<T>, \n```", "```cpp\n                 \"Arithmetic type required\");\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\n    error C2338: Arithmetic type required\n    main.cpp(157): message : see reference to function template instantiation 'T add<std::string>(const T,const T)' being compiled\n         with\n         [\n             T=std::string\n         ]\n    ```", "```cpp\n    prog.cc: In instantiation of 'T add(T, T) [with T = std::__cxx11::basic_string<char>]':\n    prog.cc:15:8:   required from here\n    prog.cc:7:24: error: static assertion failed: Arithmetic type required\n        7 |     static_assert(std::is_arithmetic_v<T>, \"Arithmetic type required\");\n          |                   ~~~~~^~~~~~~~~~~~~~~~~~\n    prog.cc:7:24: note: 'std::is_arithmetic_v<std::__cxx11::basic_string<char> >' evaluates to false\n    ```", "```cpp\n    prog.cc:7:5: error: static_assert failed due to requirement 'std::is_arithmetic_v<std::string>' \"Arithmetic type required\"\n        static_assert(std::is_arithmetic_v<T>, \"Arithmetic type required\");\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~\n    prog.cc:15:5: note: in instantiation of function template specialization 'add<std::string>' requested here\n        add(\"42\"s, \"1\"s);\n        ^\n    ```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_arithmetic_v<T>\n```", "```cpp\nT add(T const a, T const b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>      \n```", "```cpp\nT add(T const a, T const b)\n```", "```cpp\nrequires std::is_arithmetic_v<T>\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\n    error C2672: 'add': no matching overloaded function found\n    error C7602: 'add': the associated constraints are not satisfied\n    ```", "```cpp\n    prog.cc: In function 'int main()':\n    prog.cc:15:8: error: no matching function for call to 'add(std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>)'\n       15 |     add(\"42\"s, \"1\"s);\n    |     ~~~^~~~~~~~~~~~~\n    prog.cc:6:6: note: candidate: 'template<class T>  requires  is_arithmetic_v<T> T add(T, T)'\n        6 |    T add(T const a, T const b)\n          |      ^~~\n    prog.cc:6:6: note:   template argument deduction/substitution failed:\n    prog.cc:6:6: note: constraints not satisfied\n    prog.cc: In substitution of 'template<class T>  requires  is_arithmetic_v<T> T add(T, T) [with T = std::__cxx11::basic_string<char>]':\n    prog.cc:15:8:   required from here\n    prog.cc:6:6:   required by the constraints of 'template<class T>  requires  is_arithmetic_v<T> T add(T, T)'\n    prog.cc:5:15: note: the expression 'is_arithmetic_v<T> [with T = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >]' evaluated to 'false'\n        5 | requires std::is_arithmetic_v<T>\n          |          ~~~~~^~~~~~~~~~~~~~~~~~\n    ```", "```cpp\n    prog.cc:15:5: error: no matching function for call to 'add'\n    add(\"42\"s, \"1\"s);\n        ^~~\n    prog.cc:6:6: note: candidate template ignored: constraints not satisfied [with T = std::string]\n       T add(T const a, T const b)\n         ^\n    prog.cc:5:10: note: because 'std::is_arithmetic_v<std::string>' evaluated to false\n    requires std::is_arithmetic_v<T>\n             ^\n    ```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_arithmetic_v<T>\n```", "```cpp\nT mul(T const a, T const b)\n```", "```cpp\n{\n```", "```cpp\n   return a * b;\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T>\n```", "```cpp\nconcept arithmetic = std::is_arithmetic_v<T>;\n```", "```cpp\ntemplate <arithmetic T>\n```", "```cpp\nT add(T const a, T const b) { return a + b; }\n```", "```cpp\ntemplate <arithmetic T>\n```", "```cpp\nT mul(T const a, T const b) { return a * b; }\n```", "```cpp\ntemplate<typename T>\n```", "```cpp\nconcept arithmetic = requires { std::is_arithmetic_v<T>; };\n```", "```cpp\ntemplate <typename T, typename U = void>\n```", "```cpp\nstruct is_container : std::false_type {};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct is_container<T,\n```", "```cpp\n   std::void_t<typename T::value_type,\n```", "```cpp\n               typename T::size_type,\n```", "```cpp\n               typename T::allocator_type,\n```", "```cpp\n               typename T::iterator,\n```", "```cpp\n               typename T::const_iterator,\n```", "```cpp\n               decltype(std::declval<T>().size()),\n```", "```cpp\n               decltype(std::declval<T>().begin()),\n```", "```cpp\n               decltype(std::declval<T>().end()),\n```", "```cpp\n               decltype(std::declval<T>().cbegin()),\n```", "```cpp\n               decltype(std::declval<T>().cend())>> \n```", "```cpp\n   : std::true_type{};\n```", "```cpp\ntemplate <typename T, typename U = void>\n```", "```cpp\nconstexpr bool is_container_v = is_container<T, U>::value;\n```", "```cpp\nstruct foo {};\n```", "```cpp\nstatic_assert(!is_container_v<foo>);\n```", "```cpp\nstatic_assert(is_container_v<std::vector<foo>>);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept container = requires(T t)\n```", "```cpp\n{\n```", "```cpp\n   typename T::value_type;\n```", "```cpp\n   typename T::size_type;\n```", "```cpp\n   typename T::allocator_type;\n```", "```cpp\n   typename T::iterator;\n```", "```cpp\n   typename T::const_iterator;\n```", "```cpp\n   t.size();\n```", "```cpp\n   t.begin();\n```", "```cpp\n   t.end();\n```", "```cpp\n   t.cbegin();\n```", "```cpp\n   t.cend();\n```", "```cpp\n};\n```", "```cpp\nstruct foo{};\n```", "```cpp\nstatic_assert(!container<foo>);\n```", "```cpp\nstatic_assert(container<std::vector<foo>>);\n```", "```cpp\ntemplate <container C>\n```", "```cpp\nvoid process(C&& c) {}\n```", "```cpp\nrequires (parameter-list) { requirement-seq }\n```", "```cpp\ntemplate<typename T>\n```", "```cpp\nconcept arithmetic = requires \n```", "```cpp\n{\n```", "```cpp\n   std::is_arithmetic_v<T>; \n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept addable = requires(T a, T b) \n```", "```cpp\n{ \n```", "```cpp\n   a + b; \n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept logger = requires(T t)\n```", "```cpp\n{\n```", "```cpp\n   t.error(\"just\");\n```", "```cpp\n   t.warning(\"a\");\n```", "```cpp\n   t.info(\"demo\");\n```", "```cpp\n};\n```", "```cpp\ntemplate <logger T>\n```", "```cpp\nvoid log_error(T& logger)\n```", "```cpp\n{}\n```", "```cpp\nstruct console_logger\n```", "```cpp\n{\n```", "```cpp\n   void error(std::string_view text){}\n```", "```cpp\n   void warning(std::string_view text) {}\n```", "```cpp\n   void info(std::string_view text) {}\n```", "```cpp\n};\n```", "```cpp\nstruct stream_logger\n```", "```cpp\n{\n```", "```cpp\n   void error(std::string_view text, bool = false) {}\n```", "```cpp\n   void warning(std::string_view text, bool = false) {}\n```", "```cpp\n   void info(std::string_view text, bool) {}\n```", "```cpp\n};\n```", "```cpp\nconsole_logger cl;\n```", "```cpp\nlog_error(cl);      // OK\n```", "```cpp\nstream_logger sl;\n```", "```cpp\nlog_error(sl);      // error\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept KVP = requires \n```", "```cpp\n{\n```", "```cpp\n   typename T::key_type;\n```", "```cpp\n   typename T::value_type;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T, typename V>\n```", "```cpp\nstruct key_value_pair\n```", "```cpp\n{\n```", "```cpp\n   using key_type = T;\n```", "```cpp\n   using value_type = V;\n```", "```cpp\n   key_type    key;\n```", "```cpp\n   value_type  value;\n```", "```cpp\n};\n```", "```cpp\nstatic_assert(KVP<key_value_pair<int, std::string>>);\n```", "```cpp\nstatic_assert(!KVP<std::pair<int, std::string>>);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_arithmetic_v<T>\n```", "```cpp\nstruct container\n```", "```cpp\n{ /* ... */ };\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept containerizeable = requires {\n```", "```cpp\n   typename container<T>;\n```", "```cpp\n};\n```", "```cpp\nstatic_assert(containerizeable<int>);\n```", "```cpp\nstatic_assert(!containerizeable<std::string>);\n```", "```cpp\n{ expression } noexcept -> type_constraint;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid f(T) noexcept {}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid g(T) {}\n```", "```cpp\ntemplate <typename F, typename ... T>\n```", "```cpp\nconcept NonThrowing = requires(F && func, T ... t)\n```", "```cpp\n{\n```", "```cpp\n   {func(t...)} noexcept;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename F, typename ... T>\n```", "```cpp\n   requires NonThrowing<F, T...>\n```", "```cpp\nvoid invoke(F&& func, T... t)\n```", "```cpp\n{\n```", "```cpp\n   func(t...);\n```", "```cpp\n}\n```", "```cpp\ninvoke(f<int>, 42);\n```", "```cpp\ninvoke(g<int>, 42); // error\n```", "```cpp\nprog.cc:28:7: error: no matching function for call to 'invoke'\n      invoke(g<int>, 42);\n      ^~~~~~\nprog.cc:18:9: note: candidate template ignored: constraints not satisfied [with F = void (&)(int), T = <int>]\n   void invoke(F&& func, T... t)\n        ^\nprog.cc:17:16: note: because 'NonThrowing<void (&)(int), int>' evaluated to false\n      requires NonThrowing<F, T...>\n               ^\nprog.cc:13:20: note: because 'func(t)' may throw an exception\n      {func(t...)} noexcept;\n                   ^\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept timer = requires(T t)\n```", "```cpp\n{\n```", "```cpp\n   {t.start()} -> std::same_as<void>;\n```", "```cpp\n   {t.stop()}  -> std::convertible_to<long long>;\n```", "```cpp\n};\n```", "```cpp\nstruct timerA\n```", "```cpp\n{\n```", "```cpp\n   void start() {}\n```", "```cpp\n   long long stop() { return 0; }\n```", "```cpp\n};\n```", "```cpp\nstruct timerB\n```", "```cpp\n{\n```", "```cpp\n   void start() {}\n```", "```cpp\n   int stop() { return 0; }\n```", "```cpp\n};\n```", "```cpp\nstruct timerC\n```", "```cpp\n{\n```", "```cpp\n   void start() {}\n```", "```cpp\n   void stop() {}\n```", "```cpp\n   long long getTicks() { return 0; }\n```", "```cpp\n};\n```", "```cpp\nstatic_assert(timer<timerA>);\n```", "```cpp\nstatic_assert(timer<timerB>);\n```", "```cpp\nstatic_assert(!timer<timerC>);\n```", "```cpp\nrequires constraint-expression;\n```", "```cpp\ntemplate<typename T, typename... Ts>\n```", "```cpp\ninline constexpr bool are_same_v = \n```", "```cpp\n   std::conjunction_v<std::is_same<T, Ts>...>;\n```", "```cpp\ntemplate <typename ... T>\n```", "```cpp\nconcept HomogenousRange = requires(T... t)\n```", "```cpp\n{\n```", "```cpp\n   (... + t);\n```", "```cpp\n   requires are_same_v<T...>;\n```", "```cpp\n   requires sizeof...(T) > 1;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename ... T>\n```", "```cpp\nrequires HomogenousRange<T...>\n```", "```cpp\nauto add(T&&... t)\n```", "```cpp\n{\n```", "```cpp\n   return (... + t);\n```", "```cpp\n}\n```", "```cpp\nadd(1, 2);   // OK\n```", "```cpp\nadd(1, 2.0); // error, types not the same\n```", "```cpp\nadd(1);      // error, size not greater than 1\n```", "```cpp\nstatic_assert(HomogenousRange<int, int>);\n```", "```cpp\nstatic_assert(!HomogenousRange<int>);\n```", "```cpp\nstatic_assert(!HomogenousRange<int, double>);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_integral_v<T> && std::is_signed_v<T>\n```", "```cpp\nT decrement(T value) \n```", "```cpp\n{\n```", "```cpp\n   return value--;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept Integral = std::is_integral_v<T>;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept Signed = std::is_signed_v<T>;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept SignedIntegral = Integral<T> && Signed<T>;\n```", "```cpp\ntemplate <SignedIngeral T>      \n```", "```cpp\nT decrement(T value)\n```", "```cpp\n{\n```", "```cpp\n   return value--;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_integral_v<T> || std::is_floating_point_v<T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept Integral = std::is_integral_v<T>;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept FloatingPoint = std::is_floating_point_v<T>;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept Number = Integral<T> || FloatingPoint<T>;\n```", "```cpp\ntemplate <Number T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires A<T> || B<T>\n```", "```cpp\nvoid f() {}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires (A<T> || B<T>)\n```", "```cpp\nvoid f() {}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires A<T> && (!A<T> || B<T>)\n```", "```cpp\nvoid f() {}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires (!(A<T> || B<T>))\n```", "```cpp\nvoid f() {}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires (static_cast<bool>(A<T> || B<T>))\n```", "```cpp\nvoid f() {}\n```", "```cpp\ntemplate <typename ... T>\n```", "```cpp\nrequires std::is_integral_v<T> && ...\n```", "```cpp\nauto add(T ... args)\n```", "```cpp\n{\n```", "```cpp\n   return (args + ...);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename ... T>\n```", "```cpp\nrequires (std::is_integral_v<T> && ...)\n```", "```cpp\nauto add(T ... args)\n```", "```cpp\n{\n```", "```cpp\n   return (args + ...);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept Integral = std::is_integral_v<T>;\n```", "```cpp\ntemplate <typename ... T>\n```", "```cpp\nrequires (Integral<T> && ...)\n```", "```cpp\nauto add(T ... args)\n```", "```cpp\n{\n```", "```cpp\n   return (args + ...);\n```", "```cpp\n}\n```", "```cpp\nint add(int a, int b) \n```", "```cpp\n{\n```", "```cpp\n   return a + b; \n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\nadd(1.0, 2.0);  // [1]\n```", "```cpp\nadd(1, 2);      // [2]\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_integral_v<T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires (sizeof(T) == 4)\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_integral_v<T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\nadd((short)1, (short)2);  // [1]\n```", "```cpp\nadd(1, 2);                // [2]\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_integral_v<T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::is_integral_v<T> && (sizeof(T) == 4)\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept Integral = std::is_integral_v<T>;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires Integral<T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires Integral<T> && (sizeof(T) == 4)\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <Integral T>\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <Integral T>\n```", "```cpp\nrequires (sizeof(T) == 4)\n```", "```cpp\nT add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n   bool operator==(std::string_view str)\n```", "```cpp\n   requires std::is_convertible_v<T, std::string_view>\n```", "```cpp\n   {\n```", "```cpp\n      return value == str;\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nwrapper<int>         a{ 42 };\n```", "```cpp\nwrapper<char const*> b{ \"42\" };\n```", "```cpp\nif(a == 42)   {} // error\n```", "```cpp\nif(b == \"42\") {} // OK\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n    T value;\n```", "```cpp\n    wrapper(T const & v) :value(v) {}\n```", "```cpp\n};\n```", "```cpp\nwrapper<int> a = 42;            //OK\n```", "```cpp\nwrapper<std::unique_ptr<int>> p = \n```", "```cpp\n   std::make_unique<int>(42);   //error\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n   template <typename U,\n```", "```cpp\n             typename = std::enable_if_t<\n```", "```cpp\n                   std::is_copy_constructible_v<U> &&\n```", "```cpp\n                   std::is_convertible_v<U, T>>>\n```", "```cpp\n   wrapper(U const& v) :value(v) {}\n```", "```cpp\n};\n```", "```cpp\nprog.cc:19:35: error: no viable conversion from 'typename __unique_if<int>::__unique_single' (aka 'unique_ptr<int>') to 'wrapper<std::unique_ptr<int>>'\n```", "```cpp\n    wrapper<std::unique_ptr<int>> p = std::make_unique<int>(42); // error\n```", "```cpp\n                                  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n```", "```cpp\nprog.cc:6:8: note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'typename __unique_if<int>::__unique_single' (aka 'unique_ptr<int>') to 'const wrapper<std::unique_ptr<int>> &' for 1st argument\n```", "```cpp\nstruct wrapper\n```", "```cpp\n       ^\n```", "```cpp\nprog.cc:6:8: note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'typename __unique_if<int>::__unique_single' (aka 'unique_ptr<int>') to 'wrapper<std::unique_ptr<int>> &&' for 1st argument\n```", "```cpp\nstruct wrapper\n```", "```cpp\n       ^\n```", "```cpp\nprog.cc:13:9: note: candidate template ignored: requirement 'std::is_copy_constructible_v<std::unique_ptr<int, std::default_delete<int>>>' was not satisfied [with U = std::unique_ptr<int>]\n```", "```cpp\n        wrapper(U const& v) :value(v) {}\n```", "```cpp\n        ^\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n   wrapper(T const& v) \n```", "```cpp\n      requires std::is_copy_constructible_v<T> \n```", "```cpp\n      :value(v)\n```", "```cpp\n   {}\n```", "```cpp\n};\n```", "```cpp\nprog.cc:9:5: note: candidate constructor not viable: constraints not satisfied\n```", "```cpp\n    wrapper(T const& v) \n```", "```cpp\n    ^\n```", "```cpp\nprog.cc:10:18: note: because 'std::is_copy_constructible_v<std::unique_ptr<int> >' evaluated to false\n```", "```cpp\n        requires std::is_copy_constructible_v<T>\n```", "```cpp\nvoid handle(int v)\n```", "```cpp\n{ /* do something */ }\n```", "```cpp\nvoid handle(long v)\n```", "```cpp\n    requires (sizeof(long) > sizeof(int))\n```", "```cpp\n{ /* do something else */ }\n```", "```cpp\nvoid handle(long v)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (sizeof(long) > sizeof(int))\n```", "```cpp\n   {\n```", "```cpp\n      /* do something else */\n```", "```cpp\n   }\n```", "```cpp\n   else\n```", "```cpp\n   {\n```", "```cpp\n      /* do something */\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\ntemplate <std::integral T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\nwrapper<int>    a{ 42 };    // OK\n```", "```cpp\nwrapper<double> b{ 42.0 };  // error\n```", "```cpp\ntemplate <std::integral T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\ntemplate <std::integral T>\n```", "```cpp\nrequires (sizeof(T) == 4)\n```", "```cpp\nstruct wrapper<T>\n```", "```cpp\n{\n```", "```cpp\n   union\n```", "```cpp\n   {\n```", "```cpp\n      T value;\n```", "```cpp\n      struct\n```", "```cpp\n      {\n```", "```cpp\n         uint8_t byte4;\n```", "```cpp\n         uint8_t byte3;\n```", "```cpp\n         uint8_t byte2;\n```", "```cpp\n         uint8_t byte1;\n```", "```cpp\n      };\n```", "```cpp\n   };\n```", "```cpp\n};\n```", "```cpp\nwrapper<short> a{ 42 };\n```", "```cpp\nstd::cout << a.value << '\\n';\n```", "```cpp\nwrapper<int> b{ 0x11223344 };\n```", "```cpp\nstd::cout << std::hex << b.value << '\\n';\n```", "```cpp\nstd::cout << std::hex << (int)b.byte1 << '\\n';\n```", "```cpp\nstd::cout << std::hex << (int)b.byte2 << '\\n';\n```", "```cpp\nstd::cout << std::hex << (int)b.byte3 << '\\n';\n```", "```cpp\nstd::cout << std::hex << (int)b.byte4 << '\\n';\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconstexpr T PI = T(3.1415926535897932385L);\n```", "```cpp\ntemplate <std::floating_point T>\n```", "```cpp\nconstexpr T PI = T(3.1415926535897932385L);\n```", "```cpp\nstd::cout << PI<double> << '\\n';  // OK\n```", "```cpp\nstd::cout << PI<int> << '\\n';     // error\n```", "```cpp\ntemplate <std::integral T>\n```", "```cpp\nusing integral_vector = std::vector<T>;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires std::integral<T>\n```", "```cpp\nusing integral_vector = std::vector<T>;\n```", "```cpp\nintegral_vector<int>    v1 { 1,2,3 };       // OK\n```", "```cpp\nintegral_vector<double> v2 {1.0, 2.0, 3.0}; // error\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconcept addable = requires(T a, T b) { a + b; };\n```", "```cpp\n                       // [1] requires expression\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nrequires addable<T>    // [2] requires clause\n```", "```cpp\nauto add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\n   requires requires(T a, T b) { a + b; }\n```", "```cpp\nauto add(T a, T b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\nauto lsum = [](auto a, auto b) {return a + b; };\n```", "```cpp\nauto add(auto a, auto b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T, typename U>\n```", "```cpp\nauto add(T a, U b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\nadd(4, 2);   // returns 6\n```", "```cpp\nadd(4.0, 2); // returns 6.0\n```", "```cpp\ntemplate<>\n```", "```cpp\nint add<int, int>(int a, int b)\n```", "```cpp\n{\n```", "```cpp\n  return a + b;\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\ndouble add<double, int>(double a, int b)\n```", "```cpp\n{\n```", "```cpp\n  return a + static_cast<double>(b);\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nauto add(char const* a, char const* b)\n```", "```cpp\n{\n```", "```cpp\n   return std::string(a) + std::string(b);\n```", "```cpp\n}\n```", "```cpp\nauto add(std::integral auto a, std::integral auto b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\nadd(4, 2);   // OK\n```", "```cpp\nadd(4.2, 0); // error\n```", "```cpp\nauto add(std::integral auto ... args)\n```", "```cpp\n{\n```", "```cpp\n   return (args + ...);\n```", "```cpp\n}\n```", "```cpp\nauto lsum = [](std::integral auto a, std::integral auto b) \n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n};\n```", "```cpp\ntemplate < class T >\n```", "```cpp\nconcept integral = std::is_integral_v<T>;\n```", "```cpp\ntemplate < class T >\n```", "```cpp\nconcept signed_integral = std::integral<T> && \n```", "```cpp\n                          std::is_signed_v<T>;\n```", "```cpp\ntemplate <class T>\n```", "```cpp\nconcept regular = std::semiregular<T> && \n```", "```cpp\n                  std::equality_comparable<T>;\n```", "```cpp\ntemplate<typename I>\n```", "```cpp\nconcept random_access_iterator =\n```", "```cpp\n   std::bidirectional_iterator<I> &&\n```", "```cpp\n   std::derived_from</*ITER_CONCEPT*/<I>,\n```", "```cpp\n                     std::random_access_iterator_tag> &&\n```", "```cpp\n   std::totally_ordered<I> &&\n```", "```cpp\n   std::sized_sentinel_for<I, I> &&\n```", "```cpp\n   requires(I i, \n```", "```cpp\n            const I j, \n```", "```cpp\n            const std::iter_difference_t<I> n)\n```", "```cpp\n   {\n```", "```cpp\n      { i += n } -> std::same_as<I&>;\n```", "```cpp\n      { j +  n } -> std::same_as<I>;\n```", "```cpp\n      { n +  j } -> std::same_as<I>;\n```", "```cpp\n      { i -= n } -> std::same_as<I&>;\n```", "```cpp\n      { j -  n } -> std::same_as<I>;\n```", "```cpp\n      {  j[n]  } -> std::same_as<std::iter_reference_t<I>>;\n```", "```cpp\n   };\n```", "```cpp\ntemplate< class T >\n```", "```cpp\nconcept range = requires( T& t ) {\n```", "```cpp\n   ranges::begin(t);\n```", "```cpp\n   ranges::end  (t);\n```", "```cpp\n};\n```", "```cpp\ntemplate< class T >\n```", "```cpp\nconcept sized_range = ranges::range<T> &&\n```", "```cpp\n   requires(T& t) {\n```", "```cpp\n      ranges::size(t);\n```", "```cpp\n   };\n```", "```cpp\ntemplate< class T >\n```", "```cpp\nconcept input_range = ranges::range<T> && \n```", "```cpp\n   std::input_iterator<ranges::iterator_t<T>>;\n```"]