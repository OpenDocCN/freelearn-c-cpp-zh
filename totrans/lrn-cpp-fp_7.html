<html><head></head><body>
        

                            
                    <h1 class="header-title">Running Parallel Execution Using Concurrency</h1>
                
            
            
                
<p>In the previous chapter, we discussed template metaprogramming that will make a code in compile-time execution. It will also improve the flow control of our code since we can refactor the flow using the template. Now, in this chapter, we will talk about concurrency in C++, where we have to control the flow again when we run two or more processes simultaneously. In this chapter, we will discuss the following topics:</p>
<ul>
<li>Running single as well as multiple threads in C++ programming</li>
<li>Synchronizing the thread to avoid a deadlock</li>
<li>Using the <strong>handle</strong> resource in Windows to create a thread</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Concurrency in C++</h1>
                
            
            
                
<p>Many programming languages have provided support for concurrency today. Instead of sequentially, the computation of the code is executed during overlapping time periods in concurrent programming. It will make our program responsive since the code doesn't need to wait until all computation is finished. Let's suppose we want to develop a program that can play a video and download a huge video file at the same time. Without the concurrency technique, we have to wait for the video to be downloaded successfully before we can play another video file. By using this technique, we can split these two tasks, playing and downloading a video, then run them together concurrently.</p>
<p>Before C++11 was announced, the C++ programmer depended on <kbd>Boost::thread</kbd> to create a concurrent program using the multithreading technique. In multithreading, we split up the process into the smallest sequence and run these small processes concurrently. Now, in the C++11 library, we get the <kbd>thread</kbd> class to address our need for concurrency using the multithreading technique.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Processing a single threading code</h1>
                
            
            
                
<p>To use the <kbd>thread</kbd> class, we just need to create an instance of <kbd>std::thread</kbd> and pass the function name as the argument. We then call <kbd>std::join()</kbd> to pause the process until the selected thread finishes its process. Let's take a look at the following <kbd>singlethread.cpp</kbd> code:</p>
<pre>
    /* singlethread.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    void threadProc()<br/>    {<br/>      cout &lt;&lt; "Thread ID: ";<br/>      cout &lt;&lt; this_thread::get_id() &lt;&lt; endl;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[singlethread.cpp]" &lt;&lt; endl;<br/> <br/>      thread thread1(threadProc);<br/>      thread1.join();<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have a function named <kbd>threadProc()</kbd>, and we pass it into the <kbd>thread1</kbd> initialization in the <kbd>main()</kbd> function. After initialization, we call the <kbd>join()</kbd> method to execute the <kbd>thread1</kbd> object. The output that we will see on the console should be as follows:</p>
<div><img class=" image-border" src="img/86d5d8c0-8176-4e09-8737-4e31bd48ba43.png"/></div>
<p>We have successfully run a thread in our code. Now, let's add a piece of code in the <kbd>main()</kbd> function that will iterate a line of code. We will run them together concurrently. The code for <kbd>singlethread2.cpp</kbd> is as follows:</p>
<pre>
    /* singlethread2.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;chrono&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    void threadProc()<br/>    {<br/>      for (int i = 0; i &lt; 5; i++)<br/>      {<br/>        cout &lt;&lt; "thread: current i = ";<br/>        cout &lt;&lt; i &lt;&lt; endl;<br/>      }<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[singlethread2.cpp]" &lt;&lt; endl;<br/><br/>      thread thread1(threadProc);<br/><br/>      <strong>for (int i = 0; i &lt; 5; i++)</strong><br/><strong>      {</strong><br/><strong>        cout &lt;&lt; "main : current i = " &lt;&lt; i &lt;&lt; endl;<br/><br/>        this_thread::sleep_for(<br/>            chrono::milliseconds(5));<br/></strong><strong>      }</strong><br/><br/>      thread1.join();<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we add a <kbd>for</kbd> loop to iterate some code and to run it concurrently with <kbd>thread1</kbd>. To make sense of it, we add a <kbd>for</kbd> loop in the <kbd>threadProc()</kbd> function as well. Let's take a look at the following screenshot to figure out what output we will get:</p>
<div><img class=" image-border" src="img/8aa03435-bafd-4bef-a608-028751070653.png"/></div>
<p>We see that the <kbd>threadProc()</kbd> function and the code in the <kbd>main()</kbd> function is run together concurrently. Some of you may get a different result, but it's okay since the result cannot be predicted because it depends on the device itself. However, for now, we have been able to run two processes concurrently.</p>
<p>I ran the preceding code multiple times to get the output we see in the preceding screenshot. You might see different order in between the <kbd>threadProc()</kbd> and <kbd>main()</kbd> function or get a messy output since the flow of the thread is unpredictable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Processing a multithreading code</h1>
                
            
            
                
<p>In the multithread technique, we run two or more threads concurrently. Let's suppose we are running five threads simultaneously. We can use the following <kbd>multithread.cpp</kbd> code that will store these five threads in an array:</p>
<pre>
    /* multithread.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    void threadProc()<br/>    {<br/>      cout &lt;&lt; "Thread ID: ";<br/>      cout &lt;&lt; this_thread::get_id() &lt;&lt; endl;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[multithread.cpp]" &lt;&lt; endl;<br/> <br/>      thread threads[5];<br/><br/>      for (int i = 0; i &lt; 5; ++i)<br/>      {<br/>        <strong>threads[i] = thread(threadProc);</strong><br/>      }<br/><br/>      for (auto&amp; thread : threads)<br/>      {<br/>        thread.join();<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>After we initialize these five threads based on the preceding code, we will run the <kbd>join()</kbd> method for all threads to execute them. By using the <kbd>join()</kbd> method, the program will wait for all processes in the calling threads to be finished, then continue the next process if any. The result we see in the console is as follows:</p>
<div><img class=" image-border" src="img/808eb931-b775-4816-b4c6-e756f8d99112.png"/></div>
<p>In the preceding screenshot, we see that all five threads have been successfully executed. We can also initialize the thread using the Lambda expression. The following <kbd>lambdathread.cpp</kbd> code is refactored from the preceding code which uses Lambda instead of creating a separated function:</p>
<pre>
    /* lambdathread.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambdathread.cpp]" &lt;&lt; endl;<br/> <br/>      thread threads[5];<br/><br/>      for (int i = 0; i &lt; 5; ++i)<br/>      {<br/><strong>         threads[i] = thread([]()</strong><br/><strong>         {</strong><br/><strong>            cout &lt;&lt; "Thread ID: ";</strong><br/><strong>            cout &lt;&lt; this_thread::get_id() &lt;&lt; endl;</strong><br/><strong>         });</strong><br/>       }<br/><br/>      for (auto&amp; thread : threads)<br/>      {<br/>        thread.join();<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>There is no significant change if we see the <kbd>lambdathread.cpp</kbd> code comparing with the <kbd>multithread.cpp</kbd> code. However, since the function will only be called once, it's better to use Lambda so it is easier to maintain it. The output we will see on the console is like the following screenshot, not much different compared to the <kbd>multithread.cpp</kbd> code output:</p>
<div><img class=" image-border" src="img/533c3423-6bf0-450e-99a6-6988f42d3d61.png"/></div>
<p>Although we retrieve the same output when running <kbd>lambdathread.cpp</kbd> comparing with the <kbd>multithread.cpp</kbd> code, we have a clear code when we initialize the thread using the Lambda expression. We don't need to create another method to be passed to <kbd>Thread</kbd>, for instance, <kbd>threadProc()</kbd>, since this method is actually used only once.</p>
<p>Again, note that the result you see on your screen might be different from the screenshot I gave.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Synchronizing the threads using mutex</h1>
                
            
            
                
<p>As of now, we have successfully executed a multithreading code. However, a problem will occur if we consume a shared object and manipulate it inside the thread. It is called <strong>synchronization</strong>. In this section, we will try to avoid this problem by applying a <kbd>mutex</kbd> technique.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding synchronization issues</h1>
                
            
            
                
<p>As we discussed earlier, in this section, we have to ensure that the shared object we run in the thread gives the correct value when it is executing. Let's suppose we have a global variable named <kbd>counter</kbd> and we plan to increase its value in all the five threads we have. Each thread will execute <kbd>10000</kbd> times increment iteration, so we expect to get <kbd>50000</kbd> as a result for all five threads. The code is as follows:</p>
<pre>
    /* notsync.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[notsync.cpp]" &lt;&lt; endl;<br/> <br/>      int counter = 0;<br/> <br/>      thread threads[5];<br/><br/>      for (int i = 0; i &lt; 5; ++i)<br/>      {<br/>        threads[i] = thread([&amp;counter]()<br/>        {<br/><strong>            for (int i = 0; i &lt; 10000; ++i)</strong><br/><strong>            {</strong><br/><strong>                ++counter;</strong><br/><strong>                cout &lt;&lt; "Thread ID: ";</strong><br/><strong>                cout &lt;&lt; this_thread::get_id();</strong><br/><strong>                cout &lt;&lt; "\tCurrent Counter = ";</strong><br/><strong>                cout &lt;&lt; counter &lt;&lt; endl;</strong><br/><strong>            }</strong><br/>        });<br/>      }<br/><br/>      for (auto&amp; thread : threads)<br/>      {<br/>        thread.join();<br/>      }<br/> <br/>      cout &lt;&lt; "Final result = " &lt;&lt; counter &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>Now, let's take a look at the following screenshot we may get on the console when we run the preceding code:</p>
<div><img class=" image-border" src="img/e0d31bea-b6e2-49db-acff-172784871ce3.png"/></div>
<p>Unfortunately, based on the preceding screenshot, we don't get what we expect. This happens because an incrementation process is not an atomic operation since the atomic operation will guarantee the isolation of the concurrent process.</p>
<p>If you get a different output, don't worry, we are still on the right track as this program demonstrates synchronization issues, as you will see next.</p>
<p>If we trace the output deeper, we will see that there are two threads that execute exactly the same value for the <kbd>counter</kbd> variable, as we can see in the following screenshot:</p>
<div><img class=" image-border" src="img/8f7a5eff-9464-4f99-b4e6-3bb1f2553f25.png"/></div>
<p>We see that the thread with ID <kbd>2504</kbd> and <kbd>5524</kbd> access the counter variable when its value is <kbd>44143</kbd>. That's why we retrieve an unexpected result when we run the preceding code. Now we need to make the increment operation to become an atomic operation that will be executed without any other processes being able to read or change the state that is read or changed during the operation.</p>
<p>To solve this problem, we can use the <kbd>mutex</kbd> class to make our counter variable <kbd>thread-safe</kbd>. It means that before the thread accesses the counter variable, it has to ensure that the variable is not accessed by others threads. We can use the <kbd>lock()</kbd> and <kbd>unlock()</kbd> methods in the <kbd>mutex</kbd> class to lock and unlock the targeted variable. Let's take a look at the following <kbd>mutex.cpp</kbd> code to demonstrate <kbd>mutex</kbd> implementation:</p>
<pre>
    /* mutex.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;mutex&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[mutex.cpp]" &lt;&lt; endl;<br/> <br/>      mutex mtx;<br/>      int counter = 0;<br/> <br/>      thread threads[5];<br/><br/>      for (int i = 0; i &lt; 5; ++i)<br/>      {<br/>        threads[i] = thread([&amp;counter, &amp;mtx]()<br/>        {<br/>           for (int i = 0; i &lt; 10000; ++i)<br/>           {<br/>             <strong>mtx.lock();</strong><br/>             ++counter;<br/>             <strong>mtx.unlock();</strong><br/> <br/>             cout &lt;&lt; "Thread ID: ";<br/>             cout &lt;&lt; this_thread::get_id();<br/>             cout &lt;&lt; "\tCurrent Counter = ";<br/>             cout &lt;&lt; counter &lt;&lt; endl;<br/>           }<br/>        });<br/>      }<br/><br/>      for (auto&amp; thread : threads)<br/>      {<br/>        thread.join();<br/>      }<br/> <br/>      cout &lt;&lt; "Final result = " &lt;&lt; counter &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, before the code increments the <kbd>counter</kbd> variable, it calls the <kbd>lock()</kbd> method. And after that, it calls the <kbd>unlock()</kbd> method to notify the other threads that the <kbd>counter</kbd> variable is free to manipulate now. If we run the preceding code, we should see the following output on the console:</p>
<div><img class=" image-border" src="img/0e60f03b-94fb-43c7-aa0e-2e9ede5261b2.png"/></div>
<p>By using the <kbd>mutex</kbd> class, now we retrieve the result we expect, as we can see in the preceding screenshot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unlocking the variable automatically</h1>
                
            
            
                
<p>We now know how to lock the variable to ensure that no two threads working on the same value simultaneously retrieve the correct value from it. However, the problem will occur if an exception is thrown before the thread calls the <kbd>unlock()</kbd> method. The program will be completely locked if the state of the variable remains locked. To solve this problem, we can use <kbd>lock_guard&lt;mutex&gt;</kbd> to lock the variable and to ensure that it will be unlocked at the end of the scope no matter what happens. The following piece of code is refactored from the preceding code by adding the <kbd>lock_guard&lt;mutex&gt;</kbd> functionality:</p>
<pre>
    /* automutex.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;mutex&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[automutex.cpp]" &lt;&lt; endl;<br/> <br/>      mutex mtx;<br/>      int counter = 0;<br/> <br/>      thread threads[5];<br/><br/>      for (int i = 0; i &lt; 5; ++i)<br/>      {<br/>        threads[i] = thread([&amp;counter, &amp;mtx]()<br/>        {<br/>          for (int i = 0; i &lt; 10000; ++i)<br/>          {<br/>            {<br/>              <strong>lock_guard &lt;mutex&gt; guard(mtx);</strong><br/>              ++counter;<br/>             }<br/><br/>             cout &lt;&lt; "Thread ID: ";<br/>             cout &lt;&lt; this_thread::get_id();<br/>             cout &lt;&lt; "\tCurrent Counter = ";<br/>             cout &lt;&lt; counter &lt;&lt; endl;<br/>          }<br/>         });<br/>       }<br/> <br/>       for (auto&amp; thread : threads)<br/>       {<br/>          thread.join();<br/>       }<br/> <br/>      cout &lt;&lt; "Final result = " &lt;&lt; counter &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see from the preceding <kbd>automutex.cpp</kbd> code, it calls <kbd>lock_guard &lt;mutex&gt; guard(mtx)</kbd> before it increments the <kbd>counter</kbd> variable. If we run the code, we will get exactly the same output with the <kbd>mutex.cpp</kbd> code. However, now we have a program that won't be locked unpredictably.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding deadlock using recursive mutex</h1>
                
            
            
                
<p>In the previous section, we used <kbd>lock_guard</kbd> to ensure that the variable is not accessed by more than one thread. However, we will still face a problem if more than one <kbd>lock_guard</kbd> obtains the lock. In the following piece of code, we have two functions that will call <kbd>lock_guard</kbd>--<kbd>Multiplexer()</kbd> and <kbd>Divisor()</kbd>. Besides them, we also have a function that will call these two functions--<kbd>RunAll()</kbd> that will call <kbd>lock_guard</kbd> first before calling the two functions. The code should look like this:</p>
<pre>
    /* deadlock.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;mutex&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    struct Math<br/>    {<br/>      mutex mtx;<br/>      int m_content;<br/><br/>      Math() : m_content(0)<br/>      {<br/>      }<br/><br/>      // This method will lock the mutex<br/>      void Multiplexer(int i)<br/>      {<br/>        lock_guard&lt;mutex&gt; lock(mtx);<br/>        m_content *= i;<br/>        cout &lt;&lt; "Multiplexer() is called. m_content = ";<br/>        cout &lt;&lt; m_content &lt;&lt; endl;<br/>      }<br/><br/>      // This method will lock the mutex also<br/>      void Divisor(int i)<br/>      {<br/>        lock_guard&lt;mutex&gt; lock(mtx);<br/>        m_content /= i;<br/>        cout &lt;&lt; "Divisor() is called. m_content = ";<br/>        cout &lt;&lt; m_content &lt;&lt; endl;<br/>      }<br/><br/>      // This method will invoke <br/>      // the two preceding methods<br/>      // which each method locks the mutex<br/>      void RunAll(int a)<br/>      {<br/>        lock_guard&lt;mutex&gt; lock(mtx);<br/>        Multiplexer(a);<br/>        Divisor(a);<br/>      }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[deadlock.cpp]" &lt;&lt; endl;<br/><br/>      // Instantiating Math struct<br/>      // and invoking the RunAll() method <br/>      Math math;<br/>      math.RunAll(10);<br/><br/>      return 0;<br/>    }
</pre>
<p>We will successfully compile the following piece of code. However, if we run the preceding code, an error will occur since the program won't exit due to the <strong>deadlock</strong>. It is because the same mutex cannot be acquired by multiple threads twice. When the <kbd>RunAll()</kbd> function is invoked, it acquires the <kbd>lock</kbd> object. The <kbd>Multiplexer()</kbd> function inside the <kbd>RunAll()</kbd> function wants to acquire <kbd>lock</kbd> as well. However, <kbd>lock</kbd> has been locked by the <kbd>RunAll()</kbd> function. To solve this problem, we can replace <kbd>lock_guard&lt;mutex&gt;</kbd> with <kbd>lock_guard&lt;recursive_mutex&gt;</kbd>, as you can see in the following piece of code:</p>
<pre>
    /* recursivemutex.cpp */<br/>    #include &lt;thread&gt;<br/>    #include &lt;mutex&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    struct Math<br/>    {<br/><strong>      recursive_mutex mtx;</strong><br/>      int m_content;<br/><br/>      Math() : m_content(1)<br/>      {<br/>      }<br/><br/>      // This method will lock the mutex<br/>      void Multiplexer(int i)<br/>      {<br/>        <strong>lock_guard&lt;recursive_mutex&gt; lock(mtx);</strong><br/>        m_content *= i;<br/>        cout &lt;&lt; "Multiplexer() is called. m_content = ";<br/>        cout &lt;&lt; m_content &lt;&lt; endl;<br/>      }<br/><br/>      // This method will lock the mutex also<br/>      void Divisor(int i)<br/>      {<br/>        <strong>lock_guard&lt;recursive_mutex&gt; lock(mtx);</strong><br/>        m_content /= i;<br/>        cout &lt;&lt; "Divisor() is called. m_content = ";<br/>        cout &lt;&lt; m_content &lt;&lt; endl;<br/>      }<br/><br/>      // This method will invoke <br/>      // the two preceding methods<br/>      // which each method locks the mutex<br/>      void RunAll(int a)<br/>      {<br/>        <strong>lock_guard&lt;recursive_mutex&gt; lock(mtx);</strong><br/>        Multiplexer(a);<br/>        Divisor(a);<br/>      }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[recursivemutex.cpp]" &lt;&lt; endl;<br/><br/>      // Instantiating Math struct<br/>      // and invoking the RunAll() method <br/>      Math math;<br/>      math.RunAll(10);<br/><br/>      return 0;<br/>    }
</pre>
<p>Now, we can successfully compile and run the preceding code. We can use the <kbd>lock_guard&lt;recursive_mutex&gt;</kbd> class that will allow mutex to be locked more than once without getting to the deadlock. The following screenshot will be seen on the console when we run the preceding code:</p>
<div><img class=" image-border" src="img/7faafdd2-15bc-4f57-82ca-d50df7296692.png"/></div>
<p>Now, we know we need to use one recursive <kbd>mutex</kbd> if we want to call functions that lock the same <kbd>mutex</kbd> recursively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the thread processing in a Windows operating system</h1>
                
            
            
                
<p>Let's move to a specific operating system that is widely used by many user computers, that is Windows. Our code must need to be run on some commercial platform from a leading OS vendor, such as Microsoft. So, we will now run the thread in Windows OS. In this OS, the thread is a kernel resource, which means it is an object that is created and owned by the OS kernel and lives in the kernel. The kernel itself is a core program that has complete control over everything in the system. In this section, we will develop a thread in Windows OS so our program can work well in this OS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with handle</h1>
                
            
            
                
<p>In the Windows operating system, handle is an abstract reference value to a resource. In this discussion, we will use the abstract reference to hold the thread. Let's suppose we have a <kbd>threadProc()</kbd> function that will be called inside a thread which is held in the <kbd>hnd</kbd> variable. The code will be as follows:</p>
<pre>
    /* threadhandle.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;windows.h&gt;<br/><br/>    using namespace std;<br/><br/>    auto threadProc(void*) -&gt; unsigned long<br/>    {<br/>      cout &lt;&lt; "threadProc() is run." &lt;&lt; endl;<br/>      return 100;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[threadhandle.cpp]" &lt;&lt; endl;<br/><br/>      auto hnd = HANDLE<br/>      {<br/>        CreateThread(<br/>            nullptr,<br/>            0,<br/>            threadProc,<br/>            nullptr,<br/>            0,<br/>            nullptr)<br/>      };<br/><br/>      if (hnd)<br/>      {<br/>        WaitForSingleObject(hnd, INFINITE);<br/><br/>        unsigned long exitCode;<br/>        GetExitCodeThread(hnd, &amp;exitCode);<br/><br/>        cout &lt;&lt; "The result = " &lt;&lt; exitCode &lt;&lt; endl;<br/><br/>        CloseHandle(hnd);<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we use the <kbd>CreateThread()</kbd> function provided by the <kbd>windows.h</kbd> header to generate a thread. For now, we just pass the <kbd>nullptr</kbd> value as the default parameter, except <kbd>threadProc</kbd> as a function that we will call from the thread.</p>
<p>After we initialize the handle of the thread, we can ensure that the <kbd>hnd</kbd> variable contains the handle of the thread, then invokes the <kbd>WaitForSingleObject()</kbd> function. It is similar to the <kbd>join()</kbd> method we used in the preceding section that will run the thread and wait until the thread is finished. Since the thread handle is a resource we use, don't forget to release it by using the <kbd>CloseHandle()</kbd> function. If we run the preceding code, we will see the following output on the console screen:</p>
<div><img class=" image-border" src="img/b74afe83-9bdb-431b-b75f-7a7da30e77ba.png"/></div>
<p>As we can see, we have successfully run the thread since we've got the expected process from the <kbd>threadProc()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring to a unique handle</h1>
                
            
            
                
<p>Now, to ease our programming process, we will create a class named <kbd>NullHandle</kbd> that will automatically release the resource each time we no longer need it. It will be constructed from the <kbd>UniqueHandle</kbd> class, which we will develop as well. These classes can be found in the <kbd>uniquehandle.h</kbd> file. The implementation of <kbd>UniqueHandle</kbd> is as follows:</p>
<pre>
    template &lt;typename C&gt;<br/>    class UniqueHandle<br/>    {<br/>      private:<br/>        HANDLE m_val;<br/><br/>        void Close()<br/>        {<br/>          if (*this)<br/>          {<br/>            C::Exit(m_val);<br/>          }<br/>        }<br/><br/>      public:<br/>        // Copy assignment operator <br/>        UniqueHandle(UniqueHandle const &amp;) = delete;<br/>        auto operator=(UniqueHandle const &amp;)-&gt;UniqueHandle &amp; = delete;<br/><br/>        // UniqueHandle constructor<br/>        explicit UniqueHandle(HANDLE value = C::Invalid()) :<br/>        m_val{ value }<br/>        {<br/>        }<br/><br/>        // Move assignment operator<br/>        UniqueHandle(UniqueHandle &amp;&amp; other) :<br/>        m_val{ other.Release() }<br/>        {<br/>        }<br/><br/>        // Move assignment operator<br/>        auto operator=(UniqueHandle &amp;&amp; other) -&gt; UniqueHandle &amp;<br/>        {<br/>          if (this != &amp;other)<br/>          {<br/>            Reset(other.Release());<br/>          }<br/><br/>          return *this;<br/>        }<br/><br/>        // Destructor of UniqueHandle class<br/>        ~UniqueHandle()<br/>        {<br/>          Close();<br/>        }<br/><br/>        // bool operator for equality<br/>        explicit operator bool() const <br/>        {<br/>          return m_val != C::Invalid();<br/>        }<br/><br/>        // Method for retrieving the HANDLE value<br/>        HANDLE Get() const<br/>        {<br/>          return m_val;<br/>        }<br/> <br/>       // Method for releasing the HANDLE value<br/>       HANDLE Release()<br/>       {<br/>         auto value = m_val;<br/>         m_val = C::Invalid();<br/>         return value;<br/>       }<br/>  <br/>       // Method for reseting the HANDLE<br/>       bool Reset(HANDLE value = C::Invalid())<br/>       {<br/>        if (m_val != value)<br/>        {<br/>           Close();<br/>           m_val = value;<br/>        }<br/><br/>         return static_cast&lt;bool&gt;(*this);<br/>       }<br/>    };
</pre>
<p>As we can see, we have a complete implementation of the <kbd>UniqueHandle</kbd> class that can be instanced and will automatically close the handle from its destructor. To use <kbd>NullHandle</kbd> object, we will use the following code:</p>
<pre>
    using NullHandle = UniqueHandle&lt;NullHandleCharacteristics&gt;;
</pre>
<p>The implementation of the <kbd>NullHandleCharacteristics</kbd> struct is as follows:</p>
<pre>
    struct NullHandleCharacteristics<br/>    {<br/>      // Returning nullptr when the HANDLE is invalid<br/>      static HANDLE Invalid()<br/>      {<br/>         return nullptr;<br/>      }<br/><br/>      // Exit the HANDLE by closing it<br/>      static void Exit(HANDLE val)<br/>      {<br/>         CloseHandle(val);<br/>      }<br/>    };
</pre>
<p>Now, let's refactor our preceding <kbd>threadhandle.cpp</kbd> code. We will replace <kbd>HANDLE</kbd> with <kbd>NullHandle</kbd>, so it will be as follows:</p>
<pre>
    auto hnd = NullHandle<br/>    {<br/>      CreateThread(<br/>        nullptr,<br/>        0,<br/>        threadProc,<br/>        nullptr,<br/>        0,<br/>        nullptr)<br/>    };
</pre>
<p>Then, we will create a new function named <kbd>WaitOneThread()</kbd> to call the thread itself and wait until it finishes. The implementation should be as follows:</p>
<pre>
    auto WaitOneThread(<br/>      HANDLE const h,<br/>      DWORD const ms = INFINITE) -&gt; bool<br/>      {<br/>        auto const r = WaitForSingleObject(<br/>        h,<br/>        ms);<br/><br/>        // Inform that thread is not idle<br/>        if (r == WAIT_OBJECT_0)<br/>          return true;<br/><br/>        // Inform that thread is not idle<br/>        if (r == WAIT_TIMEOUT)<br/>          return false;<br/><br/>        throw WinException();<br/>      }
</pre>
<p>By using the <kbd>WaitOneThread()</kbd> function, we can know whether or not the thread has been run. The <kbd>WinException</kbd> struct can be implemented as follows:</p>
<pre>
    struct WinException<br/>    {<br/>      unsigned long error;<br/><br/>      explicit WinException(<br/>        unsigned long value = GetLastError()) :<br/>        error{ value }<br/>       {<br/>       }<br/>    };
</pre>
<p>Now, we can add the following piece of code to the <kbd>main()</kbd> function after we initialize the <kbd>hnd</kbd> HANDLE:</p>
<pre>
    if (hnd)<br/>    {<br/>      if (WaitOneThread(hnd.Get(), 0))<br/>        cout &lt;&lt; "Before running thread" &lt;&lt; endl;<br/><br/>      WaitOneThread(hnd.Get());<br/><br/>      if (WaitOneThread(hnd.Get(), 0))<br/>        cout &lt;&lt; "After running thread" &lt;&lt; endl;<br/><br/>      unsigned long exitCode;<br/>      GetExitCodeThread(hnd.Get(), &amp;exitCode);<br/><br/>      cout &lt;&lt; "The result = " &lt;&lt; exitCode &lt;&lt; endl;<br/>    }
</pre>
<p>As we can see from the preceding code, we call the <kbd>WaitOneThread()</kbd> function and pass <kbd>0</kbd> as the <kbd>ms</kbd> parameter to find out the status of the <kbd>WaitForSingleObject()</kbd> function call. We can pass the <kbd>INFINITE</kbd> value to it to call the thread and wait for it until it finishes. The following is the <kbd>threaduniquehandle.cpp</kbd> code that is refactored from the <kbd>threadhandle.cpp</kbd> code and has consumed the <kbd>UniqueHandle</kbd> class:</p>
<pre>
    /* threaduniquehandle.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;windows.h&gt;<br/>    #include "../uniquehandle_h/uniquehandle.h"<br/><br/>    using namespace std;<br/><br/>    unsigned long threadProc(void*)<br/>    {<br/>      cout &lt;&lt; "threadProc() is run." &lt;&lt; endl;<br/>      return 100;<br/>    }<br/><br/>    struct WinException<br/>    {<br/>      unsigned long error;<br/>      explicit WinException(<br/>        unsigned long value = GetLastError()) :<br/>        error{ value }<br/>        {<br/>        }<br/>    };<br/><br/>    auto WaitOneThread(<br/>      HANDLE const h,<br/>      DWORD const ms = INFINITE) -&gt; bool<br/>      {<br/>        auto const r = WaitForSingleObject(<br/>        h,<br/>        ms);<br/><br/>       // Inform that thread is not idle<br/>       if (r == WAIT_OBJECT_0)<br/>         return true;<br/><br/>       // Inform that thread is not idle<br/>       if (r == WAIT_TIMEOUT)<br/>         return false;<br/><br/>       throw WinException();<br/>      }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[threaduniquehandle.cpp]" &lt;&lt; endl;<br/><br/>      auto hnd = NullHandle<br/>      {<br/>        CreateThread(<br/>            nullptr,<br/>            0,<br/>            threadProc,<br/>            nullptr,<br/>            0,<br/>            nullptr)<br/>      };<br/><br/>      if (hnd)<br/>      {<br/>        if (WaitOneThread(hnd.Get(), 0))<br/>          cout &lt;&lt; "Before running thread" &lt;&lt; endl;<br/><br/>        WaitOneThread(hnd.Get());<br/><br/>        if (WaitOneThread(hnd.Get(), 0))<br/>          cout &lt;&lt; "After running thread" &lt;&lt; endl;<br/><br/>        unsigned long exitCode;<br/>        GetExitCodeThread(hnd.Get(), &amp;exitCode);<br/><br/>        cout &lt;&lt; "The result = " &lt;&lt; exitCode &lt;&lt; endl;<br/>      }<br/><br/>     return 0;<br/>    }
</pre>
<p>The following screenshot is the output we should see on the console screen:</p>
<div><img class=" image-border" src="img/70059c6e-2e41-4913-86c8-d05ada792004.png"/></div>
<p>As we can see from the preceding screenshot, we don't have the <kbd>Before running thread</kbd> line on it. It's because we will get the <kbd>WAIT_TIMEOUT</kbd> output each time the thread is not called. And still, we have successfully executed the code in the <kbd>threadProc()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Triggering an event</h1>
                
            
            
                
<p>After playing with thread in Windows, let's try another concurrency type--<kbd>Event</kbd>. It is an action that can be triggered by the system. To know further about it, let's take a look at the following code snippet where we create a new class named <kbd>Event</kbd> that implements <kbd>UniqueHandle</kbd> as well:</p>
<pre>
    class Event<br/>    {<br/>      private:<br/>        NullHandle hnd;<br/><br/>      public:<br/>        Event(Event const &amp;) = delete;<br/>        auto operator=(Event const &amp;)-&gt;Event &amp; = delete;<br/>        ~Event() = default;<br/><br/>        explicit Event(bool manual) :<br/>         hnd<br/>         {<br/>           CreateEvent(nullptr,<br/>            manual, false, nullptr)<br/>         }<br/>         {<br/>           if (!hnd)<br/>            throw WinException();<br/>         }<br/><br/>        explicit Event(EventType evType) :<br/>         hnd<br/>         {<br/>           CreateEvent(<br/>            nullptr,<br/>            static_cast&lt;BOOL&gt;(evType),<br/>            false,<br/>            nullptr)<br/>         }<br/>         {<br/>           if (!hnd)<br/>            throw WinException();<br/>         }<br/><br/>         Event(Event &amp;&amp; other) throw() :<br/>           hnd<br/>           {<br/>             other.hnd.Release()<br/>           }<br/>           {<br/>           }<br/><br/>         auto operator=(Event &amp;&amp; other) throw()-&gt;Event &amp;<br/>         {<br/>           hnd = move(other.hnd);<br/>         }<br/><br/>         void Set()<br/>         {<br/>           cout &lt;&lt; "The event is set" &lt;&lt; endl;<br/>           SetEvent(hnd.Get());<br/>         }<br/><br/>         void Clear()<br/>         {<br/>           cout &lt;&lt; "The event is cleared" &lt;&lt; endl;<br/>           ResetEvent(hnd.Get());<br/>         }<br/><br/>         auto Wait(<br/>           DWORD const ms = INFINITE) -&gt; bool<br/>           {<br/>             auto const result = WaitForSingleObject(<br/>             hnd.Get(), ms);<br/><br/>            return result == WAIT_OBJECT_0;<br/>           }<br/>     };
</pre>
<p>As we can see in the preceding <kbd>Event</kbd> class implementation, we have the <kbd>Set()</kbd>, <kbd>Clear()</kbd>, and <kbd>Wait()</kbd> methods to set an event, clear an event, and wait for the event to complete respectively. We have two event types, which are automatic reset and manual reset, which are declared as follows:</p>
<pre>
    enum class EventType<br/>    {<br/>      AutoReset,<br/>      ManualReset<br/>    };
</pre>
<p>Now, we will create content in the <kbd>main()</kbd> function. We will instance the <kbd>Event</kbd> class first, then we will check the event signaling. If it's not signaled, we will set the event. On the contrary, we will clear the event. The code will be the following <kbd>event.cpp</kbd> code:</p>
<pre>
    /* event.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;windows.h&gt;<br/>    #include "../uniquehandle_h/uniquehandle.h"<br/><br/>    using namespace std;<br/><br/>    struct WinException<br/>    {<br/>      unsigned long error;<br/><br/>      explicit WinException(<br/>        unsigned long value = GetLastError()) :<br/>        error{ value }<br/>        {<br/>        }<br/>    };<br/><br/>    enum class EventType<br/>    {<br/>      AutoReset,<br/>      ManualReset<br/>    };<br/><br/>    class Event<br/>    {<br/>      private:<br/>        NullHandle hnd;<br/><br/>      public:<br/>        Event(Event const &amp;) = delete;<br/>        auto operator=(Event const &amp;)-&gt;Event &amp; = delete;<br/>        ~Event() = default;<br/><br/>        explicit Event(bool manual) :<br/>         hnd<br/>         {<br/>           CreateEvent(nullptr,<br/>           manual, false, nullptr)<br/>         }<br/>         {<br/>           if (!hnd)<br/>            throw WinException();<br/>         }<br/><br/>         explicit Event(EventType evType) :<br/>          hnd<br/>          {<br/>            CreateEvent(<br/>            nullptr,<br/>            static_cast&lt;BOOL&gt;(evType),<br/>            false,<br/>            nullptr)<br/>          }<br/>          {<br/>            if (!hnd)<br/>             throw WinException();<br/>          }<br/><br/>          Event(Event &amp;&amp; other) throw() :<br/>            hnd<br/>            {<br/>              other.hnd.Release()<br/>            }<br/>            {<br/>            }<br/><br/>          auto operator=(Event &amp;&amp; other) throw() -&gt; Event &amp;<br/>          {<br/>              hnd = move(other.hnd);<br/>          }<br/><br/>          void Set()<br/>          {<br/>              cout &lt;&lt; "The event is set" &lt;&lt; endl;<br/>              SetEvent(hnd.Get());<br/>          }<br/><br/>          void Clear()<br/>          {<br/>               cout &lt;&lt; "The event is cleared" &lt;&lt; endl;<br/>               ResetEvent(hnd.Get());<br/>          }<br/><br/>          auto Wait(<br/>            DWORD const ms = INFINITE) -&gt; bool<br/>              {<br/>                auto const result = WaitForSingleObject(<br/>                  hnd.Get(), ms);<br/>    <br/>                return result == WAIT_OBJECT_0;<br/>             }<br/>          };<br/><br/>          void CheckEventSignaling( bool b)<br/>          {<br/>            if (b)<br/>            {<br/>              cout &lt;&lt; "The event is signaled" &lt;&lt; endl;<br/>            }<br/>            else<br/>            {<br/>             cout &lt;&lt; "The event is not signaled" &lt;&lt; endl;<br/>            }<br/>         }<br/><br/>         auto main() -&gt; int<br/>         {<br/>           cout &lt;&lt; "[event.cpp]" &lt;&lt; endl;<br/><br/>           auto ev = Event{<br/>             EventType::ManualReset };<br/><br/>             CheckEventSignaling(ev.Wait(0));<br/><br/>             ev.Set();<br/><br/>             CheckEventSignaling(ev.Wait(0));<br/><br/>             ev.Clear();<br/><br/>             CheckEventSignaling(ev.Wait(0));<br/><br/>             return 0;<br/>          }
</pre>
<p>As we can see in the preceding code, here is what the code does:</p>
<ol>
<li>It creates the instance of the <kbd>Event</kbd> class in the <kbd>main()</kbd> function and manually resets the event.</li>
<li>It invokes the <kbd>CheckEventSignaling()</kbd> function to find out the status of the event by passing the <kbd>Wait()</kbd> function to the <kbd>CheckEventSignaling()</kbd> function, which in turn calls the <kbd>WaitForSingleObject()</kbd> function.</li>
<li>It invokes the <kbd>Set()</kbd> and <kbd>Reset()</kbd> functions.</li>
<li>Now run the preceding <kbd>event.cpp</kbd> code. You will see the following output on the console:</li>
</ol>
<div><img class=" image-border" height="90" src="img/72bfd423-0b5b-4915-9711-490b1b27b46f.png" width="416"/></div>
<p>If we take a look at the preceding screenshot, at first, the initialization of the <kbd>Event</kbd> class is not signaled. We then set the event, and it is now signaled as the status from the <kbd>CheckEventSignaling()</kbd> method. Here, we can say that we can check the status of the signaled event by calling the <kbd>WaitForSingleObject()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling an event from a thread</h1>
                
            
            
                
<p>Now, let's use thread to call the <kbd>Event</kbd> class. However, before that, we have to be able to wrap more than one thread, call them together, and wait until their processes are finished. The following code block is a <kbd>Wrap()</kbd> function that will pack the threads:</p>
<pre>
    void Wrap(HANDLE *)<br/>    {<br/>    }<br/><br/>    template &lt;typename T, typename... Args&gt;<br/>    void Wrap(<br/>      HANDLE * left,<br/>      T const &amp; right,<br/>      Args const &amp; ... args)<br/>      {<br/>        *left = right.Get();<br/>        Wrap(++left, args...);<br/>      }
</pre>
<p>We will call the preceding <kbd>Wrap()</kbd> function when we join all the threads. So, we will need another function named <kbd>WaitAllThreads()</kbd>, as we can see in the following piece of code:</p>
<pre>
    template &lt;typename... Args&gt;<br/>    void WaitAllThreads(Args const &amp; ... args)<br/>    {<br/>      HANDLE handles[sizeof...(Args)];<br/><br/>      Wrap(handles, args...);<br/><br/>      WaitForMultipleObjects(<br/>        sizeof...(Args),<br/>        handles,<br/>        true,<br/>        INFINITE);<br/>    }
</pre>
<p>Now, we can create our full code that will run the two threads using the following <kbd>eventthread.cpp</kbd> code:</p>
<pre>
    /* eventthread.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;windows.h&gt;<br/>    #include "../uniquehandle_h/uniquehandle.h"<br/><br/>    using namespace std;<br/><br/>    void Wrap(HANDLE *)<br/>    {<br/>    }<br/><br/>    template &lt;typename T, typename... Args&gt;<br/>    void Wrap(<br/>      HANDLE * left,<br/>      T const &amp; right,<br/>      Args const &amp; ... args)<br/>      {<br/>        *left = right.Get();<br/>        Wrap(++left, args...);<br/>      }<br/><br/>    template &lt;typename... Args&gt;<br/>    void WaitAllThreads(Args const &amp; ... args)<br/>    {<br/>      HANDLE handles[sizeof...(Args)];<br/><br/>      Wrap(handles, args...);<br/><br/>      WaitForMultipleObjects(<br/>        sizeof...(Args),<br/>        handles,<br/>        true,<br/>        INFINITE);<br/>    }<br/><br/>    auto threadProc(void*) -&gt; unsigned long<br/>    {<br/>      cout &lt;&lt; "Thread ID: ";<br/>      cout &lt;&lt; GetCurrentThreadId() &lt;&lt; endl;<br/>      return 120;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[eventthread.cpp]" &lt;&lt; endl;<br/><br/>      auto thread1 = NullHandle<br/>      {<br/>        CreateThread(<br/>          nullptr,<br/>          0,<br/>          threadProc,<br/>          nullptr,<br/>          CREATE_SUSPENDED,<br/>          nullptr)<br/>      };<br/><br/>      auto thread2 = NullHandle<br/>      {<br/>        CreateThread(<br/>          nullptr,<br/>          0,<br/>          threadProc,<br/>          nullptr,<br/>          CREATE_SUSPENDED,<br/>          nullptr)<br/>     };<br/><br/><strong>     ResumeThread(thread1.Get());</strong><br/><strong>     ResumeThread(thread2.Get());</strong><br/><br/>     WaitAllThreads(thread1, thread2);<br/><br/>     return 0;<br/>    }
</pre>
<p>Moreover, if we run the preceding <kbd>eventthread.cpp</kbd> code, we will see the following output on the console screen:</p>
<div><img class=" image-border" src="img/0a60a3d6-c786-4791-b43d-797e4d01e1e6.png"/></div>
<p>We have successfully triggered an <kbd>Event</kbd>, so it can be set to become signaled and can be cleared to become unsignaled in the <kbd>event.cpp</kbd> code. We have also successfully wrapped more than one thread, then called them together in the <kbd>eventthread.cpp</kbd> code. Now, let's concatenate these two codes so we can access the event from the thread. The code should be like the following <kbd>eventthread2.cpp</kbd> code:</p>
<pre>
    /* eventthread2.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;windows.h&gt;<br/>    #include "../uniquehandle_h/uniquehandle.h"<br/><br/>    using namespace std;<br/><br/>    struct WinException<br/>    {<br/>      unsigned long error;<br/><br/>      explicit WinException(<br/>        unsigned long value = GetLastError()) :<br/>        error{ value }<br/>        {<br/>        }<br/>    };<br/><br/>    enum class EventType<br/>    {<br/>      AutoReset,<br/>      ManualReset<br/>     };<br/><br/>    class Event<br/>    {<br/>      private:<br/>        NullHandle hnd;<br/><br/>      public:<br/>        Event(Event const &amp;) = delete;<br/>        auto operator=(Event const &amp;)-&gt;Event &amp; = delete;<br/>        ~Event() = default;<br/><br/>        explicit Event(bool manual) :<br/>          hnd<br/>          {<br/>            CreateEvent(nullptr,<br/>            manual, false, nullptr)<br/>          }<br/>          {<br/>            if (!hnd)<br/>             throw WinException();<br/>          }<br/><br/>        explicit Event(EventType evType) :<br/>          hnd<br/>          {<br/>            CreateEvent(<br/>              nullptr,<br/>              static_cast&lt;BOOL&gt;(evType),<br/>              false,<br/>              nullptr)<br/>           }<br/>           {<br/>             if (!hnd)<br/>              throw WinException();<br/>           }<br/><br/>        Event(Event &amp;&amp; other) throw() :<br/>          hnd<br/>          {<br/>            other.hnd.Release()<br/>          }<br/>          {<br/>          }<br/><br/>        auto operator=(Event &amp;&amp; other) throw() -&gt; Event &amp;<br/>        {<br/>          hnd = move(other.hnd);<br/>        }<br/><br/>        void Set()<br/>        {<br/>          cout &lt;&lt; "The event is set" &lt;&lt; endl;<br/>          SetEvent(hnd.Get());<br/>        }<br/><br/>        void Clear()<br/>        {<br/>          cout &lt;&lt; "The event is cleared" &lt;&lt; endl;<br/>          ResetEvent(hnd.Get());<br/>        }<br/><br/>        auto Wait( DWORD const ms = INFINITE) -&gt; bool<br/>        {<br/>           auto const result = WaitForSingleObject(<br/>            hnd.Get(), ms);<br/><br/>           return result == WAIT_OBJECT_0;<br/>        }<br/>     };<br/><br/>        void Wrap(HANDLE *)<br/>        {<br/>        }<br/><br/>        template &lt;typename T, typename... Args&gt;<br/>        void Wrap(<br/>        HANDLE * left,<br/>        T const &amp; right,<br/>        Args const &amp; ... args)<br/>        {<br/>          *left = right.Get();<br/>           Wrap(++left, args...);<br/>        }<br/><br/>        template &lt;typename... Args&gt;<br/>        void WaitAllThreads(Args const &amp; ... args)<br/>        {<br/>        HANDLE handles[sizeof...(Args)];<br/><br/>        Wrap(handles, args...);<br/><br/>        WaitForMultipleObjects(<br/>          sizeof...(Args),<br/>          handles,<br/>          true,<br/>          INFINITE);<br/>        }<br/><br/>        static auto ev = Event{<br/>        EventType::ManualReset };<br/><br/>        auto threadProc(void*) -&gt; unsigned long<br/>        {<br/>          cout &lt;&lt; "Thread ID: ";<br/>          cout &lt;&lt; GetCurrentThreadId() &lt;&lt; endl;<br/><br/>          ev.Wait();<br/><br/>          cout &lt;&lt; "Run Thread ID: ";<br/>          cout &lt;&lt; GetCurrentThreadId() &lt;&lt; endl;<br/><br/>          return 120;<br/>        }<br/><br/>        auto main() -&gt; int<br/>        {<br/>          cout &lt;&lt; "[eventthread2.cpp]" &lt;&lt; endl;<br/><br/>          auto thread1 = NullHandle<br/>          {<br/>            CreateThread(<br/>              nullptr,<br/>              0,<br/>              threadProc,<br/>              nullptr,<br/>              0,<br/>              nullptr)<br/>          };<br/><br/>          auto thread2 = NullHandle<br/>          {<br/>            CreateThread(<br/>              nullptr,<br/>              0,<br/>              threadProc,<br/>              nullptr,<br/>              0,<br/>              nullptr)<br/>         };<br/><br/><strong>         Sleep(100);</strong><br/><strong>         ev.Set();</strong><br/><strong>         Sleep(100);</strong><br/><br/>         WaitAllThreads(thread1, thread2);<br/> <br/>         return 0;<br/>    }
</pre>
<p>In the preceding <kbd>eventthread2.cpp</kbd> code, we try to trigger the event using the thread. We initialize two <kbd>NullHandle</kbd> object threads at first. Then, we set the event and call the <kbd>Sleep()</kbd> function to make the event active. The <kbd>WaitAllThreads()</kbd> function then invokes the <kbd>threadProc()</kbd> function and runs each thread. This will trigger the event by calling the <kbd>ev.Wait()</kbd> function. The threads will be run then. The following screenshot is the output we will see on the console screen:</p>
<div><img class=" image-border" src="img/94bc604a-76c4-49b3-9325-383479e5379f.png"/></div>
<p>The preceding code is the event that we set manually to reset the event. This means that we have to state when we clear the event. Now, we pass <kbd>AutoReset</kbd> to the event instance. We will also modify the <kbd>threadProc()</kbd> function a little bit. The following piece of code is <kbd>eventthread3.cpp</kbd> that we are talking about:</p>
<pre>
    /* eventthread3.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;windows.h&gt;<br/>    #include "../uniquehandle_h/uniquehandle.h"<br/><br/>    using namespace std;<br/><br/>    struct WinException<br/>    {<br/>      unsigned long error;<br/><br/>      explicit WinException(<br/>        unsigned long value = GetLastError()) :<br/>        error{ value }<br/>        {<br/>        }<br/>    };<br/><br/>    enum class EventType<br/>    {<br/>      AutoReset,<br/>      ManualReset<br/>    };<br/><br/>    class Event<br/>    {<br/>       private:<br/>         NullHandle hnd;<br/><br/>       public:<br/>         Event(Event const &amp;) = delete;<br/>         auto operator=(Event const &amp;)-&gt;Event &amp; = delete;<br/>         ~Event() = default;<br/><br/>         explicit Event(bool manual) :<br/>           hnd<br/>           {<br/>             CreateEvent(nullptr,<br/>             manual, false, nullptr)<br/>           }<br/>           {<br/>             if (!hnd)<br/>              throw WinException();<br/>           }<br/><br/>          explicit Event(EventType evType) :<br/>             hnd<br/>             {<br/>               CreateEvent(<br/>                 nullptr,<br/>                 static_cast&lt;BOOL&gt;(evType),<br/>                 false,<br/>                 nullptr)<br/>             }<br/>             {<br/>               if (!hnd)<br/>                throw WinException();<br/>             }<br/><br/>         Event(Event &amp;&amp; other) throw() :<br/>           hnd<br/>           {<br/>             other.hnd.Release()<br/>           }<br/>           {<br/>           }<br/><br/>         auto operator=(Event &amp;&amp; other) throw() -&gt; Event &amp;<br/>           {<br/>              hnd = move(other.hnd);<br/>           }<br/> <br/>          void Set()<br/>          {<br/>             cout &lt;&lt; "The event is set" &lt;&lt; endl;<br/>             SetEvent(hnd.Get());<br/>          }<br/><br/>          void Clear()<br/>          {<br/>              cout &lt;&lt; "The event is cleared" &lt;&lt; endl;<br/>              ResetEvent(hnd.Get());<br/>          }<br/><br/>          auto Wait(<br/>            DWORD const ms = INFINITE) -&gt; bool<br/>            {<br/>              auto const result = WaitForSingleObject(<br/>                hnd.Get(), ms);<br/> <br/>             return result == WAIT_OBJECT_0;<br/>            }<br/>       };<br/><br/>         void Wrap(HANDLE *)<br/>         {<br/>         }<br/><br/>         template &lt;typename T, typename... Args&gt;<br/>         void Wrap(<br/>           HANDLE * left,<br/>           T const &amp; right,<br/>           Args const &amp; ... args)<br/>           {<br/>             *left = right.Get();<br/>             Wrap(++left, args...);<br/>           }<br/><br/>           template &lt;typename... Args&gt;<br/>           void WaitAllThreads(Args const &amp; ... args)<br/>           {<br/>              HANDLE handles[sizeof...(Args)];<br/><br/>              Wrap(handles, args...);<br/><br/>              WaitForMultipleObjects(<br/>                sizeof...(Args),<br/>                handles,<br/>                true,<br/>                INFINITE);<br/>           }<br/><br/><strong>           static auto ev = Event{</strong><br/><strong>           EventType::AutoReset };</strong><br/><br/>           auto threadProc(void*) -&gt; unsigned long<br/>           {<br/>             cout &lt;&lt; "Thread ID: ";<br/>             cout &lt;&lt; GetCurrentThreadId() &lt;&lt; endl;<br/><br/>             ev.Wait();<br/><br/>             cout &lt;&lt; "Run Thread ID: ";<br/>             cout &lt;&lt; GetCurrentThreadId() &lt;&lt; endl;<br/><br/>             <strong>Sleep(1000);</strong><br/><strong>             ev.Set();</strong><br/><br/>             return 120;<br/>           }<br/><br/>           auto main() -&gt; int<br/>           {<br/>             cout &lt;&lt; "[eventthread3.cpp]" &lt;&lt; endl;<br/><br/>             auto thread1 = NullHandle<br/>             {<br/>               CreateThread(<br/>                 nullptr,<br/>                 0,<br/>                 threadProc,<br/>                 nullptr,<br/>                 0,<br/>                 nullptr)<br/>             };<br/><br/>             auto thread2 = NullHandle<br/>             {<br/>                CreateThread(<br/>                  nullptr,<br/>                  0,<br/>                  threadProc,<br/>                  nullptr,<br/>                  0,<br/>                  nullptr)<br/>             };<br/><br/>             Sleep(100);<br/>             ev.Set();<br/>             Sleep(100);<br/><br/>             WaitAllThreads(thread1, thread2);<br/><br/>             return 0;<br/>       }
</pre>
<p>As we can see in the preceding code, we move the <kbd>Set()</kbd> method of the event from the <kbd>main()</kbd> function to the <kbd>threadProc()</kbd> function. Now, every time the <kbd>threadProc()</kbd> function is invoked, the event is set automatically. The following screenshot is the output we should see on the console screen:</p>
<div><img class=" image-border" src="img/c3e50f9d-5157-4271-a317-35d79fff8152.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have learned a concept of C++ concurrency in this chapter. We now can process a single thread as well as multithreads. We can also synchronize the multithreads so it can run smoothly; therefore, we can avoid synchronization issues and deadlock. Lastly, we can consume the handle resource in Windows to create a thread and trigger the event using that event.</p>
<p>In the next chapter, we will apply all we have learned in the previous chapters to produce an application in a functional way. It will also explain how to test an application that is built using the C++ language.</p>


            

            
        
    </body></html>