<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer238">
<h1 class="chapter-number" id="_idParaDest-141"><a id="_idTextAnchor168"/>8</h1>
<h1 id="_idParaDest-142"><a id="_idTextAnchor169"/>Creating User Interfaces with UMG</h1>
<p>In the previous chapter, we learned about general-purpose utilities that allow you to properly structure and organize the code and assets in your project by using blueprint function libraries, actor components, and interfaces.</p>
<p>In this chapter, we will dive into the topic of game <strong class="bold">User Interfaces</strong> (<strong class="bold">UIs</strong>), which are present in almost every video game. The game UI is one of the main ways in which to show information to the player, such as how many lives they have left, how many bullets are in their weapon, which weapon they are carrying, and more. It also allows the player to interact with the game by choosing whether to continue the game, create a new game, choose which level they want to play in, and more. This is shown to the player mostly in the form of images and text.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>Game UI</li>
<li>UMG basics</li>
<li>Introducing anchors</li>
<li>Understanding progress bars</li>
</ul>
<h1 id="_idParaDest-143"><a id="_idTextAnchor170"/>Technical requirements</h1>
<p>The project for this chapter can be found in the Chapter08 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor171"/>Game UI</h1>
<p>Usually, UIs are added <a id="_idIndexMarker579"/>on top of the rendering of the game, which means that they are in front of everything else you see in the game and behave as layers (you can add them on top of one another just like in Photoshop). However, there is an exception to this: <em class="italic">diegetic UI</em>. This type of UI isn’t layered onto the game’s screen but rather exists inside the game itself. A great example of this can be found in the game <em class="italic">Dead Space</em>, where you control a character in a third-person view, and can see their health points by looking at the contraption attached to their back, inside the game world.</p>
<p>There are usually two different types of game UI: <strong class="bold">menus</strong> and <strong class="bold">HUDs</strong>.</p>
<p>Menus are<a id="_idIndexMarker580"/> UI panels<a id="_idIndexMarker581"/> that allow the player to interact with them, either by pressing a button or a key on their input device.</p>
<p>This can be done in the form of many different menus, including the following:</p>
<ul>
<li>Main menus, where the player can choose whether to continue the game, create a new game, exit the game, and more</li>
<li>Level select menus, where the player can choose which level to play</li>
<li>Many other options</li>
</ul>
<p>HUDs <a id="_idIndexMarker582"/>are <a id="_idIndexMarker583"/>UI panels that are present during gameplay. They give the player information that they should always know, such as how many lives they have left, which special abilities they can use, and more.</p>
<p>In this chapter, we will be covering game UI and how to make both a menu and a HUD for our game.</p>
<p class="callout-heading">Note</p>
<p class="callout">We won’t be covering diegetic UI here, as it is beyond the scope of this book.</p>
<p>So, how do we go about creating a game UI in UE5? The main way to do it is by using <strong class="bold">Unreal Motion Graphics</strong> (<strong class="bold">UMG</strong>), which<a id="_idIndexMarker584"/> is the tool that allows you to make a game UI (also called widgets in UE5 terms), featuring menus and HUDs, and add them to the screen.</p>
<p>Let’s jump into this topic in the following section.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor172"/>UMG basics</h1>
<p>In UE5, the main <a id="_idIndexMarker585"/>way to create a game UI is by using the <strong class="bold">UMG</strong> tool. This tool will allow you to make a game UI in the form of <strong class="bold">Widgets</strong>, which<a id="_idIndexMarker586"/> can be created using UMG. This will allow you to easily edit your game UI in a visual manner, through <strong class="bold">UMG’s Designer</strong> tab, while also allowing you to add functionality to your game UI through UMG’s <strong class="source-inline">Graph</strong> tab.</p>
<p>Widgets are the way UE5 allows you to represent a game UI. Widgets can be basic UI elements such as <strong class="bold">Button</strong> elements, <strong class="bold">Text</strong> elements, and <strong class="source-inline">Image</strong> elements, but they can also be<a id="_idIndexMarker587"/> combined to create more complex and complete widgets, such as menus and HUDs, which is exactly what we will be doing in this chapter.</p>
<p>In the following exercise, let’s create our first widget in UE5 using the UMG tool.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor173"/>Exercise 8.01 – creating a Widget Blueprint</h2>
<p>In this exercise, we<a id="_idIndexMarker588"/> will be creating our first Widget Blueprint. Additionally, we will be learning about the basic elements of UMG and how we can use them to create a game UI.</p>
<p>The following steps <a id="_idIndexMarker589"/>will help you to complete this exercise:</p>
<ol>
<li>In order to create our first widget, open the editor, go to the <strong class="bold">ThirdPersonCPP -&gt; Blueprints</strong> folder inside the <strong class="bold">Content Browser </strong>section, and <em class="italic">right-click</em>. </li>
<li>Go to the very last section, <strong class="bold">User Interface</strong>, and select <strong class="bold">Widget Blueprint</strong>.</li>
<li>After that, select <strong class="bold">UserWidget</strong> from the list of parent classes available:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 8.1 – Selecting the UserWidget parent class " height="375" src="image/Figure_8.01_B18531.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Selecting the UserWidget parent class</p>
<p>Selecting<a id="_idIndexMarker590"/> this option <a id="_idIndexMarker591"/>will create a new <strong class="source-inline">Widget Blueprint</strong> asset, which is the name of a widget asset in UE5.</p>
<ol>
<li value="4">Name this widget <strong class="source-inline">TestWidget</strong> and open it. You will see the interface for editing a Widget Blueprint, where you’ll be creating your own widgets and UI. Here’s a breakdown of all the tabs present in this window:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer203">
<img alt="Figure 8.2 – The Widget Blueprint editor broken down into six windows " height="929" src="image/Figure_8.02_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The Widget Blueprint editor broken down into six windows</p>
<p>The details<a id="_idIndexMarker592"/> about the tabs<a id="_idIndexMarker593"/> in the preceding screenshot are listed as follows:</p>
<ul>
<li><strong class="bold">Palette</strong> – This tab shows you all the individual UI elements that you can add to your widget. This includes <strong class="source-inline">Button</strong> elements, <strong class="source-inline">Text Box</strong> elements, <strong class="source-inline">Image</strong> elements, <strong class="source-inline">Slider</strong> elements, <strong class="source-inline">Check Box</strong> elements, and more.</li>
<li><strong class="bold">Hierarchy</strong> – This tab shows you all the UI elements currently present in your widget. As you can see, currently, we only have a <strong class="bold">Canvas Panel</strong> element in our hierarchy.</li>
<li><strong class="bold">Designer</strong> – This tab shows you how your widget looks visually, according to the elements present in the hierarchy, and how they’re laid out. Because the only element we currently have in our widget doesn’t have a visual representation, this tab is currently empty.</li>
<li><strong class="bold">Details</strong> – This tab shows you the properties of the UI element you have currently selected. If you select the existing <strong class="bold">Canvas Panel</strong> element, all the options in the preceding screenshot should appear.</li>
<li>Because<a id="_idIndexMarker594"/> this asset is a <strong class="source-inline">Widget Blueprint</strong> asset, these two buttons allow you to switch between the <strong class="bold">Designer</strong> view, which is the one presented in the screenshot, and the <strong class="bold">Graph</strong> view, which looks exactly like the window of a normal blueprint class.</li>
</ul>
<ol>
<li value="5">Now, let’s<a id="_idIndexMarker595"/> look at some of the available UI elements in our <strong class="bold">Widget</strong>, starting with the <strong class="source-inline">Canvas Panel</strong> element.</li>
<li>Usually, <strong class="bold">Canvas Panel</strong> elements are added to the root of Widget Blueprints because they allow you to drag a UI element to any position you want in the <strong class="bold">Designer</strong> tab. This way, you can lay out these elements as you wish: at the center of the screen, in the upper-left corner, at the bottom center of the screen, and more. Now, let’s drag another very important UI element into our widget: a <strong class="bold">Button</strong> element. In order to add a <strong class="bold">Canvas Panel</strong> element to your widget, go to the <strong class="bold">Panel</strong> category inside the <strong class="bold">Palette</strong> window and drag a <strong class="bold">Canvas Panel</strong> element into your widget’s root inside the <strong class="bold">Hierarchy</strong> window (the first piece of text that says <strong class="bold">[TestWidget]</strong>) or inside the <strong class="bold">Designer</strong> window:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 8.3 – Dragging the Canvas Panel element into the Hierarchy window " height="943" src="image/Figure_8.03_B18531.jpg" width="800"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Dragging the Canvas Panel element into the Hierarchy window</p>
<ol>
<li value="7">In<a id="_idIndexMarker596"/> the <strong class="bold">Palette</strong> tab, find the <strong class="bold">Button</strong> element <a id="_idIndexMarker597"/>and drag it into the <strong class="bold">Designer</strong> window (hold the left mouse button while you drag):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 8.4 – A Button element being dragged from the Palette window into the Designer window " height="1013" src="image/Figure_8.04_B18531.jpg" width="677"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – A Button element being dragged from the Palette window into the Designer window</p>
<p>Once <a id="_idIndexMarker598"/>you have<a id="_idIndexMarker599"/> done this, you’ll be able to resize the button to the size you want by dragging the little white dots around it (keep in mind that you’ll only be able to do this to an element that is inside a <strong class="bold">Canvas Panel</strong> element):</p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 8.5 – The result of resizing a UI element using the white dots around it " height="504" src="image/Figure_8.05_B18531.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The result of resizing a UI element using the white dots around it</p>
<p>Another <a id="_idIndexMarker600"/>way for you to drag <a id="_idIndexMarker601"/>elements inside each other in a widget is to drag them inside the <strong class="bold">Hierarchy</strong> tab instead of the <strong class="bold">Designer</strong> tab.</p>
<ol>
<li value="8">Now drag a <strong class="source-inline">Text</strong> element inside our <strong class="bold">Button</strong> element, but this time, use the <strong class="bold">Hierarchy</strong> tab:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 8.6 – Dragging a Text element from the Palette window into the Hierarchy window " height="376" src="image/Figure_8.06_B18531.jpg" width="294"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Dragging a Text element from the Palette window into the Hierarchy window</p>
<p><strong class="source-inline">Text</strong> elements <a id="_idIndexMarker602"/>can contain text specified by you with a certain size and font that you can modify in the <strong class="source-inline">Details</strong> panel. After you’ve dragged the <strong class="source-inline">Text</strong> element inside the <strong class="source-inline">Button</strong> element using the <strong class="source-inline">Hierarchy</strong> tab, this is what the <strong class="source-inline">Designer</strong> tab should look like:</p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 8.7 – The Button element in the Designer tab, after adding a Text element as its child " height="95" src="image/Figure_8.07_B18531.jpg" width="187"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – The Button element in the Designer tab, after adding a Text element as its child</p>
<p>Let’s change<a id="_idIndexMarker603"/> a few properties of the preceding <strong class="source-inline">Text</strong> block. </p>
<ol>
<li value="9">Select it in either the <strong class="source-inline">Hierarchy</strong> tab or the <strong class="bold">Designer</strong> tab, and take a look at the <strong class="bold">Details</strong> panel:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 8.8 – The Details panel, showing the properties of the Text element we added " height="404" src="image/Figure_8.08_B18531.jpg" width="465"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The Details panel, showing the properties of the Text element we added</p>
<p>Here, you’ll find <a id="_idIndexMarker604"/>several properties that you can edit to your liking. For now, we just want to focus on two of them: the content of the text and its color and opacity.</p>
<ol>
<li value="10">Update the <strong class="bold">Content</strong> tab of the <strong class="bold">Text</strong> <strong class="bold">element</strong> from <strong class="bold">Text Block</strong> to <strong class="bold">Button 1</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer210">
<img alt="Figure 8.9 – Changing the Text property of the Text element to Button 1 " height="54" src="image/Figure_8.09_B18531.jpg" width="437"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Changing the Text property of the Text element to Button 1</p>
<p>Next, let’s change the <strong class="source-inline">Color and Opacity</strong> property setting from <strong class="source-inline">White</strong> to <strong class="source-inline">Black</strong>. </p>
<ol>
<li value="11">Click on<a id="_idIndexMarker605"/> the <strong class="bold">Color and Opacity </strong>property and take a look at the window that pops up: <strong class="bold">Color Picker</strong>. This window pops up whenever you edit a <strong class="source-inline">Color</strong> property in UE5. It allows you to input colors in many different ways, including a color wheel, <strong class="bold">Saturation</strong> and <strong class="bold">Value</strong> bars, <strong class="bold">RGB </strong>and <strong class="bold">HSV</strong> value sliders, and more.</li>
<li>For now, change<a id="_idIndexMarker606"/> the color from white to black by dragging the <strong class="bold">Value</strong> bar (the one that goes from white to black from top to bottom) all the way to the bottom and then pressing <strong class="bold">OK</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 8.10 – Selecting the color black in the Color Picker window " height="533" src="image/Figure_8.10_B18531.jpg" width="433"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Selecting the color black in the Color Picker window</p>
<ol>
<li value="13">After these changes, this is what the button should look like:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer212">
<img alt="Figure 8.11 – The Button element after we change the Text element’s Text property and its color " height="75" src="image/Figure_8.11_B18531.jpg" width="163"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – The Button element after we change the Text element’s Text property and its color</p>
<p>And with that, we <a id="_idIndexMarker607"/>conclude our <a id="_idIndexMarker608"/>first exercise of this chapter. You now know some of the essential basics of UMG, such as how to add <strong class="source-inline">Button</strong> and <strong class="source-inline">Text</strong> elements to your widgets.</p>
<p>Before we jump into our next exercise, first, let’s learn about anchors.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor174"/>Introducing anchors</h1>
<p>As you might<a id="_idIndexMarker609"/> be aware, video games are played on many different screen sizes with many different resolutions. Because of that, it is important to make sure that the menus you create can adapt to all these different resolutions effectively. That is the main purpose of <strong class="bold">Anchors</strong>.</p>
<p>Anchors allow you to specify how you want a UI element’s size to adapt as the screen resolution changes by specifying the proportion of the screen you want it to occupy. Using anchors, you can always have a UI element in the upper-left corner of the screen, or always occupying half of the screen, no matter the size and resolution of that screen.</p>
<p>As the size of the screen or resolution changes, your widget will scale and move relative to its anchor. Only elements that are direct children of a <strong class="source-inline">Canvas Panel</strong> element can have an anchor, which you can visualize through <a id="_idIndexMarker610"/>the <strong class="bold">Anchor Medallion</strong> (which is a white flower-like shape in the <strong class="source-inline">Designer</strong> tab) when you select said element:</p>
<div>
<div class="IMG---Figure" id="_idContainer213">
<img alt="Figure 8.12 – The Anchor Medallion in the upper-left corner of the outline, as shown in the Designer window " height="354" src="image/Figure_8.12_B18531.jpg" width="549"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – The Anchor Medallion in the upper-left corner of the outline, as shown in the Designer window</p>
<p>By default, the <a id="_idIndexMarker611"/>anchor is collapsed into the upper-left corner, which means that you won’t have much control over how the button is scaled as the resolution changes. Let’s change that in the next exercise.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor175"/>Exercise 8.02 – editing UMG anchors</h2>
<p>In this exercise, we<a id="_idIndexMarker612"/> will be changing the anchors in our widget in order to have our button’s size and shape adapt to a wide range of screen resolutions and sizes.</p>
<p>The following <a id="_idIndexMarker613"/>steps will help you to complete this exercise:</p>
<ol>
<li value="1">Select the button we created in the previous exercise. Then, head to the <strong class="bold">Details</strong> panel and press the very first property you see: the <strong class="bold">Anchors</strong> property. Here, you’ll be able to see the <strong class="source-inline">Anchor</strong> presets, which will align the UI element according to the pivots shown.</li>
</ol>
<p>We’ll want to have our button centered on the screen.</p>
<ol>
<li value="2">Click on the pivot that’s at the center of the screen:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer214">
<img alt="Figure 8.13 – The button’s Anchors property, with the center Anchor preset outlined in a box " height="342" src="image/Figure_8.13_B18531.jpg" width="285"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – The button’s Anchors property, with the center Anchor preset outlined in a box</p>
<p>You’ll see<a id="_idIndexMarker614"/> that <a id="_idIndexMarker615"/>our Anchor Medallion has now changed places:</p>
<div>
<div class="IMG---Figure" id="_idContainer215">
<img alt="Figure 8.14 – The Anchor Medallion after we change the button’s Anchor property to the center " height="542" src="image/Figure_8.14_B18531.jpg" width="932"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – The Anchor Medallion after we change the button’s Anchor property to the center</p>
<p>Now that the Anchor Medallion is at the center of the screen, we still won’t have much control over how the button will scale across different resolutions, but at least <a id="_idIndexMarker616"/>we know that it’ll scale relative to the center of the screen.</p>
<p>In order to <a id="_idIndexMarker617"/>have our button centered on the screen, we’ll have to change the button’s position to be at the center of the screen, too.</p>
<ol>
<li value="3">Repeat the previous step of picking the center anchor, but this time, before you select it, hold the <em class="italic">Ctrl</em> key in order to snap the button’s position to this anchor. After you click on it, release the <em class="italic">Ctrl</em> key. You should see a result similar to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer216">
<img alt="Figure 8.15 – The Button element being moved near its selected anchor in the center " height="125" src="image/Figure_8.15_B18531.jpg" width="213"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – The Button element being moved near its selected anchor in the center</p>
<p>As you can see from the preceding screenshot, our button has changed position, but it isn’t properly centered on the screen yet. That is because of its alignment.</p>
<p>The <strong class="source-inline">Alignment</strong> property is of the <strong class="source-inline">Vector2D</strong> type (a tuple with two <strong class="source-inline">float</strong> properties: <strong class="source-inline">X</strong> and <strong class="source-inline">Y</strong>) and dictates the center of the UI element relative to its total size. By default, it’s set to <strong class="source-inline">(0,0)</strong>, meaning the center of the element is its upper-left corner, which explains the result in the preceding screenshot. It can go all the way to <strong class="source-inline">(1,1)</strong>, which is the lower-right corner. In this case, given that we want the alignment to center the button, we want it to be <strong class="source-inline">(0.5, 0.5)</strong>. </p>
<ol>
<li value="4">In order to update a UI element’s alignment when picking an <strong class="source-inline">Anchor</strong> point, you have to hold the <em class="italic">Shift</em> key and repeat the previous step. Alternately, to update both the position and the alignment of the button, picking the center <strong class="source-inline">Anchor</strong> point <a id="_idIndexMarker618"/>while holding both the <em class="italic">Ctrl</em> and <em class="italic">Shift</em> keys <a id="_idIndexMarker619"/>will do the job. The following screenshot should then be the result:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 8.16 – The Button element being centered relative to its selected Anchor point in the center " height="127" src="image/Figure_8.16_B18531.jpg" width="242"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – The Button element being centered relative to its selected Anchor point in the center</p>
<p>At this point, when changing the resolution of the screen, we know that this button will always remain at the center of the screen. However, in order to maintain the button’s size relative to the resolution, we’ll need to make a few more modifications.</p>
<ol>
<li value="5">Drag the lower-right <em class="italic">petal</em> of the Anchor Medallion all the way to the lower-right corner of the button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 8.17 – Dragging the lower-right petal of the Anchor Medallion to update the Button element’s Anchor point " height="226" src="image/Figure_8.17_B18531.jpg" width="474"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Dragging the lower-right petal of the Anchor Medallion to update the Button element’s Anchor point</p>
<ol>
<li value="6">Drag the upper-left <em class="italic">petal</em> of the Anchor Medallion all the way to the upper-left corner <a id="_idIndexMarker620"/>of the<a id="_idIndexMarker621"/> button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer219">
<img alt="Figure 8.18 – Dragging the upper-left petal of the Anchor Medallion to update the Button element’s Anchor " height="267" src="image/Figure_8.18_B18531.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Dragging the upper-left petal of the Anchor Medallion to update the Button element’s Anchor</p>
<p class="callout-heading">Note</p>
<p class="callout">The percentages you see around the button when changing the <strong class="source-inline">Anchor</strong> point are the space the element is occupying on the screen, shown as a percentage. For instance, looking at the preceding screenshot, we can see that the button is occupying <strong class="source-inline">11.9%</strong> of the widget’s space on the <em class="italic">X</em> coordinate and <strong class="source-inline">8.4%</strong> of the widget’s space on the <em class="italic">Y</em> coordinate.</p>
<p class="callout">You can set the size of a UI element to the size of its anchor by holding the <em class="italic">Ctrl</em> key while moving the Anchor Medallion <em class="italic">petals</em>.</p>
<p>Now our button will, finally, adapt to varying screen sizes and resolutions due to these changes to its anchor. </p>
<p>Additionally, you can use the <strong class="source-inline">Details</strong> panel to manually edit all of the properties we just edited by using the Anchor Medallion and moving the button:</p>
<div>
<div class="IMG---Figure" id="_idContainer220">
<img alt="Figure 8.19 – The properties we changed using the Anchor Medallion, as shown in the Details window " height="188" src="image/Figure_8.19_B18531.jpg" width="460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – The properties we changed using the Anchor Medallion, as shown in the Details window</p>
<p>Lastly, we<a id="_idIndexMarker622"/> need to know how we can visualize our <a id="_idIndexMarker623"/>widget with different resolutions in the <strong class="source-inline">Designer</strong> tab.</p>
<ol>
<li value="7">Drag the double arrow in the lower-right corner of the outlined box inside the <strong class="source-inline">Designer</strong> tab:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer221">
<img alt="Figure 8.20 – The double arrow in the lower-right corner of the outlined box inside the Designer tab " height="357" src="image/Figure_8.20_B18531.jpg" width="598"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – The double arrow in the lower-right corner of the outlined box inside the Designer tab</p>
<p>By dragging the double arrow, you can resize the canvas to any screen resolution you want. In the following screenshot, you’ll see the most used resolutions for a variety of devices, and you can preview your widget in each of them:</p>
<div>
<div class="IMG---Figure" id="_idContainer222">
<img alt="Figure 8.21 – The resolutions we can choose to preview in the Designer window " height="569" src="image/Figure_8.21_B18531.jpg" width="995"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – The resolutions we can choose to preview in the Designer window</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find a full reference to UMG’s anchors at <a href="https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors">https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors</a>.</p>
<p>And that <a id="_idIndexMarker624"/>concludes our exercise. You’ve learned about anchors <a id="_idIndexMarker625"/>and how to adapt your widgets to varying screen sizes and resolutions.</p>
<p>Now that we’ve learned about some of the basics of UMG, let’s see how we can create a widget C++ class for this Widget Blueprint. That is what we’re going to do in the next exercise.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor176"/>Exercise 8.03 – creating the RestartWidget C++ class</h2>
<p>In this exercise, we<a id="_idIndexMarker626"/> will learn how to create a widget C++ class, which the Widget Blueprint that we created will inherit from. It will get added<a id="_idIndexMarker627"/> to the screen when the player dies in our <strong class="bold">Dodgeball</strong> game so that the player can have the option to restart the level. This widget will have a button that will restart the level when the player clicks on it.</p>
<p>The first step of this exercise will be adding the UMG-related modules to our project. Unreal Engine comprises several different modules, and in each project, you have to specify which ones you’re going to use. Our project came with a few general modules when the source code files were generated, but we’ll need to add a few more.</p>
<p>The following <a id="_idIndexMarker628"/>steps will help you complete <a id="_idIndexMarker629"/>this exercise:</p>
<ol>
<li value="1">Open the <strong class="source-inline">Dodgeball.build.cs</strong> file, which is a C# file and not a C++ file, located inside your project’s <strong class="source-inline">Source</strong> folder.</li>
<li>Open the file, and you’ll find the <strong class="source-inline">AddRange</strong> function from the <strong class="source-inline">PublicDependency ModuleNames</strong> property being called. This is the function that tells the engine which modules this project intends to use. As a parameter, an array of strings is sent, with the names of all the intended modules for the project. Given that we intend on using UMG, we’ll need to add the UMG-related modules: <strong class="source-inline">UMG</strong>, <strong class="source-inline">Slate</strong>, and <strong class="source-inline">SlateCore</strong>:<p class="source-code">PublicDependencyModuleNames.AddRange(new string[] { "Core", </p><p class="source-code">  "CoreUObject", "Engine", "InputCore", </p><p class="source-code">  "EnhancedInput", "HeadMountedDisplay", "UMG", </p><p class="source-code">  "Slate", "SlateCore" });</p></li>
</ol>
<p>Now that we’ve notified the engine that we’ll be using the UMG modules, let’s create our widget C++ class:</p>
<ol>
<li value="3">Open the Unreal Editor interface.</li>
<li>Right-click on the <strong class="bold">Content Browser</strong> section and select <strong class="bold">New C++ Class</strong>.</li>
<li>Set the <strong class="bold">Show All Classes</strong> checkbox to <strong class="bold">true</strong>.</li>
<li>Search for the <strong class="source-inline">UserWidget</strong> class and choose that as the new class’s parent class.</li>
<li>Name the new C++ class <strong class="source-inline">RestartWidget</strong>. </li>
</ol>
<p>After the files have been opened in Visual Studio, start making modifications to our widget C++ class, as mentioned in the next steps.</p>
<ol>
<li value="8">The <a id="_idIndexMarker630"/>first <a id="_idIndexMarker631"/>thing we’ll add to this class is a <strong class="source-inline">public</strong> <strong class="source-inline">class UButton*</strong> property, called <strong class="source-inline">RestartButton</strong>, which represents the button the player will press in order to restart the level. You will want it to be bound to a button in the blueprint class that inherits from this class, by using the <strong class="source-inline">UPROPERTY</strong> macro with the <strong class="source-inline">BindWidget</strong> meta tag. This will force that Widget Blueprint to have a <strong class="source-inline">Button</strong> element, called <strong class="source-inline">RestartButton</strong>, that we can access in C++ through this property and then freely edit its properties, such as its size and position, in the blueprint:<p class="source-code">UPROPERTY(meta = (BindWidget))</p><p class="source-code">class UButton* RestartButton;</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Using the <strong class="source-inline">BindWidget</strong> meta tag will cause a compilation error if the Widget Blueprint that inherits from this C++ class doesn’t have an element with the same type and name. If you don’t want this to happen, you will have to mark <strong class="source-inline">UPROPERTY</strong> as an optional <strong class="source-inline">BindWidget</strong> like so:</p>
<p class="callout"><strong class="source-inline">UPROPERTY(meta = (BindWidget, OptionalWidget = true))</strong></p>
<p class="callout">This will make it so that binding this property is optional and doesn’t cause a compilation error when compiling the Widget Blueprint.</p>
<p>Next, we’re going to add the function that will be called when the player clicks on the <strong class="source-inline">RestartButton</strong> property, which will restart the level. We will be doing this using the <strong class="source-inline">GameplayStatics</strong> object’s <strong class="source-inline">OpenLevel</strong> function and then sending the name of the current level.</p>
<ol>
<li value="9">In the widget class’s header file, add a declaration for a <strong class="source-inline">protected</strong> function called <strong class="source-inline">OnRestartClicked</strong> that returns nothing and receives no parameters. This function must be marked as <strong class="source-inline">UFUNCTION</strong>:<p class="source-code">protected:</p><p class="source-code">UFUNCTION()</p><p class="source-code">void OnRestartClicked();</p></li>
<li>In<a id="_idIndexMarker632"/> the <a id="_idIndexMarker633"/>class’s source file, add an <strong class="source-inline">include</strong> for the <strong class="source-inline">GameplayStatics</strong> object:<p class="source-code">#include "Kismet/GameplayStatics.h"</p></li>
<li>Then, add an implementation for our <strong class="source-inline">OnRestartClicked</strong> function:<p class="source-code">void URestartWidget::OnRestartClicked()</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Inside this implementation, call the <strong class="source-inline">GameplayStatics</strong> object’s <strong class="source-inline">OpenLevel</strong> function. This function receives, as parameters, a world context object, which will be the <strong class="source-inline">this</strong> pointer, and the name of the level, which we’ll have to fetch using the <strong class="source-inline">GameplayStatics</strong> object’s <strong class="source-inline">GetCurrentLevelName</strong> function. Additionally, this last function must receive a world context object, which will also be the <strong class="source-inline">this</strong> pointer:<p class="source-code">UGameplayStatics::OpenLevel(this, </p><p class="source-code">  FName(*UGameplayStatics::GetCurrentLevelName(</p><p class="source-code">  this)));</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">The call to the <strong class="source-inline">GameplayStatics</strong> object’s <strong class="source-inline">GetCurrentLevelName</strong> function must be preceded with <strong class="source-inline">*</strong> because it returns an <strong class="source-inline">FString</strong> type, UE5’s string type, and must be dereferenced in order to be passed to the <strong class="source-inline">FName</strong> constructor.</p>
<p>The next step will be to bind this function in such a way that it is called when the player presses the <strong class="source-inline">RestartButton</strong> property:</p>
<ol>
<li value="13">In order to do this, we’ll have to override a function that belongs to the <strong class="source-inline">UserWidget</strong> class, called <strong class="source-inline">NativeOnInitialized</strong>. This function is only called once, similarly to the actor’s <strong class="source-inline">BeginPlay</strong> function, which makes it appropriate to do our setup. Add a declaration for the <strong class="source-inline">public</strong> <strong class="source-inline">NativeOnInitialized</strong> function with both the <strong class="source-inline">virtual</strong> and <strong class="source-inline">override</strong> keywords in our widget class’s header file:<p class="source-code">virtual void NativeOnInitialized() override;</p></li>
<li>Next, in <a id="_idIndexMarker634"/>the class’s source file, add the<a id="_idIndexMarker635"/> implementation of this function. Inside it, call its <strong class="source-inline">Super</strong> function and add an <strong class="source-inline">if</strong> statement that checks whether our <strong class="source-inline">RestartButton</strong> property is different from <strong class="source-inline">nullptr</strong>:<p class="source-code">void URestartWidget::NativeOnInitialized()</p><p class="source-code">{</p><p class="source-code">  Super::NativeOnInitialized();</p><p class="source-code">  if (RestartButton != nullptr)</p><p class="source-code">  {</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>If the <strong class="source-inline">if</strong> statement is true, we’ll want to bind our <strong class="source-inline">OnRestartClicked</strong> function to the button’s <strong class="source-inline">OnClicked</strong> event. We can do this by accessing the button’s <strong class="source-inline">OnClicked</strong> property and calling its <strong class="source-inline">AddDynamic</strong> function. This sends, as parameters, the object we want to call that function on, the <strong class="source-inline">this</strong> pointer, and a pointer to the function to be called, that is, the <strong class="source-inline">OnRestartClicked</strong> function:<p class="source-code">if (RestartButton != nullptr)</p><p class="source-code">{</p><p class="source-code">  RestartButton-&gt;OnClicked.AddDynamic(this, </p><p class="source-code">  &amp;URestartWidget::OnRestartClicked);</p><p class="source-code">}</p></li>
<li>Because<a id="_idIndexMarker636"/> we’re accessing functions<a id="_idIndexMarker637"/> related to the <strong class="source-inline">Button</strong> class, we’ll also have to include it:<p class="source-code">#include "Components/Button.h"</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">A button’s <strong class="source-inline">OnClicked</strong> event will be called when the player presses and releases that button with the mouse. There are other events related to the button, including the <strong class="source-inline">OnPressed</strong> event (when the player presses the button), the <strong class="source-inline">OnReleased</strong> event (when the player releases the button), and the <strong class="source-inline">OnHover</strong> and <strong class="source-inline">OnUnhover</strong> events (when the player, respectively, starts and stops hovering the mouse over that button).</p>
<p class="callout">The <strong class="source-inline">AddDynamic</strong> function must receive, as a parameter, a pointer to a function marked with the <strong class="source-inline">UFUNCTION</strong> macro. If it doesn’t, you will get an error when calling that function. This is why we marked the <strong class="source-inline">OnRestartClicked</strong> function with the <strong class="source-inline">UFUNCTION</strong> macro. </p>
<p>After you’ve done these steps, compile your changes and open the editor. </p>
<ol>
<li value="17">Open the <strong class="source-inline">TestWidget</strong> Widget Blueprint that you created earlier. We’ll want to associate this Widget Blueprint with the <strong class="source-inline">RestartWidget</strong> class we just created, so we need to reparent it. </li>
<li>From the Widget Blueprint’s <strong class="bold">File</strong> tab, select the <strong class="bold">Reparent Blueprint</strong> option and choose the <strong class="source-inline">RestartWidget</strong> C++ class as its new parent class:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer223">
<img alt="Figure 8.22 – Reparenting the TestWidget’s class to RestartWidget " height="1267" src="image/Figure_8.22_B18531.jpg" width="808"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Reparenting the TestWidget’s class to RestartWidget</p>
<p>You’ll notice<a id="_idIndexMarker638"/> that <a id="_idIndexMarker639"/>the Widget Blueprint now has a compilation error related to the <strong class="source-inline">BindWidget</strong> meta tag that we created in the C++ class:</p>
<div>
<div class="IMG---Figure" id="_idContainer224">
<img alt="Figure 8.23 – Compiler errors after setting the parent class to the RestartWidget class " height="117" src="image/Figure_8.23_B18531.jpg" width="573"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – Compiler errors after setting the parent class to the RestartWidget class</p>
<p>This is caused by the fact that the C++ class couldn’t find a <strong class="source-inline">Button</strong> property called <strong class="source-inline">RestartButton</strong>. </p>
<p>In order to fix this, we’ll need to rename our <strong class="source-inline">Button</strong> element inside the Widget Blueprint to <strong class="source-inline">RestartButton</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer225">
<img alt="Figure 8.24 – Renaming the Button element to RestartButton " height="614" src="image/Figure_8.24_B18531.jpg" width="1575"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – Renaming the Button element to RestartButton</p>
<p>After <a id="_idIndexMarker640"/>you’ve <a id="_idIndexMarker641"/>done this, close the Widget Blueprint and change its name from <strong class="source-inline">TestWidget</strong> to <strong class="source-inline">BP_RestartWidget</strong>, the same way you just did in the previous step.</p>
<p>That concludes the creation of our widget class. Now, you understand how to connect a widget C++ class to a Widget Blueprint, which is a very important step toward handling game UI in UE5.</p>
<p>The next thing we need to do is create our <strong class="source-inline">Player Controller</strong> C++ class, which will be responsible for instantiating our <strong class="source-inline">RestartWidget</strong> class and adding it to the screen. We will be doing this in the following exercise.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor177"/>Exercise 8.04 – creating the logic for adding the RestartWidget class to the screen</h2>
<p>In this exercise, we will <a id="_idIndexMarker642"/>create the logic responsible for adding our newly created <strong class="source-inline">RestartWidget</strong> class to the screen. It will appear on the screen when the player dies so that they have the option to restart the level.</p>
<p>In order to do<a id="_idIndexMarker643"/> this, we’ll have to create a new <strong class="source-inline">Player Controller</strong> C++ class, which you can do by following these steps:</p>
<ol>
<li value="1">Open the Unreal Editor interface.</li>
<li><em class="italic">Right-click</em> on the <strong class="source-inline">Content Browser</strong> section and select <strong class="source-inline">New C++ Class</strong>.</li>
<li>Search for the <strong class="source-inline">Player Controller</strong> class and choose that as the new class’s parent class.</li>
<li>Name the new C++ class <strong class="source-inline">DodgeballPlayerController</strong>.</li>
<li>Open the class’s files in Visual Studio.</li>
</ol>
<p>When our player runs out of health points, the <strong class="source-inline">DodgeballCharacter</strong> class will access this <strong class="source-inline">Player Controller</strong> class and call a function that will add the <strong class="source-inline">RestartWidget</strong> class to the screen. Follow these next steps in order to make this happen.</p>
<p>In order to know the class of the widget to add to the screen (which will be a Widget Blueprint asset and not a Widget C++ class), we’ll need to use the <strong class="source-inline">TSubclassOf</strong> type.</p>
<ol>
<li value="6">In the class’s header file, add a <strong class="source-inline">public</strong> <strong class="source-inline">TSubclassOf&lt;class URestartWidget&gt;</strong> property called <strong class="source-inline">BP_RestartWidget</strong>. Be sure to make it a <strong class="source-inline">UPROPERTY</strong> function with the <strong class="source-inline">EditDefaultsOnly</strong> tag so that we can edit it in the blueprint class:<p class="source-code">public:</p><p class="source-code">UPROPERTY(EditDefaultsOnly)</p><p class="source-code">TSubclassOf&lt;class URestartWidget&gt; BP_RestartWidget;</p></li>
</ol>
<p>In order to instantiate this widget and add it to the screen, we’ll need to save a reference to it.</p>
<ol>
<li value="7">Add a <a id="_idIndexMarker644"/>new <strong class="source-inline">private</strong> variable of the <strong class="source-inline">class URestartWidget*</strong> type and call it <strong class="source-inline">RestartWidget</strong>. Be<a id="_idIndexMarker645"/> sure to make it a <strong class="source-inline">UPROPERTY</strong> function with no tags:<p class="source-code">private:</p><p class="source-code">UPROPERTY()</p><p class="source-code">class URestartWidget* RestartWidget;</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Although this property isn’t supposed to be editable in a blueprint class, we have to make this reference a <strong class="source-inline">UPROPERTY</strong> function; otherwise, the garbage collector will destroy the contents of this variable.</p>
<p>The next thing we need is a function responsible for adding our widget to the screen. </p>
<ol>
<li value="8">Add a declaration for a <strong class="source-inline">public</strong> function that returns nothing and receives no parameters, called <strong class="source-inline">ShowRestartWidget</strong>:<p class="source-code">void ShowRestartWidget();</p></li>
<li>Now, head to our class’s source file. First, add an <strong class="source-inline">include</strong> to the <strong class="source-inline">RestartWidget</strong> class:<p class="source-code">#include "RestartWidget.h"</p></li>
<li>Then, add the implementation of our <strong class="source-inline">ShowRestartWidget</strong> function, where we’ll start by checking whether our <strong class="source-inline">BP_RestartWidget</strong> variable is not a <strong class="source-inline">nullptr</strong> variable:<p class="source-code">void ADodgeballPlayerController::ShowRestartWidget()</p><p class="source-code">{</p><p class="source-code">  if (BP_RestartWidget != nullptr)</p><p class="source-code">  {</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>If that <a id="_idIndexMarker646"/>variable is valid (different from <strong class="source-inline">nullptr</strong>), we want to pause the game using the <strong class="source-inline">SetPause</strong> function of <strong class="bold">Player Controller</strong>. This will ensure that the game stops until<a id="_idIndexMarker647"/> the player decides to do something (which, in our case, will be pressing the button that restarts the level):<p class="source-code">SetPause(true);</p></li>
</ol>
<p>The next thing we’ll do is change the input mode. In UE5, there are three input modes: <strong class="source-inline">Game Only</strong>, <strong class="source-inline">Game and UI</strong>, and <strong class="source-inline">UI Only</strong>. If your Input mode includes <strong class="source-inline">Game</strong>, that means that the player character and the player controller will receive inputs through the input actions. If your <strong class="source-inline">Input</strong> mode includes <strong class="source-inline">UI</strong>, that means that the widgets that are on the screen will receive inputs from the player. When we show this widget on the screen, we won’t want the player character to receive any input.</p>
<ol>
<li value="12">Hence, update to the <strong class="source-inline">UI Only</strong> <strong class="source-inline">Input</strong> mode. You can do this by calling the <strong class="source-inline">Player Controller</strong> <strong class="source-inline">SetInputMode</strong> function and passing the <strong class="source-inline">FInputModeUIOnly</strong> type as a parameter:<p class="source-code">SetInputMode(FInputModeUIOnly());</p></li>
</ol>
<p>Following this, we want to show the mouse cursor so that the player can see which button they are hovering the mouse on.</p>
<ol>
<li value="13">We will do this by setting the <strong class="source-inline">Player Controller</strong> <strong class="source-inline">bShowMouseCursor</strong> property to <strong class="source-inline">true</strong>:<p class="source-code">bShowMouseCursor = true;</p></li>
<li>Now, we <a id="_idIndexMarker648"/>can actually instantiate our<a id="_idIndexMarker649"/> widget using the <strong class="source-inline">Player Controller</strong>’s <strong class="source-inline">CreateWidget</strong> function, passing as a template parameter the C++ Widget class, which, in our case, is <strong class="source-inline">RestartWidget</strong>. Then, as normal parameters, we will pass Owning Player, which is the <strong class="source-inline">Player Controller</strong> class that owns this widget and that we’ll send using the <strong class="source-inline">this</strong> pointer, and the widget class, which will be our <strong class="source-inline">BP_RestartWidget</strong> property:<p class="source-code">RestartWidget = CreateWidget&lt;URestartWidget&gt;(this, </p><p class="source-code">  BP_RestartWidget);</p></li>
<li>After we instantiate the widget, we’ll want to add it to the screen, using the widget’s <strong class="source-inline">AddToViewport</strong> function:<p class="source-code">RestartWidget-&gt;AddToViewport();</p></li>
<li>That concludes our <strong class="source-inline">ShowRestartWidget</strong> function. However, we also need to create the function that will remove the <strong class="source-inline">RestartWidget</strong> class from the screen. In the class’s header file, add a declaration for a function just like the <strong class="source-inline">ShowRestartWidget</strong> function, but this time called <strong class="source-inline">HideRestartWidget</strong>:<p class="source-code">void HideRestartWidget();</p></li>
<li>In the class’s source file, add the implementation for the <strong class="source-inline">HideRestartWidget</strong> function:<p class="source-code">void ADodgeballPlayerController::HideRestartWidget()</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>The first thing we should do in this function is to remove the widget from the screen by calling its <strong class="source-inline">RemoveFromParent</strong> function, and destroy it using the <strong class="source-inline">Destruct</strong> function:<p class="source-code">RestartWidget-&gt;RemoveFromParent();</p><p class="source-code">RestartWidget-&gt;Destruct();</p></li>
<li>Then, we <a id="_idIndexMarker650"/>want to unpause<a id="_idIndexMarker651"/> the game using the <strong class="source-inline">SetPause</strong> function we used in the previous function:<p class="source-code">SetPause(false);</p></li>
<li>Finally, let’s set the <strong class="source-inline">Input</strong> mode to <strong class="source-inline">Game Only</strong> and hide the mouse cursor in the same way we did in the previous function (this time, we pass the <strong class="source-inline">FInputModeGameOnly</strong> type instead):<p class="source-code">SetInputMode(FInputModeGameOnly());</p><p class="source-code">bShowMouseCursor = false;</p></li>
</ol>
<p>And that concludes the logic for our <strong class="source-inline">Player Controller</strong> C++ class. The next thing we should do is call the function that will add our widget to the screen.</p>
<ol>
<li value="21">Go to the <strong class="source-inline">DodgeballCharacter</strong> class’s source file and add the <strong class="source-inline">include</strong> keyword to our newly created <strong class="source-inline">DodgeballPlayerController</strong> class:<p class="source-code">#include "DodgeballPlayerController.h"</p></li>
<li>Within the <strong class="source-inline">DodgeballCharacter</strong> class’s implementation of the <strong class="source-inline">OnDeath_Implementation</strong> function, replace the call to the <strong class="source-inline">QuitGame</strong> function with the following:<ul><li>Get the character’s player controller using the <strong class="source-inline">GetController</strong> function. You’ll want to save the result in a variable of the <strong class="source-inline">DodgeballPlayerController*</strong> type, called <strong class="source-inline">PlayerController</strong>. Because the function will return a variable of the <strong class="source-inline">Controller</strong> type, you’ll also need to cast it to our <strong class="source-inline">PlayerController</strong> class:<p class="source-code">ADodgeballPlayerController* PlayerController = Cast&lt;ADodgeballPlayerController&gt;(GetController());</p></li><li>Check <a id="_idIndexMarker652"/>whether the <strong class="source-inline">PlayerController</strong> variable is valid. If it is, call its <strong class="source-inline">ShowRestartWidget</strong> function:<p class="source-code">if (PlayerController != nullptr)</p><p class="source-code">{</p><p class="source-code">  PlayerController-&gt;ShowRestartWidget();</p><p class="source-code">}</p></li></ul></li>
</ol>
<p>After these<a id="_idIndexMarker653"/> modifications, the last thing left for us to do is to call the function that will hide our widget from the screen. Open the <strong class="source-inline">RestartWidget</strong> class’s source file and implement the following modifications.</p>
<ol>
<li value="23">Add an <strong class="source-inline">include</strong> to the <strong class="source-inline">DodgeballPlayerController</strong> class, which contains the function that we will be calling:<p class="source-code">#include "DodgeballPlayerController.h"</p></li>
<li>Inside the <strong class="source-inline">OnRestartClicked</strong> function implementation, before the call to the <strong class="source-inline">OpenLevel</strong> function, we must fetch the widget’s <strong class="source-inline">OwningPlayer</strong>, which is of the <strong class="source-inline">PlayerController</strong> type, using the <strong class="source-inline">GetOwningPlayer</strong> function, and cast it to the <strong class="source-inline">DodgeballPlayerController</strong> class:<p class="source-code">ADodgeballPlayerController* PlayerController = </p><p class="source-code">  Cast&lt;ADodgeballPlayerController&gt;(GetOwningPlayer());</p></li>
<li>Then, if the <strong class="source-inline">PlayerController</strong> variable is valid, we call its <strong class="source-inline">HideRestartWidget</strong> function:<p class="source-code">if (PlayerController != nullptr)</p><p class="source-code">{</p><p class="source-code">  PlayerController-&gt;HideRestartWidget();</p><p class="source-code">}</p></li>
</ol>
<p>After you’ve <a id="_idIndexMarker654"/>followed all these steps, close<a id="_idIndexMarker655"/> the editor, compile your changes, and open the editor again.</p>
<p>You have now concluded this exercise. We have added all the necessary logic to add our <strong class="source-inline">RestartWidget</strong> class to the screen. The only thing left for us to do is create the blueprint class of our newly created <strong class="source-inline">DodgeballPlayerController</strong> class, which we’ll be doing in the next exercise.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor178"/>Exercise 8.05 – setting up the DodgeballPlayerController blueprint class</h2>
<p>In this<a id="_idIndexMarker656"/> exercise, we will be creating the blueprint class for <strong class="source-inline">DodgeballPlayerController</strong> in order to specify which widget we want to add to the screen. Then, we will tell UE5 to use this blueprint<a id="_idIndexMarker657"/> class when the game starts.</p>
<p>In order to do that, follow these steps:</p>
<ol>
<li value="1">Go to the <strong class="bold">ThirdPersonCPP -&gt; Blueprints</strong> directory in the <strong class="bold">Content Browser</strong> section, right-click on it, and create a new blueprint class.</li>
<li>Search for the <strong class="bold">DodgeballPlayerController</strong> class and select it as the parent class.</li>
<li>Rename this blueprint class to <strong class="source-inline">BP_DodgeballPlayerController</strong>. After that, open this blueprint asset.</li>
<li>Go to its <strong class="source-inline">Class Defaults</strong> tab and set the class’s <strong class="source-inline">BP_RestartWidget</strong> property to the <strong class="source-inline">BP_RestartWidget</strong> Widget Blueprint we created.</li>
</ol>
<p>Now, the only thing left for us to do is to make sure that this <strong class="source-inline">Player Controller</strong> blueprint class is being used in the game.</p>
<p>In order to do this, we’ll have to follow a few more steps.</p>
<ol>
<li value="5">Go to the <strong class="source-inline">ThirdPersonCPP</strong> -&gt; <strong class="source-inline">Blueprints</strong> directory in the <strong class="bold">Content Browser</strong> section, <em class="italic">right-click</em> on it, and create a new blueprint class. Search for the <strong class="source-inline">DodgeballGameMode</strong> class and select it as the parent class. Then, rename this <strong class="source-inline">Blueprint</strong> class to <strong class="source-inline">BP_DodgeballGameMode</strong>.</li>
</ol>
<p>This <a id="_idIndexMarker658"/>class is responsible for telling the game which classes to use for each element of the game, such as which <strong class="source-inline">Player Controller</strong> class to use, among other things.</p>
<ol>
<li value="6">Open the asset, go to its <strong class="bold">Class Defaults</strong> tab, and set the class’s <strong class="source-inline">PlayerControllerClass</strong> property to the <strong class="source-inline">BP_DodgeballPlayerController</strong> class we just created:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer226">
<img alt="Figure 8.25 – Setting the PlayerControllerClass property to BP_DodgeballPlayerController " height="276" src="image/Figure_8.25_B18531.jpg" width="540"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.25 – Setting the PlayerControllerClass property to BP_DodgeballPlayerController</p>
<ol>
<li value="7">Close the <a id="_idIndexMarker659"/>asset and select the <strong class="bold">Blueprints</strong> drop-down option inside the editor toolbar that is at the top of the <strong class="bold">Level Viewport</strong> window. From there, select the second <strong class="bold">Game Mode</strong> option, inside the <strong class="bold">World Override</strong> category (which should, currently, be set to <strong class="bold">DodgeballGameMode</strong>), <strong class="bold">-&gt; Select GameModeBase Class -&gt; BP_DodgeballGameMode</strong>. This will tell the editor to use this new <strong class="bold">Game Mode</strong> option in the current level.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Additionally, you can set the <strong class="bold">Game Mode</strong> option inside the <strong class="bold">Project Settings</strong> category, which will tell the editor to use that <strong class="bold">Game Mode</strong> option on all levels. However, if a level overrides this option by setting the <strong class="bold">Game Mode</strong> option in the <strong class="bold">World Override</strong> category, that option will be ignored.</p>
<p>Now, play<a id="_idIndexMarker660"/> the game and let your character get hit by a dodgeball <strong class="source-inline">three</strong> times. After the third time, you should see the game get paused and show <strong class="source-inline">BP_RestartWidget</strong>: </p>
<div>
<div class="IMG---Figure" id="_idContainer227">
<img alt="Figure 8.26 – Our BP_RestartWidget property being added to the screen after the player runs out of health points " height="507" src="image/Figure_8.26_B18531.jpg" width="656"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.26 – Our BP_RestartWidget property being added to the screen after the player runs out of health points</p>
<p>And <a id="_idIndexMarker661"/>when you click on <strong class="source-inline">Button 1</strong> using your mouse, you should see the level reset to its initial state:</p>
<div>
<div class="IMG---Figure" id="_idContainer228">
<img alt="Figure 8.27 – The level restarts after the player presses the button shown in the previous screenshot " height="449" src="image/Figure_8.27_B18531.jpg" width="551"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.27 – The level restarts after the player presses the button shown in the previous screenshot</p>
<p>And<a id="_idIndexMarker662"/> that<a id="_idIndexMarker663"/> concludes our exercise. Now you know how to create widgets and show them in your game. This is another crucial step in your journey toward becoming a skilled game developer.</p>
<p>Before we move on to the next exercise, in the next section, let’s take a look at progress bars.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor179"/>Understanding progress bars</h1>
<p>One<a id="_idIndexMarker664"/> of the ways that video games can represent character stats such as health, stamina, and more is through <strong class="bold">Progress Bars</strong>, which are what we’ll use to communicate to the player how much health their character has. Essentially, progress bars are a shape, usually rectangular, that can be filled and emptied in order to show the player how a specific stat is progressing. If you want to show the player that their character’s health is only half its maximum value, you could do this by showing the progress bar as half full. In this section, that is exactly what we’ll be doing. This progress bar will be the only element in our <strong class="bold">Dodgeball</strong> game’s HUD.</p>
<p>In order to <a id="_idIndexMarker665"/>create this <strong class="bold">Health Bar</strong> progress bar, first, we’ll need to create our HUD widget. Open the editor, go to the <strong class="source-inline">ThirdPersonCPP</strong> -&gt; <strong class="source-inline">Blueprints</strong> directory inside the <strong class="bold">Content Browser</strong> section, and right-click to create a new <strong class="source-inline">Widget Blueprint</strong> class from the <strong class="source-inline">User Interface</strong> category. Then, select <strong class="bold">User Widget</strong> from the list of parent classes available. Name this new Widget Blueprint <strong class="source-inline">BP_HUDWidget</strong>. After that, open the new Widget Blueprint.</p>
<p>Add a <strong class="source-inline">Canvas Panel</strong> element to the root of this widget, just like we did in <em class="italic">step 6</em> of <em class="italic">Exercise 8.01 – improving the RestartWidget class</em>.</p>
<p>In UE5, progress bars <a id="_idIndexMarker666"/>are just another UI element, such as <strong class="source-inline">Button</strong> elements and <strong class="source-inline">Text</strong> elements, which means we can drag them from the <strong class="bold">Palette</strong> tab into our <strong class="bold">Designer</strong> tab. Take a look at the following example:</p>
<div>
<div class="IMG---Figure" id="_idContainer229">
<img alt="Figure 8.28 – Dragging a Progress Bar element into the Designer window " height="379" src="image/Figure_8.28_B18531.jpg" width="748"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.28 – Dragging a Progress Bar element into the Designer window</p>
<p>At first, this progress bar might look similar to a button; however, it contains two specific properties that are important for a progress bar:</p>
<ul>
<li><strong class="bold">Percent</strong> – This allows <a id="_idIndexMarker667"/>you to specify this progress bar’s progress, from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>.</li>
<li><strong class="bold">Bar Fill Type</strong> – This<a id="_idIndexMarker668"/> allows you to specify how you want this progress bar to fill (from left to right, top to bottom, and so on):</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer230">
<img alt="Figure 8.29 – The progress bar’s Percent and Bar Fill Type properties " height="80" src="image/Figure_8.29_B18531.jpg" width="459"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.29 – The progress bar’s Percent and Bar Fill Type properties</p>
<p>If you set<a id="_idIndexMarker669"/> the <strong class="bold">Percent</strong> property to <strong class="source-inline">0.5</strong>, the progress bar will be updated accordingly to fill half of its length:</p>
<div>
<div class="IMG---Figure" id="_idContainer231">
<img alt="Figure 8.30 – The progress bar filled halfway to the right " height="291" src="image/Figure_8.30_B18531.jpg" width="356"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.30 – The progress bar filled halfway to the right</p>
<p>Before you continue, set the <strong class="bold">Percent</strong> property to <strong class="source-inline">1</strong>.</p>
<p>Now, let’s change the progress bar’s color from blue (its default color) to red. In order to do this, go to the <strong class="bold">Details</strong> tab and, inside the <strong class="bold">Appearance</strong> category, set the <strong class="bold">Fill Color and Opacity</strong> property to red (<strong class="source-inline">RGB(1,0,0)</strong>):</p>
<div>
<div class="IMG---Figure" id="_idContainer232">
<img alt="Figure 8.31 – The progress bar’s color being changed to red " height="56" src="image/Figure_8.31_B18531.jpg" width="459"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.31 – The progress bar’s color being changed to red</p>
<p>After you’ve done this, your progress bar should now use red as its fill color.</p>
<p>To conclude <a id="_idIndexMarker670"/>our progress bar’s setup, let’s update its position, size, and anchors. Follow these steps to achieve this:</p>
<ol>
<li value="1">In the <strong class="bold">Slot </strong>(<strong class="bold">Canvas Panel Slot</strong>) category, expand the <strong class="bold">Anchors</strong> property and set its properties to these values:<ul><li><strong class="bold">Minimum</strong>: <strong class="bold">0.052</strong> on the <strong class="source-inline">X</strong> axis, and <strong class="source-inline">0.083</strong> on the <strong class="source-inline">Y</strong> axis</li><li><strong class="bold">Maximum</strong>: <strong class="source-inline">0.208</strong> on the <strong class="source-inline">X</strong> axis, and <strong class="source-inline">0.116</strong> on the <strong class="source-inline">Y</strong> axis</li></ul></li>
<li>Set the <strong class="bold">Offset Left</strong>, <strong class="bold">Offset Top</strong>, <strong class="bold">Offset Right</strong>, and <strong class="bold">Offset Bottom</strong> properties to <strong class="source-inline">0</strong>.</li>
</ol>
<p>Your<a id="_idIndexMarker671"/> progress bar should now look like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer233">
<img alt="Figure 8.32 – The progress bar after all the modifications in this section have been completed  " height="238" src="image/Figure_8.32_B18531.jpg" width="552"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.32 – The progress bar after all the modifications in this section have been completed </p>
<p>And with that, we can conclude the topic of progress bars. Our next step is going to be to add all the logic necessary to use this progress bar as a health bar, by updating its <strong class="bold">Percent</strong> property alongside the player character’s health. In the next exercise, we’ll do exactly that.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor180"/>Exercise 8.06 – creating the health bar C++ logic</h2>
<p>In this <a id="_idIndexMarker672"/>exercise, we will be adding all the necessary <a id="_idIndexMarker673"/>C++ logic to update the progress bar inside our HUD as the player character’s health changes.</p>
<p>In order to do this, follow these steps:</p>
<ol>
<li value="1">Open the editor and create a new C++ class that inherits from <strong class="source-inline">UserWidget</strong>, similar to how we did in <em class="italic">Exercise 8.03 – creating the RestartWidget C++ class</em>. However, this time, call it <strong class="source-inline">HUDWidget</strong>. This will be the C++ class that will be used for our HUD widget.</li>
<li>In the <strong class="source-inline">HUDWidget</strong> class’s header file, add a new <strong class="source-inline">public</strong> property of the <strong class="source-inline">class UProgressBar*</strong> type called <strong class="source-inline">HealthBar</strong>. This type is used to represent a progress bar, like the one we created in the previous section, in C++. Be sure to declare this property as a <strong class="source-inline">UPROPERTY</strong> function with the <strong class="source-inline">BindWidget</strong> tag:<p class="source-code">UPROPERTY(meta = (BindWidget))</p><p class="source-code">class UProgressBar* HealthBar;</p></li>
<li>Add <a id="_idIndexMarker674"/>a declaration for a <strong class="source-inline">public</strong> function, called <strong class="source-inline">UpdateHealthPercent</strong>, which returns nothing and <a id="_idIndexMarker675"/>receives a <strong class="source-inline">float HealthPercent</strong> property as a parameter. This function will be called in order to update the <strong class="bold">Percent</strong> property of our progress bar:<p class="source-code">void UpdateHealthPercent(float HealthPercent);</p></li>
<li>In the <strong class="source-inline">HUDWidget</strong> class’s source file, add the implementation for the <strong class="source-inline">UpdateHealthPercent</strong> function, which will call the <strong class="source-inline">HealthBar</strong> property’s <strong class="source-inline">SetPercent</strong> function, passing the <strong class="source-inline">HealthPercent</strong> property as a parameter:<p class="source-code">void UHUDWidget::UpdateHealthPercent(float HealthPercent)</p><p class="source-code">{</p><p class="source-code">  HealthBar-&gt;SetPercent(HealthPercent);</p><p class="source-code">}</p></li>
<li>Because we’ll be using the <strong class="source-inline">ProgressBar</strong> C++ class, we’ll need to add an <strong class="source-inline">include</strong> to it at the top of the class’s source file:<p class="source-code">#include "Components/ProgressBar.h"</p></li>
</ol>
<p>The next step will be to add all the necessary logic to our <strong class="source-inline">Player Controller</strong> class, which is responsible for adding the <strong class="source-inline">HUDWidget</strong> class to the screen. Implement the following steps in order to achieve this:</p>
<ol>
<li value="6">Inside the <strong class="source-inline">DodgeballPlayerController</strong> class’s header file, add a <strong class="source-inline">public</strong> property of the <strong class="source-inline">TSubclassOf&lt;class UHUDWidget&gt;</strong> type, called <strong class="source-inline">BP_HUDWidget</strong>. Be sure to mark it as a <strong class="source-inline">UPROPERTY</strong> function with the <strong class="source-inline">EditDefaultsOnly</strong> tag.</li>
</ol>
<p>This<a id="_idIndexMarker676"/> property will allow us to specify, in the <strong class="source-inline">DodgeballPlayerController</strong> blueprint class, which widget we want to use as our HUD:</p>
<p class="source-code">UPROPERTY(EditDefaultsOnly)</p>
<p class="source-code">TSubclassOf&lt;class UHUDWidget&gt; BP_HUDWidget;</p>
<ol>
<li value="7">Add <a id="_idIndexMarker677"/>another property, this time <strong class="source-inline">private</strong>, of the <strong class="source-inline">class UHUDWidget*</strong> type, called <strong class="source-inline">HUDWidget</strong>. Mark it as a <strong class="source-inline">UPROPERTY</strong> function, but without any tags:<p class="source-code">UPROPERTY()</p><p class="source-code">class UHUDWidget* HUDWidget;</p></li>
<li>Add a <strong class="source-inline">protected</strong> declaration for the <strong class="source-inline">BeginPlay</strong> function, and mark it as both <strong class="source-inline">virtual</strong> and <strong class="source-inline">override</strong>:<p class="source-code">virtual void BeginPlay() override;</p></li>
<li>Add a declaration for a new <strong class="source-inline">public</strong> function, called <strong class="source-inline">UpdateHealthPercent</strong>, which returns nothing and receives <strong class="source-inline">float HealthPercent</strong> as a parameter.</li>
</ol>
<p>This function will be called by our player character class in order to update the health bar in our HUD:</p>
<p class="source-code">void UpdateHealthPercent(float HealthPercent);</p>
<ol>
<li value="10">Now head over to the <strong class="source-inline">DodgeballPlayerController</strong> class’s source file. Start by adding an <strong class="source-inline">include</strong> to our <strong class="source-inline">HUDWidget</strong> class:<p class="source-code">#include "HUDWidget.h"</p></li>
<li>Then, add the implementation for the <strong class="source-inline">BeginPlay</strong> function, where we’ll start by calling the <strong class="source-inline">Super</strong> object’s <strong class="source-inline">BeginPlay</strong> function:<p class="source-code">void ADodgeballPlayerController::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">}</p></li>
<li>After<a id="_idIndexMarker678"/> that function call, check whether<a id="_idIndexMarker679"/> the <strong class="source-inline">BP_HUDWidget</strong> property is valid. If it is, call the <strong class="source-inline">CreateWidget</strong> function with the <strong class="source-inline">UHUDWidget</strong> template parameter and pass <strong class="source-inline">Owning Player</strong>, <strong class="source-inline">this</strong>, and the <strong class="source-inline">BP_HUDWidget</strong> widget class, as parameters. Be sure to set the <strong class="source-inline">HUDWidget</strong> property to the return value of this function call:<p class="source-code">if (BP_HUDWidget != nullptr)</p><p class="source-code">{</p><p class="source-code">  HUDWidget = CreateWidget&lt;UHUDWidget&gt;(this, </p><p class="source-code">  BP_HUDWidget);</p><p class="source-code">}</p></li>
<li>After setting the <strong class="source-inline">HUDWidget</strong> property, call its <strong class="source-inline">AddToViewport</strong> function:<p class="source-code">HUDWidget-&gt;AddToViewport();</p></li>
<li>Lastly, add the implementation for the <strong class="source-inline">UpdateHealthPercent</strong> function, where we’ll check whether the <strong class="source-inline">HUDWidget</strong> property is valid. If it is, call its <strong class="source-inline">UpdateHealthPercent</strong> function and pass the <strong class="source-inline">HealthPercent</strong> property as a parameter:<p class="source-code">void ADodgeballPlayerController::UpdateHealthPercent(float </p><p class="source-code">  HealthPercent)</p><p class="source-code">{</p><p class="source-code">  if (HUDWidget != nullptr)</p><p class="source-code">  {</p><p class="source-code">    HUDWidget-&gt;UpdateHealthPercent(HealthPercent);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>Now <a id="_idIndexMarker680"/>that we’ve added the logic responsible<a id="_idIndexMarker681"/> for adding the HUD to the screen and allowing it to be updated, we’ll need to make some modifications to the other classes. Follow the next steps in order to do so.</p>
<p>Currently, our <strong class="source-inline">Health</strong> interface, which we created in the previous chapter, only has the <strong class="source-inline">OnDeath</strong> event, which is called whenever an object runs out of health points. In order to update our health bar every time the player takes damage, we need to allow our <strong class="source-inline">HealthInterface</strong> class to notify an object whenever that happens.</p>
<ol>
<li value="15">Open the <strong class="source-inline">HealthInterface</strong> class’s header file and add a declaration similar to the one we did for the <strong class="source-inline">OnDeath</strong> event in <em class="italic">Exercise 7.04 – creating the HealthInterface class</em>, but this time for the <strong class="source-inline">OnTakeDamage</strong> event. This event will be called whenever an object takes damage:<p class="source-code">UFUNCTION(BlueprintNativeEvent, Category = Health)</p><p class="source-code">void OnTakeDamage();</p><p class="source-code">virtual void OnTakeDamage_Implementation() = 0;</p></li>
<li>Now that we have added this event to our <strong class="source-inline">Interface</strong> class, let’s add the logic that calls that event: open the <strong class="source-inline">HealthComponent</strong> class’s source file and, inside its implementation of the <strong class="source-inline">LoseHealth</strong> function, after subtracting the <strong class="source-inline">Amount</strong> property from the <strong class="source-inline">Health</strong> property, check whether the <strong class="source-inline">Owner</strong> implements the <strong class="source-inline">Health</strong> interface and, if it does, call its <strong class="source-inline">OnTakeDamage</strong> event. Do this the same way we already did later in that same function for our <strong class="source-inline">OnDeath</strong> event, but this time, simply change the name of the event to <strong class="source-inline">OnTakeDamage</strong>:<p class="source-code">if (GetOwner()-&gt;Implements&lt;UHealthInterface&gt;())</p><p class="source-code">{</p><p class="source-code">  IHealthInterface::Execute_OnTakeDamage(GetOwner());</p><p class="source-code">}</p></li>
</ol>
<p>Because <a id="_idIndexMarker682"/>our health bar will require<a id="_idIndexMarker683"/> the player character’s health points as a percentage, we need to perform the following steps.</p>
<ol>
<li value="17">Add a <strong class="source-inline">public</strong> function to our <strong class="source-inline">HealthComponent</strong> class that returns just that: in the <strong class="source-inline">HealthComponent</strong> class’s header file, add a declaration for a <strong class="source-inline">FORCEINLINE</strong> function that returns a <strong class="source-inline">float</strong> property. This function should be called <strong class="source-inline">GetHealthPercent</strong> and be a <strong class="source-inline">const</strong> function. Its implementation will simply consist of returning the <strong class="source-inline">Health</strong> property divided by <strong class="source-inline">100</strong>, which we will assume is the maximum amount of health points an object can have in our game:<p class="source-code">FORCEINLINE float GetHealthPercent() const { return Health / </p><p class="source-code">  100.f; }</p></li>
<li>Now go to the <strong class="source-inline">DodgeballCharacter</strong> class’s header file and add a declaration for a <strong class="source-inline">public</strong> <strong class="source-inline">virtual</strong> function called <strong class="source-inline">OnTakeDamage_Implementation</strong>, which returns nothing and receives no parameters. Mark it as <strong class="source-inline">virtual</strong> and <strong class="source-inline">override</strong>:<p class="source-code">virtual void OnTakeDamage_Implementation() override;</p></li>
<li>In the <strong class="source-inline">DodgeballCharacter</strong> class’s source file, add an implementation for the <strong class="source-inline">OnTakeDamage_Implementation</strong> function we just declared. Copy the content of the <strong class="source-inline">OnDeath_Implementation</strong> function to this new function’s implementation, but make this change: instead of calling the <strong class="source-inline">ShowRestartWidget</strong> function of <strong class="source-inline">PlayerController</strong>, call its <strong class="source-inline">UpdateHealthPercent</strong> function, and pass the return value of the <strong class="source-inline">HealthComponent</strong> property’s <strong class="source-inline">GetHealthPercent</strong> function as a parameter:<p class="source-code">void ADodgeballCharacter::OnTakeDamage_Implementation()</p><p class="source-code">{</p><p class="source-code">  ADodgeballPlayerController* PlayerController = </p><p class="source-code">  Cast&lt;ADodgeballPlayerController&gt;(GetController());</p><p class="source-code">  if (PlayerController != nullptr)</p><p class="source-code">  {</p><p class="source-code">    PlayerController-&gt;</p><p class="source-code">    UpdateHealthPercent(HealthComponent</p><p class="source-code">    -&gt;GetHealthPercent());</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>This<a id="_idIndexMarker684"/> concludes this exercise’s code setup. After<a id="_idIndexMarker685"/> you’ve done these changes, compile your code, open the editor, and perform the following steps.</p>
<ol>
<li value="20">Open the <strong class="source-inline">BP_HUDWidget</strong> Widget Blueprint and reparent it to the <strong class="source-inline">HUDWidget</strong> class, in the same way you did in <em class="italic">Exercise 8.03 – creating the RestartWidget C++ class</em>.</li>
<li>This should cause a compilation error, which you’ll be able to fix by renaming our progress bar element to <strong class="source-inline">HealthBar</strong>.</li>
<li>Close this Widget Blueprint, open the <strong class="source-inline">BP_DodgeballPlayerController</strong> blueprint class, and set its <strong class="source-inline">BP_HUDWidget</strong> property to the <strong class="source-inline">BP_HUDWidget</strong> Widget Blueprint:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer234">
<img alt="Figure 8.33 – Setting the BP_HUDWidget property to BP_HUDWidget " height="28" src="image/Figure_8.33_B18531.jpg" width="328"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.33 – Setting the BP_HUDWidget property to BP_HUDWidget</p>
<p>After you’ve<a id="_idIndexMarker686"/> done these changes, play<a id="_idIndexMarker687"/> the level. You should notice the <strong class="bold">Health Bar </strong>progress bar in the upper-left corner of the screen:</p>
<div>
<div class="IMG---Figure" id="_idContainer235">
<img alt="Figure 8.34 – The progress bar showing in the upper-left corner of the screen " height="580" src="image/Figure_8.34_B18531.jpg" width="870"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.34 – The progress bar showing in the upper-left corner of the screen</p>
<p>When the player character gets hit by a dodgeball, you should notice the <strong class="source-inline">Health Bar</strong> progress bar being emptied:</p>
<div>
<div class="IMG---Figure" id="_idContainer236">
<img alt="Figure 8.35 – The progress bar being emptied as the player character loses health points " height="538" src="image/Figure_8.35_B18531.jpg" width="863"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.35 – The progress bar being emptied as the player character loses health points</p>
<p>And with<a id="_idIndexMarker688"/> that, we conclude this exercise. You’ve<a id="_idIndexMarker689"/> learned all the necessary steps in order to add a HUD to the screen and update it during the game.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor181"/>Activity 8.01  – improving the RestartWidget class</h2>
<p>In this<a id="_idIndexMarker690"/> activity, we will be adding a <strong class="bold">Text</strong> element<a id="_idIndexMarker691"/> to our <strong class="source-inline">RestartWidget</strong> class that reads <strong class="bold">Game Over</strong> in order for the player to know that they just lost the game; adding an <strong class="bold">Exit</strong> button, which will allow the player to exit the game; and also updating the text of our existing button to <strong class="bold">Restart</strong> so that the players know what should happen when they click on that button.</p>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Open the <strong class="source-inline">BP_RestartWidget</strong> Widget Blueprint.</li>
<li>Drag a new <strong class="source-inline">Text</strong> element into the existing <strong class="source-inline">Canvas Panel</strong> element.</li>
<li>Modify the <strong class="source-inline">Text</strong> element’s properties:<ul><li>Expand the <strong class="bold">Anchors</strong> property and set its <strong class="bold">Minimum</strong> to <strong class="source-inline">0.291</strong> on the <strong class="source-inline">X</strong> axis and <strong class="source-inline">0.115</strong> on the <strong class="source-inline">Y</strong> axis. Then, set its <strong class="bold">Maximum</strong> to <strong class="source-inline">0.708</strong> on the <strong class="source-inline">X</strong> axis and <strong class="source-inline">0.255</strong> on the <strong class="source-inline">Y</strong> axis.</li><li>Set the <strong class="bold">Offset Left</strong>, <strong class="bold">Offset Top</strong>, <strong class="bold">Offset Right</strong>, and <strong class="bold">Offset Bottom</strong> properties to <strong class="source-inline">0</strong>.</li><li>Set the <strong class="bold">Text</strong> property to <strong class="source-inline">GAME OVER</strong>.</li><li>Set the <strong class="bold">Color and Opacity</strong> property to red: <strong class="source-inline">RGBA(1.0, 0.082, 0.082, 1.0)</strong>.</li><li>Expand the <strong class="bold">Font</strong> property and set its <strong class="bold">Size</strong> value to <strong class="source-inline">100</strong>.</li><li>Set the <strong class="bold">Justification</strong> property to <strong class="bold">Align Text Center</strong>.</li></ul></li>
<li>Select <a id="_idIndexMarker692"/>the other <strong class="source-inline">Text</strong> element <a id="_idIndexMarker693"/>inside the <strong class="source-inline">RestartButton</strong> property, and change its <strong class="bold">Text</strong> property to <strong class="source-inline">Restart</strong>.</li>
<li>Duplicate the <strong class="source-inline">RestartButton</strong> property and change the copy’s name to <strong class="source-inline">ExitButton</strong>.</li>
<li>Change the <strong class="bold">Text</strong> property of the <strong class="source-inline">Text</strong> element inside the <strong class="source-inline">ExitButton</strong> property to <strong class="source-inline">Exit</strong>.</li>
<li>Expand the <strong class="bold">Anchor</strong> property of the <strong class="source-inline">ExitButton</strong> property, and set its <strong class="bold">Minimum</strong> to <strong class="source-inline">0.425</strong> on the <em class="italic">X</em> axis and <strong class="source-inline">0.615</strong> on the <em class="italic">Y</em> axis. Then, set its <strong class="bold">Maximum</strong> to <strong class="source-inline">0.574</strong> on the <em class="italic">X</em> axis and <strong class="source-inline">0.725</strong> on the <em class="italic">Y</em> axis.</li>
<li>Set the <strong class="source-inline">ExitButton</strong> properties of <strong class="bold">Offset Left</strong>, <strong class="bold">Offset Top</strong>, <strong class="bold">Offset Right</strong>, and <strong class="bold">Offset Bottom</strong> to <strong class="source-inline">0</strong>.</li>
</ol>
<p>After you’ve done these changes, we’ll need to add the logic responsible for handling the <strong class="source-inline">ExitButton</strong> property click, which will exit the game:</p>
<ol>
<li value="9">Save the changes made to the <strong class="source-inline">BP_RestartWidget</strong> Widget Blueprint and open the <strong class="source-inline">RestartWidget</strong> class’s header file in Visual Studio. In this file, add a declaration for a <strong class="source-inline">protected</strong> function called <strong class="source-inline">OnExitClicked</strong> that returns nothing and receives no parameters. Be sure to mark it as<strong class="source-inline">UFUNCTION</strong>.</li>
<li>Duplicate <a id="_idIndexMarker694"/>the existing <strong class="source-inline">RestartButton</strong> property, but call it <strong class="source-inline">ExitButton</strong> instead.</li>
<li>Inside the <strong class="source-inline">RestartWidget</strong> class’s source file, add an implementation for the <strong class="source-inline">OnExitClicked</strong> function. Copy the contents of the <strong class="source-inline">OnBeginOverlap</strong> function from inside the <strong class="source-inline">VictoryBox</strong> class’s source file into the <strong class="source-inline">OnExitClicked</strong> function, but remove the cast being done to the <strong class="source-inline">DodgeballCharacter</strong> class.</li>
<li>In the <strong class="source-inline">NativeOnInitialized</strong> function implementation, bind the <strong class="source-inline">OnExitClicked</strong> function we created to the <strong class="source-inline">OnClicked</strong> event of the <strong class="source-inline">ExitButton</strong> property, in the same way that we did for the <strong class="source-inline">RestartButton</strong> property in <em class="italic">Exercise 8.03 – creating the RestartWidget C++ class</em>.</li>
</ol>
<p>And that <a id="_idIndexMarker695"/>concludes our code setup for this activity. Compile your changes, and open the editor. Then, open the <strong class="source-inline">BP_RestartWidget</strong> property and compile it just to make sure there are no compilation errors due to the <strong class="source-inline">BindWidget</strong> tags.</p>
<p>Once you’ve done this, play the level again, let the player character be hit by three dodgeballs, and notice the <strong class="source-inline">Restart</strong> widget appear with our new modifications:</p>
<div>
<div class="IMG---Figure" id="_idContainer237">
<img alt="Figure 8.36 – The updated BP_RestartWidget property being shown after the player runs out of health points " height="690" src="image/Figure_8.36_B18531.jpg" width="728"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.36 – The updated BP_RestartWidget property being shown after the player runs out of health points</p>
<p>If you <a id="_idIndexMarker696"/>press the <strong class="source-inline">Restart</strong> button, you should be <a id="_idIndexMarker697"/>able to replay the level, and if you press the <strong class="source-inline">Exit</strong> button, the game should end.</p>
<p>And that concludes our activity. You’ve consolidated the basics of using a <strong class="bold">Widget blueprint</strong> and changing its element’s properties. Now you are ready to start making your own menus.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>. </p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor182"/>Summary</h1>
<p>With this chapter concluded, you have now learned how to make a game UI in UE5, understanding things such as menus and HUDs. You’ve seen how to manipulate a Widget Blueprint’s UI elements, including Button elements, Text elements, and Progress Bar elements; work with anchors effectively, which is instrumental in allowing your game UI to adapt elegantly to multiple screens; listen to mouse events in C++, such as the <strong class="source-inline">OnClick</strong> event, and use that to create your own game logic; and how to add the widgets you create to the screen, either at specific events or have them present at all times.</p>
<p>In the next chapter, we’ll be taking a look at polishing our <strong class="bold">Dodgeball</strong> game by adding audiovisual elements, such as sound and particle effects, as well as making a new level.</p>
</div>
</div></body></html>