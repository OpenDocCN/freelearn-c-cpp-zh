<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-141"><a id="_idTextAnchor168"/>8</h1>
<h1 id="_idParaDest-142"><a id="_idTextAnchor169"/>Creating User Interfaces with UMG</h1>
<p>In the previous chapter, we learned about general-purpose utilities that allow you to properly structure and organize the code and assets in your project by using blueprint function libraries, actor components, and interfaces.</p>
<p>In this chapter, we will dive into the topic of game <strong class="bold">User Interfaces</strong> (<strong class="bold">UIs</strong>), which are present in almost every video game. The game UI is one of the main ways in which to show information to the player, such as how many lives they have left, how many bullets are in their weapon, which weapon they are carrying, and more. It also allows the player to interact with the game by choosing whether to continue the game, create a new game, choose which level they want to play in, and more. This is shown to the player mostly in the form of images and text.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>Game UI</li>
<li>UMG basics</li>
<li>Introducing anchors</li>
<li>Understanding progress bars</li>
</ul>
<h1 id="_idParaDest-143"><a id="_idTextAnchor170"/>Technical requirements</h1>
<p>The project for this chapter can be found in the Chapter08 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor171"/>Game UI</h1>
<p>Usually, UIs are added <a id="_idIndexMarker579"/>on top of the rendering of the game, which means that they are in front of everything else you see in the game and behave as layers (you can add them on top of one another just like in Photoshop). However, there is an exception to this: <em class="italic">diegetic UI</em>. This type of UI isn’t layered onto the game’s screen but rather exists inside the game itself. A great example of this can be found in the game <em class="italic">Dead Space</em>, where you control a character in a third-person view, and can see their health points by looking at the contraption attached to their back, inside the game world.</p>
<p>There are usually two different types of game UI: <strong class="bold">menus</strong> and <strong class="bold">HUDs</strong>.</p>
<p>Menus are<a id="_idIndexMarker580"/> UI panels<a id="_idIndexMarker581"/> that allow the player to interact with them, either by pressing a button or a key on their input device.</p>
<p>This can be done in the form of many different menus, including the following:</p>
<ul>
<li>Main menus, where the player can choose whether to continue the game, create a new game, exit the game, and more</li>
<li>Level select menus, where the player can choose which level to play</li>
<li>Many other options</li>
</ul>
<p>HUDs <a id="_idIndexMarker582"/>are <a id="_idIndexMarker583"/>UI panels that are present during gameplay. They give the player information that they should always know, such as how many lives they have left, which special abilities they can use, and more.</p>
<p>In this chapter, we will be covering game UI and how to make both a menu and a HUD for our game.</p>
<p class="callout-heading">Note</p>
<p class="callout">We won’t be covering diegetic UI here, as it is beyond the scope of this book.</p>
<p>So, how do we go about creating a game UI in UE5? The main way to do it is by using <strong class="bold">Unreal Motion Graphics</strong> (<strong class="bold">UMG</strong>), which<a id="_idIndexMarker584"/> is the tool that allows you to make a game UI (also called widgets in UE5 terms), featuring menus and HUDs, and add them to the screen.</p>
<p>Let’s jump into this topic in the following section.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor172"/>UMG basics</h1>
<p>In UE5, the main <a id="_idIndexMarker585"/>way to create a game UI is by using the <code>Graph</code> tab.</p>
<p>Widgets are the way UE5 allows you to represent a game UI. Widgets can be basic UI elements such as <code>Image</code> elements, but they can also be<a id="_idIndexMarker587"/> combined to create more complex and complete widgets, such as menus and HUDs, which is exactly what we will be doing in this chapter.</p>
<p>In the following exercise, let’s create our first widget in UE5 using the UMG tool.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor173"/>Exercise 8.01 – creating a Widget Blueprint</h2>
<p>In this exercise, we<a id="_idIndexMarker588"/> will be creating our first Widget Blueprint. Additionally, we will be learning about the basic elements of UMG and how we can use them to create a game UI.</p>
<p>The following steps <a id="_idIndexMarker589"/>will help you to complete this exercise:</p>
<ol>
<li>In order to create our first widget, open the editor, go to the <strong class="bold">ThirdPersonCPP -&gt; Blueprints</strong> folder inside the <strong class="bold">Content Browser </strong>section, and <em class="italic">right-click</em>. </li>
<li>Go to the very last section, <strong class="bold">User Interface</strong>, and select <strong class="bold">Widget Blueprint</strong>.</li>
<li>After that, select <strong class="bold">UserWidget</strong> from the list of parent classes available:</li>
</ol>
<div><div><img alt="Figure 8.1 – Selecting the UserWidget parent class " height="375" src="img/Figure_8.01_B18531.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Selecting the UserWidget parent class</p>
<p>Selecting<a id="_idIndexMarker590"/> this option <a id="_idIndexMarker591"/>will create a new <code>Widget Blueprint</code> asset, which is the name of a widget asset in UE5.</p>
<ol>
<li value="4">Name this widget <code>TestWidget</code> and open it. You will see the interface for editing a Widget Blueprint, where you’ll be creating your own widgets and UI. Here’s a breakdown of all the tabs present in this window:</li>
</ol>
<div><div><img alt="Figure 8.2 – The Widget Blueprint editor broken down into six windows " height="929" src="img/Figure_8.02_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The Widget Blueprint editor broken down into six windows</p>
<p>The details<a id="_idIndexMarker592"/> about the tabs<a id="_idIndexMarker593"/> in the preceding screenshot are listed as follows:</p>
<ul>
<li><code>Button</code> elements, <code>Text Box</code> elements, <code>Image</code> elements, <code>Slider</code> elements, <code>Check Box</code> elements, and more.</li>
<li><strong class="bold">Hierarchy</strong> – This tab shows you all the UI elements currently present in your widget. As you can see, currently, we only have a <strong class="bold">Canvas Panel</strong> element in our hierarchy.</li>
<li><strong class="bold">Designer</strong> – This tab shows you how your widget looks visually, according to the elements present in the hierarchy, and how they’re laid out. Because the only element we currently have in our widget doesn’t have a visual representation, this tab is currently empty.</li>
<li><strong class="bold">Details</strong> – This tab shows you the properties of the UI element you have currently selected. If you select the existing <strong class="bold">Canvas Panel</strong> element, all the options in the preceding screenshot should appear.</li>
<li>Because<a id="_idIndexMarker594"/> this asset is a <code>Widget Blueprint</code> asset, these two buttons allow you to switch between the <strong class="bold">Designer</strong> view, which is the one presented in the screenshot, and the <strong class="bold">Graph</strong> view, which looks exactly like the window of a normal blueprint class.</li>
</ul>
<ol>
<li value="5">Now, let’s<a id="_idIndexMarker595"/> look at some of the available UI elements in our <code>Canvas Panel</code> element.</li>
<li>Usually, <strong class="bold">Canvas Panel</strong> elements are added to the root of Widget Blueprints because they allow you to drag a UI element to any position you want in the <strong class="bold">Designer</strong> tab. This way, you can lay out these elements as you wish: at the center of the screen, in the upper-left corner, at the bottom center of the screen, and more. Now, let’s drag another very important UI element into our widget: a <strong class="bold">Button</strong> element. In order to add a <strong class="bold">Canvas Panel</strong> element to your widget, go to the <strong class="bold">Panel</strong> category inside the <strong class="bold">Palette</strong> window and drag a <strong class="bold">Canvas Panel</strong> element into your widget’s root inside the <strong class="bold">Hierarchy</strong> window (the first piece of text that says <strong class="bold">[TestWidget]</strong>) or inside the <strong class="bold">Designer</strong> window:</li>
</ol>
<div><div><img alt="Figure 8.3 – Dragging the Canvas Panel element into the Hierarchy window " height="943" src="img/Figure_8.03_B18531.jpg" width="800"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Dragging the Canvas Panel element into the Hierarchy window</p>
<ol>
<li value="7">In<a id="_idIndexMarker596"/> the <strong class="bold">Palette</strong> tab, find the <strong class="bold">Button</strong> element <a id="_idIndexMarker597"/>and drag it into the <strong class="bold">Designer</strong> window (hold the left mouse button while you drag):</li>
</ol>
<div><div><img alt="Figure 8.4 – A Button element being dragged from the Palette window into the Designer window " height="1013" src="img/Figure_8.04_B18531.jpg" width="677"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – A Button element being dragged from the Palette window into the Designer window</p>
<p>Once <a id="_idIndexMarker598"/>you have<a id="_idIndexMarker599"/> done this, you’ll be able to resize the button to the size you want by dragging the little white dots around it (keep in mind that you’ll only be able to do this to an element that is inside a <strong class="bold">Canvas Panel</strong> element):</p>
<div><div><img alt="Figure 8.5 – The result of resizing a UI element using the white dots around it " height="504" src="img/Figure_8.05_B18531.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The result of resizing a UI element using the white dots around it</p>
<p>Another <a id="_idIndexMarker600"/>way for you to drag <a id="_idIndexMarker601"/>elements inside each other in a widget is to drag them inside the <strong class="bold">Hierarchy</strong> tab instead of the <strong class="bold">Designer</strong> tab.</p>
<ol>
<li value="8">Now drag a <code>Text</code> element inside our <strong class="bold">Button</strong> element, but this time, use the <strong class="bold">Hierarchy</strong> tab:</li>
</ol>
<div><div><img alt="Figure 8.6 – Dragging a Text element from the Palette window into the Hierarchy window " height="376" src="img/Figure_8.06_B18531.jpg" width="294"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Dragging a Text element from the Palette window into the Hierarchy window</p>
<p><code>Text</code> elements <a id="_idIndexMarker602"/>can contain text specified by you with a certain size and font that you can modify in the <code>Details</code> panel. After you’ve dragged the <code>Text</code> element inside the <code>Button</code> element using the <code>Hierarchy</code> tab, this is what the <code>Designer</code> tab should look like:</p>
<div><div><img alt="Figure 8.7 – The Button element in the Designer tab, after adding a Text element as its child " height="95" src="img/Figure_8.07_B18531.jpg" width="187"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – The Button element in the Designer tab, after adding a Text element as its child</p>
<p>Let’s change<a id="_idIndexMarker603"/> a few properties of the preceding <code>Text</code> block. </p>
<ol>
<li value="9">Select it in either the <code>Hierarchy</code> tab or the <strong class="bold">Designer</strong> tab, and take a look at the <strong class="bold">Details</strong> panel:</li>
</ol>
<div><div><img alt="Figure 8.8 – The Details panel, showing the properties of the Text element we added " height="404" src="img/Figure_8.08_B18531.jpg" width="465"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The Details panel, showing the properties of the Text element we added</p>
<p>Here, you’ll find <a id="_idIndexMarker604"/>several properties that you can edit to your liking. For now, we just want to focus on two of them: the content of the text and its color and opacity.</p>
<ol>
<li value="10">Update the <strong class="bold">Content</strong> tab of the <strong class="bold">Text</strong> <strong class="bold">element</strong> from <strong class="bold">Text Block</strong> to <strong class="bold">Button 1</strong>:</li>
</ol>
<div><div><img alt="Figure 8.9 – Changing the Text property of the Text element to Button 1 " height="54" src="img/Figure_8.09_B18531.jpg" width="437"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Changing the Text property of the Text element to Button 1</p>
<p>Next, let’s change the <code>Color and Opacity</code> property setting from <code>White</code> to <code>Black</code>. </p>
<ol>
<li value="11">Click on<a id="_idIndexMarker605"/> the <code>Color</code> property in UE5. It allows you to input colors in many different ways, including a color wheel, <strong class="bold">Saturation</strong> and <strong class="bold">Value</strong> bars, <strong class="bold">RGB </strong>and <strong class="bold">HSV</strong> value sliders, and more.</li>
<li>For now, change<a id="_idIndexMarker606"/> the color from white to black by dragging the <strong class="bold">Value</strong> bar (the one that goes from white to black from top to bottom) all the way to the bottom and then pressing <strong class="bold">OK</strong>:</li>
</ol>
<div><div><img alt="Figure 8.10 – Selecting the color black in the Color Picker window " height="533" src="img/Figure_8.10_B18531.jpg" width="433"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Selecting the color black in the Color Picker window</p>
<ol>
<li value="13">After these changes, this is what the button should look like:</li>
</ol>
<div><div><img alt="Figure 8.11 – The Button element after we change the Text element’s Text property and its color " height="75" src="img/Figure_8.11_B18531.jpg" width="163"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – The Button element after we change the Text element’s Text property and its color</p>
<p>And with that, we <a id="_idIndexMarker607"/>conclude our <a id="_idIndexMarker608"/>first exercise of this chapter. You now know some of the essential basics of UMG, such as how to add <code>Button</code> and <code>Text</code> elements to your widgets.</p>
<p>Before we jump into our next exercise, first, let’s learn about anchors.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor174"/>Introducing anchors</h1>
<p>As you might<a id="_idIndexMarker609"/> be aware, video games are played on many different screen sizes with many different resolutions. Because of that, it is important to make sure that the menus you create can adapt to all these different resolutions effectively. That is the main purpose of <strong class="bold">Anchors</strong>.</p>
<p>Anchors allow you to specify how you want a UI element’s size to adapt as the screen resolution changes by specifying the proportion of the screen you want it to occupy. Using anchors, you can always have a UI element in the upper-left corner of the screen, or always occupying half of the screen, no matter the size and resolution of that screen.</p>
<p>As the size of the screen or resolution changes, your widget will scale and move relative to its anchor. Only elements that are direct children of a <code>Canvas Panel</code> element can have an anchor, which you can visualize through <a id="_idIndexMarker610"/>the <code>Designer</code> tab) when you select said element:</p>
<div><div><img alt="Figure 8.12 – The Anchor Medallion in the upper-left corner of the outline, as shown in the Designer window " height="354" src="img/Figure_8.12_B18531.jpg" width="549"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – The Anchor Medallion in the upper-left corner of the outline, as shown in the Designer window</p>
<p>By default, the <a id="_idIndexMarker611"/>anchor is collapsed into the upper-left corner, which means that you won’t have much control over how the button is scaled as the resolution changes. Let’s change that in the next exercise.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor175"/>Exercise 8.02 – editing UMG anchors</h2>
<p>In this exercise, we<a id="_idIndexMarker612"/> will be changing the anchors in our widget in order to have our button’s size and shape adapt to a wide range of screen resolutions and sizes.</p>
<p>The following <a id="_idIndexMarker613"/>steps will help you to complete this exercise:</p>
<ol>
<li value="1">Select the button we created in the previous exercise. Then, head to the <code>Anchor</code> presets, which will align the UI element according to the pivots shown.</li>
</ol>
<p>We’ll want to have our button centered on the screen.</p>
<ol>
<li value="2">Click on the pivot that’s at the center of the screen:</li>
</ol>
<div><div><img alt="Figure 8.13 – The button’s Anchors property, with the center Anchor preset outlined in a box " height="342" src="img/Figure_8.13_B18531.jpg" width="285"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – The button’s Anchors property, with the center Anchor preset outlined in a box</p>
<p>You’ll see<a id="_idIndexMarker614"/> that <a id="_idIndexMarker615"/>our Anchor Medallion has now changed places:</p>
<div><div><img alt="Figure 8.14 – The Anchor Medallion after we change the button’s Anchor property to the center " height="542" src="img/Figure_8.14_B18531.jpg" width="932"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – The Anchor Medallion after we change the button’s Anchor property to the center</p>
<p>Now that the Anchor Medallion is at the center of the screen, we still won’t have much control over how the button will scale across different resolutions, but at least <a id="_idIndexMarker616"/>we know that it’ll scale relative to the center of the screen.</p>
<p>In order to <a id="_idIndexMarker617"/>have our button centered on the screen, we’ll have to change the button’s position to be at the center of the screen, too.</p>
<ol>
<li value="3">Repeat the previous step of picking the center anchor, but this time, before you select it, hold the <em class="italic">Ctrl</em> key in order to snap the button’s position to this anchor. After you click on it, release the <em class="italic">Ctrl</em> key. You should see a result similar to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 8.15 – The Button element being moved near its selected anchor in the center " height="125" src="img/Figure_8.15_B18531.jpg" width="213"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – The Button element being moved near its selected anchor in the center</p>
<p>As you can see from the preceding screenshot, our button has changed position, but it isn’t properly centered on the screen yet. That is because of its alignment.</p>
<p>The <code>Alignment</code> property is of the <code>Vector2D</code> type (a tuple with two <code>float</code> properties: <code>X</code> and <code>Y</code>) and dictates the center of the UI element relative to its total size. By default, it’s set to <code>(0,0)</code>, meaning the center of the element is its upper-left corner, which explains the result in the preceding screenshot. It can go all the way to <code>(1,1)</code>, which is the lower-right corner. In this case, given that we want the alignment to center the button, we want it to be <code>(0.5, 0.5)</code>. </p>
<ol>
<li value="4">In order to update a UI element’s alignment when picking an <code>Anchor</code> point, you have to hold the <em class="italic">Shift</em> key and repeat the previous step. Alternately, to update both the position and the alignment of the button, picking the center <code>Anchor</code> point <a id="_idIndexMarker618"/>while holding both the <em class="italic">Ctrl</em> and <em class="italic">Shift</em> keys <a id="_idIndexMarker619"/>will do the job. The following screenshot should then be the result:</li>
</ol>
<div><div><img alt="Figure 8.16 – The Button element being centered relative to its selected Anchor point in the center " height="127" src="img/Figure_8.16_B18531.jpg" width="242"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – The Button element being centered relative to its selected Anchor point in the center</p>
<p>At this point, when changing the resolution of the screen, we know that this button will always remain at the center of the screen. However, in order to maintain the button’s size relative to the resolution, we’ll need to make a few more modifications.</p>
<ol>
<li value="5">Drag the lower-right <em class="italic">petal</em> of the Anchor Medallion all the way to the lower-right corner of the button:</li>
</ol>
<div><div><img alt="Figure 8.17 – Dragging the lower-right petal of the Anchor Medallion to update the Button element’s Anchor point " height="226" src="img/Figure_8.17_B18531.jpg" width="474"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Dragging the lower-right petal of the Anchor Medallion to update the Button element’s Anchor point</p>
<ol>
<li value="6">Drag the upper-left <em class="italic">petal</em> of the Anchor Medallion all the way to the upper-left corner <a id="_idIndexMarker620"/>of the<a id="_idIndexMarker621"/> button:</li>
</ol>
<div><div><img alt="Figure 8.18 – Dragging the upper-left petal of the Anchor Medallion to update the Button element’s Anchor " height="267" src="img/Figure_8.18_B18531.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Dragging the upper-left petal of the Anchor Medallion to update the Button element’s Anchor</p>
<p class="callout-heading">Note</p>
<p class="callout">The percentages you see around the button when changing the <code>Anchor</code> point are the space the element is occupying on the screen, shown as a percentage. For instance, looking at the preceding screenshot, we can see that the button is occupying <code>11.9%</code> of the widget’s space on the <em class="italic">X</em> coordinate and <code>8.4%</code> of the widget’s space on the <em class="italic">Y</em> coordinate.</p>
<p class="callout">You can set the size of a UI element to the size of its anchor by holding the <em class="italic">Ctrl</em> key while moving the Anchor Medallion <em class="italic">petals</em>.</p>
<p>Now our button will, finally, adapt to varying screen sizes and resolutions due to these changes to its anchor. </p>
<p>Additionally, you can use the <code>Details</code> panel to manually edit all of the properties we just edited by using the Anchor Medallion and moving the button:</p>
<div><div><img alt="Figure 8.19 – The properties we changed using the Anchor Medallion, as shown in the Details window " height="188" src="img/Figure_8.19_B18531.jpg" width="460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – The properties we changed using the Anchor Medallion, as shown in the Details window</p>
<p>Lastly, we<a id="_idIndexMarker622"/> need to know how we can visualize our <a id="_idIndexMarker623"/>widget with different resolutions in the <code>Designer</code> tab.</p>
<ol>
<li value="7">Drag the double arrow in the lower-right corner of the outlined box inside the <code>Designer</code> tab:</li>
</ol>
<div><div><img alt="Figure 8.20 – The double arrow in the lower-right corner of the outlined box inside the Designer tab " height="357" src="img/Figure_8.20_B18531.jpg" width="598"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – The double arrow in the lower-right corner of the outlined box inside the Designer tab</p>
<p>By dragging the double arrow, you can resize the canvas to any screen resolution you want. In the following screenshot, you’ll see the most used resolutions for a variety of devices, and you can preview your widget in each of them:</p>
<div><div><img alt="Figure 8.21 – The resolutions we can choose to preview in the Designer window " height="569" src="img/Figure_8.21_B18531.jpg" width="995"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – The resolutions we can choose to preview in the Designer window</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find a full reference to UMG’s anchors at <a href="https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors">https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors</a>.</p>
<p>And that <a id="_idIndexMarker624"/>concludes our exercise. You’ve learned about anchors <a id="_idIndexMarker625"/>and how to adapt your widgets to varying screen sizes and resolutions.</p>
<p>Now that we’ve learned about some of the basics of UMG, let’s see how we can create a widget C++ class for this Widget Blueprint. That is what we’re going to do in the next exercise.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor176"/>Exercise 8.03 – creating the RestartWidget C++ class</h2>
<p>In this exercise, we<a id="_idIndexMarker626"/> will learn how to create a widget C++ class, which the Widget Blueprint that we created will inherit from. It will get added<a id="_idIndexMarker627"/> to the screen when the player dies in our <strong class="bold">Dodgeball</strong> game so that the player can have the option to restart the level. This widget will have a button that will restart the level when the player clicks on it.</p>
<p>The first step of this exercise will be adding the UMG-related modules to our project. Unreal Engine comprises several different modules, and in each project, you have to specify which ones you’re going to use. Our project came with a few general modules when the source code files were generated, but we’ll need to add a few more.</p>
<p>The following <a id="_idIndexMarker628"/>steps will help you complete <a id="_idIndexMarker629"/>this exercise:</p>
<ol>
<li value="1">Open the <code>Dodgeball.build.cs</code> file, which is a C# file and not a C++ file, located inside your project’s <code>Source</code> folder.</li>
<li>Open the file, and you’ll find the <code>AddRange</code> function from the <code>PublicDependency ModuleNames</code> property being called. This is the function that tells the engine which modules this project intends to use. As a parameter, an array of strings is sent, with the names of all the intended modules for the project. Given that we intend on using UMG, we’ll need to add the UMG-related modules: <code>UMG</code>, <code>Slate</code>, and <code>SlateCore</code>:<pre>PublicDependencyModuleNames.AddRange(new string[] { "Core", 
  "CoreUObject", "Engine", "InputCore", 
  "EnhancedInput", "HeadMountedDisplay", "UMG", 
  "Slate", "SlateCore" });</pre></li>
</ol>
<p>Now that we’ve notified the engine that we’ll be using the UMG modules, let’s create our widget C++ class:</p>
<ol>
<li value="3">Open the Unreal Editor interface.</li>
<li>Right-click on the <strong class="bold">Content Browser</strong> section and select <strong class="bold">New C++ Class</strong>.</li>
<li>Set the <strong class="bold">Show All Classes</strong> checkbox to <strong class="bold">true</strong>.</li>
<li>Search for the <code>UserWidget</code> class and choose that as the new class’s parent class.</li>
<li>Name the new C++ class <code>RestartWidget</code>. </li>
</ol>
<p>After the files have been opened in Visual Studio, start making modifications to our widget C++ class, as mentioned in the next steps.</p>
<ol>
<li value="8">The <a id="_idIndexMarker630"/>first <a id="_idIndexMarker631"/>thing we’ll add to this class is a <code>public</code> <code>class UButton*</code> property, called <code>RestartButton</code>, which represents the button the player will press in order to restart the level. You will want it to be bound to a button in the blueprint class that inherits from this class, by using the <code>UPROPERTY</code> macro with the <code>BindWidget</code> meta tag. This will force that Widget Blueprint to have a <code>Button</code> element, called <code>RestartButton</code>, that we can access in C++ through this property and then freely edit its properties, such as its size and position, in the blueprint:<pre>UPROPERTY(meta = (BindWidget))
class UButton* RestartButton;</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Using the <code>BindWidget</code> meta tag will cause a compilation error if the Widget Blueprint that inherits from this C++ class doesn’t have an element with the same type and name. If you don’t want this to happen, you will have to mark <code>UPROPERTY</code> as an optional <code>BindWidget</code> like so:</p>
<p class="callout"><code>UPROPERTY(meta = (BindWidget, OptionalWidget = true))</code></p>
<p class="callout">This will make it so that binding this property is optional and doesn’t cause a compilation error when compiling the Widget Blueprint.</p>
<p>Next, we’re going to add the function that will be called when the player clicks on the <code>RestartButton</code> property, which will restart the level. We will be doing this using the <code>GameplayStatics</code> object’s <code>OpenLevel</code> function and then sending the name of the current level.</p>
<ol>
<li value="9">In the widget class’s header file, add a declaration for a <code>protected</code> function called <code>OnRestartClicked</code> that returns nothing and receives no parameters. This function must be marked as <code>UFUNCTION</code>:<pre>protected:
UFUNCTION()
void OnRestartClicked();</pre></li>
<li>In<a id="_idIndexMarker632"/> the <a id="_idIndexMarker633"/>class’s source file, add an <code>include</code> for the <code>GameplayStatics</code> object:<pre>#include "Kismet/GameplayStatics.h"</pre></li>
<li>Then, add an implementation for our <code>OnRestartClicked</code> function:<pre>void URestartWidget::OnRestartClicked()
{
}</pre></li>
<li>Inside this implementation, call the <code>GameplayStatics</code> object’s <code>OpenLevel</code> function. This function receives, as parameters, a world context object, which will be the <code>this</code> pointer, and the name of the level, which we’ll have to fetch using the <code>GameplayStatics</code> object’s <code>GetCurrentLevelName</code> function. Additionally, this last function must receive a world context object, which will also be the <code>this</code> pointer:<pre>UGameplayStatics::OpenLevel(this, 
  FName(*UGameplayStatics::GetCurrentLevelName(
  this)));</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">The call to the <code>GameplayStatics</code> object’s <code>GetCurrentLevelName</code> function must be preceded with <code>*</code> because it returns an <code>FString</code> type, UE5’s string type, and must be dereferenced in order to be passed to the <code>FName</code> constructor.</p>
<p>The next step will be to bind this function in such a way that it is called when the player presses the <code>RestartButton</code> property:</p>
<ol>
<li value="13">In order to do this, we’ll have to override a function that belongs to the <code>UserWidget</code> class, called <code>NativeOnInitialized</code>. This function is only called once, similarly to the actor’s <code>BeginPlay</code> function, which makes it appropriate to do our setup. Add a declaration for the <code>public</code> <code>NativeOnInitialized</code> function with both the <code>virtual</code> and <code>override</code> keywords in our widget class’s header file:<pre>virtual void NativeOnInitialized() override;</pre></li>
<li>Next, in <a id="_idIndexMarker634"/>the class’s source file, add the<a id="_idIndexMarker635"/> implementation of this function. Inside it, call its <code>Super</code> function and add an <code>if</code> statement that checks whether our <code>RestartButton</code> property is different from <code>nullptr</code>:<pre>void URestartWidget::NativeOnInitialized()
{
  Super::NativeOnInitialized();
  if (RestartButton != nullptr)
  {
  }
}</pre></li>
<li>If the <code>if</code> statement is true, we’ll want to bind our <code>OnRestartClicked</code> function to the button’s <code>OnClicked</code> event. We can do this by accessing the button’s <code>OnClicked</code> property and calling its <code>AddDynamic</code> function. This sends, as parameters, the object we want to call that function on, the <code>this</code> pointer, and a pointer to the function to be called, that is, the <code>OnRestartClicked</code> function:<pre>if (RestartButton != nullptr)
{
  RestartButton-&gt;OnClicked.AddDynamic(this, 
  &amp;URestartWidget::OnRestartClicked);
}</pre></li>
<li>Because<a id="_idIndexMarker636"/> we’re accessing functions<a id="_idIndexMarker637"/> related to the <code>Button</code> class, we’ll also have to include it:<pre>#include "Components/Button.h"</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">A button’s <code>OnClicked</code> event will be called when the player presses and releases that button with the mouse. There are other events related to the button, including the <code>OnPressed</code> event (when the player presses the button), the <code>OnReleased</code> event (when the player releases the button), and the <code>OnHover</code> and <code>OnUnhover</code> events (when the player, respectively, starts and stops hovering the mouse over that button).</p>
<p class="callout">The <code>AddDynamic</code> function must receive, as a parameter, a pointer to a function marked with the <code>UFUNCTION</code> macro. If it doesn’t, you will get an error when calling that function. This is why we marked the <code>OnRestartClicked</code> function with the <code>UFUNCTION</code> macro. </p>
<p>After you’ve done these steps, compile your changes and open the editor. </p>
<ol>
<li value="17">Open the <code>TestWidget</code> Widget Blueprint that you created earlier. We’ll want to associate this Widget Blueprint with the <code>RestartWidget</code> class we just created, so we need to reparent it. </li>
<li>From the Widget Blueprint’s <code>RestartWidget</code> C++ class as its new parent class:</li>
</ol>
<div><div><img alt="Figure 8.22 – Reparenting the TestWidget’s class to RestartWidget " height="1267" src="img/Figure_8.22_B18531.jpg" width="808"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Reparenting the TestWidget’s class to RestartWidget</p>
<p>You’ll notice<a id="_idIndexMarker638"/> that <a id="_idIndexMarker639"/>the Widget Blueprint now has a compilation error related to the <code>BindWidget</code> meta tag that we created in the C++ class:</p>
<div><div><img alt="Figure 8.23 – Compiler errors after setting the parent class to the RestartWidget class " height="117" src="img/Figure_8.23_B18531.jpg" width="573"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – Compiler errors after setting the parent class to the RestartWidget class</p>
<p>This is caused by the fact that the C++ class couldn’t find a <code>Button</code> property called <code>RestartButton</code>. </p>
<p>In order to fix this, we’ll need to rename our <code>Button</code> element inside the Widget Blueprint to <code>RestartButton</code>:</p>
<div><div><img alt="Figure 8.24 – Renaming the Button element to RestartButton " height="614" src="img/Figure_8.24_B18531.jpg" width="1575"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – Renaming the Button element to RestartButton</p>
<p>After <a id="_idIndexMarker640"/>you’ve <a id="_idIndexMarker641"/>done this, close the Widget Blueprint and change its name from <code>TestWidget</code> to <code>BP_RestartWidget</code>, the same way you just did in the previous step.</p>
<p>That concludes the creation of our widget class. Now, you understand how to connect a widget C++ class to a Widget Blueprint, which is a very important step toward handling game UI in UE5.</p>
<p>The next thing we need to do is create our <code>Player Controller</code> C++ class, which will be responsible for instantiating our <code>RestartWidget</code> class and adding it to the screen. We will be doing this in the following exercise.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor177"/>Exercise 8.04 – creating the logic for adding the RestartWidget class to the screen</h2>
<p>In this exercise, we will <a id="_idIndexMarker642"/>create the logic responsible for adding our newly created <code>RestartWidget</code> class to the screen. It will appear on the screen when the player dies so that they have the option to restart the level.</p>
<p>In order to do<a id="_idIndexMarker643"/> this, we’ll have to create a new <code>Player Controller</code> C++ class, which you can do by following these steps:</p>
<ol>
<li value="1">Open the Unreal Editor interface.</li>
<li><em class="italic">Right-click</em> on the <code>Content Browser</code> section and select <code>New C++ Class</code>.</li>
<li>Search for the <code>Player Controller</code> class and choose that as the new class’s parent class.</li>
<li>Name the new C++ class <code>DodgeballPlayerController</code>.</li>
<li>Open the class’s files in Visual Studio.</li>
</ol>
<p>When our player runs out of health points, the <code>DodgeballCharacter</code> class will access this <code>Player Controller</code> class and call a function that will add the <code>RestartWidget</code> class to the screen. Follow these next steps in order to make this happen.</p>
<p>In order to know the class of the widget to add to the screen (which will be a Widget Blueprint asset and not a Widget C++ class), we’ll need to use the <code>TSubclassOf</code> type.</p>
<ol>
<li value="6">In the class’s header file, add a <code>public</code> <code>TSubclassOf&lt;class URestartWidget&gt;</code> property called <code>BP_RestartWidget</code>. Be sure to make it a <code>UPROPERTY</code> function with the <code>EditDefaultsOnly</code> tag so that we can edit it in the blueprint class:<pre>public:
UPROPERTY(EditDefaultsOnly)
TSubclassOf&lt;class URestartWidget&gt; BP_RestartWidget;</pre></li>
</ol>
<p>In order to instantiate this widget and add it to the screen, we’ll need to save a reference to it.</p>
<ol>
<li value="7">Add a <a id="_idIndexMarker644"/>new <code>private</code> variable of the <code>class URestartWidget*</code> type and call it <code>RestartWidget</code>. Be<a id="_idIndexMarker645"/> sure to make it a <code>UPROPERTY</code> function with no tags:<pre>private:
UPROPERTY()
class URestartWidget* RestartWidget;</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Although this property isn’t supposed to be editable in a blueprint class, we have to make this reference a <code>UPROPERTY</code> function; otherwise, the garbage collector will destroy the contents of this variable.</p>
<p>The next thing we need is a function responsible for adding our widget to the screen. </p>
<ol>
<li value="8">Add a declaration for a <code>public</code> function that returns nothing and receives no parameters, called <code>ShowRestartWidget</code>:<pre>void ShowRestartWidget();</pre></li>
<li>Now, head to our class’s source file. First, add an <code>include</code> to the <code>RestartWidget</code> class:<pre>#include "RestartWidget.h"</pre></li>
<li>Then, add the implementation of our <code>ShowRestartWidget</code> function, where we’ll start by checking whether our <code>BP_RestartWidget</code> variable is not a <code>nullptr</code> variable:<pre>void ADodgeballPlayerController::ShowRestartWidget()
{
  if (BP_RestartWidget != nullptr)
  {
  }
}</pre></li>
<li>If that <a id="_idIndexMarker646"/>variable is valid (different from <code>nullptr</code>), we want to pause the game using the <code>SetPause</code> function of <strong class="bold">Player Controller</strong>. This will ensure that the game stops until<a id="_idIndexMarker647"/> the player decides to do something (which, in our case, will be pressing the button that restarts the level):<pre>SetPause(true);</pre></li>
</ol>
<p>The next thing we’ll do is change the input mode. In UE5, there are three input modes: <code>Game Only</code>, <code>Game and UI</code>, and <code>UI Only</code>. If your Input mode includes <code>Game</code>, that means that the player character and the player controller will receive inputs through the input actions. If your <code>Input</code> mode includes <code>UI</code>, that means that the widgets that are on the screen will receive inputs from the player. When we show this widget on the screen, we won’t want the player character to receive any input.</p>
<ol>
<li value="12">Hence, update to the <code>UI Only</code> <code>Input</code> mode. You can do this by calling the <code>Player Controller</code> <code>SetInputMode</code> function and passing the <code>FInputModeUIOnly</code> type as a parameter:<pre>SetInputMode(FInputModeUIOnly());</pre></li>
</ol>
<p>Following this, we want to show the mouse cursor so that the player can see which button they are hovering the mouse on.</p>
<ol>
<li value="13">We will do this by setting the <code>Player Controller</code> <code>bShowMouseCursor</code> property to <code>true</code>:<pre>bShowMouseCursor = true;</pre></li>
<li>Now, we <a id="_idIndexMarker648"/>can actually instantiate our<a id="_idIndexMarker649"/> widget using the <code>Player Controller</code>’s <code>CreateWidget</code> function, passing as a template parameter the C++ Widget class, which, in our case, is <code>RestartWidget</code>. Then, as normal parameters, we will pass Owning Player, which is the <code>Player Controller</code> class that owns this widget and that we’ll send using the <code>this</code> pointer, and the widget class, which will be our <code>BP_RestartWidget</code> property:<pre>RestartWidget = CreateWidget&lt;URestartWidget&gt;(this, 
  BP_RestartWidget);</pre></li>
<li>After we instantiate the widget, we’ll want to add it to the screen, using the widget’s <code>AddToViewport</code> function:<pre>RestartWidget-&gt;AddToViewport();</pre></li>
<li>That concludes our <code>ShowRestartWidget</code> function. However, we also need to create the function that will remove the <code>RestartWidget</code> class from the screen. In the class’s header file, add a declaration for a function just like the <code>ShowRestartWidget</code> function, but this time called <code>HideRestartWidget</code>:<pre>void HideRestartWidget();</pre></li>
<li>In the class’s source file, add the implementation for the <code>HideRestartWidget</code> function:<pre>void ADodgeballPlayerController::HideRestartWidget()
{
}</pre></li>
<li>The first thing we should do in this function is to remove the widget from the screen by calling its <code>RemoveFromParent</code> function, and destroy it using the <code>Destruct</code> function:<pre>RestartWidget-&gt;RemoveFromParent();
RestartWidget-&gt;Destruct();</pre></li>
<li>Then, we <a id="_idIndexMarker650"/>want to unpause<a id="_idIndexMarker651"/> the game using the <code>SetPause</code> function we used in the previous function:<pre>SetPause(false);</pre></li>
<li>Finally, let’s set the <code>Input</code> mode to <code>Game Only</code> and hide the mouse cursor in the same way we did in the previous function (this time, we pass the <code>FInputModeGameOnly</code> type instead):<pre>SetInputMode(FInputModeGameOnly());
bShowMouseCursor = false;</pre></li>
</ol>
<p>And that concludes the logic for our <code>Player Controller</code> C++ class. The next thing we should do is call the function that will add our widget to the screen.</p>
<ol>
<li value="21">Go to the <code>DodgeballCharacter</code> class’s source file and add the <code>include</code> keyword to our newly created <code>DodgeballPlayerController</code> class:<pre>#include "DodgeballPlayerController.h"</pre></li>
<li>Within the <code>DodgeballCharacter</code> class’s implementation of the <code>OnDeath_Implementation</code> function, replace the call to the <code>QuitGame</code> function with the following:<ul><li>Get the character’s player controller using the <code>GetController</code> function. You’ll want to save the result in a variable of the <code>DodgeballPlayerController*</code> type, called <code>PlayerController</code>. Because the function will return a variable of the <code>Controller</code> type, you’ll also need to cast it to our <code>PlayerController</code> class:<pre>ADodgeballPlayerController* PlayerController = Cast&lt;ADodgeballPlayerController&gt;(GetController());</pre></li><li>Check <a id="_idIndexMarker652"/>whether the <code>PlayerController</code> variable is valid. If it is, call its <code>ShowRestartWidget</code> function:<pre>if (PlayerController != nullptr)
{
  PlayerController-&gt;ShowRestartWidget();
}</pre></li></ul></li>
</ol>
<p>After these<a id="_idIndexMarker653"/> modifications, the last thing left for us to do is to call the function that will hide our widget from the screen. Open the <code>RestartWidget</code> class’s source file and implement the following modifications.</p>
<ol>
<li value="23">Add an <code>include</code> to the <code>DodgeballPlayerController</code> class, which contains the function that we will be calling:<pre>#include "DodgeballPlayerController.h"</pre></li>
<li>Inside the <code>OnRestartClicked</code> function implementation, before the call to the <code>OpenLevel</code> function, we must fetch the widget’s <code>OwningPlayer</code>, which is of the <code>PlayerController</code> type, using the <code>GetOwningPlayer</code> function, and cast it to the <code>DodgeballPlayerController</code> class:<pre>ADodgeballPlayerController* PlayerController = 
  Cast&lt;ADodgeballPlayerController&gt;(GetOwningPlayer());</pre></li>
<li>Then, if the <code>PlayerController</code> variable is valid, we call its <code>HideRestartWidget</code> function:<pre>if (PlayerController != nullptr)
{
  PlayerController-&gt;HideRestartWidget();
}</pre></li>
</ol>
<p>After you’ve <a id="_idIndexMarker654"/>followed all these steps, close<a id="_idIndexMarker655"/> the editor, compile your changes, and open the editor again.</p>
<p>You have now concluded this exercise. We have added all the necessary logic to add our <code>RestartWidget</code> class to the screen. The only thing left for us to do is create the blueprint class of our newly created <code>DodgeballPlayerController</code> class, which we’ll be doing in the next exercise.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor178"/>Exercise 8.05 – setting up the DodgeballPlayerController blueprint class</h2>
<p>In this<a id="_idIndexMarker656"/> exercise, we will be creating the blueprint class for <code>DodgeballPlayerController</code> in order to specify which widget we want to add to the screen. Then, we will tell UE5 to use this blueprint<a id="_idIndexMarker657"/> class when the game starts.</p>
<p>In order to do that, follow these steps:</p>
<ol>
<li value="1">Go to the <strong class="bold">ThirdPersonCPP -&gt; Blueprints</strong> directory in the <strong class="bold">Content Browser</strong> section, right-click on it, and create a new blueprint class.</li>
<li>Search for the <strong class="bold">DodgeballPlayerController</strong> class and select it as the parent class.</li>
<li>Rename this blueprint class to <code>BP_DodgeballPlayerController</code>. After that, open this blueprint asset.</li>
<li>Go to its <code>Class Defaults</code> tab and set the class’s <code>BP_RestartWidget</code> property to the <code>BP_RestartWidget</code> Widget Blueprint we created.</li>
</ol>
<p>Now, the only thing left for us to do is to make sure that this <code>Player Controller</code> blueprint class is being used in the game.</p>
<p>In order to do this, we’ll have to follow a few more steps.</p>
<ol>
<li value="5">Go to the <code>ThirdPersonCPP</code> -&gt; <code>Blueprints</code> directory in the <code>DodgeballGameMode</code> class and select it as the parent class. Then, rename this <code>Blueprint</code> class to <code>BP_DodgeballGameMode</code>.</li>
</ol>
<p>This <a id="_idIndexMarker658"/>class is responsible for telling the game which classes to use for each element of the game, such as which <code>Player Controller</code> class to use, among other things.</p>
<ol>
<li value="6">Open the asset, go to its <code>PlayerControllerClass</code> property to the <code>BP_DodgeballPlayerController</code> class we just created:</li>
</ol>
<div><div><img alt="Figure 8.25 – Setting the PlayerControllerClass property to BP_DodgeballPlayerController " height="276" src="img/Figure_8.25_B18531.jpg" width="540"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.25 – Setting the PlayerControllerClass property to BP_DodgeballPlayerController</p>
<ol>
<li value="7">Close the <a id="_idIndexMarker659"/>asset and select the <strong class="bold">Blueprints</strong> drop-down option inside the editor toolbar that is at the top of the <strong class="bold">Level Viewport</strong> window. From there, select the second <strong class="bold">Game Mode</strong> option, inside the <strong class="bold">World Override</strong> category (which should, currently, be set to <strong class="bold">DodgeballGameMode</strong>), <strong class="bold">-&gt; Select GameModeBase Class -&gt; BP_DodgeballGameMode</strong>. This will tell the editor to use this new <strong class="bold">Game Mode</strong> option in the current level.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Additionally, you can set the <strong class="bold">Game Mode</strong> option inside the <strong class="bold">Project Settings</strong> category, which will tell the editor to use that <strong class="bold">Game Mode</strong> option on all levels. However, if a level overrides this option by setting the <strong class="bold">Game Mode</strong> option in the <strong class="bold">World Override</strong> category, that option will be ignored.</p>
<p>Now, play<a id="_idIndexMarker660"/> the game and let your character get hit by a dodgeball <code>three</code> times. After the third time, you should see the game get paused and show <code>BP_RestartWidget</code>: </p>
<div><div><img alt="Figure 8.26 – Our BP_RestartWidget property being added to the screen after the player runs out of health points " height="507" src="img/Figure_8.26_B18531.jpg" width="656"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.26 – Our BP_RestartWidget property being added to the screen after the player runs out of health points</p>
<p>And <a id="_idIndexMarker661"/>when you click on <code>Button 1</code> using your mouse, you should see the level reset to its initial state:</p>
<div><div><img alt="Figure 8.27 – The level restarts after the player presses the button shown in the previous screenshot " height="449" src="img/Figure_8.27_B18531.jpg" width="551"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.27 – The level restarts after the player presses the button shown in the previous screenshot</p>
<p>And<a id="_idIndexMarker662"/> that<a id="_idIndexMarker663"/> concludes our exercise. Now you know how to create widgets and show them in your game. This is another crucial step in your journey toward becoming a skilled game developer.</p>
<p>Before we move on to the next exercise, in the next section, let’s take a look at progress bars.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor179"/>Understanding progress bars</h1>
<p>One<a id="_idIndexMarker664"/> of the ways that video games can represent character stats such as health, stamina, and more is through <strong class="bold">Progress Bars</strong>, which are what we’ll use to communicate to the player how much health their character has. Essentially, progress bars are a shape, usually rectangular, that can be filled and emptied in order to show the player how a specific stat is progressing. If you want to show the player that their character’s health is only half its maximum value, you could do this by showing the progress bar as half full. In this section, that is exactly what we’ll be doing. This progress bar will be the only element in our <strong class="bold">Dodgeball</strong> game’s HUD.</p>
<p>In order to <a id="_idIndexMarker665"/>create this <code>ThirdPersonCPP</code> -&gt; <code>Blueprints</code> directory inside the <code>Widget Blueprint</code> class from the <code>User Interface</code> category. Then, select <code>BP_HUDWidget</code>. After that, open the new Widget Blueprint.</p>
<p>Add a <code>Canvas Panel</code> element to the root of this widget, just like we did in <em class="italic">step 6</em> of <em class="italic">Exercise 8.01 – improving the RestartWidget class</em>.</p>
<p>In UE5, progress bars <a id="_idIndexMarker666"/>are just another UI element, such as <code>Button</code> elements and <code>Text</code> elements, which means we can drag them from the <strong class="bold">Palette</strong> tab into our <strong class="bold">Designer</strong> tab. Take a look at the following example:</p>
<div><div><img alt="Figure 8.28 – Dragging a Progress Bar element into the Designer window " height="379" src="img/Figure_8.28_B18531.jpg" width="748"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.28 – Dragging a Progress Bar element into the Designer window</p>
<p>At first, this progress bar might look similar to a button; however, it contains two specific properties that are important for a progress bar:</p>
<ul>
<li><code>0</code> to <code>1</code>.</li>
<li><strong class="bold">Bar Fill Type</strong> – This<a id="_idIndexMarker668"/> allows you to specify how you want this progress bar to fill (from left to right, top to bottom, and so on):</li>
</ul>
<div><div><img alt="Figure 8.29 – The progress bar’s Percent and Bar Fill Type properties " height="80" src="img/Figure_8.29_B18531.jpg" width="459"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.29 – The progress bar’s Percent and Bar Fill Type properties</p>
<p>If you set<a id="_idIndexMarker669"/> the <code>0.5</code>, the progress bar will be updated accordingly to fill half of its length:</p>
<div><div><img alt="Figure 8.30 – The progress bar filled halfway to the right " height="291" src="img/Figure_8.30_B18531.jpg" width="356"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.30 – The progress bar filled halfway to the right</p>
<p>Before you continue, set the <code>1</code>.</p>
<p>Now, let’s change the progress bar’s color from blue (its default color) to red. In order to do this, go to the <code>RGB(1,0,0)</code>):</p>
<div><div><img alt="Figure 8.31 – The progress bar’s color being changed to red " height="56" src="img/Figure_8.31_B18531.jpg" width="459"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.31 – The progress bar’s color being changed to red</p>
<p>After you’ve done this, your progress bar should now use red as its fill color.</p>
<p>To conclude <a id="_idIndexMarker670"/>our progress bar’s setup, let’s update its position, size, and anchors. Follow these steps to achieve this:</p>
<ol>
<li value="1">In the <code>X</code> axis, and <code>0.083</code> on the <code>Y</code> axis</li><li><code>0.208</code> on the <code>X</code> axis, and <code>0.116</code> on the <code>Y</code> axis</li></ul></li>
<li>Set the <code>0</code>.</li>
</ol>
<p>Your<a id="_idIndexMarker671"/> progress bar should now look like this:</p>
<div><div><img alt="Figure 8.32 – The progress bar after all the modifications in this section have been completed  " height="238" src="img/Figure_8.32_B18531.jpg" width="552"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.32 – The progress bar after all the modifications in this section have been completed </p>
<p>And with that, we can conclude the topic of progress bars. Our next step is going to be to add all the logic necessary to use this progress bar as a health bar, by updating its <strong class="bold">Percent</strong> property alongside the player character’s health. In the next exercise, we’ll do exactly that.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor180"/>Exercise 8.06 – creating the health bar C++ logic</h2>
<p>In this <a id="_idIndexMarker672"/>exercise, we will be adding all the necessary <a id="_idIndexMarker673"/>C++ logic to update the progress bar inside our HUD as the player character’s health changes.</p>
<p>In order to do this, follow these steps:</p>
<ol>
<li value="1">Open the editor and create a new C++ class that inherits from <code>UserWidget</code>, similar to how we did in <em class="italic">Exercise 8.03 – creating the RestartWidget C++ class</em>. However, this time, call it <code>HUDWidget</code>. This will be the C++ class that will be used for our HUD widget.</li>
<li>In the <code>HUDWidget</code> class’s header file, add a new <code>public</code> property of the <code>class UProgressBar*</code> type called <code>HealthBar</code>. This type is used to represent a progress bar, like the one we created in the previous section, in C++. Be sure to declare this property as a <code>UPROPERTY</code> function with the <code>BindWidget</code> tag:<pre>UPROPERTY(meta = (BindWidget))
class UProgressBar* HealthBar;</pre></li>
<li>Add <a id="_idIndexMarker674"/>a declaration for a <code>public</code> function, called <code>UpdateHealthPercent</code>, which returns nothing and <a id="_idIndexMarker675"/>receives a <code>float HealthPercent</code> property as a parameter. This function will be called in order to update the <strong class="bold">Percent</strong> property of our progress bar:<pre>void UpdateHealthPercent(float HealthPercent);</pre></li>
<li>In the <code>HUDWidget</code> class’s source file, add the implementation for the <code>UpdateHealthPercent</code> function, which will call the <code>HealthBar</code> property’s <code>SetPercent</code> function, passing the <code>HealthPercent</code> property as a parameter:<pre>void UHUDWidget::UpdateHealthPercent(float HealthPercent)
{
  HealthBar-&gt;SetPercent(HealthPercent);
}</pre></li>
<li>Because we’ll be using the <code>ProgressBar</code> C++ class, we’ll need to add an <code>include</code> to it at the top of the class’s source file:<pre>#include "Components/ProgressBar.h"</pre></li>
</ol>
<p>The next step will be to add all the necessary logic to our <code>Player Controller</code> class, which is responsible for adding the <code>HUDWidget</code> class to the screen. Implement the following steps in order to achieve this:</p>
<ol>
<li value="6">Inside the <code>DodgeballPlayerController</code> class’s header file, add a <code>public</code> property of the <code>TSubclassOf&lt;class UHUDWidget&gt;</code> type, called <code>BP_HUDWidget</code>. Be sure to mark it as a <code>UPROPERTY</code> function with the <code>EditDefaultsOnly</code> tag.</li>
</ol>
<p>This<a id="_idIndexMarker676"/> property will allow us to specify, in the <code>DodgeballPlayerController</code> blueprint class, which widget we want to use as our HUD:</p>
<pre>UPROPERTY(EditDefaultsOnly)
TSubclassOf&lt;class UHUDWidget&gt; BP_HUDWidget;</pre>
<ol>
<li value="7">Add <a id="_idIndexMarker677"/>another property, this time <code>private</code>, of the <code>class UHUDWidget*</code> type, called <code>HUDWidget</code>. Mark it as a <code>UPROPERTY</code> function, but without any tags:<pre>UPROPERTY()
class UHUDWidget* HUDWidget;</pre></li>
<li>Add a <code>protected</code> declaration for the <code>BeginPlay</code> function, and mark it as both <code>virtual</code> and <code>override</code>:<pre>virtual void BeginPlay() override;</pre></li>
<li>Add a declaration for a new <code>public</code> function, called <code>UpdateHealthPercent</code>, which returns nothing and receives <code>float HealthPercent</code> as a parameter.</li>
</ol>
<p>This function will be called by our player character class in order to update the health bar in our HUD:</p>
<pre>void UpdateHealthPercent(float HealthPercent);</pre>
<ol>
<li value="10">Now head over to the <code>DodgeballPlayerController</code> class’s source file. Start by adding an <code>include</code> to our <code>HUDWidget</code> class:<pre>#include "HUDWidget.h"</pre></li>
<li>Then, add the implementation for the <code>BeginPlay</code> function, where we’ll start by calling the <code>Super</code> object’s <code>BeginPlay</code> function:<pre>void ADodgeballPlayerController::BeginPlay()
{
  Super::BeginPlay();
}</pre></li>
<li>After<a id="_idIndexMarker678"/> that function call, check whether<a id="_idIndexMarker679"/> the <code>BP_HUDWidget</code> property is valid. If it is, call the <code>CreateWidget</code> function with the <code>UHUDWidget</code> template parameter and pass <code>Owning Player</code>, <code>this</code>, and the <code>BP_HUDWidget</code> widget class, as parameters. Be sure to set the <code>HUDWidget</code> property to the return value of this function call:<pre>if (BP_HUDWidget != nullptr)
{
  HUDWidget = CreateWidget&lt;UHUDWidget&gt;(this, 
  BP_HUDWidget);
}</pre></li>
<li>After setting the <code>HUDWidget</code> property, call its <code>AddToViewport</code> function:<pre>HUDWidget-&gt;AddToViewport();</pre></li>
<li>Lastly, add the implementation for the <code>UpdateHealthPercent</code> function, where we’ll check whether the <code>HUDWidget</code> property is valid. If it is, call its <code>UpdateHealthPercent</code> function and pass the <code>HealthPercent</code> property as a parameter:<pre>void ADodgeballPlayerController::UpdateHealthPercent(float 
  HealthPercent)
{
  if (HUDWidget != nullptr)
  {
    HUDWidget-&gt;UpdateHealthPercent(HealthPercent);
  }
}</pre></li>
</ol>
<p>Now <a id="_idIndexMarker680"/>that we’ve added the logic responsible<a id="_idIndexMarker681"/> for adding the HUD to the screen and allowing it to be updated, we’ll need to make some modifications to the other classes. Follow the next steps in order to do so.</p>
<p>Currently, our <code>Health</code> interface, which we created in the previous chapter, only has the <code>OnDeath</code> event, which is called whenever an object runs out of health points. In order to update our health bar every time the player takes damage, we need to allow our <code>HealthInterface</code> class to notify an object whenever that happens.</p>
<ol>
<li value="15">Open the <code>HealthInterface</code> class’s header file and add a declaration similar to the one we did for the <code>OnDeath</code> event in <em class="italic">Exercise 7.04 – creating the HealthInterface class</em>, but this time for the <code>OnTakeDamage</code> event. This event will be called whenever an object takes damage:<pre>UFUNCTION(BlueprintNativeEvent, Category = Health)
void OnTakeDamage();
virtual void OnTakeDamage_Implementation() = 0;</pre></li>
<li>Now that we have added this event to our <code>Interface</code> class, let’s add the logic that calls that event: open the <code>HealthComponent</code> class’s source file and, inside its implementation of the <code>LoseHealth</code> function, after subtracting the <code>Amount</code> property from the <code>Health</code> property, check whether the <code>Owner</code> implements the <code>Health</code> interface and, if it does, call its <code>OnTakeDamage</code> event. Do this the same way we already did later in that same function for our <code>OnDeath</code> event, but this time, simply change the name of the event to <code>OnTakeDamage</code>:<pre>if (GetOwner()-&gt;Implements&lt;UHealthInterface&gt;())
{
  IHealthInterface::Execute_OnTakeDamage(GetOwner());
}</pre></li>
</ol>
<p>Because <a id="_idIndexMarker682"/>our health bar will require<a id="_idIndexMarker683"/> the player character’s health points as a percentage, we need to perform the following steps.</p>
<ol>
<li value="17">Add a <code>public</code> function to our <code>HealthComponent</code> class that returns just that: in the <code>HealthComponent</code> class’s header file, add a declaration for a <code>FORCEINLINE</code> function that returns a <code>float</code> property. This function should be called <code>GetHealthPercent</code> and be a <code>const</code> function. Its implementation will simply consist of returning the <code>Health</code> property divided by <code>100</code>, which we will assume is the maximum amount of health points an object can have in our game:<pre>FORCEINLINE float GetHealthPercent() const { return Health / 
  100.f; }</pre></li>
<li>Now go to the <code>DodgeballCharacter</code> class’s header file and add a declaration for a <code>public</code> <code>virtual</code> function called <code>OnTakeDamage_Implementation</code>, which returns nothing and receives no parameters. Mark it as <code>virtual</code> and <code>override</code>:<pre>virtual void OnTakeDamage_Implementation() override;</pre></li>
<li>In the <code>DodgeballCharacter</code> class’s source file, add an implementation for the <code>OnTakeDamage_Implementation</code> function we just declared. Copy the content of the <code>OnDeath_Implementation</code> function to this new function’s implementation, but make this change: instead of calling the <code>ShowRestartWidget</code> function of <code>PlayerController</code>, call its <code>UpdateHealthPercent</code> function, and pass the return value of the <code>HealthComponent</code> property’s <code>GetHealthPercent</code> function as a parameter:<pre>void ADodgeballCharacter::OnTakeDamage_Implementation()
{
  ADodgeballPlayerController* PlayerController = 
  Cast&lt;ADodgeballPlayerController&gt;(GetController());
  if (PlayerController != nullptr)
  {
    PlayerController-&gt;
    UpdateHealthPercent(HealthComponent
    -&gt;GetHealthPercent());
  }
}</pre></li>
</ol>
<p>This<a id="_idIndexMarker684"/> concludes this exercise’s code setup. After<a id="_idIndexMarker685"/> you’ve done these changes, compile your code, open the editor, and perform the following steps.</p>
<ol>
<li value="20">Open the <code>BP_HUDWidget</code> Widget Blueprint and reparent it to the <code>HUDWidget</code> class, in the same way you did in <em class="italic">Exercise 8.03 – creating the RestartWidget C++ class</em>.</li>
<li>This should cause a compilation error, which you’ll be able to fix by renaming our progress bar element to <code>HealthBar</code>.</li>
<li>Close this Widget Blueprint, open the <code>BP_DodgeballPlayerController</code> blueprint class, and set its <code>BP_HUDWidget</code> property to the <code>BP_HUDWidget</code> Widget Blueprint:</li>
</ol>
<div><div><img alt="Figure 8.33 – Setting the BP_HUDWidget property to BP_HUDWidget " height="28" src="img/Figure_8.33_B18531.jpg" width="328"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.33 – Setting the BP_HUDWidget property to BP_HUDWidget</p>
<p>After you’ve<a id="_idIndexMarker686"/> done these changes, play<a id="_idIndexMarker687"/> the level. You should notice the <strong class="bold">Health Bar </strong>progress bar in the upper-left corner of the screen:</p>
<div><div><img alt="Figure 8.34 – The progress bar showing in the upper-left corner of the screen " height="580" src="img/Figure_8.34_B18531.jpg" width="870"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.34 – The progress bar showing in the upper-left corner of the screen</p>
<p>When the player character gets hit by a dodgeball, you should notice the <code>Health Bar</code> progress bar being emptied:</p>
<div><div><img alt="Figure 8.35 – The progress bar being emptied as the player character loses health points " height="538" src="img/Figure_8.35_B18531.jpg" width="863"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.35 – The progress bar being emptied as the player character loses health points</p>
<p>And with<a id="_idIndexMarker688"/> that, we conclude this exercise. You’ve<a id="_idIndexMarker689"/> learned all the necessary steps in order to add a HUD to the screen and update it during the game.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor181"/>Activity 8.01  – improving the RestartWidget class</h2>
<p>In this<a id="_idIndexMarker690"/> activity, we will be adding a <code>RestartWidget</code> class that reads <strong class="bold">Game Over</strong> in order for the player to know that they just lost the game; adding an <strong class="bold">Exit</strong> button, which will allow the player to exit the game; and also updating the text of our existing button to <strong class="bold">Restart</strong> so that the players know what should happen when they click on that button.</p>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Open the <code>BP_RestartWidget</code> Widget Blueprint.</li>
<li>Drag a new <code>Text</code> element into the existing <code>Canvas Panel</code> element.</li>
<li>Modify the <code>Text</code> element’s properties:<ul><li>Expand the <code>0.291</code> on the <code>X</code> axis and <code>0.115</code> on the <code>Y</code> axis. Then, set its <code>0.708</code> on the <code>X</code> axis and <code>0.255</code> on the <code>Y</code> axis.</li><li>Set the <code>0</code>.</li><li>Set the <code>GAME OVER</code>.</li><li>Set the <code>RGBA(1.0, 0.082, 0.082, 1.0)</code>.</li><li>Expand the <code>100</code>.</li><li>Set the <strong class="bold">Justification</strong> property to <strong class="bold">Align Text Center</strong>.</li></ul></li>
<li>Select <a id="_idIndexMarker692"/>the other <code>Text</code> element <a id="_idIndexMarker693"/>inside the <code>RestartButton</code> property, and change its <code>Restart</code>.</li>
<li>Duplicate the <code>RestartButton</code> property and change the copy’s name to <code>ExitButton</code>.</li>
<li>Change the <code>Text</code> element inside the <code>ExitButton</code> property to <code>Exit</code>.</li>
<li>Expand the <code>ExitButton</code> property, and set its <code>0.425</code> on the <em class="italic">X</em> axis and <code>0.615</code> on the <em class="italic">Y</em> axis. Then, set its <code>0.574</code> on the <em class="italic">X</em> axis and <code>0.725</code> on the <em class="italic">Y</em> axis.</li>
<li>Set the <code>ExitButton</code> properties of <code>0</code>.</li>
</ol>
<p>After you’ve done these changes, we’ll need to add the logic responsible for handling the <code>ExitButton</code> property click, which will exit the game:</p>
<ol>
<li value="9">Save the changes made to the <code>BP_RestartWidget</code> Widget Blueprint and open the <code>RestartWidget</code> class’s header file in Visual Studio. In this file, add a declaration for a <code>protected</code> function called <code>OnExitClicked</code> that returns nothing and receives no parameters. Be sure to mark it as<code>UFUNCTION</code>.</li>
<li>Duplicate <a id="_idIndexMarker694"/>the existing <code>RestartButton</code> property, but call it <code>ExitButton</code> instead.</li>
<li>Inside the <code>RestartWidget</code> class’s source file, add an implementation for the <code>OnExitClicked</code> function. Copy the contents of the <code>OnBeginOverlap</code> function from inside the <code>VictoryBox</code> class’s source file into the <code>OnExitClicked</code> function, but remove the cast being done to the <code>DodgeballCharacter</code> class.</li>
<li>In the <code>NativeOnInitialized</code> function implementation, bind the <code>OnExitClicked</code> function we created to the <code>OnClicked</code> event of the <code>ExitButton</code> property, in the same way that we did for the <code>RestartButton</code> property in <em class="italic">Exercise 8.03 – creating the RestartWidget C++ class</em>.</li>
</ol>
<p>And that <a id="_idIndexMarker695"/>concludes our code setup for this activity. Compile your changes, and open the editor. Then, open the <code>BP_RestartWidget</code> property and compile it just to make sure there are no compilation errors due to the <code>BindWidget</code> tags.</p>
<p>Once you’ve done this, play the level again, let the player character be hit by three dodgeballs, and notice the <code>Restart</code> widget appear with our new modifications:</p>
<div><div><img alt="Figure 8.36 – The updated BP_RestartWidget property being shown after the player runs out of health points " height="690" src="img/Figure_8.36_B18531.jpg" width="728"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.36 – The updated BP_RestartWidget property being shown after the player runs out of health points</p>
<p>If you <a id="_idIndexMarker696"/>press the <code>Restart</code> button, you should be <a id="_idIndexMarker697"/>able to replay the level, and if you press the <code>Exit</code> button, the game should end.</p>
<p>And that concludes our activity. You’ve consolidated the basics of using a <strong class="bold">Widget blueprint</strong> and changing its element’s properties. Now you are ready to start making your own menus.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>. </p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor182"/>Summary</h1>
<p>With this chapter concluded, you have now learned how to make a game UI in UE5, understanding things such as menus and HUDs. You’ve seen how to manipulate a Widget Blueprint’s UI elements, including Button elements, Text elements, and Progress Bar elements; work with anchors effectively, which is instrumental in allowing your game UI to adapt elegantly to multiple screens; listen to mouse events in C++, such as the <code>OnClick</code> event, and use that to create your own game logic; and how to add the widgets you create to the screen, either at specific events or have them present at all times.</p>
<p>In the next chapter, we’ll be taking a look at polishing our <strong class="bold">Dodgeball</strong> game by adding audiovisual elements, such as sound and particle effects, as well as making a new level.</p>
</div>
</div></body></html>