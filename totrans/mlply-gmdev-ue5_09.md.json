["```cpp\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Stealth\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<UPawnNoiseEmitterComponent> NoiseEmitter;\n```", "```cpp\n#include \"Components/PawnNoiseEmitterComponent.h\"\n```", "```cpp\nNoiseEmitter = CreateDefaultSubobject<UPawnNoiseEmitterComponent>(TEXT(\"NoiseEmitter\"));\nNoiseEmitter->NoiseLifetime = 0.01f;\n```", "```cpp\nif (GetCharacterMovement()->MaxWalkSpeed == GetCharacterStats()->SprintSpeed)\n{\n auto Noise = 1.f;\n if(GetCharacterStats() && GetCharacterStats()->StealthMultiplier)\n {\n  Noise = Noise / GetCharacterStats()->StealthMultiplier;\n }\n NoiseEmitter->MakeNoise(this, Noise, GetActorLocation());\n}\n```", "```cpp\nUFUNCTION()\nvoid OnHearNoise(APawn* PawnInstigator, const FVector& Location, float Volume);\n```", "```cpp\nUFUNCTION(BlueprintCallable, Category=\"Minion AI\")\nvoid GoToLocation(const FVector& Location);\n```", "```cpp\nGetPawnSense()->OnHearNoise.AddDynamic(this, &AUS_Minion::OnHearNoise);\n```", "```cpp\nvoid AUS_Minion::OnHearNoise(APawn* PawnInstigator, const FVector& Location, float Volume)\n{\n GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Noise detected!\"));\n GoToLocation(Location);\n UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);\n}\n```", "```cpp\nvoid AUS_Minion::GoToLocation(const FVector& Location)\n{\n PatrolLocation = Location;\n UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);\n}\n```", "```cpp\nUFUNCTION(BlueprintCallable, Category = \"Minions\")\nvoid AlertMinions(class AActor* AlertInstigator, const FVector& Location, float Radius);\n```", "```cpp\n#include \"US_Minion.h\"\n#include \"Kismet/GameplayStatics.h\"\n```", "```cpp\nvoid AUS_GameMode::AlertMinions(AActor* AlertInstigator, const FVector& Location, const float Radius)\n{\n TArray<AActor*> Minions;\n UGameplayStatics::GetAllActorsOfClass(GetWorld(), AUS_Minion::StaticClass(), Minions);\n for (const auto Minion : Minions)\n {\n  if(AlertInstigator == Minion) continue;\n  if (const auto Distance = FVector::Distance(AlertInstigator ->GetActorLocation(), Minion->GetActorLocation()); Distance < Radius)\n  {\n   if (const auto MinionCharacter = Cast<AUS_Minion>(Minion))\n   {\n    MinionCharacter->GoToLocation(Location);\n   }\n  }\n }\n}\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Minion AI\", meta = (AllowPrivateAccess = \"true\"))\nfloat AlertRadius = 6000.0f;\n```", "```cpp\n#include \"US_GameMode.h\"\n```", "```cpp\nif(const auto GameMode = Cast<AUS_GameMode>(GetWorld()->GetAuthGameMode()))\n{\n GameMode->AlertMinions(this, Pawn->GetActorLocation(), AlertRadius);\n}\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=\"Health\", meta = (AllowPrivateAccess = \"true\"))\nfloat Health = 5.f;\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=\"Pickup\", meta = (AllowPrivateAccess = \"true\"))\nTSubclassOf<class AUS_BasePickup> SpawnedPickup;\n```", "```cpp\nUFUNCTION()\nvoid OnDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);\n```", "```cpp\n#include \"US_BasePickup.h\"\n```", "```cpp\nstatic ConstructorHelpers::FClassFinder<AUS_BasePickup> SpawnedPickupAsset(TEXT(\"/Game/Blueprints/BP_GoldCoinPickup\"));\nif (SpawnedPickupAsset.Succeeded())\n{\n SpawnedPickup = SpawnedPickupAsset.Class;\n}\n```", "```cpp\nOnTakeAnyDamage.AddDynamic(this, &AUS_Minion::OnDamage);\n```", "```cpp\nvoid AUS_Minion::OnDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy,\n AActor* DamageCauser)\n{\n Health -= Damage;\n if(Health > 0) return;\n if(SpawnedPickup)\n {\n  GetWorld()->SpawnActor<AUS_BasePickup>(SpawnedPickup, GetActorLocation(), GetActorRotation());\n }\n Destroy();\n}\n```", "```cpp\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class USphereComponent> SphereCollision;\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<UStaticMeshComponent> Mesh;\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class UProjectileMovementComponent> ProjectileMovement;\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=\"Weapon\", meta = (AllowPrivateAccess = \"true\"))\nfloat Damage = 1.f;\n```", "```cpp\nFORCEINLINE USphereComponent* GetSphereCollision() const { return SphereCollision; }\nFORCEINLINE UStaticMeshComponent* GetMesh() const { return Mesh; }\nFORCEINLINE UProjectileMovementComponent* GetProjectileMovement() const { return ProjectileMovement; }\n```", "```cpp\nUFUNCTION()\nvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse,\n const FHitResult& Hit);\n```", "```cpp\n#include \"US_Character.h\"\n#include \"US_CharacterStats.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Engine/DamageEvents.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n```", "```cpp\nSphereCollision = CreateDefaultSubobject<USphereComponent>(\"Collision\");\nSphereCollision->SetGenerateOverlapEvents(true);\nSphereCollision->SetSphereRadius(10.0f);\nSphereCollision->BodyInstance.SetCollisionProfileName(\"BlockAll\");\nSphereCollision->OnComponentHit.AddDynamic(this, &AUS_BaseWeaponProjectile::OnHit);\nRootComponent = SphereCollision;\nMesh = CreateDefaultSubobject<UStaticMeshComponent>(\"Mesh\");\nMesh->SetupAttachment(RootComponent);\nMesh->SetCollisionEnabled(ECollisionEnabled::PhysicsOnly);\nMesh->SetRelativeLocation(FVector(-40.f, 0.f, 0.f));\nMesh->SetRelativeRotation(FRotator(-90.f, 0.f, 0.f));\nstatic ConstructorHelpers::FObjectFinder<UStaticMesh> StaticMesh(TEXT(\"/Game/KayKit/DungeonElements/dagger_common\"));\nif (StaticMesh.Succeeded())\n{\n GetMesh()->SetStaticMesh(StaticMesh.Object);\n}\nProjectileMovement = CreateDefaultSubobject<UProjectileMovement Component>(\"ProjectileMovement\");\nProjectileMovement->UpdatedComponent = SphereCollision;\nProjectileMovement->ProjectileGravityScale = 0;\nProjectileMovement->InitialSpeed = 3000;\nProjectileMovement->MaxSpeed = 3000;\nProjectileMovement->bRotationFollowsVelocity = true;\nProjectileMovement->bShouldBounce = false;\nbReplicates = true;\n```", "```cpp\nvoid AUS_BaseWeaponProjectile::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,\n UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n auto ComputedDamage = Damage;\n if (const auto Character = Cast<AUS_Character>(GetInstigator()))\n {\n  ComputedDamage *= Character->GetCharacterStats()->DamageMultiplier;\n }\n if (OtherActor && OtherActor != this)\n {\n  const FDamageEvent Event(UDamageType::StaticClass());\n  OtherActor->TakeDamage(ComputedDamage, Event, GetInstigatorController(), this);\n }\n Destroy();\n}\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=\"Projectile\", meta = (AllowPrivateAccess = \"true\"))\nTSubclassOf<class AUS_BaseWeaponProjectile> ProjectileClass;\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Input\", meta=(AllowPrivateAccess = \"true\"))\nclass UInputMappingContext* WeaponMappingContext;\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Input\", meta=(AllowPrivateAccess = \"true\"))\nclass UInputAction* ThrowAction;\n```", "```cpp\nUFUNCTION(BlueprintCallable, Category = \"Projectile\")\nvoid SetProjectileClass(TSubclassOf<class AUS_BaseWeaponProjectile> NewProjectileClass);\n```", "```cpp\nvoid Throw();\nUFUNCTION(Server, Reliable)\nvoid Throw_Server();\n```", "```cpp\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"US_BaseWeaponProjectile.h\"\n#include \"US_Character.h\"\n```", "```cpp\nProjectileClass = AUS_BaseWeaponProjectile::StaticClass();\n```", "```cpp\nconst ACharacter* Character = Cast<ACharacter>(GetOwner());\nif(!Character) return;\nif (const APlayerController* PlayerController = Cast<APlayerController>(Character->GetController()))\n{\n if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n {\n  Subsystem->AddMappingContext(WeaponMappingContext, 1);\n }\n if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerController->InputComponent))\n {\n  EnhancedInputComponent->BindAction(ThrowAction, ETriggerEvent::Triggered, this, &UUS_WeaponProjectileComponent::Throw);\n }\n}\n```", "```cpp\nvoid UUS_WeaponProjectileComponent::Throw()\n{\n Throw_Server();\n}\nvoid UUS_WeaponProjectileComponent:: Throw_Server_Implementation()\n{\n if (ProjectileClass)\n {\n  const auto Character = Cast<AUS_Character>(GetOwner());\n  const auto ProjectileSpawnLocation = GetComponentLocation();\n  const auto ProjectileSpawnRotation = GetComponentRotation();\n  auto ProjectileSpawnParams = FActorSpawnParameters();\n  ProjectileSpawnParams.Owner = GetOwner();\n  ProjectileSpawnParams.Instigator = Character;\n  GetWorld()->SpawnActor<AUS_BaseWeaponProjectile>(ProjectileClass, ProjectileSpawnLocation, ProjectileSpawnRotation, ProjectileSpawnParams);\n }\n}\n```", "```cpp\nvoid UUS_WeaponProjectileComponent::SetProjectileClass(TSubclassOf<AUS_BaseWeaponProjectile> NewProjectileClass)\n{\n ProjectileClass = NewProjectileClass;\n}\n```", "```cpp\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Weapon\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class UUS_WeaponProjectileComponent> Weapon;\n```", "```cpp\nFORCEINLINE UUS_WeaponProjectileComponent* GetWeapon() const { return Weapon; }\n```", "```cpp\n#include \"US_WeaponProjectileComponent.h\"\n```", "```cpp\nWeapon = CreateDefaultSubobject<UUS_WeaponProjectileComponent>(TEXT(\"Weapon\"));\nWeapon->SetupAttachment(RootComponent);\nWeapon->SetRelativeLocation(FVector(120.f, 70.f, 0.f));\n```"]