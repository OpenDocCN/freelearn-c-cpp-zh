- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Classes in Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will begin our pursuit of **object-oriented programming** (**OOP**)
    in C++. We will begin by introducing **object-oriented** (**OO**) concepts and
    then progress to understanding how these concepts can be implemented in C++. Many
    times, implementing OOP ideas will be through *direct language support*, such
    as the features in this chapter. Sometimes, however, we will utilize various programming
    techniques to implement object-oriented concepts. These techniques will be seen
    in later chapters. In all cases, it is important to understand the object-oriented
    concepts and how these concepts relate to well-thought-out designs, and then have
    a clear understanding of how to implement these designs with robust code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will detail C++ class usage in extreme detail. Subtle features
    and nuances are detailed beyond the basics. The goal of this chapter will be to
    allow you to understand OO concepts, and for you to begin to think in terms of
    object-oriented programming. Embracing core OO ideals, such as encapsulation and
    information hiding, will allow you to write code that is easier to maintain, and
    will allow you to modify others’ code more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining object-oriented terminology and concepts – object, class, instance,
    encapsulation and information hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying class and member function basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining member function internals; the `this` pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using access labels and access regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding constructors – default, overloaded, copy, conversion constructors,
    and in-class initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding destructors and their proper usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying qualifiers to data members and member functions – `inline`, `const`,
    and `static`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand core object-oriented terminology
    applicable to classes, and how key OO ideas such as encapsulation and information
    hiding will lead to software that is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: You will also appreciate how C++ provides built-in language features to support
    object-oriented programming. You will become well versed in the use of member
    functions and will understand their underlying implementation through the `this`
    pointer. You will understand how to correctly use access labels and access regions
    to promote encapsulation and information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: You will understand how constructors can be used to initialize objects, and
    the many varieties of constructors from basic to typical (overloaded) to the copy
    constructor, and even conversion constructors. Similarly, you will understand
    how to make proper use of the destructor prior to an object’s end of existence.
  prefs: []
  type: TYPE_NORMAL
- en: You will also understand how qualifiers, such as `const`, `static`, and `inline`,
    may be applied to member functions to support either object-oriented concepts
    or efficiency. Likewise, you will understand how to apply qualifiers, such as
    `const` and `static`, to data members to additionally support OO ideals.
  prefs: []
  type: TYPE_NORMAL
- en: C++ can be used as an object-oriented programming language, but it is not automatic.
    To do so, you must understand OO concepts, ideology, and language features that
    will allow you to support this endeavor. Let us begin our pursuit of writing code
    that is easier to modify and maintain by understanding the core and essential
    building block found in object-oriented C++ programs, the C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter05`
    in a file named `Chp5-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3KaiQ39](https://bit.ly/3KaiQ39).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing object-oriented terminology and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce core object-oriented concepts as well as
    applicable terminology that will accompany these key ideas. Though new terms will
    come up throughout this chapter, we will begin with essential terms necessary
    to begin our journey in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with basic object-oriented terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-oriented terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin with basic object-oriented terminology, and then as we introduce
    new concepts, we will extend the terminology to include C++ specific terminology.
  prefs: []
  type: TYPE_NORMAL
- en: The terms object, class, and instance are all important and related terms with
    which we can start our definitions. An **object** embodies a meaningful grouping
    of characteristics and behaviors. An object can be manipulated and can receive
    the action or consequences of a behavior. Objects may undergo transformations
    and can change repeatedly over time. Objects can interact with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: The term object, at times, may be used to describe the blueprint for groupings
    of like items. The term **class** may be used interchangeably with this usage
    of an object. The term object may also (and more often) be used to describe a
    specific item in such a grouping. The term **instance** may be used interchangeably
    with this meaning of an object. The context of usage will often make clear which
    meaning of the term *object* is being applied. To avoid potential confusion, the
    terms *class* and *instance* can preferably be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider some examples, using the aforementioned terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.1_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Objects also have components. The characteristics of a class are referred to
    as **attributes**. Behaviors of a class are referred to as **operations**. The
    specific implementation of a behavior or operation is referred to as its **method**.
    In other words, the method is how an operation is implemented, or the body of
    code defining the function, whereas the operation is the function’s prototype
    or protocol for usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider some high-level examples, using the aforementioned terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.2_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each instance of a class will most likely have distinct values for its attributes.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.3_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the basic OO terms under our belt, let’s move on to important
    object-oriented concepts that are relevant to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-oriented concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key object-oriented concepts relating to this chapter are *encapsulation*
    and *information hiding*. Incorporating these interrelated ideals into your design
    will provide the basis for writing more easily modifiable and maintainable programs.
  prefs: []
  type: TYPE_NORMAL
- en: The grouping of meaningful characteristics (attributes) and behaviors (operations)
    that operate on those attributes, bundled together in a single unit, is known
    as **encapsulation**. In C++, we typically group these items together in a class.
    The interface to each class instance is made through operations that model the
    behaviors relevant to each class. These operations may additionally modify the
    internal state of the object by changing the values of its attributes. Concealing
    attributes within a class and providing an interface for operating on those details
    leads us to explore the supportive concept of information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Information hiding** refers to the process of *abstracting* the details of
    performing an operation into a class method. That is, the user needs only to understand
    which operation to utilize and its overall purpose; the implementation details
    are hidden within the method (function’s body). In this fashion, changing the
    underlying implementation (method) will not change the operation’s interface.
    Information hiding can additionally refer to keeping the underlying implementation
    of a class’ attributes hidden. We will explore this further when we introduce
    access regions. Information hiding is a means to achieve proper encapsulation
    of a class. A properly encapsulated class will enable proper class abstraction
    and thus the support of OO designs.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented systems are inherently more easily maintained because classes
    allow upgrades and modifications to be made quickly and without impact to the
    entire system due to encapsulation and information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding class and member function basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A C++ **class** is a fundamental building block in C++ that allows a programmer
    to specify a user defined type, encapsulating related data and behaviors. A C++
    class definition will contain attributes, operations, and sometimes methods. C++
    classes support encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a variable of a class type is known as **instantiation**. The attributes
    in a class are known as **data members** in C++. Operations in a class are known
    as **member functions** in C++ and are used to model behaviors. In OO terms, an
    operation implies the signature of a function, or its prototype (declaration),
    and the method implies its underlying implementation or the body of the function
    (definition). In some OO languages, the term *method* is used more loosely to
    imply either the operation or its method, based on the context of usage. In C++,
    the terms *data member* and *member function* are most often used.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype for a member function must be placed in a class definition. Most
    often, the member function definition is placed outside of the class definition.
    The scope resolution operator `::` is then used to associate a given member function
    definition to the class in which it is a member. Dot `.` or arrow `->` notation
    is used to access all class members, including member functions, depending on
    whether we are accessing members through an instance or through a pointer to an
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: C++ structures may also be used to encapsulate data and their related behaviors.
    A C++ `struct` can do anything a C++ `class` can do; in fact, `class` is implemented
    in terms of `struct` in C++. Though structures and classes may behave identically
    (other than default visibility), classes are more often used to model objects,
    relationships between object types, and implement object-oriented systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple example in which we instantiate a `class` and
    a `struct`, each with member functions, for comparison with one another. We will
    break this example into several segments. The full program example can be found
    in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first define a `student` type using a `struct`,
    and a `University` type using a `class`. Notice, by convention, that user defined
    types created using structures are not capitalized, yet user defined types created
    using classes begin with a capital letter. Also notice that the `class` definition
    requires the label `public:` toward the beginning of its definition. We will explore
    the use of this label later in this chapter; however, for now, the `public` label
    is present so that this `class` will have the same default visibility of its members
    as does the `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: In both the `class` and `struct` definitions, notice the function prototypes
    for `Initialize()` and `Print()`. We will tie these prototypes to member function
    definitions in the next program segment using `::`, the scope resolution operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the various member function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s review the various member function definitions for each user defined
    type. The definitions for `void student::Initialize(string, float)`, `void student::Print()`,
    `void University::Initialize(string, int)`, and `void University::Print()` appear
    consecutively in the preceding fragment. Notice how the scope resolution operator
    `::` allows us to tie the relevant function definition back to the `class` or
    `struct` in which it is a member.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, notice that in each `Initialize()` member function, the input
    parameters are used as values to load the relevant data members for a specific
    instance of a specific class or struct type. For example, in the function definition
    of `void University::Initialize(string n, int num)`, the input parameter `num`
    is used to initialize `numStudents` for a particular `University` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The scope resolution operator `::` associates member function definitions with
    the class (or struct) in which they are a member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how member functions are called by considering `main()` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in `main()`, we simply define a variable, `s1`, of type `student`, and
    a variable, `u1`, of type `University`. In object-oriented terms, it is preferable
    to say that `s1` is an instance of `student`, and `u1` is an instance of `University`.
    The instantiation occurs when the memory for an object is made available. For
    this reason, declaring pointer variable `u2` using: `University *u2;` does not
    instantiate a `University`; it merely declares a pointer to a possible future
    instance. Rather, on the following line, `u2 = new University();`, we instantiate
    a `University` when the memory is allocated.'
  prefs: []
  type: TYPE_NORMAL
- en: For each of the instances, we initialize their data members by calling their
    respective `Initialize()` member functions, such as `s1.Initialize("Gabby Doone",
    4.0);` or `u1.Initialize("UMD", 4500);`. We then call `Print()` through each respective
    instance, such as `u2->Print();`. Recall that `u2->Print();` may also be written
    as `(*u2).Print();`, which more easily allows us to remember that the instance
    here is `*u2`, whereas `u2` is a pointer to that instance.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we call `Initialize()` through `s1`, we call `student::Initialize()`
    because `s1` is of type `student`, and we initialize `s1`’s data members in the
    body of this function. Similarly, when we call `Print()` through `u1` or `*u2`,
    we call `University::Print()` because `u1` and `*u2` are of type `University`
    and we subsequently print out a particular university’s data members.
  prefs: []
  type: TYPE_NORMAL
- en: Since instance `u1` was dynamically allocated on the heap, we are responsible
    for releasing its memory using `delete()` toward the end of `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are creating class definitions with their associated member function
    definitions, it is important to know how developers typically organize their code
    in files. Most often, a class will be broken into a header (`.h`) file, which
    will contain the class definition, and a source code (`.cpp`) file, which will
    `#include` the header file, and then follow with the member function definitions
    themselves. For example, a class named `University` would have a `University.h`
    header file and a `University.cpp` source code file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move forward with our understanding of the details of how member
    functions work by examining the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Examining member function internals; the “this” pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have noticed that member functions are invoked through objects. We
    have noticed that in the scope of a member function, it is the data members (and
    other member functions) of the particular object that invoked the function that
    may be utilized (in addition to any input parameters). Alas, how, and why does
    this work?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that most often, member functions are invoked through objects.
    Whenever a member function is invoked in this fashion, that member function receives
    a pointer to the instance that invoked the function. A pointer to the object calling
    the function is then passed as an implicit first argument to the function. The
    name of this pointer is **this**.
  prefs: []
  type: TYPE_NORMAL
- en: Though the `this` pointer may be referred to explicitly in the definition of
    each such member function, it usually is not. Even without its explicit use, the
    data members utilized in the scope of the function belong to `this`, a pointer
    to the object that invoked the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at a full program example. Though the example is broken
    into segments, the full program can be found in the following GitHub location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first segment of the program, we define class `Student` with a variety
    of data members, and two member function prototypes. For now, we will place everything
    in the `public` access region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine the member function definitions for `void Student::Initialize()`
    and `void Student::Print()`. We will also examine how each of these functions
    looks internally to C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we see the member function definition for `void Student::Initialize()`,
    which takes a variety of parameters. Notice that in the body of this function,
    we first assign input parameter `fn` to data member `firstName`. We proceed similarly,
    using the various input parameters, to initialize the various data members for
    the specific object that will invoke this function. Also notice that we allocate
    memory for pointer data member `currentCourse` to be enough characters to hold
    what input parameter `course` requires (plus one for the terminating null character).
    We then `strcpy()` the string from the input parameter, `course`, to data member
    `currentCourse`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice in `void Student::Initialize()`, the assignment `this->middleInitial
    = mi;`. Here, we have an optional, explicit use of the `this` pointer. It is not
    necessary or customary in this situation to qualify `middleInitial` with `this`,
    but we may choose to do so. However, in the assignment `this->gpa = gpa;`, the
    use of `this` is required. Why? Notice that the input parameter is named `gpa`
    and the data member is also `gpa`. Simply assigning `gpa = gpa;` would set the
    most local version of `gpa` (the input parameter) to itself and would not affect
    the data member. Here, disambiguating `gpa` with `this` on the left-hand side
    of the assignment indicates to set the data member, `gpa`, which is pointed to
    by `this`, to the value of the input parameter, `gpa`. Another solution is to
    use distinct names for data members versus input parameters, such as renaming
    `gpa` in the formal parameter list to `avg` (which we will do in later versions
    of this code).
  prefs: []
  type: TYPE_NORMAL
- en: Now, notice the commented-out version of `void Student::Initialize()`, which
    is below the utilized version of `void Student::Initialize()`. Here, we can see
    how most member functions are internally represented. First, notice that the name
    of the function is *name mangled* to include the data types of its parameters.
    This is internally how functions are represented, and consequentially, allows
    function overloading (that is, two functions with seemingly the same name; internally,
    each has a unique name). Next, notice that among the input parameters, there is
    an additional, first, input parameter. The name of this additional (hidden) input
    parameter is `this`, and it is defined as `Student *const this`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the body of the internalized function view of `void Student::Initialize()`,
    notice that each data member’s name is preceded with `this`. We are, in fact,
    accessing the data member of an object that is pointed to by `this`. Where is
    `this` defined? Recall that `this` is the implicit first input parameter to this
    function, and is a constant pointer to the object that invoked this function.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can review the member function definition for `void Student::Print()`.
    In this function, each data member is neatly printed out using `cout` and the
    insertion operator `<<`. However, notice below this function definition, the commented-out
    internal version of `void Student::Print()`. Again, `this` is actually an implicit
    input parameter of type `Student *const`. Also, each data member usage is preceded
    with access through the `this` pointer, such as `this->gpa`. Again, we can clearly
    see that a specific instance’s members are accessed in the scope of a member function;
    these members are implicitly accessed through the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, note that explicit use of `this` is permitted in the body of a member
    function. We can almost always precede usage of a data member or member function,
    accessed in the body of a member function, with explicit use of `this`. Later
    in this chapter, we will see the one contrary case (using a static method). Also,
    later in this book, we will see situations in which explicit usage of `this` will
    be necessary to implement more intermediate-level OO concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, let’s move forward by examining `main()` to complete this program
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the last segment of this program, we instantiate `Student` twice in `main()`.
    `Student` `s1` is an instance, whereas `s2` is a pointer to a `Student`. Next,
    we utilize either `.` or `->` notation to invoke the various member functions
    through each relevant instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note, when `s1` invokes `Initialize()`, the `this` pointer (in the scope of
    the member function) will point to `s1`. It will be as if `&s1` is passed as a
    first argument to this function. Likewise, when `*s2` invokes `Initialize()`,
    the `this` pointer will point to `s2`; it will be as if `s2` (which is already
    a pointer) is passed as an implicit first argument to this function.
  prefs: []
  type: TYPE_NORMAL
- en: After each instance invokes `Print()` to display the data members for each `Student`,
    notice that we release various levels of dynamically allocated memory. We start
    with the dynamically allocated data members for each instance, releasing each
    such member using `delete()`. Then, because `s2` is a pointer to an instance that
    we have dynamically allocated, we must also remember to release the heap memory
    comprising the instance itself. We again do so with `delete s2;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s add to our understanding of classes and information hiding by examining
    access labels and regions.
  prefs: []
  type: TYPE_NORMAL
- en: Using access labels and access regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Labels may be introduced into a class (or structure) definition to control the
    access or visibility of class (or structure) members. By controlling the direct
    access of members from various scopes in our application, we can support encapsulation
    and information hiding. That is, we can insist that users of our classes use the
    functions that we select, with the protocols we select, to manipulate data and
    other member functions within the class in ways we, the programmers, find reasonable
    and acceptable. Furthermore, we can hide the implementation details of the class
    by advertising to the user only the desired public interface for a given class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data members or member functions, collectively referred to as **members**,
    can be individually labeled, or grouped together into access regions. The three
    labels or **access regions** that may be specified are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private**: Data members and member functions in this access region are only
    accessible within the scope of the class. The scope of a class includes member
    functions of that class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` until we introduce inheritance. When inheritance is introduced, `protected`
    will provide a mechanism for allowing access within the derived class scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public**: Data members and member functions in this access region are accessible
    from any scope in the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Data members and member functions are most always accessed via instances. You
    will ask, *in what scope is my instance?*, and *may I access a particular member
    from this particular scope?*
  prefs: []
  type: TYPE_NORMAL
- en: As many members as required by the programmer may be grouped under a given label
    or `private`. If access labels are omitted in a structure definition, default
    member access is `public`. When access labels are explicitly introduced, rather
    than relying on default visibility, a `class` and a `struct` are identical. Nonetheless,
    in object-oriented programming, we tend to utilize classes for user defined types.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that data members, when grouped into an access region
    collectively under the same access label, are guaranteed to be laid out in memory
    in the order specified. However, if multiple access regions exist containing data
    members within a given class, the compiler is free to reorder those respective
    groupings for efficient memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine an example to illustrate access regions. Though this example
    will be broken into several segments, the full example will be shown and can also
    be found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first define the `Student` class. Notice that we add a `private`
    access region near the top of the class definition and place all of the data members
    within this region. This placement will ensure that these data members will only
    be able to be directly accessed and modified within the scope of this class, which
    means by member functions of this class (and friends, which we will much later
    see). By limiting the access of data members only to member functions of their
    own class, safe handling of those data members is ensured; only access through
    intended and safe functions that the class designer has introduced themself will
    be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that the label `public` has been added in the class definition
    prior to the prototypes of the member functions. The implication is that these
    functions will be accessible in any scope of our program. Of course, we will generally
    need to access these functions each via an instance. But the instance can be in
    the scope of `main()` or any other function (even in the scope of another class’
    member functions) when the instance accesses these public member functions. This
    is known as a class’ `public` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Access regions support encapsulation and information hiding
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to place your data members in the `private` access region
    and then specify a safe, appropriate `public` interface to access them using `public`
    member functions. By doing so, the only access to data members is in manners that
    the class designer has intended, through member functions the class designer has
    written, which have been well tested. With this strategy, the underlying implementation
    of the class may also be changed without causing any calls to the public interface
    to change. This practice supports encapsulation and information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue by taking a look at the various member function definitions
    in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined the various member functions that were prototyped in our
    class definition. Notice the use of the scope resolution operator `::` to tie
    the class name to the member function name. Internally, these two identifiers
    are *name mangled* together to provide a unique, internal function name. Notice
    that the `void Student::Initialize()` function has been overloaded; one version
    simply initializes all data members to some form of null or zero, whereas the
    overloaded version uses input parameters to initialize the various data members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s continue by examining our `main()` function in the following segment
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `main()` function, we first instantiate a `Student` with
    the declaration `Student s1;`. Next, `s1` invokes the `Initialize()` function
    with the signature matching the parameters provided. Since this member function
    is in the `public` access region, it can be accessed in any scope of our program,
    including `main()`. Similarly, `s1` invokes `Print()`, which is also `public`.
    These functions are in the `Student` class’ public interface, and represent some
    of the core functionality for manipulating any given `Student` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the commented-out line of code, notice that `s1` tries to access `firstName`
    directly using `s1.firstName`. Because `firstName` is `private`, this data member
    can only be accessed in the scope of its own class, which means member functions
    (and later friends) of its class. The `main()` function is not a member function
    of `Student`, hence `s1` may not access `firstName` in the scope of `main()`,
    that is, a scope outside its own class.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we invoke `s1.CleanUp();`, which also works because `CleanUp()` is `public`
    and is hence accessible from any scope (including `main()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this complete example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how access regions work, let’s move forward by examining
    a concept known as a constructor, and the various types of constructors available
    within C++.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you notice how convenient it has been for the program examples in this chapter
    to have an `Initialize()` member function for each `class` or `struct`? Certainly,
    it is desirable to initialize all data members for a given instance. More so,
    it is crucial to ensure that data members for any instance have bonafide values,
    as we know that memory is not provided *clean* or *zeroed-out* by C++. Accessing
    an uninitialized data member, and utilizing its value as if it were bonafide,
    is a potential pitfall awaiting the careless programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing each data member individually each time a class is instantiated
    can be tedious work. What if we simply overlook setting a value? What if the values
    are `private`, and are therefore not directly accessible? We have seen that an
    `Initialize()` function is beneficial because once written, it provides a means
    to set all data members for a given instance. The only drawback is that the programmer
    must now remember to call `Initialize()` on each instance in the application.
    Instead, what if there is a way to ensure that an `Initialize()` function is called
    every time a class is instantiated? What if we could overload a variety of versions
    to initialize an instance, and the appropriate version could be called based on
    data available at the time? This premise is the basis for a constructor in C++.
    The language provides for an overloaded series of initialization functions, which
    will be automatically called once the memory for an instance becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at this family of initialization member functions by examining
    the C++ constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Applying constructor basics and overloading constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `class` (or `struct`) to define multiple means by which to initialize an object.
    The return type of a constructor may not be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Should your `class` or `struct` not contain a constructor, one will be made
    for you in the `public` access region, with no arguments. This is known as a default
    constructor. Behind the scenes, every time an object is instantiated, a constructor
    call is patched in by the compiler. When a class without a constructor is instantiated,
    the default constructor is patched in as a function call immediately following
    the instantiation. This system-supplied member function will have an empty body
    (method) and it will be linked into your program so that any compiler-added, implicit
    calls to this function upon instantiation can occur without a linker error. As
    needed per the design, a programmer may often write their own default (no-argument)
    constructor; that is, one that is used for the default means of instantiation
    with no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Most programmers provide at least one constructor, in addition to their own
    no-argument, default constructor. Recall that constructors can be overloaded.
    It is important to note that if you provide any constructor yourself, you will
    not then receive the system supplied no-argument default constructor, and that
    subsequently using such an interface for instantiation will cause a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Constructors have the same name as the class. You may not specify their return
    type. They can be overloaded. The compiler only creates a public, default (no-argument)
    constructor if you have not provided any constructors (that is, means for instantiation)
    in your class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce a simple example to understand constructor basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program segment, we first define `class University`; the data
    members are `private`, and the three member functions are `public`. Notice that
    the first two member functions prototyped are constructors. Both have the same
    name as the class; neither has its return type specified. The two constructors
    are overloaded, in that each has a different signature.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that the three member functions are defined. Notice the use of
    the scope resolution operator `::` preceding each member function name, in each
    of their definitions. Each constructor provides a different means for initializing
    an instance. The `void University::Print()` member function merely provides a
    means to provide simple output for our example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in `main()`, let’s create three instances of `University`. The first line
    of code, `University u1;`, instantiates a `University` and then implicitly invokes
    the default constructor to initialize the data members. On the next line of code,
    `University u2("University of Delaware", 23800);`, we instantiate a second `University`.
    Once the memory for that instance has been made available on the stack in `main()`,
    the constructor matching the signature of the arguments provided, namely `University::University(const
    string &, int)`, will be implicitly invoked to initialize the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we instantiate a third `University` using `University u3{"Temple University",
    20500};`, which also makes use of the alternate constructor. Notice the use of
    `{}`’s versus `()`’s in the instantiation and construction of `u3`. Either style
    may be utilized. The latter style was introduced in an effort to create uniformity;
    neither construct results in a performance advantage.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that based upon how we instantiate an object, we can specify which
    constructor we would like to be called on our behalf to perform the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Parameter comparison
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice the signature to the alternate `University` constructor is `University(const
    string &, int);`? That is, the first parameter is a `const string &` rather than
    a `string`, as used in previous examples for our `Initialize()` member function?
    Both are acceptable. A `string` parameter will pass a copy of the formal parameter
    on the stack to the member function. If the formal parameter is a string literal
    in quotes (such as `"University of Delaware"`), a `string` instance will first
    be made to house this literal string of characters. In comparison, if the parameter
    to the constructor is a `const string &`, then a reference to the formal parameter
    will be passed to this function and the object referenced will be treated as `const`.
    In the body of the constructor, we use assignment to copy the value of the input
    parameter to the data member. Not to worry, the implementation of the assignment
    operator for the `string` class performs a deep assignment from the source to
    the destination string. The implication is that we do not have to worry about
    the data member sharing memory (that is, not having its own copy) with the initialization
    data (string). Therefore, either use of a `string` or `const string &` as a parameter
    for the constructor is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s complement our use of constructors with in-class initializers.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and in-class initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to initializing data members within a constructor, a class may optionally
    contain **in-class initializers**. That is, default values that can be specified
    in a class definition as a means to initialize data members in the absence of
    specific constructor initialization (or assignment) of those data members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a revision of our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragment, notice that our class definition for `University`
    contains two in-class initializers for data members `name` and `numStudents`.
    These values will be used to initialize data members for a `University` instance
    when a `University` constructor does not otherwise set these values. More specifically,
    if a `University` constructor uses initialization to set these values, the in-class
    initializers will be ignored (we will see formal constructor initialization with
    the member initialization list shortly in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if a constructor sets these data members through assignment within
    the body of a constructor (as we have seen in the previous constructor example),
    the assignments will overwrite any in-class initialization that was otherwise
    done on our behalf. However, if we do not set data members in a constructor (as
    shown in the current code fragment), the in-class initializers will be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: In-class initializers can be used to simplify default constructors or to alleviate
    default values specified within a constructor’s prototype (a style that is becoming
    less popular).
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in this example, in-class initializers can lead to a default
    constructor having no work (that is, initialization) remaining to be conducted
    in the method body itself. Yet, we can see that in some cases, a default constructor
    is necessary if we would like to use the default interface for instantiation.
    In cases such as these, `=default` may be added to the prototype of the default
    constructor to indicate that the system-supplied default constructor (with an
    empty body) should be linked in on our behalf, alleviating our need to provide
    an empty, default constructor ourselves (as in our previous example).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this improvement, our class definition will become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition, we have now requested the system-supplied
    default constructor (with an empty body) in a situation where we would not have
    otherwise gotten one automatically (because we have provided a constructor with
    another signature). We have saved specifying an empty-bodied default constructor
    ourselves, as in our original example.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add to our knowledge of constructors by examining a copy constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating copy constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **copy constructor** is a specialized constructor that is invoked whenever
    a copy of an object may need to be made. Copy constructors may be invoked during
    the construction of another object. They may also be invoked when an object is
    passed by value to a function via an input parameter or returned by value from
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: Often, it is easier to make a copy of an object and modify the copy slightly
    than to construct a new object with its individual attributes from scratch. This
    is especially true if a programmer requires a copy of an object that has undergone
    many changes during the life of the application. It may be impossible to recall
    the order of various transformations that may have been applied to the object
    in question in order to create a duplicate. Instead, having the means to copy
    an object is desirable, and possibly crucial.
  prefs: []
  type: TYPE_NORMAL
- en: The signature of a copy constructor is `ClassName::ClassName(const ClassName
    &);`. Notice that a single object is explicitly passed as a parameter, and that
    parameter will be a reference to a constant object. The copy constructor, as do
    most member functions, will receive an implicit argument to the function, the
    `this` pointer. The purpose of the copy constructor’s definition will be to make
    a copy of the explicit parameter to initialize the object pointed to by `this`.
  prefs: []
  type: TYPE_NORMAL
- en: If no copy constructor is implemented by the `class` (or `struct`) designer,
    one will be provided for you (in the `public` access region) that performs a shallow,
    member-wise copy. This is unlikely not what you want if you have data members
    in your class that are pointers. Instead, the best thing to do is to write a copy
    constructor yourself, and write it to perform a deep copy (allocating memory as
    necessary) for data members that are pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should the programmer wish to disallow copying during construction, `=delete`
    can be used in the prototype of the copy constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, if the programmer wishes to prohibit object copying, a copy constructor
    may be prototyped in the `private` access region. In this case, the compiler will
    link in the default copy constructor (which performs a shallow copy), but it will
    be considered private. Therefore, instantiations that would utilize the copy constructor
    outside the scope of the class will be prohibited. This technique is used less
    frequently since the advent of `=delete`; however, it may be seen in existing
    code, so it is useful to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a copy constructor, starting with the class definition. Though
    the program is presented in several fragments, the full program example may be
    found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this program segment, we start by defining `class Student`. Notice the usual
    assortment of `private` data members and `public` member function prototypes,
    including the default constructor and an overloaded constructor. Also notice the
    prototype for the copy constructor `Student(const Student &);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at the member function definitions with the following
    continuation of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code fragment, we have various member function definitions.
    Most notably, let’s consider the copy constructor definition, which is the member
    function with the signature of `Student::Student(const Student &s)`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the input parameter, `s`, is a reference to a `Student` that is
    `const`. This means that the source object, which we will be copying from, may
    not be modified. The destination object, which we will be copying into, will be
    the object pointed to by the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: As we carefully navigate the copy constructor, notice that we successively allocate
    space, as necessary, for any pointer data members that belong to the object pointed
    to by `this`. The space allocated is the same size as required by the data members
    referred to by `s`. We then carefully copy from source data member to destination
    data member. We meticulously ensure that we make an exact copy in the destination
    object of the source object.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are making a *deep copy* in the destination object. That is,
    rather than simply copying the pointers contained in `s.currentCourse` to `this->currentCourse`,
    for example, we instead allocate space for `this->currentCourse` and then copy
    over the source data. The result of a shallow copy would instead be that the pointer
    data members in each object would share the same dereferenced memory (that is,
    the memory to which each pointer points). This is most likely not what you would
    want in a copy. Also recall that the default behavior of a system-supplied copy
    constructor would be to provide a shallow copy from the source to the destination
    object. It is also worthy to note that the assignment between two strings such
    as `firstName = s.firstName;` in the copy constructor will perform a deep assignment
    from source to destination string because that is the behavior of the assignment
    operator defined by the string class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at our `main()` function to see the various ways in
    which the copy constructor could be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In `main()`, we declare two instances of `Student`, `s1` and `s2`, and each
    is initialized with the constructor that matches the signature of `Student::Student(const
    string &, const string &, char, float, const char *);`. Notice that the signature
    used in instantiation is how we select which constructor should be implicitly
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate `s3` and pass as an argument to its constructor the object
    `s1` with `Student s3(s1);`. Here, `s1` is of type `Student`, so this instantiation
    will match the constructor that accepts a reference to a `Student`, the copy constructor.
    Once in the copy constructor, we know that we will make a deep copy of `s1` to
    initialize the newly instantiated object, `s3`, which will be pointed to by the
    `this` pointer in the scope of the copy constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we instantiate `s4` with the following line of code: `Student
    s4 = s2;`. Here, because this line of code is an initialization (that is, `s4`
    is both declared and given a value in the same statement), the copy constructor
    will also be invoked. The source object of the copy will be `s2` and the destination
    object will be `s4`. Notice that we then modify each of the copies (`s3` and `s4`)
    slightly by modifying their `firstName` data members.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the commented-out section of code, we instantiate two objects of type
    `Student`, `s5` and `s6`. We then try to assign one to the other with `s5 = s6;`.
    Though this looks similar to the initialization between `s4` and `s2`, it is not.
    The line `s5 = s6;` is an assignment. Each of the objects existed previously.
    As such, the copy constructor is not called for this segment of code. Nonetheless,
    this code is legal and has similar implications as with the assignment operator.
    We will examine these details later in the book when we discuss operator overloading
    in [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator Overloading*.
  prefs: []
  type: TYPE_NORMAL
- en: We then print out objects `s1`, `s2`, `s3`, and `s4`. Then, we call `Cleanup()`
    on each of these four objects. Why? Each object contained data members that were
    pointers, so it is appropriate to delete the heap memory contained within each
    instance (that is, selected pointer data members) prior to these outer stack objects
    going out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output for this example shows each original `Student` instance, paired with
    its copy. Notice that each copy has been modified slightly from the original (`firstName`
    differs).
  prefs: []
  type: TYPE_NORMAL
- en: Related topic
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that the assignment operator shares many similarities
    with the copy constructor, in that it can allow data to be copied from a source
    to destination instance. However, the copy constructor is implicitly invoked for
    the initialization of a new object, whereas the assignment operator will be invoked
    when performing an assignment between two existing objects. Nonetheless, the methods
    of each will look strikingly similar! We will examine overloading the assignment
    operator to customize its behavior to perform a deep assignment (much like a deep
    copy) in [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator
    Overloading*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a deep understanding of copy constructors, let’s look at one
    last variety of constructor, the conversion constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating conversion constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type conversions can be performed from one user defined type to another, or
    from a standard type to a user defined type. A conversion constructor is a language
    mechanism that allows such conversions to occur.
  prefs: []
  type: TYPE_NORMAL
- en: A **conversion constructor** is a constructor that accepts one explicit argument
    of a standard or user defined type and applies a reasonable conversion or transformation
    on that object to initialize the object being instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example illustrating this idea. Though the example
    will be broken into several segments and also abbreviated, the full program can
    be found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program segment, we first include a forward declaration to `class
    Student;` – this declaration allows us to refer to the `Student` type prior to
    its definition. We then define `class Employee`. Notice that this class includes
    several `private` data members and three constructor prototypes – a default, alternative,
    and conversion constructor. As a side note, notice that a copy constructor has
    not been programmer-specified. This means that a default (shallow) copy constructor
    will be provided by the compiler. In this case, since there are no pointer data
    members, the shallow copy is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, let us continue by examining the `Employee` conversion constructor
    prototype. Notice that in the prototype, this constructor takes a single argument.
    The argument is a `Student &`, which is why we needed the forward declaration
    for `Student`. Preferably, we might use a `const Student &` as the parameter type,
    but we will need to understand const member functions (later in this chapter)
    in order to do so. The type conversion that will take place will be to convert
    a `Student` into a newly constructed `Employee`. It will be our job to provide
    a meaningful conversion to accomplish this in the definition for the conversion
    constructor, which we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define our `Student` class, which is much the same as we have seen
    in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us continue with the example to see the member function definitions
    for `Employee` and `Student`, and our `main()` function, in the following code
    segment. To conserve space, selected member function definitions will be omitted,
    however, the online code will show the program in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving onward, our member functions for `Employee` and `Student` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we notice several constructor definitions for
    `Employee`. We have a default, alternate, and conversion constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the definition of the `Employee` conversion constructor, notice that
    the formal parameter for the source object is `s`, which is of type `Student`.
    The destination object will be the `Employee` that is being constructed, which
    will be pointed to by the `this` pointer. In the body of this function, we carefully
    copy the `firstName` and `lastName` from `Student &s` to the newly instantiated
    `Employee`. Note that we use access functions `const string &Student::GetFirstName()`
    and `const string &Student::GetLastName()` to do so (via an instance of `Student`),
    as these data members are `private`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue with the conversion constructor. It is our job to provide a meaningful
    conversion from one type to another. In that endeavor, we try to establish an
    initial salary for the `Employee` based on the `gpa` of the source `Student` object.
    Because `gpa` is `private`, an access function, `Student::GetGpa()`, is used to
    retrieve this value (via the source `Student`). Notice that because `Employee`
    did not have any dynamically allocated data members, we did not need to allocate
    memory to assist in a deep copy in the body of this function.
  prefs: []
  type: TYPE_NORMAL
- en: To conserve space, the member function definitions for the `Student` default,
    alternate, and copy constructor have been omitted, as have the definition for
    the `void Student::Print()` and `void Student::CleanUp()` member functions. However,
    they are the same as in the previous full program example illustrating the `Student`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that access functions for `private` data members in `Student`, such as
    `float Student::GetGpa()`, have been added to provide safe access to those data
    members. Note that the value returned from `float Student::GetGpa()` on the stack
    is a copy of the `gpa` data member. The original `gpa` is in no worry of being
    breached by the use of this function. The same applies for member functions `const
    string &Student::GetFirstName()` and `const string &Student::GetLastName()`, which
    each returns a `const string &`, ensuring that the data that will be returned
    will not be breached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s complete our program by examining our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our `main()` function, we instantiate a `Student`, namely `s1`, which is
    implicitly initialized with the matching constructor. Then we instantiate an `Employee`,
    `e1`, using the conversion constructor in the call `Employee e1(s1);`. At a quick
    glance, it may seem that we are utilizing the `Employee` copy constructor. But
    at a closer look, we notice that the actual parameter `s1` is of type `Student`,
    not `Employee`. Hence, we are using `Student s1` as a basis to initialize `Employee
    e1`. Note that in no manner is the `Student,` `s1`, harmed or altered in this
    conversion. For this reason, it would be preferable to define the source object
    as a `const Student &` in the formal parameter list; once we understand const
    member functions, which will then be required for usage in the body of the conversion
    constructor, we can do so.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this program, we print out the `Employee` using `Employee::Print()`,
    which enables us to visualize the conversion we applied for a `Student` to an
    `Employee`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Before we move forward, there’s one final, subtle detail about conversion constructors
    that is very important to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Any constructor that takes a single argument is considered a conversion constructor,
    which can potentially be used to convert the parameter type to the object type
    of the class to which it belongs. For example, if you have a constructor in the
    `Student` class that takes only a `float`, this constructor could be employed
    not only in the manner shown in the preceding example but also in places where
    an argument of type `Student` is expected (such as a function call), when an argument
    of type `float` is instead supplied. This may not be what you intend, which is
    why this interesting feature is being called out. If you don’t want implicit conversions
    to take place, you can disable this behavior by declaring the constructor with
    the `explicit` keyword at the beginning of its prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand basic, alternative, copy and conversion constructors
    in C++, let’s move forward and explore the constructor’s complementary member
    function, the C++ destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall how conveniently a class constructor provides us with a way to initialize
    a newly instantiated object? Rather than having to remember to call an `Initialize()`
    method for each instance of a given type, the constructor allows initialization
    automatically. The signature used in construction helps specify which of a series
    of constructors should be used.
  prefs: []
  type: TYPE_NORMAL
- en: What about object clean-up? Many classes contain dynamically allocated data
    members, which are often allocated in a constructor. Shouldn’t the memory comprising
    these data members be released when the programmer is done with an instance? Certainly.
    We have written a `CleanUp()` member function for several of our example programs.
    And we have remembered to call `CleanUp()`. Conveniently, similar to a constructor,
    C++ has an automatically built-in feature to serve as a clean-up function. This
    function is known as the destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the destructor to understand its proper usage.
  prefs: []
  type: TYPE_NORMAL
- en: Applying destructor basics and proper usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **destructor** is a member function whose purpose is to relinquish the resources
    an object may have acquired during its existence. A destructor is automatically
    invoked when a class or struct instance has either of the following occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Goes out of scope (this applies to non-pointer variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is explicitly deallocated using `delete` (for pointers to objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destructor should (most often) clean up any memory that may have been allocated
    by the constructor. The destructor’s name is a `~` character followed by the `class`
    name. A destructor will have no arguments; therefore, it cannot be overloaded.
    Lastly, the return type for a destructor may not be specified. Both classes and
    structures may have destructors.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to deallocating memory that a constructor may have allocated, a
    destructor may be used to perform other end-of-life tasks for an instance, such
    as logging a value to a database. More complex tasks may include informing objects
    pointed to by class data members (whose memory is not being released) that the
    object at hand will be concluding. This may be important if the linked object
    contains a pointer back to the terminating object. We will see examples of this
    later in the book, in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing
    Association, Aggregation, and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not provided a destructor, the compiler will create and link in
    a `public` destructor with an empty body. This is necessary because a destructor
    call is automatically patched in just prior to the point when local instances
    are popped off the stack, and with `delete()`, just prior to the memory release
    of dynamically allocated instances. It is easier for the compiler to always patch
    in this call, rather than constantly looking to see whether your class has a destructor
    or not. Be sure to provide a class destructor yourself when there are resources
    to clean up or dynamically allocated memory requiring release. If the destructor
    will be empty, consider using `=default` in its prototype to acknowledge its automatic
    inclusion (and to forego providing a definition yourself); this practice, however,
    adds unnecessary code and therefore is becoming less popular.
  prefs: []
  type: TYPE_NORMAL
- en: There are some potential pitfalls. For example, if you forget to delete a dynamically
    allocated instance, the destructor call will not be patched in for you. C++ is
    a language that gives you the flexibility and power to do (or not do) anything.
    If you do not delete memory using a given identifier (perhaps two pointers refer
    to the same memory), please remember to delete it through the other identifier
    at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one last item worth mentioning. Though you may call a destructor explicitly,
    you will rarely ever need to do so. Destructor calls are implicitly patched in
    by the compiler on your behalf in the aforementioned scenarios. Only in very few
    advanced programming situations will you need to explicitly call a destructor
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple example illustrating a class destructor, which
    will be broken into three segments. Its full example can be seen in the GitHub
    repository listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we first define `class University`. Notice
    the `private` access region filled with data members, and the `public` interface,
    which includes prototypes for a default, alternate, and copy constructor, as well
    as for the destructor and a `Print()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at the various member function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code fragment, we see the various overloaded constructors
    we are now accustomed to seeing, plus `void University::Print()`. The new addition
    is the destructor definition.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the destructor `University::~University()` takes no arguments; it may
    not be overloaded. The destructor simply deallocates memory that may have been
    allocated in any of the constructors. Note that we simply `delete [] name;`, which
    will work whether `name` points to a valid address or contains a null pointer
    (yes, applying `delete` to a null pointer is OK). We additionally print the `this`
    pointer in the destructor, just for fun, so that we can see the address of the
    instance that is approaching non-existence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at `main()` to see when the destructor may be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we instantiate two `University` instances; `u1` is an instance, and `u2`
    points to an instance. We know that `u2` is instantiated when its memory becomes
    available with `new()` and that once the memory has become available, the applicable
    constructor is called. Next, we call `University::Print()` for both instances
    to have some output.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, toward the end of `main()`, we delete `u2` to return this memory to
    the heap management facility. Just prior to memory release, with the call to `delete()`,
    C++ will patch in a call to the destructor for the object pointed to by `u2`.
    It is as if a secret function call `u2->~University();` has been patched in prior
    to `delete u2;` (note, this is done automatically, no need for you to do so as
    well). The implicit call to the destructor will delete the memory that may have
    been allocated for any data members within the class. The memory release is now
    complete for `u2`.
  prefs: []
  type: TYPE_NORMAL
- en: What about instance `u1`? Will its destructor be called? Yes; `u1` is a stack
    instance. Just prior to its memory being popped off the stack in `main()`, the
    compiler will have patched in a call to its destructor, as if the call `u1.~University();`
    was added on your behalf (again, no need to do so yourself). For the instance
    `u1`, the destructor will also deallocate any memory for data members that may
    have been allocated. Likewise, the memory release is now complete for `u1`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in each destructor call, we have printed a message to illustrate
    when the destructor is called, and have also printed out the memory address for
    `this` to allow you to visualize each specific instance as it is destructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With this example, we have now examined the destructor, the complement to the
    series of class constructors. Let us move on to another set of useful topics relating
    to classes: various keyword qualifications of data members and member functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying qualifiers to data members and member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will investigate qualifiers that can be added to both data
    members and member functions. The various qualifiers – `inline`, `const`, and
    `static` – can support program efficiency, aid in keeping private data members
    safe, support encapsulation and information hiding, and additionally be used to
    implement various object-oriented concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with the various types of member qualifications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding inline functions for potential efficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a set of short member functions in your program that are repeatedly
    called by various instances. As an object-oriented programmer, you appreciate
    using a `public` member function to provide safe and controlled access to `private`
    data. However, for very short functions, you worry about efficiency. That is,
    the overhead of calling a small function repeatedly. Certainly, it would be more
    efficient to just paste in the two or three lines of code comprising the function.
    Yet, you resist because that may mean providing `public` access to otherwise hidden
    class information, such as data members, which you are hesitant to do. An `inline`
    function can solve this dilemma, allowing you to have the safety of a member function
    to access and manipulate your private data, yet the efficiency of executing several
    lines of code without the overhead of a function call.
  prefs: []
  type: TYPE_NORMAL
- en: An **inline** function is a function whose invocation is substituted with the
    body of the function itself. Inline functions can help eliminate the overhead
    associated with calling very small functions.
  prefs: []
  type: TYPE_NORMAL
- en: Why would calling a function have overhead? When a function is called, input
    parameters (including `this`) are pushed onto the stack, space is reserved for
    a return value of the function (though sometimes registers are used), and moving
    to another section of code requires storing information in registers to jump to
    that section of code, and so on. Replacing very small function bodies with inline
    functions can add to program efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'An inline function may be specified using either of the following mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the function definition inside the class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing the keyword `inline` prior to the return type in the (typical) function
    definition, found outside the class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a function as `inline` in one of the aforementioned two fashions
    is merely a request to the compiler to consider the substitution of the function
    body for its function call. This substitution is not guaranteed. When might the
    compiler not actually inline a given function? If a function is recursive, it
    cannot be made `inline`. Likewise, if a function is lengthy, the compiler will
    not inline the function. Also, if the function call is dynamically bound with
    the specific implementation determined at run time (virtual functions), it cannot
    be made `inline`.
  prefs: []
  type: TYPE_NORMAL
- en: An `inline` function definition should be declared in the header file with the
    corresponding class definition. This will allow for any revisions to the function
    to be re-expanded correctly should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example using `inline` functions. The program will be broken into
    two segments, with some well-known functions removed. However, the full program
    may be seen in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program fragment, let’s start with the class definition. Notice
    that several access function definitions have been added in the class definition
    itself, namely, functions such as `GetFirstName()`, `GetLastName()`, and so on.
    Look closely; these functions are actually defined within the class definition.
    For example, `float GetGpa() { return gpa; }` is not just the prototype, but the
    full function definition. By virtue of the function placement within the class
    definition, functions such as these are considered `inline`.
  prefs: []
  type: TYPE_NORMAL
- en: These small functions provide safe access to private data members. Notice `const
    char *GetCurrentCourse()`, for example. This function returns a pointer to `currentCourse`,
    which is stored in the class as a `char *`. But because the return value of this
    function is a `const char *`, this means that anyone calling this function must
    treat the return value as a `const char *`, which means treating it as unmodifiable.
    Should this function’s return value be stored in a variable, that variable must
    also be defined as `const char *`. By upcasting this pointer to an unmodifiable
    version of itself with the return value, we are adding the provision that no one
    can get their hands on a `private` data member (which is a pointer) and then change
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: Now, notice toward the end of the class definition, we have a prototype for
    `void SetCurrentCourse(const char *);`. Then, outside of this class definition,
    we will see the definition for this member function. Notice the keyword `inline`
    prior to the `void` return type of this function definition. The keyword must
    be explicitly used here since the function is defined outside of the class definition.
    Remember, with either style of `inline` designation for a method, the `inline`
    specification is merely a request to the compiler to make the substitution of
    function body for function call. As with any function, if you provide a prototype
    (without `=default`), be sure to provide a function definition (or else the linker
    will definitely complain).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue this example by examining the remainder of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the remainder of our program example, several member function
    definitions have been omitted. The bodies of these functions are identical to
    the previous example illustrating a `Student` class in full, and can also be viewed
    online.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus instead on our `main()` function. Here, we instantiate a `Student`,
    namely `s1`. We then invoke several `inline` function calls via `s1`, such as
    `s1.GetFirstName();`. Because `Student::GetFirstName()` is inline, it is as if
    we are accessing data member `firstName` directly, as the body of this function
    merely has a `return firstName;` statement. We have the safety of using a function
    to access a `private` data member (meaning that no one can modify this data member
    outside the scope of the class), but the speed of an inline function’s code expansion
    to eliminate the overhead of a function call.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout `main()`, we make several other calls to `inline` functions in this
    same manner, including `s1.SetCurrentCourse();`. We now have the safety of encapsulated
    access with the speed of direct access to data members using small `inline` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now move onward by investigating another qualifier we can add to class
    members, the `const` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: Adding const data members and the member initialization list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen earlier in this book how to constant-qualify variables
    and the implications of doing so. To briefly recap, the implication of adding
    a `const` qualifier to a variable is that the variable must be initialized when
    it is declared and that its value may never again be modified. We previously also
    saw how to add `const` qualification to pointers, such that we could qualify the
    data being pointed to, the pointer itself, or both. Let us now examine what it
    means to add a `const` qualifier to data members within a class, and learn about
    specific language mechanisms that must be employed to initialize those data members.
  prefs: []
  type: TYPE_NORMAL
- en: Data members that should never be modified should be qualified as `const`. A
    `const` variables, *never modified* means that the data member may not be modified
    using its own identifier. It will then be our job to ensure that we do not initialize
    our data members that are pointers to `const` objects with objects that are not
    labeled as `const` (lest we provide a back door to change our private data).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that in C++, a programmer can always cast the const-ness away from
    a pointer variable. Not that they should. Nonetheless, we will employ safety measures
    to ensure that by using access regions and appropriate return values from access
    functions, we do not easily provide modifiable access to our `private` data members.
  prefs: []
  type: TYPE_NORMAL
- en: The **member initialization list** must be used in a constructor to initialize
    any data members that are constant, or that are references. A member initialization
    list offers a mechanism to initialize data members that may never be l-values
    in an assignment. A member initialization list may also be used to initialize
    non-const data members. For performance reasons, the member initialization list
    is most often the preferred way to initialize any data member (const or non-const).
    The member initialization list also provides a manner to specify preferred construction
    for any data members that are of class types themselves (that is, member objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'A member initialization list may appear in any constructor, and to indicate
    this list, simply place a `:` after the formal parameter list, followed by a comma-separated
    list of data members, paired with the initial value for each data member in parentheses.
    For example, here we use the member initialization list to set two data members,
    `gpa` and `middleInitial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Though we have used the member initialization list to initialize two data members
    in the previous constructor, we could have used it to set all of the data members!
    We’ll see this proposition (and preferred usage) momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: Data members in the member initialization list are initialized in the order
    in which they appear (that is, declared) in the class definition (except static
    data members, which we will see shortly). Next, the body of the constructor is
    executed. It is a nice convention to order the data members in the member initialization
    list to appear in the same order as the class definition. But remember, the order
    of actual initialization matches the order that the data members are specified
    in the class definition, irrespective of member initialization list ordering.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that a reference must use the member initialization
    list because references are implemented as constant pointers. That is, the pointer
    itself points to a specific other object and may not point elsewhere. The values
    of that object may change, but the reference always references a specific object,
    the one in which it was initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Using `const` qualification with pointers can be tricky to determine which scenarios
    require initialization with this list, and which do not. For example, a pointer
    to a constant object does not need to be initialized with the member initialization
    list. The pointer could point to any object, but once it does, it may not change
    the dereferenced value. However, a constant pointer must be initialized with the
    member initialization list because the pointer itself is fixed to a specific address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a `const` data member and how to use the member initialization
    list to initialize its value in a full program example. We will also see how to
    use this list to initialize non-const data members. Though this example is segmented
    and not shown in its entirety, the full program can be found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the aforesaid `Student` class, notice that we have added a data member, `const
    int studentId;`, to the class definition. This data member will require the use
    of the member initialization list to initialize this constant data member in each
    of the constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how the use of the member initialization list will work
    with constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code fragment, we see three `Student` constructors. Notice
    the various member initialization lists, designated by a `:` after the formal
    parameter list for each of the three constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Of particular interest is the member initialization list usage for data members
    that are of type `string` (or as we’ll later see, of any class type). In this
    usage, the string data members are constructed using the member initialization
    list using the specified constructor; that is, the one whose signature matches
    the argument in `()`. This is inevitably more efficient than default constructing
    each string (which is what happened previously behind the scenes) and then resetting
    its value via assignment within the constructor method body.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, the default `string` constructor selection in the member
    initialization list of the `Student` default constructor – that is, `:firstName(),
    lastName(), currentCourse()` – is shown to emphasize that these data members are
    member objects (of type `string`) and will be constructed. In this case, they
    will each be default constructed, which will provide their contents with an empty
    string. However, member objects will always be default constructed unless otherwise
    directed using the member initialization list. For this reason, the `:firstName()`,
    `lastName()`, and `currentCourse()` specifications in the member initialization
    list are optional and will not be included in future examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each constructor will make use of the member initialization list to set the
    values of data members that are `const`, such as `studentId`. Additionally, the
    member initialization list can be used as a simple (and more efficient) way to
    initialize any other data member. We can see examples of the member initialization
    list being used to simply set non-const data members by viewing the member initialization
    list in either the default or alternate constructor, for example, `Student::Student()
    : studentId(0), gpa(0.0)`. In this example, `gpa` is not `const`, so its use in
    the member initialization list is optional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Even though the constructor’s member initialization list is the only mechanism
    that can be used to initialize const data members (or those that are references
    or member objects), it is also often the preferred mechanism to perform simple
    initialization for any data member for performance reasons. In many cases (such
    as member objects – for example, a string), this saves data members from being
    first initialized (constructed themselves) with a default state and then re-assigned
    a value in the body of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to note that programmers may choose to utilize either `()`
    or `{}` in the member initialization list to initialize data members. Notice the
    use of `{}` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `{}` as used here were originally added for instantiation in C++ (and hence
    with usage within member initialization lists to fully construct data members)
    in an effort to provide a uniform initialization syntax. The `{}` also potentially
    control the narrowing of data types. However, when `std::initializer_list` is
    used with templates (a feature we will see in [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561),
    *Working with Templates*), the `{}` provides semantic confusion. Due to complexities
    such as these interfering with the goal of language uniformity, the next C++ standard
    may revert to preferring the use of `()` and so shall we. It is interesting to
    note that neither `()` nor `{}` has an advantage from the perspective of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s now move forward by adding the `const` qualifier to member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using const member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the constant qualifier used quite exhaustively now with data. It
    can also be used in conjunction with member functions. C++ provides a language
    mechanism to ensure that selected functions may not modify data; this mechanism
    is the `const` qualifier as applied to member functions.
  prefs: []
  type: TYPE_NORMAL
- en: A **const member function** is a member function that specifies (and enforces)
    that the method can only perform read-only activities on the object invoking the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: A constant member function means that no portion of `this` may be modified.
    However, because C++ allows typecasting, it is possible to cast `this` to its
    non-const counterpart and then change data members. However, if the class designer
    truly meant to be able to modify data members, they simply would not label a member
    function as `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Constant instances declared in your program may only invoke `const` member functions.
    Otherwise, these objects could be directly modified.
  prefs: []
  type: TYPE_NORMAL
- en: To label a member function as `const`, the keyword `const` should be specified
    after the argument list in the function prototype and in the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. It will be divided into two sections with some portions
    omitted; however, the full example can be seen in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program fragment, we see a class definition for `Student`, which
    is becoming very familiar to us. Notice, however, that we have added the `const`
    qualifier to most of the access member functions, that is, to those methods that
    are only providing read-only access to data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let us consider `float GetGpa() const { return gpa; }`. The `const`
    keyword after the argument list indicates that this is a constant member function.
    Notice that this function does not modify any data member pointed to by `this`.
    It cannot do so, as it is marked as a `const` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move on to the remainder of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the remainder of this program, notice that we have again chosen not to include
    the definitions for member functions with which we are already familiar, such
    as the constructors, the destructor, and `void Student::SetCurrentCourse()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let’s focus our attention on the member function with the signature:
    `void Student::Print() const`. Here, the `const` keyword after the argument list
    indicates that no data members pointed to by `this` can be altered in the scope
    of this function. And none are. Likewise, any member functions called on this
    within `void Student::Print()` must also be `const` member functions. Otherwise,
    they could modify `this`.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward to examine our `main()` function, we instantiate a `Student`,
    namely `s1`. This `Student` calls several member functions, including some that
    are `const`. `Student s1` then changes their current course using `Student::SetCurrentCourse()`,
    and then the new value of this course is printed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate another `Student`, `s2`, which is qualified as `const`.
    Notice that once this student is instantiated, the only member functions that
    may be applied to `s2` are those that are labeled as `const`. Otherwise, the instance
    may be modified. We then print out data for `s2` using `Student::Print();`, which
    is a `const` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the commented-out line of code: `s2.SetCurrentCourse("Advanced
    C++ Programming");`? This line is illegal and would not compile, because `SetCurrentCourse()`
    is not a constant member function and is hence inappropriate to be called via
    a constant instance, such as `s2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have fully explored `const` member functions, let’s continue to
    the final section of this chapter to delve into `static` data members and `static`
    member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing static data members and static member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have been using C++ classes to define and instantiate objects, let’s
    add to our knowledge of object-oriented concepts by exploring the idea of a class
    attribute. A data member that is intended to be shared by all instances of a particular
    class is known as a **class attribute**.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, each instance of a given class has distinct values for each of its
    data members. However, on occasion, it may be useful for all instances of a given
    class to share one data member containing a single value. The object-oriented
    concept of a class attribute can be modeled in C++ using a **static data member**.
  prefs: []
  type: TYPE_NORMAL
- en: Static data members themselves are implemented as external (global) variables
    whose scope is tied back to the class in question using *name mangling*. Hence,
    each static data member can have its scope limited to the class in question.
  prefs: []
  type: TYPE_NORMAL
- en: Static data members are designated in the class definition with the keyword
    `static` preceding the data type. To finish modeling a `static` data member, an
    external variable definition, outside the class, must additionally follow the
    `static` data member specification in the class definition. Storage for this *class
    member* is obtained by the external variable that comprises its underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '`static` data members within a class or structure. A `static` member function
    does not receive a `this` pointer, hence it may only manipulate `static` data
    members and other external (global) variables.'
  prefs: []
  type: TYPE_NORMAL
- en: To indicate a `static` member function, the keyword `static` must be specified
    in front of the function’s return type in the member function prototype only.
    The keyword `static` must not appear in the member function definition. If the
    keyword `static` appears in the function definition, the function will additionally
    be `static` in the C programming sense; that is, the function will be limited
    in scope to the file in which it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example of `static` data member and member function
    usage. The following example will be broken into segments, however, it will appear
    without any functions omitted or abbreviated, as it is the final example in this
    chapter. It can also be found in full in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the first segment of code comprising our full example, we have our `Student`
    class definition. In the `private` access region, we have added a data member,
    `static int numStudents;`, to model the object-oriented concept of a class attribute,
    a data member that will be shared by all instances of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice toward the end of this class definition that we have added a `static`
    member function, `static int GetNumberStudents();`, to provide encapsulated access
    to the `private` data member `numStudents`. Note the keyword `static` is added
    in the prototype only. If we glance outside of the class definition to find the
    member function definition of `int Student::GetNumberStudents()`, we notice that
    there is no usage of the `static` keyword within the definition of this function
    itself. The body of this member function simply returns the shared `numStudents`,
    the static data member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice that just below the class definition is the external variable definition
    to support the implementation of the static data member: `int Student::numStudents
    = 0;`. Notice with this declaration the use of `::` (the scope resolution operator)
    to associate the class name to the identifier `numStudents`. Though this data
    member is implemented as an external variable, and because the data member is
    labeled as `private`, it may only be accessed by member functions within the `Student`
    class. The implementation of a `static` data member as an external variable helps
    us understand where the memory for this shared data comes from; it is not part
    of any instance of the class but stored as a separate entity in the global namespace.
    Also notice that the declaration `int Student::numStudents = 0;` initializes this
    shared variable to a value of zero.'
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting aside, notice that the data member `studentId` has been changed
    from a `const int` to `const char *studentId;` in this new version of our `Student`
    class. Keep in mind that this means `studentId` is a pointer to a constant string,
    not a constant pointer. Because the memory for the pointer itself is not `const`,
    this data member will not need to be initialized using the member initialization
    list, but it will require some special handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue onward to review additional member functions comprising this
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program segment of member functions, most member functions look
    as we’ve grown accustomed to seeing, but there are some subtle differences.
  prefs: []
  type: TYPE_NORMAL
- en: One difference, which relates to our `static` data member, is that `numStudents`
    is incremented in each of the constructors and decremented in the destructor.
    Since this `static` data member is shared by all instances of `class Student`,
    each time a new `Student` is instantiated, the counter will increase, and when
    an instance of a `Student` ceases to exist and its destructor is implicitly called,
    the counter will be decremented to reflect the removal of such an instance. In
    this way, `numStudents` will accurately reflect how many `Student` instances exist
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: This section of code has a few other interesting details to notice, unrelated
    to `static` data members and member functions. For example, in our class definition,
    we changed `studentId` from a `const int` to a `const char *`. This means that
    the data pointed to is constant, not the pointer itself, so we are not required
    to use the member initialization list to initialize this data member.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, in the default constructor, we choose to use the member initialization
    list to initialize `studentId` to a null pointer, `nullptr`. Recall that we may
    use the member initialization list for any data member, but we must use them to
    initialize `const` data members. That is, if the `const` part equates to memory
    that is allocated with an instance. Since the memory allocated within the instance
    for data member `studentId` is a pointer and the pointer part of this data member
    is not `const` (just the data pointed to), we do not need to use the member initialization
    list for this data member. We just choose to.
  prefs: []
  type: TYPE_NORMAL
- en: However, because `studentId` is a `const char *`, this means that the identifier
    `studentId` may not serve as an l-value, or be on the left-hand side of an assignment.
    In the alternate and copy constructors, we wish to initialize `studentId` and
    need the ability to use `studentId` as an l-value. But we cannot. We circumvent
    this dilemma by instead declaring a helper variable, `char *temp;`, and allocating
    it to contain the amount of memory we need to load the desired data. Then, we
    load the desired data into `temp`, and finally, we have `studentId` point to `temp`
    to establish a value for `studentId`. When we leave each constructor, the local
    pointer `temp` is popped off the stack; however, the memory is now captured by
    `studentId` and treated as `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the destructor, we delete the memory associated with `const char
    *studentid`, using `delete [] studentId;`. It is interesting to note that in less-recent
    compilers, we instead needed to typecast `studentId` to a non-constant `char *`;
    that is, `delete const_cast<char *> (studentId);`, as operator `delete()` previously
    did not expect a constant qualified pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed reviewing new details in the member functions, let
    us continue by examining the final portion of this program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function of our program, we start by instantiating two `Students`,
    `s1` and `s2`. As each instance is initialized with a constructor, the shared
    data member value of `numStudents` is incremented to reflect the number of students
    in our application. Note that the external variable `Student::numStudents`, which
    holds the memory for this shared data member, was initialized to `0` when the
    program started with the statement earlier in our code: `int Student::numStudents
    = 0;`.'
  prefs: []
  type: TYPE_NORMAL
- en: After we print out some details for each `Student`, we then print out the `static`
    data member `numStudents` using a `static` access function `Student::GetNumStudents()`.
    The preferred way to call this function is `Student::GetNumStudents();`. Because
    `numStudents` is `private`, only a method of the `Student` class may access this
    data member. We have now provided safe, encapsulated access to a `static` data
    member using a `static` member function.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to remember that `static` member functions do not receive
    a `this` pointer, therefore, the only data they may manipulate will be `static`
    data in the class (or other external variables). Likewise, the only other functions
    they may call will be other `static` member functions in the same class or external
    non-member functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is also interesting to note that we can seemingly call `Student::GetNumStudents()`
    via any instance, such as `s1.GetNumStudents();`, as we see in the commented-out
    section of code. Though it seems as though we are calling the member function
    through an instance, the function will not receive a `this` pointer. Instead,
    the compiler reinterprets the call, which is seemingly through an instance, and
    replaces the invocation with a call to the internal, *name mangled* function.
    It is clearer from a programming point of view to call `static` member functions
    using the first calling method, and not seemingly through an instance that would
    never be passed along to the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the output for our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have reviewed our final example of this chapter, it is time to recap
    everything that we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have begun our journey with object-oriented programming.
    We have learned many object-oriented concepts and terms, and have seen how C++
    has direct language support to implement these concepts. We have seen how C++
    classes support encapsulation and information hiding, and how implementing designs
    supporting these ideals can lead to code that is easier to modify and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We have detailed class basics, including member functions. We’ve moved deeper
    into member functions by examining member function internals, including understanding
    what the `this` pointer is and how it works – including the underlying implementation
    of member functions that implicitly receive a `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored access labels and access regions. By grouping our data members
    in the `private` access region and providing a suite of `public` member functions
    to manipulate these data members, we have found that we can provide a safe, well-controlled,
    and well-tested means to manipulate data from the confines of each class. We have
    seen that making changes to a class can be limited to the member functions themselves.
    The user of the class need not know the underlying representation of data members
    – these details are hidden and can be changed as needed without causing a wave
    of changes elsewhere in an application.
  prefs: []
  type: TYPE_NORMAL
- en: We have deeply explored the many facets of constructors, by examining default,
    typical (overloaded) constructors, copy constructors, and even conversion constructors.
    We have been introduced to the destructor, and understand its proper usage.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added additional flavor to our classes by using various qualifiers to
    both data members and member functions, such as `inline` for efficiency, `const`
    to safeguard data and to ensure functions will as well, `static` data members
    to model the OO concept of class attributes, and `static` methods to provide safe
    interfaces to these `static` data members.
  prefs: []
  type: TYPE_NORMAL
- en: By immersing ourselves in object-oriented programming, we have gained a comprehensive
    set of skills relating to classes in C++. With a well-rounded set of skills and
    experience using classes under our respective belts and an appreciation for object-oriented
    programming, we can now move forward with [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Single Inheritance*, to learn how to grow a hierarchy
    of related classes. Let’s move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a C++ program to encapsulate a `Student`. You may use portions of your
    previous exercises. Try to do this yourself, rather than relying on any online
    code. You will need this class as a basis to move forward with future examples;
    now is a good time to try each feature on your own. Incorporate the following
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create, or modify your previous `Student` class to fully encapsulate a student.
    Be sure to include several data members that be dynamically allocated. Provide
    several overloaded constructors to provide the means to initialize your class.
    Be sure to include a copy constructor. Also, include a destructor to release any
    dynamically allocated data members.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an assortment of access functions to your class to provide safe access to
    data members within your class. Decide for which data members you will offer a
    `GetDataMember()` interface, and whether any of these data members should have
    the ability to be reset after construction with a `SetDataMember()` interface.
    Apply the `const` and `inline` qualifiers to these methods as appropriate.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to utilize appropriate access regions – `private` for data members,
    and possibly for some helper member functions to break up a larger task. Add `public`
    member functions as necessary above and beyond your previous access functions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Include at least one `const` data member in your class and utilize the member
    initialization list to set this member. Add at least one `static` data member
    and one `static` member function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate a `Student` using each constructor signature, including the copy
    constructor. Make several instances dynamically allocated using `new()`. Be sure
    to `delete()` each of these instances when you are done with them (so that their
    destructor will be called).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
