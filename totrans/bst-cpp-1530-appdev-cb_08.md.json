["```cpp\n#include <boost/mpl/aux_/na.hpp>\n\n// boost::mpl::na == n.a. == not available\ntemplate <\n    class T0 = boost::mpl::na, \n    class T1 = boost::mpl::na,\n    class T2 = boost::mpl::na,\n    class T3 = boost::mpl::na,\n    class T4 = boost::mpl::na,\n    class T5 = boost::mpl::na,\n    class T6 = boost::mpl::na,\n    class T7 = boost::mpl::na,\n    class T8 = boost::mpl::na,\n    class T9 = boost::mpl::na\n>\nstruct variant;\n```", "```cpp\n    #include <boost/mpl/vector.hpp>\n    template <\n      class T0, class T1, class T2, class T3, class T4,\n      class T5, class T6, class T7, class T8, class T9\n    >\n    struct variant {\n      typedef boost::mpl::vector<T0, T1, T2, T3, T4, T5, T6, T7,T8, T9> types;\n    };\n    ```", "```cpp\n    #include <string>\n\n    struct declared{ unsigned char data[4096]; };\n\n    struct non_defined;\n\n    typedef variant<\n      volatile int, \n      const int, \n      const long, \n      declared, \n      non_defined, \n      std::string\n    >::types types;\n    ```", "```cpp\n    #include <boost/static_assert.hpp>\n    #include <boost/mpl/empty.hpp>\n    BOOST_STATIC_ASSERT((!boost::mpl::empty<types>::value));\n    ```", "```cpp\n    #include <boost/mpl/at.hpp>\n    #include <boost/type_traits/is_same.hpp>\n    BOOST_STATIC_ASSERT((boost::is_same<\n      non_defined, \n      boost::mpl::at_c<types, 4>::type\n    >::value));\n    ```", "```cpp\n    #include <boost/mpl/back.hpp>\n    BOOST_STATIC_ASSERT((boost::is_same<\n      boost::mpl::back<types>::type,\n      std::string\n    >::value));\n    ```", "```cpp\n    #include <boost/mpl/transform.hpp>\n    #include <boost/type_traits/remove_cv.hpp>\n    typedef boost::mpl::transform<\n      types, \n      boost::remove_cv<boost::mpl::_1> \n    >::type noncv_types;\n    ```", "```cpp\n    #include <boost/mpl/unique.hpp>\n\n    typedef boost::mpl::unique<\n      noncv_types, \n      boost::is_same<boost::mpl::_1, boost::mpl::_2>\n    >::type unique_types;\n    ```", "```cpp\n    #include <boost/mpl/size.hpp>\n    BOOST_STATIC_ASSERT((boost::mpl::size<unique_types>::value == 5));\n    ```", "```cpp\n    // Without this we'll get an error:\n    // use of undefined type 'non_defined'\n    struct non_defined{};\n\n    #include <boost/mpl/sizeof.hpp>\n    typedef boost::mpl::transform<\n      unique_types, \n      boost::mpl::sizeof_<boost::mpl::_1>\n    >::type sizes_types;\n    ```", "```cpp\n    #include <boost/mpl/max_element.hpp>\n    typedef boost::mpl::max_element<sizes_types>::type max_size_type;\n    ```", "```cpp\n    BOOST_STATIC_ASSERT(max_size_type::type::value == sizeof(declared));\n    ```", "```cpp\n#include <boost/mpl/size.hpp>\n#include <cassert>\n\ntemplate <class Vector>\nint foo_size() {\n  return boost::mpl::size<Vector>::value;\n}\n\nint main() {\n  typedef boost::mpl::vector<int,int,int> vector1_type;\n  assert(foo_size<vector1_type>() == 3); \n}\n```", "```cpp\ntypedef boost::mpl::transform<\n  types, \n  boost::remove_cv<boost::mpl::_1> \n>::type noncv_types;\n```", "```cpp\n  std::vector<type> types;\n  // ...\n  std::unique(types.begin(), types.end(), \n    boost::bind(std::equal_to<type>(), _1, _2));\n```", "```cpp\n    struct boost::mpl::vector<\n      struct boost::mpl::size_t<4>,\n      struct boost::mpl::size_t<4>,\n      struct boost::mpl::size_t<4096>,\n      struct boost::mpl::size_t<1>,\n      struct boost::mpl::size_t<32> \n    >\n```", "```cpp\n// Make unsigned \nstruct unsigne; // No typo: 'unsigned' is a keyword, we cannot use it.\n\n// Make constant\nstruct constant;\n\n// Otherwise we do not change type\nstruct no_change;\n```", "```cpp\n    // we'll need this at step 3\n    #include <boost/mpl/size.hpp>\n    #include <boost/type_traits/is_same.hpp>\n    #include <boost/static_assert.hpp>\n\n    // we'll need this at step 4\n    #include <boost/mpl/if.hpp>\n    #include <boost/type_traits/make_unsigned.hpp>\n    #include <boost/type_traits/add_const.hpp>\n\n    // we'll need this at step 5\n    #include <boost/mpl/transform.hpp>\n    ```", "```cpp\n    template <class Types, class Modifiers>\n    struct do_modifications {\n    ```", "```cpp\n      BOOST_STATIC_ASSERT((boost::is_same<\n        typename boost::mpl::size<Types>::type, \n        typename boost::mpl::size<Modifiers>::type \n      >::value));\n    ```", "```cpp\n      typedef boost::mpl::if_<\n        boost::is_same<boost::mpl::_2, unsigne>,\n        boost::make_unsigned<boost::mpl::_1>,\n        boost::mpl::if_<\n          boost::is_same<boost::mpl::_2, constant>,\n          boost::add_const<boost::mpl::_1>,\n          boost::mpl::_1\n        >\n      > binary_operator_t;\n    ```", "```cpp\n      typedef typename boost::mpl::transform<\n        Types,\n        Modifiers,\n        binary_operator_t\n      >::type type;\n    };\n    ```", "```cpp\n    #include <boost/mpl/vector.hpp>\n    typedef boost::mpl::vector<unsigne, no_change, constant, unsigne> modifiers;\n    typedef boost::mpl::vector<int, char, short, long> types;\n    typedef do_modifications<types, modifiers>::type result_type;\n\n    #include <boost/mpl/at.hpp>\n    BOOST_STATIC_ASSERT((boost::is_same<\n      boost::mpl::at_c<result_type, 0>::type,\n      unsigned int\n    >::value));\n\n    BOOST_STATIC_ASSERT((boost::is_same<\n      boost::mpl::at_c<result_type, 1>::type,\n      char\n    >::value));\n\n    BOOST_STATIC_ASSERT((boost::is_same<\n      boost::mpl::at_c<result_type, 2>::type,\n      const short\n    >::value));\n\n    BOOST_STATIC_ASSERT((boost::is_same<\n      boost::mpl::at_c<result_type, 3>::type,\n      unsigned long\n    >::value));\n    ```", "```cpp\n  BOOST_STATIC_ASSERT((\n    boost::mpl::size<Types>::type::value\n    ==\n    boost::mpl::size<Modifiers>::type::value\n  ));\n```", "```cpp\n  vector result;\n\n  for (std::size_t i = 0; i < Types.size(); ++i) {\n    result.push_back(\n      binary_operator_t(Types[i], Modifiers[i])\n    );\n  }\n\n  return result;\n```", "```cpp\n>::type binary_operator_t; // INCORRECT!\n```", "```cpp\nbinary_operator_t foo;\n// Attempt to call binary_operator_t::operator() without parameters,\n// when it has version only with two parameters\nfoo();\n```", "```cpp\ntemplate <class... T>\nstruct vt_example {\n  typedef typename boost::mpl::vector<T...> type;\n};\n\nBOOST_STATIC_ASSERT((boost::is_same<\n  boost::mpl::at_c<vt_example<int, char, short>::type, 0>::type,\n  int\n>::value));\n```", "```cpp\ntemplate <class T1, class T2>\nauto my_function_cpp11(const T1& v1, const T2& v2) \n  -> decltype(v1 + v2) \n{\n  return v1 + v2;\n}\n```", "```cpp\n#include <cassert>\nstruct s1 {};\nstruct s2 {};\nstruct s3 {};\n\ninline s3 operator + (const s1& /*v1*/, const s2& /*v2*/) {\n  return s3();\n}\n\ninline s3 operator + (const s2& /*v1*/, const s1& /*v2*/) {\n  return s3();\n}\n\nint main() {\n  s1 v1;\n  s2 v2;\n  my_function_cpp11(v1, v2);\n  my_function_cpp11(v1, v2);\n  assert(my_function_cpp11('\\0', 1) == 1);\n}\n```", "```cpp\n    #include <boost/type_traits/common_type.hpp>\n    ```", "```cpp\n    namespace result_of {\n\n      template <class T1, class T2>\n      struct my_function_cpp03 {\n        typedef typename boost::common_type<T1, T2>::type type;\n      };\n    ```", "```cpp\n      template <> \n      struct my_function_cpp03<s1, s2> {\n        typedef s3 type;\n      };\n\n      template <>\n      struct my_function_cpp03<s2, s1> {\n        typedef s3 type;\n      };\n    } // namespace result_of\n    ```", "```cpp\n    template <class T1, class T2>\n    inline typename result_of::my_function_cpp03<T1, T2>::type\n      my_function_cpp03(const T1& v1, const T2& v2)\n    {\n      return v1 + v2;\n    }\n    ```", "```cpp\n      s1 v1;\n      s2 v2;\n\n      my_function_cpp03(v1, v2);\n      my_function_cpp03(v2, v1);\n      assert(my_function_cpp03('\\0', 1) == 1);\n    ```", "```cpp\ntemplate <class T1, class T2>\ninline typename result_of::my_function_cpp03<T1, T2>::type\n  my_function_cpp03(const T1& v1, const T2& v2)\n{\n  return v1 + v2;\n}\n```", "```cpp\nfunction_t higher_order_function1();\nvoid higher_order_function2(function_t f);\nfunction_t higher_order_function3(function_t f);\n```", "```cpp\ntemplate <class Param1, class Param2, class Func1, class Func2>\nstruct coalesce;\n```", "```cpp\n    #include <boost/mpl/apply.hpp>\n    #include <boost/mpl/if.hpp>\n    #include <boost/type_traits/is_same.hpp>\n    ```", "```cpp\n    template <class Param1, class Param2, class Func1, class Func2>\n    struct coalesce {\n      typedef typename boost::mpl::apply<Func1, Param1>::type type1;\n      typedef typename boost::mpl::apply<Func2, Param2>::type type2;\n    ```", "```cpp\n      typedef typename boost::mpl::if_<\n        boost::is_same< boost::mpl::false_, type1>,\n        type2,\n        type1\n      >::type type;\n    };\n    ```", "```cpp\n    #include <boost/static_assert.hpp>\n    #include <boost/mpl/not.hpp>\n    using boost::mpl::_1;\n    using boost::mpl::_2;\n\n    typedef coalesce<\n      boost::mpl::true_,\n      boost::mpl::true_,\n      boost::mpl::not_<_1>,\n      boost::mpl::not_<_1>\n    >::type res1_t;\n    BOOST_STATIC_ASSERT((!res1_t::value));\n\n    typedef coalesce<\n      boost::mpl::true_,\n      boost::mpl::false_,\n      boost::mpl::not_<_1>,\n      boost::mpl::not_<_1>\n    >::type res2_t;\n    BOOST_STATIC_ASSERT((res2_t::value));\n    ```", "```cpp\nstruct fallback;\n\ntemplate <\n  class Func,\n  class Param,\n  class Cond,\n  class Fallback = fallback>\nstruct apply_if;\n```", "```cpp\n    #include <boost/mpl/apply.hpp>\n    #include <boost/mpl/eval_if.hpp>\n    #include <boost/mpl/identity.hpp>\n    ```", "```cpp\n    template <class Func, class Param, class Cond, class Fallback>\n    struct apply_if {\n      typedef typename boost::mpl::apply<\n        Cond, Param\n      >::type condition_t;\n    ```", "```cpp\n      typedef boost::mpl::apply<Func, Param> applied_type;\n    ```", "```cpp\n      typedef typename boost::mpl::eval_if_c<\n        condition_t::value,\n        applied_type,\n        boost::mpl::identity<Fallback>\n      >::type type;\n    };\n    ```", "```cpp\n    #include <boost/static_assert.hpp>\n    #include <boost/type_traits/is_integral.hpp>\n    #include <boost/type_traits/make_unsigned.hpp>\n    #include <boost/type_traits/is_same.hpp>\n\n    using boost::mpl::_1;\n    using boost::mpl::_2;\n\n    typedef apply_if<\n      boost::make_unsigned<_1>,\n      int,\n      boost::is_integral<_1>\n    >::type res1_t;\n    BOOST_STATIC_ASSERT((\n      boost::is_same<res1_t, unsigned int>::value\n    ));\n\n    typedef apply_if<\n      boost::make_unsigned<_1>,\n      float,\n      boost::is_integral<_1>\n    >::type res2_t;\n    BOOST_STATIC_ASSERT((\n      boost::is_same<res2_t, fallback>::value\n    ));\n    ```", "```cpp\n// will fail with static assert somewhere deep in implementation\n// of boost::make_unsigned<_1> if we won't be evaluating function // lazy. \ntypedef apply_if<\n    boost::make_unsigned<_1>,\n    float,\n    boost::is_integral<_1>\n>::type res2_t;\nBOOST_STATIC_ASSERT((\n    boost::is_same<res2_t, fallback>::value\n));\n```", "```cpp\ntemplate <class Func, class Param, class Cond, class Fallback>\nstruct apply_if {\n  typedef boost::mpl::apply<Cond, Param> condition_t;\n\n  // Incorrect, metafunction is evaluated when `::type` called\n  typedef typename boost::mpl::apply<Func, Param>::type applied_type;\n\n  typedef typename boost::mpl::if_c<\n    condition_t::value,\n    applied_type,\n    boost::mpl::identity<Fallback>\n  >::type type;\n};\n```", "```cpp\ntemplate<bool C, typename F1, typename F2>\nstruct eval_if_c {\n  typedef typename if_c<C,F1,F2>::type f_;\n  typedef typename f_::type type;\n};\n```", "```cpp\ntemplate <class T>\nstruct identity {\n    typedef T type;\n};\n```", "```cpp\n    #include <boost/lexical_cast.hpp>\n    #include <boost/noncopyable.hpp>\n\n    struct stringize_functor: boost::noncopyable {\n    private:\n      std::string& result;\n\n    public:\n      explicit stringize_functor(std::string& res)\n        : result(res)\n      {}\n\n      template <class T>\n      void operator()(const T& v) const {\n        result += boost::lexical_cast<std::string>(v);\n      }\n    };\n    ```", "```cpp\n    #include <boost/fusion/include/for_each.hpp>\n\n    template <class Sequence>\n    std::string stringize(const Sequence& seq) {\n      std::string result;\n      boost::fusion::for_each(seq, stringize_functor(result));\n      return result;\n    }\n    ```", "```cpp\n    struct cat{};\n\n    std::ostream& operator << (std::ostream& os, const cat& ) {\n      return os << \"Meow! \";\n    }\n\n    #include <iostream>\n    #include <boost/fusion/adapted/boost_tuple.hpp>\n    #include <boost/fusion/adapted/std_pair.hpp>\n    #include <boost/fusion/adapted/boost_array.hpp>\n\n    int main() {\n      boost::fusion::vector<cat, int, std::string> tup1(cat(), 0, \"_0\");\n      boost::tuple<cat, int, std::string> tup2(cat(), 0, \"_0\");\n      std::pair<cat, cat> cats;\n      boost::array<cat, 10> many_cats;\n\n      std::cout << stringize(tup1) << '\\n' \n        << stringize(tup2) << '\\n'\n        << stringize(cats) << '\\n'\n        << stringize(many_cats) << '\\n';\n    }\n    ```", "```cpp\n    Meow! 0_0\n    Meow! 0_0\n    Meow! Meow! \n    Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! \n    ```", "```cpp\n#include <boost/fusion/adapted/boost_tuple.hpp>\n#include <boost/fusion/adapted/std_pair.hpp>\n#include <boost/fusion/adapted/boost_array.hpp>\n```", "```cpp\n#include <boost/tuple/tuple.hpp>\n#include <string>\n#include <cassert>\n\nvoid tuple_example() {\n  boost::tuple<int, int, std::string> tup(1, 2, \"Meow\");\n  assert(boost::get<0>(tup) == 1);\n  assert(boost::get<2>(tup) == \"Meow\");\n}\n\n#include <boost/fusion/include/vector.hpp>\n#include <boost/fusion/include/at_c.hpp>\n\nvoid fusion_tuple_example() {\n  boost::fusion::vector<int, int, std::string> tup(1, 2, \"Meow\");\n  assert(boost::fusion::at_c<0>(tup) == 1);\n  assert(boost::fusion::at_c<2>(tup) == \"Meow\");\n}\n```", "```cpp\n  std::string result;\n\n  // Instead of\n  // boost::fusion::for_each(seq, stringize_functor(result));\n  // there'll be the following:\n  {\n    stringize_functor functor(result);\n    functor(boost::fusion::at_c<0>(tup2));\n    functor(boost::fusion::at_c<1>(tup2));\n    functor(boost::fusion::at_c<2>(tup2));\n  }\n  return result;\n```", "```cpp\n    #include <boost/fusion/include/remove_if.hpp>\n    #include <boost/type_traits/is_arithmetic.hpp>\n    ```", "```cpp\n    template <class Sequence>\n    typename boost::fusion::result_of::remove_if<\n      const Sequence, \n      boost::is_arithmetic<boost::mpl::_1> \n    >::type get_nonarithmetics(const Sequence& seq) \n    {\n      return boost::fusion::remove_if< \n        boost::is_arithmetic<boost::mpl::_1> \n      >(seq);\n    }\n    ```", "```cpp\n    template <class Sequence>\n    typename boost::fusion::result_of::remove_if<\n      const Sequence, \n      boost::mpl::not_< boost::is_arithmetic<boost::mpl::_1> >\n    >::type get_arithmetics(const Sequence& seq) \n    {\n      return boost::fusion::remove_if< \n        boost::mpl::not_< boost::is_arithmetic<boost::mpl::_1> >\n      >(seq);\n    }\n    ```", "```cpp\n#include <boost/fusion/include/vector.hpp>\n#include <cassert>\n#include <boost/fusion/include/at_c.hpp>\n\nint main() {\n  typedef boost::fusion::vector<\n    int, boost::blank, boost::blank, float\n  > tup1_t;\n\n  tup1_t tup1(8, boost::blank(), boost::blank(), 0.0);\n  boost::fusion::vector<boost::blank, boost::blank> res_na\n    = get_nonarithmetics(tup1);\n\n  boost::fusion::vector<int, float> res_a = get_arithmetics(tup1);\n  assert(boost::fusion::at_c<0>(res_a) == 8);\n}\n```", "```cpp\ntypename boost::fusion::result_of::remove_if<\n  const Sequence, \n  boost::is_arithmetic<boost::mpl::_1> \n>::type\n```", "```cpp\n  return boost::fusion::remove_if< \n    boost::is_arithmetic<boost::mpl::_1> \n  >(seq);\n```", "```cpp\n#include <boost/fusion/include/mpl.hpp>\n#include <boost/mpl/transform.hpp>\n#include <boost/type_traits/remove_const.hpp>\n\ntemplate <class Sequence>\nstruct make_nonconst: boost::mpl::transform<\n  Sequence,\n  boost::remove_const<boost::mpl::_1>\n> {};\n\ntypedef boost::fusion::vector<\n  const int, const boost::blank, boost::blank\n> type1;\n\ntypedef make_nonconst<type1>::type nc_type;\n\nBOOST_STATIC_ASSERT((boost::is_same<\n  boost::fusion::result_of::value_at_c<nc_type, 0>::type,\n  int\n>::value));\n```"]