<html><head></head><body>
		<div><h1 class="chapterNumber">Chapter 0<a id="_idTextAnchor246"/>9</h1>
			<h1 id="_idParaDest-132" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor247"/>Abstraction and OOP in C++</h1>
			<p class="normal">This is the final chapter on OOP in C. In this chapter, we are going to cover the remaining topics and introduce you to a new programming paradigm. In addition, we explore C++ and look at how it implements object-oriented concepts behind the scenes.</p>
			<p class="normal">As part of this chapter, we will cover the following topics:</p>
			<ul>
				<li class="list">Firstly, we discuss the <em class="italics">Abstraction</em>. This continues our discussion regarding inheritance and polymorphism and will be the last topic that we cover as part of OOP in C. We show how abstraction helps us in designing object models that have the maximum extendibility and the minimum dependencies between its various components.</li>
				<li class="list">We talk about how object-oriented concepts have been implemented in a famous C++ compiler, <code class="Code-In-Text--PACKT-">g++</code> in this case. As part of this, we see that how close the approaches that we have discussed so far are in accordance with the approaches that <code class="Code-In-Text--PACKT-">g++</code> has taken to provide the same concepts.</li>
			</ul>
			<p class="normal">Let's start the chapter by talking about abstraction.</p>
			<h1 id="_idParaDest-133" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor248"/>Abstraction</h1>
			<p class="normal">Abstraction can have a very<a id="_idIndexMarker612"/> general meaning in various fields of science and engineering. But in programming, and especially in OOP, abstraction essentially deals with <em class="italics">abstract data types</em>. In class-based object orientation, abstract data types are the<a id="_idIndexMarker613"/> same as <em class="italics">abstract classes</em>. Abstract classes are special classes that we cannot create an object from; they are not ready or complete enough to be used for object creation. So, why do we need to have such classes or data types? This is because when we work with abstract and general data types, we avoid creating strong dependencies between various parts of code.</p>
			<p class="normal">As an example, we can have the following relationships between the <em class="italics">Human</em> and <em class="italics">Apple</em> classes:</p>
			<p class="normal"><em class="italics">An object of the Human class eats an object of the Apple class.</em></p>
			<p class="normal"><em class="italics">An object of the Human class eats an object of the Orange class.</em></p>
			<p class="normal">If the classes that an object from the <em class="italics">Human</em> class can eat were expanded to more than just <em class="italics">Apple</em> and <em class="italics">Orange</em>, we would <a id="_idIndexMarker614"/>need to add more relations to the <em class="italics">Human</em> class. Instead, though, we could create an abstract class called <em class="italics">Fruit</em> that is the parent of both <em class="italics">Apple</em> and <em class="italics">Orange</em> classes, and we could set the relation to be between <em class="italics">Human</em> and <em class="italics">Fruit</em> only. Therefore, we can turn our preceding two statements into one:</p>
			<p class="normal"><em class="italics">An object of the Human class eats an object from a subtype of the Fruit class.</em></p>
			<p class="normal">The <em class="italics">Fruit</em> class is abstract because it lacks information about shape, taste, smell, color, and many more attributes of a specific fruit. Only when we have an apple or an orange do we know the exact values of the different attributes. The <em class="italics">Apple</em> and <em class="italics">Orange</em> classes are said to be <em class="italics">concrete types</em>.</p>
			<p class="normal">We can even<a id="_idIndexMarker615"/> add more abstraction. The <em class="italics">Human</em> class can eat <em class="italics">Salad</em> or <em class="italics">Chocolate</em> as well. So, we can say:</p>
			<p class="normal"><em class="italics">An object of the Human type eats an object from a subtype of the Eatable class.</em></p>
			<p class="normal">As you can see, the abstraction level of <em class="italics">Eatable</em> is even higher than that of <em class="italics">Fruit</em>. Abstraction is a great technique for designing an object model that has minimal dependency on concrete types and allows the maximum future extension to the object model when more concrete types are introduced to the system.</p>
			<p class="normal">Regarding the preceding example, we could also add further abstraction by using the fact that <em class="italics">Human</em> is an <em class="italics">Eater</em>. Then, we could make our statement even more abstract:</p>
			<p class="normal"><em class="italics">An object from a subtype of the Eater class eats an object from a subtype of the Eatable class.</em></p>
			<p class="normal">We can continue to abstract everything in an object model and find abstract data types that are more abstract than the level we need to solve our problem. This is usually called <em class="italics">over-abstraction</em>. It happens <a id="_idIndexMarker616"/>when you try to create abstract data types that have no real application, either for your current or your future needs. This should be avoided at all costs because abstraction can cause problems, despite all the benefits it provides.</p>
			<p class="normal">A general guide regarding the amount of abstraction that we need can be found as part of the <em class="italics">abstraction principle</em>. I got the following quote from its Wikipedia <a href="https://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming)">page, https://en.wikipedia.org/wiki/Abstraction_principle_(computer_program</a>ming). It simply <a id="_idIndexMarker617"/>states:</p>
			<p class="normal"><em class="italics">Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.</em></p>
			<p class="normal">While at first glance you may not see any sign of object orientation or inheritance in this statement, by giving some further thought to it you will notice that what we did with inheritance was based on this principle. Therefore, as a general rule, whenever you don't expect to have variations in a specific logic, there is no need to introduce abstraction at that point.</p>
			<p class="normal">In a programming<a id="_idIndexMarker618"/> language, inheritance and polymorphism are two capabilities that are required in order to create abstraction. An abstract class such as <em class="italics">Eatable</em> is a supertype in relation to its concrete classes, such as <em class="italics">Apple</em>, and this is accomplished by inheritance.</p>
			<p class="normal">Polymorphism also plays an important role. There are behaviors in an abstract type that <em class="italics">cannot</em> have default implementation at that abstraction level. For example, <em class="italics">taste</em> as an attribute implemented using a behavior function such as <code class="Code-In-Text--PACKT-">eatable_get_taste</code> as part of the <em class="italics">Eatable</em> class cannot have an exact value when we are talking about an <em class="italics">Eatable</em> object. In other words, we cannot create an object directly from the <em class="italics">Eatable</em> class if we don't know how to define the <code class="Code-In-Text--PACKT-">eatable_get_taste</code> behavior function.</p>
			<p class="normal">The preceding function can only be defined when the child class is concrete enough. For example, we know that <em class="italics">Apple</em> objects should return <em class="italics">sweet</em> for their taste (we've assumed here that all apples are sweet). This is where polymorphism helps. It allows a child class to override its parent's behaviors and return the proper taste, for example.</p>
			<p class="normal">If you remember from the previous chapter, the behavior functions that can be overridden by child classes are <a id="_idIndexMarker619"/>called <em class="italics">virtual functions</em>. Note that it is possible that a virtual function doesn't have any definition at all. Of course, this makes the owner class abstract.</p>
			<p class="normal">By adding more and more abstraction, at a certain level, we reach classes that have no attributes and contain only virtual functions with no default definitions. These classes are called <em class="italics">interfaces</em>. In other <a id="_idIndexMarker620"/>words, they expose functionalities but they don't offer any implementation at all, and they are usually used to create dependencies between various components in a software project. As an example, in our preceding examples, the <em class="italics">Eater</em> and <em class="italics">Eatable</em> classes are interfaces. Note that, just like abstract classes, you must not create an object from an interface. The following code shows why this cannot be done in a C code.</p>
			<p class="normal">The following code box is the equivalent code written for the preceding interface <em class="italics">Eatable</em> in C using the<a id="_idIndexMarker621"/> techniques we introduced in the previous chapter to implement inheritance and polymorphism:</p>
			<pre>typedef enum {SWEET, SOUR} <strong class="highlight">taste_t</strong>;
// Function pointer type
typedef taste_t (*<strong class="highlight">get_taste_func_t</strong>)(void*);
typedef struct {
  // Pointer to the definition of the virtual function
  get_taste_func_t get_taste_func;
} <strong class="highlight">eatable_t</strong>;
eatable_t* <strong class="highlight">eatable_new</strong>() { ... }
void <strong class="highlight">eatable_ctor</strong>(eatable_t* eatable) {
  // We don't have any default definition for the virtual function
  eatable-&gt;get_taste_func = NULL;
}
// Virtual behavior function
taste_t <strong class="highlight">eatable_get_taste</strong>(eatable_t* eatable) {
  return eatable-&gt;get_taste_func(eatable);
}</pre>
			<p class="packt_figref">Code Box 9-1: The Eatable interface in C</p>
			<p class="normal">As you can see, in the constructor function we have set the <code class="Code-In-Text--PACKT-">get_taste_func</code> pointer to <code class="Code-In-Text--PACKT-">NULL</code>. So, calling the <code class="Code-In-Text--PACKT-">eatable_get_taste</code> virtual function can lead to a segmentation fault. From the coding perspective, that's basically why that we must not create an object from the <em class="italics">Eatable</em> interface other than the reasons we know from the definition of the interface and the design poin<a id="_idTextAnchor249"/>t of view.</p>
			<p class="normal">The following code box demonstrates how creating an object from the <em class="italics">Eatable</em> interface, which is totally possible and allowed from a C point of view, can lead to a crash and must not be done:</p>
			<pre>eatable_t *eatable = eatable_new();
eatable_ctor(eatable);
<strong class="highlight">taste_t taste = eatable_get_taste(eatable); // Segmentation fault!</strong>
free(eatable);</pre>
			<p class="packt_figref">Code Box 9-2: Segmentation fault when creating an object from the Eatable interface and calling a pure virtual function from it</p>
			<p class="normal">To prevent ourselves<a id="_idIndexMarker622"/> from creating an object from an abstract type, we can remove the <em class="italics">allocator function</em> from the class's public interface. If you remember the approaches that we took in the previous chapter to implement inheritance in C, by removing the allocator function, only child classes are able to create objects from the parent's attribute structure.</p>
			<p class="normal">External codes are then no longer able to do so. For instance, in the preceding example, we do not want any external code to be able to create any object from the structure <code class="Code-In-Text--PACKT-">eatable_t</code>. In order to do that, we need to have the attribute structure forward declared and make it an incomplete type. Then, we need to remove the public memory allocator <code class="Code-In-Text--PACKT-">eatable_new</code> from the class.</p>
			<p class="normal">To summarize what we need to do to have an abstract class in C, you need to nullify the virtual function pointers that are not meant to have a default definition at that abstraction level. At an extremely high level of abstraction, we have an interface whose all function pointers are null. To prevent any external code from creating objects from abstract types, we should remove the allocator function from the public interface.</p>
			<p class="normal">In the following section, we are going to compare similar object-oriented features in C and C++. This gives us an idea how C++ has been developed fr<a id="_idTextAnchor250"/>om pure C.</p>
			<h1 id="_idParaDest-134" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor251"/>Object-oriented constructs in C++</h1>
			<p class="normal">In this section, we are<a id="_idIndexMarker623"/> going to compare what we did in C and the underlying <a id="_idIndexMarker624"/>mechanisms employed in a famous C++ compiler, <code class="Code-In-Text--PACKT-">g++</code> in this case, for supporting encapsulation, inheritance, polymorphism, and abstraction.</p>
			<p class="normal">We want to show that there is a close accordance between the methods by which object-oriented concepts are implemented in C and C++. Note that, from now on, whenever we refer to C++, we are actually referring to the implementation of <code class="Code-In-Text--PACKT-">g++</code> as one of the C++ compilers, and not the C++ standard. Of course, the underlying implementations can be different for various compilers, but we don't expect to see a lot of differences. We will also be using <code class="Code-In-Text--PACKT-">g++</code> in a 64-bit Linux setup.</p>
			<p class="normal">We are going to use the previously discussed techniques to write an object-oriented code in C, and then we<a id="_idIndexMarker625"/> write the same program in C++, before<a id="_idIndexMarker626"/> jumping to the fin<a id="_idTextAnchor252"/>al conclusion.</p>
			<h2 id="_idParaDest-135" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor253"/>Encapsulation</h2>
			<p class="normal">It is difficult to go deep into a C++ compiler and see how it uses the techniques that we've been exploring <a id="_idIndexMarker627"/>so far to produce the final <a id="_idIndexMarker628"/>executable, but there is one clever trick that we can use to actually see this. The way to do this is to compare the assembly instructions generated for two similar C and C++ programs.</p>
			<p class="normal">This is exactly what we are going to do to demonstrate that the C++ compiler ends up generating the same assembly instructions as a C program that uses the OOP techniques that we've been discussing in the previous chapters.</p>
			<p class="normal"><em class="italics">Example 9.1</em> is about two C and C++ programs addressing the same simple object-oriented logic. There is a <code class="Code-In-Text--PACKT-">Rectangle</code> class in this example, which has a behavior function for calculating its area. We want to see and compare the generated assembly codes for the same behavior function in both programs. The following code box demonstrates the C version:</p>
			<pre>#include &lt;stdio.h&gt;
typedef struct {
  int width;
  int length;
} <strong class="highlight">rect_t</strong>;
int <strong class="highlight">rect_area</strong>(rect_t* rect) {
  return rect-&gt;width * rect-&gt;length;
}
int <strong class="highlight">main</strong>(int argc, char** argv) {
  rect_t r;
  r.width = 10;
  r.length = 25;
  int area = rect_area(&amp;r);
  printf("Area: %d\n", area);
  return 0;
}</pre>
			<p class="packt_figref">Code Box 9-3 [ExtremeC_examples_chapter9_1.c]: Encapsulation example in C</p>
			<p class="normal">And the following code box shows the C++ version of the preceding program:</p>
			<pre>#include &lt;iostream&gt;
class <strong class="highlight">Rect</strong> {
public:
  int <strong class="highlight">Area</strong>() {
    return width * length;
  }
  int width;
  int length;
};
int <strong class="highlight">main</strong>(int argc, char** argv) {
  Rect r;
  r.width = 10;
  r.length = 25;
  int area = r.Area();
  std::cout &lt;&lt; "Area: " &lt;&lt; area &lt;&lt; std::endl;
  return 0;
}</pre>
			<p class="packt_figref">Code Box 9-4 [ExtremeC_examples_chapter9_1.cpp]: Encapsulation example in C++</p>
			<p class="normal">So, let's generate the <a id="_idIndexMarker629"/>assembly codes for the <a id="_idIndexMarker630"/>preceding C and C++ programs:</p>
			<pre><strong class="highlight">$ gcc -S ExtremeC_examples_chapter9_1.c -o ex9_1_c.s</strong>
<strong class="highlight">$ g++ -S ExtremeC_examples_chapter9_1.cpp -o ex9_1_cpp.s</strong>
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 9-1: Generating the assembly outputs for the C and C++ codes</p>
			<p class="normal">Now, let's dump the <code class="Code-In-Text--PACKT-">ex9_1_c.s</code> and <code class="Code-In-Text--PACKT-">ex9_1_cpp.s</code> files and look for the definition of the behavior functions. In <code class="Code-In-Text--PACKT-">ex9_1_c.s</code>, we should look for the <code class="Code-In-Text--PACKT-">rect_area</code> symbol, and in <code class="Code-In-Text--PACKT-">ex9_1_cpp.s</code>, we should look for the <code class="Code-In-Text--PACKT-">_ZN4Rect4AreaEv</code> symbol. Note that C++ mangles the symbol names, and that's why you need to search for this strange symbol. Name mangling in C++ has been discussed in <em class="italics">Chapter 2</em>, <em class="italics">Compilation and Linking</em>.</p>
			<p class="normal">For the C program, the following is the generated assembly for the <code class="Code-In-Text--PACKT-">rect_area</code> function:</p>
			<pre><strong class="highlight">$ cat ex9_1_c.s</strong>
...
rect_area:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
<strong class="highlight">    movq    %rdi, -8(%rbp)</strong>
<strong class="highlight">    movq    -8(%rbp), %rax</strong>
<strong class="highlight">    movl    (%rax), %edx</strong>
<strong class="highlight">    movq    -8(%rbp), %rax</strong>
<strong class="highlight">    movl    4(%rax), %eax</strong>
    imull   %edx, %eax
    popq    %rbp
    .cfi_def_cfa 7, 8
    Ret
    .cfi_endproc
...
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 9-2: The generated assembly code of the rect_area function</p>
			<p class="normal">The following is the generated<a id="_idIndexMarker631"/> assembly instructions<a id="_idIndexMarker632"/> for the <code class="Code-In-Text--PACKT-">Rect::Area</code> function:</p>
			<pre><strong class="highlight">$ cat ex9_1_cpp.s</strong>
...
_ZN4Rect4AreaEv:
.LFB1493:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
<strong class="highlight">    movq    %rdi, -8(%rbp)</strong>
<strong class="highlight">    movq    -8(%rbp), %rax</strong>
<strong class="highlight">    movl    (%rax), %edx</strong>
<strong class="highlight">    movq    -8(%rbp), %rax</strong>
<strong class="highlight">    movl    4(%rax), %eax</strong>
    imull   %edx, %eax
    popq    %rbp
    .cfi_def_cfa 7, 8
    Ret
    .cfi_endproc
...
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 9-3: The generated assembly code of the Rect::Area function</p>
			<p class="normal">Unbelievably, they are exactly the same! I'm not sure how the C++ code turns into the preceding assembly code, but I'm sure that the assembly code generated for the preceding C <a id="_idIndexMarker633"/>function is almost, to high degree of accuracy, equivalent to the assembly code generated for the C++ function.</p>
			<p class="normal">We can conclude from<a id="_idIndexMarker634"/> this that the C++ compiler has used a similar approach to that which we used in C, introduced as <em class="italics">implicit encapsulation</em> as part of <em class="italics">Chapter 6</em>, <em class="italics">OOP and Encapsulation</em>, to implement the encapsulation. Like what we did with implicit <a id="_idIndexMarker635"/>encapsulation, you can see in <em class="italics">Code Box 9-3</em> that a pointer to the attribute structure is passed to the <code class="Code-In-Text--PACKT-">rect_area</code> function as the first argument.</p>
			<p class="normal">As part of the boldened assembly instructions in both shell boxes, the <code class="Code-In-Text--PACKT-">width</code> and <code class="Code-In-Text--PACKT-">length</code> variables are being read by adding to the memory address passed as the first argument. The first pointer argument can be found in the <code class="Code-In-Text--PACKT-">%rdi</code> register according to <em class="italics">System V ABI</em>. So, we can infer that C++ has changed the <code class="Code-In-Text--PACKT-">Area</code> function to accept a pointer argument as its first argument, which points to the object itself.</p>
			<p class="normal">As a final word on encapsulation, we saw how C and C++ are closely related regarding encapsulation, at least in this simple example. Let's see if the same is true regardi<a id="_idTextAnchor254"/>ng inheritance as well.</p>
			<h2 id="_idParaDest-136" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor255"/>Inheritance</h2>
			<p class="normal">Investigating inheritance is<a id="_idIndexMarker636"/> easier than encapsulation. In C++, the<a id="_idIndexMarker637"/> pointers from a child class can be assigned to the pointers from the parent class. Also, the child class should have access to the private definition of the parent class.</p>
			<p class="normal">Both of these behaviors imply that C++ is using our first approach to implementing inheritance, which was discussed in the previous chapter, <em class="italics">Chapter 8, Inheritance and Polymorphism</em>, along with the second approach. Please refer back to the previous chapter if you need to remind yourself of the two approaches.</p>
			<p class="normal">However, C++ inheritance seems more complex because C++ supports multiple inheritances that we can't <a id="_idIndexMarker638"/>support in our first approach. In this section, we will check the memory layouts of two objects instantiated from two similar classes<a id="_idIndexMarker639"/> in C and C++, as demonstrated in <em class="italics">example 9.2</em>.</p>
			<p class="normal"><em class="italics">Example 9.2</em> is about a simple class inheriting from another simple class, both of which have no behavior functions. The C version is as follows:</p>
			<pre>#include &lt;string.h&gt;
typedef struct {
  char c;
  char d;
} <strong class="highlight">a_t</strong>;
typedef struct {
  a_t parent;
  char str[5];
} <strong class="highlight">b_t</strong>;
int <strong class="highlight">main</strong>(int argc, char** argv) {
  b_t b;
  b.parent.c = 'A';
  b.parent.d = 'B';
  strcpy(b.str, "1234");
  // We need to set a break point at this line to see the memory layout.
  return 0;
}</pre>
			<p class="packt_figref">Code Box 9-5 [ExtremeC_examples_chapter9_2.c]: Inheritance example in C</p>
			<p class="normal">And the C++ version comes within the following code box:</p>
			<pre>#include &lt;string.h&gt;
class <strong class="highlight">A</strong> {
public:
  char c;
  char d;
};
class <strong class="highlight">B</strong> : public A {
public:
  char str[5];
};
int <strong class="highlight">main</strong>(int argc, char** argv) {
  B b;
  b.c = 'A';
  b.d = 'B';
  strcpy(b.str, "1234");
  // We need to set a break point at this line to see the memory layout.
  return 0;
}</pre>
			<p class="packt_figref">Code Box 9-6 [ExtremeC_examples_chapter9_2.cpp]: Inheritance example in C++</p>
			<p class="normal">Firstly, we need to <a id="_idIndexMarker640"/>compile the C program and use <code class="Code-In-Text--PACKT-">gdb</code> to set a<a id="_idIndexMarker641"/> breakpoint on the last line of the <code class="Code-In-Text--PACKT-">main</code> function. When the execution pauses, we can examine the memory layout as well as the existing values:</p>
			<pre><strong class="highlight">$ gcc -g ExtremeC_examples_chapter9_2.c -o ex9_2_c.out</strong>
<strong class="highlight">$ gdb ./ex9_2_c.out</strong>
...
<strong class="highlight">(gdb) b ExtremeC_examples_chapter9_2.c:19</strong>
Breakpoint 1 at 0x69e: file ExtremeC_examples_chapter9_2.c, line 19.
<strong class="highlight">(gdb) r</strong>
Starting program: .../ex9_2_c.out
Breakpoint 1, main (argc=1, argv=0x7fffffffe358) at ExtremeC_examples_chapter9_2.c:20
20    return 0;
<strong class="highlight">(gdb) x/7c &amp;b</strong>
0x7fffffffe261: 65 'A'  66 'B'  49 '1'  50 '2'  51 '3'  52 '4'  0 '\000'
<strong class="highlight">(qdb) c</strong>
[Inferior 1 (process 3759) exited normally]
<strong class="highlight">(qdb) q</strong>
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 9-4: Running the C version of example 9.2 in gdb</p>
			<p class="normal">As you can see, we<a id="_idIndexMarker642"/> have printed seven characters,<a id="_idIndexMarker643"/> starting from the address of <code class="Code-In-Text--PACKT-">b</code> object, which are as follows: <code class="Code-In-Text--PACKT-">'A'</code>, <code class="Code-In-Text--PACKT-">'B'</code>, <code class="Code-In-Text--PACKT-">'1'</code>, <code class="Code-In-Text--PACKT-">'2'</code>, <code class="Code-In-Text--PACKT-">'3'</code>, <code class="Code-In-Text--PACKT-">'4'</code>, <code class="Code-In-Text--PACKT-">'\0'</code>. Let's do the same for the C++ code:</p>
			<pre><strong class="highlight">$ g++ -g ExtremeC_examples_chapter9_2.cpp -o ex9_2_cpp.out</strong>
<strong class="highlight">$ gdb ./ex9_2_cpp.out</strong>
...
<strong class="highlight">(gdb) b ExtremeC_examples_chapter9_2.cpp:20</strong>
Breakpoint 1 at 0x69b: file ExtremeC_examples_chapter9_2.cpp, line 20.
<strong class="highlight">(gdb) r</strong>
Starting program: .../ex9_2_cpp.out
Breakpoint 1, main (argc=1, argv=0x7fffffffe358) at ExtremeC_examples_chapter9_2.cpp:21
21    return 0;
<strong class="highlight">(gdb) x/7c &amp;b</strong>
0x7fffffffe251: 65 'A'  66 'B'  49 '1'  50 '2'  51 '3'  52 '4'  0 '\000'
<strong class="highlight">(qdb) c</strong>
[Inferior 1 (process 3804) exited normally]
<strong class="highlight">(qdb) q</strong>
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 9-5: Running the C++ version of example 9.2 in gdb</p>
			<p class="normal">As you can see in the preceding two shell boxes, the memory layout and the values stored in the attributes are the same. You shouldn't get confused by having the behavior functions and attributes together in a class in C++; they are going to be treated separately from the class. In C++, the attributes, no matter where you put them in a class, are always collected within the same memory block regarding a specific object, and functions will always be independent of the attributes, just as we saw when looking at <em class="italics">implicit encapsulation</em> as part of <em class="italics">Chapter 6</em>, <em class="italics">OOP and Encapsulation</em>.</p>
			<p class="normal">The previous example demonstrates <em class="italics">single inheritance</em>. So, what about <em class="italics">multiple inheritance</em>? In the<a id="_idIndexMarker644"/> previous chapter, we explained why our first approach to implementing inheritance in C could not support multiple inheritance. We again demonstrate the reason in the following code box:</p>
			<pre>typedef struct { ... } <strong class="highlight">a_t</strong>;
typedef struct { ... } <strong class="highlight">b_t</strong>;
typedef struct {
  a_t a;
  b_t b;
  ...
} <strong class="highlight">c_t</strong>;
c_t c_obj;
a_t* a_ptr = (a_ptr*)&amp;c_obj;
b_t* b_ptr = (b_ptr*)&amp;c_obj;
c_t* c_ptr = &amp;c_obj;</pre>
			<p class="packt_figref">Code Box 9-7: Demonstration of why multiple inheritance cannot work with our proposed first approach for implementing inheritance in C</p>
			<p class="normal">In the preceding code<a id="_idIndexMarker645"/> box, the <code class="Code-In-Text--PACKT-">c_t</code> class desires to inherit both <code class="Code-In-Text--PACKT-">a_t</code> and <code class="Code-In-Text--PACKT-">b_t</code> classes. After declaring the classes, we create the <code class="Code-In-Text--PACKT-">c_obj</code> object. In the following lines of preceding code, we create different pointers.</p>
			<p class="normal">An important note here is that <em class="italics">all of these pointers must be pointing to the same address</em>. The <code class="Code-In-Text--PACKT-">a_ptr</code> and <code class="Code-In-Text--PACKT-">c_ptr</code> pointers can be used safely with any behavior function from the <code class="Code-In-Text--PACKT-">a_t</code> and <code class="Code-In-Text--PACKT-">c_t</code> classes, but the <code class="Code-In-Text--PACKT-">b_ptr</code> pointer is dangerous to use because it is pointing to the a field in the <code class="Code-In-Text--PACKT-">c_t</code> class, which is an <code class="Code-In-Text--PACKT-">a_t</code> object. Trying to access the fields inside <code class="Code-In-Text--PACKT-">b_t</code> through <code class="Code-In-Text--PACKT-">b_ptr</code> results in an undefined behavior.</p>
			<p class="normal">The following code is the correct version of the preceding code, where all pointers can be used safely:</p>
			<pre>c_t c_obj;
a_t* a_ptr = (a_ptr*)&amp;c_obj;
b_t* b_ptr = (b_ptr*)(&amp;c_obj + sizeof(a_t));
c_t* c_ptr = &amp;c_obj;</pre>
			<p class="packt_figref">Code Box 9-8: Demonstration of how casts should be updated to point to the correct fields</p>
			<p class="normal">As you can see on the third line in <em class="italics">Code Box 9-8</em>, we have added the size of an <code class="Code-In-Text--PACKT-">a_t</code> object to the address of <code class="Code-In-Text--PACKT-">c_obj</code>; this eventually results in a pointer pointing to the <code class="Code-In-Text--PACKT-">b</code> field in <code class="Code-In-Text--PACKT-">c_t</code>. Note that<a id="_idIndexMarker646"/> casting in C does not do any magic; it is there to convert types and it doesn't modify the transferring value, the memory address in the preceding case. Eventually, after the assignment, the address from the right-hand side would be copied to the left-hand side.</p>
			<p class="normal">For now, let's see the <a id="_idIndexMarker647"/>same example in C++ with a look at <em class="italics">example 9.3</em>. Suppose that we have a <code class="Code-In-Text--PACKT-">D</code> class that inherits from three different classes, <code class="Code-In-Text--PACKT-">A</code>, <code class="Code-In-Text--PACKT-">B</code>, and <code class="Code-In-Text--PACKT-">C</code>. The following is the code written for <em class="italics">example 9.3</em>:</p>
			<pre>#include &lt;string.h&gt;
class <strong class="highlight">A</strong> {
public:
  char a;
  char b[4];
};
class <strong class="highlight">B</strong> {
public:
  char c;
  char d;
};
class <strong class="highlight">C</strong> {
public:
  char e;
  char f;
};
class <strong class="highlight">D</strong> : public A, public B, public C {
public:
  char str[5];
};
int <strong class="highlight">main</strong>(int argc, char** argv) {
  D d;
  d.a = 'A';
  strcpy(d.b, "BBB");
  d.c = 'C';
  d.d = 'D';
  d.e = 'E';
  d.f = 'F';
  strcpy(d.str, "1234");
  A* ap = &amp;d;
  B* bp = &amp;d;
  C* cp = &amp;d;
  D* dp = &amp;d;
  // We need to set a break point at this line.
  return 0;
}</pre>
			<p class="packt_figref">Code Box 9-9 [ExtremeC_examples_chapter9_3.cpp]: Multiple inheritance in C++</p>
			<p class="normal">Let's compile the example and run it with <code class="Code-In-Text--PACKT-">gdb</code>:</p>
			<pre><strong class="highlight">$ g++ -g ExtremeC_examples_chapter9_3.cpp -o ex9_3.out</strong>
<strong class="highlight">$ gdb ./ex9_3.out</strong>
...
<strong class="highlight">(gdb) b ExtremeC_examples_chapter9_3.cpp:40</strong>
Breakpoint 1 at 0x100000f78: file ExtremeC_examples_chapter9_3.cpp, line 40.
<strong class="highlight">(gdb) r</strong>
Starting program: .../ex9_3.out
Breakpoint 1, main (argc=1, argv=0x7fffffffe358) at ExtremeC_examples_chapter9_3.cpp:41
41    return 0;
<strong class="highlight">(gdb) x/14c &amp;d</strong>
0x7fffffffe25a: 65 'A'  66 'B'  66 'B'  66 'B'  0 '\000'    67 'C'  68 'D'  69 'E'
0x7fffffffe262: 70 'F'  49 '1'  50 '2'  51 '3'  52 '4'  0 '\000'
<strong class="highlight">(gdb)</strong>
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 9-6: Compiling and running example 9.3 in gdb</p>
			<p class="normal">As you can see, the <a id="_idIndexMarker648"/>attributes are placed adjacent to<a id="_idIndexMarker649"/> each other. This shows that multiple objects of the parent classes are being kept inside the same memory layout of the <code class="Code-In-Text--PACKT-">d</code> object. What about the <code class="Code-In-Text--PACKT-">ap</code>, <code class="Code-In-Text--PACKT-">bp</code>, <code class="Code-In-Text--PACKT-">cp</code>, and <code class="Code-In-Text--PACKT-">dp</code> pointers? As you can see, in C++, we can cast implicitly when assigning a child pointer to a parent pointer (upcasting).</p>
			<p class="normal">Let's examine the values of these pointers in the current execution:</p>
			<pre><strong class="highlight">(gdb) print ap</strong>
$1 = (A *) 0x7fffffffe25a
<strong class="highlight">(gdb) print bp</strong>
$2 = (B *) 0x7fffffffe25f
<strong class="highlight">(gdb) print cp</strong>
$3 = (C *) 0x7fffffffe261
<strong class="highlight">(gdb) print dp</strong>
$4 = (D *) 0x7fffffffe25a
<strong class="highlight">(gdb)</strong></pre>
			<p class="packt_figref">Shell Box 9-7: Printing the addresses stored in the pointers as part of example 9.3</p>
			<p class="normal">The preceding shell<a id="_idIndexMarker650"/> box shows that the starting address of the d object, shown as <code class="Code-In-Text--PACKT-">$4</code>, is the same as the address being pointed to by ap, shown as <code class="Code-In-Text--PACKT-">$1</code>. So, this clearly shows that C++ puts an object of the type <em class="italics">A</em> as the first field in<a id="_idIndexMarker651"/> the corresponding attribute structure of the <em class="italics">D</em> class. Based on the addresses in the pointers and the result we got from the <code class="Code-In-Text--PACKT-">x</code> command, an object of the <em class="italics">B</em> type and then an object of the <em class="italics">C</em> type, are put into the same memory layout belonging to object <code class="Code-In-Text--PACKT-">d</code>.</p>
			<p class="normal">In addition, the preceding addresses show that the cast in C++ is not a passive operation, and it can perform some pointer arithmetic on the transferring address while converting the types. For example, in <em class="italics">Code Box 9-9</em>, while assigning the <code class="Code-In-Text--PACKT-">bp</code> pointer in the <code class="Code-In-Text--PACKT-">main</code> function, five bytes or <code class="Code-In-Text--PACKT-">sizeof(A)</code>, are added to the address of <code class="Code-In-Text--PACKT-">d</code>. This is done in order to overcome the problem we found in implementing multiple inheritance in C. Now, these pointers can easily be used in all behavior functions without needing to do the arithmetic yourself. As an important note, C casts and C++ casts are different, and you may see different behavior if you assume that C++ casts are as passive as C casts.</p>
			<p class="normal">Now it's time to look at the similarities between<a id="_idTextAnchor256"/> C and C++ in the case of polymorphism.</p>
			<h2 id="_idParaDest-137" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor257"/>Polymorphism</h2>
			<p class="normal">Comparing the <a id="_idIndexMarker652"/>underlying techniques for having<a id="_idIndexMarker653"/> polymorphism in C and C++ is not an easy task. In the previous chapter, we came up with a simple method for having a polymorphic behavior function in C, but C++ uses a much more sophisticated mechanism to bring about polymorphism, though the basic underlying idea is still the same. If we want to generalize our approach for implementing polymorphism in C, we can do it as the pseudo-code<a id="_idIndexMarker654"/> that can be seen in the following code box:</p>
			<pre>// Typedefing function pointer types
typedef void* (*<strong class="highlight">func_1_t</strong>)(void*, ...);
typedef void* (*<strong class="highlight">func_2_t</strong>)(void*, ...);
...
typedef void* (*<strong class="highlight">func_n_t</strong>)(void*, ...);
// Attribute structure of the parent class
typedef struct {
  // Attributes
  ...
  // Pointers to functions
  func_1_t func_1;
  func_2_t func_2;
  ...
  func_n_t func_t;
} <strong class="highlight">parent_t</strong>;
// Default private definitions for the
// virtual behavior functions
void* <strong class="highlight">__default_func_1</strong>(void* parent, ...) {  // Default definition }
void* <strong class="highlight">__default_func_2</strong>(void* parent, ...) {  // Default definition }
...
void* <strong class="highlight">__default_func_n</strong>(void* parent, ...) {  // Default definition }
// Constructor
void <strong class="highlight">parent_ctor</strong>(parent_t *parent) {
  // Initializing attributes
  ...
  // Setting default definitions for virtual
  // behavior functions
  parent-&gt;func_1 = __default_func_1;
  parent-&gt;func_2 = __default_func_2;
  ...
  parent-&gt;func_n = __default_func_n;
}
// Public and non-virtual behavior functions
void* <strong class="highlight">parent_non_virt_func_1</strong>(parent_t* parent, ...) { // Code }
void* <strong class="highlight">parent_non_virt_func_2</strong>(parent_t* parent, ...) { // Code }
...
void* <strong class="highlight">parent_non_virt_func_m</strong>(parent_t* parent, ...) { // Code }
// Actual public virtual behavior functions
void* <strong class="highlight">parent_func_1</strong>(parent_t* parent, ...) {
  return parent-&gt;func_1(parent, ...); 
}
void* <strong class="highlight">parent_func_2</strong>(parent_t* parent, ...) {
  return parent-&gt;func_2(parent, ...); 
}
...
void* <strong class="highlight">parent_func_n</strong>(parent_t* parent, ...) { 
  return parent-&gt;func_n(parent, ...); 
}</pre>
			<p class="packt_figref">Code Box 9-10: Pseudo-code demonstrating how virtual functions can be declared and defined in a C code</p>
			<p class="normal">As you can see<a id="_idIndexMarker655"/> in the preceding pseudo-code, the parent class has to maintain a list of function pointers in its attribute structure. These function<a id="_idIndexMarker656"/> pointers (in the parent class) either point to the default definitions for the virtual functions, or they are null. The pseudo-class defined as part of <em class="italics">Code Box 9-10</em> has <code class="Code-In-Text--PACKT-">m</code> non-virtual behavior functions and <code class="Code-In-Text--PACKT-">n</code> virtual behavior functions.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">Not all behavior functions are polymorphic. Polymorphic behavior functions are called virtual<a id="_idIndexMarker657"/> behavior functions or simply virtual functions. In some languages, such as Java, they are called <em class="italics">virtual methods</em>.</p>
				</div>
			</div>
			<p class="normal">Non-virtual functions are not polymorphic, and you never get various behaviors by calling them. In other words, a call to a non-virtual function is a simple function call and it just performs the logic inside the definition and doesn't relay the call to another function. However, virtual functions need to redirect the call to a proper function, set by either the parent or the child constructor. If a child class wants to override some of the inherited virtual <a id="_idIndexMarker658"/>functions, it should update the virtual function pointers.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">void*</code> type for the output variables can be replaced by any other pointer type. I used a generic pointer to show that anything can be returned from the functions in the pseudo-code.</p>
				</div>
			</div>
			<p class="normal">The following<a id="_idIndexMarker659"/> pseudo-code shows how a child class overrides a few of the virtual functions found in <em class="italics">Code Box 9-10</em>:</p>
			<pre>Include everything related to parent class ...
typedef struct {
  <strong class="highlight">parent_t parent;</strong>
  // Child attributes
  ...
} <strong class="highlight">child_t</strong>;
void* <strong class="highlight">__child_func_4</strong>(void* parent, ...) { // Overriding definition }
void* <strong class="highlight">__child_func_7</strong>(void* parent, ...) { // Overriding definition }
void <strong class="highlight">child_ctor</strong>(child_t* child) {
  parent_ctor((parent_t*)child);
  // Initialize child attributes
  ...
  // Update pointers to functions
  <strong class="highlight">child-&gt;parent.func_4 = __child_func_4;</strong>
  <strong class="highlight">child-&gt;parent.func_7 = __child_func_7;</strong>
}
// Child's behavior functions
...</pre>
			<p class="packt_figref">Code Box 9-11: Pseudo-code in C demonstrating how a child class can override some virtual functions inherited from the parent class</p>
			<p class="normal">As you can see in <em class="italics">Code Box 9-11</em>, the child class needs only to update a few pointers in the parent's attribute structure. C++ takes a similar approach. When you declare a behavior function as virtual (using the <code class="Code-In-Text--PACKT-">virtual</code> keyword), C++ creates an array of function pointers, pretty similar to the way we did in <em class="italics">Code Box 9-10</em>.</p>
			<p class="normal">As you can see, we added one function pointer attribute for each virtual function, but C++ has a smarter way<a id="_idIndexMarker660"/> of keeping these pointers. It just uses an array <a id="_idIndexMarker661"/>called a <em class="italics">virtual table</em> or <em class="italics">vtable</em>. The virtual table is created when an object is about to be created. It is first populated while calling the constructor of the base class, and then as part of the constructor of the child class, just as we've shown in <em class="italics">Code Boxes 9-10</em> and <em class="italics">9-11</em>.</p>
			<p class="normal">Since the virtual<a id="_idIndexMarker662"/> table is only populated in the constructors, calling a polymorphic method in a constructor, either in the parent or in the child class, should be avoided, as its pointer may have not been updated yet and it might be pointing to an incorrect definition.</p>
			<p class="normal">As our last discussion regarding the underlying mechanisms used for having various object-oriented concepts in <a id="_idTextAnchor258"/>C and C++, we are going to talk about abstraction.</p>
			<h2 id="_idParaDest-138" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor259"/>Abstract classes</h2>
			<p class="normal">Abstraction in C++ is <a id="_idIndexMarker663"/>possible using <em class="italics">pure virtual</em> functions. In<a id="_idIndexMarker664"/> C++ if you define a member function as a virtual function and set it to zero, you have declared a pure virtual function. Look at the following example:</p>
			<pre>enum class <strong class="highlight">Taste</strong> { Sweet, Sour };
// This is an interface
class <strong class="highlight">Eatable</strong> {
public:
  <strong class="highlight">virtual</strong> Taste GetTaste() = 0;
};</pre>
			<p class="packt_figref">Code Box 9-12: The Eatable interface in C++</p>
			<p class="normal">Inside the class <code class="Code-In-Text--PACKT-">Eatable</code>, we have a <code class="Code-In-Text--PACKT-">GetTaste</code> virtual function that is set to zero. <code class="Code-In-Text--PACKT-">GetTaste</code> is a pure virtual function and makes the whole class abstract. You can no longer create objects from the <em class="italics">Eatable</em> type, and C++ doesn't allow this. In addition, <em class="italics">Eatable</em> is an interface, because all of its member functions are purely virtual. This function can be overridden in a child class.</p>
			<p class="normal">The following shows a class that is overriding the <code class="Code-In-Text--PACKT-">GetTaste</code> function:</p>
			<pre>enum class <strong class="highlight">Taste</strong> { Sweet, Sour };
// This is an interface
class <strong class="highlight">Eatable</strong> {
public:
  virtual Taste GetTaste() = 0;
};
class <strong class="highlight">Apple : public Eatable</strong> {
public:
  Taste GetTaste() <strong class="highlight">override</strong> {
    return Taste::Sweet;
  }
};</pre>
			<p class="packt_figref">Code Box 9-13: Two child classes implementing the Eatable interface</p>
			<p class="normal">Pure virtual<a id="_idIndexMarker665"/> functions are remarkably similar to virtual functions. The addresses to the actual <a id="_idIndexMarker666"/>definitions are being kept in the virtual table in the same way as virtual functions, but with one difference. The initial values for the pointers of pure virtual functions are null, unlike the<a id="_idIndexMarker667"/> pointers of normal virtual functions, which need to point to a default definition while the construction is in progress.</p>
			<p class="normal">Unlike a C compiler, which doesn't know anything about abstract types, a C++ compiler is aware of abstract types and generates a compilation error if you try to create an object from an abstract type.</p>
			<p class="normal">In this section, we took various object-oriented concepts and compared them in C, using the techniques introduced in the past three chapters, and in C++, using the <code class="Code-In-Text--PACKT-">g++</code> compiler. We showed that, in most cases, the approaches we employed are in accordance with<a id="_idTextAnchor260"/> the techniques that a compiler like <code class="Code-In-Text--PACKT-">g++</code> uses.</p>
			<h1 id="_idParaDest-139" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor261"/>Summary</h1>
			<p class="normal">In this chapter, we concluded our exploration of topics in OOP, picking up from abstraction and moving on by showing the similarities between C and C++ regarding object-oriented concepts.</p>
			<p class="normal">The following topics were discussed as part of this chapter:</p>
			<ul>
				<li class="list">Abstract classes and interfaces were initially discussed. Using them, we can have an interface or a partially abstract class, which could be used to create concrete child classes with polymorphic and different behaviors.</li>
				<li class="list">We then compared the output of the techniques we used in C to bring in some OOP features, with the output of what <code class="Code-In-Text--PACKT-">g++</code> produces. This was to demonstrate how similar the results are. We concluded that the techniques that we employed can be very similar in their outcomes.</li>
				<li class="list">We discussed virtual tables in greater depth.</li>
				<li class="list">We showed how pure virtual functions (which is a C++ concept but does have a C counterpart) can be used to declare virtual behaviors that have no default definition.</li>
			</ul>
			<p class="normal">The next chapter is about Unix and its correspondence to C. It will review the history of Unix and the invention of C. It will also explain the layered architecture of a Unix system.</p>
		</div>
</body></html>