<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor095"/>4</h1>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor096"/>Creating an Online Chat</h1>
			<p>Welcome to the next chapter of our book on making online multiplayer games using Godot Engine 4.0!</p>
			<p>In the previous chapter, we saw how to make a lobby for players and its importance to gathering before entering a game. Now, we will take a step further and explore the development of an online chat using Godot’s Network API.</p>
			<p>As we saw, Godot’s Network API provides us with a robust set of tools for building real-time multiplayer games. In this chapter, we will use the <code>ENetMultiplayerPeer</code> class to establish a reliable connection between players, and some <strong class="bold">remote procedure call</strong> (<strong class="bold">RPC</strong>) methods to handle the chat system’s logic.</p>
			<p>As you may already know, a chat system is essential in any online multiplayer game, as it enables players to communicate with each other during gameplay. A well-designed chat system can greatly enhance the player experience, allowing for smoother coordination between team members and encouraging socialization among players.</p>
			<p>In this chapter, we’ll also explore the importance of using multiple communication channels in our network. We introduced this concept in the previous chapter, but now we are going to see how to actually use this feature in RPC methods so that our network is able to smoothly pass data around peers. By the end of the following step-by-step instructions, we will end up with the following:</p>
			<div><div><img alt="Figure 4.1 – The Chat screen with players exchanging messages" src="img/Figure_04.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Chat screen with players exchanging messages</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Understanding data exchange and channels</li>
				<li>Sending chat messages</li>
				<li>Updating peer’s data remotely</li>
			</ul>
			<h1 id="_idParaDest-63">T<a id="_idTextAnchor097"/>echnical requirements</h1>
			<p>Through this chapter, we are going to use the fourth folder of our Godot Engine project repository, available through the following link:</p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a></p>
			<p>After importing the project into your Godot Engine project manager, open it and navigate to the <code>res://04.creating-an-online-chat</code> folder. Then, open the <code>ChatControl.tscn</code> and <code>ChatControl.gd</code> files. They are going to be the focus of this chapter.</p>
			<p>Coming next in this chapter, we are going to learn the basic concepts of reliable and unreliable data exchange and how channels work so we have the ground set for our chat system.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor098"/>Understanding data exchange and channels</h1>
			<p>A chat system<a id="_idIndexMarker133"/> is essentially a chronological stack of messages that we order based on what players send to each other. Since this system needs a coherent chronological order, we need to understand how to prevent data from getting mixed and disorganized as it gets transmitted throughout the network. We also need to prevent this ordering from impacting other systems and components. To do that, we are going to learn how we can send packets reliably and how we can use multiple channels for data exchange.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor099"/>Reliable and unreliable packets</h2>
			<p>Godot Engine’s Network API<a id="_idIndexMarker134"/> allows for reliable and unreliable data exchange between peers. The <code>@rpc</code> annotation provides a way to transmit data securely between clients and the server using different transport protocols such as UDP and TCP. Reliable data exchange ensures that data is delivered in order and is not lost in transit, making it ideal for crucial data such as chat messages. Unreliable data exchange<a id="_idIndexMarker135"/> is faster and more efficient but offers no guarantee of order or delivery, making it ideal for non-critical data such as player position or real-time updates. In our chat system, we use the reliable <code>@rpc</code> option for chat messages to ensure that they are delivered in a timely manner without loss or duplication. Reliable data exchange<a id="_idIndexMarker136"/> ensures that players are able to follow the conversation and respond appropriately. Channels provide another layer of control over data exchange, allowing for better network optimization by prioritizing or separating data sent through different channels.</p>
			<p>In the upcoming section, let’s learn how channels work and what we can do with the<a id="_idTextAnchor100"/>m.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor101"/>Understanding channels</h2>
			<p>When<a id="_idIndexMarker137"/> developing multiplayer games in Godot Engine, understanding how communication channels work within the Network API is crucial for optimizing network performance and minimizing latency. In the context of Godot Engine’s Network API, communication channels are used to separate different types of data being exchanged between peers. For example, you may want to use one channel for game state updates, another channel for chat messages, and another channel for player movement data.</p>
			<p>The <code>@rpc</code> annotation in Godot<a id="_idIndexMarker138"/> Engine’s Network API provides an option to specify the channel that an RPC method should use for sending and receiving data. By default, all RPC methods use channel <code>0</code>. However, we can specify a different channel by passing an integer number as the last option in the <code>@rpc</code> annotation. For example, if you want to use a channel for game state updates, you can assign game state updates to channel <code>1</code> and chat messages to channel <code>2</code>.</p>
			<p>Using multiple channels in your Godot Engine multiplayer game can help improve network performance and minimize latency. By separating different types of data into separate channels, you can prioritize more important data and prevent congestion on a single channel.</p>
			<p>It’s worth noting that using multiple channels can also help prevent data loss and corruption in the event of packet loss or network congestion. By separating data into different channels, you can ensure that data loss or corruption on one channel doesn’t affect the other channels. This can help prevent issues such as desynchronization between peers or corrupted game data. We are going to talk about that in the next section.</p>
			<p>Remember, we are going to<a id="_idIndexMarker139"/> use reliable data exchange for our messages, so we can’t prevent players from updating other crucial information, such as their and others’ avatars’ positions, just because the data exchange channel is still waiting for a chat message to arrive. It’s wise to use another channel for that. Let’s see how this works.</p>
			<p>Open the <code>res://04.creating-an-online-chat/ChatControl.tscn</code> scene and you will notice it’s already structured with all the necessary nodes we need to make our chat system. So, we are going to focus on the script here. The following figure shows the <code>ChatControl</code> scene node hierarchy:</p>
			<div><div><img alt="Figure 4.2 – The ChatControl scene node hierarchy" src="img/Figure_04.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The ChatControl scene node hierarchy</p>
			<p>From there, open the <code>res://04.creating-an-online-chat/ChatControl.gd</code> file, and make the method responsible for adding messages to the chat:</p>
			<ol>
				<li>Create an <code>@rpc</code> annotation on top of the <code>add_message()</code> method. This RPC method should be available to any peer; it should also call itself locally. On top of that, it’ll be a reliable method. Finally, here, we are going to use a separate channel to exchange data, so let’s use channel <code>2</code>:<pre class="source-code">
@rpc("any_peer", "call_local", "reliable", 2)
func add_message(_avatar_name, message):
    pass</pre></li>				<li>Inside the <code>add_message()</code> method, create a new variable called <code>message_text</code> that’s going to use the <code>_avatar_name</code> String and the message arguments to create a text that uses two placeholders separated by a colon, like this:<pre class="source-code">
    var message_text = "%s: %s" % [_avatar_name,
        message]</pre></li>				<li>Then, concatenate the <code>label.text</code>String, skip a line, and then add the <code>message_text</code> String. This will add the latest message to the players’ visible chat:<pre class="source-code">
    label.text = label.text + "\n" + message_text</pre></li>				<li>Finally, to<a id="_idIndexMarker140"/> ensure the players’ chat is always showing the latest message, we update <code>container.scroll_vertical</code> to match the <code>label.size.y float</code>. This way, it will scroll to the bottom of the chat label, displaying the latest message:<pre class="source-code">
    container.scroll_vertical = label.size.y</pre><p class="list-inset">The complete <code>add_message()</code> method should look like this at this point:</p><pre class="source-code">@rpc("any_peer", "call_local", "reliable", 2)
func add_message(_avatar_name, message):
    var message_text = "%s: %s" % [_avatar_name,
        message]
    label.text = label.text + "\n" + message_text
    container.scroll_vertical = label.size.y</pre></li>			</ol>
			<p>With that, we can use a<a id="_idIndexMarker141"/> dedicated channel to transmit our players’ messages from one to another and display them in each player’s chat interface. Using an independent data transmission channel is as simple as adding an integer number as the last option of a function’s <code>@</code><code>rpc</code> annotation.</p>
			<p>In the next section, let’s learn how we can gather the player’s message and actually process it, sending it to other players throughout our peers’ ne<a id="_idTextAnchor102"/>twork.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor103"/>Sending chat messages</h1>
			<p>Godot Engine’s RPCs<a id="_idIndexMarker142"/> allow for efficient data transmission between clients and the server in multiplayer games. We can create an RPC method for this specific purpose, with message data as arguments. The transmission can be either reliable or unreliable, depending on the needs of the application. Once the message is sent, it’s received by the appropriate recipients (including clients and the server) who handle it appropriately, such as by displaying it to the user or logging it. We did that in the <em class="italic">Understanding data exchange and channels</em> section when we made the <code>add_message()</code> method.</p>
			<p>Sending messages using Godot’s RPCs is a straightforward process that involves defining the message format. In our case, we use the player’s avatar name and the message content, as seen previously, calling an RPC method to transmit the message and handling the message appropriately on the receiving end.</p>
			<p>We are going to implement a method to read the message that players input using the <code>LineEdit</code> node and send it to all peers on the network. For that, we are going to use the <code>LineEdit.text_submitted</code> signal connected to the <code>_on_line_edit_text_submitted()</code> callback method, as shown in the following image:</p>
			<div><div><img alt="Figure 4.3 – The LineEdit text_submitted signal connection" src="img/Figure_04.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The LineEdit text_submitted signal connection</p>
			<p>With the signal<a id="_idIndexMarker143"/> connected, open the script and let’s work on the <code>_on_line_edit_text_submitted()</code> method:</p>
			<ol>
				<li>The first thing we need to do is to prevent the processing of empty messages. For this, let’s return from the function if the <code>new_text</code> argument is an empty string:<pre class="source-code">
func _on_line_edit_text_submitted(new_text):
    if new_text == "":
        return</pre></li>				<li>Then, we can make an RPC to the <code>add_message()</code> method. This will call this method on all connected peers. We are going to pass the <code>ChatControl.avatar_name</code> String and the <code>new_text</code> String as arguments so the peers have the proper data to create their chat messages:<pre class="source-code">
    rpc("add_message", avatar_name, new_text)</pre></li>				<li>Finally, we clear the <code>line_edit.text</code> String to visually communicate that the game received the player’s message and is processing it:<pre class="source-code">
    line_edit.clear()</pre><p class="list-inset">The complete <code>_on_line_edit_text_submitted()</code> method should look like the following:</p><pre class="source-code">func _on_line_edit_text_submitted(new_text):
    if new_text == "":
        return
    rpc("add_message", avatar_name, new_text)
    line_edit.clear()</pre></li>			</ol>
			<p>With this method, any <a id="_idIndexMarker144"/>player in the game will be able to input a message and ask all peers, including themselves, to add a new message to their chat based on the <code>add_message()</code> logic we saw previously.</p>
			<p>Now, we need to understand how we are going to update each player about other players’ messages. In the next section, we will learn how to use RPCs on nodes other than the root node of a scene. With that, we will be able to make more concise scripts since we won’t bloat our classes with methods they won’t im<a id="_idTextAnchor104"/>plement.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor105"/>Updating peer’s data remotely</h1>
			<p>Something really<a id="_idIndexMarker145"/> cool about Godot Engine’s Network API is that we can abuse RPCs to pass data around. For instance, we’ve seen that we use the player’s avatar name in our messages. But have you asked yourself how we retrieve this data in any of these steps?</p>
			<p>You probably saw that there’s an RPC method called <code>set_avatar_name()</code>, right? Since its <code>@rpc</code> annotation doesn’t have any options, you can assume that it uses the default options. This is important to know because, as we saw previously, this means that it should be called remotely only by the <strong class="bold">Multiplayer Authority</strong> – in this <a id="_idIndexMarker146"/>case, the server.</p>
			<p>Let’s open <code>ChatServer.gd</code> to understand what’s happening behind the scenes. In essence, most of it is pretty much the same as in the <code>retrieve_avatar()</code> RPC method. In <em class="italic">line 39</em>, we have the following instruction:</p>
			<pre class="source-code">
var peer_id = multiplayer.get_remote_sender_id()</pre>			<p>We saw that this is a way to keep the sender of the latest RPC in memory so that we can refer back to it if necessary, and in this case, it will be necessary.</p>
			<p>In <em class="italic">line 45</em>, we make a <code>rpc_id()</code> call to the <code>set_avatar_name()</code> method on the peer that just requested its avatar’s data:</p>
			<pre class="source-code">
chat.rpc_id(peer_id, "set_avatar_name", database[user]
    ['name'])</pre>			<p>Note that there’s <a id="_idIndexMarker147"/>something else on top of that. We are calling this <code>rpc_id()</code> method from the <code>ChatControl</code> node, which is a child node of the <code>Main</code> root node.</p>
			<p>This is the server’s own <code>ChatControl</code> node. Since the server and client’s scene tree have the same <code>NodePath</code> to their <code>ChatControl</code> node, we can make this <code>rpc_id()</code> call on the server’s <code>ChatControl</code>node instead of making it from the <code>Main</code> node, and it will remotely call it on the player who requested their avatar’s data:</p>
			<div><div><img alt="Figure 4.﻿4– The ChatServer and ChatClient’s scene node hierarchies" src="img/Figure_04.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4– The ChatServer and ChatClient’s scene node hierarchies</p>
			<p>This is a good and<a id="_idIndexMarker148"/> simple way to prevent bloating a single class with many RPC methods because, remember, if a caller has an RPC method, all peers should have this method on their equivalent nodes at the same <code>NodePath</code>.</p>
			<p>It’s also a very effective way to remotely update nodes with new data. RPCs are really impressive and useful tools to have at our disposal when making online multiplayer games with Godot Engine.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor106"/>Summary</h1>
			<p>Throughout this chapter, we saw how we can use <code>RPC</code> methods to pass data around and perform actions on multiple peers of our network. We also understood the core difference between reliable and unreliable data exchange and saw some examples of situations of when to use each one. Due to this core difference in the way we can exchange data between the peers of our network, we also understood that one way may block the other, so we can use channels to prevent that one type of data from getting in the way of another type of data unrelated to that exchange.</p>
			<p>By creating an online lobby where players can chat, we saw how to use the <code>@rpc</code> annotation with some of its available options, including the option to allow other peers to make remote calls instead of only the Multiplayer Authority.</p>
			<p>In the next chapter, we will use the knowledge we’ve just acquired to build an actual real-time multiplayer experience. We’ll create a multiplayer online quiz where players will compete to see who can pick the correct answer the quickest. See you there!</p>
		</div>
	

		<div><h1 id="_idParaDest-70" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor107"/>Part 2:Creating Online Multiplayer Mechanics</h1>
		</div>
		<div><p>After understanding the tools we have available to create online multiplayer games, we put them into context by creating actual game prototypes. In this part, we learn how to turn single-player games into online multiplayer games, starting with a quiz game and ending with a prototype of an MMORPG game.</p>
			<p>This part contains the following chapters:</p>
			<ul>
				<li><a href="B18527_05.xhtml#_idTextAnchor108"><em class="italic">Chapter 5</em></a><em class="italic">,</em> <em class="italic">Making an Online Quiz Game</em></li>
				<li><a href="B18527_06.xhtml#_idTextAnchor131"><em class="italic">Chapter 6</em></a>, <em class="italic">Building an Online Checkers Game</em></li>
				<li><a href="B18527_07.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">Developing an Online Pong Game</em></li>
				<li><a href="B18527_08.xhtml#_idTextAnchor162"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Online Co-Op Platformer</em></li>
				<li><a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>