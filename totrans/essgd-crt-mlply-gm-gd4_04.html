<html><head></head><body>
		<div id="_idContainer041">
			<h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor095"/>4</h1>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor096"/>Creating an Online Chat</h1>
			<p>Welcome to the next chapter of our book on making online multiplayer games using Godot <span class="No-Break">Engine 4.0!</span></p>
			<p>In the previous chapter, we saw how to make a lobby for players and its importance to gathering before entering a game. Now, we will take a step further and explore the development of an online chat using Godot’s <span class="No-Break">Network API.</span></p>
			<p>As we saw, Godot’s Network API provides us with a robust set of tools for building real-time multiplayer games. In this chapter, we will use the <strong class="source-inline">ENetMultiplayerPeer</strong> class to establish a reliable connection between players, and some <strong class="bold">remote procedure call</strong> (<strong class="bold">RPC</strong>) methods to handle the chat <span class="No-Break">system’s logic.</span></p>
			<p>As you may already know, a chat system is essential in any online multiplayer game, as it enables players to communicate with each other during gameplay. A well-designed chat system can greatly enhance the player experience, allowing for smoother coordination between team members and encouraging socialization <span class="No-Break">among players.</span></p>
			<p>In this chapter, we’ll also explore the importance of using multiple communication channels in our network. We introduced this concept in the previous chapter, but now we are going to see how to actually use this feature in RPC methods so that our network is able to smoothly pass data around peers. By the end of the following step-by-step instructions, we will end up with <span class="No-Break">the following:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="Figure 4.1 – The Chat screen with players exchanging messages" src="image/Figure_04.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Chat screen with players exchanging messages</p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Understanding data exchange <span class="No-Break">and channels</span></li>
				<li>Sending <span class="No-Break">chat messages</span></li>
				<li>Updating peer’s <span class="No-Break">data remotely</span></li>
			</ul>
			<h1 id="_idParaDest-63">T<a id="_idTextAnchor097"/>echnical requirements</h1>
			<p>Through this chapter, we are going to use the fourth folder of our Godot Engine project repository, available through the <span class="No-Break">following link:</span></p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a></p>
			<p>After importing the project into your Godot Engine project manager, open it and navigate to the <strong class="source-inline">res://04.creating-an-online-chat</strong> folder. Then, open the <strong class="source-inline">ChatControl.tscn</strong> and <strong class="source-inline">ChatControl.gd</strong> files. They are going to be the focus of <span class="No-Break">this chapter.</span></p>
			<p>Coming next in this chapter, we are going to learn the basic concepts of reliable and unreliable data exchange and how channels work so we have the ground set for our <span class="No-Break">chat system.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor098"/>Understanding data exchange and channels</h1>
			<p>A chat system<a id="_idIndexMarker133"/> is essentially a chronological stack of messages that we order based on what players send to each other. Since this system needs a coherent chronological order, we need to understand how to prevent data from getting mixed and disorganized as it gets transmitted throughout the network. We also need to prevent this ordering from impacting other systems and components. To do that, we are going to learn how we can send packets reliably and how we can use multiple channels for <span class="No-Break">data exchange.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor099"/>Reliable and unreliable packets</h2>
			<p>Godot Engine’s Network API<a id="_idIndexMarker134"/> allows for reliable and unreliable data exchange between peers. The <strong class="source-inline">@rpc</strong> annotation provides a way to transmit data securely between clients and the server using different transport protocols such as UDP and TCP. Reliable data exchange ensures that data is delivered in order and is not lost in transit, making it ideal for crucial data such as chat messages. Unreliable data exchange<a id="_idIndexMarker135"/> is faster and more efficient but offers no guarantee of order or delivery, making it ideal for non-critical data such as player position or real-time updates. In our chat system, we use the reliable <strong class="source-inline">@rpc</strong> option for chat messages to ensure that they are delivered in a timely manner without loss or duplication. Reliable data exchange<a id="_idIndexMarker136"/> ensures that players are able to follow the conversation and respond appropriately. Channels provide another layer of control over data exchange, allowing for better network optimization by prioritizing or separating data sent through <span class="No-Break">different channels.</span></p>
			<p>In the upcoming section, let’s learn how channels work and what we can do <span class="No-Break">with the<a id="_idTextAnchor100"/>m.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor101"/>Understanding channels</h2>
			<p>When<a id="_idIndexMarker137"/> developing multiplayer games in Godot Engine, understanding how communication channels work within the Network API is crucial for optimizing network performance and minimizing latency. In the context of Godot Engine’s Network API, communication channels are used to separate different types of data being exchanged between peers. For example, you may want to use one channel for game state updates, another channel for chat messages, and another channel for player <span class="No-Break">movement data.</span></p>
			<p>The <strong class="source-inline">@rpc</strong> annotation in Godot<a id="_idIndexMarker138"/> Engine’s Network API provides an option to specify the channel that an RPC method should use for sending and receiving data. By default, all RPC methods use channel <strong class="source-inline">0</strong>. However, we can specify a different channel by passing an integer number as the last option in the <strong class="source-inline">@rpc</strong> annotation. For example, if you want to use a channel for game state updates, you can assign game state updates to channel <strong class="source-inline">1</strong> and chat messages to <span class="No-Break">channel </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<p>Using multiple channels in your Godot Engine multiplayer game can help improve network performance and minimize latency. By separating different types of data into separate channels, you can prioritize more important data and prevent congestion on a <span class="No-Break">single channel.</span></p>
			<p>It’s worth noting that using multiple channels can also help prevent data loss and corruption in the event of packet loss or network congestion. By separating data into different channels, you can ensure that data loss or corruption on one channel doesn’t affect the other channels. This can help prevent issues such as desynchronization between peers or corrupted game data. We are going to talk about that in the <span class="No-Break">next section.</span></p>
			<p>Remember, we are going to<a id="_idIndexMarker139"/> use reliable data exchange for our messages, so we can’t prevent players from updating other crucial information, such as their and others’ avatars’ positions, just because the data exchange channel is still waiting for a chat message to arrive. It’s wise to use another channel for that. Let’s see how <span class="No-Break">this works.</span></p>
			<p>Open the <strong class="source-inline">res://04.creating-an-online-chat/ChatControl.tscn</strong> scene and you will notice it’s already structured with all the necessary nodes we need to make our chat system. So, we are going to focus on the script here. The following figure shows the <strong class="source-inline">ChatControl</strong> scene <span class="No-Break">node hierarchy:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 4.2 – The ChatControl scene node hierarchy" src="image/Figure_04.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The ChatControl scene node hierarchy</p>
			<p>From there, open the <strong class="source-inline">res://04.creating-an-online-chat/ChatControl.gd</strong> file, and make the method responsible for adding messages to <span class="No-Break">the chat:</span></p>
			<ol>
				<li>Create an <strong class="source-inline">@rpc</strong> annotation on top of the <strong class="source-inline">add_message()</strong> method. This RPC method should be available to any peer; it should also call itself locally. On top of that, it’ll be a reliable method. Finally, here, we are going to use a separate channel to exchange data, so let’s use <span class="No-Break">channel </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc("any_peer", "call_local", "reliable", 2)
func add_message(_avatar_name, message):
    pass</pre></li>				<li>Inside the <strong class="source-inline">add_message()</strong> method, create a new variable called <strong class="source-inline">message_text</strong> that’s going to use the <strong class="source-inline">_avatar_name</strong> String and the message arguments to create a text that uses two placeholders separated by a colon, <span class="No-Break">like this:</span><pre class="source-code">
    var message_text = "%s: %s" % [_avatar_name,
        message]</pre></li>				<li>Then, concatenate the <strong class="source-inline">label.text</strong>String, skip a line, and then add the <strong class="source-inline">message_text</strong> String. This will add the latest message to the players’ <span class="No-Break">visible chat:</span><pre class="source-code">
    label.text = label.text + "\n" + message_text</pre></li>				<li>Finally, to<a id="_idIndexMarker140"/> ensure the players’ chat is always showing the latest message, we update <strong class="source-inline">container.scroll_vertical</strong> to match the <strong class="source-inline">label.size.y float</strong>. This way, it will scroll to the bottom of the chat label, displaying the <span class="No-Break">latest message:</span><pre class="source-code">
    container.scroll_vertical = label.size.y</pre><p class="list-inset">The complete <strong class="source-inline">add_message()</strong> method should look like this at <span class="No-Break">this point:</span></p><pre class="source-code">@rpc("any_peer", "call_local", "reliable", 2)
func add_message(_avatar_name, message):
    var message_text = "%s: %s" % [_avatar_name,
        message]
    label.text = label.text + "\n" + message_text
    container.scroll_vertical = label.size.y</pre></li>			</ol>
			<p>With that, we can use a<a id="_idIndexMarker141"/> dedicated channel to transmit our players’ messages from one to another and display them in each player’s chat interface. Using an independent data transmission channel is as simple as adding an integer number as the last option of a function’s <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">rpc</strong></span><span class="No-Break"> annotation.</span></p>
			<p>In the next section, let’s learn how we can gather the player’s message and actually process it, sending it to other players throughout our <span class="No-Break">peers’ ne<a id="_idTextAnchor102"/>twork.</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor103"/>Sending chat messages</h1>
			<p>Godot Engine’s RPCs<a id="_idIndexMarker142"/> allow for efficient data transmission between clients and the server in multiplayer games. We can create an RPC method for this specific purpose, with message data as arguments. The transmission can be either reliable or unreliable, depending on the needs of the application. Once the message is sent, it’s received by the appropriate recipients (including clients and the server) who handle it appropriately, such as by displaying it to the user or logging it. We did that in the <em class="italic">Understanding data exchange and channels</em> section when we made the <span class="No-Break"><strong class="source-inline">add_message()</strong></span><span class="No-Break"> method.</span></p>
			<p>Sending messages using Godot’s RPCs is a straightforward process that involves defining the message format. In our case, we use the player’s avatar name and the message content, as seen previously, calling an RPC method to transmit the message and handling the message appropriately on the <span class="No-Break">receiving end.</span></p>
			<p>We are going to implement a method to read the message that players input using the <strong class="source-inline">LineEdit</strong> node and send it to all peers on the network. For that, we are going to use the <strong class="source-inline">LineEdit.text_submitted</strong> signal connected to the <strong class="source-inline">_on_line_edit_text_submitted()</strong> callback method, as shown in the <span class="No-Break">following image:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Figure 4.3 – The LineEdit text_submitted signal connection" src="image/Figure_04.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The LineEdit text_submitted signal connection</p>
			<p>With the signal<a id="_idIndexMarker143"/> connected, open the script and let’s work on the <span class="No-Break"><strong class="source-inline">_on_line_edit_text_submitted()</strong></span><span class="No-Break"> method:</span></p>
			<ol>
				<li>The first thing we need to do is to prevent the processing of empty messages. For this, let’s return from the function if the <strong class="source-inline">new_text</strong> argument is an <span class="No-Break">empty string:</span><pre class="source-code">
func _on_line_edit_text_submitted(new_text):
    if new_text == "":
        return</pre></li>				<li>Then, we can make an RPC to the <strong class="source-inline">add_message()</strong> method. This will call this method on all connected peers. We are going to pass the <strong class="source-inline">ChatControl.avatar_name</strong> String and the <strong class="source-inline">new_text</strong> String as arguments so the peers have the proper data to create their <span class="No-Break">chat messages:</span><pre class="source-code">
    rpc("add_message", avatar_name, new_text)</pre></li>				<li>Finally, we clear the <strong class="source-inline">line_edit.text</strong> String to visually communicate that the game received the player’s message and is <span class="No-Break">processing it:</span><pre class="source-code">
    line_edit.clear()</pre><p class="list-inset">The complete <strong class="source-inline">_on_line_edit_text_submitted()</strong> method should look like <span class="No-Break">the following:</span></p><pre class="source-code">func _on_line_edit_text_submitted(new_text):
    if new_text == "":
        return
    rpc("add_message", avatar_name, new_text)
    line_edit.clear()</pre></li>			</ol>
			<p>With this method, any <a id="_idIndexMarker144"/>player in the game will be able to input a message and ask all peers, including themselves, to add a new message to their chat based on the <strong class="source-inline">add_message()</strong> logic we <span class="No-Break">saw previously.</span></p>
			<p>Now, we need to understand how we are going to update each player about other players’ messages. In the next section, we will learn how to use RPCs on nodes other than the root node of a scene. With that, we will be able to make more concise scripts since we won’t bloat our classes with methods they <span class="No-Break">won’t im<a id="_idTextAnchor104"/>plement.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor105"/>Updating peer’s data remotely</h1>
			<p>Something really<a id="_idIndexMarker145"/> cool about Godot Engine’s Network API is that we can abuse RPCs to pass data around. For instance, we’ve seen that we use the player’s avatar name in our messages. But have you asked yourself how we retrieve this data in any of <span class="No-Break">these steps?</span></p>
			<p>You probably saw that there’s an RPC method called <strong class="source-inline">set_avatar_name()</strong>, right? Since its <strong class="source-inline">@rpc</strong> annotation doesn’t have any options, you can assume that it uses the default options. This is important to know because, as we saw previously, this means that it should be called remotely only by the <strong class="bold">Multiplayer Authority</strong> – in this <a id="_idIndexMarker146"/>case, <span class="No-Break">the server.</span></p>
			<p>Let’s open <strong class="source-inline">ChatServer.gd</strong> to understand what’s happening behind the scenes. In essence, most of it is pretty much the same as in the <strong class="bold">Lobby</strong> project, but you will notice something slightly different in the <strong class="source-inline">retrieve_avatar()</strong> RPC method. In <em class="italic">line 39</em>, we have the <span class="No-Break">following instruction:</span></p>
			<pre class="source-code">
var peer_id = multiplayer.get_remote_sender_id()</pre>			<p>We saw that this is a way to keep the sender of the latest RPC in memory so that we can refer back to it if necessary, and in this case, it will <span class="No-Break">be necessary.</span></p>
			<p>In <em class="italic">line 45</em>, we make a <strong class="source-inline">rpc_id()</strong> call to the <strong class="source-inline">set_avatar_name()</strong> method on the peer that just requested its <span class="No-Break">avatar’s data:</span></p>
			<pre class="source-code">
chat.rpc_id(peer_id, "set_avatar_name", database[user]
    ['name'])</pre>			<p>Note that there’s <a id="_idIndexMarker147"/>something else on top of that. We are calling this <strong class="source-inline">rpc_id()</strong> method from the <strong class="source-inline">ChatControl</strong> node, which is a child node of the <strong class="source-inline">Main</strong> <span class="No-Break">root node.</span></p>
			<p>This is the server’s own <strong class="source-inline">ChatControl</strong> node. Since the server and client’s scene tree have the same <strong class="source-inline">NodePath</strong> to their <strong class="source-inline">ChatControl</strong> node, we can make this <strong class="source-inline">rpc_id()</strong> call on the server’s <strong class="source-inline">ChatControl</strong>node instead of making it from the <strong class="source-inline">Main</strong> node, and it will remotely call it on the player who requested their <span class="No-Break">avatar’s data:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure 4.﻿4– The ChatServer and ChatClient’s scene node hierarchies" src="image/Figure_04.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4– The ChatServer and ChatClient’s scene node hierarchies</p>
			<p>This is a good and<a id="_idIndexMarker148"/> simple way to prevent bloating a single class with many RPC methods because, remember, if a caller has an RPC method, all peers should have this method on their equivalent nodes at the <span class="No-Break">same </span><span class="No-Break"><strong class="source-inline">NodePath</strong></span><span class="No-Break">.</span></p>
			<p>It’s also a very effective way to remotely update nodes with new data. RPCs are really impressive and useful tools to have at our disposal when making online multiplayer games with <span class="No-Break">Godot Engine.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor106"/>Summary</h1>
			<p>Throughout this chapter, we saw how we can use <strong class="source-inline">RPC</strong> methods to pass data around and perform actions on multiple peers of our network. We also understood the core difference between reliable and unreliable data exchange and saw some examples of situations of when to use each one. Due to this core difference in the way we can exchange data between the peers of our network, we also understood that one way may block the other, so we can use channels to prevent that one type of data from getting in the way of another type of data unrelated to <span class="No-Break">that exchange.</span></p>
			<p>By creating an online lobby where players can chat, we saw how to use the <strong class="source-inline">@rpc</strong> annotation with some of its available options, including the option to allow other peers to make remote calls instead of only the <span class="No-Break">Multiplayer Authority.</span></p>
			<p>In the next chapter, we will use the knowledge we’ve just acquired to build an actual real-time multiplayer experience. We’ll create a multiplayer online quiz where players will compete to see who can pick the correct answer the quickest. See <span class="No-Break">you there!</span></p>
		</div>
	

		<div class="Content" id="_idContainer042">
			<h1 id="_idParaDest-70" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor107"/>Part 2:Creating Online Multiplayer Mechanics</h1>
		</div>
		<div class="Content" id="_idContainer043">
			<p>After understanding the tools we have available to create online multiplayer games, we put them into context by creating actual game prototypes. In this part, we learn how to turn single-player games into online multiplayer games, starting with a quiz game and ending with a prototype of an <span class="No-Break">MMORPG game.</span></p>
			<p>This part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18527_05.xhtml#_idTextAnchor108"><em class="italic">Chapter 5</em></a><em class="italic">,</em> <em class="italic">Making an Online Quiz Game</em></li>
				<li><a href="B18527_06.xhtml#_idTextAnchor131"><em class="italic">Chapter 6</em></a>, <em class="italic">Building an Online Checkers Game</em></li>
				<li><a href="B18527_07.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">Developing an Online Pong Game</em></li>
				<li><a href="B18527_08.xhtml#_idTextAnchor162"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Online Co-Op Platformer</em></li>
				<li><a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer044">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer045">
			</div>
		</div>
	</body></html>